{"buggy_code": ["#ifndef __SOUND_CORE_H\n#define __SOUND_CORE_H\n\n/*\n *  Main header file for the ALSA driver\n *  Copyright (c) 1994-2001 by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/device.h>\n#include <linux/sched.h>\t\t/* wake_up() */\n#include <linux/mutex.h>\t\t/* struct mutex */\n#include <linux/rwsem.h>\t\t/* struct rw_semaphore */\n#include <linux/pm.h>\t\t\t/* pm_message_t */\n#include <linux/stringify.h>\n#include <linux/printk.h>\n\n/* number of supported soundcards */\n#ifdef CONFIG_SND_DYNAMIC_MINORS\n#define SNDRV_CARDS CONFIG_SND_MAX_CARDS\n#else\n#define SNDRV_CARDS 8\t\t/* don't change - minor numbers */\n#endif\n\n#define CONFIG_SND_MAJOR\t116\t/* standard configuration */\n\n/* forward declarations */\nstruct pci_dev;\nstruct module;\nstruct completion;\n\n/* device allocation stuff */\n\n/* type of the object used in snd_device_*()\n * this also defines the calling order\n */\nenum snd_device_type {\n\tSNDRV_DEV_LOWLEVEL,\n\tSNDRV_DEV_CONTROL,\n\tSNDRV_DEV_INFO,\n\tSNDRV_DEV_BUS,\n\tSNDRV_DEV_CODEC,\n\tSNDRV_DEV_PCM,\n\tSNDRV_DEV_COMPRESS,\n\tSNDRV_DEV_RAWMIDI,\n\tSNDRV_DEV_TIMER,\n\tSNDRV_DEV_SEQUENCER,\n\tSNDRV_DEV_HWDEP,\n\tSNDRV_DEV_JACK,\n};\n\nenum snd_device_state {\n\tSNDRV_DEV_BUILD,\n\tSNDRV_DEV_REGISTERED,\n\tSNDRV_DEV_DISCONNECTED,\n};\n\nstruct snd_device;\n\nstruct snd_device_ops {\n\tint (*dev_free)(struct snd_device *dev);\n\tint (*dev_register)(struct snd_device *dev);\n\tint (*dev_disconnect)(struct snd_device *dev);\n};\n\nstruct snd_device {\n\tstruct list_head list;\t\t/* list of registered devices */\n\tstruct snd_card *card;\t\t/* card which holds this device */\n\tenum snd_device_state state;\t/* state of the device */\n\tenum snd_device_type type;\t/* device type */\n\tvoid *device_data;\t\t/* device structure */\n\tstruct snd_device_ops *ops;\t/* operations */\n};\n\n#define snd_device(n) list_entry(n, struct snd_device, list)\n\n/* main structure for soundcard */\n\nstruct snd_card {\n\tint number;\t\t\t/* number of soundcard (index to\n\t\t\t\t\t\t\t\tsnd_cards) */\n\n\tchar id[16];\t\t\t/* id string of this card */\n\tchar driver[16];\t\t/* driver name */\n\tchar shortname[32];\t\t/* short name of this soundcard */\n\tchar longname[80];\t\t/* name of this soundcard */\n\tchar mixername[80];\t\t/* mixer name */\n\tchar components[128];\t\t/* card components delimited with\n\t\t\t\t\t\t\t\tspace */\n\tstruct module *module;\t\t/* top-level module */\n\n\tvoid *private_data;\t\t/* private data for soundcard */\n\tvoid (*private_free) (struct snd_card *card); /* callback for freeing of\n\t\t\t\t\t\t\t\tprivate data */\n\tstruct list_head devices;\t/* devices */\n\n\tunsigned int last_numid;\t/* last used numeric ID */\n\tstruct rw_semaphore controls_rwsem;\t/* controls list lock */\n\trwlock_t ctl_files_rwlock;\t/* ctl_files list lock */\n\tint controls_count;\t\t/* count of all controls */\n\tint user_ctl_count;\t\t/* count of all user controls */\n\tstruct list_head controls;\t/* all controls for this card */\n\tstruct list_head ctl_files;\t/* active control files */\n\n\tstruct snd_info_entry *proc_root;\t/* root for soundcard specific files */\n\tstruct snd_info_entry *proc_id;\t/* the card id */\n\tstruct proc_dir_entry *proc_root_link;\t/* number link to real id */\n\n\tstruct list_head files_list;\t/* all files associated to this card */\n\tstruct snd_shutdown_f_ops *s_f_ops; /* file operations in the shutdown\n\t\t\t\t\t\t\t\tstate */\n\tspinlock_t files_lock;\t\t/* lock the files for this card */\n\tint shutdown;\t\t\t/* this card is going down */\n\tstruct completion *release_completion;\n\tstruct device *dev;\t\t/* device assigned to this card */\n\tstruct device card_dev;\t\t/* cardX object for sysfs */\n\tbool registered;\t\t/* card_dev is registered? */\n\n#ifdef CONFIG_PM\n\tunsigned int power_state;\t/* power state */\n\tstruct mutex power_lock;\t/* power lock */\n\twait_queue_head_t power_sleep;\n#endif\n\n#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)\n\tstruct snd_mixer_oss *mixer_oss;\n\tint mixer_oss_change_count;\n#endif\n};\n\n#define dev_to_snd_card(p)\tcontainer_of(p, struct snd_card, card_dev)\n\n#ifdef CONFIG_PM\nstatic inline void snd_power_lock(struct snd_card *card)\n{\n\tmutex_lock(&card->power_lock);\n}\n\nstatic inline void snd_power_unlock(struct snd_card *card)\n{\n\tmutex_unlock(&card->power_lock);\n}\n\nstatic inline unsigned int snd_power_get_state(struct snd_card *card)\n{\n\treturn card->power_state;\n}\n\nstatic inline void snd_power_change_state(struct snd_card *card, unsigned int state)\n{\n\tcard->power_state = state;\n\twake_up(&card->power_sleep);\n}\n\n/* init.c */\nint snd_power_wait(struct snd_card *card, unsigned int power_state);\n\n#else /* ! CONFIG_PM */\n\n#define snd_power_lock(card)\t\tdo { (void)(card); } while (0)\n#define snd_power_unlock(card)\t\tdo { (void)(card); } while (0)\nstatic inline int snd_power_wait(struct snd_card *card, unsigned int state) { return 0; }\n#define snd_power_get_state(card)\t({ (void)(card); SNDRV_CTL_POWER_D0; })\n#define snd_power_change_state(card, state)\tdo { (void)(card); } while (0)\n\n#endif /* CONFIG_PM */\n\nstruct snd_minor {\n\tint type;\t\t\t/* SNDRV_DEVICE_TYPE_XXX */\n\tint card;\t\t\t/* card number */\n\tint device;\t\t\t/* device number */\n\tconst struct file_operations *f_ops;\t/* file operations */\n\tvoid *private_data;\t\t/* private data for f_ops->open */\n\tstruct device *dev;\t\t/* device for sysfs */\n\tstruct snd_card *card_ptr;\t/* assigned card instance */\n};\n\n/* return a device pointer linked to each sound device as a parent */\nstatic inline struct device *snd_card_get_device_link(struct snd_card *card)\n{\n\treturn card ? &card->card_dev : NULL;\n}\n\n/* sound.c */\n\nextern int snd_major;\nextern int snd_ecards_limit;\nextern struct class *sound_class;\n\nvoid snd_request_card(int card);\n\nint snd_register_device_for_dev(int type, struct snd_card *card,\n\t\t\t\tint dev,\n\t\t\t\tconst struct file_operations *f_ops,\n\t\t\t\tvoid *private_data,\n\t\t\t\tconst char *name,\n\t\t\t\tstruct device *device);\n\n/**\n * snd_register_device - Register the ALSA device file for the card\n * @type: the device type, SNDRV_DEVICE_TYPE_XXX\n * @card: the card instance\n * @dev: the device index\n * @f_ops: the file operations\n * @private_data: user pointer for f_ops->open()\n * @name: the device file name\n *\n * Registers an ALSA device file for the given card.\n * The operators have to be set in reg parameter.\n *\n * This function uses the card's device pointer to link to the\n * correct &struct device.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nstatic inline int snd_register_device(int type, struct snd_card *card, int dev,\n\t\t\t\t      const struct file_operations *f_ops,\n\t\t\t\t      void *private_data,\n\t\t\t\t      const char *name)\n{\n\treturn snd_register_device_for_dev(type, card, dev, f_ops,\n\t\t\t\t\t   private_data, name,\n\t\t\t\t\t   snd_card_get_device_link(card));\n}\n\nint snd_unregister_device(int type, struct snd_card *card, int dev);\nvoid *snd_lookup_minor_data(unsigned int minor, int type);\nstruct device *snd_get_device(int type, struct snd_card *card, int dev);\n\n#ifdef CONFIG_SND_OSSEMUL\nint snd_register_oss_device(int type, struct snd_card *card, int dev,\n\t\t\t    const struct file_operations *f_ops, void *private_data);\nint snd_unregister_oss_device(int type, struct snd_card *card, int dev);\nvoid *snd_lookup_oss_minor_data(unsigned int minor, int type);\n#endif\n\nint snd_minor_info_init(void);\nint snd_minor_info_done(void);\n\n/* sound_oss.c */\n\n#ifdef CONFIG_SND_OSSEMUL\nint snd_minor_info_oss_init(void);\nint snd_minor_info_oss_done(void);\n#else\nstatic inline int snd_minor_info_oss_init(void) { return 0; }\nstatic inline int snd_minor_info_oss_done(void) { return 0; }\n#endif\n\n/* memory.c */\n\nint copy_to_user_fromio(void __user *dst, const volatile void __iomem *src, size_t count);\nint copy_from_user_toio(volatile void __iomem *dst, const void __user *src, size_t count);\n\n/* init.c */\n\nextern struct snd_card *snd_cards[SNDRV_CARDS];\nint snd_card_locked(int card);\n#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)\n#define SND_MIXER_OSS_NOTIFY_REGISTER\t0\n#define SND_MIXER_OSS_NOTIFY_DISCONNECT\t1\n#define SND_MIXER_OSS_NOTIFY_FREE\t2\nextern int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int cmd);\n#endif\n\nint snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t struct module *module, int extra_size,\n\t\t struct snd_card **card_ret);\n\nint snd_card_disconnect(struct snd_card *card);\nint snd_card_free(struct snd_card *card);\nint snd_card_free_when_closed(struct snd_card *card);\nvoid snd_card_set_id(struct snd_card *card, const char *id);\nint snd_card_register(struct snd_card *card);\nint snd_card_info_init(void);\nint snd_card_info_done(void);\nint snd_component_add(struct snd_card *card, const char *component);\nint snd_card_file_add(struct snd_card *card, struct file *file);\nint snd_card_file_remove(struct snd_card *card, struct file *file);\n#define snd_card_unref(card)\tput_device(&(card)->card_dev)\n\n#define snd_card_set_dev(card, devptr) ((card)->dev = (devptr))\n\n/* device.c */\n\nint snd_device_new(struct snd_card *card, enum snd_device_type type,\n\t\t   void *device_data, struct snd_device_ops *ops);\nint snd_device_register(struct snd_card *card, void *device_data);\nint snd_device_register_all(struct snd_card *card);\nint snd_device_disconnect_all(struct snd_card *card);\nvoid snd_device_free(struct snd_card *card, void *device_data);\nvoid snd_device_free_all(struct snd_card *card);\n\n/* isadma.c */\n\n#ifdef CONFIG_ISA_DMA_API\n#define DMA_MODE_NO_ENABLE\t0x0100\n\nvoid snd_dma_program(unsigned long dma, unsigned long addr, unsigned int size, unsigned short mode);\nvoid snd_dma_disable(unsigned long dma);\nunsigned int snd_dma_pointer(unsigned long dma, unsigned int size);\n#endif\n\n/* misc.c */\nstruct resource;\nvoid release_and_free_resource(struct resource *res);\n\n/* --- */\n\n/* sound printk debug levels */\nenum {\n\tSND_PR_ALWAYS,\n\tSND_PR_DEBUG,\n\tSND_PR_VERBOSE,\n};\n\n#if defined(CONFIG_SND_DEBUG) || defined(CONFIG_SND_VERBOSE_PRINTK)\n__printf(4, 5)\nvoid __snd_printk(unsigned int level, const char *file, int line,\n\t\t  const char *format, ...);\n#else\n#define __snd_printk(level, file, line, format, args...) \\\n\tprintk(format, ##args)\n#endif\n\n/**\n * snd_printk - printk wrapper\n * @fmt: format string\n *\n * Works like printk() but prints the file and the line of the caller\n * when configured with CONFIG_SND_VERBOSE_PRINTK.\n */\n#define snd_printk(fmt, args...) \\\n\t__snd_printk(0, __FILE__, __LINE__, fmt, ##args)\n\n#ifdef CONFIG_SND_DEBUG\n/**\n * snd_printd - debug printk\n * @fmt: format string\n *\n * Works like snd_printk() for debugging purposes.\n * Ignored when CONFIG_SND_DEBUG is not set.\n */\n#define snd_printd(fmt, args...) \\\n\t__snd_printk(1, __FILE__, __LINE__, fmt, ##args)\n#define _snd_printd(level, fmt, args...) \\\n\t__snd_printk(level, __FILE__, __LINE__, fmt, ##args)\n\n/**\n * snd_BUG - give a BUG warning message and stack trace\n *\n * Calls WARN() if CONFIG_SND_DEBUG is set.\n * Ignored when CONFIG_SND_DEBUG is not set.\n */\n#define snd_BUG()\t\tWARN(1, \"BUG?\\n\")\n\n/**\n * Suppress high rates of output when CONFIG_SND_DEBUG is enabled.\n */\n#define snd_printd_ratelimit() printk_ratelimit()\n\n/**\n * snd_BUG_ON - debugging check macro\n * @cond: condition to evaluate\n *\n * Has the same behavior as WARN_ON when CONFIG_SND_DEBUG is set,\n * otherwise just evaluates the conditional and returns the value.\n */\n#define snd_BUG_ON(cond)\tWARN_ON((cond))\n\n#else /* !CONFIG_SND_DEBUG */\n\n__printf(1, 2)\nstatic inline void snd_printd(const char *format, ...) {}\n__printf(2, 3)\nstatic inline void _snd_printd(int level, const char *format, ...) {}\n\n#define snd_BUG()\t\t\tdo { } while (0)\n\n#define snd_BUG_ON(condition) ({ \\\n\tint __ret_warn_on = !!(condition); \\\n\tunlikely(__ret_warn_on); \\\n})\n\nstatic inline bool snd_printd_ratelimit(void) { return false; }\n\n#endif /* CONFIG_SND_DEBUG */\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n/**\n * snd_printdd - debug printk\n * @format: format string\n *\n * Works like snd_printk() for debugging purposes.\n * Ignored when CONFIG_SND_DEBUG_VERBOSE is not set.\n */\n#define snd_printdd(format, args...) \\\n\t__snd_printk(2, __FILE__, __LINE__, format, ##args)\n#else\n__printf(1, 2)\nstatic inline void snd_printdd(const char *format, ...) {}\n#endif\n\n\n#define SNDRV_OSS_VERSION         ((3<<16)|(8<<8)|(1<<4)|(0))\t/* 3.8.1a */\n\n/* for easier backward-porting */\n#if defined(CONFIG_GAMEPORT) || defined(CONFIG_GAMEPORT_MODULE)\n#define gameport_set_dev_parent(gp,xdev) ((gp)->dev.parent = (xdev))\n#define gameport_set_port_data(gp,r) ((gp)->port_data = (r))\n#define gameport_get_port_data(gp) (gp)->port_data\n#endif\n\n/* PCI quirk list helper */\nstruct snd_pci_quirk {\n\tunsigned short subvendor;\t/* PCI subvendor ID */\n\tunsigned short subdevice;\t/* PCI subdevice ID */\n\tunsigned short subdevice_mask;\t/* bitmask to match */\n\tint value;\t\t\t/* value */\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tconst char *name;\t\t/* name of the device (optional) */\n#endif\n};\n\n#define _SND_PCI_QUIRK_ID_MASK(vend, mask, dev)\t\\\n\t.subvendor = (vend), .subdevice = (dev), .subdevice_mask = (mask)\n#define _SND_PCI_QUIRK_ID(vend, dev) \\\n\t_SND_PCI_QUIRK_ID_MASK(vend, 0xffff, dev)\n#define SND_PCI_QUIRK_ID(vend,dev) {_SND_PCI_QUIRK_ID(vend, dev)}\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n#define SND_PCI_QUIRK(vend,dev,xname,val) \\\n\t{_SND_PCI_QUIRK_ID(vend, dev), .value = (val), .name = (xname)}\n#define SND_PCI_QUIRK_VENDOR(vend, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, 0, 0), .value = (val), .name = (xname)}\n#define SND_PCI_QUIRK_MASK(vend, mask, dev, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, mask, dev),\t\t\t\\\n\t\t\t.value = (val), .name = (xname)}\n#define snd_pci_quirk_name(q)\t((q)->name)\n#else\n#define SND_PCI_QUIRK(vend,dev,xname,val) \\\n\t{_SND_PCI_QUIRK_ID(vend, dev), .value = (val)}\n#define SND_PCI_QUIRK_MASK(vend, mask, dev, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, mask, dev), .value = (val)}\n#define SND_PCI_QUIRK_VENDOR(vend, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, 0, 0), .value = (val)}\n#define snd_pci_quirk_name(q)\t\"\"\n#endif\n\n#ifdef CONFIG_PCI\nconst struct snd_pci_quirk *\nsnd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list);\n\nconst struct snd_pci_quirk *\nsnd_pci_quirk_lookup_id(u16 vendor, u16 device,\n\t\t\tconst struct snd_pci_quirk *list);\n#else\nstatic inline const struct snd_pci_quirk *\nsnd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list)\n{\n\treturn NULL;\n}\n\nstatic inline const struct snd_pci_quirk *\nsnd_pci_quirk_lookup_id(u16 vendor, u16 device,\n\t\t\tconst struct snd_pci_quirk *list)\n{\n\treturn NULL;\n}\n#endif\n\n#endif /* __SOUND_CORE_H */\n", "/*\n *  Routines for driver control interface\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/threads.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <sound/control.h>\n\n/* max number of user-defined controls */\n#define MAX_USER_CONTROLS\t32\n#define MAX_CONTROL_COUNT\t1028\n\nstruct snd_kctl_ioctl {\n\tstruct list_head list;\t\t/* list of all ioctls */\n\tsnd_kctl_ioctl_func_t fioctl;\n};\n\nstatic DECLARE_RWSEM(snd_ioctl_rwsem);\nstatic LIST_HEAD(snd_control_ioctls);\n#ifdef CONFIG_COMPAT\nstatic LIST_HEAD(snd_control_compat_ioctls);\n#endif\n\nstatic int snd_ctl_open(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard = snd_lookup_minor_data(iminor(inode), SNDRV_DEVICE_TYPE_CONTROL);\n\tif (!card) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\terr = snd_card_file_add(card, file);\n\tif (err < 0) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\tif (!try_module_get(card->module)) {\n\t\terr = -EFAULT;\n\t\tgoto __error2;\n\t}\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (ctl == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\tINIT_LIST_HEAD(&ctl->events);\n\tinit_waitqueue_head(&ctl->change_sleep);\n\tspin_lock_init(&ctl->read_lock);\n\tctl->card = card;\n\tctl->prefer_pcm_subdevice = -1;\n\tctl->prefer_rawmidi_subdevice = -1;\n\tctl->pid = get_pid(task_pid(current));\n\tfile->private_data = ctl;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_add_tail(&ctl->list, &card->ctl_files);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tsnd_card_unref(card);\n\treturn 0;\n\n      __error:\n\tmodule_put(card->module);\n      __error2:\n\tsnd_card_file_remove(card, file);\n      __error1:\n\tif (card)\n\t\tsnd_card_unref(card);\n      \treturn err;\n}\n\nstatic void snd_ctl_empty_read_queue(struct snd_ctl_file * ctl)\n{\n\tunsigned long flags;\n\tstruct snd_kctl_event *cread;\n\t\n\tspin_lock_irqsave(&ctl->read_lock, flags);\n\twhile (!list_empty(&ctl->events)) {\n\t\tcread = snd_kctl_event(ctl->events.next);\n\t\tlist_del(&cread->list);\n\t\tkfree(cread);\n\t}\n\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n}\n\nstatic int snd_ctl_release(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kcontrol *control;\n\tunsigned int idx;\n\n\tctl = file->private_data;\n\tfile->private_data = NULL;\n\tcard = ctl->card;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_del(&ctl->list);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tdown_write(&card->controls_rwsem);\n\tlist_for_each_entry(control, &card->controls, list)\n\t\tfor (idx = 0; idx < control->count; idx++)\n\t\t\tif (control->vd[idx].owner == ctl)\n\t\t\t\tcontrol->vd[idx].owner = NULL;\n\tup_write(&card->controls_rwsem);\n\tsnd_ctl_empty_read_queue(ctl);\n\tput_pid(ctl->pid);\n\tkfree(ctl);\n\tmodule_put(card->module);\n\tsnd_card_file_remove(card, file);\n\treturn 0;\n}\n\nvoid snd_ctl_notify(struct snd_card *card, unsigned int mask,\n\t\t    struct snd_ctl_elem_id *id)\n{\n\tunsigned long flags;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kctl_event *ev;\n\t\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn;\n\tread_lock(&card->ctl_files_rwlock);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tcard->mixer_oss_change_count++;\n#endif\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\tif (!ctl->subscribed)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&ctl->read_lock, flags);\n\t\tlist_for_each_entry(ev, &ctl->events, list) {\n\t\t\tif (ev->id.numid == id->numid) {\n\t\t\t\tev->mask |= mask;\n\t\t\t\tgoto _found;\n\t\t\t}\n\t\t}\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (ev) {\n\t\t\tev->id = *id;\n\t\t\tev->mask = mask;\n\t\t\tlist_add_tail(&ev->list, &ctl->events);\n\t\t} else {\n\t\t\tdev_err(card->dev, \"No memory available to allocate event\\n\");\n\t\t}\n\t_found:\n\t\twake_up(&ctl->change_sleep);\n\t\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n\t\tkill_fasync(&ctl->fasync, SIGIO, POLL_IN);\n\t}\n\tread_unlock(&card->ctl_files_rwlock);\n}\n\nEXPORT_SYMBOL(snd_ctl_notify);\n\n/**\n * snd_ctl_new - create a control instance from the template\n * @control: the control template\n * @access: the default control access\n *\n * Allocates a new struct snd_kcontrol instance and copies the given template \n * to the new instance. It does not copy volatile data (access).\n *\n * Return: The pointer of the new instance, or %NULL on failure.\n */\nstatic struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,\n\t\t\t\t\tunsigned int access)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\t\n\tif (snd_BUG_ON(!control || !control->count))\n\t\treturn NULL;\n\n\tif (control->count > MAX_CONTROL_COUNT)\n\t\treturn NULL;\n\n\tkctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);\n\tif (kctl == NULL) {\n\t\tpr_err(\"ALSA: Cannot allocate control instance\\n\");\n\t\treturn NULL;\n\t}\n\t*kctl = *control;\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tkctl->vd[idx].access = access;\n\treturn kctl;\n}\n\n/**\n * snd_ctl_new1 - create a control instance from the template\n * @ncontrol: the initialization record\n * @private_data: the private data to set\n *\n * Allocates a new struct snd_kcontrol instance and initialize from the given \n * template.  When the access field of ncontrol is 0, it's assumed as\n * READWRITE access. When the count field is 0, it's assumes as one.\n *\n * Return: The pointer of the newly generated instance, or %NULL on failure.\n */\nstruct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,\n\t\t\t\t  void *private_data)\n{\n\tstruct snd_kcontrol kctl;\n\tunsigned int access;\n\t\n\tif (snd_BUG_ON(!ncontrol || !ncontrol->info))\n\t\treturn NULL;\n\tmemset(&kctl, 0, sizeof(kctl));\n\tkctl.id.iface = ncontrol->iface;\n\tkctl.id.device = ncontrol->device;\n\tkctl.id.subdevice = ncontrol->subdevice;\n\tif (ncontrol->name) {\n\t\tstrlcpy(kctl.id.name, ncontrol->name, sizeof(kctl.id.name));\n\t\tif (strcmp(ncontrol->name, kctl.id.name) != 0)\n\t\t\tpr_warn(\"ALSA: Control name '%s' truncated to '%s'\\n\",\n\t\t\t\tncontrol->name, kctl.id.name);\n\t}\n\tkctl.id.index = ncontrol->index;\n\tkctl.count = ncontrol->count ? ncontrol->count : 1;\n\taccess = ncontrol->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t (ncontrol->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_VOLATILE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK));\n\tkctl.info = ncontrol->info;\n\tkctl.get = ncontrol->get;\n\tkctl.put = ncontrol->put;\n\tkctl.tlv.p = ncontrol->tlv.p;\n\tkctl.private_value = ncontrol->private_value;\n\tkctl.private_data = private_data;\n\treturn snd_ctl_new(&kctl, access);\n}\n\nEXPORT_SYMBOL(snd_ctl_new1);\n\n/**\n * snd_ctl_free_one - release the control instance\n * @kcontrol: the control instance\n *\n * Releases the control instance created via snd_ctl_new()\n * or snd_ctl_new1().\n * Don't call this after the control was added to the card.\n */\nvoid snd_ctl_free_one(struct snd_kcontrol *kcontrol)\n{\n\tif (kcontrol) {\n\t\tif (kcontrol->private_free)\n\t\t\tkcontrol->private_free(kcontrol);\n\t\tkfree(kcontrol);\n\t}\n}\n\nEXPORT_SYMBOL(snd_ctl_free_one);\n\nstatic bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int snd_ctl_find_hole(struct snd_card *card, unsigned int count)\n{\n\tunsigned int iter = 100000;\n\n\twhile (snd_ctl_remove_numid_conflict(card, count)) {\n\t\tif (--iter == 0) {\n\t\t\t/* this situation is very unlikely */\n\t\t\tdev_err(card->dev, \"unable to allocate new control numid\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * snd_ctl_add - add the control instance to the card\n * @card: the card instance\n * @kcontrol: the control instance to add\n *\n * Adds the control instance created via snd_ctl_new() or\n * snd_ctl_new1() to the given card. Assigns also an unique\n * numid used for fast search.\n *\n * It frees automatically the control which cannot be added.\n *\n * Return: Zero if successful, or a negative error code on failure.\n *\n */\nint snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_ctl_add);\n\n/**\n * snd_ctl_replace - replace the control instance of the card\n * @card: the card instance\n * @kcontrol: the control instance to replace\n * @add_on_replace: add the control if not already added\n *\n * Replaces the given control.  If the given control does not exist\n * and the add_on_replace flag is set, the control is added.  If the\n * control exists, it is destroyed first.\n *\n * It frees automatically the control which cannot be added or replaced.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,\n\t\t    bool add_on_replace)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tstruct snd_kcontrol *old;\n\tint ret;\n\n\tif (!kcontrol)\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!card || !kcontrol->info)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\told = snd_ctl_find_id(card, &id);\n\tif (!old) {\n\t\tif (add_on_replace)\n\t\t\tgoto add;\n\t\tup_write(&card->controls_rwsem);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tret = snd_ctl_remove(card, old);\n\tif (ret < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\tgoto error;\n\t}\nadd:\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\nerror:\n\tsnd_ctl_free_one(kcontrol);\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_ctl_replace);\n\n/**\n * snd_ctl_remove - remove the control from the card and release it\n * @card: the card instance\n * @kcontrol: the control instance to remove\n *\n * Removes the control from the card and then releases the instance.\n * You don't need to call snd_ctl_free_one(). You must be in\n * the write lock - down_write(&card->controls_rwsem).\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\n\tif (snd_BUG_ON(!card || !kcontrol))\n\t\treturn -EINVAL;\n\tlist_del(&kcontrol->list);\n\tcard->controls_count -= kcontrol->count;\n\tid = kcontrol->id;\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_REMOVE, &id);\n\tsnd_ctl_free_one(kcontrol);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_remove);\n\n/**\n * snd_ctl_remove_id - remove the control of the given id and release it\n * @card: the card instance\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove_id(struct snd_card *card, struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tret = snd_ctl_remove(card, kctl);\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(snd_ctl_remove_id);\n\n/**\n * snd_ctl_remove_user_ctl - remove and release the unlocked user control\n * @file: active control handle\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nstatic int snd_ctl_remove_user_ctl(struct snd_ctl_file * file,\n\t\t\t\t   struct snd_ctl_elem_id *id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol *kctl;\n\tint idx, ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\tif (!(kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_USER)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tif (kctl->vd[idx].owner != NULL && kctl->vd[idx].owner != file) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\tret = snd_ctl_remove(card, kctl);\n\tif (ret < 0)\n\t\tgoto error;\n\tcard->user_ctl_count--;\nerror:\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\n/**\n * snd_ctl_activate_id - activate/inactivate the control of the given id\n * @card: the card instance\n * @id: the control id to activate/inactivate\n * @active: non-zero to activate\n *\n * Finds the control instance with the given id, and activate or\n * inactivate the control together with notification, if changed.\n *\n * Return: 0 if unchanged, 1 if changed, or a negative error code on failure.\n */\nint snd_ctl_activate_id(struct snd_card *card, struct snd_ctl_elem_id *id,\n\t\t\tint active)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\tindex_offset = snd_ctl_get_ioff(kctl, &kctl->id);\n\tvd = &kctl->vd[index_offset];\n\tret = 0;\n\tif (active) {\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE))\n\t\t\tgoto unlock;\n\t\tvd->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t} else {\n\t\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE)\n\t\t\tgoto unlock;\n\t\tvd->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t}\n\tret = 1;\n unlock:\n\tup_write(&card->controls_rwsem);\n\tif (ret > 0)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO, id);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_activate_id);\n\n/**\n * snd_ctl_rename_id - replace the id of a control on the card\n * @card: the card instance\n * @src_id: the old id\n * @dst_id: the new id\n *\n * Finds the control with the old id from the card, and replaces the\n * id with the new one.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_rename_id(struct snd_card *card, struct snd_ctl_elem_id *src_id,\n\t\t      struct snd_ctl_elem_id *dst_id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, src_id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tkctl->id = *dst_id;\n\tkctl->id.numid = card->last_numid + 1;\n\tcard->last_numid += kctl->count;\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_rename_id);\n\n/**\n * snd_ctl_find_numid - find the control instance with the given number-id\n * @card: the card instance\n * @numid: the number-id to search\n *\n * Finds the control instance with the given number-id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !numid))\n\t\treturn NULL;\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)\n\t\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_ctl_find_numid);\n\n/**\n * snd_ctl_find_id - find the control instance with the given id\n * @card: the card instance\n * @id: the id to search\n *\n * Finds the control instance with the given id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_id(struct snd_card *card,\n\t\t\t\t     struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn NULL;\n\tif (id->numid != 0)\n\t\treturn snd_ctl_find_numid(card, id->numid);\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.iface != id->iface)\n\t\t\tcontinue;\n\t\tif (kctl->id.device != id->device)\n\t\t\tcontinue;\n\t\tif (kctl->id.subdevice != id->subdevice)\n\t\t\tcontinue;\n\t\tif (strncmp(kctl->id.name, id->name, sizeof(kctl->id.name)))\n\t\t\tcontinue;\n\t\tif (kctl->id.index > id->index)\n\t\t\tcontinue;\n\t\tif (kctl->id.index + kctl->count <= id->index)\n\t\t\tcontinue;\n\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_ctl_find_id);\n\nstatic int snd_ctl_card_info(struct snd_card *card, struct snd_ctl_file * ctl,\n\t\t\t     unsigned int cmd, void __user *arg)\n{\n\tstruct snd_ctl_card_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tdown_read(&snd_ioctl_rwsem);\n\tinfo->card = card->number;\n\tstrlcpy(info->id, card->id, sizeof(info->id));\n\tstrlcpy(info->driver, card->driver, sizeof(info->driver));\n\tstrlcpy(info->name, card->shortname, sizeof(info->name));\n\tstrlcpy(info->longname, card->longname, sizeof(info->longname));\n\tstrlcpy(info->mixername, card->mixername, sizeof(info->mixername));\n\tstrlcpy(info->components, card->components, sizeof(info->components));\n\tup_read(&snd_ioctl_rwsem);\n\tif (copy_to_user(arg, info, sizeof(struct snd_ctl_card_info))) {\n\t\tkfree(info);\n\t\treturn -EFAULT;\n\t}\n\tkfree(info);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_list(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_list __user *_list)\n{\n\tstruct list_head *plist;\n\tstruct snd_ctl_elem_list list;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_id *dst, *id;\n\tunsigned int offset, space, jidx;\n\t\n\tif (copy_from_user(&list, _list, sizeof(list)))\n\t\treturn -EFAULT;\n\toffset = list.offset;\n\tspace = list.space;\n\t/* try limit maximum space */\n\tif (space > 16384)\n\t\treturn -ENOMEM;\n\tif (space > 0) {\n\t\t/* allocate temporary buffer for atomic operation */\n\t\tdst = vmalloc(space * sizeof(struct snd_ctl_elem_id));\n\t\tif (dst == NULL)\n\t\t\treturn -ENOMEM;\n\t\tdown_read(&card->controls_rwsem);\n\t\tlist.count = card->controls_count;\n\t\tplist = card->controls.next;\n\t\twhile (plist != &card->controls) {\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t\tkctl = snd_kcontrol(plist);\n\t\t\tif (offset < kctl->count)\n\t\t\t\tbreak;\n\t\t\toffset -= kctl->count;\n\t\t\tplist = plist->next;\n\t\t}\n\t\tlist.used = 0;\n\t\tid = dst;\n\t\twhile (space > 0 && plist != &card->controls) {\n\t\t\tkctl = snd_kcontrol(plist);\n\t\t\tfor (jidx = offset; space > 0 && jidx < kctl->count; jidx++) {\n\t\t\t\tsnd_ctl_build_ioff(id, kctl, jidx);\n\t\t\t\tid++;\n\t\t\t\tspace--;\n\t\t\t\tlist.used++;\n\t\t\t}\n\t\t\tplist = plist->next;\n\t\t\toffset = 0;\n\t\t}\n\t\tup_read(&card->controls_rwsem);\n\t\tif (list.used > 0 &&\n\t\t    copy_to_user(list.pids, dst,\n\t\t\t\t list.used * sizeof(struct snd_ctl_elem_id))) {\n\t\t\tvfree(dst);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tvfree(dst);\n\t} else {\n\t\tdown_read(&card->controls_rwsem);\n\t\tlist.count = card->controls_count;\n\t\tup_read(&card->controls_rwsem);\n\t}\n\tif (copy_to_user(_list, &list, sizeof(list)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_info(struct snd_ctl_file *ctl,\n\t\t\t     struct snd_ctl_elem_info *info)\n{\n\tstruct snd_card *card = ctl->card;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\t\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &info->id);\n\tif (kctl == NULL) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n#ifdef CONFIG_SND_DEBUG\n\tinfo->access = 0;\n#endif\n\tresult = kctl->info(kctl, info);\n\tif (result >= 0) {\n\t\tsnd_BUG_ON(info->access);\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &info->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tsnd_ctl_build_ioff(&info->id, kctl, index_offset);\n\t\tinfo->access = vd->access;\n\t\tif (vd->owner) {\n\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_LOCK;\n\t\t\tif (vd->owner == ctl)\n\t\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_OWNER;\n\t\t\tinfo->owner = pid_vnr(vd->owner->pid);\n\t\t} else {\n\t\t\tinfo->owner = -1;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tsnd_power_lock(ctl->card);\n\tresult = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_info(ctl, &info);\n\tsnd_power_unlock(ctl->card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif ((vd->access & SNDRV_CTL_ELEM_ACCESS_READ) &&\n\t\t    kctl->get != NULL) {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->get(kctl, control);\n\t\t} else\n\t\t\tresult = -EPERM;\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_read(card, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &control->id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\t\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_unlock(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\t\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner == NULL)\n\t\t\tresult = -EINVAL;\n\t\telse if (vd->owner != file)\n\t\t\tresult = -EPERM;\n\t\telse {\n\t\t\tvd->owner = NULL;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstruct user_element {\n\tstruct snd_ctl_elem_info info;\n\tvoid *elem_data;\t\t/* element data */\n\tunsigned long elem_data_size;\t/* size of element data in bytes */\n\tvoid *tlv_data;\t\t\t/* TLV data */\n\tunsigned long tlv_data_size;\t/* TLV data size */\n\tvoid *priv_data;\t\t/* private data (like strings for enumerated type) */\n};\n\nstatic int snd_ctl_elem_user_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\t*uinfo = ue->info;\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tconst char *names;\n\tunsigned int item;\n\n\titem = uinfo->value.enumerated.item;\n\n\t*uinfo = ue->info;\n\n\titem = min(item, uinfo->value.enumerated.items - 1);\n\tuinfo->value.enumerated.item = item;\n\n\tnames = ue->priv_data;\n\tfor (; item > 0; --item)\n\t\tnames += strlen(names) + 1;\n\tstrcpy(uinfo->value.enumerated.name, names);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\t\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\treturn change;\n}\n\nstatic int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn change;\n}\n\nstatic int snd_ctl_elem_init_enum_names(struct user_element *ue)\n{\n\tchar *names, *p;\n\tsize_t buf_len, name_len;\n\tunsigned int i;\n\tconst uintptr_t user_ptrval = ue->info.value.enumerated.names_ptr;\n\n\tif (ue->info.value.enumerated.names_length > 64 * 1024)\n\t\treturn -EINVAL;\n\n\tnames = memdup_user((const void __user *)user_ptrval,\n\t\tue->info.value.enumerated.names_length);\n\tif (IS_ERR(names))\n\t\treturn PTR_ERR(names);\n\n\t/* check that there are enough valid names */\n\tbuf_len = ue->info.value.enumerated.names_length;\n\tp = names;\n\tfor (i = 0; i < ue->info.value.enumerated.items; ++i) {\n\t\tname_len = strnlen(p, buf_len);\n\t\tif (name_len == 0 || name_len >= 64 || name_len == buf_len) {\n\t\t\tkfree(names);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp += name_len + 1;\n\t\tbuf_len -= name_len + 1;\n\t}\n\n\tue->priv_data = names;\n\tue->info.value.enumerated.names_ptr = 0;\n\n\treturn 0;\n}\n\nstatic void snd_ctl_elem_user_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tkfree(ue->tlv_data);\n\tkfree(ue->priv_data);\n\tkfree(ue);\n}\n\nstatic int snd_ctl_elem_add(struct snd_ctl_file *file,\n\t\t\t    struct snd_ctl_elem_info *info, int replace)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol kctl, *_kctl;\n\tunsigned int access;\n\tlong private_size;\n\tstruct user_element *ue;\n\tint idx, err;\n\n\tif (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)\n\t\treturn -ENOMEM;\n\tif (info->count < 1)\n\t\treturn -EINVAL;\n\taccess = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));\n\tinfo->id.numid = 0;\n\tmemset(&kctl, 0, sizeof(kctl));\n\tdown_write(&card->controls_rwsem);\n\t_kctl = snd_ctl_find_id(card, &info->id);\n\terr = 0;\n\tif (_kctl) {\n\t\tif (replace)\n\t\t\terr = snd_ctl_remove(card, _kctl);\n\t\telse\n\t\t\terr = -EBUSY;\n\t} else {\n\t\tif (replace)\n\t\t\terr = -ENOENT;\n\t}\n\tup_write(&card->controls_rwsem);\n\tif (err < 0)\n\t\treturn err;\n\tmemcpy(&kctl.id, &info->id, sizeof(info->id));\n\tkctl.count = info->owner ? info->owner : 1;\n\taccess |= SNDRV_CTL_ELEM_ACCESS_USER;\n\tif (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)\n\t\tkctl.info = snd_ctl_elem_user_enum_info;\n\telse\n\t\tkctl.info = snd_ctl_elem_user_info;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_READ)\n\t\tkctl.get = snd_ctl_elem_user_get;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_WRITE)\n\t\tkctl.put = snd_ctl_elem_user_put;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {\n\t\tkctl.tlv.c = snd_ctl_elem_user_tlv;\n\t\taccess |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t}\n\tswitch (info->type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tprivate_size = sizeof(long);\n\t\tif (info->count > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tprivate_size = sizeof(long long);\n\t\tif (info->count > 64)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tprivate_size = sizeof(unsigned int);\n\t\tif (info->count > 128 || info->value.enumerated.items == 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_BYTES:\n\t\tprivate_size = sizeof(unsigned char);\n\t\tif (info->count > 512)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_IEC958:\n\t\tprivate_size = sizeof(struct snd_aes_iec958);\n\t\tif (info->count != 1)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tprivate_size *= info->count;\n\tue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);\n\tif (ue == NULL)\n\t\treturn -ENOMEM;\n\tue->info = *info;\n\tue->info.access = 0;\n\tue->elem_data = (char *)ue + sizeof(*ue);\n\tue->elem_data_size = private_size;\n\tif (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {\n\t\terr = snd_ctl_elem_init_enum_names(ue);\n\t\tif (err < 0) {\n\t\t\tkfree(ue);\n\t\t\treturn err;\n\t\t}\n\t}\n\tkctl.private_free = snd_ctl_elem_user_free;\n\t_kctl = snd_ctl_new(&kctl, access);\n\tif (_kctl == NULL) {\n\t\tkfree(ue->priv_data);\n\t\tkfree(ue);\n\t\treturn -ENOMEM;\n\t}\n\t_kctl->private_data = ue;\n\tfor (idx = 0; idx < _kctl->count; idx++)\n\t\t_kctl->vd[idx].owner = file;\n\terr = snd_ctl_add(card, _kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tdown_write(&card->controls_rwsem);\n\tcard->user_ctl_count++;\n\tup_write(&card->controls_rwsem);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_add_user(struct snd_ctl_file *file,\n\t\t\t\t struct snd_ctl_elem_info __user *_info, int replace)\n{\n\tstruct snd_ctl_elem_info info;\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_elem_add(file, &info, replace);\n}\n\nstatic int snd_ctl_elem_remove(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_ctl_elem_id id;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_remove_user_ctl(file, &id);\n}\n\nstatic int snd_ctl_subscribe_events(struct snd_ctl_file *file, int __user *ptr)\n{\n\tint subscribe;\n\tif (get_user(subscribe, ptr))\n\t\treturn -EFAULT;\n\tif (subscribe < 0) {\n\t\tsubscribe = file->subscribed;\n\t\tif (put_user(subscribe, ptr))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tif (subscribe) {\n\t\tfile->subscribed = 1;\n\t\treturn 0;\n\t} else if (file->subscribed) {\n\t\tsnd_ctl_empty_read_queue(file);\n\t\tfile->subscribed = 0;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,\n                             struct snd_ctl_tlv __user *_tlv,\n                             int op_flag)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_tlv tlv;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int len;\n\tint err = 0;\n\n\tif (copy_from_user(&tlv, _tlv, sizeof(tlv)))\n\t\treturn -EFAULT;\n\tif (tlv.length < sizeof(unsigned int) * 2)\n\t\treturn -EINVAL;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid(card, tlv.numid);\n\tif (kctl == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto __kctl_end;\n\t}\n\tif (kctl->tlv.p == NULL) {\n\t\terr = -ENXIO;\n\t\tgoto __kctl_end;\n\t}\n\tvd = &kctl->vd[tlv.numid - kctl->id.numid];\n\tif ((op_flag == 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) == 0) ||\n\t    (op_flag > 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) == 0) ||\n\t    (op_flag < 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) == 0)) {\n\t    \terr = -ENXIO;\n\t    \tgoto __kctl_end;\n\t}\n\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\tif (vd->owner != NULL && vd->owner != file) {\n\t\t\terr = -EPERM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\terr = kctl->tlv.c(kctl, op_flag, tlv.length, _tlv->tlv);\n\t\tif (err > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &kctl->id);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (op_flag) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tlen = kctl->tlv.p[1] + 2 * sizeof(unsigned int);\n\t\tif (tlv.length < len) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tif (copy_to_user(_tlv->tlv, kctl->tlv.p, len))\n\t\t\terr = -EFAULT;\n\t}\n      __kctl_end:\n\tup_read(&card->controls_rwsem);\n\treturn err;\n}\n\nstatic long snd_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_card *card;\n\tstruct snd_kctl_ioctl *p;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *ip = argp;\n\tint err;\n\n\tctl = file->private_data;\n\tcard = ctl->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_CTL_VERSION, ip) ? -EFAULT : 0;\n\tcase SNDRV_CTL_IOCTL_CARD_INFO:\n\t\treturn snd_ctl_card_info(card, ctl, cmd, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LIST:\n\t\treturn snd_ctl_elem_list(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_INFO:\n\t\treturn snd_ctl_elem_info_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_READ:\n\t\treturn snd_ctl_elem_read_user(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_WRITE:\n\t\treturn snd_ctl_elem_write_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LOCK:\n\t\treturn snd_ctl_elem_lock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_UNLOCK:\n\t\treturn snd_ctl_elem_unlock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_ADD:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_ELEM_REPLACE:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_ELEM_REMOVE:\n\t\treturn snd_ctl_elem_remove(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:\n\t\treturn snd_ctl_subscribe_events(ctl, ip);\n\tcase SNDRV_CTL_IOCTL_TLV_READ:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_TLV_WRITE:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_TLV_COMMAND:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, -1);\n\tcase SNDRV_CTL_IOCTL_POWER:\n\t\treturn -ENOPROTOOPT;\n\tcase SNDRV_CTL_IOCTL_POWER_STATE:\n#ifdef CONFIG_PM\n\t\treturn put_user(card->power_state, ip) ? -EFAULT : 0;\n#else\n\t\treturn put_user(SNDRV_CTL_POWER_D0, ip) ? -EFAULT : 0;\n#endif\n\t}\n\tdown_read(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, &snd_control_ioctls, list) {\n\t\terr = p->fioctl(card, ctl, cmd, arg);\n\t\tif (err != -ENOIOCTLCMD) {\n\t\t\tup_read(&snd_ioctl_rwsem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tup_read(&snd_ioctl_rwsem);\n\tdev_dbg(card->dev, \"unknown ioctl = 0x%x\\n\", cmd);\n\treturn -ENOTTY;\n}\n\nstatic ssize_t snd_ctl_read(struct file *file, char __user *buffer,\n\t\t\t    size_t count, loff_t * offset)\n{\n\tstruct snd_ctl_file *ctl;\n\tint err = 0;\n\tssize_t result = 0;\n\n\tctl = file->private_data;\n\tif (snd_BUG_ON(!ctl || !ctl->card))\n\t\treturn -ENXIO;\n\tif (!ctl->subscribed)\n\t\treturn -EBADFD;\n\tif (count < sizeof(struct snd_ctl_event))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctl->read_lock);\n\twhile (count >= sizeof(struct snd_ctl_event)) {\n\t\tstruct snd_ctl_event ev;\n\t\tstruct snd_kctl_event *kev;\n\t\twhile (list_empty(&ctl->events)) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto __end_lock;\n\t\t\t}\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ctl->read_lock);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tif (ctl->card->shutdown)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tspin_lock_irq(&ctl->read_lock);\n\t\t}\n\t\tkev = snd_kctl_event(ctl->events.next);\n\t\tev.type = SNDRV_CTL_EVENT_ELEM;\n\t\tev.data.elem.mask = kev->mask;\n\t\tev.data.elem.id = kev->id;\n\t\tlist_del(&kev->list);\n\t\tspin_unlock_irq(&ctl->read_lock);\n\t\tkfree(kev);\n\t\tif (copy_to_user(buffer, &ev, sizeof(struct snd_ctl_event))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __end;\n\t\t}\n\t\tspin_lock_irq(&ctl->read_lock);\n\t\tbuffer += sizeof(struct snd_ctl_event);\n\t\tcount -= sizeof(struct snd_ctl_event);\n\t\tresult += sizeof(struct snd_ctl_event);\n\t}\n      __end_lock:\n\tspin_unlock_irq(&ctl->read_lock);\n      __end:\n      \treturn result > 0 ? result : err;\n}\n\nstatic unsigned int snd_ctl_poll(struct file *file, poll_table * wait)\n{\n\tunsigned int mask;\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\tif (!ctl->subscribed)\n\t\treturn 0;\n\tpoll_wait(file, &ctl->change_sleep, wait);\n\n\tmask = 0;\n\tif (!list_empty(&ctl->events))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\treturn mask;\n}\n\n/*\n * register the device-specific control-ioctls.\n * called from each device manager like pcm.c, hwdep.c, etc.\n */\nstatic int _snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn, struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *pn;\n\n\tpn = kzalloc(sizeof(struct snd_kctl_ioctl), GFP_KERNEL);\n\tif (pn == NULL)\n\t\treturn -ENOMEM;\n\tpn->fioctl = fcn;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_add_tail(&pn->list, lists);\n\tup_write(&snd_ioctl_rwsem);\n\treturn 0;\n}\n\nint snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_register_ioctl);\n\n#ifdef CONFIG_COMPAT\nint snd_ctl_register_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_compat_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_register_ioctl_compat);\n#endif\n\n/*\n * de-register the device-specific control-ioctls.\n */\nstatic int _snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn,\n\t\t\t\t     struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *p;\n\n\tif (snd_BUG_ON(!fcn))\n\t\treturn -EINVAL;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, lists, list) {\n\t\tif (p->fioctl == fcn) {\n\t\t\tlist_del(&p->list);\n\t\t\tup_write(&snd_ioctl_rwsem);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_write(&snd_ioctl_rwsem);\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\nint snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl);\n\n#ifdef CONFIG_COMPAT\nint snd_ctl_unregister_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_compat_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);\n#endif\n\nstatic int snd_ctl_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\treturn fasync_helper(fd, file, on, &ctl->fasync);\n}\n\n/*\n * ioctl32 compat\n */\n#ifdef CONFIG_COMPAT\n#include \"control_compat.c\"\n#else\n#define snd_ctl_ioctl_compat\tNULL\n#endif\n\n/*\n *  INIT PART\n */\n\nstatic const struct file_operations snd_ctl_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_ctl_read,\n\t.open =\t\tsnd_ctl_open,\n\t.release =\tsnd_ctl_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_ctl_poll,\n\t.unlocked_ioctl =\tsnd_ctl_ioctl,\n\t.compat_ioctl =\tsnd_ctl_ioctl_compat,\n\t.fasync =\tsnd_ctl_fasync,\n};\n\n/*\n * registration of the control device\n */\nstatic int snd_ctl_dev_register(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tint err, cardnum;\n\tchar name[16];\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\tsprintf(name, \"controlC%i\", cardnum);\n\tif ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,\n\t\t\t\t       &snd_ctl_f_ops, card, name)) < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n/*\n * disconnection of the control device\n */\nstatic int snd_ctl_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_ctl_file *ctl;\n\tint err, cardnum;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\n\tread_lock(&card->ctl_files_rwlock);\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\twake_up(&ctl->change_sleep);\n\t\tkill_fasync(&ctl->fasync, SIGIO, POLL_ERR);\n\t}\n\tread_unlock(&card->ctl_files_rwlock);\n\n\tif ((err = snd_unregister_device(SNDRV_DEVICE_TYPE_CONTROL,\n\t\t\t\t\t card, -1)) < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n/*\n * free all controls\n */\nstatic int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\tsnd_ctl_remove(card, control);\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\n\n/*\n * create control core:\n * called from init.c\n */\nint snd_ctl_create(struct snd_card *card)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\treturn snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n}\n\n/*\n * Frequently used control callbacks/helpers\n */\nint snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_boolean_mono_info);\n\nint snd_ctl_boolean_stereo_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_boolean_stereo_info);\n\n/**\n * snd_ctl_enum_info - fills the info structure for an enumerated control\n * @info: the structure to be filled\n * @channels: the number of the control's channels; often one\n * @items: the number of control values; also the size of @names\n * @names: an array containing the names of all control values\n *\n * Sets all required fields in @info to their appropriate values.\n * If the control's accessibility is not the default (readable and writable),\n * the caller has to fill @info->access.\n *\n * Return: Zero.\n */\nint snd_ctl_enum_info(struct snd_ctl_elem_info *info, unsigned int channels,\n\t\t      unsigned int items, const char *const names[])\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tinfo->count = channels;\n\tinfo->value.enumerated.items = items;\n\tif (info->value.enumerated.item >= items)\n\t\tinfo->value.enumerated.item = items - 1;\n\tstrlcpy(info->value.enumerated.name,\n\t\tnames[info->value.enumerated.item],\n\t\tsizeof(info->value.enumerated.name));\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_enum_info);\n", "/*\n *  Initialization routines\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/pm.h>\n#include <linux/completion.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n\n/* monitor files for graceful shutdown (hotplug) */\nstruct snd_monitor_file {\n\tstruct file *file;\n\tconst struct file_operations *disconnected_f_op;\n\tstruct list_head shutdown_list;\t/* still need to shutdown */\n\tstruct list_head list;\t/* link of monitor files */\n};\n\nstatic DEFINE_SPINLOCK(shutdown_lock);\nstatic LIST_HEAD(shutdown_files);\n\nstatic const struct file_operations snd_shutdown_f_ops;\n\n/* locked for registering/using */\nstatic DECLARE_BITMAP(snd_cards_lock, SNDRV_CARDS);\nstruct snd_card *snd_cards[SNDRV_CARDS];\nEXPORT_SYMBOL(snd_cards);\n\nstatic DEFINE_MUTEX(snd_card_mutex);\n\nstatic char *slots[SNDRV_CARDS];\nmodule_param_array(slots, charp, NULL, 0444);\nMODULE_PARM_DESC(slots, \"Module names assigned to the slots.\");\n\n/* return non-zero if the given index is reserved for the given\n * module via slots option\n */\nstatic int module_slot_match(struct module *module, int idx)\n{\n\tint match = 1;\n#ifdef MODULE\n\tconst char *s1, *s2;\n\n\tif (!module || !*module->name || !slots[idx])\n\t\treturn 0;\n\n\ts1 = module->name;\n\ts2 = slots[idx];\n\tif (*s2 == '!') {\n\t\tmatch = 0; /* negative match */\n\t\ts2++;\n\t}\n\t/* compare module name strings\n\t * hyphens are handled as equivalent with underscore\n\t */\n\tfor (;;) {\n\t\tchar c1 = *s1++;\n\t\tchar c2 = *s2++;\n\t\tif (c1 == '-')\n\t\t\tc1 = '_';\n\t\tif (c2 == '-')\n\t\t\tc2 = '_';\n\t\tif (c1 != c2)\n\t\t\treturn !match;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n#endif /* MODULE */\n\treturn match;\n}\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\nint (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);\nEXPORT_SYMBOL(snd_mixer_oss_notify_callback);\n#endif\n\n#ifdef CONFIG_PROC_FS\nstatic void snd_card_id_read(struct snd_info_entry *entry,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tsnd_iprintf(buffer, \"%s\\n\", entry->card->id);\n}\n\nstatic inline int init_info_for_card(struct snd_card *card)\n{\n\tint err;\n\tstruct snd_info_entry *entry;\n\n\tif ((err = snd_info_card_register(card)) < 0) {\n\t\tdev_dbg(card->dev, \"unable to create card info\\n\");\n\t\treturn err;\n\t}\n\tif ((entry = snd_info_create_card_entry(card, \"id\", card->proc_root)) == NULL) {\n\t\tdev_dbg(card->dev, \"unable to create card entry\\n\");\n\t\treturn err;\n\t}\n\tentry->c.text.read = snd_card_id_read;\n\tif (snd_info_register(entry) < 0) {\n\t\tsnd_info_free_entry(entry);\n\t\tentry = NULL;\n\t}\n\tcard->proc_id = entry;\n\treturn 0;\n}\n#else /* !CONFIG_PROC_FS */\n#define init_info_for_card(card)\n#endif\n\nstatic int check_empty_slot(struct module *module, int slot)\n{\n\treturn !slots[slot] || !*slots[slot];\n}\n\n/* return an empty slot number (>= 0) found in the given bitmask @mask.\n * @mask == -1 == 0xffffffff means: take any free slot up to 32\n * when no slot is available, return the original @mask as is.\n */\nstatic int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),\n\t\t\t\t struct module *module)\n{\n\tint slot;\n\n\tfor (slot = 0; slot < SNDRV_CARDS; slot++) {\n\t\tif (slot < 32 && !(mask & (1U << slot)))\n\t\t\tcontinue;\n\t\tif (!test_bit(slot, snd_cards_lock)) {\n\t\t\tif (check(module, slot))\n\t\t\t\treturn slot; /* found */\n\t\t}\n\t}\n\treturn mask; /* unchanged */\n}\n\nstatic int snd_card_do_free(struct snd_card *card);\nstatic const struct attribute_group *card_dev_attr_groups[];\n\nstatic void release_card_device(struct device *dev)\n{\n\tsnd_card_do_free(dev_to_snd_card(dev));\n}\n\n/**\n *  snd_card_new - create and initialize a soundcard structure\n *  @parent: the parent device object\n *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]\n *  @xid: card identification (ASCII string)\n *  @module: top level module for locking\n *  @extra_size: allocate this extra size after the main soundcard structure\n *  @card_ret: the pointer to store the created card instance\n *\n *  Creates and initializes a soundcard structure.\n *\n *  The function allocates snd_card instance via kzalloc with the given\n *  space for the driver to use freely.  The allocated struct is stored\n *  in the given card_ret pointer.\n *\n *  Return: Zero if successful or a negative error code.\n */\nint snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t    struct module *module, int extra_size,\n\t\t    struct snd_card **card_ret)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (snd_BUG_ON(!card_ret))\n\t\treturn -EINVAL;\n\t*card_ret = NULL;\n\n\tif (extra_size < 0)\n\t\textra_size = 0;\n\tcard = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tif (extra_size > 0)\n\t\tcard->private_data = (char *)card + sizeof(struct snd_card);\n\tif (xid)\n\t\tstrlcpy(card->id, xid, sizeof(card->id));\n\terr = 0;\n\tmutex_lock(&snd_card_mutex);\n\tif (idx < 0) /* first check the matching module-name slot */\n\t\tidx = get_slot_from_bitmask(idx, module_slot_match, module);\n\tif (idx < 0) /* if not matched, assign an empty slot */\n\t\tidx = get_slot_from_bitmask(idx, check_empty_slot, module);\n\tif (idx < 0)\n\t\terr = -ENODEV;\n\telse if (idx < snd_ecards_limit) {\n\t\tif (test_bit(idx, snd_cards_lock))\n\t\t\terr = -EBUSY;\t/* invalid */\n\t} else if (idx >= SNDRV_CARDS)\n\t\terr = -ENODEV;\n\tif (err < 0) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\tdev_err(parent, \"cannot find the slot for index %d (range 0-%i), error: %d\\n\",\n\t\t\t idx, snd_ecards_limit - 1, err);\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\tset_bit(idx, snd_cards_lock);\t\t/* lock it */\n\tif (idx >= snd_ecards_limit)\n\t\tsnd_ecards_limit = idx + 1; /* increase the limit */\n\tmutex_unlock(&snd_card_mutex);\n\tcard->dev = parent;\n\tcard->number = idx;\n\tcard->module = module;\n\tINIT_LIST_HEAD(&card->devices);\n\tinit_rwsem(&card->controls_rwsem);\n\trwlock_init(&card->ctl_files_rwlock);\n\tINIT_LIST_HEAD(&card->controls);\n\tINIT_LIST_HEAD(&card->ctl_files);\n\tspin_lock_init(&card->files_lock);\n\tINIT_LIST_HEAD(&card->files_list);\n#ifdef CONFIG_PM\n\tmutex_init(&card->power_lock);\n\tinit_waitqueue_head(&card->power_sleep);\n#endif\n\n\tdevice_initialize(&card->card_dev);\n\tcard->card_dev.parent = parent;\n\tcard->card_dev.class = sound_class;\n\tcard->card_dev.release = release_card_device;\n\tcard->card_dev.groups = card_dev_attr_groups;\n\terr = kobject_set_name(&card->card_dev.kobj, \"card%d\", idx);\n\tif (err < 0)\n\t\tgoto __error;\n\n\t/* the control interface cannot be accessed from the user space until */\n\t/* snd_cards_bitmask and snd_cards are set with snd_card_register */\n\terr = snd_ctl_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to register control minors\\n\");\n\t\tgoto __error;\n\t}\n\terr = snd_info_card_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to create card info\\n\");\n\t\tgoto __error_ctl;\n\t}\n\t*card_ret = card;\n\treturn 0;\n\n      __error_ctl:\n\tsnd_device_free_all(card);\n      __error:\n\tput_device(&card->card_dev);\n  \treturn err;\n}\nEXPORT_SYMBOL(snd_card_new);\n\n/* return non-zero if a card is already locked */\nint snd_card_locked(int card)\n{\n\tint locked;\n\n\tmutex_lock(&snd_card_mutex);\n\tlocked = test_bit(card, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\treturn locked;\n}\n\nstatic loff_t snd_disconnect_llseek(struct file *file, loff_t offset, int orig)\n{\n\treturn -ENODEV;\n}\n\nstatic ssize_t snd_disconnect_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\treturn -ENODEV;\n}\n\nstatic ssize_t snd_disconnect_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *offset)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_monitor_file *df = NULL, *_df;\n\n\tspin_lock(&shutdown_lock);\n\tlist_for_each_entry(_df, &shutdown_files, shutdown_list) {\n\t\tif (_df->file == file) {\n\t\t\tdf = _df;\n\t\t\tlist_del_init(&df->shutdown_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&shutdown_lock);\n\n\tif (likely(df)) {\n\t\tif ((file->f_flags & FASYNC) && df->disconnected_f_op->fasync)\n\t\t\tdf->disconnected_f_op->fasync(-1, file, 0);\n\t\treturn df->disconnected_f_op->release(inode, file);\n\t}\n\n\tpanic(\"%s(%p, %p) failed!\", __func__, inode, file);\n}\n\nstatic unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)\n{\n\treturn POLLERR | POLLNVAL;\n}\n\nstatic long snd_disconnect_ioctl(struct file *file,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_fasync(int fd, struct file *file, int on)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct file_operations snd_shutdown_f_ops =\n{\n\t.owner = \tTHIS_MODULE,\n\t.llseek =\tsnd_disconnect_llseek,\n\t.read = \tsnd_disconnect_read,\n\t.write =\tsnd_disconnect_write,\n\t.release =\tsnd_disconnect_release,\n\t.poll =\t\tsnd_disconnect_poll,\n\t.unlocked_ioctl = snd_disconnect_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = snd_disconnect_ioctl,\n#endif\n\t.mmap =\t\tsnd_disconnect_mmap,\n\t.fasync =\tsnd_disconnect_fasync\n};\n\n/**\n *  snd_card_disconnect - disconnect all APIs from the file-operations (user space)\n *  @card: soundcard structure\n *\n *  Disconnects all APIs from the file-operations (user space).\n *\n *  Return: Zero, otherwise a negative error code.\n *\n *  Note: The current implementation replaces all active file->f_op with special\n *        dummy file operations (they do nothing except release).\n */\nint snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\tint err;\n\n\tif (!card)\n\t\treturn -EINVAL;\n\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\n\t/* phase 1: disable fops (user space) operations for ALSA API */\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\t\n\t/* phase 2: replace file->f_op with special dummy operations */\n\t\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\t/* it's critical part, use endless loop */\n\t\t/* we have no room to fail */\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n\n\t/* phase 3: notify all connected devices about disconnection */\n\t/* at this point, they cannot respond to any calls except release() */\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\n\t/* notify all devices that we are disconnected */\n\terr = snd_device_disconnect_all(card);\n\tif (err < 0)\n\t\tdev_err(card->dev, \"not all devices for card %i can be disconnected\\n\", card->number);\n\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}\n\nEXPORT_SYMBOL(snd_card_disconnect);\n\n/**\n *  snd_card_free - frees given soundcard structure\n *  @card: soundcard structure\n *\n *  This function releases the soundcard structure and the all assigned\n *  devices automatically.  That is, you don't have to release the devices\n *  by yourself.\n *\n *  Return: Zero. Frees all associated devices and frees the control\n *  interface associated to given soundcard.\n */\nstatic int snd_card_do_free(struct snd_card *card)\n{\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);\n#endif\n\tsnd_device_free_all(card);\n\tif (card->private_free)\n\t\tcard->private_free(card);\n\tsnd_info_free_entry(card->proc_id);\n\tif (snd_info_card_free(card) < 0) {\n\t\tdev_warn(card->dev, \"unable to free card info\\n\");\n\t\t/* Not fatal error */\n\t}\n\tif (card->release_completion)\n\t\tcomplete(card->release_completion);\n\tkfree(card);\n\treturn 0;\n}\n\nint snd_card_free_when_closed(struct snd_card *card)\n{\n\tint ret = snd_card_disconnect(card);\n\tif (ret)\n\t\treturn ret;\n\tput_device(&card->card_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_card_free_when_closed);\n\nint snd_card_free(struct snd_card *card)\n{\n\tstruct completion released;\n\tint ret;\n\n\tinit_completion(&released);\n\tcard->release_completion = &released;\n\tret = snd_card_free_when_closed(card);\n\tif (ret)\n\t\treturn ret;\n\t/* wait, until all devices are ready for the free operation */\n\twait_for_completion(&released);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_card_free);\n\n/* retrieve the last word of shortname or longname */\nstatic const char *retrieve_id_from_card_name(const char *name)\n{\n\tconst char *spos = name;\n\n\twhile (*name) {\n\t\tif (isspace(*name) && isalnum(name[1]))\n\t\t\tspos = name + 1;\n\t\tname++;\n\t}\n\treturn spos;\n}\n\n/* return true if the given id string doesn't conflict any other card ids */\nstatic bool card_id_ok(struct snd_card *card, const char *id)\n{\n\tint i;\n\tif (!snd_info_check_reserved_words(id))\n\t\treturn false;\n\tfor (i = 0; i < snd_ecards_limit; i++) {\n\t\tif (snd_cards[i] && snd_cards[i] != card &&\n\t\t    !strcmp(snd_cards[i]->id, id))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* copy to card->id only with valid letters from nid */\nstatic void copy_valid_id_string(struct snd_card *card, const char *src,\n\t\t\t\t const char *nid)\n{\n\tchar *id = card->id;\n\n\twhile (*nid && !isalnum(*nid))\n\t\tnid++;\n\tif (isdigit(*nid))\n\t\t*id++ = isalpha(*src) ? *src : 'D';\n\twhile (*nid && (size_t)(id - card->id) < sizeof(card->id) - 1) {\n\t\tif (isalnum(*nid))\n\t\t\t*id++ = *nid;\n\t\tnid++;\n\t}\n\t*id = 0;\n}\n\n/* Set card->id from the given string\n * If the string conflicts with other ids, add a suffix to make it unique.\n */\nstatic void snd_card_set_id_no_lock(struct snd_card *card, const char *src,\n\t\t\t\t    const char *nid)\n{\n\tint len, loops;\n\tbool is_default = false;\n\tchar *id;\n\t\n\tcopy_valid_id_string(card, src, nid);\n\tid = card->id;\n\n again:\n\t/* use \"Default\" for obviously invalid strings\n\t * (\"card\" conflicts with proc directories)\n\t */\n\tif (!*id || !strncmp(id, \"card\", 4)) {\n\t\tstrcpy(id, \"Default\");\n\t\tis_default = true;\n\t}\n\n\tlen = strlen(id);\n\tfor (loops = 0; loops < SNDRV_CARDS; loops++) {\n\t\tchar *spos;\n\t\tchar sfxstr[5]; /* \"_012\" */\n\t\tint sfxlen;\n\n\t\tif (card_id_ok(card, id))\n\t\t\treturn; /* OK */\n\n\t\t/* Add _XYZ suffix */\n\t\tsprintf(sfxstr, \"_%X\", loops + 1);\n\t\tsfxlen = strlen(sfxstr);\n\t\tif (len + sfxlen >= sizeof(card->id))\n\t\t\tspos = id + sizeof(card->id) - sfxlen - 1;\n\t\telse\n\t\t\tspos = id + len;\n\t\tstrcpy(spos, sfxstr);\n\t}\n\t/* fallback to the default id */\n\tif (!is_default) {\n\t\t*id = 0;\n\t\tgoto again;\n\t}\n\t/* last resort... */\n\tdev_err(card->dev, \"unable to set card id (%s)\\n\", id);\n\tif (card->proc_root->name)\n\t\tstrlcpy(card->id, card->proc_root->name, sizeof(card->id));\n}\n\n/**\n *  snd_card_set_id - set card identification name\n *  @card: soundcard structure\n *  @nid: new identification string\n *\n *  This function sets the card identification and checks for name\n *  collisions.\n */\nvoid snd_card_set_id(struct snd_card *card, const char *nid)\n{\n\t/* check if user specified own card->id */\n\tif (card->id[0] != '\\0')\n\t\treturn;\n\tmutex_lock(&snd_card_mutex);\n\tsnd_card_set_id_no_lock(card, nid, nid);\n\tmutex_unlock(&snd_card_mutex);\n}\nEXPORT_SYMBOL(snd_card_set_id);\n\nstatic ssize_t\ncard_id_show_attr(struct device *dev,\n\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", card->id);\n}\n\nstatic ssize_t\ncard_id_store_attr(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\tchar buf1[sizeof(card->id)];\n\tsize_t copy = count > sizeof(card->id) - 1 ?\n\t\t\t\t\tsizeof(card->id) - 1 : count;\n\tsize_t idx;\n\tint c;\n\n\tfor (idx = 0; idx < copy; idx++) {\n\t\tc = buf[idx];\n\t\tif (!isalnum(c) && c != '_' && c != '-')\n\t\t\treturn -EINVAL;\n\t}\n\tmemcpy(buf1, buf, copy);\n\tbuf1[copy] = '\\0';\n\tmutex_lock(&snd_card_mutex);\n\tif (!card_id_ok(NULL, buf1)) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn -EEXIST;\n\t}\n\tstrcpy(card->id, buf1);\n\tsnd_info_card_id_change(card);\n\tmutex_unlock(&snd_card_mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(id, S_IRUGO | S_IWUSR, card_id_show_attr, card_id_store_attr);\n\nstatic ssize_t\ncard_number_show_attr(struct device *dev,\n\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\treturn snprintf(buf, PAGE_SIZE, \"%i\\n\", card->number);\n}\n\nstatic DEVICE_ATTR(number, S_IRUGO, card_number_show_attr, NULL);\n\nstatic struct attribute *card_dev_attrs[] = {\n\t&dev_attr_id.attr,\n\t&dev_attr_number.attr,\n\tNULL\n};\n\nstatic struct attribute_group card_dev_attr_group = {\n\t.attrs\t= card_dev_attrs,\n};\n\nstatic const struct attribute_group *card_dev_attr_groups[] = {\n\t&card_dev_attr_group,\n\tNULL\n};\n\n/**\n *  snd_card_register - register the soundcard\n *  @card: soundcard structure\n *\n *  This function registers all the devices assigned to the soundcard.\n *  Until calling this, the ALSA control interface is blocked from the\n *  external accesses.  Thus, you should call this function at the end\n *  of the initialization of the card.\n *\n *  Return: Zero otherwise a negative error code if the registration failed.\n */\nint snd_card_register(struct snd_card *card)\n{\n\tint err;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\n\tif (!card->registered) {\n\t\terr = device_add(&card->card_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcard->registered = true;\n\t}\n\n\tif ((err = snd_device_register_all(card)) < 0)\n\t\treturn err;\n\tmutex_lock(&snd_card_mutex);\n\tif (snd_cards[card->number]) {\n\t\t/* already registered */\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn 0;\n\t}\n\tif (*card->id) {\n\t\t/* make a unique id name from the given string */\n\t\tchar tmpid[sizeof(card->id)];\n\t\tmemcpy(tmpid, card->id, sizeof(card->id));\n\t\tsnd_card_set_id_no_lock(card, tmpid, tmpid);\n\t} else {\n\t\t/* create an id from either shortname or longname */\n\t\tconst char *src;\n\t\tsrc = *card->shortname ? card->shortname : card->longname;\n\t\tsnd_card_set_id_no_lock(card, src,\n\t\t\t\t\tretrieve_id_from_card_name(src));\n\t}\n\tsnd_cards[card->number] = card;\n\tmutex_unlock(&snd_card_mutex);\n\tinit_info_for_card(card);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n#endif\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_card_register);\n\n#ifdef CONFIG_PROC_FS\nstatic struct snd_info_entry *snd_card_info_entry;\n\nstatic void snd_card_info_read(struct snd_info_entry *entry,\n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tint idx, count;\n\tstruct snd_card *card;\n\n\tfor (idx = count = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tif ((card = snd_cards[idx]) != NULL) {\n\t\t\tcount++;\n\t\t\tsnd_iprintf(buffer, \"%2i [%-15s]: %s - %s\\n\",\n\t\t\t\t\tidx,\n\t\t\t\t\tcard->id,\n\t\t\t\t\tcard->driver,\n\t\t\t\t\tcard->shortname);\n\t\t\tsnd_iprintf(buffer, \"                      %s\\n\",\n\t\t\t\t\tcard->longname);\n\t\t}\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n\tif (!count)\n\t\tsnd_iprintf(buffer, \"--- no soundcards ---\\n\");\n}\n\n#ifdef CONFIG_SND_OSSEMUL\n\nvoid snd_card_info_read_oss(struct snd_info_buffer *buffer)\n{\n\tint idx, count;\n\tstruct snd_card *card;\n\n\tfor (idx = count = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tif ((card = snd_cards[idx]) != NULL) {\n\t\t\tcount++;\n\t\t\tsnd_iprintf(buffer, \"%s\\n\", card->longname);\n\t\t}\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n\tif (!count) {\n\t\tsnd_iprintf(buffer, \"--- no soundcards ---\\n\");\n\t}\n}\n\n#endif\n\n#ifdef MODULE\nstatic struct snd_info_entry *snd_card_module_info_entry;\nstatic void snd_card_module_info_read(struct snd_info_entry *entry,\n\t\t\t\t      struct snd_info_buffer *buffer)\n{\n\tint idx;\n\tstruct snd_card *card;\n\n\tfor (idx = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tif ((card = snd_cards[idx]) != NULL)\n\t\t\tsnd_iprintf(buffer, \"%2i %s\\n\",\n\t\t\t\t    idx, card->module->name);\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n}\n#endif\n\nint __init snd_card_info_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"cards\", NULL);\n\tif (! entry)\n\t\treturn -ENOMEM;\n\tentry->c.text.read = snd_card_info_read;\n\tif (snd_info_register(entry) < 0) {\n\t\tsnd_info_free_entry(entry);\n\t\treturn -ENOMEM;\n\t}\n\tsnd_card_info_entry = entry;\n\n#ifdef MODULE\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"modules\", NULL);\n\tif (entry) {\n\t\tentry->c.text.read = snd_card_module_info_read;\n\t\tif (snd_info_register(entry) < 0)\n\t\t\tsnd_info_free_entry(entry);\n\t\telse\n\t\t\tsnd_card_module_info_entry = entry;\n\t}\n#endif\n\n\treturn 0;\n}\n\nint __exit snd_card_info_done(void)\n{\n\tsnd_info_free_entry(snd_card_info_entry);\n#ifdef MODULE\n\tsnd_info_free_entry(snd_card_module_info_entry);\n#endif\n\treturn 0;\n}\n\n#endif /* CONFIG_PROC_FS */\n\n/**\n *  snd_component_add - add a component string\n *  @card: soundcard structure\n *  @component: the component id string\n *\n *  This function adds the component id string to the supported list.\n *  The component can be referred from the alsa-lib.\n *\n *  Return: Zero otherwise a negative error code.\n */\n  \nint snd_component_add(struct snd_card *card, const char *component)\n{\n\tchar *ptr;\n\tint len = strlen(component);\n\n\tptr = strstr(card->components, component);\n\tif (ptr != NULL) {\n\t\tif (ptr[len] == '\\0' || ptr[len] == ' ')\t/* already there */\n\t\t\treturn 1;\n\t}\n\tif (strlen(card->components) + 1 + len + 1 > sizeof(card->components)) {\n\t\tsnd_BUG();\n\t\treturn -ENOMEM;\n\t}\n\tif (card->components[0] != '\\0')\n\t\tstrcat(card->components, \" \");\n\tstrcat(card->components, component);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_component_add);\n\n/**\n *  snd_card_file_add - add the file to the file list of the card\n *  @card: soundcard structure\n *  @file: file pointer\n *\n *  This function adds the file to the file linked-list of the card.\n *  This linked-list is used to keep tracking the connection state,\n *  and to avoid the release of busy resources by hotplug.\n *\n *  Return: zero or a negative error code.\n */\nint snd_card_file_add(struct snd_card *card, struct file *file)\n{\n\tstruct snd_monitor_file *mfile;\n\n\tmfile = kmalloc(sizeof(*mfile), GFP_KERNEL);\n\tif (mfile == NULL)\n\t\treturn -ENOMEM;\n\tmfile->file = file;\n\tmfile->disconnected_f_op = NULL;\n\tINIT_LIST_HEAD(&mfile->shutdown_list);\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\tkfree(mfile);\n\t\treturn -ENODEV;\n\t}\n\tlist_add(&mfile->list, &card->files_list);\n\tget_device(&card->card_dev);\n\tspin_unlock(&card->files_lock);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_card_file_add);\n\n/**\n *  snd_card_file_remove - remove the file from the file list\n *  @card: soundcard structure\n *  @file: file pointer\n *\n *  This function removes the file formerly added to the card via\n *  snd_card_file_add() function.\n *  If all files are removed and snd_card_free_when_closed() was\n *  called beforehand, it processes the pending release of\n *  resources.\n *\n *  Return: Zero or a negative error code.\n */\nint snd_card_file_remove(struct snd_card *card, struct file *file)\n{\n\tstruct snd_monitor_file *mfile, *found = NULL;\n\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tif (mfile->file == file) {\n\t\t\tlist_del(&mfile->list);\n\t\t\tspin_lock(&shutdown_lock);\n\t\t\tlist_del(&mfile->shutdown_list);\n\t\t\tspin_unlock(&shutdown_lock);\n\t\t\tif (mfile->disconnected_f_op)\n\t\t\t\tfops_put(mfile->disconnected_f_op);\n\t\t\tfound = mfile;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&card->files_lock);\n\tif (!found) {\n\t\tdev_err(card->dev, \"card file remove problem (%p)\\n\", file);\n\t\treturn -ENOENT;\n\t}\n\tkfree(found);\n\tput_device(&card->card_dev);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_card_file_remove);\n\n#ifdef CONFIG_PM\n/**\n *  snd_power_wait - wait until the power-state is changed.\n *  @card: soundcard structure\n *  @power_state: expected power state\n *\n *  Waits until the power-state is changed.\n *\n *  Return: Zero if successful, or a negative error code.\n *\n *  Note: the power lock must be active before call.\n */\nint snd_power_wait(struct snd_card *card, unsigned int power_state)\n{\n\twait_queue_t wait;\n\tint result = 0;\n\n\t/* fastpath */\n\tif (snd_power_get_state(card) == power_state)\n\t\treturn 0;\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&card->power_sleep, &wait);\n\twhile (1) {\n\t\tif (card->shutdown) {\n\t\t\tresult = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (snd_power_get_state(card) == power_state)\n\t\t\tbreak;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tsnd_power_unlock(card);\n\t\tschedule_timeout(30 * HZ);\n\t\tsnd_power_lock(card);\n\t}\n\tremove_wait_queue(&card->power_sleep, &wait);\n\treturn result;\n}\n\nEXPORT_SYMBOL(snd_power_wait);\n#endif /* CONFIG_PM */\n"], "fixing_code": ["#ifndef __SOUND_CORE_H\n#define __SOUND_CORE_H\n\n/*\n *  Main header file for the ALSA driver\n *  Copyright (c) 1994-2001 by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/device.h>\n#include <linux/sched.h>\t\t/* wake_up() */\n#include <linux/mutex.h>\t\t/* struct mutex */\n#include <linux/rwsem.h>\t\t/* struct rw_semaphore */\n#include <linux/pm.h>\t\t\t/* pm_message_t */\n#include <linux/stringify.h>\n#include <linux/printk.h>\n\n/* number of supported soundcards */\n#ifdef CONFIG_SND_DYNAMIC_MINORS\n#define SNDRV_CARDS CONFIG_SND_MAX_CARDS\n#else\n#define SNDRV_CARDS 8\t\t/* don't change - minor numbers */\n#endif\n\n#define CONFIG_SND_MAJOR\t116\t/* standard configuration */\n\n/* forward declarations */\nstruct pci_dev;\nstruct module;\nstruct completion;\n\n/* device allocation stuff */\n\n/* type of the object used in snd_device_*()\n * this also defines the calling order\n */\nenum snd_device_type {\n\tSNDRV_DEV_LOWLEVEL,\n\tSNDRV_DEV_CONTROL,\n\tSNDRV_DEV_INFO,\n\tSNDRV_DEV_BUS,\n\tSNDRV_DEV_CODEC,\n\tSNDRV_DEV_PCM,\n\tSNDRV_DEV_COMPRESS,\n\tSNDRV_DEV_RAWMIDI,\n\tSNDRV_DEV_TIMER,\n\tSNDRV_DEV_SEQUENCER,\n\tSNDRV_DEV_HWDEP,\n\tSNDRV_DEV_JACK,\n};\n\nenum snd_device_state {\n\tSNDRV_DEV_BUILD,\n\tSNDRV_DEV_REGISTERED,\n\tSNDRV_DEV_DISCONNECTED,\n};\n\nstruct snd_device;\n\nstruct snd_device_ops {\n\tint (*dev_free)(struct snd_device *dev);\n\tint (*dev_register)(struct snd_device *dev);\n\tint (*dev_disconnect)(struct snd_device *dev);\n};\n\nstruct snd_device {\n\tstruct list_head list;\t\t/* list of registered devices */\n\tstruct snd_card *card;\t\t/* card which holds this device */\n\tenum snd_device_state state;\t/* state of the device */\n\tenum snd_device_type type;\t/* device type */\n\tvoid *device_data;\t\t/* device structure */\n\tstruct snd_device_ops *ops;\t/* operations */\n};\n\n#define snd_device(n) list_entry(n, struct snd_device, list)\n\n/* main structure for soundcard */\n\nstruct snd_card {\n\tint number;\t\t\t/* number of soundcard (index to\n\t\t\t\t\t\t\t\tsnd_cards) */\n\n\tchar id[16];\t\t\t/* id string of this card */\n\tchar driver[16];\t\t/* driver name */\n\tchar shortname[32];\t\t/* short name of this soundcard */\n\tchar longname[80];\t\t/* name of this soundcard */\n\tchar mixername[80];\t\t/* mixer name */\n\tchar components[128];\t\t/* card components delimited with\n\t\t\t\t\t\t\t\tspace */\n\tstruct module *module;\t\t/* top-level module */\n\n\tvoid *private_data;\t\t/* private data for soundcard */\n\tvoid (*private_free) (struct snd_card *card); /* callback for freeing of\n\t\t\t\t\t\t\t\tprivate data */\n\tstruct list_head devices;\t/* devices */\n\n\tunsigned int last_numid;\t/* last used numeric ID */\n\tstruct rw_semaphore controls_rwsem;\t/* controls list lock */\n\trwlock_t ctl_files_rwlock;\t/* ctl_files list lock */\n\tint controls_count;\t\t/* count of all controls */\n\tint user_ctl_count;\t\t/* count of all user controls */\n\tstruct list_head controls;\t/* all controls for this card */\n\tstruct list_head ctl_files;\t/* active control files */\n\tstruct mutex user_ctl_lock;\t/* protects user controls against\n\t\t\t\t\t   concurrent access */\n\n\tstruct snd_info_entry *proc_root;\t/* root for soundcard specific files */\n\tstruct snd_info_entry *proc_id;\t/* the card id */\n\tstruct proc_dir_entry *proc_root_link;\t/* number link to real id */\n\n\tstruct list_head files_list;\t/* all files associated to this card */\n\tstruct snd_shutdown_f_ops *s_f_ops; /* file operations in the shutdown\n\t\t\t\t\t\t\t\tstate */\n\tspinlock_t files_lock;\t\t/* lock the files for this card */\n\tint shutdown;\t\t\t/* this card is going down */\n\tstruct completion *release_completion;\n\tstruct device *dev;\t\t/* device assigned to this card */\n\tstruct device card_dev;\t\t/* cardX object for sysfs */\n\tbool registered;\t\t/* card_dev is registered? */\n\n#ifdef CONFIG_PM\n\tunsigned int power_state;\t/* power state */\n\tstruct mutex power_lock;\t/* power lock */\n\twait_queue_head_t power_sleep;\n#endif\n\n#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)\n\tstruct snd_mixer_oss *mixer_oss;\n\tint mixer_oss_change_count;\n#endif\n};\n\n#define dev_to_snd_card(p)\tcontainer_of(p, struct snd_card, card_dev)\n\n#ifdef CONFIG_PM\nstatic inline void snd_power_lock(struct snd_card *card)\n{\n\tmutex_lock(&card->power_lock);\n}\n\nstatic inline void snd_power_unlock(struct snd_card *card)\n{\n\tmutex_unlock(&card->power_lock);\n}\n\nstatic inline unsigned int snd_power_get_state(struct snd_card *card)\n{\n\treturn card->power_state;\n}\n\nstatic inline void snd_power_change_state(struct snd_card *card, unsigned int state)\n{\n\tcard->power_state = state;\n\twake_up(&card->power_sleep);\n}\n\n/* init.c */\nint snd_power_wait(struct snd_card *card, unsigned int power_state);\n\n#else /* ! CONFIG_PM */\n\n#define snd_power_lock(card)\t\tdo { (void)(card); } while (0)\n#define snd_power_unlock(card)\t\tdo { (void)(card); } while (0)\nstatic inline int snd_power_wait(struct snd_card *card, unsigned int state) { return 0; }\n#define snd_power_get_state(card)\t({ (void)(card); SNDRV_CTL_POWER_D0; })\n#define snd_power_change_state(card, state)\tdo { (void)(card); } while (0)\n\n#endif /* CONFIG_PM */\n\nstruct snd_minor {\n\tint type;\t\t\t/* SNDRV_DEVICE_TYPE_XXX */\n\tint card;\t\t\t/* card number */\n\tint device;\t\t\t/* device number */\n\tconst struct file_operations *f_ops;\t/* file operations */\n\tvoid *private_data;\t\t/* private data for f_ops->open */\n\tstruct device *dev;\t\t/* device for sysfs */\n\tstruct snd_card *card_ptr;\t/* assigned card instance */\n};\n\n/* return a device pointer linked to each sound device as a parent */\nstatic inline struct device *snd_card_get_device_link(struct snd_card *card)\n{\n\treturn card ? &card->card_dev : NULL;\n}\n\n/* sound.c */\n\nextern int snd_major;\nextern int snd_ecards_limit;\nextern struct class *sound_class;\n\nvoid snd_request_card(int card);\n\nint snd_register_device_for_dev(int type, struct snd_card *card,\n\t\t\t\tint dev,\n\t\t\t\tconst struct file_operations *f_ops,\n\t\t\t\tvoid *private_data,\n\t\t\t\tconst char *name,\n\t\t\t\tstruct device *device);\n\n/**\n * snd_register_device - Register the ALSA device file for the card\n * @type: the device type, SNDRV_DEVICE_TYPE_XXX\n * @card: the card instance\n * @dev: the device index\n * @f_ops: the file operations\n * @private_data: user pointer for f_ops->open()\n * @name: the device file name\n *\n * Registers an ALSA device file for the given card.\n * The operators have to be set in reg parameter.\n *\n * This function uses the card's device pointer to link to the\n * correct &struct device.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nstatic inline int snd_register_device(int type, struct snd_card *card, int dev,\n\t\t\t\t      const struct file_operations *f_ops,\n\t\t\t\t      void *private_data,\n\t\t\t\t      const char *name)\n{\n\treturn snd_register_device_for_dev(type, card, dev, f_ops,\n\t\t\t\t\t   private_data, name,\n\t\t\t\t\t   snd_card_get_device_link(card));\n}\n\nint snd_unregister_device(int type, struct snd_card *card, int dev);\nvoid *snd_lookup_minor_data(unsigned int minor, int type);\nstruct device *snd_get_device(int type, struct snd_card *card, int dev);\n\n#ifdef CONFIG_SND_OSSEMUL\nint snd_register_oss_device(int type, struct snd_card *card, int dev,\n\t\t\t    const struct file_operations *f_ops, void *private_data);\nint snd_unregister_oss_device(int type, struct snd_card *card, int dev);\nvoid *snd_lookup_oss_minor_data(unsigned int minor, int type);\n#endif\n\nint snd_minor_info_init(void);\nint snd_minor_info_done(void);\n\n/* sound_oss.c */\n\n#ifdef CONFIG_SND_OSSEMUL\nint snd_minor_info_oss_init(void);\nint snd_minor_info_oss_done(void);\n#else\nstatic inline int snd_minor_info_oss_init(void) { return 0; }\nstatic inline int snd_minor_info_oss_done(void) { return 0; }\n#endif\n\n/* memory.c */\n\nint copy_to_user_fromio(void __user *dst, const volatile void __iomem *src, size_t count);\nint copy_from_user_toio(volatile void __iomem *dst, const void __user *src, size_t count);\n\n/* init.c */\n\nextern struct snd_card *snd_cards[SNDRV_CARDS];\nint snd_card_locked(int card);\n#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)\n#define SND_MIXER_OSS_NOTIFY_REGISTER\t0\n#define SND_MIXER_OSS_NOTIFY_DISCONNECT\t1\n#define SND_MIXER_OSS_NOTIFY_FREE\t2\nextern int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int cmd);\n#endif\n\nint snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t struct module *module, int extra_size,\n\t\t struct snd_card **card_ret);\n\nint snd_card_disconnect(struct snd_card *card);\nint snd_card_free(struct snd_card *card);\nint snd_card_free_when_closed(struct snd_card *card);\nvoid snd_card_set_id(struct snd_card *card, const char *id);\nint snd_card_register(struct snd_card *card);\nint snd_card_info_init(void);\nint snd_card_info_done(void);\nint snd_component_add(struct snd_card *card, const char *component);\nint snd_card_file_add(struct snd_card *card, struct file *file);\nint snd_card_file_remove(struct snd_card *card, struct file *file);\n#define snd_card_unref(card)\tput_device(&(card)->card_dev)\n\n#define snd_card_set_dev(card, devptr) ((card)->dev = (devptr))\n\n/* device.c */\n\nint snd_device_new(struct snd_card *card, enum snd_device_type type,\n\t\t   void *device_data, struct snd_device_ops *ops);\nint snd_device_register(struct snd_card *card, void *device_data);\nint snd_device_register_all(struct snd_card *card);\nint snd_device_disconnect_all(struct snd_card *card);\nvoid snd_device_free(struct snd_card *card, void *device_data);\nvoid snd_device_free_all(struct snd_card *card);\n\n/* isadma.c */\n\n#ifdef CONFIG_ISA_DMA_API\n#define DMA_MODE_NO_ENABLE\t0x0100\n\nvoid snd_dma_program(unsigned long dma, unsigned long addr, unsigned int size, unsigned short mode);\nvoid snd_dma_disable(unsigned long dma);\nunsigned int snd_dma_pointer(unsigned long dma, unsigned int size);\n#endif\n\n/* misc.c */\nstruct resource;\nvoid release_and_free_resource(struct resource *res);\n\n/* --- */\n\n/* sound printk debug levels */\nenum {\n\tSND_PR_ALWAYS,\n\tSND_PR_DEBUG,\n\tSND_PR_VERBOSE,\n};\n\n#if defined(CONFIG_SND_DEBUG) || defined(CONFIG_SND_VERBOSE_PRINTK)\n__printf(4, 5)\nvoid __snd_printk(unsigned int level, const char *file, int line,\n\t\t  const char *format, ...);\n#else\n#define __snd_printk(level, file, line, format, args...) \\\n\tprintk(format, ##args)\n#endif\n\n/**\n * snd_printk - printk wrapper\n * @fmt: format string\n *\n * Works like printk() but prints the file and the line of the caller\n * when configured with CONFIG_SND_VERBOSE_PRINTK.\n */\n#define snd_printk(fmt, args...) \\\n\t__snd_printk(0, __FILE__, __LINE__, fmt, ##args)\n\n#ifdef CONFIG_SND_DEBUG\n/**\n * snd_printd - debug printk\n * @fmt: format string\n *\n * Works like snd_printk() for debugging purposes.\n * Ignored when CONFIG_SND_DEBUG is not set.\n */\n#define snd_printd(fmt, args...) \\\n\t__snd_printk(1, __FILE__, __LINE__, fmt, ##args)\n#define _snd_printd(level, fmt, args...) \\\n\t__snd_printk(level, __FILE__, __LINE__, fmt, ##args)\n\n/**\n * snd_BUG - give a BUG warning message and stack trace\n *\n * Calls WARN() if CONFIG_SND_DEBUG is set.\n * Ignored when CONFIG_SND_DEBUG is not set.\n */\n#define snd_BUG()\t\tWARN(1, \"BUG?\\n\")\n\n/**\n * Suppress high rates of output when CONFIG_SND_DEBUG is enabled.\n */\n#define snd_printd_ratelimit() printk_ratelimit()\n\n/**\n * snd_BUG_ON - debugging check macro\n * @cond: condition to evaluate\n *\n * Has the same behavior as WARN_ON when CONFIG_SND_DEBUG is set,\n * otherwise just evaluates the conditional and returns the value.\n */\n#define snd_BUG_ON(cond)\tWARN_ON((cond))\n\n#else /* !CONFIG_SND_DEBUG */\n\n__printf(1, 2)\nstatic inline void snd_printd(const char *format, ...) {}\n__printf(2, 3)\nstatic inline void _snd_printd(int level, const char *format, ...) {}\n\n#define snd_BUG()\t\t\tdo { } while (0)\n\n#define snd_BUG_ON(condition) ({ \\\n\tint __ret_warn_on = !!(condition); \\\n\tunlikely(__ret_warn_on); \\\n})\n\nstatic inline bool snd_printd_ratelimit(void) { return false; }\n\n#endif /* CONFIG_SND_DEBUG */\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n/**\n * snd_printdd - debug printk\n * @format: format string\n *\n * Works like snd_printk() for debugging purposes.\n * Ignored when CONFIG_SND_DEBUG_VERBOSE is not set.\n */\n#define snd_printdd(format, args...) \\\n\t__snd_printk(2, __FILE__, __LINE__, format, ##args)\n#else\n__printf(1, 2)\nstatic inline void snd_printdd(const char *format, ...) {}\n#endif\n\n\n#define SNDRV_OSS_VERSION         ((3<<16)|(8<<8)|(1<<4)|(0))\t/* 3.8.1a */\n\n/* for easier backward-porting */\n#if defined(CONFIG_GAMEPORT) || defined(CONFIG_GAMEPORT_MODULE)\n#define gameport_set_dev_parent(gp,xdev) ((gp)->dev.parent = (xdev))\n#define gameport_set_port_data(gp,r) ((gp)->port_data = (r))\n#define gameport_get_port_data(gp) (gp)->port_data\n#endif\n\n/* PCI quirk list helper */\nstruct snd_pci_quirk {\n\tunsigned short subvendor;\t/* PCI subvendor ID */\n\tunsigned short subdevice;\t/* PCI subdevice ID */\n\tunsigned short subdevice_mask;\t/* bitmask to match */\n\tint value;\t\t\t/* value */\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tconst char *name;\t\t/* name of the device (optional) */\n#endif\n};\n\n#define _SND_PCI_QUIRK_ID_MASK(vend, mask, dev)\t\\\n\t.subvendor = (vend), .subdevice = (dev), .subdevice_mask = (mask)\n#define _SND_PCI_QUIRK_ID(vend, dev) \\\n\t_SND_PCI_QUIRK_ID_MASK(vend, 0xffff, dev)\n#define SND_PCI_QUIRK_ID(vend,dev) {_SND_PCI_QUIRK_ID(vend, dev)}\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n#define SND_PCI_QUIRK(vend,dev,xname,val) \\\n\t{_SND_PCI_QUIRK_ID(vend, dev), .value = (val), .name = (xname)}\n#define SND_PCI_QUIRK_VENDOR(vend, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, 0, 0), .value = (val), .name = (xname)}\n#define SND_PCI_QUIRK_MASK(vend, mask, dev, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, mask, dev),\t\t\t\\\n\t\t\t.value = (val), .name = (xname)}\n#define snd_pci_quirk_name(q)\t((q)->name)\n#else\n#define SND_PCI_QUIRK(vend,dev,xname,val) \\\n\t{_SND_PCI_QUIRK_ID(vend, dev), .value = (val)}\n#define SND_PCI_QUIRK_MASK(vend, mask, dev, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, mask, dev), .value = (val)}\n#define SND_PCI_QUIRK_VENDOR(vend, xname, val)\t\t\t\\\n\t{_SND_PCI_QUIRK_ID_MASK(vend, 0, 0), .value = (val)}\n#define snd_pci_quirk_name(q)\t\"\"\n#endif\n\n#ifdef CONFIG_PCI\nconst struct snd_pci_quirk *\nsnd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list);\n\nconst struct snd_pci_quirk *\nsnd_pci_quirk_lookup_id(u16 vendor, u16 device,\n\t\t\tconst struct snd_pci_quirk *list);\n#else\nstatic inline const struct snd_pci_quirk *\nsnd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list)\n{\n\treturn NULL;\n}\n\nstatic inline const struct snd_pci_quirk *\nsnd_pci_quirk_lookup_id(u16 vendor, u16 device,\n\t\t\tconst struct snd_pci_quirk *list)\n{\n\treturn NULL;\n}\n#endif\n\n#endif /* __SOUND_CORE_H */\n", "/*\n *  Routines for driver control interface\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/threads.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <sound/control.h>\n\n/* max number of user-defined controls */\n#define MAX_USER_CONTROLS\t32\n#define MAX_CONTROL_COUNT\t1028\n\nstruct snd_kctl_ioctl {\n\tstruct list_head list;\t\t/* list of all ioctls */\n\tsnd_kctl_ioctl_func_t fioctl;\n};\n\nstatic DECLARE_RWSEM(snd_ioctl_rwsem);\nstatic LIST_HEAD(snd_control_ioctls);\n#ifdef CONFIG_COMPAT\nstatic LIST_HEAD(snd_control_compat_ioctls);\n#endif\n\nstatic int snd_ctl_open(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard = snd_lookup_minor_data(iminor(inode), SNDRV_DEVICE_TYPE_CONTROL);\n\tif (!card) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\terr = snd_card_file_add(card, file);\n\tif (err < 0) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\tif (!try_module_get(card->module)) {\n\t\terr = -EFAULT;\n\t\tgoto __error2;\n\t}\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (ctl == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\tINIT_LIST_HEAD(&ctl->events);\n\tinit_waitqueue_head(&ctl->change_sleep);\n\tspin_lock_init(&ctl->read_lock);\n\tctl->card = card;\n\tctl->prefer_pcm_subdevice = -1;\n\tctl->prefer_rawmidi_subdevice = -1;\n\tctl->pid = get_pid(task_pid(current));\n\tfile->private_data = ctl;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_add_tail(&ctl->list, &card->ctl_files);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tsnd_card_unref(card);\n\treturn 0;\n\n      __error:\n\tmodule_put(card->module);\n      __error2:\n\tsnd_card_file_remove(card, file);\n      __error1:\n\tif (card)\n\t\tsnd_card_unref(card);\n      \treturn err;\n}\n\nstatic void snd_ctl_empty_read_queue(struct snd_ctl_file * ctl)\n{\n\tunsigned long flags;\n\tstruct snd_kctl_event *cread;\n\t\n\tspin_lock_irqsave(&ctl->read_lock, flags);\n\twhile (!list_empty(&ctl->events)) {\n\t\tcread = snd_kctl_event(ctl->events.next);\n\t\tlist_del(&cread->list);\n\t\tkfree(cread);\n\t}\n\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n}\n\nstatic int snd_ctl_release(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kcontrol *control;\n\tunsigned int idx;\n\n\tctl = file->private_data;\n\tfile->private_data = NULL;\n\tcard = ctl->card;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_del(&ctl->list);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tdown_write(&card->controls_rwsem);\n\tlist_for_each_entry(control, &card->controls, list)\n\t\tfor (idx = 0; idx < control->count; idx++)\n\t\t\tif (control->vd[idx].owner == ctl)\n\t\t\t\tcontrol->vd[idx].owner = NULL;\n\tup_write(&card->controls_rwsem);\n\tsnd_ctl_empty_read_queue(ctl);\n\tput_pid(ctl->pid);\n\tkfree(ctl);\n\tmodule_put(card->module);\n\tsnd_card_file_remove(card, file);\n\treturn 0;\n}\n\nvoid snd_ctl_notify(struct snd_card *card, unsigned int mask,\n\t\t    struct snd_ctl_elem_id *id)\n{\n\tunsigned long flags;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kctl_event *ev;\n\t\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn;\n\tread_lock(&card->ctl_files_rwlock);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tcard->mixer_oss_change_count++;\n#endif\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\tif (!ctl->subscribed)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&ctl->read_lock, flags);\n\t\tlist_for_each_entry(ev, &ctl->events, list) {\n\t\t\tif (ev->id.numid == id->numid) {\n\t\t\t\tev->mask |= mask;\n\t\t\t\tgoto _found;\n\t\t\t}\n\t\t}\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (ev) {\n\t\t\tev->id = *id;\n\t\t\tev->mask = mask;\n\t\t\tlist_add_tail(&ev->list, &ctl->events);\n\t\t} else {\n\t\t\tdev_err(card->dev, \"No memory available to allocate event\\n\");\n\t\t}\n\t_found:\n\t\twake_up(&ctl->change_sleep);\n\t\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n\t\tkill_fasync(&ctl->fasync, SIGIO, POLL_IN);\n\t}\n\tread_unlock(&card->ctl_files_rwlock);\n}\n\nEXPORT_SYMBOL(snd_ctl_notify);\n\n/**\n * snd_ctl_new - create a control instance from the template\n * @control: the control template\n * @access: the default control access\n *\n * Allocates a new struct snd_kcontrol instance and copies the given template \n * to the new instance. It does not copy volatile data (access).\n *\n * Return: The pointer of the new instance, or %NULL on failure.\n */\nstatic struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,\n\t\t\t\t\tunsigned int access)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\t\n\tif (snd_BUG_ON(!control || !control->count))\n\t\treturn NULL;\n\n\tif (control->count > MAX_CONTROL_COUNT)\n\t\treturn NULL;\n\n\tkctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);\n\tif (kctl == NULL) {\n\t\tpr_err(\"ALSA: Cannot allocate control instance\\n\");\n\t\treturn NULL;\n\t}\n\t*kctl = *control;\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tkctl->vd[idx].access = access;\n\treturn kctl;\n}\n\n/**\n * snd_ctl_new1 - create a control instance from the template\n * @ncontrol: the initialization record\n * @private_data: the private data to set\n *\n * Allocates a new struct snd_kcontrol instance and initialize from the given \n * template.  When the access field of ncontrol is 0, it's assumed as\n * READWRITE access. When the count field is 0, it's assumes as one.\n *\n * Return: The pointer of the newly generated instance, or %NULL on failure.\n */\nstruct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,\n\t\t\t\t  void *private_data)\n{\n\tstruct snd_kcontrol kctl;\n\tunsigned int access;\n\t\n\tif (snd_BUG_ON(!ncontrol || !ncontrol->info))\n\t\treturn NULL;\n\tmemset(&kctl, 0, sizeof(kctl));\n\tkctl.id.iface = ncontrol->iface;\n\tkctl.id.device = ncontrol->device;\n\tkctl.id.subdevice = ncontrol->subdevice;\n\tif (ncontrol->name) {\n\t\tstrlcpy(kctl.id.name, ncontrol->name, sizeof(kctl.id.name));\n\t\tif (strcmp(ncontrol->name, kctl.id.name) != 0)\n\t\t\tpr_warn(\"ALSA: Control name '%s' truncated to '%s'\\n\",\n\t\t\t\tncontrol->name, kctl.id.name);\n\t}\n\tkctl.id.index = ncontrol->index;\n\tkctl.count = ncontrol->count ? ncontrol->count : 1;\n\taccess = ncontrol->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t (ncontrol->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_VOLATILE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK));\n\tkctl.info = ncontrol->info;\n\tkctl.get = ncontrol->get;\n\tkctl.put = ncontrol->put;\n\tkctl.tlv.p = ncontrol->tlv.p;\n\tkctl.private_value = ncontrol->private_value;\n\tkctl.private_data = private_data;\n\treturn snd_ctl_new(&kctl, access);\n}\n\nEXPORT_SYMBOL(snd_ctl_new1);\n\n/**\n * snd_ctl_free_one - release the control instance\n * @kcontrol: the control instance\n *\n * Releases the control instance created via snd_ctl_new()\n * or snd_ctl_new1().\n * Don't call this after the control was added to the card.\n */\nvoid snd_ctl_free_one(struct snd_kcontrol *kcontrol)\n{\n\tif (kcontrol) {\n\t\tif (kcontrol->private_free)\n\t\t\tkcontrol->private_free(kcontrol);\n\t\tkfree(kcontrol);\n\t}\n}\n\nEXPORT_SYMBOL(snd_ctl_free_one);\n\nstatic bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int snd_ctl_find_hole(struct snd_card *card, unsigned int count)\n{\n\tunsigned int iter = 100000;\n\n\twhile (snd_ctl_remove_numid_conflict(card, count)) {\n\t\tif (--iter == 0) {\n\t\t\t/* this situation is very unlikely */\n\t\t\tdev_err(card->dev, \"unable to allocate new control numid\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * snd_ctl_add - add the control instance to the card\n * @card: the card instance\n * @kcontrol: the control instance to add\n *\n * Adds the control instance created via snd_ctl_new() or\n * snd_ctl_new1() to the given card. Assigns also an unique\n * numid used for fast search.\n *\n * It frees automatically the control which cannot be added.\n *\n * Return: Zero if successful, or a negative error code on failure.\n *\n */\nint snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_ctl_add);\n\n/**\n * snd_ctl_replace - replace the control instance of the card\n * @card: the card instance\n * @kcontrol: the control instance to replace\n * @add_on_replace: add the control if not already added\n *\n * Replaces the given control.  If the given control does not exist\n * and the add_on_replace flag is set, the control is added.  If the\n * control exists, it is destroyed first.\n *\n * It frees automatically the control which cannot be added or replaced.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,\n\t\t    bool add_on_replace)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tstruct snd_kcontrol *old;\n\tint ret;\n\n\tif (!kcontrol)\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!card || !kcontrol->info)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\told = snd_ctl_find_id(card, &id);\n\tif (!old) {\n\t\tif (add_on_replace)\n\t\t\tgoto add;\n\t\tup_write(&card->controls_rwsem);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tret = snd_ctl_remove(card, old);\n\tif (ret < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\tgoto error;\n\t}\nadd:\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\nerror:\n\tsnd_ctl_free_one(kcontrol);\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_ctl_replace);\n\n/**\n * snd_ctl_remove - remove the control from the card and release it\n * @card: the card instance\n * @kcontrol: the control instance to remove\n *\n * Removes the control from the card and then releases the instance.\n * You don't need to call snd_ctl_free_one(). You must be in\n * the write lock - down_write(&card->controls_rwsem).\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\n\tif (snd_BUG_ON(!card || !kcontrol))\n\t\treturn -EINVAL;\n\tlist_del(&kcontrol->list);\n\tcard->controls_count -= kcontrol->count;\n\tid = kcontrol->id;\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_REMOVE, &id);\n\tsnd_ctl_free_one(kcontrol);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_remove);\n\n/**\n * snd_ctl_remove_id - remove the control of the given id and release it\n * @card: the card instance\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove_id(struct snd_card *card, struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tret = snd_ctl_remove(card, kctl);\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(snd_ctl_remove_id);\n\n/**\n * snd_ctl_remove_user_ctl - remove and release the unlocked user control\n * @file: active control handle\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nstatic int snd_ctl_remove_user_ctl(struct snd_ctl_file * file,\n\t\t\t\t   struct snd_ctl_elem_id *id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol *kctl;\n\tint idx, ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\tif (!(kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_USER)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tif (kctl->vd[idx].owner != NULL && kctl->vd[idx].owner != file) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\tret = snd_ctl_remove(card, kctl);\n\tif (ret < 0)\n\t\tgoto error;\n\tcard->user_ctl_count--;\nerror:\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\n/**\n * snd_ctl_activate_id - activate/inactivate the control of the given id\n * @card: the card instance\n * @id: the control id to activate/inactivate\n * @active: non-zero to activate\n *\n * Finds the control instance with the given id, and activate or\n * inactivate the control together with notification, if changed.\n *\n * Return: 0 if unchanged, 1 if changed, or a negative error code on failure.\n */\nint snd_ctl_activate_id(struct snd_card *card, struct snd_ctl_elem_id *id,\n\t\t\tint active)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\tindex_offset = snd_ctl_get_ioff(kctl, &kctl->id);\n\tvd = &kctl->vd[index_offset];\n\tret = 0;\n\tif (active) {\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE))\n\t\t\tgoto unlock;\n\t\tvd->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t} else {\n\t\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE)\n\t\t\tgoto unlock;\n\t\tvd->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t}\n\tret = 1;\n unlock:\n\tup_write(&card->controls_rwsem);\n\tif (ret > 0)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO, id);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_activate_id);\n\n/**\n * snd_ctl_rename_id - replace the id of a control on the card\n * @card: the card instance\n * @src_id: the old id\n * @dst_id: the new id\n *\n * Finds the control with the old id from the card, and replaces the\n * id with the new one.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_rename_id(struct snd_card *card, struct snd_ctl_elem_id *src_id,\n\t\t      struct snd_ctl_elem_id *dst_id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, src_id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tkctl->id = *dst_id;\n\tkctl->id.numid = card->last_numid + 1;\n\tcard->last_numid += kctl->count;\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_rename_id);\n\n/**\n * snd_ctl_find_numid - find the control instance with the given number-id\n * @card: the card instance\n * @numid: the number-id to search\n *\n * Finds the control instance with the given number-id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !numid))\n\t\treturn NULL;\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)\n\t\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_ctl_find_numid);\n\n/**\n * snd_ctl_find_id - find the control instance with the given id\n * @card: the card instance\n * @id: the id to search\n *\n * Finds the control instance with the given id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_id(struct snd_card *card,\n\t\t\t\t     struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn NULL;\n\tif (id->numid != 0)\n\t\treturn snd_ctl_find_numid(card, id->numid);\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.iface != id->iface)\n\t\t\tcontinue;\n\t\tif (kctl->id.device != id->device)\n\t\t\tcontinue;\n\t\tif (kctl->id.subdevice != id->subdevice)\n\t\t\tcontinue;\n\t\tif (strncmp(kctl->id.name, id->name, sizeof(kctl->id.name)))\n\t\t\tcontinue;\n\t\tif (kctl->id.index > id->index)\n\t\t\tcontinue;\n\t\tif (kctl->id.index + kctl->count <= id->index)\n\t\t\tcontinue;\n\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_ctl_find_id);\n\nstatic int snd_ctl_card_info(struct snd_card *card, struct snd_ctl_file * ctl,\n\t\t\t     unsigned int cmd, void __user *arg)\n{\n\tstruct snd_ctl_card_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tdown_read(&snd_ioctl_rwsem);\n\tinfo->card = card->number;\n\tstrlcpy(info->id, card->id, sizeof(info->id));\n\tstrlcpy(info->driver, card->driver, sizeof(info->driver));\n\tstrlcpy(info->name, card->shortname, sizeof(info->name));\n\tstrlcpy(info->longname, card->longname, sizeof(info->longname));\n\tstrlcpy(info->mixername, card->mixername, sizeof(info->mixername));\n\tstrlcpy(info->components, card->components, sizeof(info->components));\n\tup_read(&snd_ioctl_rwsem);\n\tif (copy_to_user(arg, info, sizeof(struct snd_ctl_card_info))) {\n\t\tkfree(info);\n\t\treturn -EFAULT;\n\t}\n\tkfree(info);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_list(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_list __user *_list)\n{\n\tstruct list_head *plist;\n\tstruct snd_ctl_elem_list list;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_id *dst, *id;\n\tunsigned int offset, space, jidx;\n\t\n\tif (copy_from_user(&list, _list, sizeof(list)))\n\t\treturn -EFAULT;\n\toffset = list.offset;\n\tspace = list.space;\n\t/* try limit maximum space */\n\tif (space > 16384)\n\t\treturn -ENOMEM;\n\tif (space > 0) {\n\t\t/* allocate temporary buffer for atomic operation */\n\t\tdst = vmalloc(space * sizeof(struct snd_ctl_elem_id));\n\t\tif (dst == NULL)\n\t\t\treturn -ENOMEM;\n\t\tdown_read(&card->controls_rwsem);\n\t\tlist.count = card->controls_count;\n\t\tplist = card->controls.next;\n\t\twhile (plist != &card->controls) {\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t\tkctl = snd_kcontrol(plist);\n\t\t\tif (offset < kctl->count)\n\t\t\t\tbreak;\n\t\t\toffset -= kctl->count;\n\t\t\tplist = plist->next;\n\t\t}\n\t\tlist.used = 0;\n\t\tid = dst;\n\t\twhile (space > 0 && plist != &card->controls) {\n\t\t\tkctl = snd_kcontrol(plist);\n\t\t\tfor (jidx = offset; space > 0 && jidx < kctl->count; jidx++) {\n\t\t\t\tsnd_ctl_build_ioff(id, kctl, jidx);\n\t\t\t\tid++;\n\t\t\t\tspace--;\n\t\t\t\tlist.used++;\n\t\t\t}\n\t\t\tplist = plist->next;\n\t\t\toffset = 0;\n\t\t}\n\t\tup_read(&card->controls_rwsem);\n\t\tif (list.used > 0 &&\n\t\t    copy_to_user(list.pids, dst,\n\t\t\t\t list.used * sizeof(struct snd_ctl_elem_id))) {\n\t\t\tvfree(dst);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tvfree(dst);\n\t} else {\n\t\tdown_read(&card->controls_rwsem);\n\t\tlist.count = card->controls_count;\n\t\tup_read(&card->controls_rwsem);\n\t}\n\tif (copy_to_user(_list, &list, sizeof(list)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_info(struct snd_ctl_file *ctl,\n\t\t\t     struct snd_ctl_elem_info *info)\n{\n\tstruct snd_card *card = ctl->card;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\t\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &info->id);\n\tif (kctl == NULL) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n#ifdef CONFIG_SND_DEBUG\n\tinfo->access = 0;\n#endif\n\tresult = kctl->info(kctl, info);\n\tif (result >= 0) {\n\t\tsnd_BUG_ON(info->access);\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &info->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tsnd_ctl_build_ioff(&info->id, kctl, index_offset);\n\t\tinfo->access = vd->access;\n\t\tif (vd->owner) {\n\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_LOCK;\n\t\t\tif (vd->owner == ctl)\n\t\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_OWNER;\n\t\t\tinfo->owner = pid_vnr(vd->owner->pid);\n\t\t} else {\n\t\t\tinfo->owner = -1;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tsnd_power_lock(ctl->card);\n\tresult = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_info(ctl, &info);\n\tsnd_power_unlock(ctl->card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif ((vd->access & SNDRV_CTL_ELEM_ACCESS_READ) &&\n\t\t    kctl->get != NULL) {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->get(kctl, control);\n\t\t} else\n\t\t\tresult = -EPERM;\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_read(card, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &control->id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\t\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_unlock(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\t\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner == NULL)\n\t\t\tresult = -EINVAL;\n\t\telse if (vd->owner != file)\n\t\t\tresult = -EPERM;\n\t\telse {\n\t\t\tvd->owner = NULL;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstruct user_element {\n\tstruct snd_ctl_elem_info info;\n\tstruct snd_card *card;\n\tvoid *elem_data;\t\t/* element data */\n\tunsigned long elem_data_size;\t/* size of element data in bytes */\n\tvoid *tlv_data;\t\t\t/* TLV data */\n\tunsigned long tlv_data_size;\t/* TLV data size */\n\tvoid *priv_data;\t\t/* private data (like strings for enumerated type) */\n};\n\nstatic int snd_ctl_elem_user_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\t*uinfo = ue->info;\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tconst char *names;\n\tunsigned int item;\n\n\titem = uinfo->value.enumerated.item;\n\n\t*uinfo = ue->info;\n\n\titem = min(item, uinfo->value.enumerated.items - 1);\n\tuinfo->value.enumerated.item = item;\n\n\tnames = ue->priv_data;\n\tfor (; item > 0; --item)\n\t\tnames += strlen(names) + 1;\n\tstrcpy(uinfo->value.enumerated.name, names);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn change;\n}\n\nstatic int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t} else {\n\t\tint ret = 0;\n\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tif (!ue->tlv_data_size || !ue->tlv_data) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (size < ue->tlv_data_size) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\tret = -EFAULT;\nerr_unlock:\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn change;\n}\n\nstatic int snd_ctl_elem_init_enum_names(struct user_element *ue)\n{\n\tchar *names, *p;\n\tsize_t buf_len, name_len;\n\tunsigned int i;\n\tconst uintptr_t user_ptrval = ue->info.value.enumerated.names_ptr;\n\n\tif (ue->info.value.enumerated.names_length > 64 * 1024)\n\t\treturn -EINVAL;\n\n\tnames = memdup_user((const void __user *)user_ptrval,\n\t\tue->info.value.enumerated.names_length);\n\tif (IS_ERR(names))\n\t\treturn PTR_ERR(names);\n\n\t/* check that there are enough valid names */\n\tbuf_len = ue->info.value.enumerated.names_length;\n\tp = names;\n\tfor (i = 0; i < ue->info.value.enumerated.items; ++i) {\n\t\tname_len = strnlen(p, buf_len);\n\t\tif (name_len == 0 || name_len >= 64 || name_len == buf_len) {\n\t\t\tkfree(names);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp += name_len + 1;\n\t\tbuf_len -= name_len + 1;\n\t}\n\n\tue->priv_data = names;\n\tue->info.value.enumerated.names_ptr = 0;\n\n\treturn 0;\n}\n\nstatic void snd_ctl_elem_user_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tkfree(ue->tlv_data);\n\tkfree(ue->priv_data);\n\tkfree(ue);\n}\n\nstatic int snd_ctl_elem_add(struct snd_ctl_file *file,\n\t\t\t    struct snd_ctl_elem_info *info, int replace)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol kctl, *_kctl;\n\tunsigned int access;\n\tlong private_size;\n\tstruct user_element *ue;\n\tint idx, err;\n\n\tif (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)\n\t\treturn -ENOMEM;\n\tif (info->count < 1)\n\t\treturn -EINVAL;\n\taccess = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));\n\tinfo->id.numid = 0;\n\tmemset(&kctl, 0, sizeof(kctl));\n\tdown_write(&card->controls_rwsem);\n\t_kctl = snd_ctl_find_id(card, &info->id);\n\terr = 0;\n\tif (_kctl) {\n\t\tif (replace)\n\t\t\terr = snd_ctl_remove(card, _kctl);\n\t\telse\n\t\t\terr = -EBUSY;\n\t} else {\n\t\tif (replace)\n\t\t\terr = -ENOENT;\n\t}\n\tup_write(&card->controls_rwsem);\n\tif (err < 0)\n\t\treturn err;\n\tmemcpy(&kctl.id, &info->id, sizeof(info->id));\n\tkctl.count = info->owner ? info->owner : 1;\n\taccess |= SNDRV_CTL_ELEM_ACCESS_USER;\n\tif (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)\n\t\tkctl.info = snd_ctl_elem_user_enum_info;\n\telse\n\t\tkctl.info = snd_ctl_elem_user_info;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_READ)\n\t\tkctl.get = snd_ctl_elem_user_get;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_WRITE)\n\t\tkctl.put = snd_ctl_elem_user_put;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {\n\t\tkctl.tlv.c = snd_ctl_elem_user_tlv;\n\t\taccess |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t}\n\tswitch (info->type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tprivate_size = sizeof(long);\n\t\tif (info->count > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tprivate_size = sizeof(long long);\n\t\tif (info->count > 64)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tprivate_size = sizeof(unsigned int);\n\t\tif (info->count > 128 || info->value.enumerated.items == 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_BYTES:\n\t\tprivate_size = sizeof(unsigned char);\n\t\tif (info->count > 512)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_IEC958:\n\t\tprivate_size = sizeof(struct snd_aes_iec958);\n\t\tif (info->count != 1)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tprivate_size *= info->count;\n\tue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);\n\tif (ue == NULL)\n\t\treturn -ENOMEM;\n\tue->card = card;\n\tue->info = *info;\n\tue->info.access = 0;\n\tue->elem_data = (char *)ue + sizeof(*ue);\n\tue->elem_data_size = private_size;\n\tif (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {\n\t\terr = snd_ctl_elem_init_enum_names(ue);\n\t\tif (err < 0) {\n\t\t\tkfree(ue);\n\t\t\treturn err;\n\t\t}\n\t}\n\tkctl.private_free = snd_ctl_elem_user_free;\n\t_kctl = snd_ctl_new(&kctl, access);\n\tif (_kctl == NULL) {\n\t\tkfree(ue->priv_data);\n\t\tkfree(ue);\n\t\treturn -ENOMEM;\n\t}\n\t_kctl->private_data = ue;\n\tfor (idx = 0; idx < _kctl->count; idx++)\n\t\t_kctl->vd[idx].owner = file;\n\terr = snd_ctl_add(card, _kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tdown_write(&card->controls_rwsem);\n\tcard->user_ctl_count++;\n\tup_write(&card->controls_rwsem);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_add_user(struct snd_ctl_file *file,\n\t\t\t\t struct snd_ctl_elem_info __user *_info, int replace)\n{\n\tstruct snd_ctl_elem_info info;\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_elem_add(file, &info, replace);\n}\n\nstatic int snd_ctl_elem_remove(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_ctl_elem_id id;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_remove_user_ctl(file, &id);\n}\n\nstatic int snd_ctl_subscribe_events(struct snd_ctl_file *file, int __user *ptr)\n{\n\tint subscribe;\n\tif (get_user(subscribe, ptr))\n\t\treturn -EFAULT;\n\tif (subscribe < 0) {\n\t\tsubscribe = file->subscribed;\n\t\tif (put_user(subscribe, ptr))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tif (subscribe) {\n\t\tfile->subscribed = 1;\n\t\treturn 0;\n\t} else if (file->subscribed) {\n\t\tsnd_ctl_empty_read_queue(file);\n\t\tfile->subscribed = 0;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,\n                             struct snd_ctl_tlv __user *_tlv,\n                             int op_flag)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_tlv tlv;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int len;\n\tint err = 0;\n\n\tif (copy_from_user(&tlv, _tlv, sizeof(tlv)))\n\t\treturn -EFAULT;\n\tif (tlv.length < sizeof(unsigned int) * 2)\n\t\treturn -EINVAL;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid(card, tlv.numid);\n\tif (kctl == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto __kctl_end;\n\t}\n\tif (kctl->tlv.p == NULL) {\n\t\terr = -ENXIO;\n\t\tgoto __kctl_end;\n\t}\n\tvd = &kctl->vd[tlv.numid - kctl->id.numid];\n\tif ((op_flag == 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) == 0) ||\n\t    (op_flag > 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) == 0) ||\n\t    (op_flag < 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) == 0)) {\n\t    \terr = -ENXIO;\n\t    \tgoto __kctl_end;\n\t}\n\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\tif (vd->owner != NULL && vd->owner != file) {\n\t\t\terr = -EPERM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\terr = kctl->tlv.c(kctl, op_flag, tlv.length, _tlv->tlv);\n\t\tif (err > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &kctl->id);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (op_flag) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tlen = kctl->tlv.p[1] + 2 * sizeof(unsigned int);\n\t\tif (tlv.length < len) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tif (copy_to_user(_tlv->tlv, kctl->tlv.p, len))\n\t\t\terr = -EFAULT;\n\t}\n      __kctl_end:\n\tup_read(&card->controls_rwsem);\n\treturn err;\n}\n\nstatic long snd_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_card *card;\n\tstruct snd_kctl_ioctl *p;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *ip = argp;\n\tint err;\n\n\tctl = file->private_data;\n\tcard = ctl->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_CTL_VERSION, ip) ? -EFAULT : 0;\n\tcase SNDRV_CTL_IOCTL_CARD_INFO:\n\t\treturn snd_ctl_card_info(card, ctl, cmd, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LIST:\n\t\treturn snd_ctl_elem_list(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_INFO:\n\t\treturn snd_ctl_elem_info_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_READ:\n\t\treturn snd_ctl_elem_read_user(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_WRITE:\n\t\treturn snd_ctl_elem_write_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LOCK:\n\t\treturn snd_ctl_elem_lock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_UNLOCK:\n\t\treturn snd_ctl_elem_unlock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_ADD:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_ELEM_REPLACE:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_ELEM_REMOVE:\n\t\treturn snd_ctl_elem_remove(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:\n\t\treturn snd_ctl_subscribe_events(ctl, ip);\n\tcase SNDRV_CTL_IOCTL_TLV_READ:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_TLV_WRITE:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_TLV_COMMAND:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, -1);\n\tcase SNDRV_CTL_IOCTL_POWER:\n\t\treturn -ENOPROTOOPT;\n\tcase SNDRV_CTL_IOCTL_POWER_STATE:\n#ifdef CONFIG_PM\n\t\treturn put_user(card->power_state, ip) ? -EFAULT : 0;\n#else\n\t\treturn put_user(SNDRV_CTL_POWER_D0, ip) ? -EFAULT : 0;\n#endif\n\t}\n\tdown_read(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, &snd_control_ioctls, list) {\n\t\terr = p->fioctl(card, ctl, cmd, arg);\n\t\tif (err != -ENOIOCTLCMD) {\n\t\t\tup_read(&snd_ioctl_rwsem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tup_read(&snd_ioctl_rwsem);\n\tdev_dbg(card->dev, \"unknown ioctl = 0x%x\\n\", cmd);\n\treturn -ENOTTY;\n}\n\nstatic ssize_t snd_ctl_read(struct file *file, char __user *buffer,\n\t\t\t    size_t count, loff_t * offset)\n{\n\tstruct snd_ctl_file *ctl;\n\tint err = 0;\n\tssize_t result = 0;\n\n\tctl = file->private_data;\n\tif (snd_BUG_ON(!ctl || !ctl->card))\n\t\treturn -ENXIO;\n\tif (!ctl->subscribed)\n\t\treturn -EBADFD;\n\tif (count < sizeof(struct snd_ctl_event))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctl->read_lock);\n\twhile (count >= sizeof(struct snd_ctl_event)) {\n\t\tstruct snd_ctl_event ev;\n\t\tstruct snd_kctl_event *kev;\n\t\twhile (list_empty(&ctl->events)) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto __end_lock;\n\t\t\t}\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ctl->read_lock);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tif (ctl->card->shutdown)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tspin_lock_irq(&ctl->read_lock);\n\t\t}\n\t\tkev = snd_kctl_event(ctl->events.next);\n\t\tev.type = SNDRV_CTL_EVENT_ELEM;\n\t\tev.data.elem.mask = kev->mask;\n\t\tev.data.elem.id = kev->id;\n\t\tlist_del(&kev->list);\n\t\tspin_unlock_irq(&ctl->read_lock);\n\t\tkfree(kev);\n\t\tif (copy_to_user(buffer, &ev, sizeof(struct snd_ctl_event))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __end;\n\t\t}\n\t\tspin_lock_irq(&ctl->read_lock);\n\t\tbuffer += sizeof(struct snd_ctl_event);\n\t\tcount -= sizeof(struct snd_ctl_event);\n\t\tresult += sizeof(struct snd_ctl_event);\n\t}\n      __end_lock:\n\tspin_unlock_irq(&ctl->read_lock);\n      __end:\n      \treturn result > 0 ? result : err;\n}\n\nstatic unsigned int snd_ctl_poll(struct file *file, poll_table * wait)\n{\n\tunsigned int mask;\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\tif (!ctl->subscribed)\n\t\treturn 0;\n\tpoll_wait(file, &ctl->change_sleep, wait);\n\n\tmask = 0;\n\tif (!list_empty(&ctl->events))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\treturn mask;\n}\n\n/*\n * register the device-specific control-ioctls.\n * called from each device manager like pcm.c, hwdep.c, etc.\n */\nstatic int _snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn, struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *pn;\n\n\tpn = kzalloc(sizeof(struct snd_kctl_ioctl), GFP_KERNEL);\n\tif (pn == NULL)\n\t\treturn -ENOMEM;\n\tpn->fioctl = fcn;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_add_tail(&pn->list, lists);\n\tup_write(&snd_ioctl_rwsem);\n\treturn 0;\n}\n\nint snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_register_ioctl);\n\n#ifdef CONFIG_COMPAT\nint snd_ctl_register_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_compat_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_register_ioctl_compat);\n#endif\n\n/*\n * de-register the device-specific control-ioctls.\n */\nstatic int _snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn,\n\t\t\t\t     struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *p;\n\n\tif (snd_BUG_ON(!fcn))\n\t\treturn -EINVAL;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, lists, list) {\n\t\tif (p->fioctl == fcn) {\n\t\t\tlist_del(&p->list);\n\t\t\tup_write(&snd_ioctl_rwsem);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_write(&snd_ioctl_rwsem);\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\nint snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl);\n\n#ifdef CONFIG_COMPAT\nint snd_ctl_unregister_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_compat_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);\n#endif\n\nstatic int snd_ctl_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\treturn fasync_helper(fd, file, on, &ctl->fasync);\n}\n\n/*\n * ioctl32 compat\n */\n#ifdef CONFIG_COMPAT\n#include \"control_compat.c\"\n#else\n#define snd_ctl_ioctl_compat\tNULL\n#endif\n\n/*\n *  INIT PART\n */\n\nstatic const struct file_operations snd_ctl_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_ctl_read,\n\t.open =\t\tsnd_ctl_open,\n\t.release =\tsnd_ctl_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_ctl_poll,\n\t.unlocked_ioctl =\tsnd_ctl_ioctl,\n\t.compat_ioctl =\tsnd_ctl_ioctl_compat,\n\t.fasync =\tsnd_ctl_fasync,\n};\n\n/*\n * registration of the control device\n */\nstatic int snd_ctl_dev_register(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tint err, cardnum;\n\tchar name[16];\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\tsprintf(name, \"controlC%i\", cardnum);\n\tif ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,\n\t\t\t\t       &snd_ctl_f_ops, card, name)) < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n/*\n * disconnection of the control device\n */\nstatic int snd_ctl_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_ctl_file *ctl;\n\tint err, cardnum;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\n\tread_lock(&card->ctl_files_rwlock);\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\twake_up(&ctl->change_sleep);\n\t\tkill_fasync(&ctl->fasync, SIGIO, POLL_ERR);\n\t}\n\tread_unlock(&card->ctl_files_rwlock);\n\n\tif ((err = snd_unregister_device(SNDRV_DEVICE_TYPE_CONTROL,\n\t\t\t\t\t card, -1)) < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n/*\n * free all controls\n */\nstatic int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\tsnd_ctl_remove(card, control);\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\n\n/*\n * create control core:\n * called from init.c\n */\nint snd_ctl_create(struct snd_card *card)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\treturn snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n}\n\n/*\n * Frequently used control callbacks/helpers\n */\nint snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_boolean_mono_info);\n\nint snd_ctl_boolean_stereo_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_boolean_stereo_info);\n\n/**\n * snd_ctl_enum_info - fills the info structure for an enumerated control\n * @info: the structure to be filled\n * @channels: the number of the control's channels; often one\n * @items: the number of control values; also the size of @names\n * @names: an array containing the names of all control values\n *\n * Sets all required fields in @info to their appropriate values.\n * If the control's accessibility is not the default (readable and writable),\n * the caller has to fill @info->access.\n *\n * Return: Zero.\n */\nint snd_ctl_enum_info(struct snd_ctl_elem_info *info, unsigned int channels,\n\t\t      unsigned int items, const char *const names[])\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tinfo->count = channels;\n\tinfo->value.enumerated.items = items;\n\tif (info->value.enumerated.item >= items)\n\t\tinfo->value.enumerated.item = items - 1;\n\tstrlcpy(info->value.enumerated.name,\n\t\tnames[info->value.enumerated.item],\n\t\tsizeof(info->value.enumerated.name));\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_enum_info);\n", "/*\n *  Initialization routines\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/pm.h>\n#include <linux/completion.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n\n/* monitor files for graceful shutdown (hotplug) */\nstruct snd_monitor_file {\n\tstruct file *file;\n\tconst struct file_operations *disconnected_f_op;\n\tstruct list_head shutdown_list;\t/* still need to shutdown */\n\tstruct list_head list;\t/* link of monitor files */\n};\n\nstatic DEFINE_SPINLOCK(shutdown_lock);\nstatic LIST_HEAD(shutdown_files);\n\nstatic const struct file_operations snd_shutdown_f_ops;\n\n/* locked for registering/using */\nstatic DECLARE_BITMAP(snd_cards_lock, SNDRV_CARDS);\nstruct snd_card *snd_cards[SNDRV_CARDS];\nEXPORT_SYMBOL(snd_cards);\n\nstatic DEFINE_MUTEX(snd_card_mutex);\n\nstatic char *slots[SNDRV_CARDS];\nmodule_param_array(slots, charp, NULL, 0444);\nMODULE_PARM_DESC(slots, \"Module names assigned to the slots.\");\n\n/* return non-zero if the given index is reserved for the given\n * module via slots option\n */\nstatic int module_slot_match(struct module *module, int idx)\n{\n\tint match = 1;\n#ifdef MODULE\n\tconst char *s1, *s2;\n\n\tif (!module || !*module->name || !slots[idx])\n\t\treturn 0;\n\n\ts1 = module->name;\n\ts2 = slots[idx];\n\tif (*s2 == '!') {\n\t\tmatch = 0; /* negative match */\n\t\ts2++;\n\t}\n\t/* compare module name strings\n\t * hyphens are handled as equivalent with underscore\n\t */\n\tfor (;;) {\n\t\tchar c1 = *s1++;\n\t\tchar c2 = *s2++;\n\t\tif (c1 == '-')\n\t\t\tc1 = '_';\n\t\tif (c2 == '-')\n\t\t\tc2 = '_';\n\t\tif (c1 != c2)\n\t\t\treturn !match;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n#endif /* MODULE */\n\treturn match;\n}\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\nint (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);\nEXPORT_SYMBOL(snd_mixer_oss_notify_callback);\n#endif\n\n#ifdef CONFIG_PROC_FS\nstatic void snd_card_id_read(struct snd_info_entry *entry,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tsnd_iprintf(buffer, \"%s\\n\", entry->card->id);\n}\n\nstatic inline int init_info_for_card(struct snd_card *card)\n{\n\tint err;\n\tstruct snd_info_entry *entry;\n\n\tif ((err = snd_info_card_register(card)) < 0) {\n\t\tdev_dbg(card->dev, \"unable to create card info\\n\");\n\t\treturn err;\n\t}\n\tif ((entry = snd_info_create_card_entry(card, \"id\", card->proc_root)) == NULL) {\n\t\tdev_dbg(card->dev, \"unable to create card entry\\n\");\n\t\treturn err;\n\t}\n\tentry->c.text.read = snd_card_id_read;\n\tif (snd_info_register(entry) < 0) {\n\t\tsnd_info_free_entry(entry);\n\t\tentry = NULL;\n\t}\n\tcard->proc_id = entry;\n\treturn 0;\n}\n#else /* !CONFIG_PROC_FS */\n#define init_info_for_card(card)\n#endif\n\nstatic int check_empty_slot(struct module *module, int slot)\n{\n\treturn !slots[slot] || !*slots[slot];\n}\n\n/* return an empty slot number (>= 0) found in the given bitmask @mask.\n * @mask == -1 == 0xffffffff means: take any free slot up to 32\n * when no slot is available, return the original @mask as is.\n */\nstatic int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),\n\t\t\t\t struct module *module)\n{\n\tint slot;\n\n\tfor (slot = 0; slot < SNDRV_CARDS; slot++) {\n\t\tif (slot < 32 && !(mask & (1U << slot)))\n\t\t\tcontinue;\n\t\tif (!test_bit(slot, snd_cards_lock)) {\n\t\t\tif (check(module, slot))\n\t\t\t\treturn slot; /* found */\n\t\t}\n\t}\n\treturn mask; /* unchanged */\n}\n\nstatic int snd_card_do_free(struct snd_card *card);\nstatic const struct attribute_group *card_dev_attr_groups[];\n\nstatic void release_card_device(struct device *dev)\n{\n\tsnd_card_do_free(dev_to_snd_card(dev));\n}\n\n/**\n *  snd_card_new - create and initialize a soundcard structure\n *  @parent: the parent device object\n *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]\n *  @xid: card identification (ASCII string)\n *  @module: top level module for locking\n *  @extra_size: allocate this extra size after the main soundcard structure\n *  @card_ret: the pointer to store the created card instance\n *\n *  Creates and initializes a soundcard structure.\n *\n *  The function allocates snd_card instance via kzalloc with the given\n *  space for the driver to use freely.  The allocated struct is stored\n *  in the given card_ret pointer.\n *\n *  Return: Zero if successful or a negative error code.\n */\nint snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t    struct module *module, int extra_size,\n\t\t    struct snd_card **card_ret)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (snd_BUG_ON(!card_ret))\n\t\treturn -EINVAL;\n\t*card_ret = NULL;\n\n\tif (extra_size < 0)\n\t\textra_size = 0;\n\tcard = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tif (extra_size > 0)\n\t\tcard->private_data = (char *)card + sizeof(struct snd_card);\n\tif (xid)\n\t\tstrlcpy(card->id, xid, sizeof(card->id));\n\terr = 0;\n\tmutex_lock(&snd_card_mutex);\n\tif (idx < 0) /* first check the matching module-name slot */\n\t\tidx = get_slot_from_bitmask(idx, module_slot_match, module);\n\tif (idx < 0) /* if not matched, assign an empty slot */\n\t\tidx = get_slot_from_bitmask(idx, check_empty_slot, module);\n\tif (idx < 0)\n\t\terr = -ENODEV;\n\telse if (idx < snd_ecards_limit) {\n\t\tif (test_bit(idx, snd_cards_lock))\n\t\t\terr = -EBUSY;\t/* invalid */\n\t} else if (idx >= SNDRV_CARDS)\n\t\terr = -ENODEV;\n\tif (err < 0) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\tdev_err(parent, \"cannot find the slot for index %d (range 0-%i), error: %d\\n\",\n\t\t\t idx, snd_ecards_limit - 1, err);\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\tset_bit(idx, snd_cards_lock);\t\t/* lock it */\n\tif (idx >= snd_ecards_limit)\n\t\tsnd_ecards_limit = idx + 1; /* increase the limit */\n\tmutex_unlock(&snd_card_mutex);\n\tcard->dev = parent;\n\tcard->number = idx;\n\tcard->module = module;\n\tINIT_LIST_HEAD(&card->devices);\n\tinit_rwsem(&card->controls_rwsem);\n\trwlock_init(&card->ctl_files_rwlock);\n\tmutex_init(&card->user_ctl_lock);\n\tINIT_LIST_HEAD(&card->controls);\n\tINIT_LIST_HEAD(&card->ctl_files);\n\tspin_lock_init(&card->files_lock);\n\tINIT_LIST_HEAD(&card->files_list);\n#ifdef CONFIG_PM\n\tmutex_init(&card->power_lock);\n\tinit_waitqueue_head(&card->power_sleep);\n#endif\n\n\tdevice_initialize(&card->card_dev);\n\tcard->card_dev.parent = parent;\n\tcard->card_dev.class = sound_class;\n\tcard->card_dev.release = release_card_device;\n\tcard->card_dev.groups = card_dev_attr_groups;\n\terr = kobject_set_name(&card->card_dev.kobj, \"card%d\", idx);\n\tif (err < 0)\n\t\tgoto __error;\n\n\t/* the control interface cannot be accessed from the user space until */\n\t/* snd_cards_bitmask and snd_cards are set with snd_card_register */\n\terr = snd_ctl_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to register control minors\\n\");\n\t\tgoto __error;\n\t}\n\terr = snd_info_card_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to create card info\\n\");\n\t\tgoto __error_ctl;\n\t}\n\t*card_ret = card;\n\treturn 0;\n\n      __error_ctl:\n\tsnd_device_free_all(card);\n      __error:\n\tput_device(&card->card_dev);\n  \treturn err;\n}\nEXPORT_SYMBOL(snd_card_new);\n\n/* return non-zero if a card is already locked */\nint snd_card_locked(int card)\n{\n\tint locked;\n\n\tmutex_lock(&snd_card_mutex);\n\tlocked = test_bit(card, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\treturn locked;\n}\n\nstatic loff_t snd_disconnect_llseek(struct file *file, loff_t offset, int orig)\n{\n\treturn -ENODEV;\n}\n\nstatic ssize_t snd_disconnect_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\treturn -ENODEV;\n}\n\nstatic ssize_t snd_disconnect_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *offset)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_monitor_file *df = NULL, *_df;\n\n\tspin_lock(&shutdown_lock);\n\tlist_for_each_entry(_df, &shutdown_files, shutdown_list) {\n\t\tif (_df->file == file) {\n\t\t\tdf = _df;\n\t\t\tlist_del_init(&df->shutdown_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&shutdown_lock);\n\n\tif (likely(df)) {\n\t\tif ((file->f_flags & FASYNC) && df->disconnected_f_op->fasync)\n\t\t\tdf->disconnected_f_op->fasync(-1, file, 0);\n\t\treturn df->disconnected_f_op->release(inode, file);\n\t}\n\n\tpanic(\"%s(%p, %p) failed!\", __func__, inode, file);\n}\n\nstatic unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)\n{\n\treturn POLLERR | POLLNVAL;\n}\n\nstatic long snd_disconnect_ioctl(struct file *file,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_fasync(int fd, struct file *file, int on)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct file_operations snd_shutdown_f_ops =\n{\n\t.owner = \tTHIS_MODULE,\n\t.llseek =\tsnd_disconnect_llseek,\n\t.read = \tsnd_disconnect_read,\n\t.write =\tsnd_disconnect_write,\n\t.release =\tsnd_disconnect_release,\n\t.poll =\t\tsnd_disconnect_poll,\n\t.unlocked_ioctl = snd_disconnect_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = snd_disconnect_ioctl,\n#endif\n\t.mmap =\t\tsnd_disconnect_mmap,\n\t.fasync =\tsnd_disconnect_fasync\n};\n\n/**\n *  snd_card_disconnect - disconnect all APIs from the file-operations (user space)\n *  @card: soundcard structure\n *\n *  Disconnects all APIs from the file-operations (user space).\n *\n *  Return: Zero, otherwise a negative error code.\n *\n *  Note: The current implementation replaces all active file->f_op with special\n *        dummy file operations (they do nothing except release).\n */\nint snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\tint err;\n\n\tif (!card)\n\t\treturn -EINVAL;\n\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\n\t/* phase 1: disable fops (user space) operations for ALSA API */\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\t\n\t/* phase 2: replace file->f_op with special dummy operations */\n\t\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\t/* it's critical part, use endless loop */\n\t\t/* we have no room to fail */\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n\n\t/* phase 3: notify all connected devices about disconnection */\n\t/* at this point, they cannot respond to any calls except release() */\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\n\t/* notify all devices that we are disconnected */\n\terr = snd_device_disconnect_all(card);\n\tif (err < 0)\n\t\tdev_err(card->dev, \"not all devices for card %i can be disconnected\\n\", card->number);\n\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}\n\nEXPORT_SYMBOL(snd_card_disconnect);\n\n/**\n *  snd_card_free - frees given soundcard structure\n *  @card: soundcard structure\n *\n *  This function releases the soundcard structure and the all assigned\n *  devices automatically.  That is, you don't have to release the devices\n *  by yourself.\n *\n *  Return: Zero. Frees all associated devices and frees the control\n *  interface associated to given soundcard.\n */\nstatic int snd_card_do_free(struct snd_card *card)\n{\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);\n#endif\n\tsnd_device_free_all(card);\n\tif (card->private_free)\n\t\tcard->private_free(card);\n\tsnd_info_free_entry(card->proc_id);\n\tif (snd_info_card_free(card) < 0) {\n\t\tdev_warn(card->dev, \"unable to free card info\\n\");\n\t\t/* Not fatal error */\n\t}\n\tif (card->release_completion)\n\t\tcomplete(card->release_completion);\n\tkfree(card);\n\treturn 0;\n}\n\nint snd_card_free_when_closed(struct snd_card *card)\n{\n\tint ret = snd_card_disconnect(card);\n\tif (ret)\n\t\treturn ret;\n\tput_device(&card->card_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_card_free_when_closed);\n\nint snd_card_free(struct snd_card *card)\n{\n\tstruct completion released;\n\tint ret;\n\n\tinit_completion(&released);\n\tcard->release_completion = &released;\n\tret = snd_card_free_when_closed(card);\n\tif (ret)\n\t\treturn ret;\n\t/* wait, until all devices are ready for the free operation */\n\twait_for_completion(&released);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_card_free);\n\n/* retrieve the last word of shortname or longname */\nstatic const char *retrieve_id_from_card_name(const char *name)\n{\n\tconst char *spos = name;\n\n\twhile (*name) {\n\t\tif (isspace(*name) && isalnum(name[1]))\n\t\t\tspos = name + 1;\n\t\tname++;\n\t}\n\treturn spos;\n}\n\n/* return true if the given id string doesn't conflict any other card ids */\nstatic bool card_id_ok(struct snd_card *card, const char *id)\n{\n\tint i;\n\tif (!snd_info_check_reserved_words(id))\n\t\treturn false;\n\tfor (i = 0; i < snd_ecards_limit; i++) {\n\t\tif (snd_cards[i] && snd_cards[i] != card &&\n\t\t    !strcmp(snd_cards[i]->id, id))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* copy to card->id only with valid letters from nid */\nstatic void copy_valid_id_string(struct snd_card *card, const char *src,\n\t\t\t\t const char *nid)\n{\n\tchar *id = card->id;\n\n\twhile (*nid && !isalnum(*nid))\n\t\tnid++;\n\tif (isdigit(*nid))\n\t\t*id++ = isalpha(*src) ? *src : 'D';\n\twhile (*nid && (size_t)(id - card->id) < sizeof(card->id) - 1) {\n\t\tif (isalnum(*nid))\n\t\t\t*id++ = *nid;\n\t\tnid++;\n\t}\n\t*id = 0;\n}\n\n/* Set card->id from the given string\n * If the string conflicts with other ids, add a suffix to make it unique.\n */\nstatic void snd_card_set_id_no_lock(struct snd_card *card, const char *src,\n\t\t\t\t    const char *nid)\n{\n\tint len, loops;\n\tbool is_default = false;\n\tchar *id;\n\t\n\tcopy_valid_id_string(card, src, nid);\n\tid = card->id;\n\n again:\n\t/* use \"Default\" for obviously invalid strings\n\t * (\"card\" conflicts with proc directories)\n\t */\n\tif (!*id || !strncmp(id, \"card\", 4)) {\n\t\tstrcpy(id, \"Default\");\n\t\tis_default = true;\n\t}\n\n\tlen = strlen(id);\n\tfor (loops = 0; loops < SNDRV_CARDS; loops++) {\n\t\tchar *spos;\n\t\tchar sfxstr[5]; /* \"_012\" */\n\t\tint sfxlen;\n\n\t\tif (card_id_ok(card, id))\n\t\t\treturn; /* OK */\n\n\t\t/* Add _XYZ suffix */\n\t\tsprintf(sfxstr, \"_%X\", loops + 1);\n\t\tsfxlen = strlen(sfxstr);\n\t\tif (len + sfxlen >= sizeof(card->id))\n\t\t\tspos = id + sizeof(card->id) - sfxlen - 1;\n\t\telse\n\t\t\tspos = id + len;\n\t\tstrcpy(spos, sfxstr);\n\t}\n\t/* fallback to the default id */\n\tif (!is_default) {\n\t\t*id = 0;\n\t\tgoto again;\n\t}\n\t/* last resort... */\n\tdev_err(card->dev, \"unable to set card id (%s)\\n\", id);\n\tif (card->proc_root->name)\n\t\tstrlcpy(card->id, card->proc_root->name, sizeof(card->id));\n}\n\n/**\n *  snd_card_set_id - set card identification name\n *  @card: soundcard structure\n *  @nid: new identification string\n *\n *  This function sets the card identification and checks for name\n *  collisions.\n */\nvoid snd_card_set_id(struct snd_card *card, const char *nid)\n{\n\t/* check if user specified own card->id */\n\tif (card->id[0] != '\\0')\n\t\treturn;\n\tmutex_lock(&snd_card_mutex);\n\tsnd_card_set_id_no_lock(card, nid, nid);\n\tmutex_unlock(&snd_card_mutex);\n}\nEXPORT_SYMBOL(snd_card_set_id);\n\nstatic ssize_t\ncard_id_show_attr(struct device *dev,\n\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", card->id);\n}\n\nstatic ssize_t\ncard_id_store_attr(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\tchar buf1[sizeof(card->id)];\n\tsize_t copy = count > sizeof(card->id) - 1 ?\n\t\t\t\t\tsizeof(card->id) - 1 : count;\n\tsize_t idx;\n\tint c;\n\n\tfor (idx = 0; idx < copy; idx++) {\n\t\tc = buf[idx];\n\t\tif (!isalnum(c) && c != '_' && c != '-')\n\t\t\treturn -EINVAL;\n\t}\n\tmemcpy(buf1, buf, copy);\n\tbuf1[copy] = '\\0';\n\tmutex_lock(&snd_card_mutex);\n\tif (!card_id_ok(NULL, buf1)) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn -EEXIST;\n\t}\n\tstrcpy(card->id, buf1);\n\tsnd_info_card_id_change(card);\n\tmutex_unlock(&snd_card_mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(id, S_IRUGO | S_IWUSR, card_id_show_attr, card_id_store_attr);\n\nstatic ssize_t\ncard_number_show_attr(struct device *dev,\n\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\treturn snprintf(buf, PAGE_SIZE, \"%i\\n\", card->number);\n}\n\nstatic DEVICE_ATTR(number, S_IRUGO, card_number_show_attr, NULL);\n\nstatic struct attribute *card_dev_attrs[] = {\n\t&dev_attr_id.attr,\n\t&dev_attr_number.attr,\n\tNULL\n};\n\nstatic struct attribute_group card_dev_attr_group = {\n\t.attrs\t= card_dev_attrs,\n};\n\nstatic const struct attribute_group *card_dev_attr_groups[] = {\n\t&card_dev_attr_group,\n\tNULL\n};\n\n/**\n *  snd_card_register - register the soundcard\n *  @card: soundcard structure\n *\n *  This function registers all the devices assigned to the soundcard.\n *  Until calling this, the ALSA control interface is blocked from the\n *  external accesses.  Thus, you should call this function at the end\n *  of the initialization of the card.\n *\n *  Return: Zero otherwise a negative error code if the registration failed.\n */\nint snd_card_register(struct snd_card *card)\n{\n\tint err;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\n\tif (!card->registered) {\n\t\terr = device_add(&card->card_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcard->registered = true;\n\t}\n\n\tif ((err = snd_device_register_all(card)) < 0)\n\t\treturn err;\n\tmutex_lock(&snd_card_mutex);\n\tif (snd_cards[card->number]) {\n\t\t/* already registered */\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn 0;\n\t}\n\tif (*card->id) {\n\t\t/* make a unique id name from the given string */\n\t\tchar tmpid[sizeof(card->id)];\n\t\tmemcpy(tmpid, card->id, sizeof(card->id));\n\t\tsnd_card_set_id_no_lock(card, tmpid, tmpid);\n\t} else {\n\t\t/* create an id from either shortname or longname */\n\t\tconst char *src;\n\t\tsrc = *card->shortname ? card->shortname : card->longname;\n\t\tsnd_card_set_id_no_lock(card, src,\n\t\t\t\t\tretrieve_id_from_card_name(src));\n\t}\n\tsnd_cards[card->number] = card;\n\tmutex_unlock(&snd_card_mutex);\n\tinit_info_for_card(card);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n#endif\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_card_register);\n\n#ifdef CONFIG_PROC_FS\nstatic struct snd_info_entry *snd_card_info_entry;\n\nstatic void snd_card_info_read(struct snd_info_entry *entry,\n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tint idx, count;\n\tstruct snd_card *card;\n\n\tfor (idx = count = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tif ((card = snd_cards[idx]) != NULL) {\n\t\t\tcount++;\n\t\t\tsnd_iprintf(buffer, \"%2i [%-15s]: %s - %s\\n\",\n\t\t\t\t\tidx,\n\t\t\t\t\tcard->id,\n\t\t\t\t\tcard->driver,\n\t\t\t\t\tcard->shortname);\n\t\t\tsnd_iprintf(buffer, \"                      %s\\n\",\n\t\t\t\t\tcard->longname);\n\t\t}\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n\tif (!count)\n\t\tsnd_iprintf(buffer, \"--- no soundcards ---\\n\");\n}\n\n#ifdef CONFIG_SND_OSSEMUL\n\nvoid snd_card_info_read_oss(struct snd_info_buffer *buffer)\n{\n\tint idx, count;\n\tstruct snd_card *card;\n\n\tfor (idx = count = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tif ((card = snd_cards[idx]) != NULL) {\n\t\t\tcount++;\n\t\t\tsnd_iprintf(buffer, \"%s\\n\", card->longname);\n\t\t}\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n\tif (!count) {\n\t\tsnd_iprintf(buffer, \"--- no soundcards ---\\n\");\n\t}\n}\n\n#endif\n\n#ifdef MODULE\nstatic struct snd_info_entry *snd_card_module_info_entry;\nstatic void snd_card_module_info_read(struct snd_info_entry *entry,\n\t\t\t\t      struct snd_info_buffer *buffer)\n{\n\tint idx;\n\tstruct snd_card *card;\n\n\tfor (idx = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tif ((card = snd_cards[idx]) != NULL)\n\t\t\tsnd_iprintf(buffer, \"%2i %s\\n\",\n\t\t\t\t    idx, card->module->name);\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n}\n#endif\n\nint __init snd_card_info_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"cards\", NULL);\n\tif (! entry)\n\t\treturn -ENOMEM;\n\tentry->c.text.read = snd_card_info_read;\n\tif (snd_info_register(entry) < 0) {\n\t\tsnd_info_free_entry(entry);\n\t\treturn -ENOMEM;\n\t}\n\tsnd_card_info_entry = entry;\n\n#ifdef MODULE\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"modules\", NULL);\n\tif (entry) {\n\t\tentry->c.text.read = snd_card_module_info_read;\n\t\tif (snd_info_register(entry) < 0)\n\t\t\tsnd_info_free_entry(entry);\n\t\telse\n\t\t\tsnd_card_module_info_entry = entry;\n\t}\n#endif\n\n\treturn 0;\n}\n\nint __exit snd_card_info_done(void)\n{\n\tsnd_info_free_entry(snd_card_info_entry);\n#ifdef MODULE\n\tsnd_info_free_entry(snd_card_module_info_entry);\n#endif\n\treturn 0;\n}\n\n#endif /* CONFIG_PROC_FS */\n\n/**\n *  snd_component_add - add a component string\n *  @card: soundcard structure\n *  @component: the component id string\n *\n *  This function adds the component id string to the supported list.\n *  The component can be referred from the alsa-lib.\n *\n *  Return: Zero otherwise a negative error code.\n */\n  \nint snd_component_add(struct snd_card *card, const char *component)\n{\n\tchar *ptr;\n\tint len = strlen(component);\n\n\tptr = strstr(card->components, component);\n\tif (ptr != NULL) {\n\t\tif (ptr[len] == '\\0' || ptr[len] == ' ')\t/* already there */\n\t\t\treturn 1;\n\t}\n\tif (strlen(card->components) + 1 + len + 1 > sizeof(card->components)) {\n\t\tsnd_BUG();\n\t\treturn -ENOMEM;\n\t}\n\tif (card->components[0] != '\\0')\n\t\tstrcat(card->components, \" \");\n\tstrcat(card->components, component);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_component_add);\n\n/**\n *  snd_card_file_add - add the file to the file list of the card\n *  @card: soundcard structure\n *  @file: file pointer\n *\n *  This function adds the file to the file linked-list of the card.\n *  This linked-list is used to keep tracking the connection state,\n *  and to avoid the release of busy resources by hotplug.\n *\n *  Return: zero or a negative error code.\n */\nint snd_card_file_add(struct snd_card *card, struct file *file)\n{\n\tstruct snd_monitor_file *mfile;\n\n\tmfile = kmalloc(sizeof(*mfile), GFP_KERNEL);\n\tif (mfile == NULL)\n\t\treturn -ENOMEM;\n\tmfile->file = file;\n\tmfile->disconnected_f_op = NULL;\n\tINIT_LIST_HEAD(&mfile->shutdown_list);\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\tkfree(mfile);\n\t\treturn -ENODEV;\n\t}\n\tlist_add(&mfile->list, &card->files_list);\n\tget_device(&card->card_dev);\n\tspin_unlock(&card->files_lock);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_card_file_add);\n\n/**\n *  snd_card_file_remove - remove the file from the file list\n *  @card: soundcard structure\n *  @file: file pointer\n *\n *  This function removes the file formerly added to the card via\n *  snd_card_file_add() function.\n *  If all files are removed and snd_card_free_when_closed() was\n *  called beforehand, it processes the pending release of\n *  resources.\n *\n *  Return: Zero or a negative error code.\n */\nint snd_card_file_remove(struct snd_card *card, struct file *file)\n{\n\tstruct snd_monitor_file *mfile, *found = NULL;\n\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tif (mfile->file == file) {\n\t\t\tlist_del(&mfile->list);\n\t\t\tspin_lock(&shutdown_lock);\n\t\t\tlist_del(&mfile->shutdown_list);\n\t\t\tspin_unlock(&shutdown_lock);\n\t\t\tif (mfile->disconnected_f_op)\n\t\t\t\tfops_put(mfile->disconnected_f_op);\n\t\t\tfound = mfile;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&card->files_lock);\n\tif (!found) {\n\t\tdev_err(card->dev, \"card file remove problem (%p)\\n\", file);\n\t\treturn -ENOENT;\n\t}\n\tkfree(found);\n\tput_device(&card->card_dev);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_card_file_remove);\n\n#ifdef CONFIG_PM\n/**\n *  snd_power_wait - wait until the power-state is changed.\n *  @card: soundcard structure\n *  @power_state: expected power state\n *\n *  Waits until the power-state is changed.\n *\n *  Return: Zero if successful, or a negative error code.\n *\n *  Note: the power lock must be active before call.\n */\nint snd_power_wait(struct snd_card *card, unsigned int power_state)\n{\n\twait_queue_t wait;\n\tint result = 0;\n\n\t/* fastpath */\n\tif (snd_power_get_state(card) == power_state)\n\t\treturn 0;\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&card->power_sleep, &wait);\n\twhile (1) {\n\t\tif (card->shutdown) {\n\t\t\tresult = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (snd_power_get_state(card) == power_state)\n\t\t\tbreak;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tsnd_power_unlock(card);\n\t\tschedule_timeout(30 * HZ);\n\t\tsnd_power_lock(card);\n\t}\n\tremove_wait_queue(&card->power_sleep, &wait);\n\treturn result;\n}\n\nEXPORT_SYMBOL(snd_power_wait);\n#endif /* CONFIG_PM */\n"], "filenames": ["include/sound/core.h", "sound/core/control.c", "sound/core/init.c"], "buggy_code_start_loc": [118, 993, 234], "buggy_code_end_loc": [118, 1212, 234], "fixing_code_start_loc": [119, 994, 235], "fixing_code_end_loc": [121, 1232, 236], "type": "CWE-362", "message": "Race condition in the tlv handler functionality in the snd_ctl_elem_user_tlv function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allows local users to obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access.", "other": {"cve": {"id": "CVE-2014-4652", "sourceIdentifier": "cve@mitre.org", "published": "2014-07-03T04:22:15.687", "lastModified": "2020-08-14T17:53:10.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race condition in the tlv handler functionality in the snd_ctl_elem_user_tlv function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allows local users to obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funcionalidad del manejador de tlv en la funci\u00f3n snd_ctl_elem_user_tlv en sound/core/control.c en la implementaci\u00f3n del control ALSA en el kernel de Linux anterior a 3.15.2 permite a usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel mediante el aprovechamiento del acceso a /dev/snd/controlCX"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.15.2", "matchCriteriaId": "588069C4-9D69-48F6-913F-2FEB3E643870"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:10:sp4:*:*:ltss:*:*:*", "matchCriteriaId": "35BBD83D-BDC7-4678-BE94-639F59281139"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=07f4d9d74a04aa7c72c5dae0ef97565f28f17b92", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1083.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1272.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/60545", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.15.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/06/26/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2334-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2335-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1113406", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/94412", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92"}}