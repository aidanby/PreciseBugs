{"buggy_code": ["/*\n * MXF demuxer.\n * Copyright (c) 2006 SmartJog S.A., Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/*\n * References\n * SMPTE 336M KLV Data Encoding Protocol Using Key-Length-Value\n * SMPTE 377M MXF File Format Specifications\n * SMPTE 378M Operational Pattern 1a\n * SMPTE 379M MXF Generic Container\n * SMPTE 381M Mapping MPEG Streams into the MXF Generic Container\n * SMPTE 382M Mapping AES3 and Broadcast Wave Audio into the MXF Generic Container\n * SMPTE 383M Mapping DV-DIF Data to the MXF Generic Container\n *\n * Principle\n * Search for Track numbers which will identify essence element KLV packets.\n * Search for SourcePackage which define tracks which contains Track numbers.\n * Material Package contains tracks with reference to SourcePackage tracks.\n * Search for Descriptors (Picture, Sound) which contains codec info and parameters.\n * Assign Descriptors to correct Tracks.\n *\n * Metadata reading functions read Local Tags, get InstanceUID(0x3C0A) then add MetaDataSet to MXFContext.\n * Metadata parsing resolves Strong References to objects.\n *\n * Simple demuxer, only OP1A supported and some files might not work at all.\n * Only tracks with associated descriptors will be decoded. \"Highly Desirable\" SMPTE 377M D.1\n */\n\n#include <inttypes.h>\n\n#include \"libavutil/aes.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavcodec/bytestream.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/timecode.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"mxf.h\"\n\ntypedef enum {\n    Header,\n    BodyPartition,\n    Footer\n} MXFPartitionType;\n\ntypedef enum {\n    OP1a = 1,\n    OP1b,\n    OP1c,\n    OP2a,\n    OP2b,\n    OP2c,\n    OP3a,\n    OP3b,\n    OP3c,\n    OPAtom,\n    OPSONYOpt,  /* FATE sample, violates the spec in places */\n} MXFOP;\n\ntypedef struct MXFPartition {\n    int closed;\n    int complete;\n    MXFPartitionType type;\n    uint64_t previous_partition;\n    int index_sid;\n    int body_sid;\n    int64_t this_partition;\n    int64_t essence_offset;         ///< absolute offset of essence\n    int64_t essence_length;\n    int32_t kag_size;\n    int64_t header_byte_count;\n    int64_t index_byte_count;\n    int pack_length;\n    int64_t pack_ofs;               ///< absolute offset of pack in file, including run-in\n} MXFPartition;\n\ntypedef struct MXFCryptoContext {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID source_container_ul;\n} MXFCryptoContext;\n\ntypedef struct MXFStructuralComponent {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID source_package_ul;\n    UID source_package_uid;\n    UID data_definition_ul;\n    int64_t duration;\n    int64_t start_position;\n    int source_track_id;\n} MXFStructuralComponent;\n\ntypedef struct MXFSequence {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID data_definition_ul;\n    UID *structural_components_refs;\n    int structural_components_count;\n    int64_t duration;\n    uint8_t origin;\n} MXFSequence;\n\ntypedef struct MXFTrack {\n    UID uid;\n    enum MXFMetadataSetType type;\n    int drop_frame;\n    int start_frame;\n    struct AVRational rate;\n    AVTimecode tc;\n} MXFTimecodeComponent;\n\ntypedef struct {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID input_segment_ref;\n} MXFPulldownComponent;\n\ntypedef struct {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID *structural_components_refs;\n    int structural_components_count;\n    int64_t duration;\n} MXFEssenceGroup;\n\ntypedef struct {\n    UID uid;\n    enum MXFMetadataSetType type;\n    char *name;\n    char *value;\n} MXFTaggedValue;\n\ntypedef struct {\n    UID uid;\n    enum MXFMetadataSetType type;\n    MXFSequence *sequence; /* mandatory, and only one */\n    UID sequence_ref;\n    int track_id;\n    char *name;\n    uint8_t track_number[4];\n    AVRational edit_rate;\n    int intra_only;\n    uint64_t sample_count;\n    int64_t original_duration; /* st->duration in SampleRate/EditRate units */\n} MXFTrack;\n\ntypedef struct MXFDescriptor {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID essence_container_ul;\n    UID essence_codec_ul;\n    UID codec_ul;\n    AVRational sample_rate;\n    AVRational aspect_ratio;\n    int width;\n    int height; /* Field height, not frame height */\n    int frame_layout; /* See MXFFrameLayout enum */\n    int video_line_map[2];\n#define MXF_FIELD_DOMINANCE_DEFAULT 0\n#define MXF_FIELD_DOMINANCE_FF 1 /* coded first, displayed first */\n#define MXF_FIELD_DOMINANCE_FL 2 /* coded first, displayed last */\n    int field_dominance;\n    int channels;\n    int bits_per_sample;\n    int64_t duration; /* ContainerDuration optional property */\n    unsigned int component_depth;\n    unsigned int horiz_subsampling;\n    unsigned int vert_subsampling;\n    UID *sub_descriptors_refs;\n    int sub_descriptors_count;\n    int linked_track_id;\n    uint8_t *extradata;\n    int extradata_size;\n    enum AVPixelFormat pix_fmt;\n} MXFDescriptor;\n\ntypedef struct MXFIndexTableSegment {\n    UID uid;\n    enum MXFMetadataSetType type;\n    int edit_unit_byte_count;\n    int index_sid;\n    int body_sid;\n    AVRational index_edit_rate;\n    uint64_t index_start_position;\n    uint64_t index_duration;\n    int8_t *temporal_offset_entries;\n    int *flag_entries;\n    uint64_t *stream_offset_entries;\n    int nb_index_entries;\n} MXFIndexTableSegment;\n\ntypedef struct MXFPackage {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID package_uid;\n    UID package_ul;\n    UID *tracks_refs;\n    int tracks_count;\n    MXFDescriptor *descriptor; /* only one */\n    UID descriptor_ref;\n    char *name;\n    UID *comment_refs;\n    int comment_count;\n} MXFPackage;\n\ntypedef struct MXFMetadataSet {\n    UID uid;\n    enum MXFMetadataSetType type;\n} MXFMetadataSet;\n\n/* decoded index table */\ntypedef struct MXFIndexTable {\n    int index_sid;\n    int body_sid;\n    int nb_ptses;               /* number of PTSes or total duration of index */\n    int64_t first_dts;          /* DTS = EditUnit + first_dts */\n    int64_t *ptses;             /* maps EditUnit -> PTS */\n    int nb_segments;\n    MXFIndexTableSegment **segments;    /* sorted by IndexStartPosition */\n    AVIndexEntry *fake_index;   /* used for calling ff_index_search_timestamp() */\n    int8_t *offsets;            /* temporal offsets for display order to stored order conversion */\n} MXFIndexTable;\n\ntypedef struct MXFContext {\n    MXFPartition *partitions;\n    unsigned partitions_count;\n    MXFOP op;\n    UID *packages_refs;\n    int packages_count;\n    MXFMetadataSet **metadata_sets;\n    int metadata_sets_count;\n    AVFormatContext *fc;\n    struct AVAES *aesc;\n    uint8_t *local_tags;\n    int local_tags_count;\n    uint64_t footer_partition;\n    KLVPacket current_klv_data;\n    int current_klv_index;\n    int run_in;\n    MXFPartition *current_partition;\n    int parsing_backward;\n    int64_t last_forward_tell;\n    int last_forward_partition;\n    int current_edit_unit;\n    int nb_index_tables;\n    MXFIndexTable *index_tables;\n    int edit_units_per_packet;      ///< how many edit units to read at a time (PCM, OPAtom)\n} MXFContext;\n\nenum MXFWrappingScheme {\n    Frame,\n    Clip,\n};\n\n/* NOTE: klv_offset is not set (-1) for local keys */\ntypedef int MXFMetadataReadFunc(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset);\n\ntypedef struct MXFMetadataReadTableEntry {\n    const UID key;\n    MXFMetadataReadFunc *read;\n    int ctx_size;\n    enum MXFMetadataSetType type;\n} MXFMetadataReadTableEntry;\n\nstatic int mxf_read_close(AVFormatContext *s);\n\n/* partial keys to match */\nstatic const uint8_t mxf_header_partition_pack_key[]       = { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02 };\nstatic const uint8_t mxf_essence_element_key[]             = { 0x06,0x0e,0x2b,0x34,0x01,0x02,0x01,0x01,0x0d,0x01,0x03,0x01 };\nstatic const uint8_t mxf_avid_essence_element_key[]        = { 0x06,0x0e,0x2b,0x34,0x01,0x02,0x01,0x01,0x0e,0x04,0x03,0x01 };\nstatic const uint8_t mxf_canopus_essence_element_key[]     = { 0x06,0x0e,0x2b,0x34,0x01,0x02,0x01,0x0a,0x0e,0x0f,0x03,0x01 };\nstatic const uint8_t mxf_system_item_key[]                 = { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x03,0x01,0x04 };\nstatic const uint8_t mxf_klv_key[]                         = { 0x06,0x0e,0x2b,0x34 };\n/* complete keys to match */\nstatic const uint8_t mxf_crypto_source_container_ul[]      = { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0x09,0x06,0x01,0x01,0x02,0x02,0x00,0x00,0x00 };\nstatic const uint8_t mxf_encrypted_triplet_key[]           = { 0x06,0x0e,0x2b,0x34,0x02,0x04,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x7e,0x01,0x00 };\nstatic const uint8_t mxf_encrypted_essence_container[]     = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x0b,0x01,0x00 };\nstatic const uint8_t mxf_random_index_pack_key[]           = { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x11,0x01,0x00 };\nstatic const uint8_t mxf_sony_mpeg4_extradata[]            = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0e,0x06,0x06,0x02,0x02,0x01,0x00,0x00 };\nstatic const uint8_t mxf_avid_project_name[]               = { 0xa5,0xfb,0x7b,0x25,0xf6,0x15,0x94,0xb9,0x62,0xfc,0x37,0x17,0x49,0x2d,0x42,0xbf };\nstatic const uint8_t mxf_jp2k_rsiz[]                       = { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x01,0x00 };\nstatic const uint8_t mxf_indirect_value_utf16le[]          = { 0x4c,0x00,0x02,0x10,0x01,0x00,0x00,0x00,0x00,0x06,0x0e,0x2b,0x34,0x01,0x04,0x01,0x01 };\nstatic const uint8_t mxf_indirect_value_utf16be[]          = { 0x42,0x01,0x10,0x02,0x00,0x00,0x00,0x00,0x00,0x06,0x0e,0x2b,0x34,0x01,0x04,0x01,0x01 };\n\n#define IS_KLV_KEY(x, y) (!memcmp(x, y, sizeof(y)))\n\nstatic void mxf_free_metadataset(MXFMetadataSet **ctx, int freectx)\n{\n    MXFIndexTableSegment *seg;\n    switch ((*ctx)->type) {\n    case Descriptor:\n        av_freep(&((MXFDescriptor *)*ctx)->extradata);\n        break;\n    case MultipleDescriptor:\n        av_freep(&((MXFDescriptor *)*ctx)->sub_descriptors_refs);\n        break;\n    case Sequence:\n        av_freep(&((MXFSequence *)*ctx)->structural_components_refs);\n        break;\n    case EssenceGroup:\n        av_freep(&((MXFEssenceGroup *)*ctx)->structural_components_refs);\n        break;\n    case SourcePackage:\n    case MaterialPackage:\n        av_freep(&((MXFPackage *)*ctx)->tracks_refs);\n        av_freep(&((MXFPackage *)*ctx)->name);\n        av_freep(&((MXFPackage *)*ctx)->comment_refs);\n        break;\n    case TaggedValue:\n        av_freep(&((MXFTaggedValue *)*ctx)->name);\n        av_freep(&((MXFTaggedValue *)*ctx)->value);\n        break;\n    case Track:\n        av_freep(&((MXFTrack *)*ctx)->name);\n        break;\n    case IndexTableSegment:\n        seg = (MXFIndexTableSegment *)*ctx;\n        av_freep(&seg->temporal_offset_entries);\n        av_freep(&seg->flag_entries);\n        av_freep(&seg->stream_offset_entries);\n    default:\n        break;\n    }\n    if (freectx)\n    av_freep(ctx);\n}\n\nstatic int64_t klv_decode_ber_length(AVIOContext *pb)\n{\n    uint64_t size = avio_r8(pb);\n    if (size & 0x80) { /* long form */\n        int bytes_num = size & 0x7f;\n        /* SMPTE 379M 5.3.4 guarantee that bytes_num must not exceed 8 bytes */\n        if (bytes_num > 8)\n            return AVERROR_INVALIDDATA;\n        size = 0;\n        while (bytes_num--)\n            size = size << 8 | avio_r8(pb);\n    }\n    return size;\n}\n\nstatic int mxf_read_sync(AVIOContext *pb, const uint8_t *key, unsigned size)\n{\n    int i, b;\n    for (i = 0; i < size && !avio_feof(pb); i++) {\n        b = avio_r8(pb);\n        if (b == key[0])\n            i = 0;\n        else if (b != key[i])\n            i = -1;\n    }\n    return i == size;\n}\n\nstatic int klv_read_packet(KLVPacket *klv, AVIOContext *pb)\n{\n    if (!mxf_read_sync(pb, mxf_klv_key, 4))\n        return AVERROR_INVALIDDATA;\n    klv->offset = avio_tell(pb) - 4;\n    memcpy(klv->key, mxf_klv_key, 4);\n    avio_read(pb, klv->key + 4, 12);\n    klv->length = klv_decode_ber_length(pb);\n    return klv->length == -1 ? -1 : 0;\n}\n\nstatic int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        MXFTrack *track = s->streams[i]->priv_data;\n        /* SMPTE 379M 7.3 */\n        if (track && !memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n            return i;\n    }\n    /* return 0 if only one stream, for OP Atom files with 0 as track number */\n    return s->nb_streams == 1 ? 0 : -1;\n}\n\n/* XXX: use AVBitStreamFilter */\nstatic int mxf_get_d10_aes3_packet(AVIOContext *pb, AVStream *st, AVPacket *pkt, int64_t length)\n{\n    const uint8_t *buf_ptr, *end_ptr;\n    uint8_t *data_ptr;\n    int i;\n\n    if (length > 61444) /* worst case PAL 1920 samples 8 channels */\n        return AVERROR_INVALIDDATA;\n    length = av_get_packet(pb, pkt, length);\n    if (length < 0)\n        return length;\n    data_ptr = pkt->data;\n    end_ptr = pkt->data + length;\n    buf_ptr = pkt->data + 4; /* skip SMPTE 331M header */\n    for (; end_ptr - buf_ptr >= st->codecpar->channels * 4; ) {\n        for (i = 0; i < st->codecpar->channels; i++) {\n            uint32_t sample = bytestream_get_le32(&buf_ptr);\n            if (st->codecpar->bits_per_coded_sample == 24)\n                bytestream_put_le24(&data_ptr, (sample >> 4) & 0xffffff);\n            else\n                bytestream_put_le16(&data_ptr, (sample >> 12) & 0xffff);\n        }\n        buf_ptr += 32 - st->codecpar->channels*4; // always 8 channels stored SMPTE 331M\n    }\n    av_shrink_packet(pkt, data_ptr - pkt->data);\n    return 0;\n}\n\nstatic int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv)\n{\n    static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b};\n    MXFContext *mxf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t end = avio_tell(pb) + klv->length;\n    int64_t size;\n    uint64_t orig_size;\n    uint64_t plaintext_size;\n    uint8_t ivec[16];\n    uint8_t tmpbuf[16];\n    int index;\n\n    if (!mxf->aesc && s->key && s->keylen == 16) {\n        mxf->aesc = av_aes_alloc();\n        if (!mxf->aesc)\n            return AVERROR(ENOMEM);\n        av_aes_init(mxf->aesc, s->key, 128, 1);\n    }\n    // crypto context\n    avio_skip(pb, klv_decode_ber_length(pb));\n    // plaintext offset\n    klv_decode_ber_length(pb);\n    plaintext_size = avio_rb64(pb);\n    // source klv key\n    klv_decode_ber_length(pb);\n    avio_read(pb, klv->key, 16);\n    if (!IS_KLV_KEY(klv, mxf_essence_element_key))\n        return AVERROR_INVALIDDATA;\n    index = mxf_get_stream_index(s, klv);\n    if (index < 0)\n        return AVERROR_INVALIDDATA;\n    // source size\n    klv_decode_ber_length(pb);\n    orig_size = avio_rb64(pb);\n    if (orig_size < plaintext_size)\n        return AVERROR_INVALIDDATA;\n    // enc. code\n    size = klv_decode_ber_length(pb);\n    if (size < 32 || size - 32 < orig_size)\n        return AVERROR_INVALIDDATA;\n    avio_read(pb, ivec, 16);\n    avio_read(pb, tmpbuf, 16);\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1);\n    if (memcmp(tmpbuf, checkv, 16))\n        av_log(s, AV_LOG_ERROR, \"probably incorrect decryption key\\n\");\n    size -= 32;\n    size = av_get_packet(pb, pkt, size);\n    if (size < 0)\n        return size;\n    else if (size < plaintext_size)\n        return AVERROR_INVALIDDATA;\n    size -= plaintext_size;\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, &pkt->data[plaintext_size],\n                     &pkt->data[plaintext_size], size >> 4, ivec, 1);\n    av_shrink_packet(pkt, orig_size);\n    pkt->stream_index = index;\n    avio_skip(pb, end - avio_tell(pb));\n    return 0;\n}\n\nstatic int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}\n\nstatic int mxf_read_partition_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    MXFPartition *partition, *tmp_part;\n    UID op;\n    uint64_t footer_partition;\n    uint32_t nb_essence_containers;\n\n    tmp_part = av_realloc_array(mxf->partitions, mxf->partitions_count + 1, sizeof(*mxf->partitions));\n    if (!tmp_part)\n        return AVERROR(ENOMEM);\n    mxf->partitions = tmp_part;\n\n    if (mxf->parsing_backward) {\n        /* insert the new partition pack in the middle\n         * this makes the entries in mxf->partitions sorted by offset */\n        memmove(&mxf->partitions[mxf->last_forward_partition+1],\n                &mxf->partitions[mxf->last_forward_partition],\n                (mxf->partitions_count - mxf->last_forward_partition)*sizeof(*mxf->partitions));\n        partition = mxf->current_partition = &mxf->partitions[mxf->last_forward_partition];\n    } else {\n        mxf->last_forward_partition++;\n        partition = mxf->current_partition = &mxf->partitions[mxf->partitions_count];\n    }\n\n    memset(partition, 0, sizeof(*partition));\n    mxf->partitions_count++;\n    partition->pack_length = avio_tell(pb) - klv_offset + size;\n    partition->pack_ofs    = klv_offset;\n\n    switch(uid[13]) {\n    case 2:\n        partition->type = Header;\n        break;\n    case 3:\n        partition->type = BodyPartition;\n        break;\n    case 4:\n        partition->type = Footer;\n        break;\n    default:\n        av_log(mxf->fc, AV_LOG_ERROR, \"unknown partition type %i\\n\", uid[13]);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* consider both footers to be closed (there is only Footer and CompleteFooter) */\n    partition->closed = partition->type == Footer || !(uid[14] & 1);\n    partition->complete = uid[14] > 2;\n    avio_skip(pb, 4);\n    partition->kag_size = avio_rb32(pb);\n    partition->this_partition = avio_rb64(pb);\n    partition->previous_partition = avio_rb64(pb);\n    footer_partition = avio_rb64(pb);\n    partition->header_byte_count = avio_rb64(pb);\n    partition->index_byte_count = avio_rb64(pb);\n    partition->index_sid = avio_rb32(pb);\n    avio_skip(pb, 8);\n    partition->body_sid = avio_rb32(pb);\n    if (avio_read(pb, op, sizeof(UID)) != sizeof(UID)) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"Failed reading UID\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    nb_essence_containers = avio_rb32(pb);\n\n    if (partition->this_partition &&\n        partition->previous_partition == partition->this_partition) {\n        av_log(mxf->fc, AV_LOG_ERROR,\n               \"PreviousPartition equal to ThisPartition %\"PRIx64\"\\n\",\n               partition->previous_partition);\n        /* override with the actual previous partition offset */\n        if (!mxf->parsing_backward && mxf->last_forward_partition > 1) {\n            MXFPartition *prev =\n                mxf->partitions + mxf->last_forward_partition - 2;\n            partition->previous_partition = prev->this_partition;\n        }\n        /* if no previous body partition are found point to the header\n         * partition */\n        if (partition->previous_partition == partition->this_partition)\n            partition->previous_partition = 0;\n        av_log(mxf->fc, AV_LOG_ERROR,\n               \"Overriding PreviousPartition with %\"PRIx64\"\\n\",\n               partition->previous_partition);\n    }\n\n    /* some files don't have FooterPartition set in every partition */\n    if (footer_partition) {\n        if (mxf->footer_partition && mxf->footer_partition != footer_partition) {\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"inconsistent FooterPartition value: %\"PRIu64\" != %\"PRIu64\"\\n\",\n                   mxf->footer_partition, footer_partition);\n        } else {\n            mxf->footer_partition = footer_partition;\n        }\n    }\n\n    av_log(mxf->fc, AV_LOG_TRACE,\n            \"PartitionPack: ThisPartition = 0x%\"PRIX64\n            \", PreviousPartition = 0x%\"PRIX64\", \"\n            \"FooterPartition = 0x%\"PRIX64\", IndexSID = %i, BodySID = %i\\n\",\n            partition->this_partition,\n            partition->previous_partition, footer_partition,\n            partition->index_sid, partition->body_sid);\n\n    /* sanity check PreviousPartition if set */\n    //NOTE: this isn't actually enough, see mxf_seek_to_previous_partition()\n    if (partition->previous_partition &&\n        mxf->run_in + partition->previous_partition >= klv_offset) {\n        av_log(mxf->fc, AV_LOG_ERROR,\n               \"PreviousPartition points to this partition or forward\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if      (op[12] == 1 && op[13] == 1) mxf->op = OP1a;\n    else if (op[12] == 1 && op[13] == 2) mxf->op = OP1b;\n    else if (op[12] == 1 && op[13] == 3) mxf->op = OP1c;\n    else if (op[12] == 2 && op[13] == 1) mxf->op = OP2a;\n    else if (op[12] == 2 && op[13] == 2) mxf->op = OP2b;\n    else if (op[12] == 2 && op[13] == 3) mxf->op = OP2c;\n    else if (op[12] == 3 && op[13] == 1) mxf->op = OP3a;\n    else if (op[12] == 3 && op[13] == 2) mxf->op = OP3b;\n    else if (op[12] == 3 && op[13] == 3) mxf->op = OP3c;\n    else if (op[12] == 64&& op[13] == 1) mxf->op = OPSONYOpt;\n    else if (op[12] == 0x10) {\n        /* SMPTE 390m: \"There shall be exactly one essence container\"\n         * The following block deals with files that violate this, namely:\n         * 2011_DCPTEST_24FPS.V.mxf - two ECs, OP1a\n         * abcdefghiv016f56415e.mxf - zero ECs, OPAtom, output by Avid AirSpeed */\n        if (nb_essence_containers != 1) {\n            MXFOP op = nb_essence_containers ? OP1a : OPAtom;\n\n            /* only nag once */\n            if (!mxf->op)\n                av_log(mxf->fc, AV_LOG_WARNING,\n                       \"\\\"OPAtom\\\" with %\"PRIu32\" ECs - assuming %s\\n\",\n                       nb_essence_containers,\n                       op == OP1a ? \"OP1a\" : \"OPAtom\");\n\n            mxf->op = op;\n        } else\n            mxf->op = OPAtom;\n    } else {\n        av_log(mxf->fc, AV_LOG_ERROR, \"unknown operational pattern: %02xh %02xh - guessing OP1a\\n\", op[12], op[13]);\n        mxf->op = OP1a;\n    }\n\n    if (partition->kag_size <= 0 || partition->kag_size > (1 << 20)) {\n        av_log(mxf->fc, AV_LOG_WARNING, \"invalid KAGSize %\"PRId32\" - guessing \",\n               partition->kag_size);\n\n        if (mxf->op == OPSONYOpt)\n            partition->kag_size = 512;\n        else\n            partition->kag_size = 1;\n\n        av_log(mxf->fc, AV_LOG_WARNING, \"%\"PRId32\"\\n\", partition->kag_size);\n    }\n\n    return 0;\n}\n\nstatic int mxf_add_metadata_set(MXFContext *mxf, void *metadata_set)\n{\n    MXFMetadataSet **tmp;\n\n    tmp = av_realloc_array(mxf->metadata_sets, mxf->metadata_sets_count + 1, sizeof(*mxf->metadata_sets));\n    if (!tmp)\n        return AVERROR(ENOMEM);\n    mxf->metadata_sets = tmp;\n    mxf->metadata_sets[mxf->metadata_sets_count] = metadata_set;\n    mxf->metadata_sets_count++;\n    return 0;\n}\n\nstatic int mxf_read_cryptographic_context(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFCryptoContext *cryptocontext = arg;\n    if (size != 16)\n        return AVERROR_INVALIDDATA;\n    if (IS_KLV_KEY(uid, mxf_crypto_source_container_ul))\n        avio_read(pb, cryptocontext->source_container_ul, 16);\n    return 0;\n}\n\nstatic int mxf_read_strong_ref_array(AVIOContext *pb, UID **refs, int *count)\n{\n    *count = avio_rb32(pb);\n    *refs = av_calloc(*count, sizeof(UID));\n    if (!*refs) {\n        *count = 0;\n        return AVERROR(ENOMEM);\n    }\n    avio_skip(pb, 4); /* useless size of objects, always 16 according to specs */\n    avio_read(pb, (uint8_t *)*refs, *count * sizeof(UID));\n    return 0;\n}\n\nstatic inline int mxf_read_utf16_string(AVIOContext *pb, int size, char** str, int be)\n{\n    int ret;\n    size_t buf_size;\n\n    if (size < 0 || size > INT_MAX/2)\n        return AVERROR(EINVAL);\n\n    buf_size = size + size / 2 + 1;\n    *str = av_malloc(buf_size);\n    if (!*str)\n        return AVERROR(ENOMEM);\n\n    if (be)\n        ret = avio_get_str16be(pb, size, *str, buf_size);\n    else\n        ret = avio_get_str16le(pb, size, *str, buf_size);\n\n    if (ret < 0) {\n        av_freep(str);\n        return ret;\n    }\n\n    return ret;\n}\n\n#define READ_STR16(type, big_endian)                                               \\\nstatic int mxf_read_utf16 ## type ##_string(AVIOContext *pb, int size, char** str) \\\n{                                                                                  \\\nreturn mxf_read_utf16_string(pb, size, str, big_endian);                           \\\n}\nREAD_STR16(be, 1)\nREAD_STR16(le, 0)\n#undef READ_STR16\n\nstatic int mxf_read_content_storage(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    switch (tag) {\n    case 0x1901:\n        if (mxf->packages_refs)\n            av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple packages_refs\\n\");\n        av_free(mxf->packages_refs);\n        return mxf_read_strong_ref_array(pb, &mxf->packages_refs, &mxf->packages_count);\n    }\n    return 0;\n}\n\nstatic int mxf_read_source_clip(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFStructuralComponent *source_clip = arg;\n    switch(tag) {\n    case 0x0202:\n        source_clip->duration = avio_rb64(pb);\n        break;\n    case 0x1201:\n        source_clip->start_position = avio_rb64(pb);\n        break;\n    case 0x1101:\n        /* UMID, only get last 16 bytes */\n        avio_read(pb, source_clip->source_package_ul, 16);\n        avio_read(pb, source_clip->source_package_uid, 16);\n        break;\n    case 0x1102:\n        source_clip->source_track_id = avio_rb32(pb);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_timecode_component(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTimecodeComponent *mxf_timecode = arg;\n    switch(tag) {\n    case 0x1501:\n        mxf_timecode->start_frame = avio_rb64(pb);\n        break;\n    case 0x1502:\n        mxf_timecode->rate = (AVRational){avio_rb16(pb), 1};\n        break;\n    case 0x1503:\n        mxf_timecode->drop_frame = avio_r8(pb);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_pulldown_component(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFPulldownComponent *mxf_pulldown = arg;\n    switch(tag) {\n    case 0x0d01:\n        avio_read(pb, mxf_pulldown->input_segment_ref, 16);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_track(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTrack *track = arg;\n    switch(tag) {\n    case 0x4801:\n        track->track_id = avio_rb32(pb);\n        break;\n    case 0x4804:\n        avio_read(pb, track->track_number, 4);\n        break;\n    case 0x4802:\n        mxf_read_utf16be_string(pb, size, &track->name);\n        break;\n    case 0x4b01:\n        track->edit_rate.num = avio_rb32(pb);\n        track->edit_rate.den = avio_rb32(pb);\n        break;\n    case 0x4803:\n        avio_read(pb, track->sequence_ref, 16);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_sequence(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFSequence *sequence = arg;\n    switch(tag) {\n    case 0x0202:\n        sequence->duration = avio_rb64(pb);\n        break;\n    case 0x0201:\n        avio_read(pb, sequence->data_definition_ul, 16);\n        break;\n        case 0x4b02:\n        sequence->origin = avio_r8(pb);\n        break;\n    case 0x1001:\n        return mxf_read_strong_ref_array(pb, &sequence->structural_components_refs,\n                                             &sequence->structural_components_count);\n    }\n    return 0;\n}\n\nstatic int mxf_read_essence_group(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFEssenceGroup *essence_group = arg;\n    switch (tag) {\n    case 0x0202:\n        essence_group->duration = avio_rb64(pb);\n        break;\n    case 0x0501:\n        return mxf_read_strong_ref_array(pb, &essence_group->structural_components_refs,\n                                             &essence_group->structural_components_count);\n    }\n    return 0;\n}\n\nstatic int mxf_read_package(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFPackage *package = arg;\n    switch(tag) {\n    case 0x4403:\n        return mxf_read_strong_ref_array(pb, &package->tracks_refs,\n                                             &package->tracks_count);\n    case 0x4401:\n        /* UMID */\n        avio_read(pb, package->package_ul, 16);\n        avio_read(pb, package->package_uid, 16);\n        break;\n    case 0x4701:\n        avio_read(pb, package->descriptor_ref, 16);\n        break;\n    case 0x4402:\n        return mxf_read_utf16be_string(pb, size, &package->name);\n    case 0x4406:\n        return mxf_read_strong_ref_array(pb, &package->comment_refs,\n                                             &package->comment_count);\n    }\n    return 0;\n}\n\nstatic int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}\n\nstatic int mxf_read_index_table_segment(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFIndexTableSegment *segment = arg;\n    switch(tag) {\n    case 0x3F05:\n        segment->edit_unit_byte_count = avio_rb32(pb);\n        av_log(NULL, AV_LOG_TRACE, \"EditUnitByteCount %d\\n\", segment->edit_unit_byte_count);\n        break;\n    case 0x3F06:\n        segment->index_sid = avio_rb32(pb);\n        av_log(NULL, AV_LOG_TRACE, \"IndexSID %d\\n\", segment->index_sid);\n        break;\n    case 0x3F07:\n        segment->body_sid = avio_rb32(pb);\n        av_log(NULL, AV_LOG_TRACE, \"BodySID %d\\n\", segment->body_sid);\n        break;\n    case 0x3F0A:\n        av_log(NULL, AV_LOG_TRACE, \"IndexEntryArray found\\n\");\n        return mxf_read_index_entry_array(pb, segment);\n    case 0x3F0B:\n        segment->index_edit_rate.num = avio_rb32(pb);\n        segment->index_edit_rate.den = avio_rb32(pb);\n        av_log(NULL, AV_LOG_TRACE, \"IndexEditRate %d/%d\\n\", segment->index_edit_rate.num,\n                segment->index_edit_rate.den);\n        break;\n    case 0x3F0C:\n        segment->index_start_position = avio_rb64(pb);\n        av_log(NULL, AV_LOG_TRACE, \"IndexStartPosition %\"PRId64\"\\n\", segment->index_start_position);\n        break;\n    case 0x3F0D:\n        segment->index_duration = avio_rb64(pb);\n        av_log(NULL, AV_LOG_TRACE, \"IndexDuration %\"PRId64\"\\n\", segment->index_duration);\n        break;\n    }\n    return 0;\n}\n\nstatic void mxf_read_pixel_layout(AVIOContext *pb, MXFDescriptor *descriptor)\n{\n    int code, value, ofs = 0;\n    char layout[16] = {0}; /* not for printing, may end up not terminated on purpose */\n\n    do {\n        code = avio_r8(pb);\n        value = avio_r8(pb);\n        av_log(NULL, AV_LOG_TRACE, \"pixel layout: code %#x\\n\", code);\n\n        if (ofs <= 14) {\n            layout[ofs++] = code;\n            layout[ofs++] = value;\n        } else\n            break;  /* don't read byte by byte on sneaky files filled with lots of non-zeroes */\n    } while (code != 0); /* SMPTE 377M E.2.46 */\n\n    ff_mxf_decode_pixel_layout(layout, &descriptor->pix_fmt);\n}\n\nstatic int mxf_read_generic_descriptor(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFDescriptor *descriptor = arg;\n    int entry_count, entry_size;\n\n    switch(tag) {\n    case 0x3F01:\n        return mxf_read_strong_ref_array(pb, &descriptor->sub_descriptors_refs,\n                                             &descriptor->sub_descriptors_count);\n    case 0x3002: /* ContainerDuration */\n        descriptor->duration = avio_rb64(pb);\n        break;\n    case 0x3004:\n        avio_read(pb, descriptor->essence_container_ul, 16);\n        break;\n    case 0x3005:\n        avio_read(pb, descriptor->codec_ul, 16);\n        break;\n    case 0x3006:\n        descriptor->linked_track_id = avio_rb32(pb);\n        break;\n    case 0x3201: /* PictureEssenceCoding */\n        avio_read(pb, descriptor->essence_codec_ul, 16);\n        break;\n    case 0x3203:\n        descriptor->width = avio_rb32(pb);\n        break;\n    case 0x3202:\n        descriptor->height = avio_rb32(pb);\n        break;\n    case 0x320C:\n        descriptor->frame_layout = avio_r8(pb);\n        break;\n    case 0x320D:\n        entry_count = avio_rb32(pb);\n        entry_size = avio_rb32(pb);\n        if (entry_size == 4) {\n            if (entry_count > 0)\n                descriptor->video_line_map[0] = avio_rb32(pb);\n            else\n                descriptor->video_line_map[0] = 0;\n            if (entry_count > 1)\n                descriptor->video_line_map[1] = avio_rb32(pb);\n            else\n                descriptor->video_line_map[1] = 0;\n        } else\n            av_log(NULL, AV_LOG_WARNING, \"VideoLineMap element size %d currently not supported\\n\", entry_size);\n        break;\n    case 0x320E:\n        descriptor->aspect_ratio.num = avio_rb32(pb);\n        descriptor->aspect_ratio.den = avio_rb32(pb);\n        break;\n    case 0x3212:\n        descriptor->field_dominance = avio_r8(pb);\n        break;\n    case 0x3301:\n        descriptor->component_depth = avio_rb32(pb);\n        break;\n    case 0x3302:\n        descriptor->horiz_subsampling = avio_rb32(pb);\n        break;\n    case 0x3308:\n        descriptor->vert_subsampling = avio_rb32(pb);\n        break;\n    case 0x3D03:\n        descriptor->sample_rate.num = avio_rb32(pb);\n        descriptor->sample_rate.den = avio_rb32(pb);\n        break;\n    case 0x3D06: /* SoundEssenceCompression */\n        avio_read(pb, descriptor->essence_codec_ul, 16);\n        break;\n    case 0x3D07:\n        descriptor->channels = avio_rb32(pb);\n        break;\n    case 0x3D01:\n        descriptor->bits_per_sample = avio_rb32(pb);\n        break;\n    case 0x3401:\n        mxf_read_pixel_layout(pb, descriptor);\n        break;\n    default:\n        /* Private uid used by SONY C0023S01.mxf */\n        if (IS_KLV_KEY(uid, mxf_sony_mpeg4_extradata)) {\n            if (descriptor->extradata)\n                av_log(NULL, AV_LOG_WARNING, \"Duplicate sony_mpeg4_extradata\\n\");\n            av_free(descriptor->extradata);\n            descriptor->extradata_size = 0;\n            descriptor->extradata = av_malloc(size);\n            if (!descriptor->extradata)\n                return AVERROR(ENOMEM);\n            descriptor->extradata_size = size;\n            avio_read(pb, descriptor->extradata, size);\n        }\n        if (IS_KLV_KEY(uid, mxf_jp2k_rsiz)) {\n            uint32_t rsiz = avio_rb16(pb);\n            if (rsiz == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n                rsiz == FF_PROFILE_JPEG2000_DCINEMA_4K)\n                descriptor->pix_fmt = AV_PIX_FMT_XYZ12;\n        }\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_indirect_value(void *arg, AVIOContext *pb, int size)\n{\n    MXFTaggedValue *tagged_value = arg;\n    uint8_t key[17];\n\n    if (size <= 17)\n        return 0;\n\n    avio_read(pb, key, 17);\n    /* TODO: handle other types of of indirect values */\n    if (memcmp(key, mxf_indirect_value_utf16le, 17) == 0) {\n        return mxf_read_utf16le_string(pb, size - 17, &tagged_value->value);\n    } else if (memcmp(key, mxf_indirect_value_utf16be, 17) == 0) {\n        return mxf_read_utf16be_string(pb, size - 17, &tagged_value->value);\n    }\n    return 0;\n}\n\nstatic int mxf_read_tagged_value(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTaggedValue *tagged_value = arg;\n    switch (tag){\n    case 0x5001:\n        return mxf_read_utf16be_string(pb, size, &tagged_value->name);\n    case 0x5003:\n        return mxf_read_indirect_value(tagged_value, pb, size);\n    }\n    return 0;\n}\n\n/*\n * Match an uid independently of the version byte and up to len common bytes\n * Returns: boolean\n */\nstatic int mxf_match_uid(const UID key, const UID uid, int len)\n{\n    int i;\n    for (i = 0; i < len; i++) {\n        if (i != 7 && key[i] != uid[i])\n            return 0;\n    }\n    return 1;\n}\n\nstatic const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)\n{\n    while (uls->uid[0]) {\n        if(mxf_match_uid(uls->uid, *uid, uls->matching_len))\n            break;\n        uls++;\n    }\n    return uls;\n}\n\nstatic void *mxf_resolve_strong_ref(MXFContext *mxf, UID *strong_ref, enum MXFMetadataSetType type)\n{\n    int i;\n\n    if (!strong_ref)\n        return NULL;\n    for (i = 0; i < mxf->metadata_sets_count; i++) {\n        if (!memcmp(*strong_ref, mxf->metadata_sets[i]->uid, 16) &&\n            (type == AnyType || mxf->metadata_sets[i]->type == type)) {\n            return mxf->metadata_sets[i];\n        }\n    }\n    return NULL;\n}\n\nstatic const MXFCodecUL mxf_picture_essence_container_uls[] = {\n    // video essence container uls\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x0c,0x01,0x00 }, 14,   AV_CODEC_ID_JPEG2000 },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x10,0x60,0x01 }, 14,       AV_CODEC_ID_H264 }, /* H.264 frame wrapped */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x12,0x01,0x00 }, 14,        AV_CODEC_ID_VC1 }, /* VC-1 frame wrapped */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x04,0x60,0x01 }, 14, AV_CODEC_ID_MPEG2VIDEO }, /* MPEG-ES frame wrapped */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x01,0x04,0x01 }, 14, AV_CODEC_ID_MPEG2VIDEO }, /* Type D-10 mapping of 40Mbps 525/60-I */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x02,0x41,0x01 }, 14,    AV_CODEC_ID_DVVIDEO }, /* DV 625 25mbps */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x05,0x00,0x00 }, 14,   AV_CODEC_ID_RAWVIDEO }, /* uncompressed picture */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0a,0x0e,0x0f,0x03,0x01,0x02,0x20,0x01,0x01 }, 15,     AV_CODEC_ID_HQ_HQA },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0a,0x0e,0x0f,0x03,0x01,0x02,0x20,0x02,0x01 }, 15,        AV_CODEC_ID_HQX },\n    { { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0xff,0x4b,0x46,0x41,0x41,0x00,0x0d,0x4d,0x4f }, 14,   AV_CODEC_ID_RAWVIDEO }, /* Legacy ?? Uncompressed Picture */\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,      AV_CODEC_ID_NONE },\n};\n\n/* EC ULs for intra-only formats */\nstatic const MXFCodecUL mxf_intra_only_essence_container_uls[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x01,0x00,0x00 }, 14, AV_CODEC_ID_MPEG2VIDEO }, /* MXF-GC SMPTE D-10 mappings */\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,       AV_CODEC_ID_NONE },\n};\n\n/* intra-only PictureEssenceCoding ULs, where no corresponding EC UL exists */\nstatic const MXFCodecUL mxf_intra_only_picture_essence_coding_uls[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x00,0x00 }, 14,       AV_CODEC_ID_H264 }, /* H.264/MPEG-4 AVC Intra Profiles */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x07,0x04,0x01,0x02,0x02,0x03,0x01,0x01,0x00 }, 14,   AV_CODEC_ID_JPEG2000 }, /* JPEG 2000 code stream */\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,       AV_CODEC_ID_NONE },\n};\n\n/* actual coded width for AVC-Intra to allow selecting correct SPS/PPS */\nstatic const MXFCodecUL mxf_intra_only_picture_coded_width[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x21,0x01 }, 16, 1440 },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x21,0x02 }, 16, 1440 },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x21,0x03 }, 16, 1440 },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x21,0x04 }, 16, 1440 },\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,    0 },\n};\n\nstatic const MXFCodecUL mxf_sound_essence_container_uls[] = {\n    // sound essence container uls\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x06,0x01,0x00 }, 14, AV_CODEC_ID_PCM_S16LE }, /* BWF Frame wrapped */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x04,0x40,0x01 }, 14,       AV_CODEC_ID_MP2 }, /* MPEG-ES Frame wrapped, 0x40 ??? stream id */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x01,0x01,0x01 }, 14, AV_CODEC_ID_PCM_S16LE }, /* D-10 Mapping 50Mbps PAL Extended Template */\n    { { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0xff,0x4b,0x46,0x41,0x41,0x00,0x0d,0x4d,0x4F }, 14, AV_CODEC_ID_PCM_S16LE }, /* 0001GL00.MXF.A1.mxf_opatom.mxf */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x03,0x04,0x02,0x02,0x02,0x03,0x03,0x01,0x00 }, 14,       AV_CODEC_ID_AAC }, /* MPEG-2 AAC ADTS (legacy) */\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,      AV_CODEC_ID_NONE },\n};\n\nstatic const MXFCodecUL mxf_data_essence_container_uls[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x09,0x0d,0x01,0x03,0x01,0x02,0x0e,0x00,0x00 }, 16, 0 },\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0, AV_CODEC_ID_NONE },\n};\n\nstatic const char* const mxf_data_essence_descriptor[] = {\n    \"vbi_vanc_smpte_436M\",\n};\n\nstatic int mxf_get_sorted_table_segments(MXFContext *mxf, int *nb_sorted_segments, MXFIndexTableSegment ***sorted_segments)\n{\n    int i, j, nb_segments = 0;\n    MXFIndexTableSegment **unsorted_segments;\n    int last_body_sid = -1, last_index_sid = -1, last_index_start = -1;\n\n    /* count number of segments, allocate arrays and copy unsorted segments */\n    for (i = 0; i < mxf->metadata_sets_count; i++)\n        if (mxf->metadata_sets[i]->type == IndexTableSegment)\n            nb_segments++;\n\n    if (!nb_segments)\n        return AVERROR_INVALIDDATA;\n\n    if (!(unsorted_segments = av_calloc(nb_segments, sizeof(*unsorted_segments))) ||\n        !(*sorted_segments  = av_calloc(nb_segments, sizeof(**sorted_segments)))) {\n        av_freep(sorted_segments);\n        av_free(unsorted_segments);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = j = 0; i < mxf->metadata_sets_count; i++)\n        if (mxf->metadata_sets[i]->type == IndexTableSegment)\n            unsorted_segments[j++] = (MXFIndexTableSegment*)mxf->metadata_sets[i];\n\n    *nb_sorted_segments = 0;\n\n    /* sort segments by {BodySID, IndexSID, IndexStartPosition}, remove duplicates while we're at it */\n    for (i = 0; i < nb_segments; i++) {\n        int best = -1, best_body_sid = -1, best_index_sid = -1, best_index_start = -1;\n        uint64_t best_index_duration = 0;\n\n        for (j = 0; j < nb_segments; j++) {\n            MXFIndexTableSegment *s = unsorted_segments[j];\n\n            /* Require larger BosySID, IndexSID or IndexStartPosition then the previous entry. This removes duplicates.\n             * We want the smallest values for the keys than what we currently have, unless this is the first such entry this time around.\n             * If we come across an entry with the same IndexStartPosition but larger IndexDuration, then we'll prefer it over the one we currently have.\n             */\n            if ((i == 0     || s->body_sid > last_body_sid || s->index_sid > last_index_sid || s->index_start_position > last_index_start) &&\n                (best == -1 || s->body_sid < best_body_sid || s->index_sid < best_index_sid || s->index_start_position < best_index_start ||\n                (s->index_start_position == best_index_start && s->index_duration > best_index_duration))) {\n                best             = j;\n                best_body_sid    = s->body_sid;\n                best_index_sid   = s->index_sid;\n                best_index_start = s->index_start_position;\n                best_index_duration = s->index_duration;\n            }\n        }\n\n        /* no suitable entry found -> we're done */\n        if (best == -1)\n            break;\n\n        (*sorted_segments)[(*nb_sorted_segments)++] = unsorted_segments[best];\n        last_body_sid    = best_body_sid;\n        last_index_sid   = best_index_sid;\n        last_index_start = best_index_start;\n    }\n\n    av_free(unsorted_segments);\n\n    return 0;\n}\n\n/**\n * Computes the absolute file offset of the given essence container offset\n */\nstatic int mxf_absolute_bodysid_offset(MXFContext *mxf, int body_sid, int64_t offset, int64_t *offset_out)\n{\n    int x;\n    int64_t offset_in = offset;     /* for logging */\n\n    for (x = 0; x < mxf->partitions_count; x++) {\n        MXFPartition *p = &mxf->partitions[x];\n\n        if (p->body_sid != body_sid)\n            continue;\n\n        if (offset < p->essence_length || !p->essence_length) {\n            *offset_out = p->essence_offset + offset;\n            return 0;\n        }\n\n        offset -= p->essence_length;\n    }\n\n    av_log(mxf->fc, AV_LOG_ERROR,\n           \"failed to find absolute offset of %\"PRIX64\" in BodySID %i - partial file?\\n\",\n           offset_in, body_sid);\n\n    return AVERROR_INVALIDDATA;\n}\n\n/**\n * Returns the end position of the essence container with given BodySID, or zero if unknown\n */\nstatic int64_t mxf_essence_container_end(MXFContext *mxf, int body_sid)\n{\n    int x;\n    int64_t ret = 0;\n\n    for (x = 0; x < mxf->partitions_count; x++) {\n        MXFPartition *p = &mxf->partitions[x];\n\n        if (p->body_sid != body_sid)\n            continue;\n\n        if (!p->essence_length)\n            return 0;\n\n        ret = p->essence_offset + p->essence_length;\n    }\n\n    return ret;\n}\n\n/* EditUnit -> absolute offset */\nstatic int mxf_edit_unit_absolute_offset(MXFContext *mxf, MXFIndexTable *index_table, int64_t edit_unit, int64_t *edit_unit_out, int64_t *offset_out, int nag)\n{\n    int i;\n    int64_t offset_temp = 0;\n\n    for (i = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n\n        edit_unit = FFMAX(edit_unit, s->index_start_position);  /* clamp if trying to seek before start */\n\n        if (edit_unit < s->index_start_position + s->index_duration) {\n            int64_t index = edit_unit - s->index_start_position;\n\n            if (s->edit_unit_byte_count)\n                offset_temp += s->edit_unit_byte_count * index;\n            else if (s->nb_index_entries) {\n                if (s->nb_index_entries == 2 * s->index_duration + 1)\n                    index *= 2;     /* Avid index */\n\n                if (index < 0 || index >= s->nb_index_entries) {\n                    av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" IndexEntryArray too small\\n\",\n                           index_table->index_sid, s->index_start_position);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                offset_temp = s->stream_offset_entries[index];\n            } else {\n                av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" missing EditUnitByteCount and IndexEntryArray\\n\",\n                       index_table->index_sid, s->index_start_position);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (edit_unit_out)\n                *edit_unit_out = edit_unit;\n\n            return mxf_absolute_bodysid_offset(mxf, index_table->body_sid, offset_temp, offset_out);\n        } else {\n            /* EditUnitByteCount == 0 for VBR indexes, which is fine since they use explicit StreamOffsets */\n            offset_temp += s->edit_unit_byte_count * s->index_duration;\n        }\n    }\n\n    if (nag)\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to map EditUnit %\"PRId64\" in IndexSID %i to an offset\\n\", edit_unit, index_table->index_sid);\n\n    return AVERROR_INVALIDDATA;\n}\n\nstatic int mxf_compute_ptses_fake_index(MXFContext *mxf, MXFIndexTable *index_table)\n{\n    int i, j, x;\n    int8_t max_temporal_offset = -128;\n    uint8_t *flags;\n\n    /* first compute how many entries we have */\n    for (i = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n\n        if (!s->nb_index_entries) {\n            index_table->nb_ptses = 0;\n            return 0;                               /* no TemporalOffsets */\n        }\n\n        index_table->nb_ptses += s->index_duration;\n    }\n\n    /* paranoid check */\n    if (index_table->nb_ptses <= 0)\n        return 0;\n\n    if (!(index_table->ptses      = av_calloc(index_table->nb_ptses, sizeof(int64_t))) ||\n        !(index_table->fake_index = av_calloc(index_table->nb_ptses, sizeof(AVIndexEntry))) ||\n        !(index_table->offsets    = av_calloc(index_table->nb_ptses, sizeof(int8_t))) ||\n        !(flags                   = av_calloc(index_table->nb_ptses, sizeof(uint8_t)))) {\n        av_freep(&index_table->ptses);\n        av_freep(&index_table->fake_index);\n        av_freep(&index_table->offsets);\n        return AVERROR(ENOMEM);\n    }\n\n    /* we may have a few bad TemporalOffsets\n     * make sure the corresponding PTSes don't have the bogus value 0 */\n    for (x = 0; x < index_table->nb_ptses; x++)\n        index_table->ptses[x] = AV_NOPTS_VALUE;\n\n    /**\n     * We have this:\n     *\n     * x  TemporalOffset\n     * 0:  0\n     * 1:  1\n     * 2:  1\n     * 3: -2\n     * 4:  1\n     * 5:  1\n     * 6: -2\n     *\n     * We want to transform it into this:\n     *\n     * x  DTS PTS\n     * 0: -1   0\n     * 1:  0   3\n     * 2:  1   1\n     * 3:  2   2\n     * 4:  3   6\n     * 5:  4   4\n     * 6:  5   5\n     *\n     * We do this by bucket sorting x by x+TemporalOffset[x] into mxf->ptses,\n     * then settings mxf->first_dts = -max(TemporalOffset[x]).\n     * The latter makes DTS <= PTS.\n     */\n    for (i = x = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n        int index_delta = 1;\n        int n = s->nb_index_entries;\n\n        if (s->nb_index_entries == 2 * s->index_duration + 1) {\n            index_delta = 2;    /* Avid index */\n            /* ignore the last entry - it's the size of the essence container */\n            n--;\n        }\n\n        for (j = 0; j < n; j += index_delta, x++) {\n            int offset = s->temporal_offset_entries[j] / index_delta;\n            int index  = x + offset;\n\n            if (x >= index_table->nb_ptses) {\n                av_log(mxf->fc, AV_LOG_ERROR,\n                       \"x >= nb_ptses - IndexEntryCount %i < IndexDuration %\"PRId64\"?\\n\",\n                       s->nb_index_entries, s->index_duration);\n                break;\n            }\n\n            flags[x] = !(s->flag_entries[j] & 0x30) ? AVINDEX_KEYFRAME : 0;\n\n            if (index < 0 || index >= index_table->nb_ptses) {\n                av_log(mxf->fc, AV_LOG_ERROR,\n                       \"index entry %i + TemporalOffset %i = %i, which is out of bounds\\n\",\n                       x, offset, index);\n                continue;\n            }\n\n            index_table->offsets[x] = offset;\n            index_table->ptses[index] = x;\n            max_temporal_offset = FFMAX(max_temporal_offset, offset);\n        }\n    }\n\n    /* calculate the fake index table in display order */\n    for (x = 0; x < index_table->nb_ptses; x++) {\n        index_table->fake_index[x].timestamp = x;\n        if (index_table->ptses[x] != AV_NOPTS_VALUE)\n            index_table->fake_index[index_table->ptses[x]].flags = flags[x];\n    }\n    av_freep(&flags);\n\n    index_table->first_dts = -max_temporal_offset;\n\n    return 0;\n}\n\n/**\n * Sorts and collects index table segments into index tables.\n * Also computes PTSes if possible.\n */\nstatic int mxf_compute_index_tables(MXFContext *mxf)\n{\n    int i, j, k, ret, nb_sorted_segments;\n    MXFIndexTableSegment **sorted_segments = NULL;\n    AVStream *st = NULL;\n\n    for (i = 0; i < mxf->fc->nb_streams; i++) {\n        if (mxf->fc->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_DATA)\n            continue;\n        st = mxf->fc->streams[i];\n        break;\n    }\n\n    if ((ret = mxf_get_sorted_table_segments(mxf, &nb_sorted_segments, &sorted_segments)) ||\n        nb_sorted_segments <= 0) {\n        av_log(mxf->fc, AV_LOG_WARNING, \"broken or empty index\\n\");\n        return 0;\n    }\n\n    /* sanity check and count unique BodySIDs/IndexSIDs */\n    for (i = 0; i < nb_sorted_segments; i++) {\n        if (i == 0 || sorted_segments[i-1]->index_sid != sorted_segments[i]->index_sid)\n            mxf->nb_index_tables++;\n        else if (sorted_segments[i-1]->body_sid != sorted_segments[i]->body_sid) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"found inconsistent BodySID\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto finish_decoding_index;\n        }\n    }\n\n    mxf->index_tables = av_mallocz_array(mxf->nb_index_tables,\n                                         sizeof(*mxf->index_tables));\n    if (!mxf->index_tables) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to allocate index tables\\n\");\n        ret = AVERROR(ENOMEM);\n        goto finish_decoding_index;\n    }\n\n    /* distribute sorted segments to index tables */\n    for (i = j = 0; i < nb_sorted_segments; i++) {\n        if (i != 0 && sorted_segments[i-1]->index_sid != sorted_segments[i]->index_sid) {\n            /* next IndexSID */\n            j++;\n        }\n\n        mxf->index_tables[j].nb_segments++;\n    }\n\n    for (i = j = 0; j < mxf->nb_index_tables; i += mxf->index_tables[j++].nb_segments) {\n        MXFIndexTable *t = &mxf->index_tables[j];\n\n        t->segments = av_mallocz_array(t->nb_segments,\n                                       sizeof(*t->segments));\n\n        if (!t->segments) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"failed to allocate IndexTableSegment\"\n                   \" pointer array\\n\");\n            ret = AVERROR(ENOMEM);\n            goto finish_decoding_index;\n        }\n\n        if (sorted_segments[i]->index_start_position)\n            av_log(mxf->fc, AV_LOG_WARNING, \"IndexSID %i starts at EditUnit %\"PRId64\" - seeking may not work as expected\\n\",\n                   sorted_segments[i]->index_sid, sorted_segments[i]->index_start_position);\n\n        memcpy(t->segments, &sorted_segments[i], t->nb_segments * sizeof(MXFIndexTableSegment*));\n        t->index_sid = sorted_segments[i]->index_sid;\n        t->body_sid = sorted_segments[i]->body_sid;\n\n        if ((ret = mxf_compute_ptses_fake_index(mxf, t)) < 0)\n            goto finish_decoding_index;\n\n        /* fix zero IndexDurations */\n        for (k = 0; k < t->nb_segments; k++) {\n            if (t->segments[k]->index_duration)\n                continue;\n\n            if (t->nb_segments > 1)\n                av_log(mxf->fc, AV_LOG_WARNING, \"IndexSID %i segment %i has zero IndexDuration and there's more than one segment\\n\",\n                       t->index_sid, k);\n\n            if (!st) {\n                av_log(mxf->fc, AV_LOG_WARNING, \"no streams?\\n\");\n                break;\n            }\n\n            /* assume the first stream's duration is reasonable\n             * leave index_duration = 0 on further segments in case we have any (unlikely)\n             */\n            t->segments[k]->index_duration = st->duration;\n            break;\n        }\n    }\n\n    ret = 0;\nfinish_decoding_index:\n    av_free(sorted_segments);\n    return ret;\n}\n\nstatic int mxf_is_intra_only(MXFDescriptor *descriptor)\n{\n    return mxf_get_codec_ul(mxf_intra_only_essence_container_uls,\n                            &descriptor->essence_container_ul)->id != AV_CODEC_ID_NONE ||\n           mxf_get_codec_ul(mxf_intra_only_picture_essence_coding_uls,\n                            &descriptor->essence_codec_ul)->id     != AV_CODEC_ID_NONE;\n}\n\nstatic int mxf_uid_to_str(UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 2 + 4 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2x\", uid[i]);\n        p += 2;\n        if (i == 3 || i == 5 || i == 7 || i == 9) {\n            snprintf(p, 1 + 1, \"-\");\n            p++;\n        }\n    }\n    return 0;\n}\n\nstatic int mxf_umid_to_str(UID ul, UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 4 + 2 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    snprintf(p, 2 + 1, \"0x\");\n    p += 2;\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2X\", ul[i]);\n        p += 2;\n\n    }\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2X\", uid[i]);\n        p += 2;\n    }\n    return 0;\n}\n\nstatic int mxf_add_umid_metadata(AVDictionary **pm, const char *key, MXFPackage* package)\n{\n    char *str;\n    int ret;\n    if (!package)\n        return 0;\n    if ((ret = mxf_umid_to_str(package->package_ul, package->package_uid, &str)) < 0)\n        return ret;\n    av_dict_set(pm, key, str, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}\n\nstatic int mxf_add_timecode_metadata(AVDictionary **pm, const char *key, AVTimecode *tc)\n{\n    char buf[AV_TIMECODE_STR_SIZE];\n    av_dict_set(pm, key, av_timecode_make_string(tc, buf, 0), 0);\n\n    return 0;\n}\n\nstatic MXFTimecodeComponent* mxf_resolve_timecode_component(MXFContext *mxf, UID *strong_ref)\n{\n    MXFStructuralComponent *component = NULL;\n    MXFPulldownComponent *pulldown = NULL;\n\n    component = mxf_resolve_strong_ref(mxf, strong_ref, AnyType);\n    if (!component)\n        return NULL;\n\n    switch (component->type) {\n    case TimecodeComponent:\n        return (MXFTimecodeComponent*)component;\n    case PulldownComponent: /* timcode component may be located on a pulldown component */\n        pulldown = (MXFPulldownComponent*)component;\n        return mxf_resolve_strong_ref(mxf, &pulldown->input_segment_ref, TimecodeComponent);\n    default:\n        break;\n    }\n    return NULL;\n}\n\nstatic MXFPackage* mxf_resolve_source_package(MXFContext *mxf, UID package_uid)\n{\n    MXFPackage *package = NULL;\n    int i;\n\n    for (i = 0; i < mxf->packages_count; i++) {\n        package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], SourcePackage);\n        if (!package)\n            continue;\n\n        if (!memcmp(package->package_uid, package_uid, 16))\n            return package;\n    }\n    return NULL;\n}\n\nstatic MXFDescriptor* mxf_resolve_multidescriptor(MXFContext *mxf, MXFDescriptor *descriptor, int track_id)\n{\n    MXFDescriptor *sub_descriptor = NULL;\n    int i;\n\n    if (!descriptor)\n        return NULL;\n\n    if (descriptor->type == MultipleDescriptor) {\n        for (i = 0; i < descriptor->sub_descriptors_count; i++) {\n            sub_descriptor = mxf_resolve_strong_ref(mxf, &descriptor->sub_descriptors_refs[i], Descriptor);\n\n            if (!sub_descriptor) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve sub descriptor strong ref\\n\");\n                continue;\n            }\n            if (sub_descriptor->linked_track_id == track_id) {\n                return sub_descriptor;\n            }\n        }\n    } else if (descriptor->type == Descriptor)\n        return descriptor;\n\n    return NULL;\n}\n\nstatic MXFStructuralComponent* mxf_resolve_essence_group_choice(MXFContext *mxf, MXFEssenceGroup *essence_group)\n{\n    MXFStructuralComponent *component = NULL;\n    MXFPackage *package = NULL;\n    MXFDescriptor *descriptor = NULL;\n    int i;\n\n    if (!essence_group || !essence_group->structural_components_count)\n        return NULL;\n\n    /* essence groups contains multiple representations of the same media,\n       this return the first components with a valid Descriptor typically index 0 */\n    for (i =0; i < essence_group->structural_components_count; i++){\n        component = mxf_resolve_strong_ref(mxf, &essence_group->structural_components_refs[i], SourceClip);\n        if (!component)\n            continue;\n\n        if (!(package = mxf_resolve_source_package(mxf, component->source_package_uid)))\n            continue;\n\n        descriptor = mxf_resolve_strong_ref(mxf, &package->descriptor_ref, Descriptor);\n        if (descriptor)\n            return component;\n    }\n    return NULL;\n}\n\nstatic MXFStructuralComponent* mxf_resolve_sourceclip(MXFContext *mxf, UID *strong_ref)\n{\n    MXFStructuralComponent *component = NULL;\n\n    component = mxf_resolve_strong_ref(mxf, strong_ref, AnyType);\n    if (!component)\n        return NULL;\n    switch (component->type) {\n        case SourceClip:\n            return component;\n        case EssenceGroup:\n            return mxf_resolve_essence_group_choice(mxf, (MXFEssenceGroup*) component);\n        default:\n            break;\n    }\n    return NULL;\n}\n\nstatic int mxf_parse_package_comments(MXFContext *mxf, AVDictionary **pm, MXFPackage *package)\n{\n    MXFTaggedValue *tag;\n    int size, i;\n    char *key = NULL;\n\n    for (i = 0; i < package->comment_count; i++) {\n        tag = mxf_resolve_strong_ref(mxf, &package->comment_refs[i], TaggedValue);\n        if (!tag || !tag->name || !tag->value)\n            continue;\n\n        size = strlen(tag->name) + 8 + 1;\n        key = av_mallocz(size);\n        if (!key)\n            return AVERROR(ENOMEM);\n\n        snprintf(key, size, \"comment_%s\", tag->name);\n        av_dict_set(pm, key, tag->value, AV_DICT_DONT_STRDUP_KEY);\n    }\n    return 0;\n}\n\nstatic int mxf_parse_physical_source_package(MXFContext *mxf, MXFTrack *source_track, AVStream *st)\n{\n    MXFPackage *physical_package = NULL;\n    MXFTrack *physical_track = NULL;\n    MXFStructuralComponent *sourceclip = NULL;\n    MXFTimecodeComponent *mxf_tc = NULL;\n    int i, j, k;\n    AVTimecode tc;\n    int flags;\n    int64_t start_position;\n\n    for (i = 0; i < source_track->sequence->structural_components_count; i++) {\n        sourceclip = mxf_resolve_strong_ref(mxf, &source_track->sequence->structural_components_refs[i], SourceClip);\n        if (!sourceclip)\n            continue;\n\n        if (!(physical_package = mxf_resolve_source_package(mxf, sourceclip->source_package_uid)))\n            break;\n\n        mxf_add_umid_metadata(&st->metadata, \"reel_umid\", physical_package);\n\n        /* the name of physical source package is name of the reel or tape */\n        if (physical_package->name && physical_package->name[0])\n            av_dict_set(&st->metadata, \"reel_name\", physical_package->name, 0);\n\n        /* the source timecode is calculated by adding the start_position of the sourceclip from the file source package track\n         * to the start_frame of the timecode component located on one of the tracks of the physical source package.\n         */\n        for (j = 0; j < physical_package->tracks_count; j++) {\n            if (!(physical_track = mxf_resolve_strong_ref(mxf, &physical_package->tracks_refs[j], Track))) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track strong ref\\n\");\n                continue;\n            }\n\n            if (!(physical_track->sequence = mxf_resolve_strong_ref(mxf, &physical_track->sequence_ref, Sequence))) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track sequence strong ref\\n\");\n                continue;\n            }\n\n        if (physical_track->edit_rate.num <= 0 ||\n            physical_track->edit_rate.den <= 0) {\n            av_log(mxf->fc, AV_LOG_WARNING,\n                   \"Invalid edit rate (%d/%d) found on structural\"\n                   \" component #%d, defaulting to 25/1\\n\",\n                   physical_track->edit_rate.num,\n                   physical_track->edit_rate.den, i);\n            physical_track->edit_rate = (AVRational){25, 1};\n        }\n\n            for (k = 0; k < physical_track->sequence->structural_components_count; k++) {\n                if (!(mxf_tc = mxf_resolve_timecode_component(mxf, &physical_track->sequence->structural_components_refs[k])))\n                    continue;\n\n                flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;\n                /* scale sourceclip start_position to match physical track edit rate */\n                start_position = av_rescale_q(sourceclip->start_position,\n                                              physical_track->edit_rate,\n                                              source_track->edit_rate);\n\n                if (av_timecode_init(&tc, mxf_tc->rate, flags, start_position + mxf_tc->start_frame, mxf->fc) == 0) {\n                    mxf_add_timecode_metadata(&st->metadata, \"timecode\", &tc);\n                    return 0;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int mxf_add_metadata_stream(MXFContext *mxf, MXFTrack *track)\n{\n    MXFStructuralComponent *component = NULL;\n    const MXFCodecUL *codec_ul = NULL;\n    MXFPackage tmp_package;\n    AVStream *st;\n    int j;\n\n    for (j = 0; j < track->sequence->structural_components_count; j++) {\n        component = mxf_resolve_sourceclip(mxf, &track->sequence->structural_components_refs[j]);\n        if (!component)\n            continue;\n        break;\n    }\n    if (!component)\n        return 0;\n\n    st = avformat_new_stream(mxf->fc, NULL);\n    if (!st) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate metadata stream\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n    st->codecpar->codec_id = AV_CODEC_ID_NONE;\n    st->id = track->track_id;\n\n    memcpy(&tmp_package.package_ul, component->source_package_ul, 16);\n    memcpy(&tmp_package.package_uid, component->source_package_uid, 16);\n    mxf_add_umid_metadata(&st->metadata, \"file_package_umid\", &tmp_package);\n    if (track->name && track->name[0])\n        av_dict_set(&st->metadata, \"track_name\", track->name, 0);\n\n    codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &track->sequence->data_definition_ul);\n    av_dict_set(&st->metadata, \"data_type\", av_get_media_type_string(codec_ul->id), 0);\n    return 0;\n}\n\nstatic int mxf_parse_structural_metadata(MXFContext *mxf)\n{\n    MXFPackage *material_package = NULL;\n    int i, j, k, ret;\n\n    av_log(mxf->fc, AV_LOG_TRACE, \"metadata sets count %d\\n\", mxf->metadata_sets_count);\n    /* TODO: handle multiple material packages (OP3x) */\n    for (i = 0; i < mxf->packages_count; i++) {\n        material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);\n        if (material_package) break;\n    }\n    if (!material_package) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"no material package found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    mxf_add_umid_metadata(&mxf->fc->metadata, \"material_package_umid\", material_package);\n    if (material_package->name && material_package->name[0])\n        av_dict_set(&mxf->fc->metadata, \"material_package_name\", material_package->name, 0);\n    mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);\n\n    for (i = 0; i < material_package->tracks_count; i++) {\n        MXFPackage *source_package = NULL;\n        MXFTrack *material_track = NULL;\n        MXFTrack *source_track = NULL;\n        MXFTrack *temp_track = NULL;\n        MXFDescriptor *descriptor = NULL;\n        MXFStructuralComponent *component = NULL;\n        MXFTimecodeComponent *mxf_tc = NULL;\n        UID *essence_container_ul = NULL;\n        const MXFCodecUL *codec_ul = NULL;\n        const MXFCodecUL *container_ul = NULL;\n        const MXFCodecUL *pix_fmt_ul = NULL;\n        AVStream *st;\n        AVTimecode tc;\n        int flags;\n\n        if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track strong ref\\n\");\n            continue;\n        }\n\n        if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {\n            mxf_tc = (MXFTimecodeComponent*)component;\n            flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;\n            if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {\n                mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);\n            }\n        }\n\n        if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track sequence strong ref\\n\");\n            continue;\n        }\n\n        for (j = 0; j < material_track->sequence->structural_components_count; j++) {\n            component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);\n            if (!component)\n                continue;\n\n            mxf_tc = (MXFTimecodeComponent*)component;\n            flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;\n            if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {\n                mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);\n                break;\n            }\n        }\n\n        /* TODO: handle multiple source clips, only finds first valid source clip */\n        if(material_track->sequence->structural_components_count > 1)\n            av_log(mxf->fc, AV_LOG_WARNING, \"material track %d: has %d components\\n\",\n                       material_track->track_id, material_track->sequence->structural_components_count);\n\n        for (j = 0; j < material_track->sequence->structural_components_count; j++) {\n            component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);\n            if (!component)\n                continue;\n\n            source_package = mxf_resolve_source_package(mxf, component->source_package_uid);\n            if (!source_package) {\n                av_log(mxf->fc, AV_LOG_TRACE, \"material track %d: no corresponding source package found\\n\", material_track->track_id);\n                break;\n            }\n            for (k = 0; k < source_package->tracks_count; k++) {\n                if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {\n                    av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track strong ref\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail_and_free;\n                }\n                if (temp_track->track_id == component->source_track_id) {\n                    source_track = temp_track;\n                    break;\n                }\n            }\n            if (!source_track) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: no corresponding source track found\\n\", material_track->track_id);\n                break;\n            }\n            if(source_track && component)\n                break;\n        }\n        if (!source_track || !component || !source_package) {\n            if((ret = mxf_add_metadata_stream(mxf, material_track)))\n                goto fail_and_free;\n            continue;\n        }\n\n        if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track sequence strong ref\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail_and_free;\n        }\n\n        /* 0001GL00.MXF.A1.mxf_opatom.mxf has the same SourcePackageID as 0001GL.MXF.V1.mxf_opatom.mxf\n         * This would result in both files appearing to have two streams. Work around this by sanity checking DataDefinition */\n        if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: DataDefinition mismatch\\n\", material_track->track_id);\n            continue;\n        }\n\n        st = avformat_new_stream(mxf->fc, NULL);\n        if (!st) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate stream\\n\");\n            ret = AVERROR(ENOMEM);\n            goto fail_and_free;\n        }\n        st->id = material_track->track_id;\n        st->priv_data = source_track;\n\n        source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);\n        descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);\n\n        /* A SourceClip from a EssenceGroup may only be a single frame of essence data. The clips duration is then how many\n         * frames its suppose to repeat for. Descriptor->duration, if present, contains the real duration of the essence data */\n        if (descriptor && descriptor->duration != AV_NOPTS_VALUE)\n            source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);\n        else\n            source_track->original_duration = st->duration = component->duration;\n\n        if (st->duration == -1)\n            st->duration = AV_NOPTS_VALUE;\n        st->start_time = component->start_position;\n        if (material_track->edit_rate.num <= 0 ||\n            material_track->edit_rate.den <= 0) {\n            av_log(mxf->fc, AV_LOG_WARNING,\n                   \"Invalid edit rate (%d/%d) found on stream #%d, \"\n                   \"defaulting to 25/1\\n\",\n                   material_track->edit_rate.num,\n                   material_track->edit_rate.den, st->index);\n            material_track->edit_rate = (AVRational){25, 1};\n        }\n        avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);\n\n        /* ensure SourceTrack EditRate == MaterialTrack EditRate since only\n         * the former is accessible via st->priv_data */\n        source_track->edit_rate = material_track->edit_rate;\n\n        PRINT_KEY(mxf->fc, \"data definition   ul\", source_track->sequence->data_definition_ul);\n        codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);\n        st->codecpar->codec_type = codec_ul->id;\n\n        if (!descriptor) {\n            av_log(mxf->fc, AV_LOG_INFO, \"source track %d: stream %d, no descriptor found\\n\", source_track->track_id, st->index);\n            continue;\n        }\n        PRINT_KEY(mxf->fc, \"essence codec     ul\", descriptor->essence_codec_ul);\n        PRINT_KEY(mxf->fc, \"essence container ul\", descriptor->essence_container_ul);\n        essence_container_ul = &descriptor->essence_container_ul;\n        /* HACK: replacing the original key with mxf_encrypted_essence_container\n         * is not allowed according to s429-6, try to find correct information anyway */\n        if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {\n            av_log(mxf->fc, AV_LOG_INFO, \"broken encrypted mxf file\\n\");\n            for (k = 0; k < mxf->metadata_sets_count; k++) {\n                MXFMetadataSet *metadata = mxf->metadata_sets[k];\n                if (metadata->type == CryptoContext) {\n                    essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;\n                    break;\n                }\n            }\n        }\n\n        /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */\n        codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);\n        st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;\n        if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {\n            codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);\n            st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;\n        }\n\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"%s: Universal Label: \",\n               avcodec_get_name(st->codecpar->codec_id));\n        for (k = 0; k < 16; k++) {\n            av_log(mxf->fc, AV_LOG_VERBOSE, \"%.2x\",\n                   descriptor->essence_codec_ul[k]);\n            if (!(k+1 & 19) || k == 5)\n                av_log(mxf->fc, AV_LOG_VERBOSE, \".\");\n        }\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"\\n\");\n\n        mxf_add_umid_metadata(&st->metadata, \"file_package_umid\", source_package);\n        if (source_package->name && source_package->name[0])\n            av_dict_set(&st->metadata, \"file_package_name\", source_package->name, 0);\n        if (material_track->name && material_track->name[0])\n            av_dict_set(&st->metadata, \"track_name\", material_track->name, 0);\n\n        mxf_parse_physical_source_package(mxf, source_track, st);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            source_track->intra_only = mxf_is_intra_only(descriptor);\n            container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);\n            if (st->codecpar->codec_id == AV_CODEC_ID_NONE)\n                st->codecpar->codec_id = container_ul->id;\n            st->codecpar->width = descriptor->width;\n            st->codecpar->height = descriptor->height; /* Field height, not frame height */\n            switch (descriptor->frame_layout) {\n                case FullFrame:\n                    st->codecpar->field_order = AV_FIELD_PROGRESSIVE;\n                    break;\n                case OneField:\n                    /* Every other line is stored and needs to be duplicated. */\n                    av_log(mxf->fc, AV_LOG_INFO, \"OneField frame layout isn't currently supported\\n\");\n                    break; /* The correct thing to do here is fall through, but by breaking we might be\n                              able to decode some streams at half the vertical resolution, rather than not al all.\n                              It's also for compatibility with the old behavior. */\n                case MixedFields:\n                    break;\n                case SegmentedFrame:\n                    st->codecpar->field_order = AV_FIELD_PROGRESSIVE;\n                case SeparateFields:\n                    av_log(mxf->fc, AV_LOG_DEBUG, \"video_line_map: (%d, %d), field_dominance: %d\\n\",\n                           descriptor->video_line_map[0], descriptor->video_line_map[1],\n                           descriptor->field_dominance);\n                    if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {\n                        /* Detect coded field order from VideoLineMap:\n                         *  (even, even) => bottom field coded first\n                         *  (even, odd)  => top field coded first\n                         *  (odd, even)  => top field coded first\n                         *  (odd, odd)   => bottom field coded first\n                         */\n                        if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {\n                            switch (descriptor->field_dominance) {\n                                case MXF_FIELD_DOMINANCE_DEFAULT:\n                                case MXF_FIELD_DOMINANCE_FF:\n                                    st->codecpar->field_order = AV_FIELD_TT;\n                                    break;\n                                case MXF_FIELD_DOMINANCE_FL:\n                                    st->codecpar->field_order = AV_FIELD_TB;\n                                    break;\n                                default:\n                                    avpriv_request_sample(mxf->fc,\n                                                          \"Field dominance %d support\",\n                                                          descriptor->field_dominance);\n                            }\n                        } else {\n                            switch (descriptor->field_dominance) {\n                                case MXF_FIELD_DOMINANCE_DEFAULT:\n                                case MXF_FIELD_DOMINANCE_FF:\n                                    st->codecpar->field_order = AV_FIELD_BB;\n                                    break;\n                                case MXF_FIELD_DOMINANCE_FL:\n                                    st->codecpar->field_order = AV_FIELD_BT;\n                                    break;\n                                default:\n                                    avpriv_request_sample(mxf->fc,\n                                                          \"Field dominance %d support\",\n                                                          descriptor->field_dominance);\n                            }\n                        }\n                    }\n                    /* Turn field height into frame height. */\n                    st->codecpar->height *= 2;\n                    break;\n                default:\n                    av_log(mxf->fc, AV_LOG_INFO, \"Unknown frame layout type: %d\\n\", descriptor->frame_layout);\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {\n                st->codecpar->format = descriptor->pix_fmt;\n                if (st->codecpar->format == AV_PIX_FMT_NONE) {\n                    pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,\n                                                  &descriptor->essence_codec_ul);\n                    st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;\n                    if (st->codecpar->format== AV_PIX_FMT_NONE) {\n                        st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,\n                                                                   &descriptor->essence_codec_ul)->id;\n                        if (!st->codecpar->codec_tag) {\n                            /* support files created before RP224v10 by defaulting to UYVY422\n                               if subsampling is 4:2:2 and component depth is 8-bit */\n                            if (descriptor->horiz_subsampling == 2 &&\n                                descriptor->vert_subsampling == 1 &&\n                                descriptor->component_depth == 8) {\n                                st->codecpar->format = AV_PIX_FMT_UYVY422;\n                            }\n                        }\n                    }\n                }\n            }\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n            if (material_track->sequence->origin) {\n                av_dict_set_int(&st->metadata, \"material_track_origin\", material_track->sequence->origin, 0);\n            }\n            if (source_track->sequence->origin) {\n                av_dict_set_int(&st->metadata, \"source_track_origin\", source_track->sequence->origin, 0);\n            }\n            if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den)\n                st->display_aspect_ratio = descriptor->aspect_ratio;\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);\n            /* Only overwrite existing codec ID if it is unset or A-law, which is the default according to SMPTE RP 224. */\n            if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))\n                st->codecpar->codec_id = (enum AVCodecID)container_ul->id;\n            st->codecpar->channels = descriptor->channels;\n            st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;\n\n            if (descriptor->sample_rate.den > 0) {\n                st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;\n                avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);\n            } else {\n                av_log(mxf->fc, AV_LOG_WARNING, \"invalid sample rate (%d/%d) \"\n                       \"found for stream #%d, time base forced to 1/48000\\n\",\n                       descriptor->sample_rate.num, descriptor->sample_rate.den,\n                       st->index);\n                avpriv_set_pts_info(st, 64, 1, 48000);\n            }\n\n            /* if duration is set, rescale it from EditRate to SampleRate */\n            if (st->duration != AV_NOPTS_VALUE)\n                st->duration = av_rescale_q(st->duration,\n                                            av_inv_q(material_track->edit_rate),\n                                            st->time_base);\n\n            /* TODO: implement AV_CODEC_ID_RAWAUDIO */\n            if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {\n                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n                else if (descriptor->bits_per_sample == 32)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n            } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {\n                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;\n                else if (descriptor->bits_per_sample == 32)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;\n            } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n            }\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {\n            int codec_id = mxf_get_codec_ul(mxf_data_essence_container_uls,\n                                            essence_container_ul)->id;\n            if (codec_id >= 0 &&\n                codec_id < FF_ARRAY_ELEMS(mxf_data_essence_descriptor)) {\n                av_dict_set(&st->metadata, \"data_type\",\n                            mxf_data_essence_descriptor[codec_id], 0);\n            }\n        }\n        if (descriptor->extradata) {\n            if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {\n                memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);\n            }\n        } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {\n            int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,\n                                               &descriptor->essence_codec_ul)->id;\n            if (coded_width)\n                st->codecpar->width = coded_width;\n            ret = ff_generate_avci_extradata(st);\n            if (ret < 0)\n                return ret;\n        }\n        if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && (*essence_container_ul)[15] > 0x01) {\n            /* TODO: decode timestamps */\n            st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        }\n    }\n\n    ret = 0;\nfail_and_free:\n    return ret;\n}\n\nstatic int64_t mxf_timestamp_to_int64(uint64_t timestamp)\n{\n    struct tm time = { 0 };\n    time.tm_year = (timestamp >> 48) - 1900;\n    time.tm_mon  = (timestamp >> 40 & 0xFF) - 1;\n    time.tm_mday = (timestamp >> 32 & 0xFF);\n    time.tm_hour = (timestamp >> 24 & 0xFF);\n    time.tm_min  = (timestamp >> 16 & 0xFF);\n    time.tm_sec  = (timestamp >> 8  & 0xFF);\n\n    /* msvcrt versions of strftime calls the invalid parameter handler\n     * (aborting the process if one isn't set) if the parameters are out\n     * of range. */\n    time.tm_mon  = av_clip(time.tm_mon,  0, 11);\n    time.tm_mday = av_clip(time.tm_mday, 1, 31);\n    time.tm_hour = av_clip(time.tm_hour, 0, 23);\n    time.tm_min  = av_clip(time.tm_min,  0, 59);\n    time.tm_sec  = av_clip(time.tm_sec,  0, 59);\n\n    return (int64_t)av_timegm(&time) * 1000000;\n}\n\n#define SET_STR_METADATA(pb, name, str) do { \\\n    if ((ret = mxf_read_utf16be_string(pb, size, &str)) < 0) \\\n        return ret; \\\n    av_dict_set(&s->metadata, name, str, AV_DICT_DONT_STRDUP_VAL); \\\n} while (0)\n\n#define SET_UID_METADATA(pb, name, var, str) do { \\\n    avio_read(pb, var, 16); \\\n    if ((ret = mxf_uid_to_str(var, &str)) < 0) \\\n        return ret; \\\n    av_dict_set(&s->metadata, name, str, AV_DICT_DONT_STRDUP_VAL); \\\n} while (0)\n\n#define SET_TS_METADATA(pb, name, var, str) do { \\\n    var = avio_rb64(pb); \\\n    if ((ret = avpriv_dict_set_timestamp(&s->metadata, name, mxf_timestamp_to_int64(var)) < 0)) \\\n        return ret; \\\n} while (0)\n\nstatic int mxf_read_identification_metadata(void *arg, AVIOContext *pb, int tag, int size, UID _uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    AVFormatContext *s = mxf->fc;\n    int ret;\n    UID uid = { 0 };\n    char *str = NULL;\n    uint64_t ts;\n    switch (tag) {\n    case 0x3C01:\n        SET_STR_METADATA(pb, \"company_name\", str);\n        break;\n    case 0x3C02:\n        SET_STR_METADATA(pb, \"product_name\", str);\n        break;\n    case 0x3C04:\n        SET_STR_METADATA(pb, \"product_version\", str);\n        break;\n    case 0x3C05:\n        SET_UID_METADATA(pb, \"product_uid\", uid, str);\n        break;\n    case 0x3C06:\n        SET_TS_METADATA(pb, \"modification_date\", ts, str);\n        break;\n    case 0x3C08:\n        SET_STR_METADATA(pb, \"application_platform\", str);\n        break;\n    case 0x3C09:\n        SET_UID_METADATA(pb, \"generation_uid\", uid, str);\n        break;\n    case 0x3C0A:\n        SET_UID_METADATA(pb, \"uid\", uid, str);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_preface_metadata(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    AVFormatContext *s = mxf->fc;\n    int ret;\n    char *str = NULL;\n\n    if (tag >= 0x8000 && (IS_KLV_KEY(uid, mxf_avid_project_name))) {\n        SET_STR_METADATA(pb, \"project_name\", str);\n    }\n    return 0;\n}\n\nstatic const MXFMetadataReadTableEntry mxf_metadata_read_table[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x05,0x01,0x00 }, mxf_read_primer_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x01,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x02,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x03,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x04,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x03,0x01,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x03,0x02,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x03,0x03,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x03,0x04,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x04,0x02,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x04,0x04,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x2f,0x00 }, mxf_read_preface_metadata },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x30,0x00 }, mxf_read_identification_metadata },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x18,0x00 }, mxf_read_content_storage, 0, AnyType },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x37,0x00 }, mxf_read_package, sizeof(MXFPackage), SourcePackage },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x36,0x00 }, mxf_read_package, sizeof(MXFPackage), MaterialPackage },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x0f,0x00 }, mxf_read_sequence, sizeof(MXFSequence), Sequence },\n    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0D,0x01,0x01,0x01,0x01,0x01,0x05,0x00 }, mxf_read_essence_group, sizeof(MXFEssenceGroup), EssenceGroup},\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x11,0x00 }, mxf_read_source_clip, sizeof(MXFStructuralComponent), SourceClip },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3f,0x00 }, mxf_read_tagged_value, sizeof(MXFTaggedValue), TaggedValue },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x44,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), MultipleDescriptor },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x42,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* Generic Sound */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x28,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* CDCI */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x29,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* RGBA */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x48,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* Wave */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x47,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* AES3 */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x51,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* MPEG2VideoDescriptor */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x5c,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* VANC/VBI - SMPTE 436M */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x5e,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* MPEG2AudioDescriptor */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3A,0x00 }, mxf_read_track, sizeof(MXFTrack), Track }, /* Static Track */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3B,0x00 }, mxf_read_track, sizeof(MXFTrack), Track }, /* Generic Track */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x14,0x00 }, mxf_read_timecode_component, sizeof(MXFTimecodeComponent), TimecodeComponent },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x0c,0x00 }, mxf_read_pulldown_component, sizeof(MXFPulldownComponent), PulldownComponent },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x04,0x01,0x02,0x02,0x00,0x00 }, mxf_read_cryptographic_context, sizeof(MXFCryptoContext), CryptoContext },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x10,0x01,0x00 }, mxf_read_index_table_segment, sizeof(MXFIndexTableSegment), IndexTableSegment },\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, NULL, 0, AnyType },\n};\n\nstatic int mxf_metadataset_init(MXFMetadataSet *ctx, enum MXFMetadataSetType type)\n{\n    switch (type){\n    case MultipleDescriptor:\n    case Descriptor:\n        ((MXFDescriptor*)ctx)->pix_fmt = AV_PIX_FMT_NONE;\n        ((MXFDescriptor*)ctx)->duration = AV_NOPTS_VALUE;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_local_tags(MXFContext *mxf, KLVPacket *klv, MXFMetadataReadFunc *read_child, int ctx_size, enum MXFMetadataSetType type)\n{\n    AVIOContext *pb = mxf->fc->pb;\n    MXFMetadataSet *ctx = ctx_size ? av_mallocz(ctx_size) : mxf;\n    uint64_t klv_end = avio_tell(pb) + klv->length;\n\n    if (!ctx)\n        return AVERROR(ENOMEM);\n    mxf_metadataset_init(ctx, type);\n    while (avio_tell(pb) + 4 < klv_end && !avio_feof(pb)) {\n        int ret;\n        int tag = avio_rb16(pb);\n        int size = avio_rb16(pb); /* KLV specified by 0x53 */\n        uint64_t next = avio_tell(pb) + size;\n        UID uid = {0};\n\n        av_log(mxf->fc, AV_LOG_TRACE, \"local tag %#04x size %d\\n\", tag, size);\n        if (!size) { /* ignore empty tag, needed for some files with empty UMID tag */\n            av_log(mxf->fc, AV_LOG_ERROR, \"local tag %#04x with 0 size\\n\", tag);\n            continue;\n        }\n        if (tag > 0x7FFF) { /* dynamic tag */\n            int i;\n            for (i = 0; i < mxf->local_tags_count; i++) {\n                int local_tag = AV_RB16(mxf->local_tags+i*18);\n                if (local_tag == tag) {\n                    memcpy(uid, mxf->local_tags+i*18+2, 16);\n                    av_log(mxf->fc, AV_LOG_TRACE, \"local tag %#04x\\n\", local_tag);\n                    PRINT_KEY(mxf->fc, \"uid\", uid);\n                }\n            }\n        }\n        if (ctx_size && tag == 0x3C0A) {\n            avio_read(pb, ctx->uid, 16);\n        } else if ((ret = read_child(ctx, pb, tag, size, uid, -1)) < 0) {\n            mxf_free_metadataset(&ctx, !!ctx_size);\n            return ret;\n        }\n\n        /* Accept the 64k local set limit being exceeded (Avid). Don't accept\n         * it extending past the end of the KLV though (zzuf5.mxf). */\n        if (avio_tell(pb) > klv_end) {\n            if (ctx_size) {\n                ctx->type = type;\n                mxf_free_metadataset(&ctx, !!ctx_size);\n            }\n\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"local tag %#04x extends past end of local set @ %#\"PRIx64\"\\n\",\n                   tag, klv->offset);\n            return AVERROR_INVALIDDATA;\n        } else if (avio_tell(pb) <= next)   /* only seek forward, else this can loop for a long time */\n            avio_seek(pb, next, SEEK_SET);\n    }\n    if (ctx_size) ctx->type = type;\n    return ctx_size ? mxf_add_metadata_set(mxf, ctx) : 0;\n}\n\n/**\n * Matches any partition pack key, in other words:\n * - HeaderPartition\n * - BodyPartition\n * - FooterPartition\n * @return non-zero if the key is a partition pack key, zero otherwise\n */\nstatic int mxf_is_partition_pack_key(UID key)\n{\n    //NOTE: this is a little lax since it doesn't constraint key[14]\n    return !memcmp(key, mxf_header_partition_pack_key, 13) &&\n            key[13] >= 2 && key[13] <= 4;\n}\n\n/**\n * Parses a metadata KLV\n * @return <0 on error, 0 otherwise\n */\nstatic int mxf_parse_klv(MXFContext *mxf, KLVPacket klv, MXFMetadataReadFunc *read,\n                                     int ctx_size, enum MXFMetadataSetType type)\n{\n    AVFormatContext *s = mxf->fc;\n    int res;\n    if (klv.key[5] == 0x53) {\n        res = mxf_read_local_tags(mxf, &klv, read, ctx_size, type);\n    } else {\n        uint64_t next = avio_tell(s->pb) + klv.length;\n        res = read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n        /* only seek forward, else this can loop for a long time */\n        if (avio_tell(s->pb) > next) {\n            av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n                   klv.offset);\n            return AVERROR_INVALIDDATA;\n        }\n\n        avio_seek(s->pb, next, SEEK_SET);\n    }\n    if (res < 0) {\n        av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n        return res;\n    }\n    return 0;\n}\n\n/**\n * Seeks to the previous partition and parses it, if possible\n * @return <= 0 if we should stop parsing, > 0 if we should keep going\n */\nstatic int mxf_seek_to_previous_partition(MXFContext *mxf)\n{\n    AVIOContext *pb = mxf->fc->pb;\n    KLVPacket klv;\n    int64_t current_partition_ofs;\n    int ret;\n\n    if (!mxf->current_partition ||\n        mxf->run_in + mxf->current_partition->previous_partition <= mxf->last_forward_tell)\n        return 0;   /* we've parsed all partitions */\n\n    /* seek to previous partition */\n    current_partition_ofs = mxf->current_partition->pack_ofs;   //includes run-in\n    avio_seek(pb, mxf->run_in + mxf->current_partition->previous_partition, SEEK_SET);\n    mxf->current_partition = NULL;\n\n    av_log(mxf->fc, AV_LOG_TRACE, \"seeking to previous partition\\n\");\n\n    /* Make sure this is actually a PartitionPack, and if so parse it.\n     * See deadlock2.mxf\n     */\n    if ((ret = klv_read_packet(&klv, pb)) < 0) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to read PartitionPack KLV\\n\");\n        return ret;\n    }\n\n    if (!mxf_is_partition_pack_key(klv.key)) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"PreviousPartition @ %\" PRIx64 \" isn't a PartitionPack\\n\", klv.offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* We can't just check ofs >= current_partition_ofs because PreviousPartition\n     * can point to just before the current partition, causing klv_read_packet()\n     * to sync back up to it. See deadlock3.mxf\n     */\n    if (klv.offset >= current_partition_ofs) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"PreviousPartition for PartitionPack @ %\"\n               PRIx64 \" indirectly points to itself\\n\", current_partition_ofs);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = mxf_parse_klv(mxf, klv, mxf_read_partition_pack, 0, 0)) < 0)\n        return ret;\n\n    return 1;\n}\n\n/**\n * Called when essence is encountered\n * @return <= 0 if we should stop parsing, > 0 if we should keep going\n */\nstatic int mxf_parse_handle_essence(MXFContext *mxf)\n{\n    AVIOContext *pb = mxf->fc->pb;\n    int64_t ret;\n\n    if (mxf->parsing_backward) {\n        return mxf_seek_to_previous_partition(mxf);\n    } else {\n        if (!mxf->footer_partition) {\n            av_log(mxf->fc, AV_LOG_TRACE, \"no FooterPartition\\n\");\n            return 0;\n        }\n\n        av_log(mxf->fc, AV_LOG_TRACE, \"seeking to FooterPartition\\n\");\n\n        /* remember where we were so we don't end up seeking further back than this */\n        mxf->last_forward_tell = avio_tell(pb);\n\n        if (!(pb->seekable & AVIO_SEEKABLE_NORMAL)) {\n            av_log(mxf->fc, AV_LOG_INFO, \"file is not seekable - not parsing FooterPartition\\n\");\n            return -1;\n        }\n\n        /* seek to FooterPartition and parse backward */\n        if ((ret = avio_seek(pb, mxf->run_in + mxf->footer_partition, SEEK_SET)) < 0) {\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"failed to seek to FooterPartition @ 0x%\" PRIx64\n                   \" (%\"PRId64\") - partial file?\\n\",\n                   mxf->run_in + mxf->footer_partition, ret);\n            return ret;\n        }\n\n        mxf->current_partition = NULL;\n        mxf->parsing_backward = 1;\n    }\n\n    return 1;\n}\n\n/**\n * Called when the next partition or EOF is encountered\n * @return <= 0 if we should stop parsing, > 0 if we should keep going\n */\nstatic int mxf_parse_handle_partition_or_eof(MXFContext *mxf)\n{\n    return mxf->parsing_backward ? mxf_seek_to_previous_partition(mxf) : 1;\n}\n\n/**\n * Figures out the proper offset and length of the essence container in each partition\n */\nstatic void mxf_compute_essence_containers(MXFContext *mxf)\n{\n    int x;\n\n    /* everything is already correct */\n    if (mxf->op == OPAtom)\n        return;\n\n    for (x = 0; x < mxf->partitions_count; x++) {\n        MXFPartition *p = &mxf->partitions[x];\n\n        if (!p->body_sid)\n            continue;       /* BodySID == 0 -> no essence */\n\n        if (x >= mxf->partitions_count - 1)\n            break;          /* FooterPartition - can't compute length (and we don't need to) */\n\n        /* essence container spans to the next partition */\n        p->essence_length = mxf->partitions[x+1].this_partition - p->essence_offset;\n\n        if (p->essence_length < 0) {\n            /* next ThisPartition < essence_offset */\n            p->essence_length = 0;\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"partition %i: bad ThisPartition = %\"PRIX64\"\\n\",\n                   x+1, mxf->partitions[x+1].this_partition);\n        }\n    }\n}\n\nstatic int64_t round_to_kag(int64_t position, int kag_size)\n{\n    /* TODO: account for run-in? the spec isn't clear whether KAG should account for it */\n    /* NOTE: kag_size may be any integer between 1 - 2^10 */\n    int64_t ret = (position / kag_size) * kag_size;\n    return ret == position ? ret : ret + kag_size;\n}\n\nstatic int is_pcm(enum AVCodecID codec_id)\n{\n    /* we only care about \"normal\" PCM codecs until we get samples */\n    return codec_id >= AV_CODEC_ID_PCM_S16LE && codec_id < AV_CODEC_ID_PCM_S24DAUD;\n}\n\nstatic AVStream* mxf_get_opatom_stream(MXFContext *mxf)\n{\n    int i;\n\n    if (mxf->op != OPAtom)\n        return NULL;\n\n    for (i = 0; i < mxf->fc->nb_streams; i++) {\n        if (mxf->fc->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_DATA)\n            continue;\n        return mxf->fc->streams[i];\n    }\n    return NULL;\n}\n\n/**\n * Deal with the case where for some audio atoms EditUnitByteCount is\n * very small (2, 4..). In those cases we should read more than one\n * sample per call to mxf_read_packet().\n */\nstatic void mxf_handle_small_eubc(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n\n    /* assuming non-OPAtom == frame wrapped\n     * no sane writer would wrap 2 byte PCM packets with 20 byte headers.. */\n    AVStream *st = mxf_get_opatom_stream(mxf);\n    if (!st)\n        return;\n\n    /* expect PCM with exactly one index table segment and a small (< 32) EUBC */\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO         ||\n        !is_pcm(st->codecpar->codec_id)                        ||\n        mxf->nb_index_tables != 1                              ||\n        mxf->index_tables[0].nb_segments != 1                  ||\n        mxf->index_tables[0].segments[0]->edit_unit_byte_count >= 32)\n        return;\n\n    /* arbitrarily default to 48 kHz PAL audio frame size */\n    /* TODO: We could compute this from the ratio between the audio\n     *       and video edit rates for 48 kHz NTSC we could use the\n     *       1802-1802-1802-1802-1801 pattern. */\n    mxf->edit_units_per_packet = 1920;\n}\n\n/**\n * Deal with the case where OPAtom files does not have any IndexTableSegments.\n */\nstatic int mxf_handle_missing_index_segment(MXFContext *mxf)\n{\n    AVFormatContext *s = mxf->fc;\n    AVStream *st = NULL;\n    MXFIndexTableSegment *segment = NULL;\n    MXFPartition *p = NULL;\n    int essence_partition_count = 0;\n    int i, ret;\n\n    st = mxf_get_opatom_stream(mxf);\n    if (!st)\n        return 0;\n\n    /* TODO: support raw video without an index if they exist */\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO || !is_pcm(st->codecpar->codec_id))\n        return 0;\n\n    /* check if file already has a IndexTableSegment */\n    for (i = 0; i < mxf->metadata_sets_count; i++) {\n        if (mxf->metadata_sets[i]->type == IndexTableSegment)\n            return 0;\n    }\n\n    /* find the essence partition */\n    for (i = 0; i < mxf->partitions_count; i++) {\n        /* BodySID == 0 -> no essence */\n        if (!mxf->partitions[i].body_sid)\n            continue;\n\n        p = &mxf->partitions[i];\n        essence_partition_count++;\n    }\n\n    /* only handle files with a single essence partition */\n    if (essence_partition_count != 1)\n        return 0;\n\n    if (!(segment = av_mallocz(sizeof(*segment))))\n        return AVERROR(ENOMEM);\n\n    if ((ret = mxf_add_metadata_set(mxf, segment))) {\n        mxf_free_metadataset((MXFMetadataSet**)&segment, 1);\n        return ret;\n    }\n\n    segment->type = IndexTableSegment;\n    /* stream will be treated as small EditUnitByteCount */\n    segment->edit_unit_byte_count = (av_get_bits_per_sample(st->codecpar->codec_id) * st->codecpar->channels) >> 3;\n    segment->index_start_position = 0;\n    segment->index_duration = s->streams[0]->duration;\n    segment->index_sid = p->index_sid;\n    segment->body_sid = p->body_sid;\n    return 0;\n}\n\nstatic void mxf_read_random_index_pack(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n    uint32_t length;\n    int64_t file_size, max_rip_length, min_rip_length;\n    KLVPacket klv;\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL))\n        return;\n\n    file_size = avio_size(s->pb);\n\n    /* S377m says to check the RIP length for \"silly\" values, without defining \"silly\".\n     * The limit below assumes a file with nothing but partition packs and a RIP.\n     * Before changing this, consider that a muxer may place each sample in its own partition.\n     *\n     * 105 is the size of the smallest possible PartitionPack\n     * 12 is the size of each RIP entry\n     * 28 is the size of the RIP header and footer, assuming an 8-byte BER\n     */\n    max_rip_length = ((file_size - mxf->run_in) / 105) * 12 + 28;\n    max_rip_length = FFMIN(max_rip_length, INT_MAX); //2 GiB and up is also silly\n\n    /* We're only interested in RIPs with at least two entries.. */\n    min_rip_length = 16+1+24+4;\n\n    /* See S377m section 11 */\n    avio_seek(s->pb, file_size - 4, SEEK_SET);\n    length = avio_rb32(s->pb);\n\n    if (length < min_rip_length || length > max_rip_length)\n        goto end;\n    avio_seek(s->pb, file_size - length, SEEK_SET);\n    if (klv_read_packet(&klv, s->pb) < 0 ||\n        !IS_KLV_KEY(klv.key, mxf_random_index_pack_key) ||\n        klv.length != length - 20)\n        goto end;\n\n    avio_skip(s->pb, klv.length - 12);\n    mxf->footer_partition = avio_rb64(s->pb);\n\n    /* sanity check */\n    if (mxf->run_in + mxf->footer_partition >= file_size) {\n        av_log(s, AV_LOG_WARNING, \"bad FooterPartition in RIP - ignoring\\n\");\n        mxf->footer_partition = 0;\n    }\n\nend:\n    avio_seek(s->pb, mxf->run_in, SEEK_SET);\n}\n\nstatic int mxf_read_header(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n    KLVPacket klv;\n    int64_t essence_offset = 0;\n    int ret;\n\n    mxf->last_forward_tell = INT64_MAX;\n    mxf->edit_units_per_packet = 1;\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_seek(s->pb, -14, SEEK_CUR);\n    mxf->fc = s;\n    mxf->run_in = avio_tell(s->pb);\n\n    mxf_read_random_index_pack(s);\n\n    while (!avio_feof(s->pb)) {\n        const MXFMetadataReadTableEntry *metadata;\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n            /* EOF - seek to previous partition or stop */\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n                break;\n            else\n                continue;\n        }\n\n        PRINT_KEY(s, \"read header\", klv.key);\n        av_log(s, AV_LOG_TRACE, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n            if (!mxf->current_partition) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"found essence prior to first PartitionPack\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (!mxf->current_partition->essence_offset) {\n                /* for OP1a we compute essence_offset\n                 * for OPAtom we point essence_offset after the KL (usually op1a_essence_offset + 20 or 25)\n                 * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1a_essence_offset\n                 *       for OPAtom we still need the actual essence_offset though (the KL's length can vary)\n                 */\n                int64_t op1a_essence_offset =\n                    round_to_kag(mxf->current_partition->this_partition +\n                                 mxf->current_partition->pack_length,       mxf->current_partition->kag_size) +\n                    round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n                    round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n\n                if (mxf->op == OPAtom) {\n                    /* point essence_offset to the actual data\n                    * OPAtom has all the essence in one big KLV\n                    */\n                    mxf->current_partition->essence_offset = avio_tell(s->pb);\n                    mxf->current_partition->essence_length = klv.length;\n                } else {\n                    /* NOTE: op1a_essence_offset may be less than to klv.offset (C0023S01.mxf)  */\n                    mxf->current_partition->essence_offset = op1a_essence_offset;\n                }\n            }\n\n            if (!essence_offset)\n                essence_offset = klv.offset;\n\n            /* seek to footer, previous partition or stop */\n            if (mxf_parse_handle_essence(mxf) <= 0)\n                break;\n            continue;\n        } else if (mxf_is_partition_pack_key(klv.key) && mxf->current_partition) {\n            /* next partition pack - keep going, seek to previous partition or stop */\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n                break;\n            else if (mxf->parsing_backward)\n                continue;\n            /* we're still parsing forward. proceed to parsing this partition pack */\n        }\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n                if ((ret = mxf_parse_klv(mxf, klv, metadata->read, metadata->ctx_size, metadata->type)) < 0)\n                    goto fail;\n                break;\n            }\n        }\n        if (!metadata->read) {\n            av_log(s, AV_LOG_VERBOSE, \"Dark key \" PRIxUID \"\\n\",\n                            UID_ARG(klv.key));\n            avio_skip(s->pb, klv.length);\n        }\n    }\n    /* FIXME avoid seek */\n    if (!essence_offset)  {\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n    mxf_compute_essence_containers(mxf);\n\n    /* we need to do this before computing the index tables\n     * to be able to fill in zero IndexDurations with st->duration */\n    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n        goto fail;\n\n    mxf_handle_missing_index_segment(mxf);\n    if ((ret = mxf_compute_index_tables(mxf)) < 0)\n        goto fail;\n\n    if (mxf->nb_index_tables > 1) {\n        /* TODO: look up which IndexSID to use via EssenceContainerData */\n        av_log(mxf->fc, AV_LOG_INFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\",\n               mxf->nb_index_tables, mxf->index_tables[0].index_sid);\n    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"cannot demux OPAtom without an index\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    mxf_handle_small_eubc(s);\n\n    return 0;\nfail:\n    mxf_read_close(s);\n\n    return ret;\n}\n\n/**\n * Sets mxf->current_edit_unit based on what offset we're currently at.\n * @return next_ofs if OK, <0 on error\n */\nstatic int64_t mxf_set_current_edit_unit(MXFContext *mxf, int64_t current_offset)\n{\n    int64_t last_ofs = -1, next_ofs = -1;\n    MXFIndexTable *t = &mxf->index_tables[0];\n\n    /* this is called from the OP1a demuxing logic, which means there\n     * may be no index tables */\n    if (mxf->nb_index_tables <= 0)\n        return -1;\n\n    /* find mxf->current_edit_unit so that the next edit unit starts ahead of current_offset */\n    while (mxf->current_edit_unit >= 0) {\n        if (mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit + 1, NULL, &next_ofs, 0) < 0)\n            return -1;\n\n        if (next_ofs <= last_ofs) {\n            /* large next_ofs didn't change or current_edit_unit wrapped\n             * around this fixes the infinite loop on zzuf3.mxf */\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"next_ofs didn't change. not deriving packet timestamps\\n\");\n            return -1;\n        }\n\n        if (next_ofs > current_offset)\n            break;\n\n        last_ofs = next_ofs;\n        mxf->current_edit_unit++;\n    }\n\n    /* not checking mxf->current_edit_unit >= t->nb_ptses here since CBR files may lack IndexEntryArrays */\n    if (mxf->current_edit_unit < 0)\n        return -1;\n\n    return next_ofs;\n}\n\nstatic int mxf_compute_sample_count(MXFContext *mxf, int stream_index,\n                                    uint64_t *sample_count)\n{\n    int i, total = 0, size = 0;\n    AVStream *st = mxf->fc->streams[stream_index];\n    MXFTrack *track = st->priv_data;\n    AVRational time_base = av_inv_q(track->edit_rate);\n    AVRational sample_rate = av_inv_q(st->time_base);\n    const MXFSamplesPerFrame *spf = NULL;\n\n    if ((sample_rate.num / sample_rate.den) == 48000)\n        spf = ff_mxf_get_samples_per_frame(mxf->fc, time_base);\n    if (!spf) {\n        int remainder = (sample_rate.num * time_base.num) %\n                        (time_base.den * sample_rate.den);\n        *sample_count = av_q2d(av_mul_q((AVRational){mxf->current_edit_unit, 1},\n                                        av_mul_q(sample_rate, time_base)));\n        if (remainder)\n            av_log(mxf->fc, AV_LOG_WARNING,\n                   \"seeking detected on stream #%d with time base (%d/%d) and \"\n                   \"sample rate (%d/%d), audio pts won't be accurate.\\n\",\n                   stream_index, time_base.num, time_base.den,\n                   sample_rate.num, sample_rate.den);\n        return 0;\n    }\n\n    while (spf->samples_per_frame[size]) {\n        total += spf->samples_per_frame[size];\n        size++;\n    }\n\n    av_assert2(size);\n\n    *sample_count = (mxf->current_edit_unit / size) * (uint64_t)total;\n    for (i = 0; i < mxf->current_edit_unit % size; i++) {\n        *sample_count += spf->samples_per_frame[i];\n    }\n\n    return 0;\n}\n\nstatic int mxf_set_audio_pts(MXFContext *mxf, AVCodecParameters *par,\n                             AVPacket *pkt)\n{\n    MXFTrack *track = mxf->fc->streams[pkt->stream_index]->priv_data;\n    int64_t bits_per_sample = par->bits_per_coded_sample;\n\n    if (!bits_per_sample)\n        bits_per_sample = av_get_bits_per_sample(par->codec_id);\n\n    pkt->pts = track->sample_count;\n\n    if (   par->channels <= 0\n        || bits_per_sample <= 0\n        || par->channels * (int64_t)bits_per_sample < 8)\n        return AVERROR(EINVAL);\n    track->sample_count += pkt->size / (par->channels * (int64_t)bits_per_sample / 8);\n    return 0;\n}\n\nstatic int mxf_read_packet_old(AVFormatContext *s, AVPacket *pkt)\n{\n    KLVPacket klv;\n    MXFContext *mxf = s->priv_data;\n    int ret;\n\n    while ((ret = klv_read_packet(&klv, s->pb)) == 0) {\n        PRINT_KEY(s, \"read packet\", klv.key);\n        av_log(s, AV_LOG_TRACE, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key)) {\n            ret = mxf_decrypt_triplet(s, pkt, &klv);\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"invalid encoded triplet\\n\");\n                return ret;\n            }\n            return 0;\n        }\n        if (IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n            IS_KLV_KEY(klv.key, mxf_canopus_essence_element_key) ||\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key)) {\n            int index = mxf_get_stream_index(s, &klv);\n            int64_t next_ofs, next_klv;\n            AVStream *st;\n            MXFTrack *track;\n            AVCodecParameters *par;\n\n            if (index < 0) {\n                av_log(s, AV_LOG_ERROR,\n                       \"error getting stream index %\"PRIu32\"\\n\",\n                       AV_RB32(klv.key + 12));\n                goto skip;\n            }\n\n            st = s->streams[index];\n            track = st->priv_data;\n\n            if (s->streams[index]->discard == AVDISCARD_ALL)\n                goto skip;\n\n            next_klv = avio_tell(s->pb) + klv.length;\n            next_ofs = mxf_set_current_edit_unit(mxf, klv.offset);\n\n            if (next_ofs >= 0 && next_klv > next_ofs) {\n                /* if this check is hit then it's possible OPAtom was treated as OP1a\n                 * truncate the packet since it's probably very large (>2 GiB is common) */\n                avpriv_request_sample(s,\n                                      \"OPAtom misinterpreted as OP1a? \"\n                                      \"KLV for edit unit %i extending into \"\n                                      \"next edit unit\",\n                                      mxf->current_edit_unit);\n                klv.length = next_ofs - avio_tell(s->pb);\n            }\n\n            /* check for 8 channels AES3 element */\n            if (klv.key[12] == 0x06 && klv.key[13] == 0x01 && klv.key[14] == 0x10) {\n                ret = mxf_get_d10_aes3_packet(s->pb, s->streams[index],\n                                              pkt, klv.length);\n                if (ret < 0) {\n                    av_log(s, AV_LOG_ERROR, \"error reading D-10 aes3 frame\\n\");\n                    return ret;\n                }\n            } else {\n                ret = av_get_packet(s->pb, pkt, klv.length);\n                if (ret < 0)\n                    return ret;\n            }\n            pkt->stream_index = index;\n            pkt->pos = klv.offset;\n\n            par = st->codecpar;\n\n            if (par->codec_type == AVMEDIA_TYPE_VIDEO && next_ofs >= 0) {\n                /* mxf->current_edit_unit good - see if we have an\n                 * index table to derive timestamps from */\n                MXFIndexTable *t = &mxf->index_tables[0];\n\n                if (mxf->nb_index_tables >= 1 && mxf->current_edit_unit < t->nb_ptses) {\n                    pkt->dts = mxf->current_edit_unit + t->first_dts;\n                    pkt->pts = t->ptses[mxf->current_edit_unit];\n                } else if (track && track->intra_only) {\n                    /* intra-only -> PTS = EditUnit.\n                     * let utils.c figure out DTS since it can be < PTS if low_delay = 0 (Sony IMX30) */\n                    pkt->pts = mxf->current_edit_unit;\n                }\n            } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {\n                ret = mxf_set_audio_pts(mxf, par, pkt);\n                if (ret < 0)\n                    return ret;\n            }\n\n            /* seek for truncated packets */\n            avio_seek(s->pb, next_klv, SEEK_SET);\n\n            return 0;\n        } else\n        skip:\n            avio_skip(s->pb, klv.length);\n    }\n    return avio_feof(s->pb) ? AVERROR_EOF : ret;\n}\n\nstatic int mxf_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MXFContext *mxf = s->priv_data;\n    int ret, size;\n    int64_t ret64, pos, next_pos;\n    AVStream *st;\n    MXFIndexTable *t;\n    int edit_units;\n\n    if (mxf->op != OPAtom)\n        return mxf_read_packet_old(s, pkt);\n\n    // If we have no streams then we basically are at EOF\n    st = mxf_get_opatom_stream(mxf);\n    if (!st)\n        return AVERROR_EOF;\n\n    /* OPAtom - clip wrapped demuxing */\n    /* NOTE: mxf_read_header() makes sure nb_index_tables > 0 for OPAtom */\n    t = &mxf->index_tables[0];\n\n    if (mxf->current_edit_unit >= st->duration)\n        return AVERROR_EOF;\n\n    edit_units = FFMIN(mxf->edit_units_per_packet, st->duration - mxf->current_edit_unit);\n\n    if ((ret = mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit, NULL, &pos, 1)) < 0)\n        return ret;\n\n    /* compute size by finding the next edit unit or the end of the essence container\n     * not pretty, but it works */\n    if ((ret = mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit + edit_units, NULL, &next_pos, 0)) < 0 &&\n        (next_pos = mxf_essence_container_end(mxf, t->body_sid)) <= 0) {\n        av_log(s, AV_LOG_ERROR, \"unable to compute the size of the last packet\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((size = next_pos - pos) <= 0) {\n        av_log(s, AV_LOG_ERROR, \"bad size: %i\\n\", size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret64 = avio_seek(s->pb, pos, SEEK_SET)) < 0)\n        return ret64;\n\n    if ((size = av_get_packet(s->pb, pkt, size)) < 0)\n        return size;\n\n    pkt->stream_index = st->index;\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && t->ptses &&\n        mxf->current_edit_unit >= 0 && mxf->current_edit_unit < t->nb_ptses) {\n        pkt->dts = mxf->current_edit_unit + t->first_dts;\n        pkt->pts = t->ptses[mxf->current_edit_unit];\n    } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n        int ret = mxf_set_audio_pts(mxf, st->codecpar, pkt);\n        if (ret < 0)\n            return ret;\n    }\n\n    mxf->current_edit_unit += edit_units;\n\n    return 0;\n}\n\nstatic int mxf_read_close(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n    int i;\n\n    av_freep(&mxf->packages_refs);\n\n    for (i = 0; i < s->nb_streams; i++)\n        s->streams[i]->priv_data = NULL;\n\n    for (i = 0; i < mxf->metadata_sets_count; i++) {\n        mxf_free_metadataset(mxf->metadata_sets + i, 1);\n    }\n    av_freep(&mxf->partitions);\n    av_freep(&mxf->metadata_sets);\n    av_freep(&mxf->aesc);\n    av_freep(&mxf->local_tags);\n\n    if (mxf->index_tables) {\n        for (i = 0; i < mxf->nb_index_tables; i++) {\n            av_freep(&mxf->index_tables[i].segments);\n            av_freep(&mxf->index_tables[i].ptses);\n            av_freep(&mxf->index_tables[i].fake_index);\n            av_freep(&mxf->index_tables[i].offsets);\n        }\n    }\n    av_freep(&mxf->index_tables);\n\n    return 0;\n}\n\nstatic int mxf_probe(AVProbeData *p) {\n    const uint8_t *bufp = p->buf;\n    const uint8_t *end = p->buf + p->buf_size;\n\n    if (p->buf_size < sizeof(mxf_header_partition_pack_key))\n        return 0;\n\n    /* Must skip Run-In Sequence and search for MXF header partition pack key SMPTE 377M 5.5 */\n    end -= sizeof(mxf_header_partition_pack_key);\n\n    for (; bufp < end;) {\n        if (!((bufp[13] - 1) & 0xF2)){\n            if (AV_RN32(bufp   ) == AV_RN32(mxf_header_partition_pack_key   ) &&\n                AV_RN32(bufp+ 4) == AV_RN32(mxf_header_partition_pack_key+ 4) &&\n                AV_RN32(bufp+ 8) == AV_RN32(mxf_header_partition_pack_key+ 8) &&\n                AV_RN16(bufp+12) == AV_RN16(mxf_header_partition_pack_key+12))\n                return AVPROBE_SCORE_MAX;\n            bufp ++;\n        } else\n            bufp += 10;\n    }\n\n    return 0;\n}\n\n/* rudimentary byte seek */\n/* XXX: use MXF Index */\nstatic int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n{\n    AVStream *st = s->streams[stream_index];\n    int64_t seconds;\n    MXFContext* mxf = s->priv_data;\n    int64_t seekpos;\n    int i, ret;\n    MXFIndexTable *t;\n    MXFTrack *source_track = st->priv_data;\n\n    if(st->codecpar->codec_type == AVMEDIA_TYPE_DATA)\n        return 0;\n\n    /* if audio then truncate sample_time to EditRate */\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n        sample_time = av_rescale_q(sample_time, st->time_base,\n                                   av_inv_q(source_track->edit_rate));\n\n    if (mxf->nb_index_tables <= 0) {\n    if (!s->bit_rate)\n        return AVERROR_INVALIDDATA;\n    if (sample_time < 0)\n        sample_time = 0;\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n    seekpos = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET);\n    if (seekpos < 0)\n        return seekpos;\n\n    ff_update_cur_dts(s, st, sample_time);\n    mxf->current_edit_unit = sample_time;\n    } else {\n        t = &mxf->index_tables[0];\n\n        /* clamp above zero, else ff_index_search_timestamp() returns negative\n         * this also means we allow seeking before the start */\n        sample_time = FFMAX(sample_time, 0);\n\n        if (t->fake_index) {\n            /* The first frames may not be keyframes in presentation order, so\n             * we have to advance the target to be able to find the first\n             * keyframe backwards... */\n            if (!(flags & AVSEEK_FLAG_ANY) &&\n                (flags & AVSEEK_FLAG_BACKWARD) &&\n                t->ptses[0] != AV_NOPTS_VALUE &&\n                sample_time < t->ptses[0] &&\n                (t->fake_index[t->ptses[0]].flags & AVINDEX_KEYFRAME))\n                sample_time = t->ptses[0];\n\n            /* behave as if we have a proper index */\n            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)\n                return sample_time;\n            /* get the stored order index from the display order index */\n            sample_time += t->offsets[sample_time];\n        } else {\n            /* no IndexEntryArray (one or more CBR segments)\n             * make sure we don't seek past the end */\n            sample_time = FFMIN(sample_time, source_track->original_duration - 1);\n        }\n\n        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) < 0)\n            return ret;\n\n        ff_update_cur_dts(s, st, sample_time);\n        mxf->current_edit_unit = sample_time;\n        avio_seek(s->pb, seekpos, SEEK_SET);\n    }\n\n    // Update all tracks sample count\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *cur_st = s->streams[i];\n        MXFTrack *cur_track = cur_st->priv_data;\n        uint64_t current_sample_count = 0;\n        if (cur_st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            ret = mxf_compute_sample_count(mxf, i, &current_sample_count);\n            if (ret < 0)\n                return ret;\n\n            cur_track->sample_count = current_sample_count;\n        }\n    }\n    return 0;\n}\n\nAVInputFormat ff_mxf_demuxer = {\n    .name           = \"mxf\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"MXF (Material eXchange Format)\"),\n    .flags          = AVFMT_SEEK_TO_PTS,\n    .priv_data_size = sizeof(MXFContext),\n    .read_probe     = mxf_probe,\n    .read_header    = mxf_read_header,\n    .read_packet    = mxf_read_packet,\n    .read_close     = mxf_read_close,\n    .read_seek      = mxf_read_seek,\n};\n"], "fixing_code": ["/*\n * MXF demuxer.\n * Copyright (c) 2006 SmartJog S.A., Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/*\n * References\n * SMPTE 336M KLV Data Encoding Protocol Using Key-Length-Value\n * SMPTE 377M MXF File Format Specifications\n * SMPTE 378M Operational Pattern 1a\n * SMPTE 379M MXF Generic Container\n * SMPTE 381M Mapping MPEG Streams into the MXF Generic Container\n * SMPTE 382M Mapping AES3 and Broadcast Wave Audio into the MXF Generic Container\n * SMPTE 383M Mapping DV-DIF Data to the MXF Generic Container\n *\n * Principle\n * Search for Track numbers which will identify essence element KLV packets.\n * Search for SourcePackage which define tracks which contains Track numbers.\n * Material Package contains tracks with reference to SourcePackage tracks.\n * Search for Descriptors (Picture, Sound) which contains codec info and parameters.\n * Assign Descriptors to correct Tracks.\n *\n * Metadata reading functions read Local Tags, get InstanceUID(0x3C0A) then add MetaDataSet to MXFContext.\n * Metadata parsing resolves Strong References to objects.\n *\n * Simple demuxer, only OP1A supported and some files might not work at all.\n * Only tracks with associated descriptors will be decoded. \"Highly Desirable\" SMPTE 377M D.1\n */\n\n#include <inttypes.h>\n\n#include \"libavutil/aes.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavcodec/bytestream.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/timecode.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"mxf.h\"\n\ntypedef enum {\n    Header,\n    BodyPartition,\n    Footer\n} MXFPartitionType;\n\ntypedef enum {\n    OP1a = 1,\n    OP1b,\n    OP1c,\n    OP2a,\n    OP2b,\n    OP2c,\n    OP3a,\n    OP3b,\n    OP3c,\n    OPAtom,\n    OPSONYOpt,  /* FATE sample, violates the spec in places */\n} MXFOP;\n\ntypedef struct MXFPartition {\n    int closed;\n    int complete;\n    MXFPartitionType type;\n    uint64_t previous_partition;\n    int index_sid;\n    int body_sid;\n    int64_t this_partition;\n    int64_t essence_offset;         ///< absolute offset of essence\n    int64_t essence_length;\n    int32_t kag_size;\n    int64_t header_byte_count;\n    int64_t index_byte_count;\n    int pack_length;\n    int64_t pack_ofs;               ///< absolute offset of pack in file, including run-in\n} MXFPartition;\n\ntypedef struct MXFCryptoContext {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID source_container_ul;\n} MXFCryptoContext;\n\ntypedef struct MXFStructuralComponent {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID source_package_ul;\n    UID source_package_uid;\n    UID data_definition_ul;\n    int64_t duration;\n    int64_t start_position;\n    int source_track_id;\n} MXFStructuralComponent;\n\ntypedef struct MXFSequence {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID data_definition_ul;\n    UID *structural_components_refs;\n    int structural_components_count;\n    int64_t duration;\n    uint8_t origin;\n} MXFSequence;\n\ntypedef struct MXFTrack {\n    UID uid;\n    enum MXFMetadataSetType type;\n    int drop_frame;\n    int start_frame;\n    struct AVRational rate;\n    AVTimecode tc;\n} MXFTimecodeComponent;\n\ntypedef struct {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID input_segment_ref;\n} MXFPulldownComponent;\n\ntypedef struct {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID *structural_components_refs;\n    int structural_components_count;\n    int64_t duration;\n} MXFEssenceGroup;\n\ntypedef struct {\n    UID uid;\n    enum MXFMetadataSetType type;\n    char *name;\n    char *value;\n} MXFTaggedValue;\n\ntypedef struct {\n    UID uid;\n    enum MXFMetadataSetType type;\n    MXFSequence *sequence; /* mandatory, and only one */\n    UID sequence_ref;\n    int track_id;\n    char *name;\n    uint8_t track_number[4];\n    AVRational edit_rate;\n    int intra_only;\n    uint64_t sample_count;\n    int64_t original_duration; /* st->duration in SampleRate/EditRate units */\n} MXFTrack;\n\ntypedef struct MXFDescriptor {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID essence_container_ul;\n    UID essence_codec_ul;\n    UID codec_ul;\n    AVRational sample_rate;\n    AVRational aspect_ratio;\n    int width;\n    int height; /* Field height, not frame height */\n    int frame_layout; /* See MXFFrameLayout enum */\n    int video_line_map[2];\n#define MXF_FIELD_DOMINANCE_DEFAULT 0\n#define MXF_FIELD_DOMINANCE_FF 1 /* coded first, displayed first */\n#define MXF_FIELD_DOMINANCE_FL 2 /* coded first, displayed last */\n    int field_dominance;\n    int channels;\n    int bits_per_sample;\n    int64_t duration; /* ContainerDuration optional property */\n    unsigned int component_depth;\n    unsigned int horiz_subsampling;\n    unsigned int vert_subsampling;\n    UID *sub_descriptors_refs;\n    int sub_descriptors_count;\n    int linked_track_id;\n    uint8_t *extradata;\n    int extradata_size;\n    enum AVPixelFormat pix_fmt;\n} MXFDescriptor;\n\ntypedef struct MXFIndexTableSegment {\n    UID uid;\n    enum MXFMetadataSetType type;\n    int edit_unit_byte_count;\n    int index_sid;\n    int body_sid;\n    AVRational index_edit_rate;\n    uint64_t index_start_position;\n    uint64_t index_duration;\n    int8_t *temporal_offset_entries;\n    int *flag_entries;\n    uint64_t *stream_offset_entries;\n    int nb_index_entries;\n} MXFIndexTableSegment;\n\ntypedef struct MXFPackage {\n    UID uid;\n    enum MXFMetadataSetType type;\n    UID package_uid;\n    UID package_ul;\n    UID *tracks_refs;\n    int tracks_count;\n    MXFDescriptor *descriptor; /* only one */\n    UID descriptor_ref;\n    char *name;\n    UID *comment_refs;\n    int comment_count;\n} MXFPackage;\n\ntypedef struct MXFMetadataSet {\n    UID uid;\n    enum MXFMetadataSetType type;\n} MXFMetadataSet;\n\n/* decoded index table */\ntypedef struct MXFIndexTable {\n    int index_sid;\n    int body_sid;\n    int nb_ptses;               /* number of PTSes or total duration of index */\n    int64_t first_dts;          /* DTS = EditUnit + first_dts */\n    int64_t *ptses;             /* maps EditUnit -> PTS */\n    int nb_segments;\n    MXFIndexTableSegment **segments;    /* sorted by IndexStartPosition */\n    AVIndexEntry *fake_index;   /* used for calling ff_index_search_timestamp() */\n    int8_t *offsets;            /* temporal offsets for display order to stored order conversion */\n} MXFIndexTable;\n\ntypedef struct MXFContext {\n    MXFPartition *partitions;\n    unsigned partitions_count;\n    MXFOP op;\n    UID *packages_refs;\n    int packages_count;\n    MXFMetadataSet **metadata_sets;\n    int metadata_sets_count;\n    AVFormatContext *fc;\n    struct AVAES *aesc;\n    uint8_t *local_tags;\n    int local_tags_count;\n    uint64_t footer_partition;\n    KLVPacket current_klv_data;\n    int current_klv_index;\n    int run_in;\n    MXFPartition *current_partition;\n    int parsing_backward;\n    int64_t last_forward_tell;\n    int last_forward_partition;\n    int current_edit_unit;\n    int nb_index_tables;\n    MXFIndexTable *index_tables;\n    int edit_units_per_packet;      ///< how many edit units to read at a time (PCM, OPAtom)\n} MXFContext;\n\nenum MXFWrappingScheme {\n    Frame,\n    Clip,\n};\n\n/* NOTE: klv_offset is not set (-1) for local keys */\ntypedef int MXFMetadataReadFunc(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset);\n\ntypedef struct MXFMetadataReadTableEntry {\n    const UID key;\n    MXFMetadataReadFunc *read;\n    int ctx_size;\n    enum MXFMetadataSetType type;\n} MXFMetadataReadTableEntry;\n\nstatic int mxf_read_close(AVFormatContext *s);\n\n/* partial keys to match */\nstatic const uint8_t mxf_header_partition_pack_key[]       = { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02 };\nstatic const uint8_t mxf_essence_element_key[]             = { 0x06,0x0e,0x2b,0x34,0x01,0x02,0x01,0x01,0x0d,0x01,0x03,0x01 };\nstatic const uint8_t mxf_avid_essence_element_key[]        = { 0x06,0x0e,0x2b,0x34,0x01,0x02,0x01,0x01,0x0e,0x04,0x03,0x01 };\nstatic const uint8_t mxf_canopus_essence_element_key[]     = { 0x06,0x0e,0x2b,0x34,0x01,0x02,0x01,0x0a,0x0e,0x0f,0x03,0x01 };\nstatic const uint8_t mxf_system_item_key[]                 = { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x03,0x01,0x04 };\nstatic const uint8_t mxf_klv_key[]                         = { 0x06,0x0e,0x2b,0x34 };\n/* complete keys to match */\nstatic const uint8_t mxf_crypto_source_container_ul[]      = { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0x09,0x06,0x01,0x01,0x02,0x02,0x00,0x00,0x00 };\nstatic const uint8_t mxf_encrypted_triplet_key[]           = { 0x06,0x0e,0x2b,0x34,0x02,0x04,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x7e,0x01,0x00 };\nstatic const uint8_t mxf_encrypted_essence_container[]     = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x0b,0x01,0x00 };\nstatic const uint8_t mxf_random_index_pack_key[]           = { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x11,0x01,0x00 };\nstatic const uint8_t mxf_sony_mpeg4_extradata[]            = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0e,0x06,0x06,0x02,0x02,0x01,0x00,0x00 };\nstatic const uint8_t mxf_avid_project_name[]               = { 0xa5,0xfb,0x7b,0x25,0xf6,0x15,0x94,0xb9,0x62,0xfc,0x37,0x17,0x49,0x2d,0x42,0xbf };\nstatic const uint8_t mxf_jp2k_rsiz[]                       = { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x01,0x00 };\nstatic const uint8_t mxf_indirect_value_utf16le[]          = { 0x4c,0x00,0x02,0x10,0x01,0x00,0x00,0x00,0x00,0x06,0x0e,0x2b,0x34,0x01,0x04,0x01,0x01 };\nstatic const uint8_t mxf_indirect_value_utf16be[]          = { 0x42,0x01,0x10,0x02,0x00,0x00,0x00,0x00,0x00,0x06,0x0e,0x2b,0x34,0x01,0x04,0x01,0x01 };\n\n#define IS_KLV_KEY(x, y) (!memcmp(x, y, sizeof(y)))\n\nstatic void mxf_free_metadataset(MXFMetadataSet **ctx, int freectx)\n{\n    MXFIndexTableSegment *seg;\n    switch ((*ctx)->type) {\n    case Descriptor:\n        av_freep(&((MXFDescriptor *)*ctx)->extradata);\n        break;\n    case MultipleDescriptor:\n        av_freep(&((MXFDescriptor *)*ctx)->sub_descriptors_refs);\n        break;\n    case Sequence:\n        av_freep(&((MXFSequence *)*ctx)->structural_components_refs);\n        break;\n    case EssenceGroup:\n        av_freep(&((MXFEssenceGroup *)*ctx)->structural_components_refs);\n        break;\n    case SourcePackage:\n    case MaterialPackage:\n        av_freep(&((MXFPackage *)*ctx)->tracks_refs);\n        av_freep(&((MXFPackage *)*ctx)->name);\n        av_freep(&((MXFPackage *)*ctx)->comment_refs);\n        break;\n    case TaggedValue:\n        av_freep(&((MXFTaggedValue *)*ctx)->name);\n        av_freep(&((MXFTaggedValue *)*ctx)->value);\n        break;\n    case Track:\n        av_freep(&((MXFTrack *)*ctx)->name);\n        break;\n    case IndexTableSegment:\n        seg = (MXFIndexTableSegment *)*ctx;\n        av_freep(&seg->temporal_offset_entries);\n        av_freep(&seg->flag_entries);\n        av_freep(&seg->stream_offset_entries);\n    default:\n        break;\n    }\n    if (freectx)\n    av_freep(ctx);\n}\n\nstatic int64_t klv_decode_ber_length(AVIOContext *pb)\n{\n    uint64_t size = avio_r8(pb);\n    if (size & 0x80) { /* long form */\n        int bytes_num = size & 0x7f;\n        /* SMPTE 379M 5.3.4 guarantee that bytes_num must not exceed 8 bytes */\n        if (bytes_num > 8)\n            return AVERROR_INVALIDDATA;\n        size = 0;\n        while (bytes_num--)\n            size = size << 8 | avio_r8(pb);\n    }\n    return size;\n}\n\nstatic int mxf_read_sync(AVIOContext *pb, const uint8_t *key, unsigned size)\n{\n    int i, b;\n    for (i = 0; i < size && !avio_feof(pb); i++) {\n        b = avio_r8(pb);\n        if (b == key[0])\n            i = 0;\n        else if (b != key[i])\n            i = -1;\n    }\n    return i == size;\n}\n\nstatic int klv_read_packet(KLVPacket *klv, AVIOContext *pb)\n{\n    if (!mxf_read_sync(pb, mxf_klv_key, 4))\n        return AVERROR_INVALIDDATA;\n    klv->offset = avio_tell(pb) - 4;\n    memcpy(klv->key, mxf_klv_key, 4);\n    avio_read(pb, klv->key + 4, 12);\n    klv->length = klv_decode_ber_length(pb);\n    return klv->length == -1 ? -1 : 0;\n}\n\nstatic int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        MXFTrack *track = s->streams[i]->priv_data;\n        /* SMPTE 379M 7.3 */\n        if (track && !memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n            return i;\n    }\n    /* return 0 if only one stream, for OP Atom files with 0 as track number */\n    return s->nb_streams == 1 ? 0 : -1;\n}\n\n/* XXX: use AVBitStreamFilter */\nstatic int mxf_get_d10_aes3_packet(AVIOContext *pb, AVStream *st, AVPacket *pkt, int64_t length)\n{\n    const uint8_t *buf_ptr, *end_ptr;\n    uint8_t *data_ptr;\n    int i;\n\n    if (length > 61444) /* worst case PAL 1920 samples 8 channels */\n        return AVERROR_INVALIDDATA;\n    length = av_get_packet(pb, pkt, length);\n    if (length < 0)\n        return length;\n    data_ptr = pkt->data;\n    end_ptr = pkt->data + length;\n    buf_ptr = pkt->data + 4; /* skip SMPTE 331M header */\n    for (; end_ptr - buf_ptr >= st->codecpar->channels * 4; ) {\n        for (i = 0; i < st->codecpar->channels; i++) {\n            uint32_t sample = bytestream_get_le32(&buf_ptr);\n            if (st->codecpar->bits_per_coded_sample == 24)\n                bytestream_put_le24(&data_ptr, (sample >> 4) & 0xffffff);\n            else\n                bytestream_put_le16(&data_ptr, (sample >> 12) & 0xffff);\n        }\n        buf_ptr += 32 - st->codecpar->channels*4; // always 8 channels stored SMPTE 331M\n    }\n    av_shrink_packet(pkt, data_ptr - pkt->data);\n    return 0;\n}\n\nstatic int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv)\n{\n    static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b};\n    MXFContext *mxf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t end = avio_tell(pb) + klv->length;\n    int64_t size;\n    uint64_t orig_size;\n    uint64_t plaintext_size;\n    uint8_t ivec[16];\n    uint8_t tmpbuf[16];\n    int index;\n\n    if (!mxf->aesc && s->key && s->keylen == 16) {\n        mxf->aesc = av_aes_alloc();\n        if (!mxf->aesc)\n            return AVERROR(ENOMEM);\n        av_aes_init(mxf->aesc, s->key, 128, 1);\n    }\n    // crypto context\n    avio_skip(pb, klv_decode_ber_length(pb));\n    // plaintext offset\n    klv_decode_ber_length(pb);\n    plaintext_size = avio_rb64(pb);\n    // source klv key\n    klv_decode_ber_length(pb);\n    avio_read(pb, klv->key, 16);\n    if (!IS_KLV_KEY(klv, mxf_essence_element_key))\n        return AVERROR_INVALIDDATA;\n    index = mxf_get_stream_index(s, klv);\n    if (index < 0)\n        return AVERROR_INVALIDDATA;\n    // source size\n    klv_decode_ber_length(pb);\n    orig_size = avio_rb64(pb);\n    if (orig_size < plaintext_size)\n        return AVERROR_INVALIDDATA;\n    // enc. code\n    size = klv_decode_ber_length(pb);\n    if (size < 32 || size - 32 < orig_size)\n        return AVERROR_INVALIDDATA;\n    avio_read(pb, ivec, 16);\n    avio_read(pb, tmpbuf, 16);\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1);\n    if (memcmp(tmpbuf, checkv, 16))\n        av_log(s, AV_LOG_ERROR, \"probably incorrect decryption key\\n\");\n    size -= 32;\n    size = av_get_packet(pb, pkt, size);\n    if (size < 0)\n        return size;\n    else if (size < plaintext_size)\n        return AVERROR_INVALIDDATA;\n    size -= plaintext_size;\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, &pkt->data[plaintext_size],\n                     &pkt->data[plaintext_size], size >> 4, ivec, 1);\n    av_shrink_packet(pkt, orig_size);\n    pkt->stream_index = index;\n    avio_skip(pb, end - avio_tell(pb));\n    return 0;\n}\n\nstatic int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}\n\nstatic int mxf_read_partition_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    MXFPartition *partition, *tmp_part;\n    UID op;\n    uint64_t footer_partition;\n    uint32_t nb_essence_containers;\n\n    tmp_part = av_realloc_array(mxf->partitions, mxf->partitions_count + 1, sizeof(*mxf->partitions));\n    if (!tmp_part)\n        return AVERROR(ENOMEM);\n    mxf->partitions = tmp_part;\n\n    if (mxf->parsing_backward) {\n        /* insert the new partition pack in the middle\n         * this makes the entries in mxf->partitions sorted by offset */\n        memmove(&mxf->partitions[mxf->last_forward_partition+1],\n                &mxf->partitions[mxf->last_forward_partition],\n                (mxf->partitions_count - mxf->last_forward_partition)*sizeof(*mxf->partitions));\n        partition = mxf->current_partition = &mxf->partitions[mxf->last_forward_partition];\n    } else {\n        mxf->last_forward_partition++;\n        partition = mxf->current_partition = &mxf->partitions[mxf->partitions_count];\n    }\n\n    memset(partition, 0, sizeof(*partition));\n    mxf->partitions_count++;\n    partition->pack_length = avio_tell(pb) - klv_offset + size;\n    partition->pack_ofs    = klv_offset;\n\n    switch(uid[13]) {\n    case 2:\n        partition->type = Header;\n        break;\n    case 3:\n        partition->type = BodyPartition;\n        break;\n    case 4:\n        partition->type = Footer;\n        break;\n    default:\n        av_log(mxf->fc, AV_LOG_ERROR, \"unknown partition type %i\\n\", uid[13]);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* consider both footers to be closed (there is only Footer and CompleteFooter) */\n    partition->closed = partition->type == Footer || !(uid[14] & 1);\n    partition->complete = uid[14] > 2;\n    avio_skip(pb, 4);\n    partition->kag_size = avio_rb32(pb);\n    partition->this_partition = avio_rb64(pb);\n    partition->previous_partition = avio_rb64(pb);\n    footer_partition = avio_rb64(pb);\n    partition->header_byte_count = avio_rb64(pb);\n    partition->index_byte_count = avio_rb64(pb);\n    partition->index_sid = avio_rb32(pb);\n    avio_skip(pb, 8);\n    partition->body_sid = avio_rb32(pb);\n    if (avio_read(pb, op, sizeof(UID)) != sizeof(UID)) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"Failed reading UID\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    nb_essence_containers = avio_rb32(pb);\n\n    if (partition->this_partition &&\n        partition->previous_partition == partition->this_partition) {\n        av_log(mxf->fc, AV_LOG_ERROR,\n               \"PreviousPartition equal to ThisPartition %\"PRIx64\"\\n\",\n               partition->previous_partition);\n        /* override with the actual previous partition offset */\n        if (!mxf->parsing_backward && mxf->last_forward_partition > 1) {\n            MXFPartition *prev =\n                mxf->partitions + mxf->last_forward_partition - 2;\n            partition->previous_partition = prev->this_partition;\n        }\n        /* if no previous body partition are found point to the header\n         * partition */\n        if (partition->previous_partition == partition->this_partition)\n            partition->previous_partition = 0;\n        av_log(mxf->fc, AV_LOG_ERROR,\n               \"Overriding PreviousPartition with %\"PRIx64\"\\n\",\n               partition->previous_partition);\n    }\n\n    /* some files don't have FooterPartition set in every partition */\n    if (footer_partition) {\n        if (mxf->footer_partition && mxf->footer_partition != footer_partition) {\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"inconsistent FooterPartition value: %\"PRIu64\" != %\"PRIu64\"\\n\",\n                   mxf->footer_partition, footer_partition);\n        } else {\n            mxf->footer_partition = footer_partition;\n        }\n    }\n\n    av_log(mxf->fc, AV_LOG_TRACE,\n            \"PartitionPack: ThisPartition = 0x%\"PRIX64\n            \", PreviousPartition = 0x%\"PRIX64\", \"\n            \"FooterPartition = 0x%\"PRIX64\", IndexSID = %i, BodySID = %i\\n\",\n            partition->this_partition,\n            partition->previous_partition, footer_partition,\n            partition->index_sid, partition->body_sid);\n\n    /* sanity check PreviousPartition if set */\n    //NOTE: this isn't actually enough, see mxf_seek_to_previous_partition()\n    if (partition->previous_partition &&\n        mxf->run_in + partition->previous_partition >= klv_offset) {\n        av_log(mxf->fc, AV_LOG_ERROR,\n               \"PreviousPartition points to this partition or forward\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if      (op[12] == 1 && op[13] == 1) mxf->op = OP1a;\n    else if (op[12] == 1 && op[13] == 2) mxf->op = OP1b;\n    else if (op[12] == 1 && op[13] == 3) mxf->op = OP1c;\n    else if (op[12] == 2 && op[13] == 1) mxf->op = OP2a;\n    else if (op[12] == 2 && op[13] == 2) mxf->op = OP2b;\n    else if (op[12] == 2 && op[13] == 3) mxf->op = OP2c;\n    else if (op[12] == 3 && op[13] == 1) mxf->op = OP3a;\n    else if (op[12] == 3 && op[13] == 2) mxf->op = OP3b;\n    else if (op[12] == 3 && op[13] == 3) mxf->op = OP3c;\n    else if (op[12] == 64&& op[13] == 1) mxf->op = OPSONYOpt;\n    else if (op[12] == 0x10) {\n        /* SMPTE 390m: \"There shall be exactly one essence container\"\n         * The following block deals with files that violate this, namely:\n         * 2011_DCPTEST_24FPS.V.mxf - two ECs, OP1a\n         * abcdefghiv016f56415e.mxf - zero ECs, OPAtom, output by Avid AirSpeed */\n        if (nb_essence_containers != 1) {\n            MXFOP op = nb_essence_containers ? OP1a : OPAtom;\n\n            /* only nag once */\n            if (!mxf->op)\n                av_log(mxf->fc, AV_LOG_WARNING,\n                       \"\\\"OPAtom\\\" with %\"PRIu32\" ECs - assuming %s\\n\",\n                       nb_essence_containers,\n                       op == OP1a ? \"OP1a\" : \"OPAtom\");\n\n            mxf->op = op;\n        } else\n            mxf->op = OPAtom;\n    } else {\n        av_log(mxf->fc, AV_LOG_ERROR, \"unknown operational pattern: %02xh %02xh - guessing OP1a\\n\", op[12], op[13]);\n        mxf->op = OP1a;\n    }\n\n    if (partition->kag_size <= 0 || partition->kag_size > (1 << 20)) {\n        av_log(mxf->fc, AV_LOG_WARNING, \"invalid KAGSize %\"PRId32\" - guessing \",\n               partition->kag_size);\n\n        if (mxf->op == OPSONYOpt)\n            partition->kag_size = 512;\n        else\n            partition->kag_size = 1;\n\n        av_log(mxf->fc, AV_LOG_WARNING, \"%\"PRId32\"\\n\", partition->kag_size);\n    }\n\n    return 0;\n}\n\nstatic int mxf_add_metadata_set(MXFContext *mxf, void *metadata_set)\n{\n    MXFMetadataSet **tmp;\n\n    tmp = av_realloc_array(mxf->metadata_sets, mxf->metadata_sets_count + 1, sizeof(*mxf->metadata_sets));\n    if (!tmp)\n        return AVERROR(ENOMEM);\n    mxf->metadata_sets = tmp;\n    mxf->metadata_sets[mxf->metadata_sets_count] = metadata_set;\n    mxf->metadata_sets_count++;\n    return 0;\n}\n\nstatic int mxf_read_cryptographic_context(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFCryptoContext *cryptocontext = arg;\n    if (size != 16)\n        return AVERROR_INVALIDDATA;\n    if (IS_KLV_KEY(uid, mxf_crypto_source_container_ul))\n        avio_read(pb, cryptocontext->source_container_ul, 16);\n    return 0;\n}\n\nstatic int mxf_read_strong_ref_array(AVIOContext *pb, UID **refs, int *count)\n{\n    *count = avio_rb32(pb);\n    *refs = av_calloc(*count, sizeof(UID));\n    if (!*refs) {\n        *count = 0;\n        return AVERROR(ENOMEM);\n    }\n    avio_skip(pb, 4); /* useless size of objects, always 16 according to specs */\n    avio_read(pb, (uint8_t *)*refs, *count * sizeof(UID));\n    return 0;\n}\n\nstatic inline int mxf_read_utf16_string(AVIOContext *pb, int size, char** str, int be)\n{\n    int ret;\n    size_t buf_size;\n\n    if (size < 0 || size > INT_MAX/2)\n        return AVERROR(EINVAL);\n\n    buf_size = size + size / 2 + 1;\n    *str = av_malloc(buf_size);\n    if (!*str)\n        return AVERROR(ENOMEM);\n\n    if (be)\n        ret = avio_get_str16be(pb, size, *str, buf_size);\n    else\n        ret = avio_get_str16le(pb, size, *str, buf_size);\n\n    if (ret < 0) {\n        av_freep(str);\n        return ret;\n    }\n\n    return ret;\n}\n\n#define READ_STR16(type, big_endian)                                               \\\nstatic int mxf_read_utf16 ## type ##_string(AVIOContext *pb, int size, char** str) \\\n{                                                                                  \\\nreturn mxf_read_utf16_string(pb, size, str, big_endian);                           \\\n}\nREAD_STR16(be, 1)\nREAD_STR16(le, 0)\n#undef READ_STR16\n\nstatic int mxf_read_content_storage(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    switch (tag) {\n    case 0x1901:\n        if (mxf->packages_refs)\n            av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple packages_refs\\n\");\n        av_free(mxf->packages_refs);\n        return mxf_read_strong_ref_array(pb, &mxf->packages_refs, &mxf->packages_count);\n    }\n    return 0;\n}\n\nstatic int mxf_read_source_clip(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFStructuralComponent *source_clip = arg;\n    switch(tag) {\n    case 0x0202:\n        source_clip->duration = avio_rb64(pb);\n        break;\n    case 0x1201:\n        source_clip->start_position = avio_rb64(pb);\n        break;\n    case 0x1101:\n        /* UMID, only get last 16 bytes */\n        avio_read(pb, source_clip->source_package_ul, 16);\n        avio_read(pb, source_clip->source_package_uid, 16);\n        break;\n    case 0x1102:\n        source_clip->source_track_id = avio_rb32(pb);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_timecode_component(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTimecodeComponent *mxf_timecode = arg;\n    switch(tag) {\n    case 0x1501:\n        mxf_timecode->start_frame = avio_rb64(pb);\n        break;\n    case 0x1502:\n        mxf_timecode->rate = (AVRational){avio_rb16(pb), 1};\n        break;\n    case 0x1503:\n        mxf_timecode->drop_frame = avio_r8(pb);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_pulldown_component(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFPulldownComponent *mxf_pulldown = arg;\n    switch(tag) {\n    case 0x0d01:\n        avio_read(pb, mxf_pulldown->input_segment_ref, 16);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_track(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTrack *track = arg;\n    switch(tag) {\n    case 0x4801:\n        track->track_id = avio_rb32(pb);\n        break;\n    case 0x4804:\n        avio_read(pb, track->track_number, 4);\n        break;\n    case 0x4802:\n        mxf_read_utf16be_string(pb, size, &track->name);\n        break;\n    case 0x4b01:\n        track->edit_rate.num = avio_rb32(pb);\n        track->edit_rate.den = avio_rb32(pb);\n        break;\n    case 0x4803:\n        avio_read(pb, track->sequence_ref, 16);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_sequence(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFSequence *sequence = arg;\n    switch(tag) {\n    case 0x0202:\n        sequence->duration = avio_rb64(pb);\n        break;\n    case 0x0201:\n        avio_read(pb, sequence->data_definition_ul, 16);\n        break;\n        case 0x4b02:\n        sequence->origin = avio_r8(pb);\n        break;\n    case 0x1001:\n        return mxf_read_strong_ref_array(pb, &sequence->structural_components_refs,\n                                             &sequence->structural_components_count);\n    }\n    return 0;\n}\n\nstatic int mxf_read_essence_group(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFEssenceGroup *essence_group = arg;\n    switch (tag) {\n    case 0x0202:\n        essence_group->duration = avio_rb64(pb);\n        break;\n    case 0x0501:\n        return mxf_read_strong_ref_array(pb, &essence_group->structural_components_refs,\n                                             &essence_group->structural_components_count);\n    }\n    return 0;\n}\n\nstatic int mxf_read_package(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFPackage *package = arg;\n    switch(tag) {\n    case 0x4403:\n        return mxf_read_strong_ref_array(pb, &package->tracks_refs,\n                                             &package->tracks_count);\n    case 0x4401:\n        /* UMID */\n        avio_read(pb, package->package_ul, 16);\n        avio_read(pb, package->package_uid, 16);\n        break;\n    case 0x4701:\n        avio_read(pb, package->descriptor_ref, 16);\n        break;\n    case 0x4402:\n        return mxf_read_utf16be_string(pb, size, &package->name);\n    case 0x4406:\n        return mxf_read_strong_ref_array(pb, &package->comment_refs,\n                                             &package->comment_count);\n    }\n    return 0;\n}\n\nstatic int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}\n\nstatic int mxf_read_index_table_segment(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFIndexTableSegment *segment = arg;\n    switch(tag) {\n    case 0x3F05:\n        segment->edit_unit_byte_count = avio_rb32(pb);\n        av_log(NULL, AV_LOG_TRACE, \"EditUnitByteCount %d\\n\", segment->edit_unit_byte_count);\n        break;\n    case 0x3F06:\n        segment->index_sid = avio_rb32(pb);\n        av_log(NULL, AV_LOG_TRACE, \"IndexSID %d\\n\", segment->index_sid);\n        break;\n    case 0x3F07:\n        segment->body_sid = avio_rb32(pb);\n        av_log(NULL, AV_LOG_TRACE, \"BodySID %d\\n\", segment->body_sid);\n        break;\n    case 0x3F0A:\n        av_log(NULL, AV_LOG_TRACE, \"IndexEntryArray found\\n\");\n        return mxf_read_index_entry_array(pb, segment);\n    case 0x3F0B:\n        segment->index_edit_rate.num = avio_rb32(pb);\n        segment->index_edit_rate.den = avio_rb32(pb);\n        av_log(NULL, AV_LOG_TRACE, \"IndexEditRate %d/%d\\n\", segment->index_edit_rate.num,\n                segment->index_edit_rate.den);\n        break;\n    case 0x3F0C:\n        segment->index_start_position = avio_rb64(pb);\n        av_log(NULL, AV_LOG_TRACE, \"IndexStartPosition %\"PRId64\"\\n\", segment->index_start_position);\n        break;\n    case 0x3F0D:\n        segment->index_duration = avio_rb64(pb);\n        av_log(NULL, AV_LOG_TRACE, \"IndexDuration %\"PRId64\"\\n\", segment->index_duration);\n        break;\n    }\n    return 0;\n}\n\nstatic void mxf_read_pixel_layout(AVIOContext *pb, MXFDescriptor *descriptor)\n{\n    int code, value, ofs = 0;\n    char layout[16] = {0}; /* not for printing, may end up not terminated on purpose */\n\n    do {\n        code = avio_r8(pb);\n        value = avio_r8(pb);\n        av_log(NULL, AV_LOG_TRACE, \"pixel layout: code %#x\\n\", code);\n\n        if (ofs <= 14) {\n            layout[ofs++] = code;\n            layout[ofs++] = value;\n        } else\n            break;  /* don't read byte by byte on sneaky files filled with lots of non-zeroes */\n    } while (code != 0); /* SMPTE 377M E.2.46 */\n\n    ff_mxf_decode_pixel_layout(layout, &descriptor->pix_fmt);\n}\n\nstatic int mxf_read_generic_descriptor(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFDescriptor *descriptor = arg;\n    int entry_count, entry_size;\n\n    switch(tag) {\n    case 0x3F01:\n        return mxf_read_strong_ref_array(pb, &descriptor->sub_descriptors_refs,\n                                             &descriptor->sub_descriptors_count);\n    case 0x3002: /* ContainerDuration */\n        descriptor->duration = avio_rb64(pb);\n        break;\n    case 0x3004:\n        avio_read(pb, descriptor->essence_container_ul, 16);\n        break;\n    case 0x3005:\n        avio_read(pb, descriptor->codec_ul, 16);\n        break;\n    case 0x3006:\n        descriptor->linked_track_id = avio_rb32(pb);\n        break;\n    case 0x3201: /* PictureEssenceCoding */\n        avio_read(pb, descriptor->essence_codec_ul, 16);\n        break;\n    case 0x3203:\n        descriptor->width = avio_rb32(pb);\n        break;\n    case 0x3202:\n        descriptor->height = avio_rb32(pb);\n        break;\n    case 0x320C:\n        descriptor->frame_layout = avio_r8(pb);\n        break;\n    case 0x320D:\n        entry_count = avio_rb32(pb);\n        entry_size = avio_rb32(pb);\n        if (entry_size == 4) {\n            if (entry_count > 0)\n                descriptor->video_line_map[0] = avio_rb32(pb);\n            else\n                descriptor->video_line_map[0] = 0;\n            if (entry_count > 1)\n                descriptor->video_line_map[1] = avio_rb32(pb);\n            else\n                descriptor->video_line_map[1] = 0;\n        } else\n            av_log(NULL, AV_LOG_WARNING, \"VideoLineMap element size %d currently not supported\\n\", entry_size);\n        break;\n    case 0x320E:\n        descriptor->aspect_ratio.num = avio_rb32(pb);\n        descriptor->aspect_ratio.den = avio_rb32(pb);\n        break;\n    case 0x3212:\n        descriptor->field_dominance = avio_r8(pb);\n        break;\n    case 0x3301:\n        descriptor->component_depth = avio_rb32(pb);\n        break;\n    case 0x3302:\n        descriptor->horiz_subsampling = avio_rb32(pb);\n        break;\n    case 0x3308:\n        descriptor->vert_subsampling = avio_rb32(pb);\n        break;\n    case 0x3D03:\n        descriptor->sample_rate.num = avio_rb32(pb);\n        descriptor->sample_rate.den = avio_rb32(pb);\n        break;\n    case 0x3D06: /* SoundEssenceCompression */\n        avio_read(pb, descriptor->essence_codec_ul, 16);\n        break;\n    case 0x3D07:\n        descriptor->channels = avio_rb32(pb);\n        break;\n    case 0x3D01:\n        descriptor->bits_per_sample = avio_rb32(pb);\n        break;\n    case 0x3401:\n        mxf_read_pixel_layout(pb, descriptor);\n        break;\n    default:\n        /* Private uid used by SONY C0023S01.mxf */\n        if (IS_KLV_KEY(uid, mxf_sony_mpeg4_extradata)) {\n            if (descriptor->extradata)\n                av_log(NULL, AV_LOG_WARNING, \"Duplicate sony_mpeg4_extradata\\n\");\n            av_free(descriptor->extradata);\n            descriptor->extradata_size = 0;\n            descriptor->extradata = av_malloc(size);\n            if (!descriptor->extradata)\n                return AVERROR(ENOMEM);\n            descriptor->extradata_size = size;\n            avio_read(pb, descriptor->extradata, size);\n        }\n        if (IS_KLV_KEY(uid, mxf_jp2k_rsiz)) {\n            uint32_t rsiz = avio_rb16(pb);\n            if (rsiz == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n                rsiz == FF_PROFILE_JPEG2000_DCINEMA_4K)\n                descriptor->pix_fmt = AV_PIX_FMT_XYZ12;\n        }\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_indirect_value(void *arg, AVIOContext *pb, int size)\n{\n    MXFTaggedValue *tagged_value = arg;\n    uint8_t key[17];\n\n    if (size <= 17)\n        return 0;\n\n    avio_read(pb, key, 17);\n    /* TODO: handle other types of of indirect values */\n    if (memcmp(key, mxf_indirect_value_utf16le, 17) == 0) {\n        return mxf_read_utf16le_string(pb, size - 17, &tagged_value->value);\n    } else if (memcmp(key, mxf_indirect_value_utf16be, 17) == 0) {\n        return mxf_read_utf16be_string(pb, size - 17, &tagged_value->value);\n    }\n    return 0;\n}\n\nstatic int mxf_read_tagged_value(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTaggedValue *tagged_value = arg;\n    switch (tag){\n    case 0x5001:\n        return mxf_read_utf16be_string(pb, size, &tagged_value->name);\n    case 0x5003:\n        return mxf_read_indirect_value(tagged_value, pb, size);\n    }\n    return 0;\n}\n\n/*\n * Match an uid independently of the version byte and up to len common bytes\n * Returns: boolean\n */\nstatic int mxf_match_uid(const UID key, const UID uid, int len)\n{\n    int i;\n    for (i = 0; i < len; i++) {\n        if (i != 7 && key[i] != uid[i])\n            return 0;\n    }\n    return 1;\n}\n\nstatic const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)\n{\n    while (uls->uid[0]) {\n        if(mxf_match_uid(uls->uid, *uid, uls->matching_len))\n            break;\n        uls++;\n    }\n    return uls;\n}\n\nstatic void *mxf_resolve_strong_ref(MXFContext *mxf, UID *strong_ref, enum MXFMetadataSetType type)\n{\n    int i;\n\n    if (!strong_ref)\n        return NULL;\n    for (i = 0; i < mxf->metadata_sets_count; i++) {\n        if (!memcmp(*strong_ref, mxf->metadata_sets[i]->uid, 16) &&\n            (type == AnyType || mxf->metadata_sets[i]->type == type)) {\n            return mxf->metadata_sets[i];\n        }\n    }\n    return NULL;\n}\n\nstatic const MXFCodecUL mxf_picture_essence_container_uls[] = {\n    // video essence container uls\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x0c,0x01,0x00 }, 14,   AV_CODEC_ID_JPEG2000 },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x10,0x60,0x01 }, 14,       AV_CODEC_ID_H264 }, /* H.264 frame wrapped */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x12,0x01,0x00 }, 14,        AV_CODEC_ID_VC1 }, /* VC-1 frame wrapped */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x04,0x60,0x01 }, 14, AV_CODEC_ID_MPEG2VIDEO }, /* MPEG-ES frame wrapped */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x01,0x04,0x01 }, 14, AV_CODEC_ID_MPEG2VIDEO }, /* Type D-10 mapping of 40Mbps 525/60-I */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x02,0x41,0x01 }, 14,    AV_CODEC_ID_DVVIDEO }, /* DV 625 25mbps */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x05,0x00,0x00 }, 14,   AV_CODEC_ID_RAWVIDEO }, /* uncompressed picture */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0a,0x0e,0x0f,0x03,0x01,0x02,0x20,0x01,0x01 }, 15,     AV_CODEC_ID_HQ_HQA },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0a,0x0e,0x0f,0x03,0x01,0x02,0x20,0x02,0x01 }, 15,        AV_CODEC_ID_HQX },\n    { { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0xff,0x4b,0x46,0x41,0x41,0x00,0x0d,0x4d,0x4f }, 14,   AV_CODEC_ID_RAWVIDEO }, /* Legacy ?? Uncompressed Picture */\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,      AV_CODEC_ID_NONE },\n};\n\n/* EC ULs for intra-only formats */\nstatic const MXFCodecUL mxf_intra_only_essence_container_uls[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x01,0x00,0x00 }, 14, AV_CODEC_ID_MPEG2VIDEO }, /* MXF-GC SMPTE D-10 mappings */\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,       AV_CODEC_ID_NONE },\n};\n\n/* intra-only PictureEssenceCoding ULs, where no corresponding EC UL exists */\nstatic const MXFCodecUL mxf_intra_only_picture_essence_coding_uls[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x00,0x00 }, 14,       AV_CODEC_ID_H264 }, /* H.264/MPEG-4 AVC Intra Profiles */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x07,0x04,0x01,0x02,0x02,0x03,0x01,0x01,0x00 }, 14,   AV_CODEC_ID_JPEG2000 }, /* JPEG 2000 code stream */\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,       AV_CODEC_ID_NONE },\n};\n\n/* actual coded width for AVC-Intra to allow selecting correct SPS/PPS */\nstatic const MXFCodecUL mxf_intra_only_picture_coded_width[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x21,0x01 }, 16, 1440 },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x21,0x02 }, 16, 1440 },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x21,0x03 }, 16, 1440 },\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x02,0x01,0x32,0x21,0x04 }, 16, 1440 },\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,    0 },\n};\n\nstatic const MXFCodecUL mxf_sound_essence_container_uls[] = {\n    // sound essence container uls\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x06,0x01,0x00 }, 14, AV_CODEC_ID_PCM_S16LE }, /* BWF Frame wrapped */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x04,0x40,0x01 }, 14,       AV_CODEC_ID_MP2 }, /* MPEG-ES Frame wrapped, 0x40 ??? stream id */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x01,0x01,0x01 }, 14, AV_CODEC_ID_PCM_S16LE }, /* D-10 Mapping 50Mbps PAL Extended Template */\n    { { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0xff,0x4b,0x46,0x41,0x41,0x00,0x0d,0x4d,0x4F }, 14, AV_CODEC_ID_PCM_S16LE }, /* 0001GL00.MXF.A1.mxf_opatom.mxf */\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x03,0x04,0x02,0x02,0x02,0x03,0x03,0x01,0x00 }, 14,       AV_CODEC_ID_AAC }, /* MPEG-2 AAC ADTS (legacy) */\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,      AV_CODEC_ID_NONE },\n};\n\nstatic const MXFCodecUL mxf_data_essence_container_uls[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x09,0x0d,0x01,0x03,0x01,0x02,0x0e,0x00,0x00 }, 16, 0 },\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0, AV_CODEC_ID_NONE },\n};\n\nstatic const char* const mxf_data_essence_descriptor[] = {\n    \"vbi_vanc_smpte_436M\",\n};\n\nstatic int mxf_get_sorted_table_segments(MXFContext *mxf, int *nb_sorted_segments, MXFIndexTableSegment ***sorted_segments)\n{\n    int i, j, nb_segments = 0;\n    MXFIndexTableSegment **unsorted_segments;\n    int last_body_sid = -1, last_index_sid = -1, last_index_start = -1;\n\n    /* count number of segments, allocate arrays and copy unsorted segments */\n    for (i = 0; i < mxf->metadata_sets_count; i++)\n        if (mxf->metadata_sets[i]->type == IndexTableSegment)\n            nb_segments++;\n\n    if (!nb_segments)\n        return AVERROR_INVALIDDATA;\n\n    if (!(unsorted_segments = av_calloc(nb_segments, sizeof(*unsorted_segments))) ||\n        !(*sorted_segments  = av_calloc(nb_segments, sizeof(**sorted_segments)))) {\n        av_freep(sorted_segments);\n        av_free(unsorted_segments);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = j = 0; i < mxf->metadata_sets_count; i++)\n        if (mxf->metadata_sets[i]->type == IndexTableSegment)\n            unsorted_segments[j++] = (MXFIndexTableSegment*)mxf->metadata_sets[i];\n\n    *nb_sorted_segments = 0;\n\n    /* sort segments by {BodySID, IndexSID, IndexStartPosition}, remove duplicates while we're at it */\n    for (i = 0; i < nb_segments; i++) {\n        int best = -1, best_body_sid = -1, best_index_sid = -1, best_index_start = -1;\n        uint64_t best_index_duration = 0;\n\n        for (j = 0; j < nb_segments; j++) {\n            MXFIndexTableSegment *s = unsorted_segments[j];\n\n            /* Require larger BosySID, IndexSID or IndexStartPosition then the previous entry. This removes duplicates.\n             * We want the smallest values for the keys than what we currently have, unless this is the first such entry this time around.\n             * If we come across an entry with the same IndexStartPosition but larger IndexDuration, then we'll prefer it over the one we currently have.\n             */\n            if ((i == 0     || s->body_sid > last_body_sid || s->index_sid > last_index_sid || s->index_start_position > last_index_start) &&\n                (best == -1 || s->body_sid < best_body_sid || s->index_sid < best_index_sid || s->index_start_position < best_index_start ||\n                (s->index_start_position == best_index_start && s->index_duration > best_index_duration))) {\n                best             = j;\n                best_body_sid    = s->body_sid;\n                best_index_sid   = s->index_sid;\n                best_index_start = s->index_start_position;\n                best_index_duration = s->index_duration;\n            }\n        }\n\n        /* no suitable entry found -> we're done */\n        if (best == -1)\n            break;\n\n        (*sorted_segments)[(*nb_sorted_segments)++] = unsorted_segments[best];\n        last_body_sid    = best_body_sid;\n        last_index_sid   = best_index_sid;\n        last_index_start = best_index_start;\n    }\n\n    av_free(unsorted_segments);\n\n    return 0;\n}\n\n/**\n * Computes the absolute file offset of the given essence container offset\n */\nstatic int mxf_absolute_bodysid_offset(MXFContext *mxf, int body_sid, int64_t offset, int64_t *offset_out)\n{\n    int x;\n    int64_t offset_in = offset;     /* for logging */\n\n    for (x = 0; x < mxf->partitions_count; x++) {\n        MXFPartition *p = &mxf->partitions[x];\n\n        if (p->body_sid != body_sid)\n            continue;\n\n        if (offset < p->essence_length || !p->essence_length) {\n            *offset_out = p->essence_offset + offset;\n            return 0;\n        }\n\n        offset -= p->essence_length;\n    }\n\n    av_log(mxf->fc, AV_LOG_ERROR,\n           \"failed to find absolute offset of %\"PRIX64\" in BodySID %i - partial file?\\n\",\n           offset_in, body_sid);\n\n    return AVERROR_INVALIDDATA;\n}\n\n/**\n * Returns the end position of the essence container with given BodySID, or zero if unknown\n */\nstatic int64_t mxf_essence_container_end(MXFContext *mxf, int body_sid)\n{\n    int x;\n    int64_t ret = 0;\n\n    for (x = 0; x < mxf->partitions_count; x++) {\n        MXFPartition *p = &mxf->partitions[x];\n\n        if (p->body_sid != body_sid)\n            continue;\n\n        if (!p->essence_length)\n            return 0;\n\n        ret = p->essence_offset + p->essence_length;\n    }\n\n    return ret;\n}\n\n/* EditUnit -> absolute offset */\nstatic int mxf_edit_unit_absolute_offset(MXFContext *mxf, MXFIndexTable *index_table, int64_t edit_unit, int64_t *edit_unit_out, int64_t *offset_out, int nag)\n{\n    int i;\n    int64_t offset_temp = 0;\n\n    for (i = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n\n        edit_unit = FFMAX(edit_unit, s->index_start_position);  /* clamp if trying to seek before start */\n\n        if (edit_unit < s->index_start_position + s->index_duration) {\n            int64_t index = edit_unit - s->index_start_position;\n\n            if (s->edit_unit_byte_count)\n                offset_temp += s->edit_unit_byte_count * index;\n            else if (s->nb_index_entries) {\n                if (s->nb_index_entries == 2 * s->index_duration + 1)\n                    index *= 2;     /* Avid index */\n\n                if (index < 0 || index >= s->nb_index_entries) {\n                    av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" IndexEntryArray too small\\n\",\n                           index_table->index_sid, s->index_start_position);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                offset_temp = s->stream_offset_entries[index];\n            } else {\n                av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" missing EditUnitByteCount and IndexEntryArray\\n\",\n                       index_table->index_sid, s->index_start_position);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (edit_unit_out)\n                *edit_unit_out = edit_unit;\n\n            return mxf_absolute_bodysid_offset(mxf, index_table->body_sid, offset_temp, offset_out);\n        } else {\n            /* EditUnitByteCount == 0 for VBR indexes, which is fine since they use explicit StreamOffsets */\n            offset_temp += s->edit_unit_byte_count * s->index_duration;\n        }\n    }\n\n    if (nag)\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to map EditUnit %\"PRId64\" in IndexSID %i to an offset\\n\", edit_unit, index_table->index_sid);\n\n    return AVERROR_INVALIDDATA;\n}\n\nstatic int mxf_compute_ptses_fake_index(MXFContext *mxf, MXFIndexTable *index_table)\n{\n    int i, j, x;\n    int8_t max_temporal_offset = -128;\n    uint8_t *flags;\n\n    /* first compute how many entries we have */\n    for (i = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n\n        if (!s->nb_index_entries) {\n            index_table->nb_ptses = 0;\n            return 0;                               /* no TemporalOffsets */\n        }\n\n        index_table->nb_ptses += s->index_duration;\n    }\n\n    /* paranoid check */\n    if (index_table->nb_ptses <= 0)\n        return 0;\n\n    if (!(index_table->ptses      = av_calloc(index_table->nb_ptses, sizeof(int64_t))) ||\n        !(index_table->fake_index = av_calloc(index_table->nb_ptses, sizeof(AVIndexEntry))) ||\n        !(index_table->offsets    = av_calloc(index_table->nb_ptses, sizeof(int8_t))) ||\n        !(flags                   = av_calloc(index_table->nb_ptses, sizeof(uint8_t)))) {\n        av_freep(&index_table->ptses);\n        av_freep(&index_table->fake_index);\n        av_freep(&index_table->offsets);\n        return AVERROR(ENOMEM);\n    }\n\n    /* we may have a few bad TemporalOffsets\n     * make sure the corresponding PTSes don't have the bogus value 0 */\n    for (x = 0; x < index_table->nb_ptses; x++)\n        index_table->ptses[x] = AV_NOPTS_VALUE;\n\n    /**\n     * We have this:\n     *\n     * x  TemporalOffset\n     * 0:  0\n     * 1:  1\n     * 2:  1\n     * 3: -2\n     * 4:  1\n     * 5:  1\n     * 6: -2\n     *\n     * We want to transform it into this:\n     *\n     * x  DTS PTS\n     * 0: -1   0\n     * 1:  0   3\n     * 2:  1   1\n     * 3:  2   2\n     * 4:  3   6\n     * 5:  4   4\n     * 6:  5   5\n     *\n     * We do this by bucket sorting x by x+TemporalOffset[x] into mxf->ptses,\n     * then settings mxf->first_dts = -max(TemporalOffset[x]).\n     * The latter makes DTS <= PTS.\n     */\n    for (i = x = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n        int index_delta = 1;\n        int n = s->nb_index_entries;\n\n        if (s->nb_index_entries == 2 * s->index_duration + 1) {\n            index_delta = 2;    /* Avid index */\n            /* ignore the last entry - it's the size of the essence container */\n            n--;\n        }\n\n        for (j = 0; j < n; j += index_delta, x++) {\n            int offset = s->temporal_offset_entries[j] / index_delta;\n            int index  = x + offset;\n\n            if (x >= index_table->nb_ptses) {\n                av_log(mxf->fc, AV_LOG_ERROR,\n                       \"x >= nb_ptses - IndexEntryCount %i < IndexDuration %\"PRId64\"?\\n\",\n                       s->nb_index_entries, s->index_duration);\n                break;\n            }\n\n            flags[x] = !(s->flag_entries[j] & 0x30) ? AVINDEX_KEYFRAME : 0;\n\n            if (index < 0 || index >= index_table->nb_ptses) {\n                av_log(mxf->fc, AV_LOG_ERROR,\n                       \"index entry %i + TemporalOffset %i = %i, which is out of bounds\\n\",\n                       x, offset, index);\n                continue;\n            }\n\n            index_table->offsets[x] = offset;\n            index_table->ptses[index] = x;\n            max_temporal_offset = FFMAX(max_temporal_offset, offset);\n        }\n    }\n\n    /* calculate the fake index table in display order */\n    for (x = 0; x < index_table->nb_ptses; x++) {\n        index_table->fake_index[x].timestamp = x;\n        if (index_table->ptses[x] != AV_NOPTS_VALUE)\n            index_table->fake_index[index_table->ptses[x]].flags = flags[x];\n    }\n    av_freep(&flags);\n\n    index_table->first_dts = -max_temporal_offset;\n\n    return 0;\n}\n\n/**\n * Sorts and collects index table segments into index tables.\n * Also computes PTSes if possible.\n */\nstatic int mxf_compute_index_tables(MXFContext *mxf)\n{\n    int i, j, k, ret, nb_sorted_segments;\n    MXFIndexTableSegment **sorted_segments = NULL;\n    AVStream *st = NULL;\n\n    for (i = 0; i < mxf->fc->nb_streams; i++) {\n        if (mxf->fc->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_DATA)\n            continue;\n        st = mxf->fc->streams[i];\n        break;\n    }\n\n    if ((ret = mxf_get_sorted_table_segments(mxf, &nb_sorted_segments, &sorted_segments)) ||\n        nb_sorted_segments <= 0) {\n        av_log(mxf->fc, AV_LOG_WARNING, \"broken or empty index\\n\");\n        return 0;\n    }\n\n    /* sanity check and count unique BodySIDs/IndexSIDs */\n    for (i = 0; i < nb_sorted_segments; i++) {\n        if (i == 0 || sorted_segments[i-1]->index_sid != sorted_segments[i]->index_sid)\n            mxf->nb_index_tables++;\n        else if (sorted_segments[i-1]->body_sid != sorted_segments[i]->body_sid) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"found inconsistent BodySID\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto finish_decoding_index;\n        }\n    }\n\n    mxf->index_tables = av_mallocz_array(mxf->nb_index_tables,\n                                         sizeof(*mxf->index_tables));\n    if (!mxf->index_tables) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to allocate index tables\\n\");\n        ret = AVERROR(ENOMEM);\n        goto finish_decoding_index;\n    }\n\n    /* distribute sorted segments to index tables */\n    for (i = j = 0; i < nb_sorted_segments; i++) {\n        if (i != 0 && sorted_segments[i-1]->index_sid != sorted_segments[i]->index_sid) {\n            /* next IndexSID */\n            j++;\n        }\n\n        mxf->index_tables[j].nb_segments++;\n    }\n\n    for (i = j = 0; j < mxf->nb_index_tables; i += mxf->index_tables[j++].nb_segments) {\n        MXFIndexTable *t = &mxf->index_tables[j];\n\n        t->segments = av_mallocz_array(t->nb_segments,\n                                       sizeof(*t->segments));\n\n        if (!t->segments) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"failed to allocate IndexTableSegment\"\n                   \" pointer array\\n\");\n            ret = AVERROR(ENOMEM);\n            goto finish_decoding_index;\n        }\n\n        if (sorted_segments[i]->index_start_position)\n            av_log(mxf->fc, AV_LOG_WARNING, \"IndexSID %i starts at EditUnit %\"PRId64\" - seeking may not work as expected\\n\",\n                   sorted_segments[i]->index_sid, sorted_segments[i]->index_start_position);\n\n        memcpy(t->segments, &sorted_segments[i], t->nb_segments * sizeof(MXFIndexTableSegment*));\n        t->index_sid = sorted_segments[i]->index_sid;\n        t->body_sid = sorted_segments[i]->body_sid;\n\n        if ((ret = mxf_compute_ptses_fake_index(mxf, t)) < 0)\n            goto finish_decoding_index;\n\n        /* fix zero IndexDurations */\n        for (k = 0; k < t->nb_segments; k++) {\n            if (t->segments[k]->index_duration)\n                continue;\n\n            if (t->nb_segments > 1)\n                av_log(mxf->fc, AV_LOG_WARNING, \"IndexSID %i segment %i has zero IndexDuration and there's more than one segment\\n\",\n                       t->index_sid, k);\n\n            if (!st) {\n                av_log(mxf->fc, AV_LOG_WARNING, \"no streams?\\n\");\n                break;\n            }\n\n            /* assume the first stream's duration is reasonable\n             * leave index_duration = 0 on further segments in case we have any (unlikely)\n             */\n            t->segments[k]->index_duration = st->duration;\n            break;\n        }\n    }\n\n    ret = 0;\nfinish_decoding_index:\n    av_free(sorted_segments);\n    return ret;\n}\n\nstatic int mxf_is_intra_only(MXFDescriptor *descriptor)\n{\n    return mxf_get_codec_ul(mxf_intra_only_essence_container_uls,\n                            &descriptor->essence_container_ul)->id != AV_CODEC_ID_NONE ||\n           mxf_get_codec_ul(mxf_intra_only_picture_essence_coding_uls,\n                            &descriptor->essence_codec_ul)->id     != AV_CODEC_ID_NONE;\n}\n\nstatic int mxf_uid_to_str(UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 2 + 4 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2x\", uid[i]);\n        p += 2;\n        if (i == 3 || i == 5 || i == 7 || i == 9) {\n            snprintf(p, 1 + 1, \"-\");\n            p++;\n        }\n    }\n    return 0;\n}\n\nstatic int mxf_umid_to_str(UID ul, UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 4 + 2 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    snprintf(p, 2 + 1, \"0x\");\n    p += 2;\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2X\", ul[i]);\n        p += 2;\n\n    }\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2X\", uid[i]);\n        p += 2;\n    }\n    return 0;\n}\n\nstatic int mxf_add_umid_metadata(AVDictionary **pm, const char *key, MXFPackage* package)\n{\n    char *str;\n    int ret;\n    if (!package)\n        return 0;\n    if ((ret = mxf_umid_to_str(package->package_ul, package->package_uid, &str)) < 0)\n        return ret;\n    av_dict_set(pm, key, str, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}\n\nstatic int mxf_add_timecode_metadata(AVDictionary **pm, const char *key, AVTimecode *tc)\n{\n    char buf[AV_TIMECODE_STR_SIZE];\n    av_dict_set(pm, key, av_timecode_make_string(tc, buf, 0), 0);\n\n    return 0;\n}\n\nstatic MXFTimecodeComponent* mxf_resolve_timecode_component(MXFContext *mxf, UID *strong_ref)\n{\n    MXFStructuralComponent *component = NULL;\n    MXFPulldownComponent *pulldown = NULL;\n\n    component = mxf_resolve_strong_ref(mxf, strong_ref, AnyType);\n    if (!component)\n        return NULL;\n\n    switch (component->type) {\n    case TimecodeComponent:\n        return (MXFTimecodeComponent*)component;\n    case PulldownComponent: /* timcode component may be located on a pulldown component */\n        pulldown = (MXFPulldownComponent*)component;\n        return mxf_resolve_strong_ref(mxf, &pulldown->input_segment_ref, TimecodeComponent);\n    default:\n        break;\n    }\n    return NULL;\n}\n\nstatic MXFPackage* mxf_resolve_source_package(MXFContext *mxf, UID package_uid)\n{\n    MXFPackage *package = NULL;\n    int i;\n\n    for (i = 0; i < mxf->packages_count; i++) {\n        package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], SourcePackage);\n        if (!package)\n            continue;\n\n        if (!memcmp(package->package_uid, package_uid, 16))\n            return package;\n    }\n    return NULL;\n}\n\nstatic MXFDescriptor* mxf_resolve_multidescriptor(MXFContext *mxf, MXFDescriptor *descriptor, int track_id)\n{\n    MXFDescriptor *sub_descriptor = NULL;\n    int i;\n\n    if (!descriptor)\n        return NULL;\n\n    if (descriptor->type == MultipleDescriptor) {\n        for (i = 0; i < descriptor->sub_descriptors_count; i++) {\n            sub_descriptor = mxf_resolve_strong_ref(mxf, &descriptor->sub_descriptors_refs[i], Descriptor);\n\n            if (!sub_descriptor) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve sub descriptor strong ref\\n\");\n                continue;\n            }\n            if (sub_descriptor->linked_track_id == track_id) {\n                return sub_descriptor;\n            }\n        }\n    } else if (descriptor->type == Descriptor)\n        return descriptor;\n\n    return NULL;\n}\n\nstatic MXFStructuralComponent* mxf_resolve_essence_group_choice(MXFContext *mxf, MXFEssenceGroup *essence_group)\n{\n    MXFStructuralComponent *component = NULL;\n    MXFPackage *package = NULL;\n    MXFDescriptor *descriptor = NULL;\n    int i;\n\n    if (!essence_group || !essence_group->structural_components_count)\n        return NULL;\n\n    /* essence groups contains multiple representations of the same media,\n       this return the first components with a valid Descriptor typically index 0 */\n    for (i =0; i < essence_group->structural_components_count; i++){\n        component = mxf_resolve_strong_ref(mxf, &essence_group->structural_components_refs[i], SourceClip);\n        if (!component)\n            continue;\n\n        if (!(package = mxf_resolve_source_package(mxf, component->source_package_uid)))\n            continue;\n\n        descriptor = mxf_resolve_strong_ref(mxf, &package->descriptor_ref, Descriptor);\n        if (descriptor)\n            return component;\n    }\n    return NULL;\n}\n\nstatic MXFStructuralComponent* mxf_resolve_sourceclip(MXFContext *mxf, UID *strong_ref)\n{\n    MXFStructuralComponent *component = NULL;\n\n    component = mxf_resolve_strong_ref(mxf, strong_ref, AnyType);\n    if (!component)\n        return NULL;\n    switch (component->type) {\n        case SourceClip:\n            return component;\n        case EssenceGroup:\n            return mxf_resolve_essence_group_choice(mxf, (MXFEssenceGroup*) component);\n        default:\n            break;\n    }\n    return NULL;\n}\n\nstatic int mxf_parse_package_comments(MXFContext *mxf, AVDictionary **pm, MXFPackage *package)\n{\n    MXFTaggedValue *tag;\n    int size, i;\n    char *key = NULL;\n\n    for (i = 0; i < package->comment_count; i++) {\n        tag = mxf_resolve_strong_ref(mxf, &package->comment_refs[i], TaggedValue);\n        if (!tag || !tag->name || !tag->value)\n            continue;\n\n        size = strlen(tag->name) + 8 + 1;\n        key = av_mallocz(size);\n        if (!key)\n            return AVERROR(ENOMEM);\n\n        snprintf(key, size, \"comment_%s\", tag->name);\n        av_dict_set(pm, key, tag->value, AV_DICT_DONT_STRDUP_KEY);\n    }\n    return 0;\n}\n\nstatic int mxf_parse_physical_source_package(MXFContext *mxf, MXFTrack *source_track, AVStream *st)\n{\n    MXFPackage *physical_package = NULL;\n    MXFTrack *physical_track = NULL;\n    MXFStructuralComponent *sourceclip = NULL;\n    MXFTimecodeComponent *mxf_tc = NULL;\n    int i, j, k;\n    AVTimecode tc;\n    int flags;\n    int64_t start_position;\n\n    for (i = 0; i < source_track->sequence->structural_components_count; i++) {\n        sourceclip = mxf_resolve_strong_ref(mxf, &source_track->sequence->structural_components_refs[i], SourceClip);\n        if (!sourceclip)\n            continue;\n\n        if (!(physical_package = mxf_resolve_source_package(mxf, sourceclip->source_package_uid)))\n            break;\n\n        mxf_add_umid_metadata(&st->metadata, \"reel_umid\", physical_package);\n\n        /* the name of physical source package is name of the reel or tape */\n        if (physical_package->name && physical_package->name[0])\n            av_dict_set(&st->metadata, \"reel_name\", physical_package->name, 0);\n\n        /* the source timecode is calculated by adding the start_position of the sourceclip from the file source package track\n         * to the start_frame of the timecode component located on one of the tracks of the physical source package.\n         */\n        for (j = 0; j < physical_package->tracks_count; j++) {\n            if (!(physical_track = mxf_resolve_strong_ref(mxf, &physical_package->tracks_refs[j], Track))) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track strong ref\\n\");\n                continue;\n            }\n\n            if (!(physical_track->sequence = mxf_resolve_strong_ref(mxf, &physical_track->sequence_ref, Sequence))) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track sequence strong ref\\n\");\n                continue;\n            }\n\n        if (physical_track->edit_rate.num <= 0 ||\n            physical_track->edit_rate.den <= 0) {\n            av_log(mxf->fc, AV_LOG_WARNING,\n                   \"Invalid edit rate (%d/%d) found on structural\"\n                   \" component #%d, defaulting to 25/1\\n\",\n                   physical_track->edit_rate.num,\n                   physical_track->edit_rate.den, i);\n            physical_track->edit_rate = (AVRational){25, 1};\n        }\n\n            for (k = 0; k < physical_track->sequence->structural_components_count; k++) {\n                if (!(mxf_tc = mxf_resolve_timecode_component(mxf, &physical_track->sequence->structural_components_refs[k])))\n                    continue;\n\n                flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;\n                /* scale sourceclip start_position to match physical track edit rate */\n                start_position = av_rescale_q(sourceclip->start_position,\n                                              physical_track->edit_rate,\n                                              source_track->edit_rate);\n\n                if (av_timecode_init(&tc, mxf_tc->rate, flags, start_position + mxf_tc->start_frame, mxf->fc) == 0) {\n                    mxf_add_timecode_metadata(&st->metadata, \"timecode\", &tc);\n                    return 0;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int mxf_add_metadata_stream(MXFContext *mxf, MXFTrack *track)\n{\n    MXFStructuralComponent *component = NULL;\n    const MXFCodecUL *codec_ul = NULL;\n    MXFPackage tmp_package;\n    AVStream *st;\n    int j;\n\n    for (j = 0; j < track->sequence->structural_components_count; j++) {\n        component = mxf_resolve_sourceclip(mxf, &track->sequence->structural_components_refs[j]);\n        if (!component)\n            continue;\n        break;\n    }\n    if (!component)\n        return 0;\n\n    st = avformat_new_stream(mxf->fc, NULL);\n    if (!st) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate metadata stream\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n    st->codecpar->codec_id = AV_CODEC_ID_NONE;\n    st->id = track->track_id;\n\n    memcpy(&tmp_package.package_ul, component->source_package_ul, 16);\n    memcpy(&tmp_package.package_uid, component->source_package_uid, 16);\n    mxf_add_umid_metadata(&st->metadata, \"file_package_umid\", &tmp_package);\n    if (track->name && track->name[0])\n        av_dict_set(&st->metadata, \"track_name\", track->name, 0);\n\n    codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &track->sequence->data_definition_ul);\n    av_dict_set(&st->metadata, \"data_type\", av_get_media_type_string(codec_ul->id), 0);\n    return 0;\n}\n\nstatic int mxf_parse_structural_metadata(MXFContext *mxf)\n{\n    MXFPackage *material_package = NULL;\n    int i, j, k, ret;\n\n    av_log(mxf->fc, AV_LOG_TRACE, \"metadata sets count %d\\n\", mxf->metadata_sets_count);\n    /* TODO: handle multiple material packages (OP3x) */\n    for (i = 0; i < mxf->packages_count; i++) {\n        material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);\n        if (material_package) break;\n    }\n    if (!material_package) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"no material package found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    mxf_add_umid_metadata(&mxf->fc->metadata, \"material_package_umid\", material_package);\n    if (material_package->name && material_package->name[0])\n        av_dict_set(&mxf->fc->metadata, \"material_package_name\", material_package->name, 0);\n    mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);\n\n    for (i = 0; i < material_package->tracks_count; i++) {\n        MXFPackage *source_package = NULL;\n        MXFTrack *material_track = NULL;\n        MXFTrack *source_track = NULL;\n        MXFTrack *temp_track = NULL;\n        MXFDescriptor *descriptor = NULL;\n        MXFStructuralComponent *component = NULL;\n        MXFTimecodeComponent *mxf_tc = NULL;\n        UID *essence_container_ul = NULL;\n        const MXFCodecUL *codec_ul = NULL;\n        const MXFCodecUL *container_ul = NULL;\n        const MXFCodecUL *pix_fmt_ul = NULL;\n        AVStream *st;\n        AVTimecode tc;\n        int flags;\n\n        if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track strong ref\\n\");\n            continue;\n        }\n\n        if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {\n            mxf_tc = (MXFTimecodeComponent*)component;\n            flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;\n            if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {\n                mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);\n            }\n        }\n\n        if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track sequence strong ref\\n\");\n            continue;\n        }\n\n        for (j = 0; j < material_track->sequence->structural_components_count; j++) {\n            component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);\n            if (!component)\n                continue;\n\n            mxf_tc = (MXFTimecodeComponent*)component;\n            flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;\n            if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {\n                mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);\n                break;\n            }\n        }\n\n        /* TODO: handle multiple source clips, only finds first valid source clip */\n        if(material_track->sequence->structural_components_count > 1)\n            av_log(mxf->fc, AV_LOG_WARNING, \"material track %d: has %d components\\n\",\n                       material_track->track_id, material_track->sequence->structural_components_count);\n\n        for (j = 0; j < material_track->sequence->structural_components_count; j++) {\n            component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);\n            if (!component)\n                continue;\n\n            source_package = mxf_resolve_source_package(mxf, component->source_package_uid);\n            if (!source_package) {\n                av_log(mxf->fc, AV_LOG_TRACE, \"material track %d: no corresponding source package found\\n\", material_track->track_id);\n                break;\n            }\n            for (k = 0; k < source_package->tracks_count; k++) {\n                if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {\n                    av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track strong ref\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail_and_free;\n                }\n                if (temp_track->track_id == component->source_track_id) {\n                    source_track = temp_track;\n                    break;\n                }\n            }\n            if (!source_track) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: no corresponding source track found\\n\", material_track->track_id);\n                break;\n            }\n            if(source_track && component)\n                break;\n        }\n        if (!source_track || !component || !source_package) {\n            if((ret = mxf_add_metadata_stream(mxf, material_track)))\n                goto fail_and_free;\n            continue;\n        }\n\n        if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track sequence strong ref\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail_and_free;\n        }\n\n        /* 0001GL00.MXF.A1.mxf_opatom.mxf has the same SourcePackageID as 0001GL.MXF.V1.mxf_opatom.mxf\n         * This would result in both files appearing to have two streams. Work around this by sanity checking DataDefinition */\n        if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: DataDefinition mismatch\\n\", material_track->track_id);\n            continue;\n        }\n\n        st = avformat_new_stream(mxf->fc, NULL);\n        if (!st) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate stream\\n\");\n            ret = AVERROR(ENOMEM);\n            goto fail_and_free;\n        }\n        st->id = material_track->track_id;\n        st->priv_data = source_track;\n\n        source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);\n        descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);\n\n        /* A SourceClip from a EssenceGroup may only be a single frame of essence data. The clips duration is then how many\n         * frames its suppose to repeat for. Descriptor->duration, if present, contains the real duration of the essence data */\n        if (descriptor && descriptor->duration != AV_NOPTS_VALUE)\n            source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);\n        else\n            source_track->original_duration = st->duration = component->duration;\n\n        if (st->duration == -1)\n            st->duration = AV_NOPTS_VALUE;\n        st->start_time = component->start_position;\n        if (material_track->edit_rate.num <= 0 ||\n            material_track->edit_rate.den <= 0) {\n            av_log(mxf->fc, AV_LOG_WARNING,\n                   \"Invalid edit rate (%d/%d) found on stream #%d, \"\n                   \"defaulting to 25/1\\n\",\n                   material_track->edit_rate.num,\n                   material_track->edit_rate.den, st->index);\n            material_track->edit_rate = (AVRational){25, 1};\n        }\n        avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);\n\n        /* ensure SourceTrack EditRate == MaterialTrack EditRate since only\n         * the former is accessible via st->priv_data */\n        source_track->edit_rate = material_track->edit_rate;\n\n        PRINT_KEY(mxf->fc, \"data definition   ul\", source_track->sequence->data_definition_ul);\n        codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);\n        st->codecpar->codec_type = codec_ul->id;\n\n        if (!descriptor) {\n            av_log(mxf->fc, AV_LOG_INFO, \"source track %d: stream %d, no descriptor found\\n\", source_track->track_id, st->index);\n            continue;\n        }\n        PRINT_KEY(mxf->fc, \"essence codec     ul\", descriptor->essence_codec_ul);\n        PRINT_KEY(mxf->fc, \"essence container ul\", descriptor->essence_container_ul);\n        essence_container_ul = &descriptor->essence_container_ul;\n        /* HACK: replacing the original key with mxf_encrypted_essence_container\n         * is not allowed according to s429-6, try to find correct information anyway */\n        if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {\n            av_log(mxf->fc, AV_LOG_INFO, \"broken encrypted mxf file\\n\");\n            for (k = 0; k < mxf->metadata_sets_count; k++) {\n                MXFMetadataSet *metadata = mxf->metadata_sets[k];\n                if (metadata->type == CryptoContext) {\n                    essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;\n                    break;\n                }\n            }\n        }\n\n        /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */\n        codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);\n        st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;\n        if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {\n            codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);\n            st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;\n        }\n\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"%s: Universal Label: \",\n               avcodec_get_name(st->codecpar->codec_id));\n        for (k = 0; k < 16; k++) {\n            av_log(mxf->fc, AV_LOG_VERBOSE, \"%.2x\",\n                   descriptor->essence_codec_ul[k]);\n            if (!(k+1 & 19) || k == 5)\n                av_log(mxf->fc, AV_LOG_VERBOSE, \".\");\n        }\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"\\n\");\n\n        mxf_add_umid_metadata(&st->metadata, \"file_package_umid\", source_package);\n        if (source_package->name && source_package->name[0])\n            av_dict_set(&st->metadata, \"file_package_name\", source_package->name, 0);\n        if (material_track->name && material_track->name[0])\n            av_dict_set(&st->metadata, \"track_name\", material_track->name, 0);\n\n        mxf_parse_physical_source_package(mxf, source_track, st);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            source_track->intra_only = mxf_is_intra_only(descriptor);\n            container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);\n            if (st->codecpar->codec_id == AV_CODEC_ID_NONE)\n                st->codecpar->codec_id = container_ul->id;\n            st->codecpar->width = descriptor->width;\n            st->codecpar->height = descriptor->height; /* Field height, not frame height */\n            switch (descriptor->frame_layout) {\n                case FullFrame:\n                    st->codecpar->field_order = AV_FIELD_PROGRESSIVE;\n                    break;\n                case OneField:\n                    /* Every other line is stored and needs to be duplicated. */\n                    av_log(mxf->fc, AV_LOG_INFO, \"OneField frame layout isn't currently supported\\n\");\n                    break; /* The correct thing to do here is fall through, but by breaking we might be\n                              able to decode some streams at half the vertical resolution, rather than not al all.\n                              It's also for compatibility with the old behavior. */\n                case MixedFields:\n                    break;\n                case SegmentedFrame:\n                    st->codecpar->field_order = AV_FIELD_PROGRESSIVE;\n                case SeparateFields:\n                    av_log(mxf->fc, AV_LOG_DEBUG, \"video_line_map: (%d, %d), field_dominance: %d\\n\",\n                           descriptor->video_line_map[0], descriptor->video_line_map[1],\n                           descriptor->field_dominance);\n                    if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {\n                        /* Detect coded field order from VideoLineMap:\n                         *  (even, even) => bottom field coded first\n                         *  (even, odd)  => top field coded first\n                         *  (odd, even)  => top field coded first\n                         *  (odd, odd)   => bottom field coded first\n                         */\n                        if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {\n                            switch (descriptor->field_dominance) {\n                                case MXF_FIELD_DOMINANCE_DEFAULT:\n                                case MXF_FIELD_DOMINANCE_FF:\n                                    st->codecpar->field_order = AV_FIELD_TT;\n                                    break;\n                                case MXF_FIELD_DOMINANCE_FL:\n                                    st->codecpar->field_order = AV_FIELD_TB;\n                                    break;\n                                default:\n                                    avpriv_request_sample(mxf->fc,\n                                                          \"Field dominance %d support\",\n                                                          descriptor->field_dominance);\n                            }\n                        } else {\n                            switch (descriptor->field_dominance) {\n                                case MXF_FIELD_DOMINANCE_DEFAULT:\n                                case MXF_FIELD_DOMINANCE_FF:\n                                    st->codecpar->field_order = AV_FIELD_BB;\n                                    break;\n                                case MXF_FIELD_DOMINANCE_FL:\n                                    st->codecpar->field_order = AV_FIELD_BT;\n                                    break;\n                                default:\n                                    avpriv_request_sample(mxf->fc,\n                                                          \"Field dominance %d support\",\n                                                          descriptor->field_dominance);\n                            }\n                        }\n                    }\n                    /* Turn field height into frame height. */\n                    st->codecpar->height *= 2;\n                    break;\n                default:\n                    av_log(mxf->fc, AV_LOG_INFO, \"Unknown frame layout type: %d\\n\", descriptor->frame_layout);\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {\n                st->codecpar->format = descriptor->pix_fmt;\n                if (st->codecpar->format == AV_PIX_FMT_NONE) {\n                    pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,\n                                                  &descriptor->essence_codec_ul);\n                    st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;\n                    if (st->codecpar->format== AV_PIX_FMT_NONE) {\n                        st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,\n                                                                   &descriptor->essence_codec_ul)->id;\n                        if (!st->codecpar->codec_tag) {\n                            /* support files created before RP224v10 by defaulting to UYVY422\n                               if subsampling is 4:2:2 and component depth is 8-bit */\n                            if (descriptor->horiz_subsampling == 2 &&\n                                descriptor->vert_subsampling == 1 &&\n                                descriptor->component_depth == 8) {\n                                st->codecpar->format = AV_PIX_FMT_UYVY422;\n                            }\n                        }\n                    }\n                }\n            }\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n            if (material_track->sequence->origin) {\n                av_dict_set_int(&st->metadata, \"material_track_origin\", material_track->sequence->origin, 0);\n            }\n            if (source_track->sequence->origin) {\n                av_dict_set_int(&st->metadata, \"source_track_origin\", source_track->sequence->origin, 0);\n            }\n            if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den)\n                st->display_aspect_ratio = descriptor->aspect_ratio;\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);\n            /* Only overwrite existing codec ID if it is unset or A-law, which is the default according to SMPTE RP 224. */\n            if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))\n                st->codecpar->codec_id = (enum AVCodecID)container_ul->id;\n            st->codecpar->channels = descriptor->channels;\n            st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;\n\n            if (descriptor->sample_rate.den > 0) {\n                st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;\n                avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);\n            } else {\n                av_log(mxf->fc, AV_LOG_WARNING, \"invalid sample rate (%d/%d) \"\n                       \"found for stream #%d, time base forced to 1/48000\\n\",\n                       descriptor->sample_rate.num, descriptor->sample_rate.den,\n                       st->index);\n                avpriv_set_pts_info(st, 64, 1, 48000);\n            }\n\n            /* if duration is set, rescale it from EditRate to SampleRate */\n            if (st->duration != AV_NOPTS_VALUE)\n                st->duration = av_rescale_q(st->duration,\n                                            av_inv_q(material_track->edit_rate),\n                                            st->time_base);\n\n            /* TODO: implement AV_CODEC_ID_RAWAUDIO */\n            if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {\n                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n                else if (descriptor->bits_per_sample == 32)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n            } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {\n                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;\n                else if (descriptor->bits_per_sample == 32)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;\n            } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n            }\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {\n            int codec_id = mxf_get_codec_ul(mxf_data_essence_container_uls,\n                                            essence_container_ul)->id;\n            if (codec_id >= 0 &&\n                codec_id < FF_ARRAY_ELEMS(mxf_data_essence_descriptor)) {\n                av_dict_set(&st->metadata, \"data_type\",\n                            mxf_data_essence_descriptor[codec_id], 0);\n            }\n        }\n        if (descriptor->extradata) {\n            if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {\n                memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);\n            }\n        } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {\n            int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,\n                                               &descriptor->essence_codec_ul)->id;\n            if (coded_width)\n                st->codecpar->width = coded_width;\n            ret = ff_generate_avci_extradata(st);\n            if (ret < 0)\n                return ret;\n        }\n        if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && (*essence_container_ul)[15] > 0x01) {\n            /* TODO: decode timestamps */\n            st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        }\n    }\n\n    ret = 0;\nfail_and_free:\n    return ret;\n}\n\nstatic int64_t mxf_timestamp_to_int64(uint64_t timestamp)\n{\n    struct tm time = { 0 };\n    time.tm_year = (timestamp >> 48) - 1900;\n    time.tm_mon  = (timestamp >> 40 & 0xFF) - 1;\n    time.tm_mday = (timestamp >> 32 & 0xFF);\n    time.tm_hour = (timestamp >> 24 & 0xFF);\n    time.tm_min  = (timestamp >> 16 & 0xFF);\n    time.tm_sec  = (timestamp >> 8  & 0xFF);\n\n    /* msvcrt versions of strftime calls the invalid parameter handler\n     * (aborting the process if one isn't set) if the parameters are out\n     * of range. */\n    time.tm_mon  = av_clip(time.tm_mon,  0, 11);\n    time.tm_mday = av_clip(time.tm_mday, 1, 31);\n    time.tm_hour = av_clip(time.tm_hour, 0, 23);\n    time.tm_min  = av_clip(time.tm_min,  0, 59);\n    time.tm_sec  = av_clip(time.tm_sec,  0, 59);\n\n    return (int64_t)av_timegm(&time) * 1000000;\n}\n\n#define SET_STR_METADATA(pb, name, str) do { \\\n    if ((ret = mxf_read_utf16be_string(pb, size, &str)) < 0) \\\n        return ret; \\\n    av_dict_set(&s->metadata, name, str, AV_DICT_DONT_STRDUP_VAL); \\\n} while (0)\n\n#define SET_UID_METADATA(pb, name, var, str) do { \\\n    avio_read(pb, var, 16); \\\n    if ((ret = mxf_uid_to_str(var, &str)) < 0) \\\n        return ret; \\\n    av_dict_set(&s->metadata, name, str, AV_DICT_DONT_STRDUP_VAL); \\\n} while (0)\n\n#define SET_TS_METADATA(pb, name, var, str) do { \\\n    var = avio_rb64(pb); \\\n    if ((ret = avpriv_dict_set_timestamp(&s->metadata, name, mxf_timestamp_to_int64(var)) < 0)) \\\n        return ret; \\\n} while (0)\n\nstatic int mxf_read_identification_metadata(void *arg, AVIOContext *pb, int tag, int size, UID _uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    AVFormatContext *s = mxf->fc;\n    int ret;\n    UID uid = { 0 };\n    char *str = NULL;\n    uint64_t ts;\n    switch (tag) {\n    case 0x3C01:\n        SET_STR_METADATA(pb, \"company_name\", str);\n        break;\n    case 0x3C02:\n        SET_STR_METADATA(pb, \"product_name\", str);\n        break;\n    case 0x3C04:\n        SET_STR_METADATA(pb, \"product_version\", str);\n        break;\n    case 0x3C05:\n        SET_UID_METADATA(pb, \"product_uid\", uid, str);\n        break;\n    case 0x3C06:\n        SET_TS_METADATA(pb, \"modification_date\", ts, str);\n        break;\n    case 0x3C08:\n        SET_STR_METADATA(pb, \"application_platform\", str);\n        break;\n    case 0x3C09:\n        SET_UID_METADATA(pb, \"generation_uid\", uid, str);\n        break;\n    case 0x3C0A:\n        SET_UID_METADATA(pb, \"uid\", uid, str);\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_preface_metadata(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    AVFormatContext *s = mxf->fc;\n    int ret;\n    char *str = NULL;\n\n    if (tag >= 0x8000 && (IS_KLV_KEY(uid, mxf_avid_project_name))) {\n        SET_STR_METADATA(pb, \"project_name\", str);\n    }\n    return 0;\n}\n\nstatic const MXFMetadataReadTableEntry mxf_metadata_read_table[] = {\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x05,0x01,0x00 }, mxf_read_primer_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x01,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x02,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x03,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x02,0x04,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x03,0x01,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x03,0x02,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x03,0x03,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x03,0x04,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x04,0x02,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x04,0x04,0x00 }, mxf_read_partition_pack },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x2f,0x00 }, mxf_read_preface_metadata },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x30,0x00 }, mxf_read_identification_metadata },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x18,0x00 }, mxf_read_content_storage, 0, AnyType },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x37,0x00 }, mxf_read_package, sizeof(MXFPackage), SourcePackage },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x36,0x00 }, mxf_read_package, sizeof(MXFPackage), MaterialPackage },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x0f,0x00 }, mxf_read_sequence, sizeof(MXFSequence), Sequence },\n    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0D,0x01,0x01,0x01,0x01,0x01,0x05,0x00 }, mxf_read_essence_group, sizeof(MXFEssenceGroup), EssenceGroup},\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x11,0x00 }, mxf_read_source_clip, sizeof(MXFStructuralComponent), SourceClip },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3f,0x00 }, mxf_read_tagged_value, sizeof(MXFTaggedValue), TaggedValue },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x44,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), MultipleDescriptor },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x42,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* Generic Sound */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x28,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* CDCI */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x29,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* RGBA */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x48,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* Wave */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x47,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* AES3 */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x51,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* MPEG2VideoDescriptor */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x5c,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* VANC/VBI - SMPTE 436M */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x5e,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* MPEG2AudioDescriptor */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3A,0x00 }, mxf_read_track, sizeof(MXFTrack), Track }, /* Static Track */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3B,0x00 }, mxf_read_track, sizeof(MXFTrack), Track }, /* Generic Track */\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x14,0x00 }, mxf_read_timecode_component, sizeof(MXFTimecodeComponent), TimecodeComponent },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x0c,0x00 }, mxf_read_pulldown_component, sizeof(MXFPulldownComponent), PulldownComponent },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x04,0x01,0x02,0x02,0x00,0x00 }, mxf_read_cryptographic_context, sizeof(MXFCryptoContext), CryptoContext },\n    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x10,0x01,0x00 }, mxf_read_index_table_segment, sizeof(MXFIndexTableSegment), IndexTableSegment },\n    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, NULL, 0, AnyType },\n};\n\nstatic int mxf_metadataset_init(MXFMetadataSet *ctx, enum MXFMetadataSetType type)\n{\n    switch (type){\n    case MultipleDescriptor:\n    case Descriptor:\n        ((MXFDescriptor*)ctx)->pix_fmt = AV_PIX_FMT_NONE;\n        ((MXFDescriptor*)ctx)->duration = AV_NOPTS_VALUE;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nstatic int mxf_read_local_tags(MXFContext *mxf, KLVPacket *klv, MXFMetadataReadFunc *read_child, int ctx_size, enum MXFMetadataSetType type)\n{\n    AVIOContext *pb = mxf->fc->pb;\n    MXFMetadataSet *ctx = ctx_size ? av_mallocz(ctx_size) : mxf;\n    uint64_t klv_end = avio_tell(pb) + klv->length;\n\n    if (!ctx)\n        return AVERROR(ENOMEM);\n    mxf_metadataset_init(ctx, type);\n    while (avio_tell(pb) + 4 < klv_end && !avio_feof(pb)) {\n        int ret;\n        int tag = avio_rb16(pb);\n        int size = avio_rb16(pb); /* KLV specified by 0x53 */\n        uint64_t next = avio_tell(pb) + size;\n        UID uid = {0};\n\n        av_log(mxf->fc, AV_LOG_TRACE, \"local tag %#04x size %d\\n\", tag, size);\n        if (!size) { /* ignore empty tag, needed for some files with empty UMID tag */\n            av_log(mxf->fc, AV_LOG_ERROR, \"local tag %#04x with 0 size\\n\", tag);\n            continue;\n        }\n        if (tag > 0x7FFF) { /* dynamic tag */\n            int i;\n            for (i = 0; i < mxf->local_tags_count; i++) {\n                int local_tag = AV_RB16(mxf->local_tags+i*18);\n                if (local_tag == tag) {\n                    memcpy(uid, mxf->local_tags+i*18+2, 16);\n                    av_log(mxf->fc, AV_LOG_TRACE, \"local tag %#04x\\n\", local_tag);\n                    PRINT_KEY(mxf->fc, \"uid\", uid);\n                }\n            }\n        }\n        if (ctx_size && tag == 0x3C0A) {\n            avio_read(pb, ctx->uid, 16);\n        } else if ((ret = read_child(ctx, pb, tag, size, uid, -1)) < 0) {\n            mxf_free_metadataset(&ctx, !!ctx_size);\n            return ret;\n        }\n\n        /* Accept the 64k local set limit being exceeded (Avid). Don't accept\n         * it extending past the end of the KLV though (zzuf5.mxf). */\n        if (avio_tell(pb) > klv_end) {\n            if (ctx_size) {\n                ctx->type = type;\n                mxf_free_metadataset(&ctx, !!ctx_size);\n            }\n\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"local tag %#04x extends past end of local set @ %#\"PRIx64\"\\n\",\n                   tag, klv->offset);\n            return AVERROR_INVALIDDATA;\n        } else if (avio_tell(pb) <= next)   /* only seek forward, else this can loop for a long time */\n            avio_seek(pb, next, SEEK_SET);\n    }\n    if (ctx_size) ctx->type = type;\n    return ctx_size ? mxf_add_metadata_set(mxf, ctx) : 0;\n}\n\n/**\n * Matches any partition pack key, in other words:\n * - HeaderPartition\n * - BodyPartition\n * - FooterPartition\n * @return non-zero if the key is a partition pack key, zero otherwise\n */\nstatic int mxf_is_partition_pack_key(UID key)\n{\n    //NOTE: this is a little lax since it doesn't constraint key[14]\n    return !memcmp(key, mxf_header_partition_pack_key, 13) &&\n            key[13] >= 2 && key[13] <= 4;\n}\n\n/**\n * Parses a metadata KLV\n * @return <0 on error, 0 otherwise\n */\nstatic int mxf_parse_klv(MXFContext *mxf, KLVPacket klv, MXFMetadataReadFunc *read,\n                                     int ctx_size, enum MXFMetadataSetType type)\n{\n    AVFormatContext *s = mxf->fc;\n    int res;\n    if (klv.key[5] == 0x53) {\n        res = mxf_read_local_tags(mxf, &klv, read, ctx_size, type);\n    } else {\n        uint64_t next = avio_tell(s->pb) + klv.length;\n        res = read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n        /* only seek forward, else this can loop for a long time */\n        if (avio_tell(s->pb) > next) {\n            av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n                   klv.offset);\n            return AVERROR_INVALIDDATA;\n        }\n\n        avio_seek(s->pb, next, SEEK_SET);\n    }\n    if (res < 0) {\n        av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n        return res;\n    }\n    return 0;\n}\n\n/**\n * Seeks to the previous partition and parses it, if possible\n * @return <= 0 if we should stop parsing, > 0 if we should keep going\n */\nstatic int mxf_seek_to_previous_partition(MXFContext *mxf)\n{\n    AVIOContext *pb = mxf->fc->pb;\n    KLVPacket klv;\n    int64_t current_partition_ofs;\n    int ret;\n\n    if (!mxf->current_partition ||\n        mxf->run_in + mxf->current_partition->previous_partition <= mxf->last_forward_tell)\n        return 0;   /* we've parsed all partitions */\n\n    /* seek to previous partition */\n    current_partition_ofs = mxf->current_partition->pack_ofs;   //includes run-in\n    avio_seek(pb, mxf->run_in + mxf->current_partition->previous_partition, SEEK_SET);\n    mxf->current_partition = NULL;\n\n    av_log(mxf->fc, AV_LOG_TRACE, \"seeking to previous partition\\n\");\n\n    /* Make sure this is actually a PartitionPack, and if so parse it.\n     * See deadlock2.mxf\n     */\n    if ((ret = klv_read_packet(&klv, pb)) < 0) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to read PartitionPack KLV\\n\");\n        return ret;\n    }\n\n    if (!mxf_is_partition_pack_key(klv.key)) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"PreviousPartition @ %\" PRIx64 \" isn't a PartitionPack\\n\", klv.offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* We can't just check ofs >= current_partition_ofs because PreviousPartition\n     * can point to just before the current partition, causing klv_read_packet()\n     * to sync back up to it. See deadlock3.mxf\n     */\n    if (klv.offset >= current_partition_ofs) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"PreviousPartition for PartitionPack @ %\"\n               PRIx64 \" indirectly points to itself\\n\", current_partition_ofs);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = mxf_parse_klv(mxf, klv, mxf_read_partition_pack, 0, 0)) < 0)\n        return ret;\n\n    return 1;\n}\n\n/**\n * Called when essence is encountered\n * @return <= 0 if we should stop parsing, > 0 if we should keep going\n */\nstatic int mxf_parse_handle_essence(MXFContext *mxf)\n{\n    AVIOContext *pb = mxf->fc->pb;\n    int64_t ret;\n\n    if (mxf->parsing_backward) {\n        return mxf_seek_to_previous_partition(mxf);\n    } else {\n        if (!mxf->footer_partition) {\n            av_log(mxf->fc, AV_LOG_TRACE, \"no FooterPartition\\n\");\n            return 0;\n        }\n\n        av_log(mxf->fc, AV_LOG_TRACE, \"seeking to FooterPartition\\n\");\n\n        /* remember where we were so we don't end up seeking further back than this */\n        mxf->last_forward_tell = avio_tell(pb);\n\n        if (!(pb->seekable & AVIO_SEEKABLE_NORMAL)) {\n            av_log(mxf->fc, AV_LOG_INFO, \"file is not seekable - not parsing FooterPartition\\n\");\n            return -1;\n        }\n\n        /* seek to FooterPartition and parse backward */\n        if ((ret = avio_seek(pb, mxf->run_in + mxf->footer_partition, SEEK_SET)) < 0) {\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"failed to seek to FooterPartition @ 0x%\" PRIx64\n                   \" (%\"PRId64\") - partial file?\\n\",\n                   mxf->run_in + mxf->footer_partition, ret);\n            return ret;\n        }\n\n        mxf->current_partition = NULL;\n        mxf->parsing_backward = 1;\n    }\n\n    return 1;\n}\n\n/**\n * Called when the next partition or EOF is encountered\n * @return <= 0 if we should stop parsing, > 0 if we should keep going\n */\nstatic int mxf_parse_handle_partition_or_eof(MXFContext *mxf)\n{\n    return mxf->parsing_backward ? mxf_seek_to_previous_partition(mxf) : 1;\n}\n\n/**\n * Figures out the proper offset and length of the essence container in each partition\n */\nstatic void mxf_compute_essence_containers(MXFContext *mxf)\n{\n    int x;\n\n    /* everything is already correct */\n    if (mxf->op == OPAtom)\n        return;\n\n    for (x = 0; x < mxf->partitions_count; x++) {\n        MXFPartition *p = &mxf->partitions[x];\n\n        if (!p->body_sid)\n            continue;       /* BodySID == 0 -> no essence */\n\n        if (x >= mxf->partitions_count - 1)\n            break;          /* FooterPartition - can't compute length (and we don't need to) */\n\n        /* essence container spans to the next partition */\n        p->essence_length = mxf->partitions[x+1].this_partition - p->essence_offset;\n\n        if (p->essence_length < 0) {\n            /* next ThisPartition < essence_offset */\n            p->essence_length = 0;\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"partition %i: bad ThisPartition = %\"PRIX64\"\\n\",\n                   x+1, mxf->partitions[x+1].this_partition);\n        }\n    }\n}\n\nstatic int64_t round_to_kag(int64_t position, int kag_size)\n{\n    /* TODO: account for run-in? the spec isn't clear whether KAG should account for it */\n    /* NOTE: kag_size may be any integer between 1 - 2^10 */\n    int64_t ret = (position / kag_size) * kag_size;\n    return ret == position ? ret : ret + kag_size;\n}\n\nstatic int is_pcm(enum AVCodecID codec_id)\n{\n    /* we only care about \"normal\" PCM codecs until we get samples */\n    return codec_id >= AV_CODEC_ID_PCM_S16LE && codec_id < AV_CODEC_ID_PCM_S24DAUD;\n}\n\nstatic AVStream* mxf_get_opatom_stream(MXFContext *mxf)\n{\n    int i;\n\n    if (mxf->op != OPAtom)\n        return NULL;\n\n    for (i = 0; i < mxf->fc->nb_streams; i++) {\n        if (mxf->fc->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_DATA)\n            continue;\n        return mxf->fc->streams[i];\n    }\n    return NULL;\n}\n\n/**\n * Deal with the case where for some audio atoms EditUnitByteCount is\n * very small (2, 4..). In those cases we should read more than one\n * sample per call to mxf_read_packet().\n */\nstatic void mxf_handle_small_eubc(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n\n    /* assuming non-OPAtom == frame wrapped\n     * no sane writer would wrap 2 byte PCM packets with 20 byte headers.. */\n    AVStream *st = mxf_get_opatom_stream(mxf);\n    if (!st)\n        return;\n\n    /* expect PCM with exactly one index table segment and a small (< 32) EUBC */\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO         ||\n        !is_pcm(st->codecpar->codec_id)                        ||\n        mxf->nb_index_tables != 1                              ||\n        mxf->index_tables[0].nb_segments != 1                  ||\n        mxf->index_tables[0].segments[0]->edit_unit_byte_count >= 32)\n        return;\n\n    /* arbitrarily default to 48 kHz PAL audio frame size */\n    /* TODO: We could compute this from the ratio between the audio\n     *       and video edit rates for 48 kHz NTSC we could use the\n     *       1802-1802-1802-1802-1801 pattern. */\n    mxf->edit_units_per_packet = 1920;\n}\n\n/**\n * Deal with the case where OPAtom files does not have any IndexTableSegments.\n */\nstatic int mxf_handle_missing_index_segment(MXFContext *mxf)\n{\n    AVFormatContext *s = mxf->fc;\n    AVStream *st = NULL;\n    MXFIndexTableSegment *segment = NULL;\n    MXFPartition *p = NULL;\n    int essence_partition_count = 0;\n    int i, ret;\n\n    st = mxf_get_opatom_stream(mxf);\n    if (!st)\n        return 0;\n\n    /* TODO: support raw video without an index if they exist */\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO || !is_pcm(st->codecpar->codec_id))\n        return 0;\n\n    /* check if file already has a IndexTableSegment */\n    for (i = 0; i < mxf->metadata_sets_count; i++) {\n        if (mxf->metadata_sets[i]->type == IndexTableSegment)\n            return 0;\n    }\n\n    /* find the essence partition */\n    for (i = 0; i < mxf->partitions_count; i++) {\n        /* BodySID == 0 -> no essence */\n        if (!mxf->partitions[i].body_sid)\n            continue;\n\n        p = &mxf->partitions[i];\n        essence_partition_count++;\n    }\n\n    /* only handle files with a single essence partition */\n    if (essence_partition_count != 1)\n        return 0;\n\n    if (!(segment = av_mallocz(sizeof(*segment))))\n        return AVERROR(ENOMEM);\n\n    if ((ret = mxf_add_metadata_set(mxf, segment))) {\n        mxf_free_metadataset((MXFMetadataSet**)&segment, 1);\n        return ret;\n    }\n\n    segment->type = IndexTableSegment;\n    /* stream will be treated as small EditUnitByteCount */\n    segment->edit_unit_byte_count = (av_get_bits_per_sample(st->codecpar->codec_id) * st->codecpar->channels) >> 3;\n    segment->index_start_position = 0;\n    segment->index_duration = s->streams[0]->duration;\n    segment->index_sid = p->index_sid;\n    segment->body_sid = p->body_sid;\n    return 0;\n}\n\nstatic void mxf_read_random_index_pack(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n    uint32_t length;\n    int64_t file_size, max_rip_length, min_rip_length;\n    KLVPacket klv;\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL))\n        return;\n\n    file_size = avio_size(s->pb);\n\n    /* S377m says to check the RIP length for \"silly\" values, without defining \"silly\".\n     * The limit below assumes a file with nothing but partition packs and a RIP.\n     * Before changing this, consider that a muxer may place each sample in its own partition.\n     *\n     * 105 is the size of the smallest possible PartitionPack\n     * 12 is the size of each RIP entry\n     * 28 is the size of the RIP header and footer, assuming an 8-byte BER\n     */\n    max_rip_length = ((file_size - mxf->run_in) / 105) * 12 + 28;\n    max_rip_length = FFMIN(max_rip_length, INT_MAX); //2 GiB and up is also silly\n\n    /* We're only interested in RIPs with at least two entries.. */\n    min_rip_length = 16+1+24+4;\n\n    /* See S377m section 11 */\n    avio_seek(s->pb, file_size - 4, SEEK_SET);\n    length = avio_rb32(s->pb);\n\n    if (length < min_rip_length || length > max_rip_length)\n        goto end;\n    avio_seek(s->pb, file_size - length, SEEK_SET);\n    if (klv_read_packet(&klv, s->pb) < 0 ||\n        !IS_KLV_KEY(klv.key, mxf_random_index_pack_key) ||\n        klv.length != length - 20)\n        goto end;\n\n    avio_skip(s->pb, klv.length - 12);\n    mxf->footer_partition = avio_rb64(s->pb);\n\n    /* sanity check */\n    if (mxf->run_in + mxf->footer_partition >= file_size) {\n        av_log(s, AV_LOG_WARNING, \"bad FooterPartition in RIP - ignoring\\n\");\n        mxf->footer_partition = 0;\n    }\n\nend:\n    avio_seek(s->pb, mxf->run_in, SEEK_SET);\n}\n\nstatic int mxf_read_header(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n    KLVPacket klv;\n    int64_t essence_offset = 0;\n    int ret;\n\n    mxf->last_forward_tell = INT64_MAX;\n    mxf->edit_units_per_packet = 1;\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_seek(s->pb, -14, SEEK_CUR);\n    mxf->fc = s;\n    mxf->run_in = avio_tell(s->pb);\n\n    mxf_read_random_index_pack(s);\n\n    while (!avio_feof(s->pb)) {\n        const MXFMetadataReadTableEntry *metadata;\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n            /* EOF - seek to previous partition or stop */\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n                break;\n            else\n                continue;\n        }\n\n        PRINT_KEY(s, \"read header\", klv.key);\n        av_log(s, AV_LOG_TRACE, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n            if (!mxf->current_partition) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"found essence prior to first PartitionPack\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (!mxf->current_partition->essence_offset) {\n                /* for OP1a we compute essence_offset\n                 * for OPAtom we point essence_offset after the KL (usually op1a_essence_offset + 20 or 25)\n                 * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1a_essence_offset\n                 *       for OPAtom we still need the actual essence_offset though (the KL's length can vary)\n                 */\n                int64_t op1a_essence_offset =\n                    round_to_kag(mxf->current_partition->this_partition +\n                                 mxf->current_partition->pack_length,       mxf->current_partition->kag_size) +\n                    round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n                    round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n\n                if (mxf->op == OPAtom) {\n                    /* point essence_offset to the actual data\n                    * OPAtom has all the essence in one big KLV\n                    */\n                    mxf->current_partition->essence_offset = avio_tell(s->pb);\n                    mxf->current_partition->essence_length = klv.length;\n                } else {\n                    /* NOTE: op1a_essence_offset may be less than to klv.offset (C0023S01.mxf)  */\n                    mxf->current_partition->essence_offset = op1a_essence_offset;\n                }\n            }\n\n            if (!essence_offset)\n                essence_offset = klv.offset;\n\n            /* seek to footer, previous partition or stop */\n            if (mxf_parse_handle_essence(mxf) <= 0)\n                break;\n            continue;\n        } else if (mxf_is_partition_pack_key(klv.key) && mxf->current_partition) {\n            /* next partition pack - keep going, seek to previous partition or stop */\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n                break;\n            else if (mxf->parsing_backward)\n                continue;\n            /* we're still parsing forward. proceed to parsing this partition pack */\n        }\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n                if ((ret = mxf_parse_klv(mxf, klv, metadata->read, metadata->ctx_size, metadata->type)) < 0)\n                    goto fail;\n                break;\n            }\n        }\n        if (!metadata->read) {\n            av_log(s, AV_LOG_VERBOSE, \"Dark key \" PRIxUID \"\\n\",\n                            UID_ARG(klv.key));\n            avio_skip(s->pb, klv.length);\n        }\n    }\n    /* FIXME avoid seek */\n    if (!essence_offset)  {\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n    mxf_compute_essence_containers(mxf);\n\n    /* we need to do this before computing the index tables\n     * to be able to fill in zero IndexDurations with st->duration */\n    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n        goto fail;\n\n    mxf_handle_missing_index_segment(mxf);\n    if ((ret = mxf_compute_index_tables(mxf)) < 0)\n        goto fail;\n\n    if (mxf->nb_index_tables > 1) {\n        /* TODO: look up which IndexSID to use via EssenceContainerData */\n        av_log(mxf->fc, AV_LOG_INFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\",\n               mxf->nb_index_tables, mxf->index_tables[0].index_sid);\n    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"cannot demux OPAtom without an index\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    mxf_handle_small_eubc(s);\n\n    return 0;\nfail:\n    mxf_read_close(s);\n\n    return ret;\n}\n\n/**\n * Sets mxf->current_edit_unit based on what offset we're currently at.\n * @return next_ofs if OK, <0 on error\n */\nstatic int64_t mxf_set_current_edit_unit(MXFContext *mxf, int64_t current_offset)\n{\n    int64_t last_ofs = -1, next_ofs = -1;\n    MXFIndexTable *t = &mxf->index_tables[0];\n\n    /* this is called from the OP1a demuxing logic, which means there\n     * may be no index tables */\n    if (mxf->nb_index_tables <= 0)\n        return -1;\n\n    /* find mxf->current_edit_unit so that the next edit unit starts ahead of current_offset */\n    while (mxf->current_edit_unit >= 0) {\n        if (mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit + 1, NULL, &next_ofs, 0) < 0)\n            return -1;\n\n        if (next_ofs <= last_ofs) {\n            /* large next_ofs didn't change or current_edit_unit wrapped\n             * around this fixes the infinite loop on zzuf3.mxf */\n            av_log(mxf->fc, AV_LOG_ERROR,\n                   \"next_ofs didn't change. not deriving packet timestamps\\n\");\n            return -1;\n        }\n\n        if (next_ofs > current_offset)\n            break;\n\n        last_ofs = next_ofs;\n        mxf->current_edit_unit++;\n    }\n\n    /* not checking mxf->current_edit_unit >= t->nb_ptses here since CBR files may lack IndexEntryArrays */\n    if (mxf->current_edit_unit < 0)\n        return -1;\n\n    return next_ofs;\n}\n\nstatic int mxf_compute_sample_count(MXFContext *mxf, int stream_index,\n                                    uint64_t *sample_count)\n{\n    int i, total = 0, size = 0;\n    AVStream *st = mxf->fc->streams[stream_index];\n    MXFTrack *track = st->priv_data;\n    AVRational time_base = av_inv_q(track->edit_rate);\n    AVRational sample_rate = av_inv_q(st->time_base);\n    const MXFSamplesPerFrame *spf = NULL;\n\n    if ((sample_rate.num / sample_rate.den) == 48000)\n        spf = ff_mxf_get_samples_per_frame(mxf->fc, time_base);\n    if (!spf) {\n        int remainder = (sample_rate.num * time_base.num) %\n                        (time_base.den * sample_rate.den);\n        *sample_count = av_q2d(av_mul_q((AVRational){mxf->current_edit_unit, 1},\n                                        av_mul_q(sample_rate, time_base)));\n        if (remainder)\n            av_log(mxf->fc, AV_LOG_WARNING,\n                   \"seeking detected on stream #%d with time base (%d/%d) and \"\n                   \"sample rate (%d/%d), audio pts won't be accurate.\\n\",\n                   stream_index, time_base.num, time_base.den,\n                   sample_rate.num, sample_rate.den);\n        return 0;\n    }\n\n    while (spf->samples_per_frame[size]) {\n        total += spf->samples_per_frame[size];\n        size++;\n    }\n\n    av_assert2(size);\n\n    *sample_count = (mxf->current_edit_unit / size) * (uint64_t)total;\n    for (i = 0; i < mxf->current_edit_unit % size; i++) {\n        *sample_count += spf->samples_per_frame[i];\n    }\n\n    return 0;\n}\n\nstatic int mxf_set_audio_pts(MXFContext *mxf, AVCodecParameters *par,\n                             AVPacket *pkt)\n{\n    MXFTrack *track = mxf->fc->streams[pkt->stream_index]->priv_data;\n    int64_t bits_per_sample = par->bits_per_coded_sample;\n\n    if (!bits_per_sample)\n        bits_per_sample = av_get_bits_per_sample(par->codec_id);\n\n    pkt->pts = track->sample_count;\n\n    if (   par->channels <= 0\n        || bits_per_sample <= 0\n        || par->channels * (int64_t)bits_per_sample < 8)\n        return AVERROR(EINVAL);\n    track->sample_count += pkt->size / (par->channels * (int64_t)bits_per_sample / 8);\n    return 0;\n}\n\nstatic int mxf_read_packet_old(AVFormatContext *s, AVPacket *pkt)\n{\n    KLVPacket klv;\n    MXFContext *mxf = s->priv_data;\n    int ret;\n\n    while ((ret = klv_read_packet(&klv, s->pb)) == 0) {\n        PRINT_KEY(s, \"read packet\", klv.key);\n        av_log(s, AV_LOG_TRACE, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key)) {\n            ret = mxf_decrypt_triplet(s, pkt, &klv);\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"invalid encoded triplet\\n\");\n                return ret;\n            }\n            return 0;\n        }\n        if (IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n            IS_KLV_KEY(klv.key, mxf_canopus_essence_element_key) ||\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key)) {\n            int index = mxf_get_stream_index(s, &klv);\n            int64_t next_ofs, next_klv;\n            AVStream *st;\n            MXFTrack *track;\n            AVCodecParameters *par;\n\n            if (index < 0) {\n                av_log(s, AV_LOG_ERROR,\n                       \"error getting stream index %\"PRIu32\"\\n\",\n                       AV_RB32(klv.key + 12));\n                goto skip;\n            }\n\n            st = s->streams[index];\n            track = st->priv_data;\n\n            if (s->streams[index]->discard == AVDISCARD_ALL)\n                goto skip;\n\n            next_klv = avio_tell(s->pb) + klv.length;\n            next_ofs = mxf_set_current_edit_unit(mxf, klv.offset);\n\n            if (next_ofs >= 0 && next_klv > next_ofs) {\n                /* if this check is hit then it's possible OPAtom was treated as OP1a\n                 * truncate the packet since it's probably very large (>2 GiB is common) */\n                avpriv_request_sample(s,\n                                      \"OPAtom misinterpreted as OP1a? \"\n                                      \"KLV for edit unit %i extending into \"\n                                      \"next edit unit\",\n                                      mxf->current_edit_unit);\n                klv.length = next_ofs - avio_tell(s->pb);\n            }\n\n            /* check for 8 channels AES3 element */\n            if (klv.key[12] == 0x06 && klv.key[13] == 0x01 && klv.key[14] == 0x10) {\n                ret = mxf_get_d10_aes3_packet(s->pb, s->streams[index],\n                                              pkt, klv.length);\n                if (ret < 0) {\n                    av_log(s, AV_LOG_ERROR, \"error reading D-10 aes3 frame\\n\");\n                    return ret;\n                }\n            } else {\n                ret = av_get_packet(s->pb, pkt, klv.length);\n                if (ret < 0)\n                    return ret;\n            }\n            pkt->stream_index = index;\n            pkt->pos = klv.offset;\n\n            par = st->codecpar;\n\n            if (par->codec_type == AVMEDIA_TYPE_VIDEO && next_ofs >= 0) {\n                /* mxf->current_edit_unit good - see if we have an\n                 * index table to derive timestamps from */\n                MXFIndexTable *t = &mxf->index_tables[0];\n\n                if (mxf->nb_index_tables >= 1 && mxf->current_edit_unit < t->nb_ptses) {\n                    pkt->dts = mxf->current_edit_unit + t->first_dts;\n                    pkt->pts = t->ptses[mxf->current_edit_unit];\n                } else if (track && track->intra_only) {\n                    /* intra-only -> PTS = EditUnit.\n                     * let utils.c figure out DTS since it can be < PTS if low_delay = 0 (Sony IMX30) */\n                    pkt->pts = mxf->current_edit_unit;\n                }\n            } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {\n                ret = mxf_set_audio_pts(mxf, par, pkt);\n                if (ret < 0)\n                    return ret;\n            }\n\n            /* seek for truncated packets */\n            avio_seek(s->pb, next_klv, SEEK_SET);\n\n            return 0;\n        } else\n        skip:\n            avio_skip(s->pb, klv.length);\n    }\n    return avio_feof(s->pb) ? AVERROR_EOF : ret;\n}\n\nstatic int mxf_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MXFContext *mxf = s->priv_data;\n    int ret, size;\n    int64_t ret64, pos, next_pos;\n    AVStream *st;\n    MXFIndexTable *t;\n    int edit_units;\n\n    if (mxf->op != OPAtom)\n        return mxf_read_packet_old(s, pkt);\n\n    // If we have no streams then we basically are at EOF\n    st = mxf_get_opatom_stream(mxf);\n    if (!st)\n        return AVERROR_EOF;\n\n    /* OPAtom - clip wrapped demuxing */\n    /* NOTE: mxf_read_header() makes sure nb_index_tables > 0 for OPAtom */\n    t = &mxf->index_tables[0];\n\n    if (mxf->current_edit_unit >= st->duration)\n        return AVERROR_EOF;\n\n    edit_units = FFMIN(mxf->edit_units_per_packet, st->duration - mxf->current_edit_unit);\n\n    if ((ret = mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit, NULL, &pos, 1)) < 0)\n        return ret;\n\n    /* compute size by finding the next edit unit or the end of the essence container\n     * not pretty, but it works */\n    if ((ret = mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit + edit_units, NULL, &next_pos, 0)) < 0 &&\n        (next_pos = mxf_essence_container_end(mxf, t->body_sid)) <= 0) {\n        av_log(s, AV_LOG_ERROR, \"unable to compute the size of the last packet\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((size = next_pos - pos) <= 0) {\n        av_log(s, AV_LOG_ERROR, \"bad size: %i\\n\", size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret64 = avio_seek(s->pb, pos, SEEK_SET)) < 0)\n        return ret64;\n\n    if ((size = av_get_packet(s->pb, pkt, size)) < 0)\n        return size;\n\n    pkt->stream_index = st->index;\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && t->ptses &&\n        mxf->current_edit_unit >= 0 && mxf->current_edit_unit < t->nb_ptses) {\n        pkt->dts = mxf->current_edit_unit + t->first_dts;\n        pkt->pts = t->ptses[mxf->current_edit_unit];\n    } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n        int ret = mxf_set_audio_pts(mxf, st->codecpar, pkt);\n        if (ret < 0)\n            return ret;\n    }\n\n    mxf->current_edit_unit += edit_units;\n\n    return 0;\n}\n\nstatic int mxf_read_close(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n    int i;\n\n    av_freep(&mxf->packages_refs);\n\n    for (i = 0; i < s->nb_streams; i++)\n        s->streams[i]->priv_data = NULL;\n\n    for (i = 0; i < mxf->metadata_sets_count; i++) {\n        mxf_free_metadataset(mxf->metadata_sets + i, 1);\n    }\n    av_freep(&mxf->partitions);\n    av_freep(&mxf->metadata_sets);\n    av_freep(&mxf->aesc);\n    av_freep(&mxf->local_tags);\n\n    if (mxf->index_tables) {\n        for (i = 0; i < mxf->nb_index_tables; i++) {\n            av_freep(&mxf->index_tables[i].segments);\n            av_freep(&mxf->index_tables[i].ptses);\n            av_freep(&mxf->index_tables[i].fake_index);\n            av_freep(&mxf->index_tables[i].offsets);\n        }\n    }\n    av_freep(&mxf->index_tables);\n\n    return 0;\n}\n\nstatic int mxf_probe(AVProbeData *p) {\n    const uint8_t *bufp = p->buf;\n    const uint8_t *end = p->buf + p->buf_size;\n\n    if (p->buf_size < sizeof(mxf_header_partition_pack_key))\n        return 0;\n\n    /* Must skip Run-In Sequence and search for MXF header partition pack key SMPTE 377M 5.5 */\n    end -= sizeof(mxf_header_partition_pack_key);\n\n    for (; bufp < end;) {\n        if (!((bufp[13] - 1) & 0xF2)){\n            if (AV_RN32(bufp   ) == AV_RN32(mxf_header_partition_pack_key   ) &&\n                AV_RN32(bufp+ 4) == AV_RN32(mxf_header_partition_pack_key+ 4) &&\n                AV_RN32(bufp+ 8) == AV_RN32(mxf_header_partition_pack_key+ 8) &&\n                AV_RN16(bufp+12) == AV_RN16(mxf_header_partition_pack_key+12))\n                return AVPROBE_SCORE_MAX;\n            bufp ++;\n        } else\n            bufp += 10;\n    }\n\n    return 0;\n}\n\n/* rudimentary byte seek */\n/* XXX: use MXF Index */\nstatic int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n{\n    AVStream *st = s->streams[stream_index];\n    int64_t seconds;\n    MXFContext* mxf = s->priv_data;\n    int64_t seekpos;\n    int i, ret;\n    MXFIndexTable *t;\n    MXFTrack *source_track = st->priv_data;\n\n    if(st->codecpar->codec_type == AVMEDIA_TYPE_DATA)\n        return 0;\n\n    /* if audio then truncate sample_time to EditRate */\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n        sample_time = av_rescale_q(sample_time, st->time_base,\n                                   av_inv_q(source_track->edit_rate));\n\n    if (mxf->nb_index_tables <= 0) {\n    if (!s->bit_rate)\n        return AVERROR_INVALIDDATA;\n    if (sample_time < 0)\n        sample_time = 0;\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n    seekpos = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET);\n    if (seekpos < 0)\n        return seekpos;\n\n    ff_update_cur_dts(s, st, sample_time);\n    mxf->current_edit_unit = sample_time;\n    } else {\n        t = &mxf->index_tables[0];\n\n        /* clamp above zero, else ff_index_search_timestamp() returns negative\n         * this also means we allow seeking before the start */\n        sample_time = FFMAX(sample_time, 0);\n\n        if (t->fake_index) {\n            /* The first frames may not be keyframes in presentation order, so\n             * we have to advance the target to be able to find the first\n             * keyframe backwards... */\n            if (!(flags & AVSEEK_FLAG_ANY) &&\n                (flags & AVSEEK_FLAG_BACKWARD) &&\n                t->ptses[0] != AV_NOPTS_VALUE &&\n                sample_time < t->ptses[0] &&\n                (t->fake_index[t->ptses[0]].flags & AVINDEX_KEYFRAME))\n                sample_time = t->ptses[0];\n\n            /* behave as if we have a proper index */\n            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)\n                return sample_time;\n            /* get the stored order index from the display order index */\n            sample_time += t->offsets[sample_time];\n        } else {\n            /* no IndexEntryArray (one or more CBR segments)\n             * make sure we don't seek past the end */\n            sample_time = FFMIN(sample_time, source_track->original_duration - 1);\n        }\n\n        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) < 0)\n            return ret;\n\n        ff_update_cur_dts(s, st, sample_time);\n        mxf->current_edit_unit = sample_time;\n        avio_seek(s->pb, seekpos, SEEK_SET);\n    }\n\n    // Update all tracks sample count\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *cur_st = s->streams[i];\n        MXFTrack *cur_track = cur_st->priv_data;\n        uint64_t current_sample_count = 0;\n        if (cur_st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            ret = mxf_compute_sample_count(mxf, i, &current_sample_count);\n            if (ret < 0)\n                return ret;\n\n            cur_track->sample_count = current_sample_count;\n        }\n    }\n    return 0;\n}\n\nAVInputFormat ff_mxf_demuxer = {\n    .name           = \"mxf\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"MXF (Material eXchange Format)\"),\n    .flags          = AVFMT_SEEK_TO_PTS,\n    .priv_data_size = sizeof(MXFContext),\n    .read_probe     = mxf_probe,\n    .read_header    = mxf_read_header,\n    .read_packet    = mxf_read_packet,\n    .read_close     = mxf_read_close,\n    .read_seek      = mxf_read_seek,\n};\n"], "filenames": ["libavformat/mxfdec.c"], "buggy_code_start_loc": [901], "buggy_code_end_loc": [911], "fixing_code_start_loc": [902], "fixing_code_end_loc": [916], "type": "CWE-834", "message": "In libavformat/mxfdec.c in FFmpeg 3.3.3 -> 2.4, a DoS in mxf_read_index_entry_array() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted MXF file, which claims a large \"nb_index_entries\" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU resources, since there is no EOF check inside the loop. Moreover, this big loop can be invoked multiple times if there is more than one applicable data segment in the crafted MXF file.", "other": {"cve": {"id": "CVE-2017-14170", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-07T06:29:00.267", "lastModified": "2021-01-04T19:15:12.797", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libavformat/mxfdec.c in FFmpeg 3.3.3 -> 2.4, a DoS in mxf_read_index_entry_array() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted MXF file, which claims a large \"nb_index_entries\" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU resources, since there is no EOF check inside the loop. Moreover, this big loop can be invoked multiple times if there is more than one applicable data segment in the crafted MXF file."}, {"lang": "es", "value": "En libavformat/mxfdec.c en FFmpeg versi\u00f3n 3.3.3 mayor a 2.4, en DoS una denegaci\u00f3n de servicio en mxf_read_index_entry_array() por una falta de chequeos EOF (End of File) podr\u00eda provocar un enorme consumo de recursos de la CPU. Cuando se proporciona un archivo MXF manipulado que pide un campo \"nb_index_entries\" grande en la cabecera pero no contiene suficientes datos de respaldo, el bucle consumir\u00eda una gran cantidad de recursos de CPU, ya que el bucle no contiene ning\u00fan chequeo EOF. Adem\u00e1s, este gran bucle se invocar\u00eda en m\u00faltiples ocasiones si existe m\u00e1s de un segmento de datos aplicable en el archivo MXF manipulado"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100700", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/900f39692ca0337a98a7cf047e4e2611071810c2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/f173cdfe669556aa92857adafe60cbe5f2aa1210", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/900f39692ca0337a98a7cf047e4e2611071810c2"}}