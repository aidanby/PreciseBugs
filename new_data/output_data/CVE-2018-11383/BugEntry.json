{"buggy_code": ["/* radare - LGPL - Copyright 2011-2018 - pancake, Roc Valles, condret, killabyte */\n\n#if 0\nhttp://www.atmel.com/images/atmel-0856-avr-instruction-set-manual.pdf\nhttps://en.wikipedia.org/wiki/Atmel_AVR_instruction_set\n#endif\n\n#include <string.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n\nstatic RDESContext desctx;\n\ntypedef struct _cpu_const_tag {\n\tconst char *const key;\n\tut8 type;\n\tut32 value;\n\tut8 size;\n} CPU_CONST;\n\n#define CPU_CONST_NONE\t0\n#define CPU_CONST_PARAM\t1\n#define CPU_CONST_REG\t2\n\ntypedef struct _cpu_model_tag {\n\tconst char *const model;\n\tint pc;\n\tchar *inherit;\n\tstruct _cpu_model_tag *inherit_cpu_p;\n\tCPU_CONST *consts[10];\n} CPU_MODEL;\n\ntypedef void (*inst_handler_t) (RAnal *anal, RAnalOp *op, const ut8 *buf, int len, int *fail, CPU_MODEL *cpu);\n\ntypedef struct _opcodes_tag_ {\n\tconst char *const name;\n\tint mask;\n\tint selector;\n\tinst_handler_t handler;\n\tint cycles;\n\tint size;\n\tut64 type;\n} OPCODE_DESC;\n\nstatic OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu);\n\n#define CPU_MODEL_DECL(model, pc, consts)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tmodel,\t\t\t\t\t\t\t\\\n\t\tpc,\t\t\t\t\t\t\t\\\n\t\tconsts\t\t\t\t\t\t\t\\\n\t}\n#define MASK(bits)\t\t\t((bits) == 32 ? 0xffffffff : (~((~((ut32) 0)) << (bits))))\n#define CPU_PC_MASK(cpu)\t\tMASK((cpu)->pc)\n#define CPU_PC_SIZE(cpu)\t\t((((cpu)->pc) >> 3) + ((((cpu)->pc) & 0x07) ? 1 : 0))\n\n#define INST_HANDLER(OPCODE_NAME)\tstatic void _inst__ ## OPCODE_NAME (RAnal *anal, RAnalOp *op, const ut8 *buf, int len, int *fail, CPU_MODEL *cpu)\n#define INST_DECL(OP, M, SL, C, SZ, T)\t{ #OP, (M), (SL), _inst__ ## OP, (C), (SZ), R_ANAL_OP_TYPE_ ## T }\n#define INST_LAST\t\t\t{ \"unknown\", 0, 0, (void *) 0, 2, 1, R_ANAL_OP_TYPE_UNK }\n\n#define INST_CALL(OPCODE_NAME)\t\t_inst__ ## OPCODE_NAME (anal, op, buf, len, fail, cpu)\n#define INST_INVALID\t\t\t{ *fail = 1; return; }\n#define INST_ASSERT(x)\t\t\t{ if (!(x)) { INST_INVALID; } }\n\n#define ESIL_A(e, ...)\t\t\tr_strbuf_appendf (&op->esil, e, ##__VA_ARGS__)\n\n#define STR_BEGINS(in, s)\t\tstrncasecmp (in, s, strlen (s))\n\n// Following IO definitions are valid for:\n//\tATmega8\n//\tATmega88\nCPU_CONST cpu_reg_common[] = {\n\t{ \"spl\",    CPU_CONST_REG, 0x3d, sizeof (ut8) },\n\t{ \"sph\",    CPU_CONST_REG, 0x3e, sizeof (ut8) },\n\t{ \"sreg\",   CPU_CONST_REG, 0x3f, sizeof (ut8) },\n\t{ \"spmcsr\", CPU_CONST_REG, 0x37, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_common[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,  512, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM, 0x40, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM, 0x60, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 1024, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_m640_m1280m_m1281_m2560_m2561[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,    512, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM,  0x1ff, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM,  0x200, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 0x2000, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_xmega128a4u[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,  0x800, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM, 0x1000, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM,  0x800, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 0x2000, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_pagesize_5_bits[] = {\n\t{ \"page_size\", CPU_CONST_PARAM, 5, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_pagesize_7_bits[] = {\n\t{ \"page_size\", CPU_CONST_PARAM, 7, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_MODEL cpu_models[] = {\n\t{ .model = \"ATmega640\",   .pc = 15,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_m640_m1280m_m1281_m2560_m2561,\n\t\t\tcpu_pagesize_7_bits,\n\t\t\tNULL\n\t\t},\n\t},\n\t{\n\t\t.model = \"ATxmega128a4u\", .pc = 17,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_xmega128a4u,\n\t\t\tcpu_pagesize_7_bits,\n\t\t\tNULL\n\t\t}\n\t},\n\t{ .model = \"ATmega1280\",  .pc = 16, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega1281\",  .pc = 16, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega2560\",  .pc = 17, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega2561\",  .pc = 17, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega88\",    .pc = 8,  .inherit = \"ATmega8\" },\n//\tCPU_MODEL_DECL (\"ATmega168\",   13, 512, 512),\n\t// last model is the default AVR - ATmega8 forever!\n\t{\n\t\t.model = \"ATmega8\", .pc = 13,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_common,\n\t\t\tcpu_pagesize_5_bits,\n\t\t\tNULL\n\t\t}\n\t},\n};\n\nstatic CPU_MODEL *get_cpu_model(char *model);\n\nstatic CPU_MODEL *__get_cpu_model_recursive(char *model) {\n\tCPU_MODEL *cpu = NULL;\n\n\tfor (cpu = cpu_models; cpu < cpu_models + ((sizeof (cpu_models) / sizeof (CPU_MODEL))) - 1; cpu++) {\n\t\tif (!strcasecmp (model, cpu->model)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// fix inheritance tree\n\tif (cpu->inherit && !cpu->inherit_cpu_p) {\n\t\tcpu->inherit_cpu_p = get_cpu_model (cpu->inherit);\n\t\tif (!cpu->inherit_cpu_p) {\n\t\t\teprintf (\"ERROR: Cannot inherit from unknown CPU model '%s'.\\n\", cpu->inherit);\n\t\t}\n\t}\n\n\treturn cpu;\n}\n\nstatic CPU_MODEL *get_cpu_model(char *model) {\n\tstatic CPU_MODEL *cpu = NULL;\n\n\t// cached value?\n\tif (cpu && !strcasecmp (model, cpu->model))\n\t\treturn cpu;\n\n\t// do the real search\n\tcpu = __get_cpu_model_recursive (model);\n\n\treturn cpu;\n}\n\nstatic ut32 const_get_value(CPU_CONST *c) {\n\treturn c ? MASK (c->size * 8) & c->value : 0;\n}\n\n\nstatic CPU_CONST *const_by_name(CPU_MODEL *cpu, int type, char *c) {\n\tCPU_CONST **clist, *citem;\n\n\tfor (clist = cpu->consts; *clist; clist++) {\n\t\tfor (citem = *clist; citem->key; citem++) {\n\t\t\tif (!strcmp (c, citem->key)\n\t\t\t&& (type == CPU_CONST_NONE || type == citem->type)) {\n\t\t\t\treturn citem;\n\t\t\t}\n\t\t}\n\t}\n\tif (cpu->inherit_cpu_p)\n\t\treturn const_by_name (cpu->inherit_cpu_p, type, c);\n\teprintf (\"ERROR: CONSTANT key[%s] NOT FOUND.\\n\", c);\n\treturn NULL;\n}\n\nstatic int __esil_pop_argument(RAnalEsil *esil, ut64 *v) {\n\tchar *t = r_anal_esil_pop (esil);\n\tif (!t || !r_anal_esil_get_parm (esil, t, v)) {\n\t\tfree (t);\n\t\treturn false;\n\t}\n\tfree (t);\n\treturn true;\n}\n\nstatic CPU_CONST *const_by_value(CPU_MODEL *cpu, int type, ut32 v) {\n\tCPU_CONST **clist, *citem;\n\n\tfor (clist = cpu->consts; *clist; clist++) {\n\t\tfor (citem = *clist; citem && citem->key; citem++) {\n\t\t\tif (citem->value == (MASK (citem->size * 8) & v)\n\t\t\t&& (type == CPU_CONST_NONE || type == citem->type)) {\n\t\t\t\treturn citem;\n\t\t\t}\n\t\t}\n\t}\n\tif (cpu->inherit_cpu_p)\n\t\treturn const_by_value (cpu->inherit_cpu_p, type, v);\n\treturn NULL;\n}\n\nstatic RStrBuf *__generic_io_dest(ut8 port, int write, CPU_MODEL *cpu) {\n\tRStrBuf *r = r_strbuf_new (\"\");\n\tCPU_CONST *c = const_by_value (cpu, CPU_CONST_REG, port);\n\tif (c != NULL) {\n\t\tr_strbuf_set (r, c->key);\n\t\tif (write) {\n\t\t\tr_strbuf_append (r, \",=\");\n\t\t}\n\t} else {\n\t\tr_strbuf_setf (r, \"_io,%d,+,%s[1]\", port, write ? \"=\" : \"\");\n\t}\n\n\treturn r;\n}\n\nstatic void __generic_bitop_flags(RAnalOp *op) {\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n}\n\nstatic void __generic_ld_st(RAnalOp *op, char *mem, char ireg, int use_ramp, int prepostdec, int offset, int st) {\n\tif (ireg) {\n\t\t// preincrement index register\n\t\tif (prepostdec < 0) {\n\t\t\tESIL_A (\"1,%c,-,%c,=,\", ireg, ireg);\n\t\t}\n\t\t// set register index address\n\t\tESIL_A (\"%c,\", ireg);\n\t\t// add offset\n\t\tif (offset != 0) {\n\t\t\tESIL_A (\"%d,+,\", offset);\n\t\t}\n\t} else {\n\t\tESIL_A (\"%d,\", offset);\n\t}\n\tif (use_ramp) {\n\t\tESIL_A (\"16,ramp%c,<<,+,\", ireg ? ireg : 'd');\n\t}\n\t// set SRAM base address\n\tESIL_A (\"_%s,+,\", mem);\n\t// read/write from SRAM\n\tESIL_A (\"%s[1],\", st ? \"=\" : \"\");\n\t// postincrement index register\n\tif (ireg && prepostdec > 0) {\n\t\tESIL_A (\"1,%c,+,%c,=,\", ireg, ireg);\n\t}\n}\n\nstatic void __generic_pop(RAnalOp *op, int sz) {\n\tif (sz > 1) {\n\t\tESIL_A (\"1,sp,+,_ram,+,\");\t// calc SRAM(sp+1)\n\t\tESIL_A (\"[%d],\", sz);\t\t// read value\n\t\tESIL_A (\"%d,sp,+=,\", sz);\t// sp += item_size\n\t} else {\n\t\tESIL_A (\"1,sp,+=,\"\t\t// increment stack pointer\n\t\t\t\"sp,_ram,+,[1],\");\t// load SRAM[sp]\n\t}\n}\n\nstatic void __generic_push(RAnalOp *op, int sz) {\n\tESIL_A (\"sp,_ram,+,\");\t\t\t// calc pointer SRAM(sp)\n\tif (sz > 1) {\n\t\tESIL_A (\"-%d,+,\", sz - 1);\t// dec SP by 'sz'\n\t}\n\tESIL_A (\"=[%d],\", sz);\t\t\t// store value in stack\n\tESIL_A (\"-%d,sp,+=,\", sz);\t\t// decrement stack pointer\n}\n\nstatic void __generic_add_update_flags(RAnalOp *op, char t_d, ut64 v_d, char t_rk, ut64 v_rk) {\n\tRStrBuf *d_strbuf, *rk_strbuf;\n\tchar *d, *rk;\n\n\td_strbuf = r_strbuf_new (NULL);\n\trk_strbuf = r_strbuf_new (NULL);\n\tr_strbuf_setf (d_strbuf,  t_d  == 'r' ? \"r%d\" : \"%\" PFMT64d, v_d);\n\tr_strbuf_setf (rk_strbuf, t_rk == 'r' ? \"r%d\" : \"%\" PFMT64d, v_rk);\n\n\td = r_strbuf_get(d_strbuf);\n\trk = r_strbuf_get(rk_strbuf);\n\n\tESIL_A (\"%s,0x08,&,!,!,\" \"%s,0x08,&,!,!,\"    \"&,\"\t// H\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,\" \"&,\"\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,\" \"&,\"\n\t\t\"|,|,hf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,!,\"      \"&,\"\t// V\n\t\t\"\"               \"0,RPICK,0x80,&,!,\"   \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"%s,0x80,&,!,\"        \"&,\"\n\t\t\"\"               \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,vf,=,\",\n\t\td, rk, d, rk);\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,!,\"    \"&,\"\t// C\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,\" \"&,\"\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,\" \"&,\"\n\t\t\"|,|,cf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\n\tr_strbuf_free (d_strbuf);\n\tr_strbuf_free (rk_strbuf);\n}\n\nstatic void __generic_add_update_flags_rr(RAnalOp *op, int d, int r) {\n\t__generic_add_update_flags(op, 'r', d, 'r', r);\n}\n\nstatic void __generic_sub_update_flags(RAnalOp *op, char t_d, ut64 v_d, char t_rk, ut64 v_rk, int carry) {\n\tRStrBuf *d_strbuf, *rk_strbuf;\n\tchar *d, *rk;\n\n\td_strbuf = r_strbuf_new (NULL);\n\trk_strbuf = r_strbuf_new (NULL);\n\tr_strbuf_setf (d_strbuf,  t_d  == 'r' ? \"r%d\" : \"%\" PFMT64d, v_d);\n\tr_strbuf_setf (rk_strbuf, t_rk == 'r' ? \"r%d\" : \"%\" PFMT64d, v_rk);\n\n\td = r_strbuf_get(d_strbuf);\n\trk = r_strbuf_get(rk_strbuf);\n\n\tESIL_A (\"%s,0x08,&,!,\"   \"%s,0x08,&,!,!,\"      \"&,\"\t// H\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,!,\" \"&,\"\n\t\t\"%s,0x08,&,!,\"   \"0,RPICK,0x08,&,!,!,\" \"&,\"\n\t\t\"|,|,hf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,\"        \"&,\"\t// V\n\t\t\"\"               \"0,RPICK,0x80,&,!,\"   \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"%s,0x80,&,!,!,\"      \"&,\"\n\t\t\"\"               \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,vf,=,\",\n\t\td, rk, d, rk);\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tif (carry)\n\t\tESIL_A (\"0,RPICK,!,zf,&,zf,=,\");\t\t// Z\n\telse\n\t\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"%s,0x80,&,!,\"   \"%s,0x80,&,!,!,\"      \"&,\"\t// C\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,|,cf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\n\tr_strbuf_free (d_strbuf);\n\tr_strbuf_free (rk_strbuf);\n}\n\nstatic void __generic_sub_update_flags_rr(RAnalOp *op, int d, int r, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'r', r, carry);\n}\n\nstatic void __generic_sub_update_flags_rk(RAnalOp *op, int d, int k, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'k', k, carry);\n}\n\nINST_HANDLER (adc) {\t// ADC Rd, Rr\n\t\t\t// ROL Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,cf,+,r%d,+,\", r, d);\t\t// Rd + Rr + C\n\t__generic_add_update_flags_rr(op, d, r);\t// FLAGS\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (add) {\t// ADD Rd, Rr\n\t\t\t// LSL Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,+,\", r, d);\t\t\t// Rd + Rr\n\t__generic_add_update_flags_rr(op, d, r);\t// FLAGS\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (adiw) {\t// ADIW Rd+1:Rd, K\n\tint d = ((buf[0] & 0x30) >> 3) + 24;\n\tint k = (buf[0] & 0xf) | ((buf[0] >> 2) & 0x30);\n\top->val = k;\n\tESIL_A (\"r%d:r%d,%d,+,\", d + 1, d, k);\t\t\t// Rd+1:Rd + Rr\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"r%d,0x80,&,!,\"\t\t\t\t\t// V\n\t\t\"0,RPICK,0x8000,&,!,!,\"\n\t\t\"&,vf,=,\", d + 1);\n\tESIL_A (\"0,RPICK,0x8000,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"r%d,0x80,&,!,!,\"\t\t\t\t// C\n\t\t\"0,RPICK,0x8000,&,!,\"\n\t\t\"&,cf,=,\", d + 1);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d:r%d,=,\", d + 1, d);\t\t\t// Rd = result\n}\n\nINST_HANDLER (and) {\t// AND Rd, Rr\n\t\t\t// TST Rd\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,&,\", r, d);\t\t\t\t// 0: Rd & Rr\n\t__generic_bitop_flags (op);\t\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (andi) {\t// ANDI Rd, K\n\t\t\t// CBR Rd, K (= ANDI Rd, 1-K)\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0x0f) << 4) | (buf[0] & 0x0f);\n\top->val = k;\n\tESIL_A (\"%d,r%d,&,\", k, d);\t\t\t\t// 0: Rd & Rr\n\t__generic_bitop_flags (op);\t\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (asr) {\t// ASR Rd\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"1,r%d,>>,r%d,0x80,&,|,\", d, d);\t\t// 0: R=(Rd >> 1) | Rd7\n\tESIL_A (\"r%d,0x1,&,!,!,cf,=,\", d);\t\t\t// C = Rd0\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t\t// V\n\tESIL_A (\"nf,vf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = R\n}\n\nINST_HANDLER (bclr) {\t// BCLR s\n\t\t\t// CLC\n\t\t\t// CLH\n\t\t\t// CLI\n\t\t\t// CLN\n\t\t\t// CLR\n\t\t\t// CLS\n\t\t\t// CLT\n\t\t\t// CLV\n\t\t\t// CLZ\n\tint s = (buf[0] >> 4) & 0x7;\n\tESIL_A (\"0xff,%d,1,<<,^,sreg,&=,\", s);\n}\n\nINST_HANDLER (bld) {\t// BLD Rd, b\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[1] & 0x01) << 4) | ((buf[0] >> 4) & 0xf);\n\tint b = buf[0] & 0x7;\n\tESIL_A (\"r%d,%d,1,<<,0xff,^,&,\", d, b);\t\t\t// Rd/b = 0\n\tESIL_A (\"%d,tf,<<,|,r%d,=,\", b, d);\t\t\t// Rd/b |= T<<b\n}\n\nINST_HANDLER (brbx) {\t// BRBC s, k\n\t\t\t// BRBS s, k\n\t\t\t// BRBC/S 0:\t\tBRCC\t\tBRCS\n\t\t\t//\t\t\tBRSH\t\tBRLO\n\t\t\t// BRBC/S 1:\t\tBREQ\t\tBRNE\n\t\t\t// BRBC/S 2:\t\tBRPL\t\tBRMI\n\t\t\t// BRBC/S 3:\t\tBRVC\t\tBRVS\n\t\t\t// BRBC/S 4:\t\tBRGE\t\tBRLT\n\t\t\t// BRBC/S 5:\t\tBRHC\t\tBRHS\n\t\t\t// BRBC/S 6:\t\tBRTC\t\tBRTS\n\t\t\t// BRBC/S 7:\t\tBRID\t\tBRIE\n\tint s = buf[0] & 0x7;\n\top->jump = op->addr\n\t\t+ ((((buf[1] & 0x03) << 6) | ((buf[0] & 0xf8) >> 2))\n\t\t\t| (buf[1] & 0x2 ? ~((int) 0x7f) : 0))\n\t\t+ 2;\n\top->fail = op->addr + op->size;\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"%d,1,<<,sreg,&,\", s);\t\t\t\t// SREG(s)\n\tESIL_A (buf[1] & 0x4\n\t\t\t? \"!,\"\t\t// BRBC => branch if cleared\n\t\t\t: \"!,!,\");\t// BRBS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (break) {\t// BREAK\n\tESIL_A (\"BREAK\");\n}\n\nINST_HANDLER (bset) {\t// BSET s\n\t\t\t// SEC\n\t\t\t// SEH\n\t\t\t// SEI\n\t\t\t// SEN\n\t\t\t// SER\n\t\t\t// SES\n\t\t\t// SET\n\t\t\t// SEV\n\t\t\t// SEZ\n\tint s = (buf[0] >> 4) & 0x7;\n\tESIL_A (\"%d,1,<<,sreg,|=,\", s);\n}\n\nINST_HANDLER (bst) {\t// BST Rd, b\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tESIL_A (\"r%d,%d,1,<<,&,!,!,tf,=,\",\t\t\t// tf = Rd/b\n\t\t((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf),\t// r\n\t\tbuf[0] & 0x7);\t\t\t\t\t// b\n}\n\nINST_HANDLER (call) {\t// CALL k\n\tif (len < 4) {\n\t\treturn;\n\t}\n\top->jump = (buf[2] << 1)\n\t\t | (buf[3] << 9)\n\t\t | (buf[1] & 0x01) << 23\n\t\t | (buf[0] & 0x01) << 17\n\t\t | (buf[0] & 0xf0) << 14;\n\top->fail = op->addr + op->size;\n\top->cycles = cpu->pc <= 16 ? 3 : 4;\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\top->cycles--;\t// AT*mega optimizes one cycle\n\t}\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n}\n\nINST_HANDLER (cbi) {\t// CBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->family = R_ANAL_OP_FAMILY_IO;\n\top->type2 = 1;\n\top->val = a;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,^,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (com) {\t// COM Rd\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 1) << 4);\n\n\tESIL_A (\"r%d,0xff,-,0xff,&,r%d,=,\", r, r);\t\t// Rd = 0xFF-Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,cf,=,\");\t\t\t\t\t// C\n\t__generic_bitop_flags (op);\t\t\t\t// ...rest...\n}\n\nINST_HANDLER (cp) {\t// CP Rd, Rr\n\tint r = (buf[0]        & 0x0f) | ((buf[1] << 3) & 0x10);\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\tESIL_A (\"r%d,r%d,-,\", r, d);\t\t\t// do Rd - Rr\n\t__generic_sub_update_flags_rr (op, d, r, 0);\t// FLAGS (no carry)\n}\n\nINST_HANDLER (cpc) {\t// CPC Rd, Rr\n\tint r = (buf[0]        & 0x0f) | ((buf[1] << 3) & 0x10);\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\n\tESIL_A (\"cf,r%d,+,r%d,-,\", r, d);\t\t// Rd - Rr - C\n\t__generic_sub_update_flags_rr (op, d, r, 1);\t// FLAGS (carry)\n}\n\nINST_HANDLER (cpi) { // CPI Rd, K\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0xf) | ((buf[1] & 0xf) << 4);\n\tESIL_A (\"%d,r%d,-,\", k, d);\t\t\t// Rd - k\n\t__generic_sub_update_flags_rk (op, d, k, 0);\t// FLAGS (carry)\n}\n\nINST_HANDLER (cpse) {\t// CPSE Rd, Rr\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t// Rr == Rd\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (dec) {\t// DEC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"-1,r%d,+,\", d);\t\t\t\t// --Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,RPICK,0x7f,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (des) {\t// DES k\n\tif (desctx.round < 16) {\t//DES\n\t\top->type = R_ANAL_OP_TYPE_CRYPTO;\n\t\top->cycles = 1;\t\t//redo this\n\t\tr_strbuf_setf (&op->esil, \"%d,des\", desctx.round);\n\t}\n}\n\nINST_HANDLER (eijmp) {\t// EIJMP\n\tut64 z, eind;\n\t// read z and eind for calculating jump address on runtime\n\tr_anal_esil_reg_read (anal->esil, \"z\",    &z,    NULL);\n\tr_anal_esil_reg_read (anal->esil, \"eind\", &eind, NULL);\n\t// real target address may change during execution, so this value will\n\t// be changing all the time\n\top->jump = ((eind << 16) + z) << 1;\n\t// jump\n\tESIL_A (\"1,z,16,eind,<<,+,<<,pc,=,\");\n\t// cycles\n\top->cycles = 2;\n}\n\nINST_HANDLER (eicall) {\t// EICALL\n\t// push pc in stack\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\t// do a standard EIJMP\n\tINST_CALL (eijmp);\n\t// fix cycles\n\top->cycles = !STR_BEGINS (cpu->model, \"ATxmega\") ? 3 : 4;\n}\n\nINST_HANDLER (elpm) {\t// ELPM\n\t\t\t// ELPM Rd\n\t\t\t// ELPM Rd, Z+\n\tint d = ((buf[1] & 0xfe) == 0x90)\n\t\t\t? ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf)\t// Rd\n\t\t\t: 0;\t\t\t\t\t\t// R0\n\tESIL_A (\"16,rampz,<<,z,+,_prog,+,[1],\");\t// read RAMPZ:Z\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = [1]\n\tif ((buf[1] & 0xfe) == 0x90 && (buf[0] & 0xf) == 0x7) {\n\t\tESIL_A (\"16,1,z,+,DUP,z,=,>>,1,&,rampz,+=,\");\t// ++(rampz:z)\n\t}\n}\n\nINST_HANDLER (eor) {\t// EOR Rd, Rr\n\t\t\t// CLR Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,^,\", r, d);\t\t\t// 0: Rd ^ Rr\n\t__generic_bitop_flags (op);\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (fmul) {\t// FMUL Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,r%d,r%d,*,<<,\", r, d);\t\t// 0: (Rd*Rr)<<1\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (fmuls) {\t// FMULS Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,\");\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"*,<<,\", r, d);\t\t\t\t// 0: (Rd*Rr)<<1\n\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (fmulsu) {\t// FMULSU Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,\");\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"r%d\", r);\t\t\t\t// unsigned Rr\n\tESIL_A (\"*,<<,\");\t\t\t\t// 0: (Rd*Rr)<<1\n\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (ijmp) {\t// IJMP k\n\tut64 z;\n\t// read z for calculating jump address on runtime\n\tr_anal_esil_reg_read (anal->esil, \"z\", &z, NULL);\n\t// real target address may change during execution, so this value will\n\t// be changing all the time\n\top->jump = z << 1;\n\top->cycles = 2;\n\tESIL_A (\"1,z,<<,pc,=,\");\t\t// jump!\n}\n\nINST_HANDLER (icall) {\t// ICALL k\n\t// push pc in stack\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\t// do a standard IJMP\n\tINST_CALL (ijmp);\n\t// fix cycles\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (in) {\t// IN Rd, A\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 0x01) << 4);\n\tint a = (buf[0] & 0x0f) | ((buf[1] & 0x6) << 3);\n\tRStrBuf *io_src = __generic_io_dest (a, 0, cpu);\n\top->type2 = 0;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\tESIL_A (\"%s,r%d,=,\", r_strbuf_get (io_src), r);\n\tr_strbuf_free (io_src);\n}\n\nINST_HANDLER (inc) {\t// INC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"1,r%d,+,\", d);\t\t\t\t\t// ++Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,RPICK,0x80,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (jmp) {\t// JMP k\n\top->jump = (buf[2] << 1)\n\t\t | (buf[3] << 9)\n\t\t | (buf[1] & 0x01) << 23\n\t\t | (buf[0] & 0x01) << 17\n\t\t | (buf[0] & 0xf0) << 14;\n\top->cycles = 3;\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n}\n\nINST_HANDLER (lac) {\t// LAC Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,0xff,^,&,\", d);\t\t\t// 0: (Z) & ~Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (las) {\t// LAS Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,|,\", d);\t\t\t\t// 0: (Z) | Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (lat) {\t// LAT Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,^,\", d);\t\t\t\t// 0: (Z) ^ Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (ld) {\t// LD Rd, X\n\t\t\t// LD Rd, X+\n\t\t\t// LD Rd, -X\n\t// read memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\t'x',\t\t\t\t// use index register X\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t(buf[0] & 0xf) == 0xe\n\t\t\t? -1\t\t\t// pre decremented\n\t\t\t: (buf[0] & 0xf) == 0xd\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: 0,\t\t// no increment\n\t\t0,\t\t\t\t// offset always 0\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// cycles\n\top->cycles = (buf[0] & 0x3) == 0\n\t\t\t? 2\t\t\t// LD Rd, X\n\t\t\t: (buf[0] & 0x3) == 1\n\t\t\t\t? 2\t\t// LD Rd, X+\n\t\t\t\t: 3;\t\t// LD Rd, -X\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (ldd) {\t// LD Rd, Y\tLD Rd, Z\n\t\t\t// LD Rd, Y+\tLD Rd, Z+\n\t\t\t// LD Rd, -Y\tLD Rd, -Z\n\t\t\t// LD Rd, Y+q\tLD Rd, Z+q\n\t// calculate offset (this value only has sense in some opcodes,\n\t// but we are optimistic and we calculate it always)\n\tint offset = (buf[1] & 0x20)\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7);\n\t// read memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10) ? offset : 0,\t// offset or not offset\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// cycles\n\top->cycles =\n\t\t(buf[1] & 0x10) == 0\n\t\t\t? (!offset ? 1 : 3)\t\t// LDD\n\t\t\t: (buf[0] & 0x3) == 0\n\t\t\t\t? 1\t\t\t// LD Rd, X\n\t\t\t\t: (buf[0] & 0x3) == 1\n\t\t\t\t\t? 2\t\t// LD Rd, X+\n\t\t\t\t\t: 3;\t\t// LD Rd, -X\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (ldi) {\t// LDI Rd, K\n\tint k = (buf[0] & 0xf) + ((buf[1] & 0xf) << 4);\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\top->val = k;\n\tESIL_A (\"0x%x,r%d,=,\", k, d);\n}\n\nINST_HANDLER (lds) {\t// LDS Rd, k\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t// load value from RAMPD:k\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n\nINST_HANDLER (sts) {\t// STS k, Rr\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\n\top->cycles = 2;\n}\n\n#if 0\nINST_HANDLER (lds16) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0x0f)\n\t\t| ((buf[1] << 3) & 0x30)\n\t\t| ((buf[1] << 4) & 0x40)\n\t\t| (~(buf[1] << 4) & 0x80);\n\top->ptr = k;\n\n\t// load value from @k\n\t__generic_ld_st (op, \"ram\", 0, 0, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n#endif\n\nINST_HANDLER (lpm) {\t// LPM\n\t\t\t// LPM Rd, Z\n\t\t\t// LPM Rd, Z+\n\tut16 ins = (((ut16) buf[1]) << 8) | ((ut16) buf[0]);\n\t// read program memory\n\t__generic_ld_st (\n\t\top, \"prog\",\n\t\t'z',\t\t\t\t// index register Y/Z\n\t\t1,\t\t\t\t// use RAMP* registers\n\t\t(ins & 0xfe0f) == 0x9005\n\t\t\t? 1\t\t\t// post incremented\n\t\t\t: 0,\t\t\t// no increment\n\t\t0,\t\t\t\t// not offset\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\",\n\t\t(ins == 0x95c8)\n\t\t\t? 0\t\t\t// LPM (r0)\n\t\t\t: ((buf[0] >> 4) & 0xf)\t// LPM Rd\n\t\t\t\t| ((buf[1] & 0x1) << 4));\n}\n\nINST_HANDLER (lsr) {\t// LSR Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"1,r%d,>>,\", d);\t\t\t\t// 0: R=(Rd >> 1)\n\tESIL_A (\"r%d,0x1,&,!,!,cf,=,\", d);\t\t\t// C = Rd0\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,nf,=,\");\t\t\t\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t\t// V\n\tESIL_A (\"nf,vf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = R\n}\n\nINST_HANDLER (mov) {\t// MOV Rd, Rr\n\tint d = ((buf[1] << 4) & 0x10) | ((buf[0] >> 4) & 0x0f);\n\tint r = ((buf[1] << 3) & 0x10) | (buf[0] & 0x0f);\n\tESIL_A (\"r%d,r%d,=,\", r, d);\n}\n\nINST_HANDLER (movw) {\t// MOVW Rd+1:Rd, Rr+1:Rr\n\tint d = (buf[0] & 0xf0) >> 3;\n\tint r = (buf[0] & 0x0f) << 1;\n\tESIL_A (\"r%d,r%d,=,r%d,r%d,=,\", r, d, r + 1, d + 1);\n}\n\nINST_HANDLER (mul) {\t// MUL Rd, Rr\n\tint d = ((buf[1] << 4) & 0x10) | ((buf[0] >> 4) & 0x0f);\n\tint r = ((buf[1] << 3) & 0x10) | (buf[0] & 0x0f);\n\n\tESIL_A (\"r%d,r%d,*,\", r, d);\t\t\t// 0: (Rd*Rr)<<1\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (muls) {\t// MULS Rd, Rr\n\tint d = (buf[0] >> 4 & 0x0f) + 16;\n\tint r = (buf[0] & 0x0f) + 16;\n\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (mulsu) {\t// MULSU Rd, Rr\n\tint d = (buf[0] >> 4 & 0x07) + 16;\n\tint r = (buf[0] & 0x07) + 16;\n\n\tESIL_A (\"r%d,\", r);\t\t\t\t// unsigned Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (neg) {\t// NEG Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"r%d,0x00,-,0xff,&,\", d);\t\t\t// 0: (0-Rd)\n\tESIL_A (\"DUP,r%d,0xff,^,|,0x08,&,!,!,hf,=,\", d);\t// H\n\tESIL_A (\"DUP,0x80,-,!,vf,=,\", d);\t\t\t// V\n\tESIL_A (\"DUP,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t\t// Z\n\tESIL_A (\"DUP,!,!,cf,=,\");\t\t\t\t// C\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (nop) {\t// NOP\n\tESIL_A (\",,\");\n}\n\nINST_HANDLER (or) {\t// OR Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,|,\", r, d);\t\t\t\t// 0: (Rd | Rr)\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"nf,sf,=,\");\t\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (ori) {\t// ORI Rd, K\n\t\t\t// SBR Rd, K\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0xf) | ((buf[1] & 0xf) << 4);\n\top->val = k;\n\tESIL_A (\"r%d,%d,|,\", d, k);\t\t\t\t// 0: (Rd | k)\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"nf,sf,=,\");\t\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (out) {\t// OUT A, Rr\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 0x01) << 4);\n\tint a = (buf[0] & 0x0f) | ((buf[1] & 0x6) << 3);\n\tRStrBuf *io_dst = __generic_io_dest (a, 1, cpu);\n\top->type2 = 1;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\tESIL_A (\"r%d,%s,\", r, r_strbuf_get (io_dst));\n\tr_strbuf_free (io_dst);\n}\n\nINST_HANDLER (pop) {\t// POP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\t__generic_pop (op, 1);\n\tESIL_A (\"r%d,=,\", d);\t// store in Rd\n\n}\n\nINST_HANDLER (push) {\t// PUSH Rr\n\tint r = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\tESIL_A (\"r%d,\", r);\t// load Rr\n\t__generic_push (op, 1);\t// push it into stack\n\t// cycles\n\top->cycles = !STR_BEGINS (cpu->model, \"ATxmega\")\n\t\t\t? 1\t// AT*mega optimizes one cycle\n\t\t\t: 2;\n}\n\nINST_HANDLER (rcall) {\t// RCALL k\n\t// target address\n\top->jump = (op->addr\n\t\t+ (((((buf[1] & 0xf) << 8) | buf[0]) << 1)\n\t\t\t| (((buf[1] & 0x8) ? ~((int) 0x1fff) : 0)))\n\t\t+ 2) & CPU_PC_MASK (cpu);\n\top->fail = op->addr + op->size;\n\t// esil\n\tESIL_A (\"pc,\");\t\t\t\t// esil already points to next\n\t\t\t\t\t\t// instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret addr\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n\t// cycles\n\tif (!strncasecmp (cpu->model, \"ATtiny\", 6)) {\n\t\top->cycles = 4;\t// ATtiny is always slow\n\t} else {\n\t\t// PC size decides required runtime!\n\t\top->cycles = cpu->pc <= 16 ? 3 : 4;\n\t\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\t\top->cycles--;\t// ATxmega optimizes one cycle\n\t\t}\n\t}\n}\n\nINST_HANDLER (ret) {\t// RET\n\top->eob = true;\n\t// esil\n\t__generic_pop (op, CPU_PC_SIZE (cpu));\n\tESIL_A (\"pc,=,\");\t// jump!\n\t// cycles\n\tif (CPU_PC_SIZE (cpu) > 2) {\t// if we have a bus bigger than 16 bit\n\t\top->cycles++;\t// (i.e. a 22-bit bus), add one extra cycle\n\t}\n}\n\nINST_HANDLER (reti) {\t// RETI\n\t//XXX: There are not privileged instructions in ATMEL/AVR\n\top->family = R_ANAL_OP_FAMILY_PRIV;\n\n\t// first perform a standard 'ret'\n\tINST_CALL (ret);\n\n\t// RETI: The I-bit is cleared by hardware after an interrupt\n\t// has occurred, and is set by the RETI instruction to enable\n\t// subsequent interrupts\n\tESIL_A (\"1,if,=,\");\n}\n\nINST_HANDLER (rjmp) {\t// RJMP k\n\top->jump = (op->addr\n#ifdef _MSC_VER\n#pragma message (\"anal_avr.c: WARNING: Probably broken on windows\")\n\t\t+ ((((( buf[1] & 0xf) << 9) | (buf[0] << 1)))\n\t\t\t| (buf[1] & 0x8 ? ~(0x1fff) : 0))\n#else\n\t\t+ ((((( (typeof (op->jump)) buf[1] & 0xf) << 9) | ((typeof (op->jump)) buf[0] << 1)))\n\t\t\t| (buf[1] & 0x8 ? ~((typeof (op->jump)) 0x1fff) : 0))\n#endif\n\t\t+ 2) & CPU_PC_MASK (cpu);\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\n}\n\nINST_HANDLER (ror) {\t// ROR Rd\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\tESIL_A (\"1,r%d,>>,7,cf,<<,|,\", d);\t\t// 0: (Rd>>1) | (cf<<7)\n\tESIL_A (\"r%d,1,&,cf,=,\", d);\t\t\t// C\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t// V\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (sbc) {\t// SBC Rd, Rr\n\tint r = (buf[0] & 0x0f) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\tESIL_A (\"cf,r%d,+,r%d,-,\", r, d);\t\t// 0: (Rd-Rr-C)\n\t__generic_sub_update_flags_rr (op, d, r, 1);\t// FLAGS (carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sbci) {\t// SBCI Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0xf) << 4) | (buf[0] & 0xf);\n\top->val = k;\n\n\tESIL_A (\"cf,%d,+,r%d,-,\", k, d);\t\t// 0: (Rd-k-C)\n\t__generic_sub_update_flags_rk (op, d, k, 1);\t// FLAGS (carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sub) {\t// SUB Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\n\tESIL_A (\"r%d,r%d,-,\", r, d);\t\t\t// 0: (Rd-k)\n\t__generic_sub_update_flags_rr (op, d, r, 0);\t// FLAGS (no carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (subi) {\t// SUBI Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0xf) << 4) | (buf[0] & 0xf);\n\top->val = k;\n\n\tESIL_A (\"%d,r%d,-,\", k, d);\t\t\t// 0: (Rd-k)\n\t__generic_sub_update_flags_rk (op, d, k, 1);\t// FLAGS (no carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sbi) {\t// SBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->type2 = 1;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,|,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (sbix) {\t// SBIC A, b\n\t\t\t// SBIS A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRAnalOp next_op;\n\tRStrBuf *io_port;\n\n\top->type2 = 0;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size,\n\t\t\tlen - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to false, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"%d,1,<<,%s,&,\", b, io_port);\t\t// IO(A,b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\t\t// SBIC => branch if 0\n\t\t\t: \"!,!,\");\t\t\t// SBIS => branch if 1\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (sbiw) {\t// SBIW Rd+1:Rd, K\n\tint d = ((buf[0] & 0x30) >> 3) + 24;\n\tint k = (buf[0] & 0xf) | ((buf[0] >> 2) & 0x30);\n\top->val = k;\n\tESIL_A (\"%d,r%d:r%d,-,\", k, d + 1, d);\t\t// 0(Rd+1:Rd - Rr)\n\tESIL_A (\"r%d,0x80,&,!,!,\"\t\t\t// V\n\t\t\"0,RPICK,0x8000,&,!,\"\n\t\t\"&,vf,=,\", d + 1);\n\tESIL_A (\"0,RPICK,0x8000,&,!,!,nf,=,\");\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"r%d,0x80,&,!,\"\t\t\t\t// C\n\t\t\"0,RPICK,0x8000,&,!,!,\"\n\t\t\"&,cf,=,\", d + 1);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t// S\n\tESIL_A (\"r%d:r%d,=,\", d + 1, d);\t\t// Rd = result\n}\n\nINST_HANDLER (sbrx) {\t// SBRC Rr, b\n\t\t\t// SBRS Rr, b\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op = {0};\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to false, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t// Rr(b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t// SBRC => branch if cleared\n\t\t\t: \"!,!,\");\t// SBRS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (sleep) {\t// SLEEP\n\tESIL_A (\"BREAK\");\n}\n\nINST_HANDLER (spm) {\t// SPM Z+\n\tut64 spmcsr;\n\n\t// read SPM Control Register (SPMCR)\n\tr_anal_esil_reg_read (anal->esil, \"spmcsr\", &spmcsr, NULL);\n\n\t// clear SPMCSR\n\tESIL_A (\"0x7c,spmcsr,&=,\");\n\n\t// decide action depending on the old value of SPMCSR\n\tswitch (spmcsr & 0x7f) {\n\t\tcase 0x03: // PAGE ERASE\n\t\t\t// invoke SPM_CLEAR_PAGE (erases target page writing\n\t\t\t// the 0xff value\n\t\t\tESIL_A (\"16,rampz,<<,z,+,\"); // push target address\n\t\t\tESIL_A (\"SPM_PAGE_ERASE,\");  // do magic\n\t\t\tbreak;\n\n\t\tcase 0x01: // FILL TEMPORARY BUFFER\n\t\t\tESIL_A (\"r1,r0,\");           // push data\n\t\t\tESIL_A (\"z,\");               // push target address\n\t\t\tESIL_A (\"SPM_PAGE_FILL,\");   // do magic\n\t\t\tbreak;\n\n\t\tcase 0x05: // WRITE PAGE\n\t\t\tESIL_A (\"16,rampz,<<,z,+,\"); // push target address\n\t\t\tESIL_A (\"SPM_PAGE_WRITE,\");  // do magic\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\teprintf (\"SPM: I dont know what to do with SPMCSR %02x.\\n\",\n\t\t\t\t\t(unsigned int) spmcsr);\n\t}\n\n\top->cycles = 1;\t// This is truly false. Datasheets do not publish how\n\t\t\t// many cycles this instruction uses in all its\n\t\t\t// operation modes and I am pretty sure that this value\n\t\t\t// can vary substantially from one MCU type to another.\n\t\t\t// So... one cycle is fine.\n}\n\nINST_HANDLER (st) {\t// ST X, Rr\n\t\t\t// ST X+, Rr\n\t\t\t// ST -X, Rr\n\t// load register\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// write in memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\t'x',\t\t\t\t// use index register X\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t(buf[0] & 0xf) == 0xe\n\t\t\t? -1\t\t\t// pre decremented\n\t\t\t: (buf[0] & 0xf) == 0xd\n\t\t\t\t? 1\t\t// post increment\n\t\t\t\t: 0,\t\t// no increment\n\t\t0,\t\t\t\t// offset always 0\n\t\t1);\t\t\t\t// store operation (st)\n//\t// cycles\n//\top->cycles = buf[0] & 0x3 == 0\n//\t\t\t? 2\t\t\t// LD Rd, X\n//\t\t\t: buf[0] & 0x3 == 1\n//\t\t\t\t? 2\t\t// LD Rd, X+\n//\t\t\t\t: 3;\t\t// LD Rd, -X\n//\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n//\t\t// AT*mega optimizes 1 cycle!\n//\t\top->cycles--;\n//\t}\n}\n\nINST_HANDLER (std) {\t// ST Y, Rr\tST Z, Rr\n\t\t\t// ST Y+, Rr\tST Z+, Rr\n\t\t\t// ST -Y, Rr\tST -Z, Rr\n\t\t\t// ST Y+q, Rr\tST Z+q, Rr\n\t// load register\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// write in memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10)\n\t\t\t? (buf[1] & 0x20)\t// offset\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7)\n\t\t\t: 0,\t\t\t// no offset\n\t\t1);\t\t\t\t// load operation (!st)\n//\t// cycles\n//\top->cycles =\n//\t\tbuf[1] & 0x1 == 0\n//\t\t\t? !(offset ? 1 : 3)\t\t// LDD\n//\t\t\t: buf[0] & 0x3 == 0\n//\t\t\t\t? 1\t\t\t// LD Rd, X\n//\t\t\t\t: buf[0] & 0x3 == 1\n//\t\t\t\t\t? 2\t\t// LD Rd, X+\n//\t\t\t\t\t: 3;\t\t// LD Rd, -X\n//\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n//\t\t// AT*mega optimizes 1 cycle!\n//\t\top->cycles--;\n//\t}\n}\n\nINST_HANDLER (swap) {\t// SWAP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\tESIL_A (\"4,r%d,>>,0x0f,&,\", d);\t\t// (Rd >> 4) & 0xf\n\tESIL_A (\"4,r%d,<<,0xf0,&,\", d);\t\t// (Rd >> 4) & 0xf\n\tESIL_A (\"|,\", d);\t\t\t// S[0] | S[1]\n\tESIL_A (\"r%d,=,\", d);\t\t\t// Rd = result\n}\n\nOPCODE_DESC opcodes[] = {\n\t//         op      mask    select  cycles  size type\n\tINST_DECL (break,  0xffff, 0x9698, 1,      2,   TRAP   ), // BREAK\n\tINST_DECL (eicall, 0xffff, 0x9519, 0,      2,   UCALL  ), // EICALL\n\tINST_DECL (eijmp,  0xffff, 0x9419, 0,      2,   UJMP   ), // EIJMP\n\tINST_DECL (icall,  0xffff, 0x9509, 0,      2,   UCALL  ), // ICALL\n\tINST_DECL (ijmp,   0xffff, 0x9409, 0,      2,   UJMP   ), // IJMP\n\tINST_DECL (lpm,    0xffff, 0x95c8, 3,      2,   LOAD   ), // LPM\n\tINST_DECL (nop,    0xffff, 0x0000, 1,      2,   NOP    ), // NOP\n\tINST_DECL (ret,    0xffff, 0x9508, 4,      2,   RET    ), // RET\n\tINST_DECL (reti,   0xffff, 0x9518, 4,      2,   RET    ), // RETI\n\tINST_DECL (sleep,  0xffff, 0x9588, 1,      2,   NOP    ), // SLEEP\n\tINST_DECL (spm,    0xffff, 0x95e8, 1,      2,   TRAP   ), // SPM ...\n\tINST_DECL (bclr,   0xff8f, 0x9488, 1,      2,   SWI    ), // BCLR s\n\tINST_DECL (bset,   0xff8f, 0x9408, 1,      2,   SWI    ), // BSET s\n\tINST_DECL (fmul,   0xff88, 0x0308, 2,      2,   MUL    ), // FMUL Rd, Rr\n\tINST_DECL (fmuls,  0xff88, 0x0380, 2,      2,   MUL    ), // FMULS Rd, Rr\n\tINST_DECL (fmulsu, 0xff88, 0x0388, 2,      2,   MUL    ), // FMULSU Rd, Rr\n\tINST_DECL (mulsu,  0xff88, 0x0300, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (des,    0xff0f, 0x940b, 0,      2,   CRYPTO ), // DES k\n\tINST_DECL (adiw,   0xff00, 0x9600, 2,      2,   ADD    ), // ADIW Rd+1:Rd, K\n\tINST_DECL (sbiw,   0xff00, 0x9700, 2,      2,   SUB    ), // SBIW Rd+1:Rd, K\n\tINST_DECL (cbi,    0xff00, 0x9800, 1,      2,   IO     ), // CBI A, K\n\tINST_DECL (sbi,    0xff00, 0x9a00, 1,      2,   IO     ), // SBI A, K\n\tINST_DECL (movw,   0xff00, 0x0100, 1,      2,   MOV    ), // MOVW Rd+1:Rd, Rr+1:Rr\n\tINST_DECL (muls,   0xff00, 0x0200, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (asr,    0xfe0f, 0x9405, 1,      2,   SAR    ), // ASR Rd\n\tINST_DECL (com,    0xfe0f, 0x9400, 1,      2,   SWI    ), // BLD Rd, b\n\tINST_DECL (dec,    0xfe0f, 0x940a, 1,      2,   SUB    ), // DEC Rd\n\tINST_DECL (elpm,   0xfe0f, 0x9006, 0,      2,   LOAD   ), // ELPM Rd, Z\n\tINST_DECL (elpm,   0xfe0f, 0x9007, 0,      2,   LOAD   ), // ELPM Rd, Z+\n\tINST_DECL (inc,    0xfe0f, 0x9403, 1,      2,   ADD    ), // INC Rd\n\tINST_DECL (lac,    0xfe0f, 0x9206, 2,      2,   LOAD   ), // LAC Z, Rd\n\tINST_DECL (las,    0xfe0f, 0x9205, 2,      2,   LOAD   ), // LAS Z, Rd\n\tINST_DECL (lat,    0xfe0f, 0x9207, 2,      2,   LOAD   ), // LAT Z, Rd\n\tINST_DECL (ld,     0xfe0f, 0x900c, 0,      2,   LOAD   ), // LD Rd, X\n\tINST_DECL (ld,     0xfe0f, 0x900d, 0,      2,   LOAD   ), // LD Rd, X+\n\tINST_DECL (ld,     0xfe0f, 0x900e, 0,      2,   LOAD   ), // LD Rd, -X\n\tINST_DECL (lds,    0xfe0f, 0x9000, 0,      4,   LOAD   ), // LDS Rd, k\n\tINST_DECL (sts,    0xfe0f, 0x9200, 2,      4,   STORE  ), // STS k, Rr\n\tINST_DECL (lpm,    0xfe0f, 0x9004, 3,      2,   LOAD   ), // LPM Rd, Z\n\tINST_DECL (lpm,    0xfe0f, 0x9005, 3,      2,   LOAD   ), // LPM Rd, Z+\n\tINST_DECL (lsr,    0xfe0f, 0x9406, 1,      2,   SHR    ), // LSR Rd\n\tINST_DECL (neg,    0xfe0f, 0x9401, 2,      2,   SUB    ), // NEG Rd\n\tINST_DECL (pop,    0xfe0f, 0x900f, 2,      2,   POP    ), // POP Rd\n\tINST_DECL (push,   0xfe0f, 0x920f, 0,      2,   PUSH   ), // PUSH Rr\n\tINST_DECL (ror,    0xfe0f, 0x9407, 1,      2,   SAR    ), // ROR Rd\n\tINST_DECL (st,     0xfe0f, 0x920c, 2,      2,   STORE  ), // ST X, Rr\n\tINST_DECL (st,     0xfe0f, 0x920d, 0,      2,   STORE  ), // ST X+, Rr\n\tINST_DECL (st,     0xfe0f, 0x920e, 0,      2,   STORE  ), // ST -X, Rr\n\tINST_DECL (swap,   0xfe0f, 0x9402, 1,      2,   SAR    ), // SWAP Rd\n\tINST_DECL (call,   0xfe0e, 0x940e, 0,      4,   CALL   ), // CALL k\n\tINST_DECL (jmp,    0xfe0e, 0x940c, 2,      4,   JMP    ), // JMP k\n\tINST_DECL (bld,    0xfe08, 0xf800, 1,      2,   SWI    ), // BLD Rd, b\n\tINST_DECL (bst,    0xfe08, 0xfa00, 1,      2,   SWI    ), // BST Rd, b\n\tINST_DECL (sbix,   0xfe08, 0x9900, 2,      2,   CJMP   ), // SBIC A, b\n\tINST_DECL (sbix,   0xfe08, 0x9900, 2,      2,   CJMP   ), // SBIS A, b\n\tINST_DECL (sbrx,   0xfe08, 0xfc00, 2,      2,   CJMP   ), // SBRC Rr, b\n\tINST_DECL (sbrx,   0xfe08, 0xfe00, 2,      2,   CJMP   ), // SBRS Rr, b\n\tINST_DECL (ldd,    0xfe07, 0x9001, 0,      2,   LOAD   ), // LD Rd, Y/Z+\n\tINST_DECL (ldd,    0xfe07, 0x9002, 0,      2,   LOAD   ), // LD Rd, -Y/Z\n\tINST_DECL (std,    0xfe07, 0x9201, 0,      2,   STORE  ), // ST Y/Z+, Rr\n\tINST_DECL (std,    0xfe07, 0x9202, 0,      2,   STORE  ), // ST -Y/Z, Rr\n\tINST_DECL (adc,    0xfc00, 0x1c00, 1,      2,   ADD    ), // ADC Rd, Rr\n\tINST_DECL (add,    0xfc00, 0x0c00, 1,      2,   ADD    ), // ADD Rd, Rr\n\tINST_DECL (and,    0xfc00, 0x2000, 1,      2,   AND    ), // AND Rd, Rr\n\tINST_DECL (brbx,   0xfc00, 0xf000, 0,      2,   CJMP   ), // BRBS s, k\n\tINST_DECL (brbx,   0xfc00, 0xf400, 0,      2,   CJMP   ), // BRBC s, k\n\tINST_DECL (cp,     0xfc00, 0x1400, 1,      2,   CMP    ), // CP Rd, Rr\n\tINST_DECL (cpc,    0xfc00, 0x0400, 1,      2,   CMP    ), // CPC Rd, Rr\n\tINST_DECL (cpse,   0xfc00, 0x1000, 0,      2,   CJMP   ), // CPSE Rd, Rr\n\tINST_DECL (eor,    0xfc00, 0x2400, 1,      2,   XOR    ), // EOR Rd, Rr\n\tINST_DECL (mov,    0xfc00, 0x2c00, 1,      2,   MOV    ), // MOV Rd, Rr\n\tINST_DECL (mul,    0xfc00, 0x9c00, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (or,     0xfc00, 0x2800, 1,      2,   OR     ), // OR Rd, Rr\n\tINST_DECL (sbc,    0xfc00, 0x0800, 1,      2,   SUB    ), // SBC Rd, Rr\n\tINST_DECL (sub,    0xfc00, 0x1800, 1,      2,   SUB    ), // SUB Rd, Rr\n\tINST_DECL (in,     0xf800, 0xb000, 1,      2,   IO     ), // IN Rd, A\n\t//INST_DECL (lds16,  0xf800, 0xa000, 1,      2,   LOAD   ), // LDS Rd, k\n\tINST_DECL (out,    0xf800, 0xb800, 1,      2,   IO     ), // OUT A, Rr\n\tINST_DECL (andi,   0xf000, 0x7000, 1,      2,   AND    ), // ANDI Rd, K\n\tINST_DECL (cpi,    0xf000, 0x3000, 1,      2,   CMP    ), // CPI Rd, K\n\tINST_DECL (ldi,    0xf000, 0xe000, 1,      2,   LOAD   ), // LDI Rd, K\n\tINST_DECL (ori,    0xf000, 0x6000, 1,      2,   OR     ), // ORI Rd, K\n\tINST_DECL (rcall,  0xf000, 0xd000, 0,      2,   CALL   ), // RCALL k\n\tINST_DECL (rjmp,   0xf000, 0xc000, 2,      2,   JMP    ), // RJMP k\n\tINST_DECL (sbci,   0xf000, 0x4000, 1,      2,   SUB    ), // SBC Rd, Rr\n\tINST_DECL (subi,   0xf000, 0x5000, 1,      2,   SUB    ), // SUBI Rd, Rr\n\tINST_DECL (ldd,    0xd200, 0x8000, 0,      2,   LOAD   ), // LD Rd, Y/Z+q\n\tINST_DECL (std,    0xd200, 0x8200, 0,      2,   STORE  ), // ST Y/Z+q, Rr\n\n\tINST_LAST\n};\n\nstatic OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tif (len < 2) {\n\t\treturn NULL;\n\t}\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\n\t// initialize op struct\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\n\t// process opcode\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\n\t\t\t// copy default cycles/size values\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\t// op->fail = addr + op->size;\n\t\t\top->addr = addr;\n\n\t\t\t// start void esil expression\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\n\t\t\t// handle opcode\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\t// eprintf (\"opcode %s @%\"PFMT64x\" returned 0 cycles.\\n\", opcode_desc->name, op->addr);\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\n\t\t\t// remove trailing coma (COMETE LA COMA)\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\n\t// ignore reserved opcodes (if they have not been caught by the previous loop)\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\n\nINVALID_OP:\n\t// An unknown or invalid option has appeared.\n\t//  -- Throw pokeball!\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\t// launch esil trap (for communicating upper layers about this weird\n\t// and stinky situation\n\tr_strbuf_set (&op->esil, \"1,$\");\n\n\treturn NULL;\n}\n\nstatic int avr_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len) {\n\tCPU_MODEL *cpu;\n\tut64 offset;\n\n\t// init op\n\tif (!op) {\n\t\treturn 2;\n\t}\n\n\t// select cpu info\n\tcpu = get_cpu_model (anal->cpu);\n\n\t// set memory layout registers\n\tif (anal->esil) {\n\t\toffset = 0;\n\t\tr_anal_esil_reg_write (anal->esil, \"_prog\", offset);\n\n\t\toffset += (1 << cpu->pc);\n\t\tr_anal_esil_reg_write (anal->esil, \"_io\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"sram_start\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_sram\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"sram_size\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_eeprom\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"eeprom_size\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_page\", offset);\n\t}\n\t// process opcode\n\tavr_op_analyze (anal, op, addr, buf, len, cpu);\n\n\treturn op->size;\n}\n\nstatic int avr_custom_des (RAnalEsil *esil) {\n\tut64 key, encrypt, text,des_round;\n\tut32 key_lo, key_hi, buf_lo, buf_hi;\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\tif (!__esil_pop_argument (esil, &des_round)) {\n\t\treturn false;\n\t}\n\tr_anal_esil_reg_read (esil, \"hf\", &encrypt, NULL);\n\tr_anal_esil_reg_read (esil, \"deskey\", &key, NULL);\n\tr_anal_esil_reg_read (esil, \"text\", &text, NULL);\n\n\tkey_lo = key & UT32_MAX;\n\tkey_hi = key >> 32;\n\tbuf_lo = text & UT32_MAX;\n\tbuf_hi = text >> 32;\n\n\tif (des_round != desctx.round) {\n\t\tdesctx.round = des_round;\n\t}\n\n\tif (!desctx.round) {\n\t\tint i;\n\t\t//generating all round keys\n\t\tr_des_permute_key (&key_lo, &key_hi);\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tr_des_round_key (i, &desctx.round_key_lo[i], &desctx.round_key_hi[i], &key_lo, &key_hi);\n\t\t}\n\t\tr_des_permute_block0 (&buf_lo, &buf_hi);\n\t}\n\n\tif (encrypt) {\n\t\tr_des_round (&buf_lo, &buf_hi, &desctx.round_key_lo[desctx.round], &desctx.round_key_hi[desctx.round]);\n\t} else {\n\t\tr_des_round (&buf_lo, &buf_hi, &desctx.round_key_lo[15 - desctx.round], &desctx.round_key_hi[15 - desctx.round]);\n\t}\n\n\tif (desctx.round == 15) {\n\t\tr_des_permute_block1 (&buf_hi, &buf_lo);\n\t\tdesctx.round = 0;\n\t} else {\n\t\tdesctx.round++;\n\t}\n\n\tr_anal_esil_reg_write (esil, \"text\", text);\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_ERASE\nstatic int avr_custom_spm_page_erase(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tut8 c;\n\tut64 addr, page_size_bits, i;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address\n\tif (!__esil_pop_argument(esil, &addr)) {\n\t\treturn false;\n\t}\n\n\t// get details about current MCU and fix input address\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\n\t// align base address to page_size_bits\n\taddr &= ~(MASK (page_size_bits));\n\n\t// perform erase\n\t//eprintf (\"SPM_PAGE_ERASE %ld bytes @ 0x%08\" PFMT64x \".\\n\", page_size, addr);\n\tc = 0xff;\n\tfor (i = 0; i < (1ULL << page_size_bits); i++) {\n\t\tr_anal_esil_mem_write (\n\t\t\tesil, (addr + i) & CPU_PC_MASK (cpu), &c, 1);\n\t}\n\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_FILL\nstatic int avr_custom_spm_page_fill(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tut64 addr, page_size_bits, i;\n\tut8 r0, r1;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address, r0, r1\n\tif (!__esil_pop_argument(esil, &addr)) {\n\t\treturn false;\n\t}\n\n\tif (!__esil_pop_argument (esil, &i)) {\n\t\treturn false;\n\t}\n\tr0 = i;\n\n\tif (!__esil_pop_argument (esil, &i)) {\n\t\treturn false;\n\t}\n\tr1 = i;\n\n\t// get details about current MCU and fix input address\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\n\t// align and crop base address\n\taddr &= (MASK (page_size_bits) ^ 1);\n\n\t// perform write to temporary page\n\t//eprintf (\"SPM_PAGE_FILL bytes (%02x, %02x) @ 0x%08\" PFMT64x \".\\n\", r1, r0, addr);\n\tr_anal_esil_mem_write (esil, addr++, &r0, 1);\n\tr_anal_esil_mem_write (esil, addr++, &r1, 1);\n\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_WRITE\nstatic int avr_custom_spm_page_write(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tchar *t = NULL;\n\tut64 addr, page_size_bits, tmp_page;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address\n\tif (!__esil_pop_argument (esil, &addr)) {\n\t\treturn false;\n\t}\n\n\t// get details about current MCU and fix input address and base address\n\t// of the internal temporary page\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\tr_anal_esil_reg_read (esil, \"_page\", &tmp_page, NULL);\n\n\t// align base address to page_size_bits\n\taddr &= (~(MASK (page_size_bits)) & CPU_PC_MASK (cpu));\n\n\t// perform writing\n\t//eprintf (\"SPM_PAGE_WRITE %ld bytes @ 0x%08\" PFMT64x \".\\n\", page_size, addr);\n\tif (!(t = malloc (1 << page_size_bits))) {\n\t\teprintf (\"Cannot alloc a buffer for copying the temporary page.\\n\");\n\t\treturn false;\n\t}\n\tr_anal_esil_mem_read (esil, tmp_page, (ut8 *) t, 1 << page_size_bits);\n\tr_anal_esil_mem_write (esil, addr, (ut8 *) t, 1 << page_size_bits);\n\n\treturn true;\n}\n\nstatic int esil_avr_hook_reg_write(RAnalEsil *esil, const char *name, ut64 *val) {\n\tCPU_MODEL *cpu;\n\n\tif (!esil || !esil->anal) {\n\t\treturn 0;\n\t}\n\n\t// select cpu info\n\tcpu = get_cpu_model (esil->anal->cpu);\n\n\t// crop registers and force certain values\n\tif (!strcmp (name, \"pc\")) {\n\t\t*val &= CPU_PC_MASK (cpu);\n\t} else if (!strcmp (name, \"pcl\")) {\n\t\tif (cpu->pc < 8) {\n\t\t\t*val &= MASK (8);\n\t\t}\n\t} else if (!strcmp (name, \"pch\")) {\n\t\t*val = cpu->pc > 8\n\t\t\t? *val & MASK (cpu->pc - 8)\n\t\t\t: 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int esil_avr_init(RAnalEsil *esil) {\n\tif (!esil) {\n\t\treturn false;\n\t}\n\tdesctx.round = 0;\n\tr_anal_esil_set_op (esil, \"des\", avr_custom_des);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_ERASE\", avr_custom_spm_page_erase);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_FILL\", avr_custom_spm_page_fill);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_WRITE\", avr_custom_spm_page_write);\n\tesil->cb.hook_reg_write = esil_avr_hook_reg_write;\n\n\treturn true;\n}\n\nstatic int esil_avr_fini(RAnalEsil *esil) {\n\treturn true;\n}\n\nstatic int set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpcl\\n\"\n\t\t\"=SP\tsp\\n\"\n// explained in http://www.nongnu.org/avr-libc/user-manual/FAQ.html\n// and http://www.avrfreaks.net/forum/function-calling-convention-gcc-generated-assembly-file\n\t\t\"=A0\tr25\\n\"\n\t\t\"=A1\tr24\\n\"\n\t\t\"=A2\tr23\\n\"\n\t\t\"=A3\tr22\\n\"\n\t\t\"=R0\tr24\\n\"\n#if 0\nPC: 16- or 22-bit program counter\nSP: 8- or 16-bit stack pointer\nSREG: 8-bit status register\nRAMPX, RAMPY, RAMPZ, RAMPD and EIND:\n#endif\n// 8bit registers x 32\n\t\t\"gpr\tr0\t.8\t0\t0\\n\"\n\t\t\"gpr\tr1\t.8\t1\t0\\n\"\n\t\t\"gpr\tr2\t.8\t2\t0\\n\"\n\t\t\"gpr\tr3\t.8\t3\t0\\n\"\n\t\t\"gpr\tr4\t.8\t4\t0\\n\"\n\t\t\"gpr\tr5\t.8\t5\t0\\n\"\n\t\t\"gpr\tr6\t.8\t6\t0\\n\"\n\t\t\"gpr\tr7\t.8\t7\t0\\n\"\n\t\t\"gpr\ttext\t.64\t0\t0\\n\"\n\t\t\"gpr\tr8\t.8\t8\t0\\n\"\n\t\t\"gpr\tr9\t.8\t9\t0\\n\"\n\t\t\"gpr\tr10\t.8\t10\t0\\n\"\n\t\t\"gpr\tr11\t.8\t11\t0\\n\"\n\t\t\"gpr\tr12\t.8\t12\t0\\n\"\n\t\t\"gpr\tr13\t.8\t13\t0\\n\"\n\t\t\"gpr\tr14\t.8\t14\t0\\n\"\n\t\t\"gpr\tr15\t.8\t15\t0\\n\"\n\t\t\"gpr\tdeskey\t.64\t8\t0\\n\"\n\t\t\"gpr\tr16\t.8\t16\t0\\n\"\n\t\t\"gpr\tr17\t.8\t17\t0\\n\"\n\t\t\"gpr\tr18\t.8\t18\t0\\n\"\n\t\t\"gpr\tr19\t.8\t19\t0\\n\"\n\t\t\"gpr\tr20\t.8\t20\t0\\n\"\n\t\t\"gpr\tr21\t.8\t21\t0\\n\"\n\t\t\"gpr\tr22\t.8\t22\t0\\n\"\n\t\t\"gpr\tr23\t.8\t23\t0\\n\"\n\t\t\"gpr\tr24\t.8\t24\t0\\n\"\n\t\t\"gpr\tr25\t.8\t25\t0\\n\"\n\t\t\"gpr\tr26\t.8\t26\t0\\n\"\n\t\t\"gpr\tr27\t.8\t27\t0\\n\"\n\t\t\"gpr\tr28\t.8\t28\t0\\n\"\n\t\t\"gpr\tr29\t.8\t29\t0\\n\"\n\t\t\"gpr\tr30\t.8\t30\t0\\n\"\n\t\t\"gpr\tr31\t.8\t31\t0\\n\"\n\n// 16 bit overlapped registers for 16 bit math\n\t\t\"gpr\tr17:r16\t.16\t16\t0\\n\"\n\t\t\"gpr\tr19:r18\t.16\t18\t0\\n\"\n\t\t\"gpr\tr21:r20\t.16\t20\t0\\n\"\n\t\t\"gpr\tr23:r22\t.16\t22\t0\\n\"\n\t\t\"gpr\tr25:r24\t.16\t24\t0\\n\"\n\t\t\"gpr\tr27:r26\t.16\t26\t0\\n\"\n\t\t\"gpr\tr29:r28\t.16\t28\t0\\n\"\n\t\t\"gpr\tr31:r30\t.16\t30\t0\\n\"\n\n// 16 bit overlapped registers for memory addressing\n\t\t\"gpr\tx\t.16\t26\t0\\n\"\n\t\t\"gpr\ty\t.16\t28\t0\\n\"\n\t\t\"gpr\tz\t.16\t30\t0\\n\"\n// program counter\n// NOTE: program counter size in AVR depends on the CPU model. It seems that\n// the PC may range from 16 bits to 22 bits.\n\t\t\"gpr\tpc\t.32\t32\t0\\n\"\n\t\t\"gpr\tpcl\t.16\t32\t0\\n\"\n\t\t\"gpr\tpch\t.16\t34\t0\\n\"\n// special purpose registers\n\t\t\"gpr\tsp\t.16\t36\t0\\n\"\n\t\t\"gpr\tspl\t.8\t36\t0\\n\"\n\t\t\"gpr\tsph\t.8\t37\t0\\n\"\n// status bit register (SREG)\n\t\t\"gpr\tsreg\t.8\t38\t0\\n\"\n\t\t\"gpr\tcf\t.1\t38.0\t0\\n\" // Carry. This is a borrow flag on subtracts.\n\t\t\"gpr\tzf\t.1\t38.1\t0\\n\" // Zero. Set to 1 when an arithmetic result is zero.\n\t\t\"gpr\tnf\t.1\t38.2\t0\\n\" // Negative. Set to a copy of the most significant bit of an arithmetic result.\n\t\t\"gpr\tvf\t.1\t38.3\t0\\n\" // Overflow flag. Set in case of two's complement overflow.\n\t\t\"gpr\tsf\t.1\t38.4\t0\\n\" // Sign flag. Unique to AVR, this is always (N ^ V) (xor), and shows the true sign of a comparison.\n\t\t\"gpr\thf\t.1\t38.5\t0\\n\" // Half carry. This is an internal carry from additions and is used to support BCD arithmetic.\n\t\t\"gpr\ttf\t.1\t38.6\t0\\n\" // Bit copy. Special bit load and bit store instructions use this bit.\n\t\t\"gpr\tif\t.1\t38.7\t0\\n\" // Interrupt flag. Set when interrupts are enabled.\n// 8bit segment registers to be added to X, Y, Z to get 24bit offsets\n\t\t\"gpr\trampx\t.8\t39\t0\\n\"\n\t\t\"gpr\trampy\t.8\t40\t0\\n\"\n\t\t\"gpr\trampz\t.8\t41\t0\\n\"\n\t\t\"gpr\trampd\t.8\t42\t0\\n\"\n\t\t\"gpr\teind\t.8\t43\t0\\n\"\n// memory mapping emulator registers\n//      _prog\n//\t\tthe program flash. It has its own address space.\n//\t_ram\n//\t_io\n//\t\tstart of the data addres space. It is the same address of IO,\n//\t\tbecause IO is the first memory space addressable in the AVR.\n//\t_sram\n//\t\tstart of the SRAM (this offset depends on IO size, and it is\n//\t\tinside the _ram address space)\n//      _eeprom\n//              this is another address space, outside ram and flash\n//      _page\n//              this is the temporary page used by the SPM instruction. This\n//              memory is not directly addressable and it is used internally by\n//              the CPU when autoflashing.\n\t\t\"gpr\t_prog\t.32\t44\t0\\n\"\n\t\t\"gpr    _page   .32     48\t0\\n\"\n\t\t\"gpr\t_eeprom\t.32\t52\t0\\n\"\n\t\t\"gpr\t_ram\t.32\t56\t0\\n\"\n\t\t\"gpr\t_io\t.32\t56\t0\\n\"\n\t\t\"gpr\t_sram\t.32\t60\t0\\n\"\n// other important MCU registers\n//\tspmcsr/spmcr\n//\t\tStore Program Memory Control and Status Register (SPMCSR)\n\t\t\"gpr    spmcsr  .8      64      0\\n\"\n\t\t;\n\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n\nstatic int archinfo(RAnal *anal, int q) {\n\tif (q == R_ANAL_ARCHINFO_ALIGN)\n\t\treturn 2;\n\tif (q == R_ANAL_ARCHINFO_MAX_OP_SIZE)\n\t\treturn 4;\n\tif (q == R_ANAL_ARCHINFO_MIN_OP_SIZE)\n\t\treturn 2;\n\treturn 2; // XXX\n}\n\n\nstatic ut8 *anal_mask_avr(RAnal *anal, int size, const ut8 *data, ut64 at) {\n\tRAnalOp *op = NULL;\n\tut8 *ret = NULL;\n\tint idx;\n\n\tif (!(op = r_anal_op_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(ret = malloc (size))) {\n\t\tr_anal_op_free (op);\n\t\treturn NULL;\n\t}\n\n\tmemset (ret, 0xff, size);\n\n\tCPU_MODEL *cpu = get_cpu_model (anal->cpu);\n\n\tfor (idx = 0; idx + 1 < size; idx += op->size) {\n\t\tOPCODE_DESC* opcode_desc = avr_op_analyze (anal, op, at + idx, data + idx, size - idx, cpu);\n\n\t\tif (op->size < 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!opcode_desc) { // invalid instruction\n\t\t\tcontinue;\n\t\t}\n\n\t\t// the additional data for \"long\" opcodes (4 bytes) is usually something we want to ignore for matching\n\t\t// (things like memory offsets or jump addresses)\n\t\tif (op->size == 4) {\n\t\t\tret[idx + 2] = 0;\n\t\t\tret[idx + 3] = 0;\n\t\t}\n\n\t\tif (op->ptr != UT64_MAX || op->jump != UT64_MAX) {\n\t\t\tret[idx] = opcode_desc->mask;\n\t\t\tret[idx + 1] = opcode_desc->mask >> 8;\n\t\t}\n\t}\n\n\tr_anal_op_free (op);\n\n\treturn ret;\n}\n\nRAnalPlugin r_anal_plugin_avr = {\n\t.name = \"avr\",\n\t.desc = \"AVR code analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"avr\",\n\t.esil = true,\n\t.archinfo = archinfo,\n\t.bits = 8 | 16, // 24 big regs conflicts\n\t.op = &avr_op,\n\t.set_reg_profile = &set_reg_profile,\n\t.esil_init = esil_avr_init,\n\t.esil_fini = esil_avr_fini,\n\t.anal_mask = anal_mask_avr,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_avr,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare - LGPL - Copyright 2009-2018 - pancake, maijin */\n\n#include \"r_util.h\"\n#include \"r_core.h\"\n\nstatic const char *help_msg_a[] = {\n\t\"Usage:\", \"a\", \"[abdefFghoprxstc] [...]\",\n\t\"aa\", \"[?]\", \"analyze all (fcns + bbs) (aa0 to avoid sub renaming)\",\n\t\"a8\", \" [hexpairs]\", \"analyze bytes\",\n\t\"ab\", \"[b] [addr]\", \"analyze block at given address\",\n\t\"abb\", \" [len]\", \"analyze N basic blocks in [len] (section.size by default)\",\n\t\"ac\", \" [cycles]\", \"analyze which op could be executed in [cycles]\",\n\t\"ad\", \"[?]\", \"analyze data trampoline (wip)\",\n\t\"ad\", \" [from] [to]\", \"analyze data pointers to (from-to)\",\n\t\"ae\", \"[?] [expr]\", \"analyze opcode eval expression (see ao)\",\n\t\"af\", \"[?]\", \"analyze Functions\",\n\t\"aF\", \"\", \"same as above, but using anal.depth=1\",\n\t\"ag\", \"[?] [options]\", \"output Graphviz code\",\n\t\"ah\", \"[?]\", \"analysis hints (force opcode size, ...)\",\n\t\"ai\", \" [addr]\", \"address information (show perms, stack, heap, ...)\",\n\t\"an\",\" [name] [@addr]\",\"show/rename/create whatever flag/function is used at addr\",\n\t\"ao\", \"[?] [len]\", \"analyze Opcodes (or emulate it)\",\n\t\"aO\", \"[?] [len]\", \"Analyze N instructions in M bytes\",\n\t\"ap\", \"\", \"find prelude for current offset\",\n\t\"ar\", \"[?]\", \"like 'dr' but for the esil vm. (registers)\",\n\t\"as\", \"[?] [num]\", \"analyze syscall using dbg.reg\",\n\t\"av\", \"[?] [.]\", \"show vtables\",\n\t\"ax\", \"[?]\", \"manage refs/xrefs (see also afx?)\",\n\tNULL\n};\n\nstatic const char *help_msg_aa[] = {\n\t\"Usage:\", \"aa[0*?]\", \" # see also 'af' and 'afna'\",\n\t\"aa\", \" \", \"alias for 'af@@ sym.*;af@entry0;afva'\", //;.afna @@ fcn.*'\",\n\t\"aa*\", \"\", \"analyze all flags starting with sym. (af @@ sym.*)\",\n\t\"aaa\", \"[?]\", \"autoname functions after aa (see afna)\",\n\t\"aab\", \"\", \"aab across io.sections.text\",\n\t\"aac\", \" [len]\", \"analyze function calls (af @@ `pi len~call[1]`)\",\n\t\"aac*\", \" [len]\", \"flag function calls without performing a complete analysis\",\n\t\"aad\", \" [len]\", \"analyze data references to code\",\n\t\"aae\", \" [len] ([addr])\", \"analyze references with ESIL (optionally to address)\",\n\t\"aaE\", \"\", \"run aef on all functions (same as aef @@f)\",\n\t\"aaf\", \" \", \"analyze all functions (e anal.hasnext=1;afr @@c:isq)\",\n\t\"aai\", \"[j]\", \"show info of all analysis parameters\",\n\t\"aan\", \"\", \"autoname functions that either start with fcn.* or sym.func.*\",\n\t\"aap\", \"\", \"find and analyze function preludes\",\n\t\"aar\", \"[?] [len]\", \"analyze len bytes of instructions for references\",\n\t\"aas\", \" [len]\", \"analyze symbols (af @@= `isq~[0]`)\",\n\t\"aat\", \" [len]\", \"analyze all consecutive functions in section\",\n\t\"aaT\", \" [len]\", \"analyze code after trap-sleds\",\n\t\"aau\", \" [len]\", \"list mem areas (larger than len bytes) not covered by functions\",\n\t\"aav\", \" [sat]\", \"find values referencing a specific section or map\",\n\tNULL\n};\n\nstatic const char *help_msg_aar[] = {\n\t\"Usage:\", \"aar\", \"[j*] [sz] # search and analyze xrefs\",\n\t\"aar\", \" [sz]\", \"analyze xrefs in current section or sz bytes of code\",\n\t\"aar*\", \" [sz]\", \"list found xrefs in radare commands format\",\n\t\"aarj\", \" [sz]\", \"list found xrefs in JSON format\",\n\tNULL\n};\n\nstatic const char *help_msg_ab[] = {\n\t\"Usage:\", \"ab\", \"\",\n\t\"ab\", \" [addr]\", \"show basic block information at given address\",\n\t\"abb\", \" [length]\", \"analyze N bytes and extract basic blocks\",\n\t\"abj\", \"\", \"display basic block information in JSON\",\n\t\"abx\", \" [hexpair-bytes]\", \"analyze N bytes\",\n\tNULL\n};\n\nstatic const char *help_msg_ad[] = {\n\t\"Usage:\", \"ad\", \"[kt] [...]\",\n\t\"ad\", \" [N] [D]\", \"analyze N data words at D depth\",\n\t\"ad4\", \" [N] [D]\", \"analyze N data words at D depth (asm.bits=32)\",\n\t\"ad8\", \" [N] [D]\", \"analyze N data words at D depth (asm.bits=64)\",\n\t\"adf\", \"\", \"analyze data in function (use like .adf @@=`afl~[0]`\",\n\t\"adfg\", \"\", \"analyze data in function gaps\",\n\t\"adt\", \"\", \"analyze data trampolines (wip)\",\n\t\"adk\", \"\", \"analyze data kind (code, text, data, invalid, ...)\",\n\tNULL\n};\n\nstatic const char *help_msg_ae[] = {\n\t\"Usage:\", \"ae[idesr?] [arg]\", \"ESIL code emulation\",\n\t\"ae\", \" [expr]\", \"evaluate ESIL expression\",\n\t\"ae?\", \"\", \"show this help\",\n\t\"ae??\", \"\", \"show ESIL help\",\n\t\"ae[aA]\", \"[f] [count]\", \"analyse esil accesses (regs, mem..)\",\n\t\"aec\", \"[?]\", \"continue until ^C\",\n\t\"aecs\", \" [sn]\", \"continue until syscall number\",\n\t\"aecu\", \" [addr]\", \"continue until address\",\n\t\"aecue\", \" [esil]\", \"continue until esil expression match\",\n\t\"aef\", \" [addr]\", \"emulate function\",\n\t\"aei\", \"\", \"initialize ESIL VM state (aei- to deinitialize)\",\n\t\"aeim\", \" [addr] [size] [name]\", \"initialize ESIL VM stack (aeim- remove)\",\n\t\"aeip\", \"\", \"initialize ESIL program counter to curseek\",\n\t\"aek\", \" [query]\", \"perform sdb query on ESIL.info\",\n\t\"aek-\", \"\", \"resets the ESIL.info sdb instance\",\n\t\"aep\", \"[?] [addr]\", \"manage esil pin hooks\",\n\t\"aepc\", \" [addr]\", \"change esil PC to this address\",\n\t\"aer\", \" [..]\", \"handle ESIL registers like 'ar' or 'dr' does\",\n\t\"aets\", \"[?]\", \"ESIL Trace session\",\n\t\"aes\", \"\", \"perform emulated debugger step\",\n\t\"aesp\", \" [X] [N]\", \"evaluate N instr from offset X\",\n\t\"aesb\", \"\", \"step back\",\n\t\"aeso\", \" \", \"step over\",\n\t\"aesu\", \" [addr]\", \"step until given address\",\n\t\"aesue\", \" [esil]\", \"step until esil expression match\",\n\t\"aetr\", \"[esil]\", \"Convert an ESIL Expression to REIL\",\n\t\"aex\", \" [hex]\", \"evaluate opcode expression\",\n\tNULL\n};\n\nstatic const char *help_detail_ae[] = {\n\t\"Examples:\", \"ESIL\", \" examples and documentation\",\n\t\"+\", \"=\", \"A+=B => B,A,+=\",\n\t\"+\", \"\", \"A=A+B => B,A,+,A,=\",\n\t\"++\", \"\", \"increment, 2,A,++ == 3 (see rsi,--=[1], ... )\",\n\t\"--\", \"\", \"decrement, 2,A,-- == 1\",\n\t\"*\", \"=\", \"A*=B => B,A,*=\",\n\t\"/\", \"=\", \"A/=B => B,A,/=\",\n\t\"%\", \"=\", \"A%=B => B,A,%=\",\n\t\"&\", \"=\", \"and ax, bx => bx,ax,&=\",\n\t\"|\", \"\", \"or r0, r1, r2 => r2,r1,|,r0,=\",\n\t\"!\", \"=\", \"negate all bits\",\n\t\"^\", \"=\", \"xor ax, bx => bx,ax,^=\",\n\t\"\", \"[]\", \"mov eax,[eax] => eax,[],eax,=\",\n\t\"=\", \"[]\", \"mov [eax+3], 1 => 1,3,eax,+,=[]\",\n\t\"=\", \"[1]\", \"mov byte[eax],1 => 1,eax,=[1]\",\n\t\"=\", \"[8]\", \"mov [rax],1 => 1,rax,=[8]\",\n\t\"[]\", \"\", \"peek from random position\",\n\t\"[*]\", \"\", \"peek some from random position\",\n\t\"=\", \"[*]\", \"poke some at random position\",\n\t\"$\", \"\", \"int 0x80 => 0x80,$\",\n\t\"$$\", \"\", \"simulate a hardware trap\",\n\t\"==\", \"\", \"pops twice, compare and update esil flags\",\n\t\"<\", \"\", \"compare for smaller\",\n\t\"<\", \"=\", \"compare for smaller or equal\",\n\t\">\", \"\", \"compare for bigger\",\n\t\">\", \"=\", \"compare bigger for or equal\",\n\t\">>\", \"=\", \"shr ax, bx => bx,ax,>>=  # shift right\",\n\t\"<<\", \"=\", \"shl ax, bx => bx,ax,<<=  # shift left\",\n\t\">>>\", \"=\", \"ror ax, bx => bx,ax,>>>=  # rotate right\",\n\t\"<<<\", \"=\", \"rol ax, bx => bx,ax,<<<=  # rotate left\",\n\t\"?{\", \"\", \"if popped value != 0 run the block until }\",\n\t\"POP\", \"\", \"drops last element in the esil stack\",\n\t\"DUP\", \"\", \"duplicate last value in stack\",\n\t\"NUM\", \"\", \"evaluate last item in stack to number\",\n\t\"PICK\", \"\", \"pick Nth element in stack\",\n\t\"RPICK\", \"\", \"pick Nth element in reversed stack\",\n\t\"SWAP\", \"\", \"swap last two values in stack\",\n\t\"TRAP\", \"\", \"stop execution\",\n\t\"BITS\", \"\", \"16,BITS  # change bits, useful for arm/thumb\",\n\t\"TODO\", \"\", \"the instruction is not yet esilized\",\n\t\"STACK\", \"\", \"show contents of stack\",\n\t\"CLEAR\", \"\", \"clears the esil stack\",\n\t\"REPEAT\", \"\", \"repeat n times\",\n\t\"BREAK\", \"\", \"terminates the string parsing\",\n\t\"GOTO\", \"\", \"jump to the Nth word popped from the stack\",\n\tNULL\n};\n\nstatic const char *help_msg_aea[] = {\n\t\"Examples:\", \"aea\", \" show regs used in a range\",\n\t\"aea\", \" [ops]\", \"Show regs used in N instructions (all,read,{no,}written,memreads,memwrites)\",\n\t\"aea*\", \" [ops]\", \"Create mem.* flags for memory accesses\",\n\t\"aeaf\", \"\", \"Show regs used in current function\",\n\t\"aear\", \" [ops]\", \"Show regs read in N instructions\",\n\t\"aeaw\", \" [ops]\", \"Show regs written in N instructions\",\n\t\"aean\", \" [ops]\", \"Show regs not written in N instructions\",\n\t\"aeaj\", \" [ops]\", \"Show aea output in JSON format\",\n\t\"aeA\", \" [len]\", \"Show regs used in N bytes (subcommands are the same)\",\n\tNULL\n};\n\nstatic const char *help_msg_aec[] = {\n\t\"Examples:\", \"aec\", \" continue until ^c\",\n\t\"aec\", \"\", \"Continue until exception\",\n\t\"aecs\", \"\", \"Continue until syscall\",\n\t\"aecu\", \"[addr]\", \"Continue until address\",\n\t\"aecue\", \"[addr]\", \"Continue until esil expression\",\n\tNULL\n};\n\nstatic const char *help_msg_aep[] = {\n\t\"Usage:\", \"aep[-c] \", \" [...]\",\n\t\"aepc\", \" [addr]\", \"change program counter for esil\",\n\t\"aep\", \"-[addr]\", \"remove pin\",\n\t\"aep\", \" [name] @ [addr]\", \"set pin\",\n\t\"aep\", \"\", \"list pins\",\n\tNULL\n};\n\nstatic const char *help_msg_aets[] = {\n\t\"Usage:\", \"aets \", \" [...]\",\n\t\"aets\", \"\", \"List all ESIL trace sessions\",\n\t\"aets+\", \"\", \"Add ESIL trace session\",\n\tNULL\n};\n\nstatic const char *help_msg_af[] = {\n\t\"Usage:\", \"af\", \"\",\n\t\"af\", \" ([name]) ([addr])\", \"analyze functions (start at addr or $$)\",\n\t\"afr\", \" ([name]) ([addr])\", \"analyze functions recursively\",\n\t\"af+\", \" addr name [type] [diff]\", \"hand craft a function (requires afb+)\",\n\t\"af-\", \" [addr]\", \"clean all function analysis data (or function at addr)\",\n\t\"afb+\", \" fcnA bbA sz [j] [f] ([t]( [d]))\", \"add bb to function @ fcnaddr\",\n\t\"afb\", \"[?] [addr]\", \"List basic blocks of given function\",\n\t\"afB\", \" 16\", \"set current function as thumb (change asm.bits)\",\n\t\"afC[lc]\", \" ([addr])@[addr]\", \"calculate the Cycles (afC) or Cyclomatic Complexity (afCc)\",\n\t\"afc\", \"[?] type @[addr]\", \"set calling convention for function\",\n\t\"afd\", \"[addr]\",\"show function + delta for given offset\",\n\t\"aft\", \"[?]\", \"type matching, type propagation\",\n\t\"aff\", \"\", \"re-adjust function boundaries to fit\",\n\t\"afF\", \"[1|0|]\", \"fold/unfold/toggle\",\n\t\"afi\", \" [addr|fcn.name]\", \"show function(s) information (verbose afl)\",\n\t\"afl\", \"[?] [l*] [fcn name]\", \"list functions (addr, size, bbs, name) (see afll)\",\n\t\"afo\", \" [fcn.name]\", \"show address for the function named like this\",\n\t\"afm\", \" name\", \"merge two functions\",\n\t\"afM\", \" name\", \"print functions map\",\n\t\"afn\", \"[?] name [addr]\", \"rename name for function at address (change flag too)\",\n\t\"afna\", \"\", \"suggest automatic name for current offset\",\n\t\"afs\", \" [addr] [fcnsign]\", \"get/set function signature at current address\",\n\t\"afS\", \"[stack_size]\", \"set stack frame size for function at current address\",\n\t\"afu\", \" [addr]\", \"resize and analyze function from current address until addr\",\n\t\"afv[bsra]\", \"?\", \"manipulate args, registers and variables in function\",\n\t\"afx\", \"[cCd-] src dst\", \"add/remove code/Call/data/string reference\",\n\tNULL\n};\n\nstatic const char *help_msg_afb[] = {\n\t\"Usage:\", \"afb\", \" List basic blocks of given function\",\n\t\".afbr-\", \"\", \"Set breakpoint on every return address of the function\",\n\t\".afbr-*\", \"\", \"Remove breakpoint on every return address of the function\",\n\t\"afb\", \" [addr]\", \"list basic blocks of function\",\n\t\"afb.\", \" [addr]\", \"show info of current basic block\",\n\t\"afb+\", \" fcn_at bbat bbsz [jump] [fail] ([type] ([diff]))\", \"add basic block by hand\",\n\t\"afbr\", \"\", \"Show addresses of instructions which leave the function\",\n\t\"afbi\", \"\", \"print current basic block information\",\n\t\"afbj\", \"\", \"show basic blocks information in json\",\n\t\"afbe\", \" bbfrom bbto\", \"add basic-block edge for switch-cases\",\n\t\"afB\", \" [bits]\", \"define asm.bits for the given function\",\n\tNULL\n};\n\nstatic const char *help_msg_afc[] = {\n\t\"Usage:\", \"afc[agl?]\", \"\",\n\t\"afc\", \" convention\", \"Manually set calling convention for current function\",\n\t\"afc\", \"\", \"Show Calling convention for the Current function\",\n\t\"afcr\", \"[j]\", \"Show register usage for the current function\",\n\t\"afca\", \"\", \"Analyse function for finding the current calling convention\",\n\t\"afcl\", \"\", \"List all available calling conventions\",\n\t\"afco\", \" path\", \"Open Calling Convention sdb profile from given path\",\n\tNULL\n};\n\nstatic const char *help_msg_afC[] = {\n\t\"Usage:\", \"afC\", \" [addr]\",\n\t\"afC\", \"\", \"function cycles cost\",\n\t\"afCc\", \"\", \"cyclomatic complexity\",\n\t\"afCl\", \"\", \"loop count (backward jumps)\",\n\tNULL\n};\n\nstatic const char *help_msg_afi[] = {\n\t\"Usage:\", \"afi[jl*]\", \" <addr>\",\n\t\"afi\", \"\", \"show information of the function\",\n\t\"afi.\", \"\", \"show function name in current offset\",\n\t\"afi*\", \"\", \"function, variables and arguments\",\n\t\"afij\", \"\", \"function info in json format\",\n\t\"afil\", \"\", \"verbose function info\",\n\tNULL\n};\n\nstatic const char *help_msg_afl[] = {\n\t\"Usage:\", \"afl\", \" List all functions\",\n\t\"afl\", \"\", \"list functions\",\n\t\"aflc\", \"\", \"count of functions\",\n\t\"aflj\", \"\", \"list functions in json\",\n\t\"afll\", \"\", \"list functions in verbose mode\",\n\t\"afllj\", \"\", \"list functions in verbose mode (alias to aflj)\",\n\t\"aflq\", \"\", \"list functions in quiet mode\",\n\t\"aflqj\", \"\", \"list functions in json quiet mode\",\n\t\"afls\", \"\", \"print sum of sizes of all functions\",\n\tNULL\n};\n\nstatic const char *help_msg_afll[] = {\n\t\"Usage:\", \"\", \" List functions in verbose mode\",\n\t\"\", \"\", \"\",\n\t\"Table fields:\", \"\", \"\",\n\t\"\", \"\", \"\",\n\t\"address\", \"\", \"start address\",\n\t\"size\", \"\", \"function size (realsize)\",\n\t\"nbbs\", \"\", \"number of basic blocks\",\n\t\"edges\", \"\", \"number of edges between basic blocks\",\n\t\"cc\", \"\", \"cyclomatic complexity ( cc = edges - blocks + 2 * exit_blocks)\",\n\t\"cost\", \"\", \"cyclomatic cost\",\n\t\"min bound\", \"\", \"minimal address\",\n\t\"range\", \"\", \"function size\",\n\t\"max bound\", \"\", \"maximal address\",\n\t\"calls\", \"\", \"number of caller functions\",\n\t\"locals\", \"\", \"number of local variables\",\n\t\"args\", \"\", \"number of function arguments\",\n\t\"xref\", \"\", \"number of cross references\",\n\t\"frame\", \"\", \"function stack size\",\n\t\"name\", \"\", \"function name\",\n\tNULL\n};\n\nstatic const char *help_msg_afn[] = {\n\t\"Usage:\", \"afn[sa]\", \" Analyze function names\",\n\t\"afn\", \" [name]\", \"rename the function\",\n\t\"afna\", \"\", \"construct a function name for the current offset\",\n\t\"afns\", \"\", \"list all strings associated with the current function\",\n\tNULL\n};\n\nstatic const char *help_msg_aft[] = {\n\t\"Usage:\", \"aftm\", \"\",\n\t\"afta\", \"\", \"Setup memory and analyse do type matching analysis for all functions\",\n\t\"aftm\", \"\", \"type matching analysis\",\n\tNULL\n};\n\nstatic const char *help_msg_afv[] = {\n\t\"Usage:\", \"afv\",\"[rbs]\",\n\t\"afvr\", \"[?]\", \"manipulate register based arguments\",\n\t\"afvb\", \"[?]\", \"manipulate bp based arguments/locals\",\n\t\"afvs\", \"[?]\", \"manipulate sp based arguments/locals\",\n\t\"afvR\", \" [varname]\", \"list addresses where vars are accessed\",\n\t\"afvW\", \" [varname]\", \"list addresses where vars are accessed\",\n\t\"afva\", \"\", \"analyze function arguments/locals\",\n\t\"afvd\", \" name\", \"output r2 command for displaying the value of args/locals in the debugger\",\n\t\"afvn\", \" [old_name] [new_name]\", \"rename argument/local\",\n\t\"afvt\", \" [name] [new_type]\", \"change type for given argument/local\",\n\t\"afv-\", \"([name])\", \"remove all or given var\",\n\tNULL\n};\n\nstatic const char *help_msg_afvb[] = {\n\t\"Usage:\", \"afvb\", \" [idx] [name] ([type])\",\n\t\"afvb\", \"\", \"list base pointer based arguments, locals\",\n\t\"afvb*\", \"\", \"same as afvb but in r2 commands\",\n\t\"afvb\", \" [idx] [name] ([type])\", \"define base pointer based arguments, locals\",\n\t\"afvbj\", \"\", \"return list of base pointer based arguments, locals in JSON format\",\n\t\"afvb-\", \" [name]\", \"delete argument/locals at the given name\",\n\t\"afvbg\", \" [idx] [addr]\", \"define var get reference\",\n\t\"afvbs\", \" [idx] [addr]\", \"define var set reference\",\n\tNULL\n};\n\nstatic const char *help_msg_afvr[] = {\n\t\"Usage:\", \"afvr\", \" [reg] [type] [name]\",\n\t\"afvr\", \"\", \"list register based arguments\",\n\t\"afvr*\", \"\", \"same as afvr but in r2 commands\",\n\t\"afvr\", \" [reg] [name] ([type])\", \"define register arguments\",\n\t\"afvrj\", \"\", \"return list of register arguments in JSON format\",\n\t\"afvr-\", \" [name]\", \"delete register arguments at the given index\",\n\t\"afvrg\", \" [reg] [addr]\", \"define argument get reference\",\n\t\"afvrs\", \" [reg] [addr]\", \"define argument set reference\",\n\tNULL\n};\n\nstatic const char *help_msg_afvs[] = {\n\t\"Usage:\", \"afvs\", \" [idx] [type] [name]\",\n\t\"afvs\", \"\", \"list stack based arguments and locals\",\n\t\"afvs*\", \"\", \"same as afvs but in r2 commands\",\n\t\"afvs\", \" [idx] [name] [type]\", \"define stack based arguments,locals\",\n\t\"afvsj\", \"\", \"return list of stack based arguments and locals in JSON format\",\n\t\"afvs-\", \" [name]\", \"delete stack based argument or locals with the given name\",\n\t\"afvsg\", \" [idx] [addr]\", \"define var get reference\",\n\t\"afvss\", \" [idx] [addr]\", \"define var set reference\",\n\tNULL\n};\n\nstatic const char *help_msg_afx[] = {\n\t\"Usage:\", \"afx[-cCd?] [src] [dst]\", \" manage function references (see also ar?)\",\n\t\"afxc\", \" sym.main+0x38 sym.printf\", \"add code ref\",\n\t\"afxC\", \" sym.main sym.puts\", \"add call ref\",\n\t\"afxd\", \" sym.main str.helloworld\", \"add data ref\",\n\t\"afx-\", \" sym.main str.helloworld\", \"remove reference\",\n\tNULL\n};\n\nstatic const char *help_msg_ag[] = {\n\t\"Usage:\", \"ag[?f]\", \" Graphviz/graph code\",\n\t\"ag\", \" [addr]\", \"output graphviz code (bb at addr and children)\",\n\t\"ag-\", \"\", \"Reset the current ASCII art graph (see agn, age, agg?)\",\n\t\"aga\", \" [addr]\", \"idem, but only addresses\",\n\t\"agr\", \"[j] [addr]\", \"output graphviz call graph of function\",\n\t\"agg\", \"\", \"display current graph created with agn and age (see also ag-)\",\n\t\"agc\", \"[*j] [addr]\", \"output graphviz call graph of function\",\n\t\"agC\", \"[j]\", \"Same as agc -1. full program callgraph\",\n\t\"agd\", \" [fcn name]\", \"output graphviz code of diffed function\",\n\t\"age\", \"[?] title1 title2\", \"Add an edge to the current graph\",\n\t\"agf\", \" [addr]\", \"Show ASCII art graph of given function\",\n\t\"agg\", \"[?] [kdi*]\", \"Print graph in ASCII-Art, graphviz, k=v, r2 or visual\",\n\t\"agj\", \" [addr]\", \"idem, but in JSON format\",\n\t\"agJ\", \" [addr]\", \"idem, but in JSON format with formatted disassembly (like pdJ)\",\n\t\"agk\", \" [addr]\", \"idem, but in SDB key-value format\",\n\t\"agl\", \" [fcn name]\", \"output graphviz code using meta-data\",\n\t\"agn\", \"[?] title body\", \"Add a node to the current graph\",\n\t\"ags\", \" [addr]\", \"output simple graphviz call graph of function (only bb offset)\",\n\t\"agt\", \" [addr]\", \"find paths from current offset to given address\",\n\t\"agv\", \"\", \"Show function graph in web/png (see graph.web and cmd.graph) or agf for asciiart\",\n\tNULL\n};\n\nstatic const char *help_msg_age[] = {\n\t\"Usage:\", \"age [title1] [title2]\", \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"age\", \" title1 title2\", \"Add an edge from the node with \\\"title1\\\" as title to the one with title \\\"title2\\\"\",\n\t\"age\", \" \\\"title1 with spaces\\\" title2\", \"Add an edge from node \\\"title1 with spaces\\\" to node \\\"title2\\\"\",\n\t\"age-\", \" title1 title2\", \"Remove an edge from the node with \\\"title1\\\" as title to the one with title \\\"title2\\\"\",\n\t\"age?\", \"\", \"Show this help\",\n\tNULL\n};\n\nstatic const char *help_msg_agg[] = {\n\t\"Usage:\", \"agg[kid?*]\", \"print graph\",\n\t\"agg\", \"\", \"show current graph in ascii art\",\n\t\"aggk\", \"\", \"show graph in key=value form\",\n\t\"aggi\", \"\", \"enter interactive mode for the current graph\",\n\t\"aggd\", \"\", \"print the current graph in GRAPHVIZ dot format\",\n\t\"aggv\", \"\", \"run graphviz + viewer (see 'e cmd.graph')\",\n\t\"agg*\", \"\", \"in r2 commands, to save in projects, etc\",\n\tNULL\n};\n\nstatic const char *help_msg_agn[] = {\n\t\"Usage:\", \"agn [title] [body]\", \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"agn\", \" title1 body1\", \"Add a node with title \\\"title1\\\" and body \\\"body1\\\"\",\n\t\"agn\", \" \\\"title with space\\\" \\\"body with space\\\"\", \"Add a node with spaces in the title and in the body\",\n\t\"agn\", \" title1 base64:Ym9keTE=\", \"Add a node with the body specified as base64\",\n\t\"agn-\", \" title1\", \"Remove a node with title \\\"title1\\\"\",\n\t\"agn?\", \"\", \"Show this help\",\n\tNULL\n};\n\nstatic const char *help_msg_ah[] = {\n\t\"Usage:\", \"ah[lba-]\", \"Analysis Hints\",\n\t\"ah?\", \"\", \"show this help\",\n\t\"ah?\", \" offset\", \"show hint of given offset\",\n\t\"ah\", \"\", \"list hints in human-readable format\",\n\t\"ah.\", \"\", \"list hints in human-readable format from current offset\",\n\t\"ah-\", \"\", \"remove all hints\",\n\t\"ah-\", \" offset [size]\", \"remove hints at given offset\",\n\t\"ah*\", \" offset\", \"list hints in radare commands format\",\n\t\"aha\", \" ppc 51\", \"set arch for a range of N bytes\",\n\t\"ahb\", \" 16 @ $$\", \"force 16bit for current instruction\",\n\t\"ahc\", \" 0x804804\", \"override call/jump address\",\n\t\"ahe\", \" 3,eax,+=\", \"set vm analysis string\",\n\t\"ahf\", \" 0x804840\", \"override fallback address for call\",\n\t\"ahh\", \" 0x804840\", \"highlight this adrress offset in disasm\",\n\t\"ahi\", \"[?] 10\", \"define numeric base for immediates (1, 8, 10, 16, s)\",\n\t\"ahj\", \"\", \"list hints in JSON\",\n\t\"aho\", \" foo a0,33\", \"replace opcode string\",\n\t\"ahp\", \" addr\", \"set pointer hint\",\n\t\"ahs\", \" 4\", \"set opcode size=4\",\n\t\"ahS\", \" jz\", \"set asm.syntax=jz for this opcode\",\n\tNULL\n};\n\nstatic const char *help_msg_ahi[] = {\n\t\"Usage\", \"ahi [sbodh] [@ offset]\", \" Define numeric base\",\n\t\"ahi\", \" [base]\", \"set numeric base (1, 2, 8, 10, 16)\",\n\t\"ahi\", \" b\", \"set base to binary (2)\",\n\t\"ahi\", \" d\", \"set base to decimal (10)\",\n\t\"ahi\", \" h\", \"set base to hexadecimal (16)\",\n\t\"ahi\", \" o\", \"set base to octal (8)\",\n\t\"ahi\", \" p\", \"set base to htons(port) (3)\",\n\t\"ahi\", \" i\", \"set base to IP address (32)\",\n\t\"ahi\", \" S\", \"set base to syscall (80)\",\n\t\"ahi\", \" s\", \"set base to string (1)\",\n\tNULL\n};\n\nstatic const char *help_msg_ao[] = {\n\t\"Usage:\", \"ao[e?] [len]\", \"Analyze Opcodes\",\n\t\"aoj\", \" N\", \"display opcode analysis information in JSON for N opcodes\",\n\t\"aoe\", \" N\", \"display esil form for N opcodes\",\n\t\"aor\", \" N\", \"display reil form for N opcodes\",\n\t\"aos\", \" N\", \"display size of N opcodes\",\n\t\"ao\", \" 5\", \"display opcode analysis of 5 opcodes\",\n\t\"ao*\", \"\", \"display opcode in r commands\",\n\tNULL\n};\n\nstatic const char *help_msg_ar[] = {\n\t\"Usage: ar\", \"\", \"# Analysis Registers\",\n\t\"ar\", \"\", \"Show 'gpr' registers\",\n\t\"ar0\", \"\", \"Reset register arenas to 0\",\n\t\"ara\", \"[?]\", \"Manage register arenas\",\n\t\"ar\", \" 16\", \"Show 16 bit registers\",\n\t\"ar\", \" 32\", \"Show 32 bit registers\",\n\t\"ar\", \" all\", \"Show all bit registers\",\n\t\"ar\", \" <type>\", \"Show all registers of given type\",\n\t\"arC\", \"\", \"Display register profile comments\",\n\t\"arr\", \"\", \"Show register references (telescoping)\",\n\t\"ar=\", \"([size])(:[regs])\", \"Show register values in columns\",\n\t\"ar?\", \" <reg>\", \"Show register value\",\n\t\"arb\", \" <type>\", \"Display hexdump of the given arena\",\n\t\"arc\", \" <name>\", \"Conditional flag registers\",\n\t\"ard\", \" <name>\", \"Show only different registers\",\n\t\"arn\", \" <regalias>\", \"Get regname for pc,sp,bp,a0-3,zf,cf,of,sg\",\n\t\"aro\", \"\", \"Show old (previous) register values\",\n\t\"arp\", \"[?] <file>\", \"Load register profile from file\",\n\t\"ars\", \"\", \"Stack register state\",\n\t\"art\", \"\", \"List all register types\",\n\t\"arw\", \" <hexnum>\", \"Set contents of the register arena\",\n\t\".ar*\", \"\", \"Import register values as flags\",\n\t\".ar-\", \"\", \"Unflag all registers\",\n\tNULL\n};\n\nstatic const char *help_msg_ara[] = {\n\t\"Usage:\", \"ara[+-s]\", \"Register Arena Push/Pop/Swap\",\n\t\"ara\", \"\", \"show all register arenas allocated\",\n\t\"ara\", \"+\", \"push a new register arena for each type\",\n\t\"ara\", \"-\", \"pop last register arena\",\n\t\"aras\", \"\", \"swap last two register arenas\",\n\tNULL\n};\n\nstatic const char *help_msg_arw[] = {\n\t\"Usage:\", \"arw \", \"# Set contents of the register arena\",\n\t\"arw\", \" <hexnum>\", \"Set contents of the register arena\",\n\tNULL\n};\n\nstatic const char *help_msg_as[] = {\n\t\"Usage: as[ljk?]\", \"\", \"syscall name <-> number utility\",\n\t\"as\", \"\", \"show current syscall and arguments\",\n\t\"as\", \" 4\", \"show syscall 4 based on asm.os and current regs/mem\",\n\t\"asc[a]\", \" 4\", \"dump syscall info in .asm or .h\",\n\t\"asf\", \" [k[=[v]]]\", \"list/set/unset pf function signatures (see fcnsign)\",\n\t\"asj\", \"\", \"list of syscalls in JSON\",\n\t\"asl\", \"\", \"list of syscalls by asm.os and asm.arch\",\n\t\"asl\", \" close\", \"returns the syscall number for close\",\n\t\"asl\", \" 4\", \"returns the name of the syscall number 4\",\n\t\"ask\", \" [query]\", \"perform syscall/ queries\",\n\tNULL\n};\n\nstatic const char *help_msg_av[] = {\n\t\"Usage:\", \"av[?jr*]\", \" C++ vtables and RTTI\",\n\t\"av\", \"\", \"search for vtables in data sections and show results\",\n\t\"avj\", \"\", \"like av, but as json\",\n\t\"av*\", \"\", \"like av, but as r2 commands\",\n\t\"avr\", \"[j@addr]\", \"try to parse RTTI at vtable addr (see anal.cpp.abi)\",\n\t\"avra\", \"[j]\", \"search for vtables and try to parse RTTI at each of them\",\n\tNULL\n};\n\nstatic const char *help_msg_ax[] = {\n\t\"Usage:\", \"ax[?d-l*]\", \" # see also 'afx?'\",\n\t\"ax\", \"\", \"list refs\",\n\t\"ax\", \" addr [at]\", \"add code ref pointing to addr (from curseek)\",\n\t\"ax-\", \" [at]\", \"clean all refs (or refs from addr)\",\n\t\"axc\", \" addr [at]\", \"add code jmp ref // unused?\",\n\t\"axC\", \" addr [at]\", \"add code call ref\",\n\t\"axg\", \" [addr]\", \"show xrefs graph to reach current function\",\n\t\"axgj\", \" [addr]\", \"show xrefs graph to reach current function in json format\",\n\t\"axd\", \" addr [at]\", \"add data ref\",\n\t\"axq\", \"\", \"list refs in quiet/human-readable format\",\n\t\"axj\", \"\", \"list refs in json format\",\n\t\"axF\", \" [flg-glob]\", \"find data/code references of flags\",\n\t\"axt\", \" [addr]\", \"find data/code references to this address\",\n\t\"axf\", \" [addr]\", \"find data/code references from this address\",\n\t\"axk\", \" [query]\", \"perform sdb query\",\n\t\"ax*\", \"\", \"output radare commands\",\n\tNULL\n};\n\nstatic void cmd_anal_init(RCore *core) {\n\tDEFINE_CMD_DESCRIPTOR (core, a);\n\tDEFINE_CMD_DESCRIPTOR (core, aa);\n\tDEFINE_CMD_DESCRIPTOR (core, aar);\n\tDEFINE_CMD_DESCRIPTOR (core, ab);\n\tDEFINE_CMD_DESCRIPTOR (core, ad);\n\tDEFINE_CMD_DESCRIPTOR (core, ae);\n\tDEFINE_CMD_DESCRIPTOR (core, aea);\n\tDEFINE_CMD_DESCRIPTOR (core, aec);\n\tDEFINE_CMD_DESCRIPTOR (core, aep);\n\tDEFINE_CMD_DESCRIPTOR (core, af);\n\tDEFINE_CMD_DESCRIPTOR (core, afb);\n\tDEFINE_CMD_DESCRIPTOR (core, afc);\n\tDEFINE_CMD_DESCRIPTOR (core, afC);\n\tDEFINE_CMD_DESCRIPTOR (core, afi);\n\tDEFINE_CMD_DESCRIPTOR (core, afl);\n\tDEFINE_CMD_DESCRIPTOR (core, afll);\n\tDEFINE_CMD_DESCRIPTOR (core, afn);\n\tDEFINE_CMD_DESCRIPTOR (core, aft);\n\tDEFINE_CMD_DESCRIPTOR (core, afv);\n\tDEFINE_CMD_DESCRIPTOR (core, afvb);\n\tDEFINE_CMD_DESCRIPTOR (core, afvr);\n\tDEFINE_CMD_DESCRIPTOR (core, afvs);\n\tDEFINE_CMD_DESCRIPTOR (core, afx);\n\tDEFINE_CMD_DESCRIPTOR (core, ag);\n\tDEFINE_CMD_DESCRIPTOR (core, age);\n\tDEFINE_CMD_DESCRIPTOR (core, agg);\n\tDEFINE_CMD_DESCRIPTOR (core, agn);\n\tDEFINE_CMD_DESCRIPTOR (core, ah);\n\tDEFINE_CMD_DESCRIPTOR (core, ahi);\n\tDEFINE_CMD_DESCRIPTOR (core, ao);\n\tDEFINE_CMD_DESCRIPTOR (core, ar);\n\tDEFINE_CMD_DESCRIPTOR (core, ara);\n\tDEFINE_CMD_DESCRIPTOR (core, arw);\n\tDEFINE_CMD_DESCRIPTOR (core, as);\n\tDEFINE_CMD_DESCRIPTOR (core, ax);\n}\n\n/* better aac for windows-x86-32 */\n#define JAYRO_03 0\n\n#if JAYRO_03\n\nstatic bool anal_is_bad_call(RCore *core, ut64 from, ut64 to, ut64 addr, ut8 *buf, int bufi) {\n\tut64 align = R_ABS (addr % PE_ALIGN);\n\tut32 call_bytes;\n\n\t// XXX this is x86 specific\n\tif (align == 0) {\n\t\tcall_bytes = (ut32)((ut8*)buf)[bufi + 3] << 24;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 2] << 16;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 1] << 8;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi];\n\t} else {\n\t\tcall_bytes = (ut32)((ut8*)buf)[bufi - align + 3] << 24;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align + 2] << 16;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align + 1] << 8;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align];\n\t}\n\tif (call_bytes >= from && call_bytes <= to) {\n\t\treturn true;\n\t}\n\tcall_bytes = (ut32)((ut8*)buf)[bufi + 4] << 24;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 3] << 16;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 2] << 8;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 1];\n\tcall_bytes += addr + 5;\n\tif (call_bytes >= from && call_bytes <= to) {\n\t\treturn false;\n\t}\n\treturn false;\n}\n#endif\n\nstatic void type_cmd(RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tif (!fcn && *input != '?' && *input != 'a') {\n\t\teprintf (\"cant find function here\\n\");\n\t\treturn;\n\t}\n\tRListIter *it;\n\tut64 seek;\n\tbool io_cache =  r_config_get_i (core->config, \"io.cache\");\n\tr_cons_break_push (NULL, NULL);\n\tswitch (*input) {\n\tcase 'a': // \"afta\"\n\t\tif (r_config_get_i (core->config, \"cfg.debug\")) {\n\t\t\teprintf (\"TOFIX: afta can't run in debugger mode.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tseek = core->offset;\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tr_reg_arena_push (core->anal->reg);\n\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\tint ret = r_core_seek (core, fcn->addr, true);\n\t\t\tif (!ret) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_anal_esil_set_pc (core->anal->esil, fcn->addr);\n\t\t\tr_core_anal_type_match (core, fcn);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim-\");\n\t\tr_core_cmd0 (core, \"aei-\");\n\t\tr_core_seek (core, seek, true);\n\t\tr_reg_arena_pop (core->anal->reg);\n\t\tbreak;\n\tcase 'm': // \"aftm\"\n\t\tr_config_set_i (core->config, \"io.cache\", true);\n\t\tseek = core->offset;\n\t\tr_anal_esil_set_pc (core->anal->esil, fcn? fcn->addr: core->offset);\n\t\tr_core_anal_type_match (core, fcn);\n\t\tr_core_seek (core, seek, true);\n\t\tr_config_set_i (core->config, \"io.cache\", io_cache);\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_aft);\n\t\tbreak;\n\t}\n\tr_cons_break_pop ();\n}\n\nstatic int cc_print(void *p, const char *k, const char *v) {\n\tif (!strcmp (v, \"cc\")) {\n\t\tr_cons_println (k);\n\t}\n\treturn 1;\n}\n\nstatic void find_refs(RCore *core, const char *glob) {\n\tchar cmd[128];\n\tut64 curseek = core->offset;\n\twhile (*glob == ' ') glob++;\n\tif (!*glob) {\n\t\tglob = \"str.\";\n\t}\n\tif (*glob == '?') {\n\t\teprintf (\"Usage: arf [flag-str-filter]\\n\");\n\t\treturn;\n\t}\n\teprintf (\"Finding references of flags matching '%s'...\\n\", glob);\n\tsnprintf (cmd, sizeof (cmd) - 1, \".(findstref) @@= `f~%s[0]`\", glob);\n\tr_core_cmd0 (core, \"(findstref,f here=$$,s entry0,/r here,f-here)\");\n\tr_core_cmd0 (core, cmd);\n\tr_core_cmd0 (core, \"(-findstref)\");\n\tr_core_seek (core, curseek, 1);\n}\n\n/* set flags for every function */\nstatic void flag_every_function(RCore *core) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_flag_space_push (core->flags, \"functions\");\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tr_flag_set (core->flags, fcn->name,\n\t\t\tfcn->addr, r_anal_fcn_size (fcn));\n\t}\n\tr_flag_space_pop (core->flags);\n}\n\nstatic void var_help(RCore *core, char ch) {\n\tswitch (ch) {\n\tcase 'b':\n\t\tr_core_cmd_help (core, help_msg_afvb);\n\t\tbreak;\n\tcase 's':\n\t\tr_core_cmd_help (core, help_msg_afvs);\n\t\tbreak;\n\tcase 'r':\n\t\tr_core_cmd_help (core, help_msg_afvr);\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_afv);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"See afv?, afvb?, afvr? and afvs?\\n\");\n\t}\n}\n\nstatic void var_accesses_list(RAnal *a, RAnalFunction *fcn, int delta, const char *typestr) {\n\tconst char *var_local = sdb_fmt (\"var.0x%\"PFMT64x\".%d.%d.%s\",\n\t\t\tfcn->addr, 1, delta, typestr);\n\tconst char *xss = sdb_const_get (a->sdb_fcns, var_local, 0);\n\tif (xss && *xss) {\n\t\tr_cons_printf (\"%s\\n\", xss);\n\t} else {\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic void list_vars(RCore *core, RAnalFunction *fcn, int type, const char *name) {\n\tRAnalVar *var;\n\tRListIter *iter;\n\tRList *list = r_anal_var_list (core->anal, fcn, 0);\n\tif (type == '*') {\n\t\tconst char *bp = r_reg_get_name (core->anal->reg, R_REG_NAME_BP);\n\t\tr_cons_printf (\"f-fcnvar*\\n\");\n\t\tr_list_foreach (list, iter, var) {\n\t\t\tr_cons_printf (\"f fcnvar.%s @ %s%s%d\\n\", var->name, bp,\n\t\t\t\tvar->delta>=0? \"+\":\"\", var->delta);\n\t\t}\n\t\treturn;\n\t}\n\tif (type != 'W' && type != 'R') {\n\t\treturn;\n\t}\n\tconst char *typestr = type == 'R'?\"reads\":\"writes\";\n\tr_list_foreach (list, iter, var) {\n\t\tr_cons_printf (\"%10s  \", var->name);\n\t\tvar_accesses_list (core->anal, fcn, var->delta, typestr);\n\t}\n}\n\nstatic int cmd_an(RCore *core, bool use_json, const char *name)\n{\n\tut64 off = core->offset;\n\tRAnalOp op;\n\tchar *q = NULL;\n\tut64 tgt_addr = UT64_MAX;\n\n\tif (use_json) {\n\t\tr_cons_print (\"[\");\n\t}\n\n\tr_anal_op (core->anal, &op, off,\n\t\t\tcore->block + off - core->offset, 32, R_ANAL_OP_MASK_ALL);\n\n\ttgt_addr = op.jump != UT64_MAX ? op.jump : op.ptr;\n\tif (op.var) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, off, 0);\n\t\tif (fcn) {\n\t\t\tRAnalVar *bar = r_anal_var_get_byname (core->anal, fcn, op.var->name);\n\t\t\tif (!bar) {\n\t\t\t\tbar = r_anal_var_get_byname (core->anal, fcn, op.var->name);\n\t\t\t\tif (!bar) {\n\t\t\t\t\tbar = r_anal_var_get_byname (core->anal, fcn, op.var->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bar) {\n\t\t\t\tif (name) {\n\t\t\t\t\tr_anal_var_rename (core->anal, fcn->addr, bar->scope,\n\t\t\t\t\t\t\t\t\tbar->kind, bar->name, name);\n\t\t\t\t} else if (!use_json) {\n\t\t\t\t\tr_cons_println (bar->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"var\\\",\\\"name\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\t\tbar->name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot find variable\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot find function\\n\");\n\t\t}\n\t} else if (tgt_addr != UT64_MAX) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, tgt_addr, R_ANAL_FCN_TYPE_NULL);\n\t\tRFlagItem *f = r_flag_get_i (core->flags, tgt_addr);\n\t\tif (fcn) {\n\t\t\tif (name) {\n\t\t\t\tq = r_str_newf (\"afn %s 0x%\"PFMT64x, name, tgt_addr);\n\t\t\t} else if (!use_json) {\n\t\t\t\tr_cons_println (fcn->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"function\\\",\\\"name\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\tfcn->name);\n\t\t\t}\n\t\t} else if (f) {\n\t\t\tif (name) {\n\t\t\t\tq = r_str_newf (\"fr %s %s\", f->name, name);\n\t\t\t} else if (!use_json) {\n\t\t\t\tr_cons_println (f->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"flag\\\",\\\"name\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\tf->name);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name) {\n\t\t\t\tq = r_str_newf (\"f %s @ 0x%\"PFMT64x, name, tgt_addr);\n\t\t\t} else if (!use_json) {\n\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", tgt_addr);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"address\\\",\\\"offset\\\":\"\n\t\t\t\t\t\t\t   \"%\" PFMT64d \"}\", tgt_addr);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (use_json) {\n\t\tr_cons_print (\"]\\n\");\n\t}\n\n\tif (q) {\n\t\tr_core_cmd0 (core, q);\n\t\tfree (q);\n\t}\n\tr_anal_op_fini (&op);\n\treturn 0;\n}\n\nstatic int var_cmd(RCore *core, const char *str) {\n\tchar *p, *ostr;\n\tint delta, type = *str, res = true;\n\tRAnalVar *v1;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tostr = p = NULL;\n\tif (!str[0]) {\n\t\t// \"afv\"\n\t\tif (fcn) {\n\t\t\tr_core_cmd0 (core, \"afvs\");\n\t\t\tr_core_cmd0 (core, \"afvb\");\n\t\t\tr_core_cmd0 (core, \"afvr\");\n\t\t\treturn true;\n\t\t}\n\t\teprintf (\"Cannot find function\\n\");\n\t\treturn false;\n\t}\n\tif (str[0] == 'j') {\n\t\t// \"afvj\"\n\t\tif (fcn) {\n\t\t\tr_cons_printf (\"{\\\"sp\\\":\");\n\t\t\tr_core_cmd0 (core, \"afvsj\");\n\t\t\tr_cons_printf (\",\\\"bp\\\":\");\n\t\t\tr_core_cmd0 (core, \"afvbj\");\n\t\t\tr_cons_printf (\",\\\"reg\\\":\");\n\t\t\tr_core_cmd0 (core, \"afvrj\");\n\t\t\tr_cons_printf (\"}\\n\");\n\t\t\treturn true;\n\t\t}\n\t\teprintf (\"Cannot find function\\n\");\n\t\treturn false;\n\t}\n\tif (!str[0] || str[1] == '?'|| str[0] == '?') {\n\t\tvar_help (core, *str);\n\t\treturn res;\n\t}\n\tif (!fcn) {\n\t\teprintf (\"Cannot find function in 0x%08\"PFMT64x\"\\n\", core->offset);\n\t\treturn false;\n\t}\n\tostr = p = strdup (str);\n\t/* Variable access CFvs = set fun var */\n\tswitch (str[0]) {\n\tcase '-':\n\t\t// \"afv\"\n\t\tif (fcn) {\n\t\t\tr_core_cmdf (core, \"afvs-%s\", str + 1);\n\t\t\tr_core_cmdf (core, \"afvb-%s\", str + 1);\n\t\t\tr_core_cmdf (core, \"afvr-%s\", str + 1);\n\t\t\treturn true;\n\t\t}\n\t\teprintf (\"Cannot find function\\n\");\n\t\treturn false;\n\tcase 'R': // \"afvR\"\n\tcase 'W': // \"afvW\"\n\tcase '*': // \"afv*\"\n\t\tlist_vars (core, fcn, str[0], str + 1);\n\t\tbreak;\n\tcase 'a': // \"afva\"\n\t\tr_anal_var_delete_all (core->anal, fcn->addr, R_ANAL_VAR_KIND_REG);\n\t\tr_anal_var_delete_all (core->anal, fcn->addr, R_ANAL_VAR_KIND_BPV);\n\t\tr_anal_var_delete_all (core->anal, fcn->addr, R_ANAL_VAR_KIND_SPV);\n\t\tfcn_callconv (core, fcn);\n\t\tfree (p);\n\t\treturn true;\n\tcase 'n':\n\t\tif (str[1]) { // \"afvn\"\n\t\t\tchar *old_name = r_str_trim_head (strchr (ostr, ' '));\n\t\t\tif (!old_name) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchar *new_name = strchr (old_name, ' ');\n\t\t\tif (!new_name) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t*new_name++ = 0;\n\t\t\tr_str_trim (new_name);\n\t\t\tv1 = r_anal_var_get_byname (core->anal, fcn, old_name);\n\t\t\tif (v1) {\n\t\t\t\tr_anal_var_rename (core->anal, fcn->addr, R_ANAL_VAR_SCOPE_LOCAL,\n\t\t\t\t\t\tv1->kind, old_name, new_name);\n\t\t\t\tr_anal_var_free (v1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Cant find var by name\\n\");\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t} else {\n\t\t\tRListIter *iter;\n\t\t\tRAnalVar *v;\n\t\t\tRList *list = r_anal_var_list (core->anal, fcn, 0);\n\t\t\tr_list_foreach (list, iter, v) {\n\t\t\t\tr_cons_printf (\"%s\\n\", v->name);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase 'd': // \"afvd\"\n\t\tif (str[1]) {\n\t\t\tp = r_str_trim (strchr (ostr, ' '));\n\t\t\tif (!p) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tv1 = r_anal_var_get_byname (core->anal, fcn, p);\n\t\t\tif (!v1) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_var_display (core->anal, v1->delta, v1->kind, v1->type);\n\t\t\tr_anal_var_free (v1);\n\t\t\tfree (ostr);\n\t\t} else {\n\t\t\tRListIter *iter;\n\t\t\tRAnalVar *p;\n\t\t\tRList *list = r_anal_var_list (core->anal, fcn, 0);\n\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\tchar *a = r_core_cmd_strf (core, \".afvd %s\", p->name);\n\t\t\t\tif ((a && !*a) || !a) {\n\t\t\t\t\tfree (a);\n\t\t\t\t\ta = strdup (\"\\n\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"var %s = %s\", p->name, a);\n\t\t\t\tfree (a);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t\t// args\n\t\t\tlist = r_anal_var_list (core->anal, fcn, 1);\n\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\tchar *a = r_core_cmd_strf (core, \".afvd %s\", p->name);\n\t\t\t\tif ((a && !*a) || !a) {\n\t\t\t\t\tfree (a);\n\t\t\t\t\ta = strdup (\"\\n\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"arg %s = %s\", p->name, a);\n\t\t\t\tfree (a);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\treturn true;\n\tcase 't':{ // \"afvt\"\n\t\tp = strchr (ostr, ' ');\n\t\tif (!p++) {\n\t\t\tfree (ostr);\n\t\t\treturn false;\n\t\t}\n\n\t\tchar *type = strchr (p, ' ');\n\t\tif (!type) {\n\t\t\tfree (ostr);\n\t\t\treturn false;\n\t\t}\n\t\t*type++ = 0;\n\t\tv1 = r_anal_var_get_byname (core->anal, fcn, p);\n\t\tif (!v1) {\n\t\t\teprintf (\"Cant find get by name %s\\n\", p);\n\t\t\tfree (ostr);\n\t\t\treturn false;\n\t\t}\n\t\tr_anal_var_retype (core->anal, fcn->addr,\n\t\t\tR_ANAL_VAR_SCOPE_LOCAL, -1, v1->kind, type, -1, p);\n\t\tr_anal_var_free (v1);\n\t\tfree (ostr);\n\t\treturn true;\n\n\t}\n\t}\n\tswitch (str[1]) {\n\tcase '\\0':\n\tcase '*':\n\tcase 'j':\n\t\tr_anal_var_list_show (core->anal, fcn, type, str[1]);\n\t\tbreak;\n\tcase '.':\n\t\tr_anal_var_list_show (core->anal, fcn, core->offset, 0);\n\t\tbreak;\n\tcase '-': // \"afv[bsr]-\"\n\t\tif (str[2] == '*') {\n\t\t\tr_anal_var_delete_all (core->anal, fcn->addr, type);\n\t\t} else {\n\t\t\tif (IS_DIGIT (str[2])) {\n\t\t\t\tr_anal_var_delete (core->anal, fcn->addr,\n\t\t\t\t\t\ttype, 1, (int)r_num_math (core->num, str + 1));\n\t\t\t} else {\n\t\t\t\tchar *name = r_str_trim ( strdup (str + 2));\n\t\t\t\tr_anal_var_delete_byname (core->anal, fcn, type, name);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\teprintf (\"This command is deprecated, use afvd instead\\n\");\n\t\tbreak;\n\tcase 't':\n\t\teprintf (\"This command is deprecated use afvt instead\\n\");\n\t\tbreak;\n\tcase 's':\n\tcase 'g':\n\t\tif (str[2] != '\\0') {\n\t\t\tint rw = 0; // 0 = read, 1 = write\n\t\t\tRAnalVar *var = r_anal_var_get (core->anal, fcn->addr,\n\t\t\t\t\t\t\t(char)type, atoi (str + 2), R_ANAL_VAR_SCOPE_LOCAL);\n\t\t\tif (!var) {\n\t\t\t\teprintf (\"Cannot find variable in: '%s'\\n\", str);\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (var != NULL) {\n\t\t\t\tint scope = (str[1] == 'g')? 0: 1;\n\t\t\t\tr_anal_var_access (core->anal, fcn->addr, (char)type,\n\t\t\t\t\t\tscope, atoi (str + 2), rw, core->offset);\n\t\t\t\tr_anal_var_free (var);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Missing argument\\n\");\n\t\t}\n\t\tbreak;\n\tcase ' ': {\n\t\tconst char *name;\n\t\tchar *vartype;\n\t\tint size = 4;\n\t\tint scope = 1;\n\t\t\tfor (str++; *str == ' ';) str++;\n\t\tp = strchr (str, ' ');\n\t\tif (!p) {\n\t\t\tvar_help (core, type);\n\t\t\tbreak;\n\t\t}\n\t\t*p++ = 0;\n\t\tif (type == 'r') { //registers\n\t\t\tRRegItem *i = r_reg_get (core->anal->reg, str, -1);\n\t\t\tif (!i) {\n\t\t\t\teprintf (\"Register not found\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelta = i->index;\n\t\t} else {\n\t\t\tdelta = r_num_math (core->num, str);\n\t\t}\n\t\tname = p;\n\t\tvartype = strchr (name, ' ');\n\t\tif (vartype) {\n\t\t\t*vartype++ = 0;\n\t\t\tr_anal_var_add (core->anal, fcn->addr,\n\t\t\t\t\tscope, delta, type,\n\t\t\t\t\tvartype, size, name);\n\t\t} else {\n\t\t\teprintf (\"Missing name\\n\");\n\t\t}\n\t\t}\n\t\tbreak;\n\t};\n\n\tfree (ostr);\n\treturn res;\n}\n\nstatic void print_trampolines(RCore *core, ut64 a, ut64 b, size_t element_size) {\n\tint i;\n\tfor (i = 0; i < core->blocksize; i += element_size) {\n\t\tut32 n;\n\t\tmemcpy (&n, core->block + i, sizeof (ut32));\n\t\tif (n >= a && n <= b) {\n\t\t\tif (element_size == 4) {\n\t\t\t\tr_cons_printf (\"f trampoline.%x @ 0x%\" PFMT64x \"\\n\", n, core->offset + i);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"f trampoline.%\" PFMT64x \" @ 0x%\" PFMT64x \"\\n\", n, core->offset + i);\n\t\t\t}\n\t\t\tr_cons_printf (\"Cd %u @ 0x%\" PFMT64x \":%u\\n\", element_size, core->offset + i, element_size);\n\t\t\t// TODO: add data xrefs\n\t\t}\n\t}\n}\n\nstatic void cmd_anal_trampoline(RCore *core, const char *input) {\n\tint bits = r_config_get_i (core->config, \"asm.bits\");\n\tchar *p, *inp = strdup (input);\n\tp = strchr (inp, ' ');\n\tif (p) {\n\t\t*p = 0;\n\t}\n\tut64 a = r_num_math (core->num, inp);\n\tut64 b = p? r_num_math (core->num, p + 1): 0;\n\tfree (inp);\n\n\tswitch (bits) {\n\tcase 32:\n\t\tprint_trampolines (core, a, b, 4);\n\t\tbreak;\n\tcase 64:\n\t\tprint_trampolines (core, a, b, 8);\n\t\tbreak;\n\t}\n}\n\nR_API char *cmd_syscall_dostr(RCore *core, int n) {\n\tchar *res = NULL;\n\tint i;\n\tchar str[64];\n\tif (n == -1) {\n\t\tn = (int)r_debug_reg_get (core->dbg, \"oeax\");\n\t\tif (!n || n == -1) {\n\t\t\tconst char *a0 = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\t\t\tn = (int)r_debug_reg_get (core->dbg, a0);\n\t\t}\n\t}\n\tRSyscallItem *item = r_syscall_get (core->anal->syscall, n, -1);\n\tif (!item) {\n\t\tres = r_str_appendf (res, \"%d = unknown ()\", n);\n\t\treturn res;\n\t}\n\tres = r_str_appendf (res, \"%d = %s (\", item->num, item->name);\n\t// TODO: move this to r_syscall\n\t//TODO replace the hardcoded CC with the sdb ones\n\tfor (i = 0; i < item->args; i++) {\n\t\t// XXX this is a hack to make syscall args work on x86-32 and x86-64\n\t\t// we need to shift sn first.. which is bad, but needs to be redesigned\n\t\tint regidx = i;\n\t\tif (core->assembler->bits == 32) {\n\t\t\tregidx++;\n\t\t}\n\t\tut64 arg = r_debug_arg_get (core->dbg, R_ANAL_CC_TYPE_FASTCALL, regidx);\n\t\t//r_cons_printf (\"(%d:0x%\"PFMT64x\")\\n\", i, arg);\n\t\tif (item->sargs) {\n\t\t\tswitch (item->sargs[i]) {\n\t\t\tcase 'p': // pointer\n\t\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x \"\", arg);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tres = r_str_appendf (res, \"%\" PFMT64d \"\", arg);\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tmemset (str, 0, sizeof (str));\n\t\t\t\tr_io_read_at (core->io, arg, (ut8 *)str, sizeof (str) - 1);\n\t\t\t\tr_str_filter (str, strlen (str));\n\t\t\t\tres = r_str_appendf (res, \"\\\"%s\\\"\", str);\n\t\t\t\tbreak;\n\t\t\tcase 'Z': {\n\t\t\t\t//TODO replace the hardcoded CC with the sdb ones\n\t\t\t\tut64 len = r_debug_arg_get (core->dbg, R_ANAL_CC_TYPE_FASTCALL, i + 2);\n\t\t\t\tlen = R_MIN (len + 1, sizeof (str) - 1);\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tlen = 16; // override default\n\t\t\t\t}\n\t\t\t\t(void)r_io_read_at (core->io, arg, (ut8 *)str, len);\n\t\t\t\tstr[len] = 0;\n\t\t\t\tr_str_filter (str, -1);\n\t\t\t\tres = r_str_appendf (res, \"\\\"%s\\\"\", str);\n\t\t\t} break;\n\t\t\tdefault:\n\t\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x \"\", arg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x \"\", arg);\n\t\t}\n\t\tif (i + 1 < item->args) {\n\t\t\tres = r_str_appendf (res, \", \");\n\t\t}\n\t}\n\tr_syscall_item_free (item);\n\tres = r_str_appendf (res, \")\");\n\treturn res;\n}\n\nstatic void cmd_syscall_do(RCore *core, int n) {\n\tchar *msg = cmd_syscall_dostr (core, n);\n\tif (msg) {\n\t\tr_cons_println (msg);\n\t\tfree (msg);\n\t}\n}\n\nstatic void core_anal_bytes(RCore *core, const ut8 *buf, int len, int nops, int fmt) {\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tbool iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tbool romem = r_config_get_i (core->config, \"esil.romem\");\n\tbool stats = r_config_get_i (core->config, \"esil.stats\");\n\tbool be = core->print->big_endian;\n\tbool use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tcore->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");\n\tint ret, i, j, idx, size;\n\tconst char *color = \"\";\n\tconst char *esilstr;\n\tconst char *opexstr;\n\tRAnalHint *hint;\n\tRAnalEsil *esil = NULL;\n\tRAsmOp asmop;\n\tRAnalOp op;\n\tut64 addr;\n\tbool isFirst = true;\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tint totalsize = 0;\n\n\t// Variables required for setting up ESIL to REIL conversion\n\tif (use_color) {\n\t\tcolor = core->cons->pal.label;\n\t}\n\tswitch (fmt) {\n\tcase 'j':\n\t\tr_cons_printf (\"[\");\n\t\tbreak;\n\tcase 'r':\n\t\t// Setup for ESIL to REIL conversion\n\t\tesil = r_anal_esil_new (stacksize, iotrap, addrsize);\n\t\tif (!esil) {\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_to_reil_setup (esil, core->anal, romem, stats);\n\t\tr_anal_esil_set_pc (esil, core->offset);\n\t\tbreak;\n\t}\n\tfor (i = idx = ret = 0; idx < len && (!nops || (nops && i < nops)); i++, idx += ret) {\n\t\taddr = core->offset + idx;\n\t\t// TODO: use more anal hints\n\t\thint = r_anal_hint_get (core->anal, addr);\n\t\tr_asm_set_pc (core->assembler, addr);\n\t\tret = r_asm_disassemble (core->assembler, &asmop, buf + idx, len - idx);\n\t\tret = r_anal_op (core->anal, &op, core->offset + idx, buf + idx, len - idx, R_ANAL_OP_MASK_ALL);\n\t\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\topexstr = R_STRBUF_SAFEGET (&op.opex);\n\t\tchar *mnem = strdup (asmop.buf_asm);\n\t\tchar *sp = strchr (mnem, ' ');\n\t\tif (sp) {\n\t\t\t*sp = 0;\n\t\t}\n\t\tif (ret < 1 && fmt != 'd') {\n\t\t\teprintf (\"Oops at 0x%08\" PFMT64x \" (\", core->offset + idx);\n\t\t\tfor (i = idx, j = 0; i < core->blocksize && j < 3; ++i, ++j) {\n\t\t\t\teprintf (\"%02x \", buf[i]);\n\t\t\t}\n\t\t\teprintf (\"...)\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tsize = (hint && hint->size)? hint->size: op.size;\n\t\tif (fmt == 'd') {\n\t\t\tchar *opname = strdup (asmop.buf_asm);\n\t\t\tr_str_split (opname, ' ');\n\t\t\tchar *d = r_asm_describe (core->assembler, opname);\n\t\t\tif (d && *d) {\n\t\t\t\tr_cons_printf (\"%s: %s\\n\", opname, d);\n\t\t\t\tfree (d);\n\t\t\t} else {\n\t\t\t\teprintf (\"Unknown opcode\\n\");\n\t\t\t}\n\t\t\tfree (opname);\n\t\t} else if (fmt == 'e') {\n\t\t\tif (*esilstr) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \" %s\\n\", color, core->offset + idx, esilstr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \" %s\\n\", core->offset + idx, esilstr);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fmt == 's') {\n\t\t\ttotalsize += op.size;\n\t\t} else if (fmt == 'r') {\n\t\t\tif (*esilstr) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \"\\n\", color, core->offset + idx);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\t\t}\n\t\t\t\tr_anal_esil_parse (esil, esilstr);\n\t\t\t\tr_anal_esil_dumpstack (esil);\n\t\t\t\tr_anal_esil_stack_free (esil);\n\t\t\t}\n\t\t} else if (fmt == 'j') {\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t} else {\n\t\t\t\tr_cons_print (\",\");\n\t\t\t}\n\t\t\tr_cons_printf (\"{\\\"opcode\\\":\\\"%s\\\",\", asmop.buf_asm);\n\t\t\t{\n\t\t\t\tchar strsub[128] = { 0 };\n\t\t\t\t// pc+33\n\t\t\t\tr_parse_varsub (core->parser, NULL,\n\t\t\t\t\tcore->offset + idx,\n\t\t\t\t\tasmop.size, asmop.buf_asm,\n\t\t\t\t\tstrsub, sizeof (strsub));\n\t\t\t\t{\n\t\t\t\t\tut64 killme = UT64_MAX;\n\t\t\t\t\tif (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {\n\t\t\t\t\t\tcore->parser->relsub_addr = killme;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 0x33->sym.xx\n\t\t\t\tchar *p = strdup (strsub);\n\t\t\t\tr_parse_filter (core->parser, core->flags, p,\n\t\t\t\t\t\tstrsub, sizeof (strsub), be);\n\t\t\t\tfree (p);\n\t\t\t\tr_cons_printf (\"\\\"disasm\\\":\\\"%s\\\",\", strsub);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"mnemonic\\\":\\\"%s\\\",\", mnem);\n\t\t\tif (hint && hint->opcode) {\n\t\t\t\tr_cons_printf (\"\\\"ophint\\\":\\\"%s\\\",\", hint->opcode);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"prefix\\\":%\" PFMT64d \",\", op.prefix);\n\t\t\tr_cons_printf (\"\\\"id\\\":%d,\", op.id);\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tr_cons_printf (\"\\\"opex\\\":%s,\", opexstr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"addr\\\":%\" PFMT64d \",\", core->offset + idx);\n\t\t\tr_cons_printf (\"\\\"bytes\\\":\\\"\");\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[j + idx]);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\",\");\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"val\\\": %\" PFMT64d \",\", op.val);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"ptr\\\": %\" PFMT64d \",\", op.ptr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"size\\\": %d,\", size);\n\t\t\tr_cons_printf (\"\\\"type\\\": \\\"%s\\\",\",\n\t\t\t\tr_anal_optype_to_string (op.type));\n\t\t\tif (op.reg) {\n\t\t\t\tr_cons_printf (\"\\\"reg\\\": \\\"%s\\\",\", op.reg);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tr_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", hint->esil);\n\t\t\t} else if (*esilstr) {\n\t\t\t\tr_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"jump\\\":%\" PFMT64d \",\", op.jump);\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.refptr != -1) {\n\t\t\t\tr_cons_printf (\"\\\"refptr\\\":%d,\", op.refptr);\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"fail\\\":%\" PFMT64d \",\", op.fail);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"cycles\\\":%d,\", op.cycles);\n\t\t\tif (op.failcycles) {\n\t\t\t\tr_cons_printf (\"\\\"failcycles\\\":%d,\", op.failcycles);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"delay\\\":%d,\", op.delay);\n\t\t\t{\n\t\t\t\tconst char *p = r_anal_stackop_tostring (op.stackop);\n\t\t\t\tif (p && *p && strcmp (p, \"null\"))\n\t\t\t\t\tr_cons_printf (\"\\\"stack\\\":\\\"%s\\\",\", p);\n\t\t\t}\n\t\t\tif (op.stackptr) {\n\t\t\t\tr_cons_printf (\"\\\"stackptr\\\":%d,\", op.stackptr);\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)\n\t\t\t\t\t? r_anal_cond_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tr_cons_printf (\"\\\"cond\\\":\\\"%s\\\",\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"family\\\":\\\"%s\\\"}\", r_anal_op_family_to_string (op.family));\n\t\t} else {\n#define printline(k, fmt, arg)\\\n\t{ \\\n\t\tif (use_color)\\\n\t\t\tr_cons_printf (\"%s%s: \" Color_RESET, color, k);\\\n\t\telse\\\n\t\t\tr_cons_printf (\"%s: \", k);\\\n\t\tif (fmt) r_cons_printf (fmt, arg);\\\n\t}\n\t\t\tprintline (\"address\", \"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\tprintline (\"opcode\", \"%s\\n\", asmop.buf_asm);\n\t\t\tprintline (\"mnemonic\", \"%s\\n\", mnem);\n\t\t\tif (hint) {\n\t\t\t\tif (hint->opcode) {\n\t\t\t\t\tprintline (\"ophint\", \"%s\\n\", hint->opcode);\n\t\t\t\t}\n#if 0\n\t\t\t\t// addr should not override core->offset + idx.. its silly\n\t\t\t\tif (hint->addr != UT64_MAX) {\n\t\t\t\t\tprintline (\"addr\", \"0x%08\" PFMT64x \"\\n\", (hint->addr + idx));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tprintline (\"prefix\", \"%\" PFMT64d \"\\n\", op.prefix);\n\t\t\tprintline (\"id\", \"%d\\n\", op.id);\n#if 0\n// no opex here to avoid lot of tests broken..and having json in here is not much useful imho\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tprintline (\"opex\", \"%s\\n\", opexstr);\n\t\t\t}\n#endif\n\t\t\tprintline (\"bytes\", NULL, 0);\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[j + idx]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tif (op.val != UT64_MAX)\n\t\t\t\tprintline (\"val\", \"0x%08\" PFMT64x \"\\n\", op.val);\n\t\t\tif (op.ptr != UT64_MAX)\n\t\t\t\tprintline (\"ptr\", \"0x%08\" PFMT64x \"\\n\", op.ptr);\n\t\t\tif (op.refptr != -1)\n\t\t\t\tprintline (\"refptr\", \"%d\\n\", op.refptr);\n\t\t\tprintline (\"size\", \"%d\\n\", size);\n\t\t\tprintline (\"type\", \"%s\\n\", r_anal_optype_to_string (op.type));\n\t\t\t{\n\t\t\t\tconst char *t2 = r_anal_optype_to_string (op.type2);\n\t\t\t\tif (t2 && strcmp (t2, \"null\")) {\n\t\t\t\t\tprintline (\"type2\", \"%s\\n\", t2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op.reg) {\n\t\t\t\tprintline (\"reg\", \"%s\\n\", op.reg);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", hint->esil);\n\t\t\t} else if (*esilstr) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tprintline (\"jump\", \"0x%08\" PFMT64x \"\\n\", op.jump);\n\t\t\t}\n\t\t\tif (op.direction != 0) {\n\t\t\t\tconst char * dir = op.direction == 1 ? \"read\"\n\t\t\t\t\t: op.direction == 2 ? \"write\"\n\t\t\t\t\t: op.direction == 4 ? \"exec\"\n\t\t\t\t\t: op.direction == 8 ? \"ref\": \"none\";\n\t\t\t\tprintline (\"direction\", \"%s\\n\", dir);\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tprintline (\"fail\", \"0x%08\" PFMT64x \"\\n\", op.fail);\n\t\t\t}\n\t\t\tif (op.delay) {\n\t\t\t\tprintline (\"delay\", \"%d\\n\", op.delay);\n\t\t\t}\n\t\t\tprintline (\"stack\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)?  r_anal_cond_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tprintline (\"cond\", \"%s\\n\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintline (\"family\", \"%s\\n\", r_anal_op_family_to_string (op.family));\n\t\t\tprintline (\"stackop\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\tif (op.stackptr) {\n\t\t\t\tprintline (\"stackptr\", \"%\"PFMT64d\"\\n\", op.stackptr);\n\t\t\t}\n\t\t}\n\t\t//r_cons_printf (\"false: 0x%08\"PFMT64x\"\\n\", core->offset+idx);\n\t\t//free (hint);\n\t\tfree (mnem);\n\t\tr_anal_hint_free (hint);\n\t}\n\tif (fmt == 'j') {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (fmt == 's') {\n\t\tr_cons_printf (\"%d\\n\", totalsize);\n\t}\n\tr_anal_esil_free (esil);\n}\n\nstatic int bb_cmp(const void *a, const void *b) {\n\tconst RAnalBlock *ba = a;\n\tconst RAnalBlock *bb = b;\n\treturn ba->addr - bb->addr;\n}\n\nstatic int anal_fcn_list_bb(RCore *core, const char *input, bool one) {\n\tRDebugTracepoint *tp = NULL;\n\tRListIter *iter;\n\tRAnalBlock *b;\n\tint mode = 0;\n\tut64 addr, bbaddr = UT64_MAX;\n\tbool firstItem = true;\n\n\tif (*input == '.') {\n\t\tone = true;\n\t\tinput++;\n\t}\n\tif (*input) {\n\t\tmode = *input;\n\t\tinput++;\n\t}\n\tif (*input == '.') {\n\t\tone = true;\n\t\tinput++;\n\t}\n\tif (input && *input) {\n\t\taddr = bbaddr = r_num_math (core->num, input);\n\t} else {\n\t\taddr = core->offset;\n\t}\n\tif (one) {\n\t\tbbaddr = addr;\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\tswitch (mode) {\n\tcase 'j':\n\t\tr_cons_printf (\"[\");\n\t\tbreak;\n\tcase '*':\n\t\tr_cons_printf (\"fs blocks\\n\");\n\t\tbreak;\n\t}\n\tr_list_sort (fcn->bbs, bb_cmp);\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tif (one) {\n\t\t\tif (bbaddr != UT64_MAX && (bbaddr < b->addr || bbaddr >= (b->addr + b->size))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (mode) {\n\t\tcase 'r':\n\t\t\tif (b->jump == UT64_MAX) {\n\t\t\t\tut64 retaddr = b->addr;\n\t\t\t\tif (b->op_pos) {\n\t\t\t\t\tretaddr += b->op_pos[b->ninstr - 2];\n\t\t\t\t}\n\t\t\t\tif (!strcmp (input, \"*\")) {\n\t\t\t\t\tr_cons_printf (\"db 0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t} else if (!strcmp (input, \"-*\")) {\n\t\t\t\t\tr_cons_printf (\"db-0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tr_cons_printf (\"f bb.%05\" PFMT64x \" = 0x%08\" PFMT64x \"\\n\",\n\t\t\t\tb->addr & 0xFFFFF, b->addr);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", b->addr);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\t//r_cons_printf (\"%\" PFMT64d \"%s\", b->addr, iter->n? \",\": \"\");\n\t\t\t{\n\t\t\tRListIter *iter2;\n\t\t\tRAnalBlock *b2;\n\t\t\tint inputs = 0;\n\t\t\tint outputs = 0;\n\t\t\tr_list_foreach (fcn->bbs, iter2, b2) {\n\t\t\t\tif (b2->jump == b->addr) {\n\t\t\t\t\tinputs++;\n\t\t\t\t}\n\t\t\t\tif (b2->fail == b->addr) {\n\t\t\t\t\tinputs++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\toutputs ++;\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\toutputs ++;\n\t\t\t}\n\t\t\tr_cons_printf (\"%s{\", firstItem? \"\": \",\");\n\t\t\tfirstItem = false;\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"jump\\\":%\"PFMT64d\",\", b->jump);\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"fail\\\":%\"PFMT64d\",\", b->fail);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"addr\\\":%\" PFMT64d \",\\\"size\\\":%d,\\\"inputs\\\":%d,\\\"outputs\\\":%d,\\\"ninstr\\\":%d,\\\"traced\\\":%s}\",\n\t\t\t\tb->addr, b->size, inputs, outputs, b->ninstr, r_str_bool (b->traced));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t{\n\t\t\tRListIter *iter2;\n\t\t\tRAnalBlock *b2;\n\t\t\tint inputs = 0;\n\t\t\tint outputs = 0;\n\t\t\tr_list_foreach (fcn->bbs, iter2, b2) {\n\t\t\t\tif (b2->jump == b->addr) {\n\t\t\t\t\tinputs++;\n\t\t\t\t}\n\t\t\t\tif (b2->fail == b->addr) {\n\t\t\t\t\tinputs++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\toutputs ++;\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\toutputs ++;\n\t\t\t}\n\t\t\tfirstItem = false;\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"jump: 0x%08\"PFMT64x\"\\n\", b->jump);\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"fail: 0x%08\"PFMT64x\"\\n\", b->fail);\n\t\t\t}\n\t\t\tr_cons_printf (\"addr: 0x%08\"PFMT64x\"\\nsize: %d\\ninputs: %d\\noutputs: %d\\nninstr: %d\\ntraced: %s\\n\",\n\t\t\t\tb->addr, b->size, inputs, outputs, b->ninstr, r_str_bool (b->traced));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttp = r_debug_trace_get (core->dbg, b->addr);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %02X:%04X %d\",\n\t\t\t\tb->addr, b->addr + b->size,\n\t\t\t\ttp? tp->times: 0, tp? tp->count: 0,\n\t\t\t\tb->size);\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" j 0x%08\" PFMT64x, b->jump);\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" f 0x%08\" PFMT64x, b->fail);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_printf (\"]\\n\");\n\t}\n\treturn true;\n}\n\nstatic bool anal_bb_edge (RCore *core, const char *input) {\n\t// \"afbe\" switch-bb-addr case-bb-addr\n\tchar *arg = strdup (r_str_trim_ro(input));\n\tchar *sp = strchr (arg, ' ');\n\tif (sp) {\n\t\t*sp++ = 0;\n\t\tut64 sw_at = r_num_math (core->num, arg);\n\t\tut64 cs_at = r_num_math (core->num, sp);\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, sw_at, 0);\n\t\tif (fcn) {\n\t\t\tRAnalBlock *bb;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\tif (sw_at >= bb->addr && sw_at < (bb->addr + bb->size)) {\n\t\t\t\t\tif (!bb->switch_op) {\n\t\t\t\t\t\tbb->switch_op = r_anal_switch_op_new (\n\t\t\t\t\t\t\tsw_at, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tr_anal_switch_op_add_case (bb->switch_op, cs_at, 0, cs_at);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (arg);\n\t\t\treturn true;\n\t\t}\n\t}\n\tfree (arg);\n\treturn false;\n}\n\nstatic bool anal_fcn_del_bb(RCore *core, const char *input) {\n\tut64 addr = r_num_math (core->num, input);\n\tif (!addr) {\n\t\taddr = core->offset;\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tif (!strcmp (input, \"*\")) {\n\t\t\tr_list_free (fcn->bbs);\n\t\t\tfcn->bbs = NULL;\n\t\t} else {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tif (b->addr == addr) {\n\t\t\t\t\tr_list_delete (fcn->bbs, iter);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\teprintf (\"Cannot find basic block\\n\");\n\t\t}\n\t} else {\n\t\teprintf (\"Cannot find function\\n\");\n\t}\n\treturn false;\n}\n\nstatic int anal_fcn_add_bb(RCore *core, const char *input) {\n\t// fcn_addr bb_addr bb_size [jump] [fail]\n\tchar *ptr;\n\tconst char *ptr2 = NULL;\n\tut64 fcnaddr = -1LL, addr = -1LL;\n\tut64 size = 0LL;\n\tut64 jump = UT64_MAX;\n\tut64 fail = UT64_MAX;\n\tint type = R_ANAL_BB_TYPE_NULL;\n\tRAnalFunction *fcn = NULL;\n\tRAnalDiff *diff = NULL;\n\n\twhile (*input == ' ') input++;\n\tptr = strdup (input);\n\n\tswitch (r_str_word_set0 (ptr)) {\n\tcase 7:\n\t\tptr2 = r_str_word_get0 (ptr, 6);\n\t\tif (!(diff = r_anal_diff_new ())) {\n\t\t\teprintf (\"error: Cannot init RAnalDiff\\n\");\n\t\t\tfree (ptr);\n\t\t\treturn false;\n\t\t}\n\t\tif (ptr2[0] == 'm') {\n\t\t\tdiff->type = R_ANAL_DIFF_TYPE_MATCH;\n\t\t} else if (ptr2[0] == 'u') {\n\t\t\tdiff->type = R_ANAL_DIFF_TYPE_UNMATCH;\n\t\t}\n\tcase 6:\n\t\tptr2 = r_str_word_get0 (ptr, 5);\n\t\tif (strchr (ptr2, 'h')) {\n\t\t\ttype |= R_ANAL_BB_TYPE_HEAD;\n\t\t}\n\t\tif (strchr (ptr2, 'b')) {\n\t\t\ttype |= R_ANAL_BB_TYPE_BODY;\n\t\t}\n\t\tif (strchr (ptr2, 'l')) {\n\t\t\ttype |= R_ANAL_BB_TYPE_LAST;\n\t\t}\n\t\tif (strchr (ptr2, 'f')) {\n\t\t\ttype |= R_ANAL_BB_TYPE_FOOT;\n\t\t}\n\tcase 5: // get fail\n\t\tfail = r_num_math (core->num, r_str_word_get0 (ptr, 4));\n\tcase 4: // get jump\n\t\tjump = r_num_math (core->num, r_str_word_get0 (ptr, 3));\n\tcase 3: // get size\n\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 2));\n\tcase 2: // get addr\n\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\tcase 1: // get fcnaddr\n\t\tfcnaddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t}\n\tfcn = r_anal_get_fcn_in (core->anal, fcnaddr, 0);\n\tif (fcn) {\n\t\tint ret = r_anal_fcn_add_bb (core->anal, fcn, addr, size, jump, fail, type, diff);\n\t\tif (!ret) {\n\t\t\teprintf (\"Cannot add basic block\\n\");\n\t\t}\n\t} else {\n\t\teprintf (\"Cannot find function at 0x%\" PFMT64x \"\\n\", fcnaddr);\n\t}\n\tr_anal_diff_free (diff);\n\tfree (ptr);\n\treturn true;\n}\n\nstatic void r_core_anal_nofunclist  (RCore *core, const char *input) {\n\tint minlen = (int)(input[0]==' ') ? r_num_math (core->num, input + 1): 16;\n\tut64 code_size = r_num_get (core->num, \"$SS\");\n\tut64 base_addr = r_num_get (core->num, \"$S\");\n\tut64 chunk_size, chunk_offset, i;\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *b;\n\tchar* bitmap;\n\tint counter;\n\n\tif (minlen < 1) {\n\t\tminlen = 1;\n\t}\n\tif (code_size < 1) {\n\t\treturn;\n\t}\n\tbitmap = calloc (1, code_size+64);\n\tif (!bitmap) {\n\t\treturn;\n\t}\n\n\t// for each function\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t// for each basic block in the function\n\t\tr_list_foreach (fcn->bbs, iter2, b) {\n\t\t\t// if it is not withing range, continue\n\t\t\tif ((fcn->addr < base_addr) || (fcn->addr >= base_addr+code_size))\n\t\t\t\tcontinue;\n\t\t\t// otherwise mark each byte in the BB in the bitmap\n\t\t\tfor (counter = 0; counter < b->size; counter++) {\n\t\t\t\tbitmap[b->addr+counter-base_addr] = '=';\n\t\t\t}\n\t\t\t// finally, add a special marker to show the beginning of a\n\t\t\t// function\n\t\t\tbitmap[fcn->addr-base_addr] = 'F';\n\t\t}\n\t}\n\n\t// Now we print the list of memory regions that are not assigned to a function\n\tchunk_size = 0;\n\tchunk_offset = 0;\n\tfor (i = 0; i < code_size; i++) {\n\t\tif (bitmap[i]){\n\t\t\t// We only print a region is its size is bigger than 15 bytes\n\t\t\tif (chunk_size >= minlen){\n\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, base_addr+chunk_offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6d   %s\\n\", base_addr+chunk_offset, chunk_size, fcn->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6d\\n\", base_addr+chunk_offset, chunk_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\tchunk_size = 0;\n\t\t\tchunk_offset = i+1;\n\t\t\tcontinue;\n\t\t}\n\t\tchunk_size+=1;\n\t}\n\tif (chunk_size >= 16) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, base_addr+chunk_offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6d   %s\\n\", base_addr+chunk_offset, chunk_size, fcn->name);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6d\\n\", base_addr+chunk_offset, chunk_size);\n\t\t}\n\t}\n\tfree(bitmap);\n}\n\nstatic void r_core_anal_fmap  (RCore *core, const char *input) {\n\tint show_color = r_config_get_i (core->config, \"scr.color\");\n\tint cols = r_config_get_i (core->config, \"hex.cols\") * 4;\n\tut64 code_size = r_num_get (core->num, \"$SS\");\n\tut64 base_addr = r_num_get (core->num, \"$S\");\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *b;\n\tchar* bitmap;\n\tint assigned;\n\tut64 i;\n\n\tif (code_size < 1) {\n\t\treturn;\n\t}\n\tbitmap = calloc (1, code_size+64);\n\tif (!bitmap) {\n\t\treturn;\n\t}\n\n\t// for each function\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t// for each basic block in the function\n\t\tr_list_foreach (fcn->bbs, iter2, b) {\n\t\t\t// if it is not within range, continue\n\t\t\tif ((fcn->addr < base_addr) || (fcn->addr >= base_addr+code_size))\n\t\t\t\tcontinue;\n\t\t\t// otherwise mark each byte in the BB in the bitmap\n\t\t\tint counter = 1;\n\t\t\tfor (counter = 0; counter < b->size; counter++) {\n\t\t\t\tbitmap[b->addr+counter-base_addr] = '=';\n\t\t\t}\n\t\t\tbitmap[fcn->addr-base_addr] = 'F';\n\t\t}\n\t}\n\t// print the bitmap\n\tassigned = 0;\n\tif (cols < 1) {\n\t\tcols = 1;\n\t}\n\tfor (i = 0; i < code_size; i += 1) {\n\t\tif (!(i % cols)) {\n\t\t\tr_cons_printf (\"\\n0x%08\"PFMT64x\"  \", base_addr+i);\n\t\t}\n\t\tif (bitmap[i]) {\n\t\t\tassigned++;\n\t\t}\n\t\tif (show_color) {\n\t\t\tif (bitmap[i]) {\n\t\t\t\tr_cons_printf (\"%s%c\\x1b[0m\", Color_GREEN, bitmap[i]);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\".\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_cons_printf (\"%c\", bitmap[i] ? bitmap[i] : '.' );\n\t\t}\n\t}\n\tr_cons_printf (\"\\n%d / %d (%.2lf%%) bytes assigned to a function\\n\", assigned, code_size, 100.0*( (float) assigned) / code_size);\n\tfree(bitmap);\n}\n\nstatic bool fcnNeedsPrefix(const char *name) {\n\tif (!strncmp (name, \"entry\", 5)) {\n\t\treturn false;\n\t}\n\tif (!strncmp (name, \"main\", 4)) {\n\t\treturn false;\n\t}\n\treturn (!strchr (name, '.'));\n}\n\n/* TODO: move into r_anal_fcn_rename(); */\nstatic bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {\n\tchar *name, *oname, *nname = NULL;\n\tRAnalFunction *fcn;\n\tif (!core || !_name) {\n\t\treturn false;\n\t}\n\tconst char *fcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\tif (!fcnpfx) {\n\t\tfcnpfx = \"fcn\";\n\t}\n\tif (r_reg_get (core->anal->reg, _name, -1)) {\n\t\tname = r_str_newf (\"%s.%s\", fcnpfx, _name);\n\t} else {\n\t\tname = strdup (_name);\n\t}\n\tfcn = r_anal_get_fcn_in (core->anal, off,\n\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\tif (prefix && fcnNeedsPrefix (name)) {\n\t\tnname = r_str_newf (\"%s.%s\", fcnpfx, name);\n\t} else {\n\t\tnname = strdup (name);\n\t}\n\toname = fcn->name;\n\tr_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);\n\tfcn->name = strdup (nname);\n\tif (core->anal->cb.on_fcn_rename) {\n\t\tcore->anal->cb.on_fcn_rename (core->anal,\n\t\t\t\t\tcore->anal->user, fcn, nname);\n\t}\n\tfree (oname);\n\tfree (nname);\n\tfree (name);\n\treturn true;\n}\n\nstatic void afCc(RCore *core, const char *input) {\n\tut64 addr;\n\tRAnalFunction *fcn;\n\tif (*input == ' ') {\n\t\taddr = r_num_math (core->num, input);\n\t} else {\n\t\taddr = core->offset;\n\t}\n\tif (addr == 0LL) {\n\t\tfcn = r_anal_fcn_find_name (core->anal, input + 3);\n\t} else {\n\t\tfcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t}\n\tif (fcn) {\n\t\tut32 totalCycles = r_anal_fcn_cost (core->anal, fcn);\n\t\t// FIXME: This defeats the purpose of the function, but afC is used in project files.\n\t\t// cf. canal.c\n\t\tr_cons_printf (\"%d\\n\", totalCycles);\n\t} else {\n\t\teprintf (\"Cannot find function\\n\");\n\t}\n}\n\nstatic int cmd_anal_fcn(RCore *core, const char *input) {\n\tchar i;\n\n\tr_cons_break_timeout (r_config_get_i (core->config, \"anal.timeout\"));\n\tswitch (input[1]) {\n\tcase 'f': // \"aff\"\n\t\tr_anal_fcn_fit_overlaps (core->anal, NULL);\n\t\tbreak;\n\tcase 'a':\n\t\tif (input[2] == 'l') { // afal : list function call arguments\n\t\t\tint show_args = r_config_get_i (core->config, \"dbg.funcarg\");\n\t\t\tif (show_args) {\n\t\t\t\tr_core_print_func_args (core);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase 'd': // \"afd\"\n\t\t{\n\t\tut64 addr = 0;\n\t\tif (input[2] == '?') {\n\t\t\teprintf (\"afd [offset]\\n\");\n\t\t} else if (input[2] == ' ') {\n\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\tif (fcn) {\n\t\t\tif (fcn->addr != addr) {\n\t\t\t\tr_cons_printf (\"%s + %d\\n\", fcn->name,\n\t\t\t\t\t\t(int)(addr - fcn->addr));\n\t\t\t} else {\n\t\t\t\tr_cons_println (fcn->name);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot find function\\n\");\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '-': // \"af-\"\n\t\tif (!input[2] || !strcmp (input + 2, \"*\")) {\n\t\t\tr_anal_fcn_del_locs (core->anal, UT64_MAX);\n\t\t\tr_anal_fcn_del (core->anal, UT64_MAX);\n\t\t} else {\n\t\t\tut64 addr = input[2]\n\t\t\t\t? r_num_math (core->num, input + 2)\n\t\t\t\t: core->offset;\n\t\t\tr_anal_fcn_del_locs (core->anal, addr);\n\t\t\tr_anal_fcn_del (core->anal, addr);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"afu\"\n\t\t{\n\t\tut64 addr = core->offset;\n\t\tut64 addr_end = r_num_math (core->num, input + 2);\n\t\tif (addr_end < addr) {\n\t\t\teprintf (\"Invalid address ranges\\n\");\n\t\t} else {\n\t\t\tint depth = 1;\n\t\t\tut64 a, b;\n\t\t\tconst char *c;\n\t\t\ta = r_config_get_i (core->config, \"anal.from\");\n\t\t\tb = r_config_get_i (core->config, \"anal.to\");\n\t\t\tc = r_config_get (core->config, \"anal.limits\");\n\t\t\tr_config_set_i (core->config, \"anal.from\", addr);\n\t\t\tr_config_set_i (core->config, \"anal.to\", addr_end);\n\t\t\tr_config_set (core->config, \"anal.limits\", \"true\");\n\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_fcn_resize (core->anal, fcn, addr_end - addr);\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, addr, UT64_MAX,\n\t\t\t\t\tR_ANAL_REF_TYPE_NULL, depth);\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_fcn_resize (core->anal, fcn, addr_end - addr);\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"anal.from\", a);\n\t\t\tr_config_set_i (core->config, \"anal.to\", b);\n\t\t\tr_config_set (core->config, \"anal.limits\", c? c: \"\");\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+': { // \"af+\"\n\t\tif (input[2] != ' ') {\n\t\t\teprintf (\"Missing arguments\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tchar *ptr = strdup (input + 3);\n\t\tconst char *ptr2;\n\t\tint n = r_str_word_set0 (ptr);\n\t\tconst char *name = NULL;\n\t\tut64 addr = UT64_MAX;\n\t\tut64 size = 0LL;\n\t\tRAnalDiff *diff = NULL;\n\t\tint type = R_ANAL_FCN_TYPE_FCN;\n\t\tif (n > 1) {\n\t\t\tswitch (n) {\n\t\t\tcase 5:\n\t\t\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 4));\n\t\t\tcase 4:\n\t\t\t\tptr2 = r_str_word_get0 (ptr, 3);\n\t\t\t\tif (!(diff = r_anal_diff_new ())) {\n\t\t\t\t\teprintf (\"error: Cannot init RAnalDiff\\n\");\n\t\t\t\t\tfree (ptr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ptr2[0] == 'm') {\n\t\t\t\t\tdiff->type = R_ANAL_DIFF_TYPE_MATCH;\n\t\t\t\t} else if (ptr2[0] == 'u') {\n\t\t\t\t\tdiff->type = R_ANAL_DIFF_TYPE_UNMATCH;\n\t\t\t\t}\n\t\t\tcase 3:\n\t\t\t\tptr2 = r_str_word_get0 (ptr, 2);\n\t\t\t\tif (strchr (ptr2, 'l')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_LOC;\n\t\t\t\t} else if (strchr (ptr2, 'i')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_IMP;\n\t\t\t\t} else if (strchr (ptr2, 's')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_SYM;\n\t\t\t\t} else {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_FCN;\n\t\t\t\t}\n\t\t\tcase 2:\n\t\t\t\tname = r_str_word_get0 (ptr, 1);\n\t\t\tcase 1:\n\t\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t}\n\t\t\tif (!r_anal_fcn_add (core->anal, addr, size, name, type, diff)) {\n\t\t\t\teprintf (\"Cannot add function (duplicated)\\n\");\n\t\t\t}\n\t\t}\n\t\tr_anal_diff_free (diff);\n\t\tfree (ptr);\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"afo\"\n\t\t{\n\t\tRAnalFunction *fcn;\n\t\tut64 addr = core->offset;\n\t\tif (input[2] == ' ')\n\t\t\taddr = r_num_math (core->num, input + 3);\n\t\tif (addr == 0LL) {\n\t\t\tfcn = r_anal_fcn_find_name (core->anal, input + 3);\n\t\t} else {\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t}\n\t\tif (fcn) {\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"afi\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afi);\n\t\t\tbreak;\n\t\tcase '.': // \"afi.\"\n\t\t\t{\n\t\t\t\tut64 addr = core->offset;\n\t\t\t\tif (input[3] == ' ') {\n\t\t\t\t\taddr = r_num_math (core->num, input + 3);\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", fcn->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': // \"afil\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\t// TODO #7967 help refactor\n\t\t\t\thelp_msg_afll[1] = \"afil\";\n\t\t\t\tr_core_cmd_help (core, help_msg_afll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase 'j':   // \"afij\"\n\t\tcase '*':   // \"afi*\"\n\t\t\tr_core_anal_fcn_list (core, input + 3, input + 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = 1;\n\t\t\tr_core_anal_fcn_list (core, input + 2, &i);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"afl\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afl);\n\t\t\tbreak;\n\t\tcase 'l': // \"afll\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\t// TODO #7967 help refactor\n\t\t\t\thelp_msg_afll[1] = \"afll\";\n\t\t\t\tr_core_cmd_help (core, help_msg_afll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase 'j': // \"aflj\"\n\t\tcase 'q': // \"aflq\"\n\t\tcase 's': // \"afls\"\n\t\tcase '*': // \"afl*\"\n\t\t\tr_core_anal_fcn_list (core, NULL, input + 2);\n\t\t\tbreak;\n\t\tcase 'c': // \"aflc\"\n\t\t\tr_cons_printf (\"%d\\n\", r_list_length (core->anal->fcns));\n\t\t\tbreak;\n\t\tdefault: // \"afl \"\n\t\t\tr_core_anal_fcn_list (core, NULL, \"o\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 's': // \"afs\"\n\t\t{\n\t\tut64 addr;\n\t\tRAnalFunction *f;\n\t\tconst char *arg = input + 3;\n\t\tif (input[2] && (addr = r_num_math (core->num, arg))) {\n\t\t\targ = strchr (arg, ' ');\n\t\t\tif (arg) {\n\t\t\t\targ++;\n\t\t\t}\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tif ((f = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL))) {\n\t\t\tif (arg && *arg) {\n\t\t\t\tr_anal_str_to_fcn (core->anal, f, arg);\n\t\t\t} else {\n\t\t\t\tchar *str = r_anal_fcn_to_string (core->anal, f);\n\t\t\t\tr_cons_println (str);\n\t\t\t\tfree (str);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"No function defined at 0x%08\" PFMT64x \"\\n\", addr);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'm': // \"afm\" - merge two functions\n\t\tr_core_anal_fcn_merge (core, core->offset, r_num_math (core->num, input + 2));\n\t\tbreak;\n\tcase 'M': // \"afM\" - print functions map\n\t\tr_core_anal_fmap (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"afv\"\n\t\tvar_cmd (core, input + 2);\n\t\tbreak;\n\tcase 't': // \"aft\"\n\t\ttype_cmd (core, input + 2);\n\t\tbreak;\n\tcase 'C': // \"afC\"\n\t\tif (input[2] == 'c') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tif ((fcn = r_anal_get_fcn_in (core->anal, core->offset, 0)) != NULL) {\n\t\t\t\tr_cons_printf (\"%i\\n\", r_anal_fcn_cc (fcn));\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: Cannot find function at 0x08%\" PFMT64x \"\\n\", core->offset);\n\t\t\t}\n\t\t} else if (input[2] == 'l') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tif ((fcn = r_anal_get_fcn_in (core->anal, core->offset, 0)) != NULL) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_anal_fcn_loops (fcn));\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: Cannot find function at 0x08%\" PFMT64x \"\\n\", core->offset);\n\t\t\t}\n\t\t} else if (input[2] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_afC);\n\t\t} else {\n\t\t\tafCc (core, input + 3);\n\t\t}\n\t\tbreak;\n\tcase 'c':{ // \"afc\"\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (!fcn && !(input[2] == '?'|| input[2] == 'l' || input[2] == 'o')) {\n\t\t\teprintf (\"Cannot find function here\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (input[2]) {\n\t\tcase '\\0': // \"afc\"\n\t\t\tr_cons_println (fcn->cc);\n\t\t\tbreak;\n\t\tcase ' ': { // \"afc \"\n\t\t\tchar *cc = r_str_trim (strdup (input + 3));\n\t\t\tif (!r_anal_cc_exist (core->anal, cc)) {\n\t\t\t\teprintf (\"Unknown calling convention '%s'\\n\"\n\t\t\t\t\t\t\"See afcl for available types\\n\", cc);\n\t\t\t} else {\n\t\t\t\tfcn->cc = r_str_const (r_anal_cc_to_constant (core->anal, cc));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'a': // \"afca\"\"\n\t\t\teprintf (\"Todo\\n\");\n\t\t\tbreak;\n\t\tcase 'l': // \"afcl\" list all function Calling conventions.\n\t\t\tsdb_foreach (core->anal->sdb_cc, cc_print, NULL);\n\t\t\tbreak;\n\t\tcase 'o': { // \"afco\"\n\t\t\tchar *dbpath = r_str_trim (strdup (input + 3));\n\t\t\tif (r_file_exists (dbpath)) {\n\t\t\t\tSdb *db = sdb_new (0, dbpath, 0);\n\t\t\t\tsdb_merge (core->anal->sdb_cc, db);\n\t\t\t\tsdb_close (db);\n\t\t\t\tsdb_free (db);\n\t\t\t}\n\t\t\tfree (dbpath);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'r': {\t// \"afcr\"\n\t\t\tint i;\n\t\t\tchar *out, *cmd, *regname, *tmp;\n\t\t\tchar *subvec_str = r_str_new (\"\");\n\t\t\tchar *json_str = r_str_new (\"\");\n\t\t\t// if json_str initialize to NULL, it's possible for afcrj to output a (NULL)\n\t\t\t// subvec_str and json_str should be valid until exiting this code block\n\t\t\tbool json = input[3] == 'j'? true: false;\n\t\t\tfor (i = 0; i <= 11; i++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tcmd = r_str_newf (\"cc.%s.ret\", fcn->cc);\n\t\t\t\t} else {\n\t\t\t\t\tcmd = r_str_newf (\"cc.%s.arg%d\", fcn->cc, i);\n\t\t\t\t}\n\t\t\t\tif (i < 7) {\n\t\t\t\t\tregname = r_str_new (cmd);\n\t\t\t\t} else {\n\t\t\t\t\tregname = r_str_newf (\"cc.%s.float_arg%d\", fcn->cc, i - 6);\n\t\t\t\t}\n\t\t\t\tout = sdb_querys (core->anal->sdb_cc, NULL, 0, cmd);\n\t\t\t\tfree (cmd);\n\t\t\t\tif (out) {\n\t\t\t\t\tout[strlen (out) - 1] = 0;\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\ttmp = subvec_str;\n\t\t\t\t\t\tsubvec_str = r_str_newf (\"%s,\\\"%s\\\"\", subvec_str, out);\n\t\t\t\t\t\tfree (tmp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", regname, out);\n\t\t\t\t\t}\n\t\t\t\t\tfree (out);\n\t\t\t\t}\n\t\t\t\tfree (regname);\n\t\t\t\tif (!subvec_str[0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0: {\n\t\t\t\t\ttmp = json_str;\n\t\t\t\t\tjson_str = r_str_newf (\"%s,\\\"ret\\\":%s\", json_str, subvec_str + 1);\n\t\t\t\t\tfree (tmp);\n\t\t\t\t} break;\n\t\t\t\tcase 6: {\n\t\t\t\t\ttmp = json_str;\n\t\t\t\t\tjson_str = r_str_newf (\"%s,\\\"args\\\":[%s]\", json_str, subvec_str + 1);\n\t\t\t\t\tfree (tmp);\n\t\t\t\t} break;\n\t\t\t\tcase 11: {\n\t\t\t\t\ttmp = json_str;\n\t\t\t\t\tjson_str = r_str_newf (\"%s,\\\"float_args\\\":[%s]\", json_str, subvec_str + 1);\n\t\t\t\t\tfree (tmp);\n\t\t\t\t} break;\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfree (subvec_str);\n\t\t\t\tsubvec_str = r_str_new (\"\");\n\t\t\t}\n\t\t\tif (json && json_str[0]) {\n\t\t\t\tr_cons_printf (\"{%s}\\n\", json_str + 1);\n\t\t\t}\n\t\t\tfree (subvec_str);\n\t\t\tfree (json_str);\n\t\t} break;\n\t\tcase '?': // \"afc?\"\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afc);\n\t\t}\n\t\t}break;\n\tcase 'B': // \"afB\" // set function bits\n\t\tif (input[2] == ' ') {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\tif (fcn) {\n\t\t\t\tint bits = atoi (input + 3);\n\t\t\t\tr_anal_hint_set_bits (core->anal, fcn->addr, bits);\n\t\t\t\tr_anal_hint_set_bits (core->anal,\n\t\t\t\t\tfcn->addr + r_anal_fcn_size (fcn),\n\t\t\t\t\tcore->anal->bits);\n\t\t\t\tfcn->bits = bits;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot find function to set bits\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: afB [bits]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"afb\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"afb-\"\n\t\t\tanal_fcn_del_bb (core, input + 3);\n\t\t\tbreak;\n\t\tcase 'e': // \"afbe\"\n\t\t\tanal_bb_edge (core, input + 3);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase ' ': // \"afb \"\n\t\tcase 'q': // \"afbq\"\n\t\tcase 'r': // \"afbr\"\n\t\tcase '*': // \"afb*\"\n\t\tcase 'j': // \"afbj\"\n\t\t\tanal_fcn_list_bb (core, input + 2, false);\n\t\t\tbreak;\n\t\tcase 'i': // \"afbi\"\n\t\t\tanal_fcn_list_bb (core, input + 2, true);\n\t\t\tbreak;\n\t\tcase '.': // \"afb.\"\n\t\t\tanal_fcn_list_bb (core, input[2]? \" $$\": input + 2, true);\n\t\t\tbreak;\n\t\tcase '+': // \"afb+\"\n\t\t\tanal_fcn_add_bb (core, input + 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"afn\"\n\t\tswitch (input[2]) {\n\t\tcase 's': // \"afns\"\n\t\t\tfree (r_core_anal_fcn_autoname (core, core->offset, 1));\n\t\t\tbreak;\n\t\tcase 'a': // \"afna\"\n\t\t\t{\n\t\t\tchar *name = r_core_anal_fcn_autoname (core, core->offset, 0);\n\t\t\tif (name) {\n\t\t\t\tr_cons_printf (\"afn %s 0x%08\" PFMT64x \"\\n\", name, core->offset);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0: // \"afn\"\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", fcn->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ': // \"afn \"\n\t\t\t{\n\t\t\tut64 off = core->offset;\n\t\t\tchar *p, *name = strdup (input + 3);\n\t\t\tif ((p = strchr (name, ' '))) {\n\t\t\t\t*p++ = 0;\n\t\t\t\toff = r_num_math (core->num, p);\n\t\t\t}\n\t\t\tif (*name) {\n\t\t\t\tif (!setFunctionName (core, off, name, false)) {\n\t\t\t\t\teprintf (\"Cannot find function '%s' at 0x%08\" PFMT64x \"\\n\", name, off);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: afn newname [off]   # set new name to given function\\n\");\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afn);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': // afS\"\n\t\t{\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\tif (fcn) {\n\t\t\tfcn->maxstack = r_num_math (core->num, input + 3);\n\t\t\t//fcn->stack = fcn->maxstack;\n\t\t}\n\t\t}\n\t\tbreak;\n#if 0\n\t/* this is undocumented and probably have no uses. plz discuss */\n\tcase 'e': // \"afe\"\n\t\t{\n\t\tRAnalFunction *fcn;\n\t\tut64 off = core->offset;\n\t\tchar *p, *name = strdup ((input[2]&&input[3])? input + 3: \"\");\n\t\tif ((p = strchr (name, ' '))) {\n\t\t\t*p = 0;\n\t\t\toff = r_num_math (core->num, p + 1);\n\t\t}\n\t\tfcn = r_anal_get_fcn_in (core->anal, off, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tRAnalRef *r;\n\t\t\tr_list_foreach (fcn->refs, iter, r) {\n\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" -%c 0x%08\" PFMT64x \"\\n\", r->at, r->type, r->addr);\n\t\t\t}\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint ok = 0;\n\t\t\t\tif (b->type == R_ANAL_BB_TYPE_LAST) ok = 1;\n\t\t\t\tif (b->type == R_ANAL_BB_TYPE_FOOT) ok = 1;\n\t\t\t\tif (b->jump == UT64_MAX && b->fail == UT64_MAX) ok = 1;\n\t\t\t\tif (ok) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" -r\\n\", b->addr);\n\t\t\t\t\t// TODO: check if destination is outside the function boundaries\n\t\t\t\t}\n\t\t\t}\n\t\t} else eprintf (\"Cannot find function at 0x%08\" PFMT64x \"\\n\", core->offset);\n\t\tfree (name);\n\t\t}\n\t\tbreak;\n#endif\n\tcase 'x': // \"afx\"\n\t\tswitch (input[2]) {\n\t\tcase '\\0': // \"afx\"\n\t\tcase 'j': // \"afxj\"\n\t\tcase ' ': // \"afx \"\n#if FCN_OLD\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tr_cons_printf (\"[\");\n\t\t\t}\n\t\t\t// TODO: sdbize!\n\t\t\t// list xrefs from current address\n\t\t\t{\n\t\t\t\tut64 addr = input[2]==' '? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tRList *refs = r_anal_fcn_get_refs (core->anal, fcn);\n\t\t\t\t\tr_list_foreach (refs, iter, ref) {\n\t\t\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"%c\\\",\\\"from\\\":%\"PFMT64d\",\\\"to\\\":%\"PFMT64d\"}%s\",\n\t\t\t\t\t\t\t\t\tref->type, ref->at, ref->addr, iter->n? \",\": \"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"%c 0x%08\" PFMT64x \" -> 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\t\tref->type, ref->at, ref->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_list_free (refs);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Cannot find function at 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tr_cons_printf (\"]\\n\");\n\t\t\t}\n#else\n#warning TODO_ FCNOLD sdbize xrefs here\n\t\t\teprintf (\"TODO\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'c': // \"afxc\" add code xref\n\t\tcase 'd': // \"afxd\"\n\t\tcase 's': // \"afxs\"\n\t\tcase 'C': { // \"afxC\"\n\t\t\tchar *p;\n\t\t\tut64 a, b;\n\t\t\tchar *mi = strdup (input);\n\t\t\tif (mi && mi[3] == ' ' && (p = strchr (mi + 4, ' '))) {\n\t\t\t\t*p = 0;\n\t\t\t\ta = r_num_math (core->num, mi + 3);\n\t\t\t\tb = r_num_math (core->num, p + 1);\n\t\t\t\tr_anal_xrefs_set (core->anal, input[2], a, b);\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help (core, help_msg_afx);\n\t\t\t}\n\t\t\tfree (mi);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-': // \"afx-\"\n\t\t\t{\n\t\t\tchar *p;\n\t\t\tut64 a, b;\n\t\t\tchar *mi = strdup (input + 3);\n\t\t\tif (mi && *mi == ' ' && (p = strchr (mi + 1, ' '))) {\n\t\t\t\t*p = 0;\n\t\t\t\ta = r_num_math (core->num, mi);\n\t\t\t\tb = r_num_math (core->num, p + 1);\n\t\t\t\tr_anal_xrefs_deln (core->anal, -1, a, b);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: afx- [src] [dst]\\n\");\n\t\t\t}\n\t\t\tfree (mi);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase '?': // \"afx?\"\n\t\t\tr_core_cmd_help (core, help_msg_afx);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"afF\"\n\t\t{\n\t\t\tint val = input[2] && r_num_math (core->num, input + 2);\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\tif (fcn) {\n\t\t\t\tfcn->folded = input[2]? val: !fcn->folded;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?': // \"af?\"\n\t\tr_core_cmd_help (core, help_msg_af);\n\t\tbreak;\n\tcase 'r': // \"afr\" // analyze function recursively\n\tcase ' ': // \"af \"\n\tcase '\\0': // \"af\"\n\t\t{\n\t\tchar *uaddr = NULL, *name = NULL;\n\t\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\t\tbool analyze_recursively = r_config_get_i (core->config, \"anal.calls\");\n\t\tRAnalFunction *fcn;\n\t\tut64 addr = core->offset;\n\t\tif (input[1] == 'r') {\n\t\t\tinput++;\n\t\t\tanalyze_recursively = true;\n\t\t}\n\n\t\t// first undefine\n\t\tif (input[0] && input[1] == ' ') {\n\t\t\tname = strdup (input + 2);\n\t\t\tuaddr = strchr (name, ' ');\n\t\t\tif (uaddr) {\n\t\t\t\t*uaddr++ = 0;\n\t\t\t\taddr = r_num_math (core->num, uaddr);\n\t\t\t}\n\t\t\t// depth = 1; // or 1?\n\t\t\t// disable hasnext\n\t\t}\n\n\t\t//r_core_anal_undefine (core, core->offset);\n\t\tr_core_anal_fcn (core, addr, UT64_MAX, R_ANAL_REF_TYPE_NULL, depth);\n\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\tif (fcn && r_config_get_i (core->config, \"anal.vars\")) {\n\t\t\tfcn_callconv (core, fcn);\n\t\t}\n\t\tif (fcn) {\n\t\t\t/* ensure we use a proper name */\n\t\t\tsetFunctionName (core, addr, fcn->name, false);\n\t\t}\n\t\tif (analyze_recursively) {\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0); /// XXX wrong in case of nopskip\n\t\t\tif (fcn) {\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRList *refs = r_anal_fcn_get_refs (core->anal, fcn);\n\t\t\t\tr_list_foreach (refs, iter, ref) {\n\t\t\t\t\tif (ref->addr == UT64_MAX) {\n\t\t\t\t\t\t//eprintf (\"Warning: ignore 0x%08\"PFMT64x\" call 0x%08\"PFMT64x\"\\n\", ref->at, ref->addr);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ref->type != 'c' && ref->type != 'C') {\n\t\t\t\t\t\t/* only follow code/call references */\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!r_io_is_valid_offset (core->io, ref->addr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (core, ref->addr, fcn->addr, R_ANAL_REF_TYPE_CALL, depth);\n\t\t\t\t\t/* use recursivity here */\n#if 1\n\t\t\t\t\tRAnalFunction *f = r_anal_get_fcn_at (core->anal, ref->addr, 0);\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tRListIter *iter;\n\t\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\t\tRList *refs1 = r_anal_fcn_get_refs (core->anal, f);\n\t\t\t\t\t\tr_list_foreach (refs1, iter, ref) {\n\t\t\t\t\t\t\tif (!r_io_is_valid_offset (core->io, ref->addr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ref->type != 'c' && ref->type != 'C') {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_core_anal_fcn (core, ref->addr, f->addr, R_ANAL_REF_TYPE_CALL, depth);\n\t\t\t\t\t\t\t// recursively follow fcn->refs again and again\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_list_free (refs1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf = r_anal_get_fcn_in (core->anal, fcn->addr, 0);\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\t/* cut function */\n\t\t\t\t\t\t\tr_anal_fcn_resize (core->anal, f, addr - fcn->addr);\n\t\t\t\t\t\t\tr_core_anal_fcn (core, ref->addr, fcn->addr,\n\t\t\t\t\t\t\t\t\tR_ANAL_REF_TYPE_CALL, depth);\n\t\t\t\t\t\t\tf = r_anal_get_fcn_at (core->anal, fcn->addr, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\teprintf (\"Cannot find function at 0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tr_list_free (refs);\n\t\t\t}\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (*name && !setFunctionName (core, addr, name, true)) {\n\t\t\t\teprintf (\"Cannot find function '%s' at 0x%08\" PFMT64x \"\\n\", name, (ut64)addr);\n\t\t\t}\n\t\t\tfree (name);\n\t\t}\n\t\tflag_every_function (core);\n\t}\n\tdefault:\n\t\treturn false;\n\t\tbreak;\n\t}\n\treturn true;\n}\n\n// size: 0: bits; -1: any; >0: exact size\nstatic void __anal_reg_list(RCore *core, int type, int bits, char mode) {\n\tRReg *hack = core->dbg->reg;\n\tconst char *use_color;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tif (use_colors) {\n#undef ConsP\n#define ConsP(x) (core->cons && core->cons->pal.x)? core->cons->pal.x\n\t\tuse_color = ConsP (creg) : Color_BWHITE;\n\t} else {\n\t\tuse_color = NULL;\n\t}\n\tif (bits < 0) {\n\t\t// TODO Change the `size` argument of r_debug_reg_list to use -1 for any and 0 for anal->bits\n\t\tbits = 0;\n\t} else if (!bits) {\n\t\tbits = core->anal->bits;\n\t}\n\tif (core->anal) {\n\t\tcore->dbg->reg = core->anal->reg;\n\t\tif (core->anal->cur && core->anal->cur->arch) {\n\t\t\t/* workaround for thumb */\n\t\t\tif (!strcmp (core->anal->cur->arch, \"arm\") && bits == 16) {\n\t\t\t\tbits = 32;\n\t\t\t}\n\t\t\t/* workaround for 6502 */\n\t\t\tif (!strcmp (core->anal->cur->arch, \"6502\") && bits == 8) {\n\t\t\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, 16, mode, use_color); // XXX detect which one is current usage\n\t\t\t}\n\t\t\tif (!strcmp (core->anal->cur->arch, \"avr\") && bits == 8) {\n\t\t\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, 16, mode, use_color); // XXX detect which one is current usage\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mode == '=') {\n\t\tint pcbits = 0;\n\t\tconst char *pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\tRRegItem *reg = r_reg_get (core->anal->reg, pcname, 0);\n\t\tif (bits != reg->size) {\n\t\t\tpcbits = reg->size;\n\t\t}\n\t\tif (pcbits) {\n\t\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, pcbits, 2, use_color); // XXX detect which one is current usage\n\t\t}\n\t}\n\tr_debug_reg_list (core->dbg, type, bits, mode, use_color);\n\tcore->dbg->reg = hack;\n}\n\n// XXX dup from drp :OOO\nvoid cmd_anal_reg(RCore *core, const char *str) {\n\tint size = 0, i, type = R_REG_TYPE_GPR;\n\tint bits = (core->anal->bits & R_SYS_BITS_64)? 64: 32;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tstruct r_reg_item_t *r;\n\tconst char *use_color;\n\tconst char *name;\n\tchar *arg;\n\n\tif (use_colors) {\n#define ConsP(x) (core->cons && core->cons->pal.x)? core->cons->pal.x\n\t\tuse_color = ConsP (creg)\n\t\t: Color_BWHITE;\n\t} else {\n\t\tuse_color = NULL;\n\t}\n\tswitch (str[0]) {\n\tcase 'l': // \"arl\"\n\t{\n\t\tRRegSet *rs = r_reg_regset_get (core->anal->reg, R_REG_TYPE_GPR);\n\t\tif (rs) {\n\t\t\tRRegItem *r;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (rs->regs, iter, r) {\n\t\t\t\tr_cons_println (r->name);\n\t\t\t}\n\t\t}\n\t} break;\n\tcase '0': // \"ar0\"\n\t\tr_reg_arena_zero (core->anal->reg);\n\t\tbreak;\n\tcase 'C': // \"arC\"\n\t\tif (core->anal->reg->reg_profile_cmt) {\n\t\t\tr_cons_println (core->anal->reg->reg_profile_cmt);\n\t\t}\n\t\tbreak;\n\tcase 'w': // \"arw\"\n\t\tswitch (str[1]) {\n\t\tcase '?': {\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ':\n\t\t\tr_reg_arena_set_bytes (core->anal->reg, str + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"ara\"\n\t\tswitch (str[1]) {\n\t\tcase '?': // \"ara?\"\n\t\t\tr_core_cmd_help (core, help_msg_ara);\n\t\t\tbreak;\n\t\tcase 's': // \"aras\"\n\t\t\tr_reg_arena_swap (core->anal->reg, false);\n\t\t\tbreak;\n\t\tcase '+': // \"ara+\"\n\t\t\tr_reg_arena_push (core->anal->reg);\n\t\t\tbreak;\n\t\tcase '-': // \"ara-\"\n\t\t\tr_reg_arena_pop (core->anal->reg);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tint i, j;\n\t\t\tRRegArena *a;\n\t\t\tRListIter *iter;\n\t\t\tfor (i = 0; i < R_REG_TYPE_LAST; i++) {\n\t\t\t\tRRegSet *rs = &core->anal->reg->regset[i];\n\t\t\t\tj = 0;\n\t\t\t\tr_list_foreach (rs->pool, iter, a) {\n\t\t\t\t\tr_cons_printf (\"%s %p %d %d %s %d\\n\",\n\t\t\t\t\t\t(a == rs->arena)? \"*\": \".\", a,\n\t\t\t\t\t\ti, j, r_reg_get_type (i), a->size);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ar?\"\n\t\tif (str[1]) {\n\t\t\tut64 off = r_reg_getv (core->anal->reg, str + 1);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", off);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"arr\"\n\t\tr_core_debug_rr (core, core->anal->reg);\n\t\tbreak;\n\tcase 'S': { // \"arS\"\n\t\tint sz;\n\t\tut8 *buf = r_reg_get_bytes (\n\t\t\tcore->anal->reg, R_REG_TYPE_GPR, &sz);\n\t\tr_cons_printf (\"%d\\n\", sz);\n\t\tfree (buf);\n\t\t} break;\n\tcase 'b': { // \"arb\" WORK IN PROGRESS // DEBUG COMMAND\n\t\tint len, type = R_REG_TYPE_GPR;\n\t\targ = strchr (str, ' ');\n\t\tif (arg) {\n\t\t\tchar *string = r_str_trim (strdup (arg + 1));\n\t\t\tif (string) {\n\t\t\t\ttype = r_reg_type_by_name (string);\n\t\t\t\tif (type == -1 && string[0] != 'a') {\n\t\t\t\t\ttype = R_REG_TYPE_GPR;\n\t\t\t\t}\n\t\t\t\tfree (string);\n\t\t\t}\n\t\t}\n\t\tut8 *buf = r_reg_get_bytes (core->dbg->reg, type, &len);\n\t\tif (buf) {\n\t\t\t//r_print_hexdump (core->print, 0LL, buf, len, 16, 16);\n\t\t\tr_print_hexdump (core->print, 0LL, buf, len, 32, 4, 1);\n\t\t\tfree (buf);\n\t\t}\n\t\t} break;\n\tcase 'c': // \"arc\"\n\t\t// TODO: set flag values with drc zf=1\n\t\t{\n\t\t\tRRegItem *r;\n\t\t\tconst char *name = str + 1;\n\t\t\twhile (*name == ' ') name++;\n\t\t\tif (*name && name[1]) {\n\t\t\t\tr = r_reg_cond_get (core->dbg->reg, name);\n\t\t\t\tif (r) {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t} else {\n\t\t\t\t\tint id = r_reg_cond_from_string (name);\n\t\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\t\tif (rf) {\n\t\t\t\t\t\tint o = r_reg_cond_bits (core->dbg->reg, id, rf);\n\t\t\t\t\t\tcore->num->value = o;\n\t\t\t\t\t\t// ORLY?\n\t\t\t\t\t\tr_cons_printf (\"%d\\n\", o);\n\t\t\t\t\t\tfree (rf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"unknown conditional or flag register\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\tif (rf) {\n\t\t\t\t\tr_cons_printf (\"| s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\t\tif (*name == '=') {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s:%d \",\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (i),\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%d %s\\n\",\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf),\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (rf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ars\"\n\t\tswitch (str[1]) {\n\t\tcase '-': // \"ars-\"\n\t\t\tr_reg_arena_pop (core->dbg->reg);\n\t\t\t// restore debug registers if in debugger mode\n\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, true);\n\t\t\tbreak;\n\t\tcase '+': // \"ars+\"\n\t\t\tr_reg_arena_push (core->dbg->reg);\n\t\t\tbreak;\n\t\tcase '?': { // \"ars?\"\n\t\t\t// TODO #7967 help refactor: dup from drp\n\t\t\tconst char *help_msg[] = {\n\t\t\t\t\"Usage:\", \"drs\", \" # Register states commands\",\n\t\t\t\t\"drs\", \"\", \"List register stack\",\n\t\t\t\t\"drs+\", \"\", \"Push register state\",\n\t\t\t\t\"drs-\", \"\", \"Pop register state\",\n\t\t\t\tNULL };\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\t} break;\n\t\tdefault:\n\t\t\tr_cons_printf (\"%d\\n\", r_list_length (\n\t\t\t\t\t\tcore->dbg->reg->regset[0].pool));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"arp\"\n\t\t// XXX we have to break out .h for these cmd_xxx files.\n\t\tcmd_reg_profile (core, 'a', str);\n\t\tbreak;\n\tcase 't': // \"art\"\n\t\tfor (i = 0; (name = r_reg_get_type (i)); i++)\n\t\t\tr_cons_println (name);\n\t\tbreak;\n\tcase 'n': // \"arn\"\n\t\tif (*(str + 1) == '\\0') {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tname = r_reg_get_name (core->dbg->reg, r_reg_get_name_idx (str + 2));\n\t\tif (name && *name) {\n\t\t\tr_cons_println (name);\n\t\t} else {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ard\"\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 3, use_color); // XXX detect which one is current usage\n\t\tbreak;\n\tcase 'o': // \"aro\"\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 0, use_color); // XXX detect which one is current usage\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tbreak;\n\tcase '=': // \"ar=\"\n\t\t{\n\t\t\tchar *p = NULL;\n\t\t\tchar *bits = NULL;\n\t\t\tif (str[1]) {\n\t\t\t\tp = strdup (str + 1);\n\t\t\t\tif (str[1] != ':') {\n\t\t\t\t\t// Bits were specified\n\t\t\t\t\tbits = strtok (p, \":\");\n\t\t\t\t\tif (r_str_isnumber (bits)) {\n\t\t\t\t\t\tst64 sz = r_num_math (core->num, bits);\n\t\t\t\t\t\tif (sz > 0) {\n\t\t\t\t\t\t\tsize = sz;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint len = bits ? strlen (bits) : 0;\n\t\t\t\tif (str[len + 1] == ':') {\n\t\t\t\t\t// We have some regs\n\t\t\t\t\tchar *regs = bits ? strtok (NULL, \":\") : strtok ((char *)str + 1, \":\");\n\t\t\t\t\tchar *reg = strtok (regs, \" \");\n\t\t\t\t\tRList *q_regs = r_list_new ();\n\t\t\t\t\tif (q_regs) {\n\t\t\t\t\t\twhile (reg) {\n\t\t\t\t\t\t\tr_list_append (q_regs, reg);\n\t\t\t\t\t\t\treg = strtok (NULL, \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcore->dbg->q_regs = q_regs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t__anal_reg_list (core, type, size, 2);\n\t\t\tif (!r_list_empty (core->dbg->q_regs)) {\n\t\t\t\tr_list_free (core->dbg->q_regs);\n\t\t\t}\n\t\t\tcore->dbg->q_regs = NULL;\n\t\t\tfree (p);\n\t\t}\n\t\tbreak;\n\tcase '-': // \"ar-\"\n\tcase '*': // \"ar*\"\n\tcase 'R': // \"arR\"\n\tcase 'j': // \"arj\"\n\tcase '\\0': // \"ar\"\n\t\t__anal_reg_list (core, type, size, str[0]);\n\t\tbreak;\n\tcase ' ': { // \"ar \"\n\t\targ = strchr (str + 1, '=');\n\t\tif (arg) {\n\t\t\tchar *ostr, *regname;\n\t\t\t*arg = 0;\n\t\t\tostr = r_str_trim (strdup (str + 1));\n\t\t\tregname = r_str_trim_nc (ostr);\n\t\t\tr = r_reg_get (core->dbg->reg, regname, -1);\n\t\t\tif (!r) {\n\t\t\t\tint role = r_reg_get_name_idx (regname);\n\t\t\t\tif (role != -1) {\n\t\t\t\t\tconst char *alias = r_reg_get_name (core->dbg->reg, role);\n\t\t\t\t\tr = r_reg_get (core->dbg->reg, alias, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\t//eprintf (\"%s 0x%08\"PFMT64x\" -> \", str,\n\t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n\t\t\t\tr_reg_set_value (core->dbg->reg, r,\n\t\t\t\t\t\tr_num_math (core->num, arg + 1));\n\t\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_ALL, true);\n\t\t\t\t//eprintf (\"0x%08\"PFMT64x\"\\n\",\n\t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n\t\t\t\tr_core_cmdf (core, \".dr*%d\", bits);\n\t\t\t} else {\n\t\t\t\teprintf (\"ar: Unknown register '%s'\\n\", regname);\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\treturn;\n\t\t}\n\t\tchar name[32];\n\t\tint i = 1, j;\n\t\twhile (str[i]) {\n\t\t\tif (str[i] == ',') {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tfor (j = i; str[++j] && str[j] != ','; );\n\t\t\t\tif (j - i + 1 <= sizeof name) {\n\t\t\t\t\tr_str_ncpy (name, str + i, j - i + 1);\n\t\t\t\t\tif (IS_DIGIT (name[0])) { // e.g. ar 32\n\t\t\t\t\t\t__anal_reg_list (core, R_REG_TYPE_GPR, atoi (name), '\\0');\n\t\t\t\t\t} else if (showreg (core, name) > 0) { // e.g. ar rax\n\t\t\t\t\t} else { // e.g. ar gpr ; ar all\n\t\t\t\t\t\ttype = r_reg_type_by_name (name);\n\t\t\t\t\t\t// TODO differentiate ALL and illegal register types and print error message for the latter\n\t\t\t\t\t\t__anal_reg_list (core, type, -1, '\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t}\n\t}\n}\n\nstatic ut64 initializeEsil(RCore *core) {\n\tconst char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tRAnalEsil *esil = core->anal->esil;\n\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\tint stats = r_config_get_i (core->config, \"esil.stats\");\n\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tint exectrap = r_config_get_i (core->config, \"esil.exectrap\");\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tif (!(core->anal->esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\treturn UT64_MAX;\n\t}\n\tut64 addr;\n\tesil = core->anal->esil;\n\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\tesil->exectrap = exectrap;\n\tRList *entries = r_bin_get_entries (core->bin);\n\tRBinAddr *entry = NULL;\n\tRBinInfo *info = NULL;\n\tif (entries && !r_list_empty (entries)) {\n\t\tentry = (RBinAddr *)r_list_pop (entries);\n\t\tinfo = r_bin_get_info (core->bin);\n\t\taddr = info->has_va? entry->vaddr: entry->paddr;\n\t\tr_list_push (entries, entry);\n\t} else {\n\t\taddr = core->offset;\n\t}\n\tr_reg_setv (core->anal->reg, name, addr);\n\t// set memory read only\n\treturn addr;\n}\n\nR_API int r_core_esil_step(RCore *core, ut64 until_addr, const char *until_expr, ut64 *prev_addr) {\n#define return_tail(x) { tail_return_value = x; goto tail_return; }\n\tint tail_return_value = 0;\n\tint ret;\n\tut8 code[32];\n\tRAnalOp op = {0};\n\tRAnalEsil *esil = core->anal->esil;\n\tconst char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!esil) {\n// TODO\t\tinititalizeEsil (core);\n\n\t\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\t\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\t\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\t\tint stats = r_config_get_i (core->config, \"esil.stats\");\n\t\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\t\tint verbose = r_config_get_i (core->config, \"esil.verbose\");\n\t\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\t\tif (!(esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\t\treturn 0;\n\t\t}\n\t\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\t\tcore->anal->esil = esil;\n\t\tesil->verbose = verbose;\n\t\t{\n\t\t\tconst char *s = r_config_get (core->config, \"cmd.esil.intr\");\n\t\t\tif (s) {\n\t\t\t\tchar *my = strdup (s);\n\t\t\t\tif (my) {\n\t\t\t\t\tr_config_set (core->config, \"cmd.esil.intr\", my);\n\t\t\t\t\tfree (my);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tesil->cmd = r_core_esil_cmd;\n\tut64 addr = r_reg_getv (core->anal->reg, name);\n\tr_cons_break_push (NULL, NULL);\nrepeat:\n\tif (r_cons_is_breaked ()) {\n\t\teprintf (\"[+] ESIL emulation interrupted at 0x%08\" PFMT64x \"\\n\", addr);\n\t\treturn_tail (0);\n\t}\n\tif (!esil) {\n\t\taddr = initializeEsil (core);\n\t\tesil = core->anal->esil;\n\t\tif (!esil) {\n\t\t\treturn_tail (0);\n\t\t}\n\t} else {\n\t\tesil->trap = 0;\n\t\taddr = r_reg_getv (core->anal->reg, name);\n\t\t//eprintf (\"PC=0x%\"PFMT64x\"\\n\", (ut64)addr);\n\t}\n\tif (prev_addr) {\n\t\t*prev_addr = addr;\n\t}\n\tif (esil->exectrap) {\n\t\tif (!r_io_is_valid_offset (core->io, addr, R_IO_EXEC)) {\n\t\t\tesil->trap = R_ANAL_TRAP_EXEC_ERR;\n\t\t\tesil->trap_code = addr;\n\t\t\teprintf (\"[ESIL] Trap, trying to execute on non-executable memory\\n\");\n\t\t\treturn_tail (1);\n\t\t}\n\t}\n\tr_asm_set_pc (core->assembler, addr);\n\t// run esil pin command here\n\tconst char *pincmd = r_anal_pin_call (core->anal, addr);\n\tif (pincmd) {\n\t\tr_core_cmd0 (core, pincmd);\n\t\tut64 pc = r_debug_reg_get (core->dbg, \"PC\");\n\t\tif (addr != pc) {\n\t\t\treturn_tail (1);\n\t\t}\n\t}\n\t(void)r_io_read_at (core->io, addr, code, sizeof (code));\n\t// TODO: sometimes this is dupe\n\tret = r_anal_op (core->anal, &op, addr, code, sizeof (code), R_ANAL_OP_MASK_ALL);\n// if type is JMP then we execute the next N instructions\n\t// update the esil pointer because RAnal.op() can change it\n\tesil = core->anal->esil;\n\tif (op.size < 1 || ret < 0) {\n\t\tif (esil->cmd && esil->cmd_todo) {\n\t\t\tesil->cmd (esil, esil->cmd_todo, addr, 0);\n\t\t}\n\t\top.size = 1; // avoid inverted stepping\n\t}\n\t{\n\t\t/* apply hint */\n\t\tRAnalHint *hint = r_anal_hint_get (core->anal, addr);\n\t\tr_anal_op_hint (&op, hint);\n\t\tr_anal_hint_free (hint);\n\t}\n\tr_reg_setv (core->anal->reg, name, addr + op.size);\n\tif (ret) {\n\t\tr_anal_esil_set_pc (esil, addr);\n\t\tif (core->dbg->trace->enabled) {\n\t\t\tRReg *reg = core->dbg->reg;\n\t\t\tcore->dbg->reg = core->anal->reg;\n\t\t\tr_debug_trace_pc (core->dbg, addr);\n\t\t\tcore->dbg->reg = reg;\n\t\t} else {\n\t\t\tr_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op.esil));\n\n\t\t\tif (core->anal->cur && core->anal->cur->esil_post_loop) {\n\t\t\t\tcore->anal->cur->esil_post_loop (esil, &op);\n\t\t\t}\n\t\t\tr_anal_esil_stack_free (esil);\n\t\t}\n\t\t// only support 1 slot for now\n\t\tif (op.delay) {\n\t\t\tut8 code2[32];\n\t\t\tut64 naddr = addr + op.size;\n\t\t\tRAnalOp op2 = {0};\n\t\t\t// emulate only 1 instruction\n\t\t\tr_anal_esil_set_pc (esil, naddr);\n\t\t\t(void)r_io_read_at (core->io, naddr, code2, sizeof (code2));\n\t\t\t// TODO: sometimes this is dupe\n\t\t\tret = r_anal_op (core->anal, &op2, naddr, code2, sizeof (code2), R_ANAL_OP_MASK_ALL);\n\t\t\tswitch (op2.type) {\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CRET:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\t\t// branches are illegal in a delay slot\n\t\t\t\tesil->trap = R_ANAL_TRAP_EXEC_ERR;\n\t\t\t\tesil->trap_code = addr;\n\t\t\t\teprintf (\"[ESIL] Trap, trying to execute a branch in a delay slot\\n\");\n\t\t\t\treturn_tail (1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op2.esil));\n\t\t\tr_anal_op_fini (&op2);\n\t\t}\n\t\ttail_return_value = 1;\n\t}\n\n\tst64 follow = (st64)r_config_get_i (core->config, \"dbg.follow\");\n\tut64 pc = r_debug_reg_get (core->dbg, \"PC\");\n\tif (follow > 0) {\n\t\tif ((pc < core->offset) || (pc > (core->offset + follow))) {\n\t\t\tr_core_cmd0 (core, \"sr PC\");\n\t\t}\n\t}\n\n\t// check addr\n\tif (until_addr != UT64_MAX) {\n\t\tif (r_reg_getv (core->anal->reg, name) == until_addr) {\n\t\t\treturn_tail (0);\n\t\t}\n\t\tgoto repeat;\n\t}\n\t// check esil\n\tif (esil && esil->trap) {\n\t\tif (core->anal->esil->verbose) {\n\t\t\teprintf (\"TRAP\\n\");\n\t\t}\n\t\treturn_tail (0);\n\t}\n\tif (until_expr) {\n\t\tif (r_anal_esil_condition (core->anal->esil, until_expr)) {\n\t\t\tif (core->anal->esil->verbose) {\n\t\t\t\teprintf (\"ESIL BREAK!\\n\");\n\t\t\t}\n\t\t\treturn_tail (0);\n\t\t}\n\t\tgoto repeat;\n\t}\ntail_return:\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\treturn tail_return_value;\n}\n\nR_API int r_core_esil_step_back(RCore *core) {\n\tRAnalEsil *esil = core->anal->esil;\n\tRListIter *tail;\n\tconst char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tut64 prev = 0;\n\tut64 end = r_reg_getv (core->anal->reg, name);\n\n\tif (!esil || !(tail = r_list_tail (esil->sessions))) {\n\t\treturn 0;\n\t}\n\tRAnalEsilSession *before = (RAnalEsilSession *) tail->data;\n\tif (!before) {\n\t\teprintf (\"Cannot find any previous state here\\n\");\n\t\treturn 0;\n\t}\n\teprintf (\"NOTE: step back in esil is setting an initial state and stepping into pc is the same.\\n\");\n\teprintf (\"NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\\n\");\n\teprintf (\"NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\\n\");\n\teprintf (\"Execute until 0x%08\"PFMT64x\"\\n\", end);\n\tr_anal_esil_session_set (esil, before);\n\tr_core_esil_step (core, end, NULL, &prev);\n\teprintf (\"Before 0x%08\"PFMT64x\"\\n\", prev);\n\tr_anal_esil_session_set (esil, before);\n\tr_core_esil_step (core, prev, NULL, NULL);\n\treturn 1;\n}\n\nstatic void cmd_address_info(RCore *core, const char *addrstr, int fmt) {\n\tut64 addr, type;\n\tif (!addrstr || !*addrstr) {\n\t\taddr = core->offset;\n\t} else {\n\t\taddr = r_num_math (core->num, addrstr);\n\t}\n\ttype = r_core_anal_address (core, addr);\n\tint isp = 0;\n\tswitch (fmt) {\n\tcase 'j':\n#define COMMA isp++? \",\": \"\"\n\t\tr_cons_printf (\"{\");\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM)\n\t\t\tr_cons_printf (\"%s\\\"program\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY)\n\t\t\tr_cons_printf (\"%s\\\"library\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC)\n\t\t\tr_cons_printf (\"%s\\\"exec\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_READ)\n\t\t\tr_cons_printf (\"%s\\\"read\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE)\n\t\t\tr_cons_printf (\"%s\\\"write\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_FLAG)\n\t\t\tr_cons_printf (\"%s\\\"flag\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_FUNC)\n\t\t\tr_cons_printf (\"%s\\\"func\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_STACK)\n\t\t\tr_cons_printf (\"%s\\\"stack\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP)\n\t\t\tr_cons_printf (\"%s\\\"heap\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_REG)\n\t\t\tr_cons_printf (\"%s\\\"reg\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII)\n\t\t\tr_cons_printf (\"%s\\\"ascii\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE)\n\t\t\tr_cons_printf (\"%s\\\"sequence\\\":true\", COMMA);\n\t\tr_cons_print (\"}\");\n\t\tbreak;\n\tdefault:\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM)\n\t\t\tr_cons_printf (\"program\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY)\n\t\t\tr_cons_printf (\"library\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC)\n\t\t\tr_cons_printf (\"exec\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_READ)\n\t\t\tr_cons_printf (\"read\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE)\n\t\t\tr_cons_printf (\"write\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_FLAG)\n\t\t\tr_cons_printf (\"flag\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_FUNC)\n\t\t\tr_cons_printf (\"func\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_STACK)\n\t\t\tr_cons_printf (\"stack\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP)\n\t\t\tr_cons_printf (\"heap\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_REG)\n\t\t\tr_cons_printf (\"reg\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII)\n\t\t\tr_cons_printf (\"ascii\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE)\n\t\t\tr_cons_printf (\"sequence\\n\");\n\t}\n}\n\nstatic void cmd_anal_info(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '?':\n\t\teprintf (\"Usage: ai @ rsp\\n\");\n\t\tbreak;\n\tcase ' ':\n\t\tcmd_address_info (core, input, 0);\n\t\tbreak;\n\tcase 'j': // \"aij\"\n\t\tcmd_address_info (core, input + 1, 'j');\n\t\tbreak;\n\tdefault:\n\t\tcmd_address_info (core, NULL, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void initialize_stack (RCore *core, ut64 addr, ut64 size) {\n\tconst char *mode = r_config_get (core->config, \"esil.fillstack\");\n\tif (mode && *mode && *mode != '0') {\n\t\tconst int bs = 4096 * 32;\n\t\tut64 i;\n\t\tfor (i = 0; i < size; i += bs) {\n\t\t\tint left = R_MIN (bs, size - i);\n\t\t//\tr_core_cmdf (core, \"wx 10203040 @ 0x%llx\", addr);\n\t\t\tswitch (*mode) {\n\t\t\tcase 'd': // \"debrujn\"\n\t\t\t\tr_core_cmdf (core, \"wopD %\"PFMT64d\" @ 0x%\"PFMT64x, left, addr + i);\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"seq\"\n\t\t\t\tr_core_cmdf (core, \"woe 1 0xff 1 4 @ 0x%\"PFMT64x\"!0x%\"PFMT64x, addr + i, left);\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"random\"\n\t\t\t\tr_core_cmdf (core, \"woR %\"PFMT64d\" @ 0x%\"PFMT64x\"!0x%\"PFMT64x, left, addr + i, left);\n\t\t\t\tbreak;\n\t\t\tcase 'z': // \"zero\"\n\t\t\tcase '0':\n\t\t\t\tr_core_cmdf (core, \"wow 00 @ 0x%\"PFMT64x\"!0x%\"PFMT64x, addr + i, left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// eprintf (\"[*] Initializing ESIL stack with pattern\\n\");\n\t\t// r_core_cmdf (core, \"woe 0 10 4 @ 0x%\"PFMT64x, size, addr);\n\t}\n}\n\nstatic void cmd_esil_mem(RCore *core, const char *input) {\n\tRAnalEsil *esil = core->anal->esil;\n\tRIOMap *stack_map;\n\tut64 curoff = core->offset;\n\tconst char *patt = \"\";\n\tut64 addr = 0x100000;\n\tut32 size = 0xf0000;\n\tchar name[128];\n\tRFlagItem *fi;\n\tconst char *sp, *pc;\n\tchar uri[32];\n\tchar nomalloc[256];\n\tchar *p;\n\tif (!esil) {\n\t\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\t\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\t\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\t\tint stats = r_config_get_i (core->config, \"esil.stats\");\n\t\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\t\tint verbose = r_config_get_i (core->config, \"esil.verbose\");\n\t\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\t\tif (!(esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\t\tcore->anal->esil = esil;\n\t\tesil->verbose = verbose;\n\t\t{\n\t\t\tconst char *s = r_config_get (core->config, \"cmd.esil.intr\");\n\t\t\tif (s) {\n\t\t\t\tchar *my = strdup (s);\n\t\t\t\tif (my) {\n\t\t\t\t\tr_config_set (core->config, \"cmd.esil.intr\", my);\n\t\t\t\t\tfree (my);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (*input == '?') {\n\t\teprintf (\"Usage: aeim [addr] [size] [name] - initialize ESIL VM stack\\n\");\n\t\teprintf (\"Default: 0x100000 0xf0000\\n\");\n\t\teprintf (\"See ae? for more help\\n\");\n\t\treturn;\n\t}\n\n\tif (input[0] == 'p') {\n\t\tfi = r_flag_get (core->flags, \"aeim.stack\");\n\t\tif (fi) {\n\t\t\taddr = fi->offset;\n\t\t\tsize = fi->size;\n\t\t} else {\n\t\t\tcmd_esil_mem (core, \"\");\n\t\t}\n\t\tif (esil) {\n\t\t\tesil->stack_addr = addr;\n\t\t\tesil->stack_size = size;\n\t\t}\n\t\tinitialize_stack (core, addr, size);\n\t\treturn;\n\t}\n\n\tif (!*input) {\n\t\tRFlagItem *fi = r_flag_get (core->flags, \"aeim.fd\");\n\t\tif (fi) {\n\t\t\t// Close the fd associated with the aeim stack\n\t\t\t(void)r_io_fd_close (core->io, fi->offset);\n\t\t}\n\t}\n\taddr = r_config_get_i (core->config, \"esil.stack.addr\");\n\tsize = r_config_get_i (core->config, \"esil.stack.size\");\n\tpatt = r_config_get (core->config, \"esil.stack.pattern\");\n\n\tp = strncpy (nomalloc, input, 255);\n\tif ((p = strchr (p, ' '))) {\n\t\twhile (*p == ' ') p++;\n\t\taddr = r_num_math (core->num, p);\n\t\tif ((p = strchr (p, ' '))) {\n\t\t\twhile (*p == ' ') p++;\n\t\t\tsize = (ut32)r_num_math (core->num, p);\n\t\t\tif (size < 1) {\n\t\t\t\tsize = 0xf0000;\n\t\t\t}\n\t\t\tif ((p = strchr (p, ' '))) {\n\t\t\t\twhile (*p == ' ') p++;\n\t\t\t\tsnprintf (name, sizeof (name), \"mem.%s\", p);\n\t\t\t} else {\n\t\t\t\tsnprintf (name, sizeof (name), \"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf (name, sizeof (name), \"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t\t}\n\t} else {\n\t\tsnprintf (name, sizeof (name), \"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t}\n\tif (*input == '-') {\n\t\tif (esil->stack_fd > 2) {\t//0, 1, 2 are reserved for stdio/stderr\n\t\t\tr_io_fd_close (core->io, esil->stack_fd);\n\t\t\t// no need to kill the maps, r_io_map_cleanup does that for us in the close\n\t\t\tesil->stack_fd = 0;\n\t\t} else {\n\t\t\teprintf (\"Cannot deinitialize %s\\n\", name);\n\t\t}\n\t\tr_flag_unset_name (core->flags, name);\n\t\t// eprintf (\"Deinitialized %s\\n\", name);\n\t\treturn;\n\t}\n\n\tsnprintf (uri, sizeof (uri), \"malloc://%d\", (int)size);\n\tesil->stack_fd = r_io_fd_open (core->io, uri, R_IO_RW, 0);\n\tif (!(stack_map = r_io_map_add (core->io, esil->stack_fd,\n\t\t\tR_IO_RW, 0LL, addr, size, true))) {\n\t\tr_io_fd_close (core->io, esil->stack_fd);\n\t\teprintf (\"Cannot create map for tha stack, fd %d got closed again\\n\", esil->stack_fd);\n\t\tesil->stack_fd = 0;\n\t\treturn;\n\t}\n\tr_io_map_set_name (stack_map, name);\n\t// r_flag_set (core->flags, name, addr, size);\t//why is this here?\n\tr_flag_set (core->flags, \"aeim.stack\", addr, size);\n\tr_flag_set (core->flags, \"aeim.fd\", esil->stack_fd, 1);\n\tr_config_set_i (core->config, \"io.va\", true);\n\tif (patt && *patt) {\n\t\tswitch (*patt) {\n\t\tcase '0':\n\t\t\t// do nothing\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tr_core_cmdf (core, \"wopD %d @ 0x%\"PFMT64x, size, addr);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tr_core_cmdf (core, \"woe 0 255 1 @ 0x%\"PFMT64x\"!%d\",addr, size);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tr_core_cmdf (core, \"woe 0 0xffff 1 4 @ 0x%\"PFMT64x\"!%d\",addr, size);\n\t\t\tbreak;\n\t\t}\n\t}\n\t// SP\n\tsp = r_reg_get_name (core->dbg->reg, R_REG_NAME_SP);\n\tr_debug_reg_set (core->dbg, sp, addr + (size / 2));\n\t// BP\n\tsp = r_reg_get_name (core->dbg->reg, R_REG_NAME_BP);\n\tr_debug_reg_set (core->dbg, sp, addr + (size / 2));\n\t// PC\n\tpc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\tr_debug_reg_set (core->dbg, pc, curoff);\n\tr_core_cmd0 (core, \".ar*\");\n#if 0\n\tif (!r_io_section_get_name (core->io, ESIL_STACK_NAME)) {\n\t\tr_core_cmdf (core, \"om %d 0x%\"PFMT64x, cf->fd, addr);\n\t\tr_core_cmdf (core, \"S 0x%\"PFMT64x\" 0x%\"PFMT64x\" %d %d \"\n\t\t\tESIL_STACK_NAME, addr, addr, size, size);\n\t}\n#endif\n\tif (esil) {\n\t\tesil->stack_addr = addr;\n\t\tesil->stack_size = size;\n\t}\n\tinitialize_stack (core, addr, size);\n\tr_core_seek (core, curoff, 0);\n}\n\n#if 0\nstatic ut64 opc = UT64_MAX;\nstatic ut8 *regstate = NULL;\n\nstatic void esil_init (RCore *core) {\n\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\topc = r_reg_getv (core->anal->reg, pc);\n\tif (!opc || opc==UT64_MAX) {\n\t\topc = core->offset;\n\t}\n\tif (!core->anal->esil) {\n\t\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\t\tut64 stackSize = r_config_get_i (core->config, \"esil.stack.size\");\n\t\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\t\tif (!(core->anal->esil = r_anal_esil_new (stackSize, iotrap, addrsize))) {\n\t\t\tR_FREE (regstate);\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_setup (core->anal->esil, core->anal, 0, 0, noNULL);\n\t}\n\tfree (regstate);\n\tregstate = r_reg_arena_peek (core->anal->reg);\n}\n\nstatic void esil_fini(RCore *core) {\n\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tr_reg_arena_poke (core->anal->reg, regstate);\n\tr_reg_setv (core->anal->reg, pc, opc);\n\tR_FREE (regstate);\n}\n#endif\n\ntypedef struct {\n\tRList *regs;\n\tRList *regread;\n\tRList *regwrite;\n\tRList *inputregs;\n} AeaStats;\n\nstatic void aea_stats_init (AeaStats *stats) {\n\tstats->regs = r_list_newf (free);\n\tstats->regread = r_list_newf (free);\n\tstats->regwrite = r_list_newf (free);\n\tstats->inputregs = r_list_newf (free);\n}\n\nstatic void aea_stats_fini (AeaStats *stats) {\n\tR_FREE (stats->regs);\n\tR_FREE (stats->regread);\n\tR_FREE (stats->regwrite);\n\tR_FREE (stats->inputregs);\n}\n\nstatic bool contains(RList *list, const char *name) {\n\tRListIter *iter;\n\tconst char *n;\n\tr_list_foreach (list, iter, n) {\n\t\tif (!strcmp (name, n))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic char *oldregread = NULL;\nstatic RList *mymemxsr = NULL;\nstatic RList *mymemxsw = NULL;\n\n#define R_NEW_DUP(x) memcpy((void*)malloc(sizeof(x)), &(x), sizeof(x))\ntypedef struct {\n\tut64 addr;\n\tint size;\n} AeaMemItem;\n\nstatic int mymemwrite(RAnalEsil *esil, ut64 addr, const ut8 *buf, int len) {\n\tRListIter *iter;\n\tAeaMemItem *n;\n\tr_list_foreach (mymemxsw, iter, n) {\n\t\tif (addr == n->addr) {\n\t\t\treturn len;\n\t\t}\n\t}\n\tif (!r_io_is_valid_offset (esil->anal->iob.io, addr, 0)) {\n\t\treturn false;\n\t}\n\tn = R_NEW (AeaMemItem);\n\tif (n) {\n\t\tn->addr = addr;\n\t\tn->size = len;\n\t\tr_list_push (mymemxsw, n);\n\t}\n\treturn len;\n}\n\nstatic int mymemread(RAnalEsil *esil, ut64 addr, ut8 *buf, int len) {\n\tRListIter *iter;\n\tAeaMemItem *n;\n\tr_list_foreach (mymemxsr, iter, n) {\n\t\tif (addr == n->addr) {\n\t\t\treturn len;\n\t\t}\n\t}\n\tif (!r_io_is_valid_offset (esil->anal->iob.io, addr, 0)) {\n\t\treturn false;\n\t}\n\tn = R_NEW (AeaMemItem);\n\tif (n) {\n\t\tn->addr = addr;\n\t\tn->size = len;\n\t\tr_list_push (mymemxsr, n);\n\t}\n\treturn len;\n}\n\nstatic int myregwrite(RAnalEsil *esil, const char *name, ut64 *val) {\n\tAeaStats *stats = esil->user;\n\tif (oldregread && !strcmp (name, oldregread)) {\n\t\tr_list_pop (stats->regread);\n\t\tR_FREE (oldregread)\n\t}\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regwrite, name)) {\n\t\t\tr_list_push (stats->regwrite, strdup (name));\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int myregread(RAnalEsil *esil, const char *name, ut64 *val, int *len) {\n\tAeaStats *stats = esil->user;\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->inputregs, name)) {\n\t\t\tif (!contains (stats->regwrite, name)) {\n\t\t\t\tr_list_push (stats->inputregs, strdup (name));\n\t\t\t}\n\t\t}\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regread, name)) {\n\t\t\tr_list_push (stats->regread, strdup (name));\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void showregs (RList *list) {\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tr_cons_print (reg);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_newline();\n}\n\nstatic void showregs_json (RList *list) {\n\tr_cons_printf (\"[\");\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tr_cons_printf (\"\\\"%s\\\"\", reg);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_printf (\"]\");\n}\n\nstatic bool cmd_aea(RCore* core, int mode, ut64 addr, int length) {\n\tRAnalEsil *esil;\n\tint ptr, ops, ops_end = 0, len, buf_sz, maxopsize;\n\tut64 addr_end;\n\tAeaStats stats;\n\tconst char *esilstr;\n\tRAnalOp aop = R_EMPTY;\n\tut8 *buf;\n\tRList* regnow;\n\tif (!core) {\n\t\treturn false;\n\t}\n\tmaxopsize = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\tif (maxopsize < 1) {\n\t\tmaxopsize = 16;\n\t}\n\tif (mode & 1) {\n\t\t// number of bytes / length\n\t\tbuf_sz = length;\n\t} else {\n\t\t// number of instructions / opcodes\n\t\tops_end = length;\n\t\tif (ops_end < 1) {\n\t\t\tops_end = 1;\n\t\t}\n\t\tbuf_sz = ops_end * maxopsize;\n\t}\n\tif (buf_sz < 1) {\n\t\tbuf_sz = maxopsize;\n\t}\n\taddr_end = addr + buf_sz;\n\tbuf = malloc (buf_sz);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\t(void)r_io_read_at (core->io, addr, (ut8 *)buf, buf_sz);\n\taea_stats_init (&stats);\n\n\t//esil_init (core);\n\t//esil = core->anal->esil;\n\tr_reg_arena_push (core->anal->reg);\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tbool iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\tint stats1 = r_config_get_i (core->config, \"esil.stats\");\n\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tesil = r_anal_esil_new (stacksize, iotrap, addrsize);\n\tr_anal_esil_setup (esil, core->anal, romem, stats1, noNULL); // setup io\n#\tdefine hasNext(x) (x&1) ? (addr<addr_end) : (ops<ops_end)\n\n\tmymemxsr = r_list_new ();\n\tmymemxsw = r_list_new ();\n\tesil->user = &stats;\n\tesil->cb.hook_reg_write = myregwrite;\n\tesil->cb.hook_reg_read = myregread;\n\tesil->cb.hook_mem_write = mymemwrite;\n\tesil->cb.hook_mem_read = mymemread;\n\tesil->nowrite = true;\n\tfor (ops = ptr = 0; ptr < buf_sz && hasNext (mode); ops++, ptr += len) {\n\t\tlen = r_anal_op (core->anal, &aop, addr + ptr, buf + ptr, buf_sz - ptr, R_ANAL_OP_MASK_ALL);\n\t\tesilstr = R_STRBUF_SAFEGET (&aop.esil);\n\t\tif (len < 1) {\n\t\t\teprintf (\"Invalid 0x%08\"PFMT64x\" instruction %02x %02x\\n\",\n\t\t\t\taddr + ptr, buf[ptr], buf[ptr + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_parse (esil, esilstr);\n\t\tr_anal_esil_stack_free (esil);\n\t}\n\tesil->nowrite = false;\n\tesil->cb.hook_reg_write = NULL;\n\tesil->cb.hook_reg_read = NULL;\n\t//esil_fini (core);\n\tr_anal_esil_free (esil);\n\tr_reg_arena_pop (core->anal->reg);\n\tregnow = r_list_newf (free);\n\t{\n\t\tRListIter *iter;\n\t\tchar *reg;\n\t\tr_list_foreach (stats.regs, iter, reg) {\n\t\t\tif (!contains (stats.regwrite, reg)) {\n\t\t\t\tr_list_push (regnow, strdup (reg));\n\t\t\t}\n\t\t}\n\t}\n\tif ((mode >> 5) & 1) {\n\t\tRListIter *iter;\n\t\tAeaMemItem *n;\n\t\tint c = 0;\n\t\tr_cons_printf (\"f-mem.*\\n\");\n\t\tr_list_foreach (mymemxsr, iter, n) {\n\t\t\tr_cons_printf (\"f mem.read.%d 0x%08x @ 0x%08\"PFMT64x\"\\n\", c++, n->size, n->addr);\n\t\t}\n\t\tc = 0;\n\t\tr_list_foreach (mymemxsw, iter, n) {\n\t\t\tr_cons_printf (\"f mem.write.%d 0x%08x @ 0x%08\"PFMT64x\"\\n\", c++, n->size, n->addr);\n\t\t}\n\t}\n\n\t/* show registers used */\n\tif ((mode >> 1) & 1) {\n\t\tshowregs (stats.regread);\n\t} else if ((mode >> 2) & 1) {\n\t\tshowregs (stats.regwrite);\n\t} else if ((mode >> 3) & 1) {\n\t\tshowregs (regnow);\n\t} else if ((mode >> 4) & 1) {\n\t\tr_cons_printf (\"{\\\"A\\\":\");\n\t\tshowregs_json (stats.regs);\n\t\tr_cons_printf (\",\\\"I\\\":\");\n\t\tshowregs_json (stats.inputregs);\n\t\tr_cons_printf (\",\\\"R\\\":\");\n\t\tshowregs_json (stats.regread);\n\t\tr_cons_printf (\",\\\"W\\\":\");\n\t\tshowregs_json (stats.regwrite);\n\t\tr_cons_printf (\",\\\"N\\\":\");\n\t\tshowregs_json (regnow);\n\t\tr_cons_printf (\"}\");\n\t\tr_cons_newline();\n\t} else if ((mode >> 5) & 1) {\n\t\t// nothing\n\t} else {\n\t\tr_cons_printf (\" I: \");\n\t\tshowregs (stats.inputregs);\n\t\tr_cons_printf (\" A: \");\n\t\tshowregs (stats.regs);\n\t\tr_cons_printf (\" R: \");\n\t\tshowregs (stats.regread);\n\t\tr_cons_printf (\" W: \");\n\t\tshowregs (stats.regwrite);\n\t\tr_cons_printf (\"NW: \");\n\t\tif (r_list_length (regnow)) {\n\t\t\tshowregs (regnow);\n\t\t} else {\n\t\t\tr_cons_newline();\n\t\t}\n\t\tRListIter *iter;\n\t\tut64 *n;\n\t\tif (!r_list_empty (mymemxsr)) {\n\t\t\tr_cons_printf (\"@R:\");\n\t\t\tr_list_foreach (mymemxsr, iter, n) {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, *n);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tif (!r_list_empty (mymemxsw)) {\n\t\t\tr_cons_printf (\"@W:\");\n\t\t\tr_list_foreach (mymemxsw, iter, n) {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, *n);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\tr_list_free (mymemxsr);\n\tr_list_free (mymemxsw);\n\tmymemxsr = NULL;\n\tmymemxsw = NULL;\n\taea_stats_fini (&stats);\n\tfree (buf);\n\tR_FREE (regnow);\n\treturn true;\n}\n\nstatic void cmd_aespc(RCore *core, ut64 addr, int off) {\n\tRAnalEsil *esil = core->anal->esil;\n\tint i, j = 0;\n\tint instr_size = 0;\n\tut8 *buf;\n\tRAnalOp aop = {0};\n\tint ret , bsize = R_MAX (64, core->blocksize);\n\tconst int mininstrsz = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = R_MAX (1, mininstrsz);\n\tconst char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\tRRegItem *r = r_reg_get (core->dbg->reg, pc, -1);\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\n\tif (!esil) {\n\t\tif (!(esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\t\treturn;\n\t\t}\n\t}\n\tbuf = malloc (bsize);\n\tif (!buf) {\n\t\teprintf (\"Cannot allocate %d byte(s)\\n\", bsize);\n\t\tfree (buf);\n\t\treturn;\n\t}\n\tif (addr == -1) {\n\t\taddr = r_debug_reg_get (core->dbg, pc);\n\t}\n\tut64 curpc = addr;\n\tut64 oldoff = core->offset;\n\tfor (i = 0, j = 0; j < off ; i++, j++) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= (bsize - 32)) {\n\t\t\ti = 0;\n\t\t}\n\t\tif (!i) {\n\t\t\tr_core_read_at (core, addr, buf, bsize);\n\t\t}\n\t\tret = r_anal_op (core->anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_ALL);\n\t\tinstr_size += ret;\n\t\tint inc = (core->search->align > 0)? core->search->align - 1: ret - 1;\n\t\tif (inc < 0) {\n\t\t\tinc = minopcode;\n\t\t}\n\t\ti += inc;\n\t\taddr += inc;\n\t\tr_anal_op_fini (&aop);\n\t}\n\tr_reg_set_value (core->dbg->reg, r, curpc);\n\tr_core_esil_step (core, curpc + instr_size, NULL, NULL);\n\tr_core_seek (core, oldoff, 1);\n}\n\nstatic void cmd_anal_esil(RCore *core, const char *input) {\n\tRAnalEsil *esil = core->anal->esil;\n\tut64 addr = core->offset;\n\tut64 adr ;\n\tchar *n, *n1;\n\tint off;\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\tint stats = r_config_get_i (core->config, \"esil.stats\");\n\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\tut64 until_addr = UT64_MAX;\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\n\tconst char *until_expr = NULL;\n\tRAnalOp *op;\n\n\tswitch (input[0]) {\n\tcase 'p': // \"aep\"\n\t\tswitch (input[1]) {\n\t\tcase 'c':\n\t\t\tif (input[2] == ' ') {\n\t\t\t\t// seek to this address\n\t\t\t\tr_core_cmdf (core, \"ar PC=%s\", input + 3);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t} else {\n\t\t\t\teprintf (\"Missing argument\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tr_anal_pin_list (core->anal);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (input[2])\n\t\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t\tr_anal_pin_unset (core->anal, addr);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tr_anal_pin (core->anal, addr, input + 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_aep);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"aer\"\n\t\t// 'aer' is an alias for 'ar'\n\t\tcmd_anal_reg (core, input + 1);\n\t\tbreak;\n\tcase '*':\n\t\t// XXX: this is wip, not working atm\n\t\tif (core->anal->esil) {\n\t\t\tr_cons_printf (\"trap: %d\\n\", core->anal->esil->trap);\n\t\t\tr_cons_printf (\"trap-code: %d\\n\", core->anal->esil->trap_code);\n\t\t} else {\n\t\t\teprintf (\"esil vm not initialized. run `aei`\\n\");\n\t\t}\n\t\tbreak;\n\tcase ' ':\n\t\t//r_anal_esil_eval (core->anal, input+1);\n\t\tif (!esil) {\n\t\t\tif (!(core->anal->esil = esil = r_anal_esil_new (stacksize, iotrap, addrsize)))\n\t\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\t\tr_anal_esil_set_pc (esil, core->offset);\n\t\tr_anal_esil_parse (esil, input + 1);\n\t\tr_anal_esil_dumpstack (esil);\n\t\tr_anal_esil_stack_free (esil);\n\t\tbreak;\n\tcase 's': // \"aes\"\n\t\t// \"aes\" \"aeso\" \"aesu\" \"aesue\"\n\t\t// aes -> single step\n\t\t// aesb -> single step back\n\t\t// aeso -> single step over\n\t\t// aesu -> until address\n\t\t// aesue -> until esil expression\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\teprintf (\"See: ae?~aes\\n\");\n\t\t\tbreak;\n\t\tcase 'l': // \"aesl\"\n\t\t{\n\t\t\tut64 pc = r_debug_reg_get (core->dbg, \"PC\");\n\t\t\tRAnalOp *op = r_core_anal_op (core, pc);\n// TODO: honor hint\n\t\t\tif (!op) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL);\n\t\t\tr_debug_reg_set (core->dbg, \"PC\", pc + op->size);\n\t\t\tr_anal_esil_set_pc (esil, pc + op->size);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t} break;\n\t\tcase 'b': // \"aesb\"\n\t\t\tif (!r_core_esil_step_back (core)) {\n\t\t\t\teprintf (\"cannnot step back\\n\");\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'u': // \"aesu\"\n\t\t\tif (input[2] == 'e') {\n\t\t\t\tuntil_expr = input + 3;\n\t\t\t} else {\n\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t}\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'o': // \"aeso\"\n\t\t\t// step over\n\t\t\top = r_core_anal_op (core, r_reg_getv (core->anal->reg,\n\t\t\t\tr_reg_get_name (core->anal->reg, R_REG_NAME_PC)));\n\t\t\tif (op && op->type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\tuntil_addr = op->addr + op->size;\n\t\t\t}\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\tr_anal_op_free (op);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'p': //\"aesp\"\n\t\t\tn = strchr (input, ' ');\n\t\t\tn1 = n ? strchr (n + 1, ' ') : NULL;\n\t\t\tif ((!n || !n1) || (!(n + 1) || !(n1 + 1))) {\n\t\t\t\teprintf (\"aesp [offset] [num]\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadr = r_num_math (core->num, n + 1);\n\t\t\toff = r_num_math (core->num, n1 + 1);\n\t\t\tcmd_aespc (core, adr, off);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tn = strchr (input, ' ');\n\t\t\tif (!(n + 1)) {\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toff = r_num_math (core->num, n + 1);\n\t\t\tcmd_aespc (core, -1, off);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aec\"\n\t\tif (input[1] == '?') { // \"aec?\"\n\t\t\tr_core_cmd_help (core, help_msg_aec);\n\t\t} else if (input[1] == 's') { // \"aecs\"\n\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\tut64 newaddr;\n\t\t\tint ret;\n\t\t\tfor (;;) {\n\t\t\t\top = r_core_anal_op (core, addr);\n\t\t\t\tif (!op) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_SWI) {\n\t\t\t\t\teprintf (\"syscall at 0x%08\" PFMT64x \"\\n\", addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_TRAP) {\n\t\t\t\t\teprintf (\"trap at 0x%08\" PFMT64x \"\\n\", addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = r_core_esil_step (core, UT64_MAX, NULL, NULL);\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\top = NULL;\n\t\t\t\tif (core->anal->esil->trap || core->anal->esil->trap_code) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t\tnewaddr = r_num_get (core->num, pc);\n\t\t\t\tif (addr == newaddr) {\n\t\t\t\t\taddr++;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\taddr = newaddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t}\n\t\t} else {\n\t\t\t// \"aec\"  -> continue until ^C\n\t\t\t// \"aecu\" -> until address\n\t\t\t// \"aecue\" -> until esil expression\n\t\t\tif (input[1] == 'u' && input[2] == 'e')\n\t\t\t\tuntil_expr = input + 3;\n\t\t\telse if (input[1] == 'u')\n\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\telse until_expr = \"0\";\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"aei\"\n\t\tswitch (input[1]) {\n\t\tcase 's':\n\t\tcase 'm': // \"aeim\"\n\t\t\tcmd_esil_mem (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'p': // initialize pc = $$\n\t\t\tr_core_cmd0 (core, \"ar PC=$$\");\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tcmd_esil_mem (core, \"?\");\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (esil) {\n\t\t\t\tsdb_reset (esil->stats);\n\t\t\t}\n\t\t\tr_anal_esil_free (esil);\n\t\t\tcore->anal->esil = NULL;\n\t\t\tbreak;\n\t\tcase 0:\t\t\t\t//lolololol\n\t\t\tr_anal_esil_free (esil);\n\t\t\t// reinitialize\n\t\t\t{\n\t\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\t\tif (r_reg_getv (core->anal->reg, pc) == 0LL) {\n\t\t\t\t\tr_core_cmd0 (core, \"ar PC=$$\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(esil = core->anal->esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\t\t\tesil->verbose = (int)r_config_get_i (core->config, \"esil.verbose\");\n\t\t\t/* restore user settings for interrupt handling */\n\t\t\t{\n\t\t\t\tconst char *s = r_config_get (core->config, \"cmd.esil.intr\");\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *my = strdup (s);\n\t\t\t\t\tif (my) {\n\t\t\t\t\t\tr_config_set (core->config, \"cmd.esil.intr\", my);\n\t\t\t\t\t\tfree (my);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"aek\"\n\t\tswitch (input[1]) {\n\t\tcase '\\0':\n\t\t\tinput = \"123*\";\n\t\t\t/* fall through */\n\t\tcase ' ':\n\t\t\tif (esil && esil->stats) {\n\t\t\t\tchar *out = sdb_querys (esil->stats, NULL, 0, input + 2);\n\t\t\t\tif (out) {\n\t\t\t\t\tr_cons_println (out);\n\t\t\t\t\tfree (out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"esil.stats is empty. Run 'aei'\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (esil) {\n\t\t\t\tsdb_reset (esil->stats);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"aef\"\n\t{\n\t\tRListIter *iter;\n\t\tRAnalBlock *bb;\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal,\n\t\t\t\t\t\t\tcore->offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\t// emulate every instruction in the function recursively across all the basic blocks\n\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\tut64 pc = bb->addr;\n\t\t\t\tut64 end = bb->addr + bb->size;\n\t\t\t\tRAnalOp op;\n\t\t\t\tut8 *buf;\n\t\t\t\tint ret, bbs = end - pc;\n\t\t\t\tif (bbs < 1 || bbs > 0xfffff) {\n\t\t\t\t\teprintf (\"Invalid block size\\n\");\n\t\t\t\t}\n\t\t//\t\teprintf (\"[*] Emulating 0x%08\"PFMT64x\" basic block 0x%08\" PFMT64x \" - 0x%08\" PFMT64x \"\\r[\", fcn->addr, pc, end);\n\t\t\t\tbuf = calloc (1, bbs + 1);\n\t\t\t\tr_io_read_at (core->io, pc, buf, bbs);\n\t\t\t\tint left;\n\t\t\t\twhile (pc < end) {\n\t\t\t\t\tleft = R_MIN (end - pc, 32);\n\t\t\t\t\tr_asm_set_pc (core->assembler, pc);\n\t\t\t\t\tret = r_anal_op (core->anal, &op, addr, buf, left, R_ANAL_OP_MASK_ALL); // read overflow\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tr_reg_set_value_by_role (core->anal->reg, R_REG_NAME_PC, pc);\n\t\t\t\t\t\tr_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op.esil));\n\t\t\t\t\t\tr_anal_esil_dumpstack (esil);\n\t\t\t\t\t\tr_anal_esil_stack_free (esil);\n\t\t\t\t\t\tpc += op.size;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpc += 4; // XXX\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot find function at 0x%08\" PFMT64x \"\\n\", core->offset);\n\t\t}\n\t} break;\n\tcase 't': // \"aet\"\n\t\tswitch (input[1]) {\n\t\tcase 'r': // \"aetr\"\n\t\t{\n\t\t\t// anal ESIL to REIL.\n\t\t\tRAnalEsil *esil = r_anal_esil_new (stacksize, iotrap, addrsize);\n\t\t\tif (!esil)\n\t\t\t\treturn;\n\t\t\tr_anal_esil_to_reil_setup (esil, core->anal, romem, stats);\n\t\t\tr_anal_esil_set_pc (esil, core->offset);\n\t\t\tr_anal_esil_parse (esil, input + 2);\n\t\t\tr_anal_esil_dumpstack (esil);\n\t\t\tr_anal_esil_free (esil);\n\t\t\tbreak;\n\t\t}\n\t\tcase 's': // \"aets\"\n\t\t\tswitch (input[2]) {\n\t\t\tcase 0:\n\t\t\t\tr_anal_esil_session_list (esil);\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tr_anal_esil_session_add (esil);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_core_cmd_help (core, help_msg_aets);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown command. Use `aetr`.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'A': // \"aeA\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aea);\n\t\t} else if (input[1] == 'r') {\n\t\t\tcmd_aea (core, 1 + (1<<1), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'w') {\n\t\t\tcmd_aea (core, 1 + (1<<2), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'n') {\n\t\t\tcmd_aea (core, 1 + (1<<3), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'j') {\n\t\t\tcmd_aea (core, 1 + (1<<4), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == '*') {\n\t\t\tcmd_aea (core, 1 + (1<<5), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'f') {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tcmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));\n\t\t\t}\n\t\t} else {\n\t\t\tcmd_aea (core, 1, core->offset, (int)r_num_math (core->num, input+2));\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"aea\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aea);\n\t\t} else if (input[1] == 'r') {\n\t\t\tcmd_aea (core, 1<<1, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'w') {\n\t\t\tcmd_aea (core, 1<<2, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'n') {\n\t\t\tcmd_aea (core, 1<<3, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'j') {\n\t\t\tcmd_aea (core, 1<<4, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == '*') {\n\t\t\tcmd_aea (core, 1<<5, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'f') {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n                        // \"aeafj\"\n\t\t\tif (fcn) {\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase 'j': // \"aeafj\"\n\t\t\t\t\tcmd_aea (core, 1<<4, fcn->addr, r_anal_fcn_size (fcn));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *arg = input[1]? input + 2: \"\";\n\t\t\tut64 len = r_num_math (core->num, arg);\n\t\t\tcmd_aea (core, 0, core->offset, len);\n\t\t}\n\t\tbreak;\n\tcase 'x': { // \"aex\"\n\t\tchar *hex;\n\t\tint ret, bufsz;\n\n\t\tinput = r_str_trim_ro (input + 1);\n\t\thex = strdup (input);\n\t\tif (!hex) {\n\t\t\tbreak;\n\t\t}\n\n\t\tRAnalOp aop = R_EMPTY;\n\t\tbufsz = r_hex_str2bin (hex, (ut8*)hex);\n\t\tret = r_anal_op (core->anal, &aop, core->offset,\n\t\t\t(const ut8*)hex, bufsz, R_ANAL_OP_MASK_ALL);\n\t\tif (ret>0) {\n\t\t\tconst char *str = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\tchar *str2 = r_str_newf (\" %s\", str);\n\t\t\tcmd_anal_esil (core, str2);\n\t\t\tfree (str2);\n\t\t}\n\t\tr_anal_op_fini (&aop);\n\t\tbreak;\n\t}\n\tcase '?': // \"ae?\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_detail_ae);\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ae);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_bytes(RCore *core, const char *input) {\n\tint len = core->blocksize;\n\tint tbs = len;\n\tif (input[0]) {\n\t\tlen = (int)r_num_get (core->num, input + 1);\n\t\tif (len > tbs) {\n\t\t\tr_core_block_size (core, len);\n\t\t}\n\t}\n\tcore_anal_bytes (core, core->block, len, 0, input[0]);\n\tif (tbs != core->blocksize) {\n\t\tr_core_block_size (core, tbs);\n\t}\n}\n\nstatic void cmd_anal_opcode(RCore *core, const char *input) {\n\tint l, len = core->blocksize;\n\tut32 tbs = core->blocksize;\n\n\tswitch (input[0]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ao);\n\t\tbreak;\n\tcase 's': // \"aos\"\n\tcase 'j': // \"aoj\"\n\tcase 'e': // \"aoe\"\n\tcase 'r': {\n\t\tint count = 1;\n\t\tif (input[1] && input[2]) {\n\t\t\tl = (int)r_num_get (core->num, input + 1);\n\t\t\tif (l > 0) {\n\t\t\t\tcount = l;\n\t\t\t}\n\t\t\tif (l > tbs) {\n\t\t\t\tr_core_block_size (core, l * 4);\n\t\t\t//\tlen = l;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = l = core->blocksize;\n\t\t\tcount = 1;\n\t\t}\n\t\tcore_anal_bytes (core, core->block, len, count, input[0]);\n\t\t}\n\t\tbreak;\n\tcase '*':\n\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\tbreak;\n\tdefault: {\n\t\tint count = 0;\n\t\tif (input[0]) {\n\t\t\tl = (int)r_num_get (core->num, input + 1);\n\t\t\tif (l > 0) {\n\t\t\t\tcount = l;\n\t\t\t}\n\t\t\tif (l > tbs) {\n\t\t\t\tr_core_block_size (core, l * 4);\n\t\t\t\t//len = l;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = l = core->blocksize;\n\t\t\tcount = 1;\n\t\t}\n\t\tcore_anal_bytes (core, core->block, len, count, 0);\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic void cmd_anal_jumps(RCore *core, const char *input) {\n\tr_core_cmdf (core, \"af @@= `ax~ref.code.jmp[1]`\");\n}\n\n// TODO: cleanup to reuse code\nstatic void cmd_anal_aftertraps(RCore *core, const char *input) {\n\tint bufi, minop = 1; // 4\n\tut8 *buf;\n\tRBinFile *binfile;\n\tRAnalOp op;\n\tut64 addr, addr_end;\n\tut64 len = r_num_math (core->num, input);\n\tif (len > 0xffffff) {\n\t\teprintf (\"Too big\\n\");\n\t\treturn;\n\t}\n\tbinfile = r_core_bin_cur (core);\n\tif (!binfile) {\n\t\teprintf (\"cur binfile NULL\\n\");\n\t\treturn;\n\t}\n\taddr = core->offset;\n\tif (!len) {\n\t\t// ignore search.in to avoid problems. analysis != search\n\t\tRIOSection *sec = r_io_section_vget (core->io, addr);\n\t\tif (sec && sec->flags & 1) {\n\t\t\t// search in current section\n\t\t\tif (sec->size > binfile->size) {\n\t\t\t\taddr = sec->vaddr;\n\t\t\t\tif (binfile->size > sec->paddr) {\n\t\t\t\t\tlen = binfile->size - sec->paddr;\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Opps something went wrong aac\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr = sec->vaddr;\n\t\t\t\tlen = sec->size;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sec && sec->vaddr != sec->paddr && binfile->size > (core->offset - sec->vaddr + sec->paddr)) {\n\t\t\t\tlen = binfile->size - (core->offset - sec->vaddr + sec->paddr);\n\t\t\t} else {\n\t\t\t\tif (binfile->size > core->offset) {\n\t\t\t\t\tlen = binfile->size - core->offset;\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Oops invalid range\\n\");\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taddr_end = addr + len;\n\tif (!(buf = malloc (4096))) {\n\t\treturn;\n\t}\n\tbufi = 0;\n\tint trapcount = 0;\n\tint nopcount = 0;\n\tr_cons_break_push (NULL, NULL);\n\twhile (addr < addr_end) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > 4000) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\tr_io_read_at (core->io, addr, buf, 4096);\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, 4096 - bufi, R_ANAL_OP_MASK_ALL)) {\n\t\t\tif (op.size < 1) {\n\t\t\t\t// XXX must be +4 on arm/mips/.. like we do in disasm.c\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_TRAP) {\n\t\t\t\ttrapcount ++;\n\t\t\t} else if (op.type == R_ANAL_OP_TYPE_NOP) {\n\t\t\t\tnopcount ++;\n\t\t\t} else {\n\t\t\t\tif (nopcount > 1) {\n\t\t\t\t\tr_cons_printf (\"af @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\tnopcount = 0;\n\t\t\t\t}\n\t\t\t\tif (trapcount > 0) {\n\t\t\t\t\tr_cons_printf (\"af @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\ttrapcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += (op.size > 0)? op.size : 1;\n\t\tbufi += (op.size > 0)? op.size : 1;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n}\n\nstatic void cmd_anal_blocks(RCore *core, const char *input) {\n\tut64 from , to;\n\tchar *arg = strchr (input, ' ');\n\tr_cons_break_push (NULL, NULL);\n#if 0\n\tls_foreach (core->io->sections, iter, s) {\n\t\t/* is executable */\n\t\tif (!(s->flags & R_IO_EXEC)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmin = s->vaddr;\n\t\tmax = s->vaddr + s->vsize;\n\t\tr_core_cmdf (core, \"abb%s 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, input, (max - min), min);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tgoto ctrl_c;\n\t\t}\n\t}\n\tif (ls_empty (core->io->sections)) {\n\t\tmin = core->offset;\n\t\tmax = 0xffff + min;\n\t\tr_core_cmdf (core, \"abb%s 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, input, (max - min), min);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tgoto ctrl_c;\n\t\t}\n\t}\n#endif\n\tif (!arg) {\n\t\tRList *list = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, \"anal\");\n\t\tRListIter *iter;\n\t\tRIOMap* map;\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tfrom = map->itv.addr;\n\t\t\tto = r_itv_end (map->itv);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto ctrl_c;\n\t\t\t}\n\t\t\tif (!from && !to) {\n\t\t\t\teprintf (\"Cannot determine search boundaries\\n\");\n\t\t\t} else if (to - from > UT32_MAX) {\n\t\t\t\teprintf (\"Skipping huge range\\n\");\n\t\t\t} else {\n\t\t\t\tr_core_cmdf (core, \"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, (to - from), from);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint sz = r_num_math (core->num, arg + 1);\n\t\tr_core_cmdf (core, \"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, sz, core->offset);\n\t}\nctrl_c:\n\tr_cons_break_pop ();\n}\n\nstatic void _anal_calls(RCore *core, ut64 addr, ut64 addr_end) {\n\tRAnalOp op;\n\tint bufi;\n\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\tconst int addrbytes = core->io->addrbytes;\n\tconst int bsz = 4096;\n\tut8 *buf;\n\tut8 *block;\n\tbufi = 0;\n\tif (addr_end - addr > UT32_MAX) {\n\t\treturn;\n\t}\n\tbuf = malloc (bsz);\n\tblock = malloc (bsz);\n\tif (!buf || !block) {\n\t\teprintf (\"Error: cannot allocate buf or block\\n\");\n\t\tfree (buf);\n\t\tfree (block);\n\t\treturn;\n\t}\n\n\tint minop = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tif (minop < 1) {\n\t\tminop = 1;\n\t}\n\twhile (addr < addr_end) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > 4000) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\tr_io_read_at (core->io, addr, buf, bsz);\n\t\t}\n\t\tmemset (block, -1, bsz);\n\t\tif (!memcmp (buf, block, bsz)) {\n\t\t\t//eprintf (\"Error: skipping uninitialized block \\n\");\n\t\t\taddr += bsz;\n\t\t\tcontinue;\n\t\t}\n\t\tmemset (block, 0, bsz);\n\t\tif (!memcmp (buf, block, bsz)) {\n\t\t\t//eprintf (\"Error: skipping uninitialized block \\n\");\n\t\t\taddr += bsz;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, bsz - bufi, 0) > 0) {\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CALL) {\n#if JAYRO_03\n#error FUCK\n\t\t\t\tif (!anal_is_bad_call (core, from, to, addr, buf, bufi)) {\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, op.jump, R_ANAL_FCN_TYPE_ROOT);\n\t\t\t\t\tif (!fcn) {\n\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr,\n\t\t\t\t\t\t  R_ANAL_REF_TYPE_NULL, depth);\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\t// add xref here\n\t\t\t\tr_anal_xrefs_set (core->anal, R_ANAL_REF_TYPE_CALL, addr, op.jump);\n\t\t\t\tif (r_io_is_valid_offset (core->io, op.jump, 1)) {\n\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_NULL, depth);\n\t\t\t\t}\n#endif\n\t\t\t}\n\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\tif ((int)op.size < 1) {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += op.size;\n\t\tbufi += addrbytes * op.size;\n\t\tr_anal_op_fini (&op);\n\t}\n\tfree (buf);\n\tfree (block);\n}\n\nstatic void cmd_anal_calls(RCore *core, const char *input, bool only_print_flag) {\n\tRList *ranges = NULL;\n\tRIOMap *r;\n\tRBinFile *binfile;\n\tut64 addr;\n\tut64 len = r_num_math (core->num, input);\n\tif (len > 0xffffff) {\n\t\teprintf (\"Too big\\n\");\n\t\treturn;\n\t}\n\tbinfile = r_core_bin_cur (core);\n\taddr = core->offset;\n\tif (binfile) {\n\t\tif (len) {\n\t\t\tRIOMap *m = R_NEW0 (RIOMap);\n\t\t\tm->itv.addr = addr;\n\t\t\tm->itv.size = len;\n\t\t\tr_list_append (ranges, m);\n\t\t} else {\n\t\t\tranges = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, \"anal\");\n\t\t}\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tif (!binfile || !r_list_length (ranges)) {\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tr_list_free (ranges);\n\t\tranges = r_core_get_boundaries_prot (core, 0, NULL, \"anal\");\n\t\tr_list_foreach (ranges, iter, map) {\n\t\t\tut64 addr = map->itv.addr;\n\t\t\tif (only_print_flag) {\n\t\t\t\tr_cons_printf (\"f fcn.0x%08\"PFMT64x\" %d 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\taddr, map->itv.size, addr);\n\t\t\t} else {\n\t\t\t\t_anal_calls (core, addr, r_itv_end (map->itv));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tRListIter *iter;\n\t\tif (binfile) {\n\t\t\tr_list_foreach (ranges, iter, r) {\n\t\t\t\taddr = r->itv.addr;\n\t\t\t\t//this normally will happen on fuzzed binaries, dunno if with huge\n\t\t\t\t//binaries as well\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (only_print_flag) {\n\t\t\t\t\tr_cons_printf (\"f fcn.0x%08\"PFMT64x\" %d 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\taddr, r->itv.size, addr);\n\t\t\t\t} else {\n\t\t\t\t\t_anal_calls (core, addr, r_itv_end (r->itv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tr_list_free (ranges);\n}\n\nstatic void cmd_asf(RCore *core, const char *input) {\n\tchar *ret;\n\tif (input[0] == ' ') {\n\t\tret = sdb_querys (core->anal->sdb_fcnsign, NULL, 0, input + 1);\n\t} else {\n\t\tret = sdb_querys (core->anal->sdb_fcnsign, NULL, 0, \"*\");\n\t}\n\tif (ret && *ret) {\n\t\tr_cons_println (ret);\n\t}\n\tfree (ret);\n}\n\nstatic void cmd_anal_syscall(RCore *core, const char *input) {\n\tRSyscallItem *si;\n\tRListIter *iter;\n\tRList *list;\n\tRNum *num = NULL;\n\tchar *out;\n\tint n;\n\n\tswitch (input[0]) {\n\tcase 'c': // \"asc\"\n\t\tif (input[1] == 'a') {\n\t\t\tif (input[2] == ' ') {\n\t\t\t\tif (!isalpha (input[3]) && (n = r_num_math (num, input + 3)) >= 0 ) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\t\tif (si)\n\t\t\t\t\t\tr_cons_printf (\".equ SYS_%s %d\\n\", si->name, n);\n\t\t\t\t\telse eprintf (\"Unknown syscall number\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 3);\n\t\t\t\t\tif (n != -1) {\n\t\t\t\t\t\tr_cons_printf (\".equ SYS_%s %d\\n\", input + 3, n);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Unknown syscall name\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\t\tr_cons_printf (\".equ SYS_%s %d\\n\",\n\t\t\t\t\t\tsi->name, (ut32)si->num);\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t} else {\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tif (!isalpha (input[2]) && (n = r_num_math (num, input + 2)) >= 0 ) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\t\tif (si)\n\t\t\t\t\t\tr_cons_printf (\"#define SYS_%s %d\\n\", si->name, n);\n\t\t\t\t\telse eprintf (\"Unknown syscall number\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 2);\n\t\t\t\t\tif (n != -1) {\n\t\t\t\t\t\tr_cons_printf (\"#define SYS_%s %d\\n\", input + 2, n);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Unknown syscall name\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\t\tr_cons_printf (\"#define SYS_%s %d\\n\",\n\t\t\t\t\t\tsi->name, (ut32)si->num);\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"asf\"\n\t\tcmd_asf (core, input + 1);\n\t\tbreak;\n\tcase 'l': // \"asl\"\n\t\tif (input[1] == ' ') {\n\t\t\tif (!isalpha (input[2]) && (n = r_num_math (num, input + 2)) >= 0 ) {\n\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\tif (si)\n\t\t\t\t\tr_cons_println (si->name);\n\t\t\t\telse eprintf (\"Unknown syscall number\\n\");\n\t\t\t} else {\n\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 2);\n\t\t\t\tif (n != -1) {\n\t\t\t\t\tr_cons_printf (\"%d\\n\", n);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Unknown syscall name\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\tr_cons_printf (\"%s = 0x%02x.%u\\n\",\n\t\t\t\t\tsi->name, (ut32)si->swi, (ut32)si->num);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"asj\"\n\t\tlist = r_syscall_list (core->anal->syscall);\n\t\tr_cons_printf (\"[\");\n\t\tr_list_foreach (list, iter, si) {\n\t\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"swi\\\":\\\"%d\\\",\\\"num\\\":\\\"%d\\\"}\",\n\t\t\t\tsi->name, si->swi, si->num);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\"]\\n\");\n\t\tr_list_free (list);\n\t\t// JSON support\n\t\tbreak;\n\tcase '\\0':\n\t\tcmd_syscall_do (core, -1); //n);\n\t\tbreak;\n\tcase ' ':\n\t\tcmd_syscall_do (core, (int)r_num_get (core->num, input + 1));\n\t\tbreak;\n\tcase 'k': // \"ask\"\n\t\tif (input[1] == ' ') {\n\t\t\tout = sdb_querys (core->anal->syscall->db, NULL, 0, input + 2);\n\t\t\tif (out) {\n\t\t\t\tr_cons_println (out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t} else eprintf (\"|ERROR| Usage: ask [query]\\n\");\n\t\tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_as);\n\t\tbreak;\n\t}\n}\n\nstatic void anal_axg (RCore *core, const char *input, int level, Sdb *db, int opts) {\n\tchar arg[32], pre[128];\n\tRList *xrefs;\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tut64 addr = core->offset;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tif (input && *input) {\n\t\taddr = r_num_math (core->num, input);\n\t}\n\tint spaces = (level + 1) * 2;\n\tif (spaces > sizeof (pre) - 4) {\n\t\tspaces = sizeof (pre) - 4;\n\t}\n\tmemset (pre, ' ', sizeof (pre));\n\tstrcpy (pre+spaces, \"- \");\n\n\txrefs = r_anal_xrefs_get (core->anal, addr);\n\tif (!r_list_empty (xrefs)) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\t\tif (fcn) {\n\t\t\tif (is_json) {\n\t\t\t\tr_cons_printf (\"{\\\"%\"PFMT64d\"\\\":{\\\"type\\\":\\\"fcn\\\",\"\n\t\t\t\t\t\"\\\"fcn_addr\\\":%\"PFMT64d\",\\\"name\\\":\\\"%s\\\",\\\"refs\\\":[\",\n\t\t\t\t\taddr, fcn->addr, fcn->name);\n\t\t\t} else {\n\t\t\t\t//if (sdb_add (db, fcn->name, \"1\", 0)) {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" fcn 0x%08\"PFMT64x\" %s\\n\",\n\t\t\t\t\tpre + 2, addr, fcn->addr, fcn->name);\n\t\t\t\t//}\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_json) {\n\t\t\t\tr_cons_printf (\"{\\\"%\"PFMT64d\"\\\":{\\\"refs\\\":[\", addr);\n\t\t\t} else {\n\t\t\t//snprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, addr);\n\t\t\t//if (sdb_add (db, arg, \"1\", 0)) {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\"\\n\", pre+2, addr);\n\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\tr_list_foreach (xrefs, iter, ref) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, ref->addr, -1);\n\t\tif (fcn) {\n\t\t\tif (is_json) {\n\t\t\t\tif (level == 0) {\n\t\t\t\t\tr_cons_printf (\"{\\\"%\"PFMT64d\"\\\":{\\\"type\\\":\\\"fcn\\\",\\\"fcn_addr\\\": %\"PFMT64d\",\\\"name\\\":\\\"%s\\\",\\\"refs\\\":[\", ref->addr, fcn->addr, fcn->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"]}},{\\\"%\"PFMT64d\"\\\":{\\\"type\\\":\\\"fcn\\\",\\\"fcn_addr\\\": %\"PFMT64d\",\\\"name\\\":\\\"%s\\\",\\\"refs\\\":[\", ref->addr, fcn->addr, fcn->name);\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" fcn 0x%08\"PFMT64x\" %s\\n\", pre, ref->addr, fcn->addr, fcn->name);\n\t\t\t}\n\t\t\tif (sdb_add (db, fcn->name, \"1\", 0)) {\n\t\t\t\tsnprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, fcn->addr);\n\t\t\t\tanal_axg (core, arg, level+1, db, opts);\n\t\t\t} else {\n\t\t\t\tif (is_json) {\n\t\t\t\t\tr_cons_printf(\"]}}\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_json) {\n\t\t\t\tif (iter->n) {\n\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_json) {\n\t\t\t\tr_cons_printf (\"{\\\"%\"PFMT64d\"\\\":{\\\"type\\\":\\\"???\\\",\\\"refs\\\":[\", ref->addr);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" ???\\n\", pre, ref->addr);\n\t\t\t}\n\t\t\tsnprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, ref->addr);\n\t\t\tif (sdb_add (db, arg, \"1\", 0)) {\n\t\t\t\tanal_axg (core, arg, level +1, db, opts);\n\t\t\t} else {\n\t\t\t\tif (is_json) {\n\t\t\t\t\tr_cons_printf(\"]}}\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_json) {\n\t\t\t\tif (iter->n) {\n\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (is_json) {\n\t\tr_cons_printf(\"]}}\");\n\t\tif (level == 0) {\n\t\t\tr_cons_printf(\"\\n\");\n\t\t}\n\t}\n\tr_list_free (xrefs);\n}\n\nstatic void cmd_anal_ucall_ref (RCore *core, ut64 addr) {\n\tRAnalFunction * fcn = r_anal_get_fcn_at (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}\n\nstatic bool cmd_anal_refs(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[0]) {\n\tcase '-': { // \"ax-\"\n\t\tRList *list;\n\t\tRListIter *iter;\n\t\tRAnalRef *ref;\n\t\tchar *cp_inp = strdup (input + 1);\n\t\tchar *ptr = r_str_trim_head (cp_inp);\n\t\tif (!strcmp (ptr, \"*\")) {\n\t\t\tr_anal_xrefs_init (core->anal);\n\t\t} else {\n\t\t\tint n = r_str_word_set0 (ptr);\n\t\t\tut64 from = UT64_MAX, to = UT64_MAX;\n\t\t\tswitch (n) {\n\t\t\tcase 2:\n\t\t\t\tfrom = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t\t//fall through\n\t\t\tcase 1: // get addr\n\t\t\t\tto = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tto = core->offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist = r_anal_xrefs_get (core->anal, to);\n\t\t\tif (list) {\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tif (from != UT64_MAX && from == ref->addr) {\n\t\t\t\t\t\tr_anal_ref_del (core->anal, ref->addr, ref->at);\n\t\t\t\t\t}\n\t\t\t\t\tif (from == UT64_MAX) {\n\t\t\t\t\t\tr_anal_ref_del (core->anal, ref->addr, ref->at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t}\n\t\tfree (cp_inp);\n\t} break;\n\tcase 'g': // \"axg\"\n\t\t{\n\t\t\tSdb *db = sdb_new0 ();\n\t\t\tif(input[1] == '\\0') {\n\t\t\t\tanal_axg (core, input[1] ? input + 2 : NULL, 0, db, 0);\n\t\t\t} else if(input[1] == 'j') {\n\t\t\t\tanal_axg (core, input[1] ? input + 2 : NULL, 0, db, R_CORE_ANAL_JSON);\n\t\t\t}\n\t\t\tsdb_free (db);\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"axk\"\n\t\tif (input[1] == '?') {\n\t\t\teprintf (\"Usage: axk [query]\\n\");\n\t\t} else if (input[1] == ' ') {\n\t\t\tsdb_query (core->anal->sdb_xrefs, input + 2);\n\t\t} else {\n\t\t\tr_core_anal_ref_list (core, 'k');\n\t\t}\n\t\tbreak;\n\tcase '\\0': // \"ax\"\n\tcase 'j': // \"axj\"\n\tcase 'q': // \"axq\"\n\tcase '*': // \"ax*\"\n\t\tr_core_anal_ref_list (core, input[0]);\n\t\tbreak;\n\tcase 't': { // \"axt\"\n\t\tconst int size = 12;\n\t\tRList *list;\n\t\tRAnalFunction *fcn;\n\t\tRAnalRef *ref;\n\t\tRListIter *iter;\n\t\tut8 buf[12];\n\t\tRAsmOp asmop;\n\t\tchar *buf_asm = NULL;\n\t\tchar *space = strchr (input, ' ');\n\n\t\tif (space) {\n\t\t\taddr = r_num_math (core->num, space + 1);\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tlist = r_anal_xrefs_get (core->anal, addr);\n\t\tif (list) {\n\t\t\tif (input[1] == 'q') { // \"axtq\"\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", ref->addr);\n\t\t\t\t}\n\t\t\t} else if (input[1] == 'j') { // \"axtj\"\n\t\t\t\tbool asm_varsub = r_config_get_i (core->config, \"asm.varsub\");\n\t\t\t\tcore->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");\n\t\t\t\tcore->parser->localvar_only = r_config_get_i (core->config, \"asm.varsub_only\");\n\t\t\t\tr_cons_printf (\"[\");\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_core_read_at (core, ref->addr, buf, size);\n\t\t\t\t\tr_asm_set_pc (core->assembler, ref->addr);\n\t\t\t\t\tr_asm_disassemble (core->assembler, &asmop, buf, size);\n\t\t\t\t\tchar str[512];\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, ref->addr, 0);\n\t\t\t\t\tif (asm_varsub) {\n\t\t\t\t\t\tr_parse_varsub (core->parser, fcn, ref->addr, asmop.size,\n\t\t\t\t\t\t\t\tasmop.buf_asm, asmop.buf_asm, sizeof (asmop.buf_asm));\n\t\t\t\t\t}\n\t\t\t\t\tr_parse_filter (core->parser, core->flags,\n\t\t\t\t\t\t\tasmop.buf_asm, str, sizeof (str), core->print->big_endian);\n\n\t\t\t\t\tr_cons_printf (\"{\\\"from\\\":%\" PFMT64u \",\\\"type\\\":\\\"%s\\\",\\\"opcode\\\":\\\"%s\\\"\", ref->addr, r_anal_ref_to_string (ref->type), str);\n\t\t\t\t\tif (fcn) {\n\t\t\t\t\t\tr_cons_printf (\",\\\"fcn_addr\\\":%\"PFMT64d\",\\\"fcn_name\\\":\\\"%s\\\"\", fcn->addr, fcn->name);\n\t\t\t\t\t}\n\t\t\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, fcn? fcn->addr: ref->addr, true);\n\t\t\t\t\tif (fi) {\n\t\t\t\t\t\tif (fcn && strcmp (fcn->name, fi->name)) {\n\t\t\t\t\t\t\tr_cons_printf (\",\\\"flag\\\":\\\"%s\\\"\", fi->name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fi->realname && strcmp (fi->name, fi->realname)) {\n\t\t\t\t\t\t\tr_cons_printf (\",\\\"realname\\\":\\\"%s\\\"\", fi->realname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"}%s\", iter->n? \",\": \"\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\tr_cons_newline ();\n\t\t\t} else if (input[1] == 'g') { // axtg\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tchar *str = r_core_cmd_strf (core, \"fd 0x%\"PFMT64x, ref->addr);\n\t\t\t\t\tif (!str) {\n\t\t\t\t\t\tstr = strdup (\"?\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tr_str_trim_tail (str);\n\t\t\t\t\tr_cons_printf (\"agn 0x%\" PFMT64x \" \\\"%s\\\"\\n\", ref->addr, str);\n\t\t\t\t\tfree (str);\n\t\t\t\t}\n\t\t\t\tif (input[2] != '*') {\n\t\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\t\tr_cons_printf (\"agn 0x%\" PFMT64x \" \\\"%s\\\"\\n\", addr, fcn?fcn->name: \"$$\");\n\t\t\t\t}\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_cons_printf (\"age 0x%\" PFMT64x \" 0x%\"PFMT64x\"\\n\", ref->addr, addr);\n\t\t\t\t}\n\t\t\t} else if (input[1] == '*') { // axt*\n\t\t\t\t// TODO: implement multi-line comments\n\t\t\t\tr_list_foreach (list, iter, ref)\n\t\t\t\t\tr_cons_printf (\"CCa 0x%\" PFMT64x \" \\\"XREF type %d at 0x%\" PFMT64x\"%s\\n\",\n\t\t\t\t\t\tref->addr, ref->type, addr, iter->n? \",\": \"\");\n\t\t\t} else { // axt\n\t\t\t\tint has_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\t\t\t\tchar str[512];\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tchar *comment;\n\t\t\t\tbool asm_varsub = r_config_get_i (core->config, \"asm.varsub\");\n\t\t\t\tcore->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");\n\t\t\t\tcore->parser->localvar_only = r_config_get_i (core->config, \"asm.varsub_only\");\n\t\t\t\tif (core->parser->relsub) {\n\t\t\t\t\tcore->parser->relsub_addr = addr;\n\t\t\t\t}\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_core_read_at (core, ref->addr, buf, size);\n\t\t\t\t\tr_asm_set_pc (core->assembler, ref->addr);\n\t\t\t\t\tr_asm_disassemble (core->assembler, &asmop, buf, size);\n\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, ref->addr, 0);\n\t\t\t\t\tif (asm_varsub) {\n\t\t\t\t\t\tr_parse_varsub (core->parser, fcn, ref->addr, asmop.size,\n\t\t\t\t\t\t\t\tasmop.buf_asm, asmop.buf_asm, sizeof (asmop.buf_asm));\n\t\t\t\t\t}\n\t\t\t\t\tr_parse_filter (core->parser, core->flags,\n\t\t\t\t\t\t\tasmop.buf_asm, str, sizeof (str), core->print->big_endian);\n\t\t\t\t\tif (has_color) {\n\t\t\t\t\t\tbuf_asm = r_print_colorize_opcode (core->print, str,\n\t\t\t\t\t\t\tcore->cons->pal.reg, core->cons->pal.num, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf_asm = r_str_new (str);\n\t\t\t\t\t}\n\t\t\t\t\tcomment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, ref->addr);\n\t\t\t\t\tchar *buf_fcn = comment\n\t\t\t\t\t\t? r_str_newf (\"%s; %s\", fcn ?  fcn->name : \"(nofunc)\", strtok (comment, \"\\n\"))\n\t\t\t\t\t\t: r_str_newf (\"%s\", fcn ? fcn->name : \"(nofunc)\");\n\t\t\t\t\tr_cons_printf (\"%s 0x%\" PFMT64x \" [%s] %s\\n\",\n\t\t\t\t\t\tbuf_fcn, ref->addr, r_anal_ref_to_string (ref->type), buf_asm);\n\t\t\t\t\tfree (buf_asm);\n\t\t\t\t\tfree (buf_fcn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t} else {\n\t\t\tif (input[1] == 'j') { // \"axtj\"\n\t\t\t\tr_cons_print (\"[]\\n\");\n\t\t\t}\n\t\t}\n\t} break;\n\tcase 'f': { // \"axf\"\n\t\tut8 buf[12];\n\t\tRAsmOp asmop;\n\t\tchar *buf_asm = NULL;\n\t\tRList *list, *list_ = NULL;\n\t\tRAnalRef *ref;\n\t\tRListIter *iter;\n\t\tchar *space = strchr (input, ' ');\n\n\t\tif (space) {\n\t\t\taddr = r_num_math (core->num, space + 1);\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tif (input[1] == '.') { // axf.\n\t\t\tlist = list_ = r_anal_xrefs_get_from (core->anal, addr);\n\t\t\tif (!list) {\n\t\t\t\tRAnalFunction * fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\tlist = r_anal_fcn_get_refs (core->anal, fcn);\n\t\t\t}\n\t\t} else {\n\t\t\tlist = r_anal_refs_get (core->anal, addr);\n\t\t}\n\n\t\tif (list) {\n\t\t\tif (input[1] == 'q') { // axfq\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", ref->at);\n\t\t\t\t}\n\t\t\t} else if (input[1] == 'j') { // axfj\n\t\t\t\tr_cons_print (\"[\");\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_core_read_at (core, ref->at, buf, 12);\n\t\t\t\t\tr_asm_set_pc (core->assembler, ref->at);\n\t\t\t\t\tr_asm_disassemble (core->assembler, &asmop, buf, 12);\n\t\t\t\t\tr_cons_printf (\"{\\\"from\\\":%\" PFMT64d \",\\\"to\\\":%\" PFMT64d \",\\\"type\\\":\\\"%s\\\",\\\"opcode\\\":\\\"%s\\\"}%s\",\n\t\t\t\t\t\tref->at, ref->addr, r_anal_ref_to_string (ref->type), asmop.buf_asm, iter->n? \",\": \"\");\n\t\t\t\t}\n\t\t\t\tr_cons_print (\"]\\n\");\n\t\t\t} else if (input[1] == '*') { // axf*\n\t\t\t\t// TODO: implement multi-line comments\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_cons_printf (\"CCa 0x%\" PFMT64x \" \\\"XREF from 0x%\" PFMT64x \"\\n\",\n\t\t\t\t\t\tref->at, ref->type, asmop.buf_asm, iter->n? \",\": \"\");\n\t\t\t\t}\n\t\t\t} else { // axf\n\t\t\t\tchar str[512];\n\t\t\t\tint has_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_core_read_at (core, ref->at, buf, 12);\n\t\t\t\t\tr_asm_set_pc (core->assembler, ref->at);\n\t\t\t\t\tr_asm_disassemble (core->assembler, &asmop, buf, 12);\n\t\t\t\t\tr_parse_filter (core->parser, core->flags,\n\t\t\t\t\t\t\tasmop.buf_asm, str, sizeof (str), core->print->big_endian);\n\t\t\t\t\tif (has_color) {\n\t\t\t\t\t\tbuf_asm = r_print_colorize_opcode (core->print, str,\n\t\t\t\t\t\t\tcore->cons->pal.reg, core->cons->pal.num, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf_asm = r_str_new (str);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"%c 0x%\" PFMT64x \" %s\",\n\t\t\t\t\t\tref->type, ref->at, buf_asm);\n\n\t\t\t\t\tif (ref->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\t\tRAnalOp aop;\n\t\t\t\t\t\tr_anal_op (core->anal, &aop, ref->at, buf, 12, R_ANAL_OP_MASK_ALL);\n\t\t\t\t\t\tif (aop.type == R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\t\t\t\tcmd_anal_ucall_ref (core, ref->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\tfree (buf_asm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_free (list_);\n\t\t\tr_list_free (list);\n\t\t} else {\n\t\t\tif (input[1] == 'j') { // axfj\n\t\t\t\tr_cons_print (\"[]\\n\");\n\t\t\t}\n\t\t}\n\t} break;\n\tcase 'F':\n\t\tfind_refs (core, input + 1);\n\t\tbreak;\n\tcase 'C': // \"axC\"\n\tcase 'c': // \"axc\"\n\tcase 'd': // \"axd\"\n\tcase ' ': // \"ax \"\n\t\t{\n\t\tchar *ptr = strdup (r_str_trim_head ((char *)input + 1));\n\t\tint n = r_str_word_set0 (ptr);\n\t\tut64 at = core->offset;\n\t\tut64 addr = UT64_MAX;\n\t\tswitch (n) {\n\t\tcase 2: // get at\n\t\t\tat = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t/* fall through */\n\t\tcase 1: // get addr\n\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfree (ptr);\n\t\t\treturn false;\n\t\t}\n\t\tr_anal_xrefs_set (core->anal, input[0], at, addr);\n\t\tfree (ptr);\n\t\t}\n\t   \tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ax);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\nstatic void cmd_anal_hint(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '?':\n\t\tif (input[1]) {\n\t\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\t\tr_core_anal_hint_print (core->anal, addr, 0);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ah);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"ah.\"\n\t\tr_core_anal_hint_print (core->anal, core->offset, 0);\n\t\tbreak;\n\tcase 'a': // \"aha\" set arch\n\t\tif (input[1]) {\n\t\t\tint i;\n\t\t\tchar *ptr = strdup (input + 2);\n\t\t\ti = r_str_word_set0 (ptr);\n\t\t\tif (i == 2) {\n\t\t\t\tr_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t}\n\t\t\tr_anal_hint_set_arch (core->anal, core->offset, r_str_word_get0 (ptr, 0));\n\t\t\tfree (ptr);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_arch (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Missing argument\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"ahb\" set bits\n\t\tif (input[1]) {\n\t\t\tchar *ptr = strdup (input + 2);\n\t\t\tint bits;\n\t\t\tint i = r_str_word_set0 (ptr);\n\t\t\tif (i == 2) {\n\t\t\t\tr_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t}\n\t\t\tbits = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tr_anal_hint_set_bits (core->anal, core->offset, bits);\n\t\t\tfree (ptr);\n\t\t}  else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_bits (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Missing argument\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"ahi\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_ahi);\n\t\t} else if (input[1] == ' ') {\n\t\t// You can either specify immbase with letters, or numbers\n\t\t\tconst int base =\n\t\t\t\t(input[2] == 's') ? 1 :\n\t\t\t\t(input[2] == 'b') ? 2 :\n\t\t\t\t(input[2] == 'p') ? 3 :\n\t\t\t\t(input[2] == 'o') ? 8 :\n\t\t\t\t(input[2] == 'd') ? 10 :\n\t\t\t\t(input[2] == 'h') ? 16 :\n\t\t\t\t(input[2] == 'i') ? 32 : // ip address\n\t\t\t\t(input[2] == 'S') ? 80 : // syscall\n\t\t\t\t(int) r_num_math (core->num, input + 1);\n\t\t\tr_anal_hint_set_immbase (core->anal, core->offset, base);\n\t\t} else if (input[1] == '-') { // \"ahi-\"\n\t\t\tr_anal_hint_set_immbase (core->anal, core->offset, 0);\n\t\t} else {\n\t\t\teprintf (\"|ERROR| Usage: ahi [base]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ahh\"\n\t\tif (input[1] == '-') {\n\t\t\tr_anal_hint_unset_high (core->anal, core->offset);\n\t\t} else if (input[1] == ' ') {\n\t\t\tr_anal_hint_set_high (core->anal, r_num_math (core->num, input + 1));\n\t\t} else {\n\t\t\tr_anal_hint_set_high (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"ahc\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_jump (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_jump (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"ahf\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_fail (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_fail (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ahs\" set size (opcode length)\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_size (core->anal, core->offset, atoi (input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_size (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Usage: ahs 16\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'S': // \"ahS\" set size (opcode length)\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_syntax (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_syntax (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Usage: ahS att\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"aho\" set opcode string\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_opcode (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_opcode (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Usage: aho popall\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"ahe\" set ESIL string\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_esil (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_esil (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Usage: ahe r0,pc,=\\n\");\n\t\t}\n\t\tbreak;\n#if 0\n\tcase 'e': // set endian\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_opcode (core->anal, core->offset, atoi (input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_opcode (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n#endif\n\tcase 'p': // \"ahp\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_pointer (core->anal, core->offset, r_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') { // \"ahp-\"\n\t\t\tr_anal_hint_unset_pointer (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"ah*\"\n\t\tif (input[1] == ' ') {\n\t\t\tchar *ptr = strdup (r_str_trim_ro (input + 2));\n\t\t\tr_str_word_set0 (ptr);\n\t\t\tut64 addr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tr_core_anal_hint_print (core->anal, addr, '*');\n\t\t} else {\n\t\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"ahj\"\n\tcase '\\0': // \"ah\"\n\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\tbreak;\n\tcase '-': // \"ah-\"\n\t\tif (input[1]) {\n\t\t\tif (input[1] == '*') {\n\t\t\t\tr_anal_hint_clear (core->anal);\n\t\t\t} else {\n\t\t\t\tchar *ptr = strdup (r_str_trim_ro (input + 1));\n\t\t\t\tut64 addr;\n\t\t\t\tint size = 1;\n\t\t\t\tint i = r_str_word_set0 (ptr);\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t\t}\n\t\t\t\tconst char *a0 = r_str_word_get0 (ptr, 0);\n\t\t\t\tif (a0 && *a0) {\n\t\t\t\t\taddr = r_num_math (core->num, a0);\n\t\t\t\t} else {\n\t\t\t\t\taddr = core->offset;\n\t\t\t\t}\n\t\t\t\tr_anal_hint_del (core->anal, addr, size);\n\t\t\t\tfree (ptr);\n\t\t\t}\n\t\t} else {\n\t\t\tr_anal_hint_clear (core->anal);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void agraph_print_node_dot(RANode *n, void *user) {\n\tchar *label = strdup (n->body);\n\t//label = r_str_replace (label, \"\\n\", \"\\\\l\", 1);\n\tif (!label || !*label) {\n\t\tr_cons_printf (\"\\\"%s\\\" [URL=\\\"%s\\\", color=\\\"lightgray\\\", label=\\\"%s\\\"]\\n\",\n\t\t\t\tn->title, n->title, n->title);\n\t} else {\n\t\tr_cons_printf (\"\\\"%s\\\" [URL=\\\"%s\\\", color=\\\"lightgray\\\", label=\\\"%s\\\\n%s\\\"]\\n\",\n\t\t\t\tn->title, n->title, n->title, label);\n\t}\n\tfree (label);\n}\n\nstatic void agraph_print_node(RANode *n, void *user) {\n\tchar *encbody, *cmd;\n\tint len = strlen (n->body);\n\n\tif (n->body[len - 1] == '\\n') {\n\t\tlen--;\n\t}\n\tencbody = r_base64_encode_dyn (n->body, len);\n\tcmd = r_str_newf (\"agn \\\"%s\\\" base64:%s\\n\", n->title, encbody);\n\tr_cons_printf (cmd);\n\tfree (cmd);\n\tfree (encbody);\n}\n\nstatic void agraph_print_edge_dot(RANode *from, RANode *to, void *user) {\n\tr_cons_printf (\"\\\"%s\\\" -> \\\"%s\\\"\\n\", from->title, to->title);\n}\n\nstatic void agraph_print_edge(RANode *from, RANode *to, void *user) {\n\tr_cons_printf (\"age \\\"%s\\\" \\\"%s\\\"\\n\", from->title, to->title);\n}\n\nstatic void cmd_agraph_node(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase ' ': { // \"agn\"\n\t\tchar *newbody = NULL;\n\t\tchar **args, *body;\n\t\tint n_args, B_LEN = strlen (\"base64:\");\n\t\tinput++;\n\t\targs = r_str_argv (input, &n_args);\n\t\tif (n_args < 1 || n_args > 2) {\n\t\t\tr_cons_printf (\"Wrong arguments\\n\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\t// strdup cause there is double free in r_str_argv_free due to a realloc call\n\t\tif (n_args > 1) {\n\t\t\tbody = strdup (args[1]);\n\t\t\tif (strncmp (body, \"base64:\", B_LEN) == 0) {\n\t\t\t\tbody = r_str_replace (body, \"\\\\n\", \"\", true);\n\t\t\t\tnewbody = (char *)r_base64_decode_dyn (body + B_LEN, -1);\n\t\t\t\tfree (body);\n\t\t\t\tif (!newbody) {\n\t\t\t\t\teprintf (\"Cannot allocate buffer\\n\");\n\t\t\t\t\tr_str_argv_free (args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbody = newbody;\n\t\t\t}\n\t\t\tbody = r_str_append (body, \"\\n\");\n\t\t} else {\n\t\t\tbody = strdup (\"\");\n\t\t}\n\t\tr_agraph_add_node (core->graph, args[0], body);\n\t\tr_str_argv_free (args);\n\t\tfree (body);\n\t\t//free newbody it's not necessary since r_str_append reallocate the space\n\t\tbreak;\n\t}\n\tcase '-': { // \"agn-\"\n\t\tchar **args;\n\t\tint n_args;\n\n\t\tinput++;\n\t\targs = r_str_argv (input, &n_args);\n\t\tif (n_args != 1) {\n\t\t\tr_cons_printf (\"Wrong arguments\\n\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\tr_agraph_del_node (core->graph, args[0]);\n\t\tr_str_argv_free (args);\n\t\tbreak;\n\t}\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_agn);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_agraph_edge(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase ' ': // \"age\"\n\tcase '-': { // \"age-\"\n\t\tRANode *u, *v;\n\t\tchar **args;\n\t\tint n_args;\n\n\t\targs = r_str_argv (input + 1, &n_args);\n\t\tif (n_args != 2) {\n\t\t\tr_cons_printf (\"Wrong arguments\\n\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\n\t\tu = r_agraph_get_node (core->graph, args[0]);\n\t\tv = r_agraph_get_node (core->graph, args[1]);\n\t\tif (!u || !v) {\n\t\t\tif (!u) {\n\t\t\t\tr_cons_printf (\"Node %s not found!\\n\", args[0]);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"Node %s not found!\\n\", args[1]);\n\t\t\t}\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\tif (*input == ' ') {\n\t\t\tr_agraph_add_edge (core->graph, u, v);\n\t\t} else {\n\t\t\tr_agraph_del_edge (core->graph, u, v);\n\t\t}\n\t\tr_str_argv_free (args);\n\t\tbreak;\n\t}\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_age);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_agraph_print(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase 'k': // \"aggk\"\n\t{\n\t\tSdb *db = r_agraph_get_sdb (core->graph);\n\t\tchar *o = sdb_querys (db, \"null\", 0, \"*\");\n\t\tr_cons_print (o);\n\t\tfree (o);\n\t\tbreak;\n\t}\n\tcase 'v': // \"aggv\"\n\t{\n\t\tconst char *cmd = r_config_get (core->config, \"cmd.graph\");\n\t\tif (cmd && *cmd) {\n\t\t\tchar *newCmd = strdup (cmd);\n\t\t\tif (newCmd) {\n\t\t\t\tnewCmd = r_str_replace (newCmd, \"ag $$\", \"aggd\", 0);\n\t\t\t\tr_core_cmd0 (core, newCmd);\n\t\t\t\tfree (newCmd);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd0 (core, \"agf\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'i': // \"aggi\" - open current core->graph in interactive mode\n\t{\n\t\tRANode *ran = r_agraph_get_first_node (core->graph);\n\t\tif (ran) {\n\t\t\tr_agraph_set_title (core->graph, r_config_get (core->config, \"graph.title\"));\n\t\t\tr_agraph_set_curnode (core->graph, ran);\n\t\t\tcore->graph->force_update_seek = true;\n\t\t\tcore->graph->need_set_layout = true;\n\t\t\tcore->graph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\tint ov = r_config_get_i (core->config, \"scr.interactive\");\n\t\t\tcore->graph->need_update_dim = true;\n\t\t\tr_core_visual_graph (core, core->graph, NULL, true);\n\t\t\tr_config_set_i (core->config, \"scr.interactive\", ov);\n\t\t\tr_cons_show_cursor (true);\n\t\t} else {\n\t\t\teprintf (\"This graph contains no nodes\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'd': // \"aggd\" - dot format\n\t\tr_cons_printf (\"digraph code {\\ngraph [bgcolor=white];\\n\"\n\t\t\t\"node [color=lightgray, style=filled shape=box \"\n\t\t\t\"fontname=\\\"Courier\\\" fontsize=\\\"8\\\"];\\n\");\n\t\tr_agraph_foreach (core->graph, agraph_print_node_dot, NULL);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge_dot, NULL);\n\t\tr_cons_printf (\"}\\n\");\n\t\tbreak;\n\tcase '*': // \"agg*\" -\n\t\tr_agraph_foreach (core->graph, agraph_print_node, NULL);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge, NULL);\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_agg);\n\t\tbreak;\n\tdefault:\n\t\tcore->graph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\tcore->graph->can->color = r_config_get_i (core->config, \"scr.color\");\n\t\tr_agraph_set_title (core->graph,\n\t\t\tr_config_get (core->config, \"graph.title\"));\n\t\tr_agraph_print (core->graph);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_graph(RCore *core, const char *input) {\n\tRList *list;\n\tconst char *arg;\n\tswitch (input[0]) {\n\tcase 'f': // \"agf\"\n\t\tswitch (input[1]) {\n\t\tcase 't':// \"agft\" - tiny graph\n\t\t\tr_core_visual_graph (core, NULL, NULL, 2);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tr_core_visual_graph (core, NULL, NULL, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Usage: agf or agft (for tiny)\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '-': // \"ag-\"\n\t\tr_agraph_reset (core->graph);\n\t\tbreak;\n\tcase 'n': // \"agn\"\n\t\tcmd_agraph_node (core, input + 1);\n\t\tbreak;\n\tcase 'e': // \"age\"\n\t\tcmd_agraph_edge (core, input + 1);\n\t\tbreak;\n\tcase 'g': // \"agg\"\n\t\tcmd_agraph_print (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"ags\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), 0);\n\t\tbreak;\n\tcase 't': // \"agt\"\n\t\tlist = r_core_anal_graph_to (core, r_num_math (core->num, input + 1), 0);\n\t\tif (list) {\n\t\t\tRListIter *iter, *iter2;\n\t\t\tRList *list2;\n\t\t\tRAnalBlock *bb;\n\t\t\tr_list_foreach (list, iter, list2) {\n\t\t\t\tr_list_foreach (list2, iter2, bb) {\n\t\t\t\t\tr_cons_printf (\"-> 0x%08\" PFMT64x \"\\n\", bb->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_purge (list);\n\t\t\tfree (list);\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"agC\"\n\t\tr_core_anal_coderefs (core, UT64_MAX, input[1] == 'j'? 2: 1);\n\t\tbreak;\n\tcase 'r': // \"refs\"\n\t\tswitch (input[1]) {\n\t\tcase '*':\n\t\tcase 'j':\n\t\tcase ' ':\n\t\tcase 0:\n\t\t\t{\n\t\t\t\tut64 addr = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\tr_core_anal_codexrefs (core, addr, '*');\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"|ERROR| Usage: agr[*j]\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"agc\"\n\t\tif (input[1] == '*') {\n\t\t\tut64 addr = input[2]? r_num_math (core->num, input + 2): UT64_MAX;\n\t\t\tr_core_anal_coderefs (core, addr, '*');\n\t\t} else if (input[1] == 'j') {\n\t\t\tut64 addr = input[2]? r_num_math (core->num, input + 2): UT64_MAX;\n\t\t\tr_core_anal_coderefs (core, addr, 2);\n\t\t} else if (input[1] == ' ') {\n\t\t\tut64 addr = input[2]? r_num_math (core->num, input + 1): UT64_MAX;\n\t\t\tr_core_anal_coderefs (core, addr, 1);\n\t\t} else {\n\t\t\teprintf (\"|ERROR| Usage: agc[j*] ([addr])\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"agj\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_JSON);\n\t\tbreak;\n\tcase 'J': // \"agJ\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_JSON | R_CORE_ANAL_JSON_FORMAT_DISASM);\n\t\tbreak;\n\tcase 'k': // \"agk\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_KEYVALUE);\n\t\tbreak;\n\tcase 'l': // \"agl\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_GRAPHLINES);\n\t\tbreak;\n\tcase 'a': // \"aga\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), 0);\n\t\tbreak;\n\tcase 'd': // \"agd\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1),\n\t\t\t\tR_CORE_ANAL_GRAPHBODY | R_CORE_ANAL_GRAPHDIFF);\n\t\tbreak;\n\tcase 'v': // \"agv\"\n\t\tif (r_config_get_i (core->config, \"graph.web\")) {\n\t\t\tr_core_cmd0 (core, \"=H /graph/\");\n\t\t} else {\n\t\t\tconst char *cmd = r_config_get (core->config, \"cmd.graph\");\n\t\t\tif (cmd && *cmd) {\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t} else {\n\t\t\t\tr_core_cmd0 (core, \"agf\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ag?\"\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\tbreak;\n\tcase ' ': // \"ag\"\n\t\targ = strchr (input, ' ');\n\t\tr_core_anal_graph (core, r_num_math (core->num, arg? arg + 1: NULL),\n\t\t\t\tR_CORE_ANAL_GRAPHBODY);\n\t\tbreak;\n\tcase 0:\n\t\teprintf (\"|ERROR| Usage: ag [addr]\\n\");\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"See ag?\\n\");\n\t\tbreak;\n\t}\n}\n\nR_API int r_core_anal_refs(RCore *core, const char *input) {\n\tint cfg_debug = r_config_get_i (core->config, \"cfg.debug\");\n\tut64 from, to;\n\tchar *ptr;\n\tint rad, n;\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_aar);\n\t\treturn 0;\n\t}\n\n\tif (*input == 'j' || *input == '*') {\n\t\trad = *input;\n\t\tinput++;\n\t} else {\n\t\trad = 0;\n\t}\n\n\tfrom = to = 0;\n\tptr = r_str_trim_head (strdup (input));\n\tn = r_str_word_set0 (ptr);\n\tif (!n) {\n\t\t// get boundaries of current memory map, section or io map\n\t\tif (cfg_debug) {\n\t\t\tRDebugMap *map = r_debug_map_get (core->dbg, core->offset);\n\t\t\tif (map) {\n\t\t\t\tfrom = map->addr;\n\t\t\t\tto = map->addr_end;\n\t\t\t}\n\t\t} else {\n\t\t\tRList *list = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, \"anal\");\n\t\t\tRListIter *iter;\n\t\t\tRIOMap* map;\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tfrom = map->itv.addr;\n\t\t\t\tto = r_itv_end (map->itv);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!from && !to) {\n\t\t\t\t\teprintf (\"Cannot determine xref search boundaries\\n\");\n\t\t\t\t} else if (to - from > UT32_MAX) {\n\t\t\t\t\teprintf (\"Skipping huge range\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tr_core_anal_search_xrefs (core, from, to, rad);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (ptr);\n\t\t\treturn 1;\n\t\t}\n\t} else if (n == 1) {\n\t\tfrom = core->offset;\n\t\tto = core->offset + r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t} else {\n\t\teprintf (\"Invalid number of arguments\\n\");\n\t}\n\tfree (ptr);\n\n\tif (from == UT64_MAX && to == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (!from && !to) {\n\t\treturn false;\n\t}\n\tif (to - from > r_io_size (core->io)) {\n\t\treturn false;\n\t}\n\treturn r_core_anal_search_xrefs (core, from, to, rad);\n}\n\nstatic const char *oldstr = NULL;\n\nstatic void rowlog(RCore *core, const char *str) {\n\tint use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tbool verbose = r_config_get_i (core->config, \"scr.prompt\");\n\toldstr = str;\n\tif (!verbose) {\n\t\treturn;\n\t}\n\tif (use_color) {\n\t\teprintf (\"[ ] \"Color_YELLOW\"%s\\r[\"Color_RESET, str);\n\t} else {\n\t\teprintf (\"[ ] %s\\r[\", str);\n\t}\n}\n\nstatic void rowlog_done(RCore *core) {\n\tint use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tbool verbose = r_config_get_i (core->config, \"scr.prompt\");\n\tif (verbose) {\n\t\tif (use_color)\n\t\t\teprintf (\"\\r\"Color_GREEN\"[x]\"Color_RESET\" %s\\n\", oldstr);\n\t\telse eprintf (\"\\r[x] %s\\n\", oldstr);\n\t}\n}\n\nstatic int compute_coverage(RCore *core) {\n\tRListIter *iter;\n\tSdbListIter *iter2;\n\tRAnalFunction *fcn;\n\tRIOSection *sec;\n\tint cov = 0;\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tls_foreach (core->io->sections, iter2, sec) {\n\t\t\tif (sec->flags & 1) {\n\t\t\t\tut64 section_end = sec->vaddr + sec->vsize;\n\t\t\t\tut64 s = r_anal_fcn_realsize (fcn);\n\t\t\t\tif (fcn->addr >= sec->vaddr && (fcn->addr + s) < section_end) {\n\t\t\t\t\tcov += s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cov;\n}\n\nstatic int compute_code (RCore* core) {\n\tint code = 0;\n\tSdbListIter *iter;\n\tRIOSection *sec;\n\tls_foreach (core->io->sections, iter, sec) {\n\t\tif (sec->flags & 1) {\n\t\t\tcode += sec->vsize;\n\t\t}\n\t}\n\treturn code;\n}\n\nstatic int compute_calls(RCore *core) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tRList *xrefs;\n\tint cov = 0;\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\txrefs = r_anal_fcn_get_xrefs (core->anal, fcn);\n\t\tif (xrefs) {\n\t\t\tcov += r_list_length (xrefs);\n\t\t\tr_list_free (xrefs);\n\t\t\txrefs = NULL;\n\t\t}\n\t}\n\treturn cov;\n}\n\nstatic void r_core_anal_info (RCore *core, const char *input) {\n\tint fcns = r_list_length (core->anal->fcns);\n\tint strs = r_flag_count (core->flags, \"str.*\");\n\tint syms = r_flag_count (core->flags, \"sym.*\");\n\tint imps = r_flag_count (core->flags, \"sym.imp.*\");\n\tint code = compute_code (core);\n\tint covr = compute_coverage (core);\n\tint call = compute_calls (core);\n\tint xrfs = r_anal_xrefs_count (core->anal);\n\tint cvpc = (code > 0)? (covr * 100 / code): 0;\n\tif (*input == 'j') {\n\t\tr_cons_printf (\"{\\\"fcns\\\":%d\", fcns);\n\t\tr_cons_printf (\",\\\"xrefs\\\":%d\", xrfs);\n\t\tr_cons_printf (\",\\\"calls\\\":%d\", call);\n\t\tr_cons_printf (\",\\\"strings\\\":%d\", strs);\n\t\tr_cons_printf (\",\\\"symbols\\\":%d\", syms);\n\t\tr_cons_printf (\",\\\"imports\\\":%d\", imps);\n\t\tr_cons_printf (\",\\\"covrage\\\":%d\", covr);\n\t\tr_cons_printf (\",\\\"codesz\\\":%d\", code);\n\t\tr_cons_printf (\",\\\"percent\\\":%d}\\n\", cvpc);\n\t} else {\n\t\tr_cons_printf (\"fcns    %d\\n\", fcns);\n\t\tr_cons_printf (\"xrefs   %d\\n\", xrfs);\n\t\tr_cons_printf (\"calls   %d\\n\", call);\n\t\tr_cons_printf (\"strings %d\\n\", strs);\n\t\tr_cons_printf (\"symbols %d\\n\", syms);\n\t\tr_cons_printf (\"imports %d\\n\", imps);\n\t\tr_cons_printf (\"covrage %d\\n\", covr);\n\t\tr_cons_printf (\"codesz  %d\\n\", code);\n\t\tr_cons_printf (\"percent %d%%\\n\", cvpc);\n\t}\n}\n\nstatic void cmd_anal_aad(RCore *core, const char *input) {\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tRList *list = r_list_newf (NULL);\n\tr_anal_xrefs_from (core->anal, list, \"xref\", R_ANAL_REF_TYPE_DATA, UT64_MAX);\n\tr_list_foreach (list, iter, ref) {\n\t\tif (r_io_is_valid_offset (core->io, ref->addr, false)) {\n\t\t\tr_core_anal_fcn (core, ref->at, ref->addr, R_ANAL_REF_TYPE_NULL, 1);\n\t\t}\n\t}\n\tr_list_free (list);\n}\n\n\nstatic bool archIsArmOrThumb(RCore *core) {\n\tRAsm *as = core ? core->assembler : NULL;\n\tif (as && as->cur && as->cur->arch) {\n\t\tif (r_str_startswith (as->cur->arch, \"mips\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (r_str_startswith (as->cur->arch, \"arm\")) {\n\t\t\tif (as->bits < 64) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nconst bool archIsMips (RCore *core) {\n\treturn strstr (core->assembler->cur->name, \"mips\");\n}\n\nvoid _CbInRangeAav(RCore *core, ut64 from, ut64 to, int vsize, bool asterisk, int count) {\n\tbool isarm = archIsArmOrThumb (core);\n\tif (isarm) {\n\t\tif (to & 1) {\n\t\t\t// .dword 0x000080b9 in reality is 0x000080b8\n\t\t\tto--;\n\t\t\tr_anal_hint_set_bits (core->anal, to, 16);\n\t\t\t// can we assume is gonna be always a function?\n\t\t} else {\n\t\t\tr_core_seek_archbits (core, from);\n\t\t\tut64 bits = r_config_get_i (core->config, \"asm.bits\");\n\t\t\tr_anal_hint_set_bits (core->anal, from, bits);\n\t\t}\n\t} else {\n\t\tbool ismips = archIsMips (core);\n\t\tif (ismips) {\n\t\t\tif (from % 4 || to % 4) {\n\t\t\t\teprintf (\"False positive\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (asterisk) {\n\t\tr_cons_printf (\"ax 0x%\"PFMT64x \" 0x%\"PFMT64x \"\\n\", to, from);\n\t\tr_cons_printf (\"Cd %d @ 0x%\"PFMT64x \"\\n\", vsize, from);\n\t\tr_cons_printf (\"f+ aav.0x%08\"PFMT64x \"= 0x%08\"PFMT64x, to, to);\n\t} else {\n#if 1\n\t\tr_anal_ref_add (core->anal, to, from, ' ');\n\t\tr_meta_add (core->anal, 'd', from, from + vsize, NULL);\n\t\tif (!r_flag_get_at (core->flags, to, false)) {\n\t\t\tchar *name = r_str_newf (\"aav.0x%08\"PFMT64x, to);\n\t\t\tr_flag_set (core->flags, name, to, vsize);\n\t\t\tfree (name);\n\t\t}\n#else\n\t\tr_core_cmdf (core, \"ax 0x%\"PFMT64x \" 0x%\"PFMT64x, to, from);\n\t\tr_core_cmdf (core, \"Cd %d @ 0x%\"PFMT64x, vsize, from);\n\t\tr_core_cmdf (core, \"f+ aav.0x%08\"PFMT64x \"= 0x%08\"PFMT64x, to, to);\n#endif\n\t}\n}\n\nstatic void cmd_anal_aav(RCore *core, const char *input) {\n#define seti(x,y) r_config_set_i(core->config, x, y);\n#define geti(x) r_config_get_i(core->config, x);\n\tut64 o_align = geti (\"search.align\");\n\tbool asterisk = strchr (input, '*');;\n\tbool is_debug = r_config_get_i (core->config, \"cfg.debug\");\n\n\t// pre\n\tint archAlign = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\tseti (\"search.align\", archAlign);\n\n\tint vsize = 4; // 32bit dword\n\tif (core->assembler->bits == 64) {\n\t\tvsize = 8;\n\t}\n\n\t// body\n\tr_cons_break_push (NULL, NULL);\n\tif (is_debug) {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, \"dbg.map\", \"anal\");\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teprintf (\"aav: from 0x%\"PFMT64x\" to 0x%\"PFMT64x\"\\n\", map->itv.addr, r_itv_end (map->itv));\n\t\t\t(void)r_core_search_value_in_range (core, map->itv,\n\t\t\t\tmap->itv.addr, r_itv_end (map->itv), vsize, asterisk, _CbInRangeAav);\n\t\t}\n\t\tr_list_free (list);\n\t} else {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, NULL, \"anal\");\n\t\tRListIter *iter, *iter2;\n\t\tRIOMap *map, *map2;\n\t\tut64 from = UT64_MAX;\n\t\tut64 to = UT64_MAX;\n\t\t// find values pointing to non-executable regions\n\t\tr_list_foreach (list, iter2, map2) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//TODO: Reduce multiple hits for same addr\n\t\t\tfrom = r_itv_begin (map2->itv);\n\t\t\tto = r_itv_end (map2->itv);\n\t\t\teprintf (\"Value from 0x%08\"PFMT64x \" to 0x%08\" PFMT64x \"\\n\", from, to);\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tut64 begin = map->itv.addr;\n\t\t\t\tut64 end = r_itv_end (map->itv);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (end - begin > UT32_MAX) {\n\t\t\t\t\teprintf (\"Skipping huge range\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\teprintf (\"aav: 0x%08\"PFMT64x\"-0x%08\"PFMT64x\" in 0x%\"PFMT64x\"-0x%\"PFMT64x\"\\n\", from, to, begin, end);\n\t\t\t\t(void)r_core_search_value_in_range (core, map->itv, from, to, vsize, asterisk, _CbInRangeAav);\n\t\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\n\tr_cons_break_pop ();\n\t// end\n\tseti (\"search.align\", o_align);\n}\n\nstatic bool should_aav(RCore *core) {\n\t// Don't aav on x86 for now\n\tif (r_str_startswith (r_config_get (core->config, \"asm.arch\"), \"x86\")) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int cmd_anal_all(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase '?': r_core_cmd_help (core, help_msg_aa); break;\n\tcase 'b': // \"aab\"\n\t\tcmd_anal_blocks (core, input + 1);\n\t\tbreak; // \"aab\"\n\tcase 'f': // \"aaf\"\n\t\t{\n\t\t\tint analHasnext = r_config_get_i (core->config, \"anal.hasnext\");\n\t\t\tr_config_set_i (core->config, \"anal.hasnext\", true);\n\t\t\tr_core_cmd0 (core, \"afr@@c:isq\");\n\t\t\tr_config_set_i (core->config, \"anal.hasnext\", analHasnext);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aac\"\n\t\tswitch (input[1]) {\n\t\tcase '*':\n\t\t\tcmd_anal_calls (core, input + 1, true); break; // \"aac*\"\n\t\tdefault:\n\t\t\tcmd_anal_calls (core, input + 1, false); break; // \"aac\"\n\t\t}\n\tcase 'j': cmd_anal_jumps (core, input + 1); break; // \"aaj\"\n\tcase '*': // \"aa*\"\n\t\tr_core_cmd0 (core, \"af @@ sym.*\");\n\t\tr_core_cmd0 (core, \"af @@ entry*\");\n\t\tbreak;\n\tcase 'd': // \"aad\"\n\t\tcmd_anal_aad (core, input);\n\t\tbreak;\n\tcase 'v': // \"aav\"\n\t\tcmd_anal_aav (core, input);\n\t\tbreak;\n\tcase 'u': // \"aau\" - print areas not covered by functions\n\t\tr_core_anal_nofunclist (core, input + 1);\n\t\tbreak;\n\tcase 'i': // \"aai\"\n\t\tr_core_anal_info (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"aas\"\n\t\tr_core_cmd0 (core, \"af @@= `isq~[0]`\");\n\t\tr_core_cmd0 (core, \"af @@ entry*\");\n\t\tbreak;\n\tcase 'n': // \"aan\"\n\t\tr_core_anal_autoname_all_fcns (core);\n\t\tbreak; //aan\n\tcase 'p': // \"aap\"\n\t\tif (*input == '?') {\n\t\t\t// TODO: accept parameters for ranges\n\t\t\teprintf (\"Usage: /aap   ; find in memory for function preludes\");\n\t\t} else {\n\t\t\tr_core_search_preludes (core);\n\t\t}\n\t\tbreak;\n\tcase '\\0': // \"aa\"\n\tcase 'a':\n\t\tif (input[0] && (input[1] == '?' || (input[1] && input[2] == '?'))) {\n\t\t\tr_cons_println (\"Usage: See aa? for more help\");\n\t\t} else {\n\t\t\tchar *dh_orig = NULL;\n\t\t\tif (!strncmp (input, \"aaaaa\", 5)) {\n\t\t\t\teprintf (\"An r2 developer is coming to your place to manually analyze this program. Please wait for it\\n\");\n\t\t\t\tif (r_config_get_i (core->config, \"scr.interactive\")) {\n\t\t\t\t\tr_cons_any_key (NULL);\n\t\t\t\t}\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\t\t\tut64 curseek = core->offset;\n\t\t\trowlog (core, \"Analyze all flags starting with sym. and entry0 (aa)\");\n\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\tr_cons_break_timeout (r_config_get_i (core->config, \"anal.timeout\"));\n\t\t\tr_core_anal_all (core);\n\t\t\trowlog_done (core);\n\t\t\tdh_orig = core->dbg->h\n\t\t\t\t\t? strdup (core->dbg->h->name)\n\t\t\t\t\t: strdup (\"esil\");\n\t\t\tif (core->io && core->io->desc && core->io->desc->plugin && !core->io->desc->plugin->isdbg) {\n\t\t\t\t//use dh_origin if we are debugging\n\t\t\t\tR_FREE (dh_orig);\n\t\t\t}\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\t\t\tr_cons_clear_line (1);\n\t\t\tif (*input == 'a') { // \"aaa\"\n\t\t\t\tif (dh_orig && strcmp (dh_orig, \"esil\")) {\n\t\t\t\t\tr_core_cmd0 (core, \"dL esil\");\n\t\t\t\t}\n\t\t\t\tint c = r_config_get_i (core->config, \"anal.calls\");\n\t\t\t\tif (should_aav (core)) {\n\t\t\t\t\trowlog (core, \"\\nAnalyze value pointers (aav)\");\n\t\t\t\t\tr_core_cmd0 (core, \"aav\");\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_config_set_i (core->config, \"anal.calls\", 1);\n\t\t\t\tr_core_cmd0 (core, \"s $S\");\n\t\t\t\trowlog (core, \"Analyze len bytes of instructions for references (aar)\");\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\t(void)r_core_anal_refs (core, \"\"); // \"aar\"\n\t\t\t\trowlog_done (core);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\trowlog (core, \"Analyze function calls (aac)\");\n\t\t\t\t(void) cmd_anal_calls (core, \"\", false); // \"aac\"\n\t\t\t\tr_core_seek (core, curseek, 1);\n\t\t\t\t// rowlog (core, \"Analyze data refs as code (LEA)\");\n\t\t\t\t// (void) cmd_anal_aad (core, NULL); // \"aad\"\n\t\t\t\trowlog_done (core);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\tif (input[1] == 'a') { // \"aaaa\"\n\t\t\t\t\tbool ioCache = r_config_get_i (core->config, \"io.pcache\");\n\t\t\t\t\tr_config_set_i (core->config, \"io.pcache\", 1);\n\t\t\t\t\trowlog (core, \"Emulate code to find computed references (aae)\");\n\t\t\t\t\tr_core_cmd0 (core, \"aae $SS @ $S\");\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t\trowlog (core, \"Analyze consecutive function (aat)\");\n\t\t\t\t\tr_core_cmd0 (core, \"aat\");\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t\t// drop cache writes is no cache was\n\t\t\t\t\tif (!ioCache) {\n\t\t\t\t\t\tr_core_cmd0 (core, \"wc-*\");\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set_i (core->config, \"io.pcache\", ioCache);\n\t\t\t\t} else {\n\t\t\t\t\trowlog (core, \"Use -AA or aaaa to perform additional experimental analysis.\");\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t}\n\t\t\t\tr_config_set_i (core->config, \"anal.calls\", c);\n\t\t\t\trowlog (core, \"Constructing a function name for fcn.* and sym.func.* functions (aan)\");\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\tif (r_config_get_i (core->config, \"anal.autoname\")) {\n\t\t\t\t\tr_core_anal_autoname_all_fcns (core);\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t}\n\t\t\t\tif (input[1] == 'a') { // \"aaaa\"\n\t\t\t\t\tbool ioCache = r_config_get_i (core->config, \"io.pcache\");\n\t\t\t\t\tr_config_set_i (core->config, \"io.pcache\", 1);\n\t\t\t\t\tif (sdb_count (core->anal->sdb_zigns) > 0) {\n\t\t\t\t\t\trowlog (core, \"Check for zignature from zigns folder (z/)\");\n\t\t\t\t\t\tr_core_cmd0 (core, \"z/\");\n\t\t\t\t\t}\n\t\t\t\t\trowlog (core, \"Type matching analysis for all functions (afta)\");\n\t\t\t\t\tr_core_cmd0 (core, \"afta\");\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t\tif (!ioCache) {\n\t\t\t\t\t\tr_core_cmd0 (core, \"wc-*\");\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set_i (core->config, \"io.pcache\", ioCache);\n\t\t\t\t}\n\t\t\t\tr_core_cmd0 (core, \"s-\");\n\t\t\t\tif (dh_orig) {\n\t\t\t\t\tr_core_cmdf (core, \"dL %s;dpa\", dh_orig);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_seek (core, curseek, 1);\n\t\tjacuzzi:\n\t\t\tflag_every_function (core);\n\t\t\tr_cons_break_pop ();\n\t\t\tR_FREE (dh_orig);\n\t\t}\n\t\tbreak;\n\tcase 't': { // \"aat\"\n\t\tut64 cur = core->offset;\n\t\tbool hasnext = r_config_get_i (core->config, \"anal.hasnext\");\n\t\tRListIter *iter;\n\t\tRIOMap* map;\n\t\tRList *list = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, \"anal\");\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tr_core_seek (core, map->itv.addr, 1);\n\t\t\tr_config_set_i (core->config, \"anal.hasnext\", 1);\n\t\t\tr_core_cmd0 (core, \"afr\");\n\t\t\tr_config_set_i (core->config, \"anal.hasnext\", hasnext);\n\t\t}\n\t\tr_core_seek (core, cur, 1);\n\t\tbreak;\n\t}\n\tcase 'T': // \"aaT\"\n\t\tcmd_anal_aftertraps (core, input + 1);\n\t\tbreak;\n\tcase 'E': // \"aaE\"\n\t\tr_core_cmd0 (core, \"aef @@f\");\n\t\tbreak;\n\tcase 'e': // \"aae\"\n\t\tif (input[1]) {\n\t\t\tconst char *len = (char *) input + 1;\n\t\t\tchar *addr = strchr (input + 2, ' ');\n\t\t\tif (addr) {\n\t\t\t\t*addr++ = 0;\n\t\t\t}\n\t\t\tr_core_anal_esil (core, len, addr);\n\t\t} else {\n\t\t\tut64 at = core->offset;\n\t\t\tRIOMap* map;\n\t\t\tRListIter *iter;\n\t\t\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"anal\");\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tr_core_seek (core, map->itv.addr, 1);\n\t\t\t\tr_core_anal_esil (core, \"$SS\", NULL);\n\t\t\t}\n\t\t\tr_core_seek (core, at, 1);\n\t\t}\n\t\tbreak;\n\tcase 'r':\n\t\t(void)r_core_anal_refs (core, input + 1);\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_aa);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_fcn_size (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t\tgap = false;\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int cmpaddr (const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn a->addr - b->addr;\n}\n\nstatic bool anal_fcn_data_gaps (RCore *core, const char *input) {\n\tut64 end = UT64_MAX;\n\tRAnalFunction *fcn;\n\tRListIter *iter;\n\tint i, wordsize = (core->assembler->bits == 64)? 8: 4;\n\tr_list_sort (core->anal->fcns, cmpaddr);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tif (end != UT64_MAX) {\n\t\t\tint range = fcn->addr - end;\n\t\t\tif (range > 0) {\n\t\t\t\tfor (i = 0; i + wordsize < range; i+= wordsize) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", wordsize, end + i);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", range - i, end + i);\n\t\t\t\t//r_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", range, end);\n\t\t\t}\n\t\t}\n\t\tend = fcn->addr + r_anal_fcn_size (fcn);\n\t}\n\treturn true;\n}\n\nstatic void cmd_anal_rtti(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '\\0': // \"avr\"\n\tcase 'j': // \"avrj\"\n\t\tr_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);\n\t\tbreak;\n\tcase 'a': // \"avra\"\n\t\tr_anal_rtti_print_all (core->anal, input[1]);\n\t\tbreak;\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_virtual_functions(RCore *core, const char* input) {\n\tswitch (input[0]) {\n\tcase '\\0': // \"av\"\n\tcase '*': // \"av*\"\n\tcase 'j': // \"avj\"\n\t\tr_anal_list_vtables (core->anal, input[0]);\n\t\tbreak;\n\tcase 'r': // \"avr\"\n\t\tcmd_anal_rtti (core, input + 1);\n\t\tbreak;\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}\n\nstatic int cmd_anal(void *data, const char *input) {\n\tconst char *r;\n\tRCore *core = (RCore *)data;\n\tut32 tbs = core->blocksize;\n\n\tswitch (input[0]) {\n\tcase 'p': // \"ap\"\n\t\t{\n\t\t\tconst ut8 *prelude = (const ut8*)\"\\xe9\\x2d\"; //:fffff000\";\n\t\t\tconst int prelude_sz = 2;\n\t\t\tconst int bufsz = 4096;\n\t\t\tut8 *buf = calloc (1, bufsz);\n\t\t\tut64 off = core->offset;\n\t\t\tif (input[1] == ' ') {\n\t\t\t\toff = r_num_math (core->num, input+1);\n\t\t\t\tr_io_read_at (core->io, off - bufsz + prelude_sz, buf, bufsz);\n\t\t\t} else {\n\t\t\t\tr_io_read_at (core->io, off - bufsz + prelude_sz, buf, bufsz);\n\t\t\t}\n\t\t\t//const char *prelude = \"\\x2d\\xe9\\xf0\\x47\"; //:fffff000\";\n\t\t\tr_mem_reverse (buf, bufsz);\n\t\t\t//r_print_hexdump (NULL, off, buf, bufsz, 16, -16);\n\t\t\tconst ut8 *pos = r_mem_mem (buf, bufsz, prelude, prelude_sz);\n\t\t\tif (pos) {\n\t\t\t\tint delta = (size_t)(pos - buf);\n\t\t\t\teprintf (\"POS = %d\\n\", delta);\n\t\t\t\teprintf (\"HIT = 0x%\"PFMT64x\"\\n\", off - delta);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", off - delta);\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot find prelude\\n\");\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase '8':\n\t\t{\n\t\t\tut8 *buf = malloc (strlen (input) + 1);\n\t\t\tif (buf) {\n\t\t\t\tint len = r_hex_str2bin (input + 1, buf);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tcore_anal_bytes (core, buf, len, 0, input[1]);\n\t\t\t\t}\n\t\t\t\tfree (buf);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'b':\n\t\tif (input[1] == 'b') { // \"abb\"\n\t\t\tcore_anal_bbs (core, input + 2);\n\t\t} else if (input[1] == 'r') { // \"abr\"\n\t\t\tcore_anal_bbs_range (core, input + 2);\n\t\t} else if (input[1] == ' ' || !input[1]) {\n\t\t\t// find block\n\t\t\tut64 addr = core->offset;\n\t\t\tif (input[1]) {\n\t\t\t\taddr = r_num_math (core->num, input + 1);\n\t\t\t}\n\t\t\tr_core_cmdf (core, \"afbi @ 0x%\"PFMT64x, addr);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ab);\n\t\t}\n\t\tbreak;\n\tcase 'i': cmd_anal_info (core, input + 1); break; // \"ai\"\n\tcase 'r': cmd_anal_reg (core, input + 1); break;  // \"ar\"\n\tcase 'e': cmd_anal_esil (core, input + 1); break; // \"ae\"\n\tcase 'o': cmd_anal_opcode (core, input + 1); break; // \"ao\"\n\tcase 'O': cmd_anal_bytes (core, input + 1); break; // \"aO\"\n\tcase 'F': // \"aF\"\n\t\tr_core_anal_fcn (core, core->offset, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n\t\tbreak;\n\tcase 'f': // \"af\"\n\t\t{\n\t\tint res = cmd_anal_fcn (core, input);\n\t\tif (!res) {\n\t\t\treturn false;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'n': // 'an'\n\t\t{\n\t\tconst char *name = NULL;\n\t\tbool use_json = false;\n\n\t\tif (input[1] == 'j') {\n\t\t\tuse_json = true;\n\t\t\tinput++;\n\t\t}\n\n\t\tif (input[1] == ' ') {\n\t\t\tname = input + 1;\n\t\t\twhile (name[0] == ' ') {\n\t\t\t\tname++;\n\t\t\t}\n\t\t\tchar *end = strchr (name, ' ');\n\t\t\tif (end) {\n\t\t\t\t*end = '\\0';\n\t\t\t}\n\t\t\tif (*name == '\\0') {\n\t\t\t\tname = NULL;\n\t\t\t}\n\t\t}\n\n\t\tcmd_an (core, use_json, name);\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"ag\"\n\t\tcmd_anal_graph (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"as\"\n\t\tcmd_anal_syscall (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"av\"\n\t\tcmd_anal_virtual_functions (core, input + 1);\n\t\tbreak;\n\tcase 'x': // \"ax\"\n\t\tif (!cmd_anal_refs (core, input + 1)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"aa\"\n\t\tif (!cmd_anal_all (core, input + 1))\n\t\t\treturn false;\n\t\tbreak;\n\tcase 'c': // \"ac\"\n\t\t{\n\t\tRList *hooks;\n\t\tRListIter *iter;\n\t\tRAnalCycleHook *hook;\n\t\tchar *instr_tmp = NULL;\n\t\tint ccl = input[1]? r_num_math (core->num, &input[2]): 0; //get cycles to look for\n\t\tint cr = r_config_get_i (core->config, \"asm.cmt.right\");\n\t\tint fun = r_config_get_i (core->config, \"asm.functions\");\n\t\tint li = r_config_get_i (core->config, \"asm.lines\");\n\t\tint xr = r_config_get_i (core->config, \"asm.xrefs\");\n\n\t\tr_config_set_i (core->config, \"asm.cmt.right\", true);\n\t\tr_config_set_i (core->config, \"asm.functions\", false);\n\t\tr_config_set_i (core->config, \"asm.lines\", false);\n\t\tr_config_set_i (core->config, \"asm.xrefs\", false);\n\n\t\thooks = r_core_anal_cycles (core, ccl); //analyse\n\t\tr_cons_clear_line (1);\n\t\tr_list_foreach (hooks, iter, hook) {\n\t\t\tinstr_tmp = r_core_disassemble_instr (core, hook->addr, 1);\n\t\t\tr_cons_printf (\"After %4i cycles:\\t%s\", (ccl - hook->cycles), instr_tmp);\n\t\t\tr_cons_flush ();\n\t\t\tfree (instr_tmp);\n\t\t}\n\t\tr_list_free (hooks);\n\n\t\tr_config_set_i (core->config, \"asm.cmt.right\", cr); //reset settings\n\t\tr_config_set_i (core->config, \"asm.functions\", fun);\n\t\tr_config_set_i (core->config, \"asm.lines\", li);\n\t\tr_config_set_i (core->config, \"asm.xrefs\", xr);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ad\"\n\t\tswitch (input[1]) {\n\t\tcase 'f': // \"adf\"\n\t\t\tif (input[2] == 'g') {\n\t\t\t\tanal_fcn_data_gaps (core, input + 1);\n\t\t\t} else {\n\t\t\t\tanal_fcn_data (core, input + 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't': // \"adt\"\n\t\t\tcmd_anal_trampoline (core, input + 2);\n\t\t\tbreak;\n\t\tcase ' ': { // \"ad\"\n\t\t\tconst int default_depth = 1;\n\t\t\tconst char *p;\n\t\t\tint a, b;\n\t\t\ta = r_num_math (core->num, input + 2);\n\t\t\tp = strchr (input + 2, ' ');\n\t\t\tb = p? r_num_math (core->num, p + 1): default_depth;\n\t\t\tif (a < 1) {\n\t\t\t\ta = 1;\n\t\t\t}\n\t\t\tif (b < 1) {\n\t\t\t\tb = 1;\n\t\t\t}\n\t\t\tr_core_anal_data (core, core->offset, a, b, 0);\n\t\t} break;\n\t\tcase 'k': // \"adk\"\n\t\t\tr = r_anal_data_kind (core->anal,\n\t\t\t\t\tcore->offset, core->block, core->blocksize);\n\t\t\tr_cons_println (r);\n\t\t\tbreak;\n\t\tcase '\\0': // \"ad\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 0);\n\t\t\tbreak;\n\t\tcase '4': // \"ad4\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 4);\n\t\t\tbreak;\n\t\tcase '8': // \"ad8\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ad);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ah\"\n\t\tcmd_anal_hint (core, input + 1);\n\t\tbreak;\n\tcase '!': // \"a!\"\n\t\tif (core->anal && core->anal->cur && core->anal->cur->cmd_ext) {\n\t\t\treturn core->anal->cur->cmd_ext (core->anal, input + 1);\n\t\t} else {\n\t\t\tr_cons_printf (\"No plugins for this analysis plugin\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_a);\n#if 0\n\t\tr_cons_printf (\"Examples:\\n\"\n\t\t\t\" f ts @ `S*~text:0[3]`; f t @ section..text\\n\"\n\t\t\t\" f ds @ `S*~data:0[3]`; f d @ section..data\\n\"\n\t\t\t\" .ad t t+ts @ d:ds\\n\",\n\t\t\tNULL);\n#endif\n\t\tbreak;\n\t}\n\tif (tbs != core->blocksize) {\n\t\tr_core_block_size (core, tbs);\n\t}\n\tif (r_cons_is_breaked ()) {\n\t\tr_cons_clear_line (1);\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2011-2018 - pancake, Roc Valles, condret, killabyte */\n\n#if 0\nhttp://www.atmel.com/images/atmel-0856-avr-instruction-set-manual.pdf\nhttps://en.wikipedia.org/wiki/Atmel_AVR_instruction_set\n#endif\n\n#include <string.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n\nstatic RDESContext desctx;\n\ntypedef struct _cpu_const_tag {\n\tconst char *const key;\n\tut8 type;\n\tut32 value;\n\tut8 size;\n} CPU_CONST;\n\n#define CPU_CONST_NONE\t0\n#define CPU_CONST_PARAM\t1\n#define CPU_CONST_REG\t2\n\ntypedef struct _cpu_model_tag {\n\tconst char *const model;\n\tint pc;\n\tchar *inherit;\n\tstruct _cpu_model_tag *inherit_cpu_p;\n\tCPU_CONST *consts[10];\n} CPU_MODEL;\n\ntypedef void (*inst_handler_t) (RAnal *anal, RAnalOp *op, const ut8 *buf, int len, int *fail, CPU_MODEL *cpu);\n\ntypedef struct _opcodes_tag_ {\n\tconst char *const name;\n\tint mask;\n\tint selector;\n\tinst_handler_t handler;\n\tint cycles;\n\tint size;\n\tut64 type;\n} OPCODE_DESC;\n\nstatic OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu);\n\n#define CPU_MODEL_DECL(model, pc, consts)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tmodel,\t\t\t\t\t\t\t\\\n\t\tpc,\t\t\t\t\t\t\t\\\n\t\tconsts\t\t\t\t\t\t\t\\\n\t}\n#define MASK(bits)\t\t\t((bits) == 32 ? 0xffffffff : (~((~((ut32) 0)) << (bits))))\n#define CPU_PC_MASK(cpu)\t\tMASK((cpu)->pc)\n#define CPU_PC_SIZE(cpu)\t\t((((cpu)->pc) >> 3) + ((((cpu)->pc) & 0x07) ? 1 : 0))\n\n#define INST_HANDLER(OPCODE_NAME)\tstatic void _inst__ ## OPCODE_NAME (RAnal *anal, RAnalOp *op, const ut8 *buf, int len, int *fail, CPU_MODEL *cpu)\n#define INST_DECL(OP, M, SL, C, SZ, T)\t{ #OP, (M), (SL), _inst__ ## OP, (C), (SZ), R_ANAL_OP_TYPE_ ## T }\n#define INST_LAST\t\t\t{ \"unknown\", 0, 0, (void *) 0, 2, 1, R_ANAL_OP_TYPE_UNK }\n\n#define INST_CALL(OPCODE_NAME)\t\t_inst__ ## OPCODE_NAME (anal, op, buf, len, fail, cpu)\n#define INST_INVALID\t\t\t{ *fail = 1; return; }\n#define INST_ASSERT(x)\t\t\t{ if (!(x)) { INST_INVALID; } }\n\n#define ESIL_A(e, ...)\t\t\tr_strbuf_appendf (&op->esil, e, ##__VA_ARGS__)\n\n#define STR_BEGINS(in, s)\t\tstrncasecmp (in, s, strlen (s))\n\n// Following IO definitions are valid for:\n//\tATmega8\n//\tATmega88\nCPU_CONST cpu_reg_common[] = {\n\t{ \"spl\",    CPU_CONST_REG, 0x3d, sizeof (ut8) },\n\t{ \"sph\",    CPU_CONST_REG, 0x3e, sizeof (ut8) },\n\t{ \"sreg\",   CPU_CONST_REG, 0x3f, sizeof (ut8) },\n\t{ \"spmcsr\", CPU_CONST_REG, 0x37, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_common[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,  512, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM, 0x40, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM, 0x60, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 1024, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_m640_m1280m_m1281_m2560_m2561[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,    512, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM,  0x1ff, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM,  0x200, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 0x2000, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_xmega128a4u[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,  0x800, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM, 0x1000, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM,  0x800, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 0x2000, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_pagesize_5_bits[] = {\n\t{ \"page_size\", CPU_CONST_PARAM, 5, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_pagesize_7_bits[] = {\n\t{ \"page_size\", CPU_CONST_PARAM, 7, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_MODEL cpu_models[] = {\n\t{ .model = \"ATmega640\",   .pc = 15,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_m640_m1280m_m1281_m2560_m2561,\n\t\t\tcpu_pagesize_7_bits,\n\t\t\tNULL\n\t\t},\n\t},\n\t{\n\t\t.model = \"ATxmega128a4u\", .pc = 17,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_xmega128a4u,\n\t\t\tcpu_pagesize_7_bits,\n\t\t\tNULL\n\t\t}\n\t},\n\t{ .model = \"ATmega1280\",  .pc = 16, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega1281\",  .pc = 16, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega2560\",  .pc = 17, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega2561\",  .pc = 17, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega88\",    .pc = 8,  .inherit = \"ATmega8\" },\n//\tCPU_MODEL_DECL (\"ATmega168\",   13, 512, 512),\n\t// last model is the default AVR - ATmega8 forever!\n\t{\n\t\t.model = \"ATmega8\", .pc = 13,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_common,\n\t\t\tcpu_pagesize_5_bits,\n\t\t\tNULL\n\t\t}\n\t},\n};\n\nstatic CPU_MODEL *get_cpu_model(char *model);\n\nstatic CPU_MODEL *__get_cpu_model_recursive(char *model) {\n\tCPU_MODEL *cpu = NULL;\n\n\tfor (cpu = cpu_models; cpu < cpu_models + ((sizeof (cpu_models) / sizeof (CPU_MODEL))) - 1; cpu++) {\n\t\tif (!strcasecmp (model, cpu->model)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// fix inheritance tree\n\tif (cpu->inherit && !cpu->inherit_cpu_p) {\n\t\tcpu->inherit_cpu_p = get_cpu_model (cpu->inherit);\n\t\tif (!cpu->inherit_cpu_p) {\n\t\t\teprintf (\"ERROR: Cannot inherit from unknown CPU model '%s'.\\n\", cpu->inherit);\n\t\t}\n\t}\n\n\treturn cpu;\n}\n\nstatic CPU_MODEL *get_cpu_model(char *model) {\n\tstatic CPU_MODEL *cpu = NULL;\n\n\t// cached value?\n\tif (cpu && !strcasecmp (model, cpu->model))\n\t\treturn cpu;\n\n\t// do the real search\n\tcpu = __get_cpu_model_recursive (model);\n\n\treturn cpu;\n}\n\nstatic ut32 const_get_value(CPU_CONST *c) {\n\treturn c ? MASK (c->size * 8) & c->value : 0;\n}\n\n\nstatic CPU_CONST *const_by_name(CPU_MODEL *cpu, int type, char *c) {\n\tCPU_CONST **clist, *citem;\n\n\tfor (clist = cpu->consts; *clist; clist++) {\n\t\tfor (citem = *clist; citem->key; citem++) {\n\t\t\tif (!strcmp (c, citem->key)\n\t\t\t&& (type == CPU_CONST_NONE || type == citem->type)) {\n\t\t\t\treturn citem;\n\t\t\t}\n\t\t}\n\t}\n\tif (cpu->inherit_cpu_p)\n\t\treturn const_by_name (cpu->inherit_cpu_p, type, c);\n\teprintf (\"ERROR: CONSTANT key[%s] NOT FOUND.\\n\", c);\n\treturn NULL;\n}\n\nstatic int __esil_pop_argument(RAnalEsil *esil, ut64 *v) {\n\tchar *t = r_anal_esil_pop (esil);\n\tif (!t || !r_anal_esil_get_parm (esil, t, v)) {\n\t\tfree (t);\n\t\treturn false;\n\t}\n\tfree (t);\n\treturn true;\n}\n\nstatic CPU_CONST *const_by_value(CPU_MODEL *cpu, int type, ut32 v) {\n\tCPU_CONST **clist, *citem;\n\n\tfor (clist = cpu->consts; *clist; clist++) {\n\t\tfor (citem = *clist; citem && citem->key; citem++) {\n\t\t\tif (citem->value == (MASK (citem->size * 8) & v)\n\t\t\t&& (type == CPU_CONST_NONE || type == citem->type)) {\n\t\t\t\treturn citem;\n\t\t\t}\n\t\t}\n\t}\n\tif (cpu->inherit_cpu_p)\n\t\treturn const_by_value (cpu->inherit_cpu_p, type, v);\n\treturn NULL;\n}\n\nstatic RStrBuf *__generic_io_dest(ut8 port, int write, CPU_MODEL *cpu) {\n\tRStrBuf *r = r_strbuf_new (\"\");\n\tCPU_CONST *c = const_by_value (cpu, CPU_CONST_REG, port);\n\tif (c != NULL) {\n\t\tr_strbuf_set (r, c->key);\n\t\tif (write) {\n\t\t\tr_strbuf_append (r, \",=\");\n\t\t}\n\t} else {\n\t\tr_strbuf_setf (r, \"_io,%d,+,%s[1]\", port, write ? \"=\" : \"\");\n\t}\n\n\treturn r;\n}\n\nstatic void __generic_bitop_flags(RAnalOp *op) {\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n}\n\nstatic void __generic_ld_st(RAnalOp *op, char *mem, char ireg, int use_ramp, int prepostdec, int offset, int st) {\n\tif (ireg) {\n\t\t// preincrement index register\n\t\tif (prepostdec < 0) {\n\t\t\tESIL_A (\"1,%c,-,%c,=,\", ireg, ireg);\n\t\t}\n\t\t// set register index address\n\t\tESIL_A (\"%c,\", ireg);\n\t\t// add offset\n\t\tif (offset != 0) {\n\t\t\tESIL_A (\"%d,+,\", offset);\n\t\t}\n\t} else {\n\t\tESIL_A (\"%d,\", offset);\n\t}\n\tif (use_ramp) {\n\t\tESIL_A (\"16,ramp%c,<<,+,\", ireg ? ireg : 'd');\n\t}\n\t// set SRAM base address\n\tESIL_A (\"_%s,+,\", mem);\n\t// read/write from SRAM\n\tESIL_A (\"%s[1],\", st ? \"=\" : \"\");\n\t// postincrement index register\n\tif (ireg && prepostdec > 0) {\n\t\tESIL_A (\"1,%c,+,%c,=,\", ireg, ireg);\n\t}\n}\n\nstatic void __generic_pop(RAnalOp *op, int sz) {\n\tif (sz > 1) {\n\t\tESIL_A (\"1,sp,+,_ram,+,\");\t// calc SRAM(sp+1)\n\t\tESIL_A (\"[%d],\", sz);\t\t// read value\n\t\tESIL_A (\"%d,sp,+=,\", sz);\t// sp += item_size\n\t} else {\n\t\tESIL_A (\"1,sp,+=,\"\t\t// increment stack pointer\n\t\t\t\"sp,_ram,+,[1],\");\t// load SRAM[sp]\n\t}\n}\n\nstatic void __generic_push(RAnalOp *op, int sz) {\n\tESIL_A (\"sp,_ram,+,\");\t\t\t// calc pointer SRAM(sp)\n\tif (sz > 1) {\n\t\tESIL_A (\"-%d,+,\", sz - 1);\t// dec SP by 'sz'\n\t}\n\tESIL_A (\"=[%d],\", sz);\t\t\t// store value in stack\n\tESIL_A (\"-%d,sp,+=,\", sz);\t\t// decrement stack pointer\n}\n\nstatic void __generic_add_update_flags(RAnalOp *op, char t_d, ut64 v_d, char t_rk, ut64 v_rk) {\n\tRStrBuf *d_strbuf, *rk_strbuf;\n\tchar *d, *rk;\n\n\td_strbuf = r_strbuf_new (NULL);\n\trk_strbuf = r_strbuf_new (NULL);\n\tr_strbuf_setf (d_strbuf,  t_d  == 'r' ? \"r%d\" : \"%\" PFMT64d, v_d);\n\tr_strbuf_setf (rk_strbuf, t_rk == 'r' ? \"r%d\" : \"%\" PFMT64d, v_rk);\n\n\td = r_strbuf_get(d_strbuf);\n\trk = r_strbuf_get(rk_strbuf);\n\n\tESIL_A (\"%s,0x08,&,!,!,\" \"%s,0x08,&,!,!,\"    \"&,\"\t// H\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,\" \"&,\"\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,\" \"&,\"\n\t\t\"|,|,hf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,!,\"      \"&,\"\t// V\n\t\t\"\"               \"0,RPICK,0x80,&,!,\"   \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"%s,0x80,&,!,\"        \"&,\"\n\t\t\"\"               \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,vf,=,\",\n\t\td, rk, d, rk);\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,!,\"    \"&,\"\t// C\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,\" \"&,\"\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,\" \"&,\"\n\t\t\"|,|,cf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\n\tr_strbuf_free (d_strbuf);\n\tr_strbuf_free (rk_strbuf);\n}\n\nstatic void __generic_add_update_flags_rr(RAnalOp *op, int d, int r) {\n\t__generic_add_update_flags(op, 'r', d, 'r', r);\n}\n\nstatic void __generic_sub_update_flags(RAnalOp *op, char t_d, ut64 v_d, char t_rk, ut64 v_rk, int carry) {\n\tRStrBuf *d_strbuf, *rk_strbuf;\n\tchar *d, *rk;\n\n\td_strbuf = r_strbuf_new (NULL);\n\trk_strbuf = r_strbuf_new (NULL);\n\tr_strbuf_setf (d_strbuf,  t_d  == 'r' ? \"r%d\" : \"%\" PFMT64d, v_d);\n\tr_strbuf_setf (rk_strbuf, t_rk == 'r' ? \"r%d\" : \"%\" PFMT64d, v_rk);\n\n\td = r_strbuf_get(d_strbuf);\n\trk = r_strbuf_get(rk_strbuf);\n\n\tESIL_A (\"%s,0x08,&,!,\"   \"%s,0x08,&,!,!,\"      \"&,\"\t// H\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,!,\" \"&,\"\n\t\t\"%s,0x08,&,!,\"   \"0,RPICK,0x08,&,!,!,\" \"&,\"\n\t\t\"|,|,hf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,\"        \"&,\"\t// V\n\t\t\"\"               \"0,RPICK,0x80,&,!,\"   \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"%s,0x80,&,!,!,\"      \"&,\"\n\t\t\"\"               \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,vf,=,\",\n\t\td, rk, d, rk);\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tif (carry)\n\t\tESIL_A (\"0,RPICK,!,zf,&,zf,=,\");\t\t// Z\n\telse\n\t\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"%s,0x80,&,!,\"   \"%s,0x80,&,!,!,\"      \"&,\"\t// C\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,|,cf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\n\tr_strbuf_free (d_strbuf);\n\tr_strbuf_free (rk_strbuf);\n}\n\nstatic void __generic_sub_update_flags_rr(RAnalOp *op, int d, int r, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'r', r, carry);\n}\n\nstatic void __generic_sub_update_flags_rk(RAnalOp *op, int d, int k, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'k', k, carry);\n}\n\nINST_HANDLER (adc) {\t// ADC Rd, Rr\n\t\t\t// ROL Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,cf,+,r%d,+,\", r, d);\t\t// Rd + Rr + C\n\t__generic_add_update_flags_rr(op, d, r);\t// FLAGS\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (add) {\t// ADD Rd, Rr\n\t\t\t// LSL Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,+,\", r, d);\t\t\t// Rd + Rr\n\t__generic_add_update_flags_rr(op, d, r);\t// FLAGS\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (adiw) {\t// ADIW Rd+1:Rd, K\n\tint d = ((buf[0] & 0x30) >> 3) + 24;\n\tint k = (buf[0] & 0xf) | ((buf[0] >> 2) & 0x30);\n\top->val = k;\n\tESIL_A (\"r%d:r%d,%d,+,\", d + 1, d, k);\t\t\t// Rd+1:Rd + Rr\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"r%d,0x80,&,!,\"\t\t\t\t\t// V\n\t\t\"0,RPICK,0x8000,&,!,!,\"\n\t\t\"&,vf,=,\", d + 1);\n\tESIL_A (\"0,RPICK,0x8000,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"r%d,0x80,&,!,!,\"\t\t\t\t// C\n\t\t\"0,RPICK,0x8000,&,!,\"\n\t\t\"&,cf,=,\", d + 1);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d:r%d,=,\", d + 1, d);\t\t\t// Rd = result\n}\n\nINST_HANDLER (and) {\t// AND Rd, Rr\n\t\t\t// TST Rd\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,&,\", r, d);\t\t\t\t// 0: Rd & Rr\n\t__generic_bitop_flags (op);\t\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (andi) {\t// ANDI Rd, K\n\t\t\t// CBR Rd, K (= ANDI Rd, 1-K)\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0x0f) << 4) | (buf[0] & 0x0f);\n\top->val = k;\n\tESIL_A (\"%d,r%d,&,\", k, d);\t\t\t\t// 0: Rd & Rr\n\t__generic_bitop_flags (op);\t\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (asr) {\t// ASR Rd\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"1,r%d,>>,r%d,0x80,&,|,\", d, d);\t\t// 0: R=(Rd >> 1) | Rd7\n\tESIL_A (\"r%d,0x1,&,!,!,cf,=,\", d);\t\t\t// C = Rd0\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t\t// V\n\tESIL_A (\"nf,vf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = R\n}\n\nINST_HANDLER (bclr) {\t// BCLR s\n\t\t\t// CLC\n\t\t\t// CLH\n\t\t\t// CLI\n\t\t\t// CLN\n\t\t\t// CLR\n\t\t\t// CLS\n\t\t\t// CLT\n\t\t\t// CLV\n\t\t\t// CLZ\n\tint s = (buf[0] >> 4) & 0x7;\n\tESIL_A (\"0xff,%d,1,<<,^,sreg,&=,\", s);\n}\n\nINST_HANDLER (bld) {\t// BLD Rd, b\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[1] & 0x01) << 4) | ((buf[0] >> 4) & 0xf);\n\tint b = buf[0] & 0x7;\n\tESIL_A (\"r%d,%d,1,<<,0xff,^,&,\", d, b);\t\t\t// Rd/b = 0\n\tESIL_A (\"%d,tf,<<,|,r%d,=,\", b, d);\t\t\t// Rd/b |= T<<b\n}\n\nINST_HANDLER (brbx) {\t// BRBC s, k\n\t\t\t// BRBS s, k\n\t\t\t// BRBC/S 0:\t\tBRCC\t\tBRCS\n\t\t\t//\t\t\tBRSH\t\tBRLO\n\t\t\t// BRBC/S 1:\t\tBREQ\t\tBRNE\n\t\t\t// BRBC/S 2:\t\tBRPL\t\tBRMI\n\t\t\t// BRBC/S 3:\t\tBRVC\t\tBRVS\n\t\t\t// BRBC/S 4:\t\tBRGE\t\tBRLT\n\t\t\t// BRBC/S 5:\t\tBRHC\t\tBRHS\n\t\t\t// BRBC/S 6:\t\tBRTC\t\tBRTS\n\t\t\t// BRBC/S 7:\t\tBRID\t\tBRIE\n\tint s = buf[0] & 0x7;\n\top->jump = op->addr\n\t\t+ ((((buf[1] & 0x03) << 6) | ((buf[0] & 0xf8) >> 2))\n\t\t\t| (buf[1] & 0x2 ? ~((int) 0x7f) : 0))\n\t\t+ 2;\n\top->fail = op->addr + op->size;\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"%d,1,<<,sreg,&,\", s);\t\t\t\t// SREG(s)\n\tESIL_A (buf[1] & 0x4\n\t\t\t? \"!,\"\t\t// BRBC => branch if cleared\n\t\t\t: \"!,!,\");\t// BRBS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (break) {\t// BREAK\n\tESIL_A (\"BREAK\");\n}\n\nINST_HANDLER (bset) {\t// BSET s\n\t\t\t// SEC\n\t\t\t// SEH\n\t\t\t// SEI\n\t\t\t// SEN\n\t\t\t// SER\n\t\t\t// SES\n\t\t\t// SET\n\t\t\t// SEV\n\t\t\t// SEZ\n\tint s = (buf[0] >> 4) & 0x7;\n\tESIL_A (\"%d,1,<<,sreg,|=,\", s);\n}\n\nINST_HANDLER (bst) {\t// BST Rd, b\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tESIL_A (\"r%d,%d,1,<<,&,!,!,tf,=,\",\t\t\t// tf = Rd/b\n\t\t((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf),\t// r\n\t\tbuf[0] & 0x7);\t\t\t\t\t// b\n}\n\nINST_HANDLER (call) {\t// CALL k\n\tif (len < 4) {\n\t\treturn;\n\t}\n\top->jump = (buf[2] << 1)\n\t\t | (buf[3] << 9)\n\t\t | (buf[1] & 0x01) << 23\n\t\t | (buf[0] & 0x01) << 17\n\t\t | (buf[0] & 0xf0) << 14;\n\top->fail = op->addr + op->size;\n\top->cycles = cpu->pc <= 16 ? 3 : 4;\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\top->cycles--;\t// AT*mega optimizes one cycle\n\t}\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n}\n\nINST_HANDLER (cbi) {\t// CBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->family = R_ANAL_OP_FAMILY_IO;\n\top->type2 = 1;\n\top->val = a;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,^,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (com) {\t// COM Rd\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 1) << 4);\n\n\tESIL_A (\"r%d,0xff,-,0xff,&,r%d,=,\", r, r);\t\t// Rd = 0xFF-Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,cf,=,\");\t\t\t\t\t// C\n\t__generic_bitop_flags (op);\t\t\t\t// ...rest...\n}\n\nINST_HANDLER (cp) {\t// CP Rd, Rr\n\tint r = (buf[0]        & 0x0f) | ((buf[1] << 3) & 0x10);\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\tESIL_A (\"r%d,r%d,-,\", r, d);\t\t\t// do Rd - Rr\n\t__generic_sub_update_flags_rr (op, d, r, 0);\t// FLAGS (no carry)\n}\n\nINST_HANDLER (cpc) {\t// CPC Rd, Rr\n\tint r = (buf[0]        & 0x0f) | ((buf[1] << 3) & 0x10);\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\n\tESIL_A (\"cf,r%d,+,r%d,-,\", r, d);\t\t// Rd - Rr - C\n\t__generic_sub_update_flags_rr (op, d, r, 1);\t// FLAGS (carry)\n}\n\nINST_HANDLER (cpi) { // CPI Rd, K\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0xf) | ((buf[1] & 0xf) << 4);\n\tESIL_A (\"%d,r%d,-,\", k, d);\t\t\t// Rd - k\n\t__generic_sub_update_flags_rk (op, d, k, 0);\t// FLAGS (carry)\n}\n\nINST_HANDLER (cpse) {\t// CPSE Rd, Rr\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op = {0};\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t// Rr == Rd\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (dec) {\t// DEC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"-1,r%d,+,\", d);\t\t\t\t// --Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,RPICK,0x7f,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (des) {\t// DES k\n\tif (desctx.round < 16) {\t//DES\n\t\top->type = R_ANAL_OP_TYPE_CRYPTO;\n\t\top->cycles = 1;\t\t//redo this\n\t\tr_strbuf_setf (&op->esil, \"%d,des\", desctx.round);\n\t}\n}\n\nINST_HANDLER (eijmp) {\t// EIJMP\n\tut64 z, eind;\n\t// read z and eind for calculating jump address on runtime\n\tr_anal_esil_reg_read (anal->esil, \"z\",    &z,    NULL);\n\tr_anal_esil_reg_read (anal->esil, \"eind\", &eind, NULL);\n\t// real target address may change during execution, so this value will\n\t// be changing all the time\n\top->jump = ((eind << 16) + z) << 1;\n\t// jump\n\tESIL_A (\"1,z,16,eind,<<,+,<<,pc,=,\");\n\t// cycles\n\top->cycles = 2;\n}\n\nINST_HANDLER (eicall) {\t// EICALL\n\t// push pc in stack\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\t// do a standard EIJMP\n\tINST_CALL (eijmp);\n\t// fix cycles\n\top->cycles = !STR_BEGINS (cpu->model, \"ATxmega\") ? 3 : 4;\n}\n\nINST_HANDLER (elpm) {\t// ELPM\n\t\t\t// ELPM Rd\n\t\t\t// ELPM Rd, Z+\n\tint d = ((buf[1] & 0xfe) == 0x90)\n\t\t\t? ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf)\t// Rd\n\t\t\t: 0;\t\t\t\t\t\t// R0\n\tESIL_A (\"16,rampz,<<,z,+,_prog,+,[1],\");\t// read RAMPZ:Z\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = [1]\n\tif ((buf[1] & 0xfe) == 0x90 && (buf[0] & 0xf) == 0x7) {\n\t\tESIL_A (\"16,1,z,+,DUP,z,=,>>,1,&,rampz,+=,\");\t// ++(rampz:z)\n\t}\n}\n\nINST_HANDLER (eor) {\t// EOR Rd, Rr\n\t\t\t// CLR Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,^,\", r, d);\t\t\t// 0: Rd ^ Rr\n\t__generic_bitop_flags (op);\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (fmul) {\t// FMUL Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,r%d,r%d,*,<<,\", r, d);\t\t// 0: (Rd*Rr)<<1\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (fmuls) {\t// FMULS Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,\");\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"*,<<,\", r, d);\t\t\t\t// 0: (Rd*Rr)<<1\n\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (fmulsu) {\t// FMULSU Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,\");\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"r%d\", r);\t\t\t\t// unsigned Rr\n\tESIL_A (\"*,<<,\");\t\t\t\t// 0: (Rd*Rr)<<1\n\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (ijmp) {\t// IJMP k\n\tut64 z;\n\t// read z for calculating jump address on runtime\n\tr_anal_esil_reg_read (anal->esil, \"z\", &z, NULL);\n\t// real target address may change during execution, so this value will\n\t// be changing all the time\n\top->jump = z << 1;\n\top->cycles = 2;\n\tESIL_A (\"1,z,<<,pc,=,\");\t\t// jump!\n}\n\nINST_HANDLER (icall) {\t// ICALL k\n\t// push pc in stack\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\t// do a standard IJMP\n\tINST_CALL (ijmp);\n\t// fix cycles\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (in) {\t// IN Rd, A\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 0x01) << 4);\n\tint a = (buf[0] & 0x0f) | ((buf[1] & 0x6) << 3);\n\tRStrBuf *io_src = __generic_io_dest (a, 0, cpu);\n\top->type2 = 0;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\tESIL_A (\"%s,r%d,=,\", r_strbuf_get (io_src), r);\n\tr_strbuf_free (io_src);\n}\n\nINST_HANDLER (inc) {\t// INC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"1,r%d,+,\", d);\t\t\t\t\t// ++Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,RPICK,0x80,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (jmp) {\t// JMP k\n\top->jump = (buf[2] << 1)\n\t\t | (buf[3] << 9)\n\t\t | (buf[1] & 0x01) << 23\n\t\t | (buf[0] & 0x01) << 17\n\t\t | (buf[0] & 0xf0) << 14;\n\top->cycles = 3;\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n}\n\nINST_HANDLER (lac) {\t// LAC Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,0xff,^,&,\", d);\t\t\t// 0: (Z) & ~Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (las) {\t// LAS Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,|,\", d);\t\t\t\t// 0: (Z) | Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (lat) {\t// LAT Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,^,\", d);\t\t\t\t// 0: (Z) ^ Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (ld) {\t// LD Rd, X\n\t\t\t// LD Rd, X+\n\t\t\t// LD Rd, -X\n\t// read memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\t'x',\t\t\t\t// use index register X\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t(buf[0] & 0xf) == 0xe\n\t\t\t? -1\t\t\t// pre decremented\n\t\t\t: (buf[0] & 0xf) == 0xd\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: 0,\t\t// no increment\n\t\t0,\t\t\t\t// offset always 0\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// cycles\n\top->cycles = (buf[0] & 0x3) == 0\n\t\t\t? 2\t\t\t// LD Rd, X\n\t\t\t: (buf[0] & 0x3) == 1\n\t\t\t\t? 2\t\t// LD Rd, X+\n\t\t\t\t: 3;\t\t// LD Rd, -X\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (ldd) {\t// LD Rd, Y\tLD Rd, Z\n\t\t\t// LD Rd, Y+\tLD Rd, Z+\n\t\t\t// LD Rd, -Y\tLD Rd, -Z\n\t\t\t// LD Rd, Y+q\tLD Rd, Z+q\n\t// calculate offset (this value only has sense in some opcodes,\n\t// but we are optimistic and we calculate it always)\n\tint offset = (buf[1] & 0x20)\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7);\n\t// read memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10) ? offset : 0,\t// offset or not offset\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// cycles\n\top->cycles =\n\t\t(buf[1] & 0x10) == 0\n\t\t\t? (!offset ? 1 : 3)\t\t// LDD\n\t\t\t: (buf[0] & 0x3) == 0\n\t\t\t\t? 1\t\t\t// LD Rd, X\n\t\t\t\t: (buf[0] & 0x3) == 1\n\t\t\t\t\t? 2\t\t// LD Rd, X+\n\t\t\t\t\t: 3;\t\t// LD Rd, -X\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (ldi) {\t// LDI Rd, K\n\tint k = (buf[0] & 0xf) + ((buf[1] & 0xf) << 4);\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\top->val = k;\n\tESIL_A (\"0x%x,r%d,=,\", k, d);\n}\n\nINST_HANDLER (lds) {\t// LDS Rd, k\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t// load value from RAMPD:k\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n\nINST_HANDLER (sts) {\t// STS k, Rr\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\n\top->cycles = 2;\n}\n\n#if 0\nINST_HANDLER (lds16) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0x0f)\n\t\t| ((buf[1] << 3) & 0x30)\n\t\t| ((buf[1] << 4) & 0x40)\n\t\t| (~(buf[1] << 4) & 0x80);\n\top->ptr = k;\n\n\t// load value from @k\n\t__generic_ld_st (op, \"ram\", 0, 0, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n#endif\n\nINST_HANDLER (lpm) {\t// LPM\n\t\t\t// LPM Rd, Z\n\t\t\t// LPM Rd, Z+\n\tut16 ins = (((ut16) buf[1]) << 8) | ((ut16) buf[0]);\n\t// read program memory\n\t__generic_ld_st (\n\t\top, \"prog\",\n\t\t'z',\t\t\t\t// index register Y/Z\n\t\t1,\t\t\t\t// use RAMP* registers\n\t\t(ins & 0xfe0f) == 0x9005\n\t\t\t? 1\t\t\t// post incremented\n\t\t\t: 0,\t\t\t// no increment\n\t\t0,\t\t\t\t// not offset\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\",\n\t\t(ins == 0x95c8)\n\t\t\t? 0\t\t\t// LPM (r0)\n\t\t\t: ((buf[0] >> 4) & 0xf)\t// LPM Rd\n\t\t\t\t| ((buf[1] & 0x1) << 4));\n}\n\nINST_HANDLER (lsr) {\t// LSR Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"1,r%d,>>,\", d);\t\t\t\t// 0: R=(Rd >> 1)\n\tESIL_A (\"r%d,0x1,&,!,!,cf,=,\", d);\t\t\t// C = Rd0\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,nf,=,\");\t\t\t\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t\t// V\n\tESIL_A (\"nf,vf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = R\n}\n\nINST_HANDLER (mov) {\t// MOV Rd, Rr\n\tint d = ((buf[1] << 4) & 0x10) | ((buf[0] >> 4) & 0x0f);\n\tint r = ((buf[1] << 3) & 0x10) | (buf[0] & 0x0f);\n\tESIL_A (\"r%d,r%d,=,\", r, d);\n}\n\nINST_HANDLER (movw) {\t// MOVW Rd+1:Rd, Rr+1:Rr\n\tint d = (buf[0] & 0xf0) >> 3;\n\tint r = (buf[0] & 0x0f) << 1;\n\tESIL_A (\"r%d,r%d,=,r%d,r%d,=,\", r, d, r + 1, d + 1);\n}\n\nINST_HANDLER (mul) {\t// MUL Rd, Rr\n\tint d = ((buf[1] << 4) & 0x10) | ((buf[0] >> 4) & 0x0f);\n\tint r = ((buf[1] << 3) & 0x10) | (buf[0] & 0x0f);\n\n\tESIL_A (\"r%d,r%d,*,\", r, d);\t\t\t// 0: (Rd*Rr)<<1\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (muls) {\t// MULS Rd, Rr\n\tint d = (buf[0] >> 4 & 0x0f) + 16;\n\tint r = (buf[0] & 0x0f) + 16;\n\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (mulsu) {\t// MULSU Rd, Rr\n\tint d = (buf[0] >> 4 & 0x07) + 16;\n\tint r = (buf[0] & 0x07) + 16;\n\n\tESIL_A (\"r%d,\", r);\t\t\t\t// unsigned Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (neg) {\t// NEG Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"r%d,0x00,-,0xff,&,\", d);\t\t\t// 0: (0-Rd)\n\tESIL_A (\"DUP,r%d,0xff,^,|,0x08,&,!,!,hf,=,\", d);\t// H\n\tESIL_A (\"DUP,0x80,-,!,vf,=,\", d);\t\t\t// V\n\tESIL_A (\"DUP,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t\t// Z\n\tESIL_A (\"DUP,!,!,cf,=,\");\t\t\t\t// C\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (nop) {\t// NOP\n\tESIL_A (\",,\");\n}\n\nINST_HANDLER (or) {\t// OR Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,|,\", r, d);\t\t\t\t// 0: (Rd | Rr)\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"nf,sf,=,\");\t\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (ori) {\t// ORI Rd, K\n\t\t\t// SBR Rd, K\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0xf) | ((buf[1] & 0xf) << 4);\n\top->val = k;\n\tESIL_A (\"r%d,%d,|,\", d, k);\t\t\t\t// 0: (Rd | k)\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"nf,sf,=,\");\t\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (out) {\t// OUT A, Rr\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 0x01) << 4);\n\tint a = (buf[0] & 0x0f) | ((buf[1] & 0x6) << 3);\n\tRStrBuf *io_dst = __generic_io_dest (a, 1, cpu);\n\top->type2 = 1;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\tESIL_A (\"r%d,%s,\", r, r_strbuf_get (io_dst));\n\tr_strbuf_free (io_dst);\n}\n\nINST_HANDLER (pop) {\t// POP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\t__generic_pop (op, 1);\n\tESIL_A (\"r%d,=,\", d);\t// store in Rd\n\n}\n\nINST_HANDLER (push) {\t// PUSH Rr\n\tint r = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\tESIL_A (\"r%d,\", r);\t// load Rr\n\t__generic_push (op, 1);\t// push it into stack\n\t// cycles\n\top->cycles = !STR_BEGINS (cpu->model, \"ATxmega\")\n\t\t\t? 1\t// AT*mega optimizes one cycle\n\t\t\t: 2;\n}\n\nINST_HANDLER (rcall) {\t// RCALL k\n\t// target address\n\top->jump = (op->addr\n\t\t+ (((((buf[1] & 0xf) << 8) | buf[0]) << 1)\n\t\t\t| (((buf[1] & 0x8) ? ~((int) 0x1fff) : 0)))\n\t\t+ 2) & CPU_PC_MASK (cpu);\n\top->fail = op->addr + op->size;\n\t// esil\n\tESIL_A (\"pc,\");\t\t\t\t// esil already points to next\n\t\t\t\t\t\t// instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret addr\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n\t// cycles\n\tif (!strncasecmp (cpu->model, \"ATtiny\", 6)) {\n\t\top->cycles = 4;\t// ATtiny is always slow\n\t} else {\n\t\t// PC size decides required runtime!\n\t\top->cycles = cpu->pc <= 16 ? 3 : 4;\n\t\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\t\top->cycles--;\t// ATxmega optimizes one cycle\n\t\t}\n\t}\n}\n\nINST_HANDLER (ret) {\t// RET\n\top->eob = true;\n\t// esil\n\t__generic_pop (op, CPU_PC_SIZE (cpu));\n\tESIL_A (\"pc,=,\");\t// jump!\n\t// cycles\n\tif (CPU_PC_SIZE (cpu) > 2) {\t// if we have a bus bigger than 16 bit\n\t\top->cycles++;\t// (i.e. a 22-bit bus), add one extra cycle\n\t}\n}\n\nINST_HANDLER (reti) {\t// RETI\n\t//XXX: There are not privileged instructions in ATMEL/AVR\n\top->family = R_ANAL_OP_FAMILY_PRIV;\n\n\t// first perform a standard 'ret'\n\tINST_CALL (ret);\n\n\t// RETI: The I-bit is cleared by hardware after an interrupt\n\t// has occurred, and is set by the RETI instruction to enable\n\t// subsequent interrupts\n\tESIL_A (\"1,if,=,\");\n}\n\nINST_HANDLER (rjmp) {\t// RJMP k\n\top->jump = (op->addr\n#ifdef _MSC_VER\n#pragma message (\"anal_avr.c: WARNING: Probably broken on windows\")\n\t\t+ ((((( buf[1] & 0xf) << 9) | (buf[0] << 1)))\n\t\t\t| (buf[1] & 0x8 ? ~(0x1fff) : 0))\n#else\n\t\t+ ((((( (typeof (op->jump)) buf[1] & 0xf) << 9) | ((typeof (op->jump)) buf[0] << 1)))\n\t\t\t| (buf[1] & 0x8 ? ~((typeof (op->jump)) 0x1fff) : 0))\n#endif\n\t\t+ 2) & CPU_PC_MASK (cpu);\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\n}\n\nINST_HANDLER (ror) {\t// ROR Rd\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\tESIL_A (\"1,r%d,>>,7,cf,<<,|,\", d);\t\t// 0: (Rd>>1) | (cf<<7)\n\tESIL_A (\"r%d,1,&,cf,=,\", d);\t\t\t// C\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t// V\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (sbc) {\t// SBC Rd, Rr\n\tint r = (buf[0] & 0x0f) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\tESIL_A (\"cf,r%d,+,r%d,-,\", r, d);\t\t// 0: (Rd-Rr-C)\n\t__generic_sub_update_flags_rr (op, d, r, 1);\t// FLAGS (carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sbci) {\t// SBCI Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0xf) << 4) | (buf[0] & 0xf);\n\top->val = k;\n\n\tESIL_A (\"cf,%d,+,r%d,-,\", k, d);\t\t// 0: (Rd-k-C)\n\t__generic_sub_update_flags_rk (op, d, k, 1);\t// FLAGS (carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sub) {\t// SUB Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\n\tESIL_A (\"r%d,r%d,-,\", r, d);\t\t\t// 0: (Rd-k)\n\t__generic_sub_update_flags_rr (op, d, r, 0);\t// FLAGS (no carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (subi) {\t// SUBI Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0xf) << 4) | (buf[0] & 0xf);\n\top->val = k;\n\n\tESIL_A (\"%d,r%d,-,\", k, d);\t\t\t// 0: (Rd-k)\n\t__generic_sub_update_flags_rk (op, d, k, 1);\t// FLAGS (no carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sbi) {\t// SBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->type2 = 1;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,|,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (sbix) {\t// SBIC A, b\n\t\t\t// SBIS A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRAnalOp next_op;\n\tRStrBuf *io_port;\n\n\top->type2 = 0;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size,\n\t\t\tlen - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to false, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"%d,1,<<,%s,&,\", b, io_port);\t\t// IO(A,b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\t\t// SBIC => branch if 0\n\t\t\t: \"!,!,\");\t\t\t// SBIS => branch if 1\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (sbiw) {\t// SBIW Rd+1:Rd, K\n\tint d = ((buf[0] & 0x30) >> 3) + 24;\n\tint k = (buf[0] & 0xf) | ((buf[0] >> 2) & 0x30);\n\top->val = k;\n\tESIL_A (\"%d,r%d:r%d,-,\", k, d + 1, d);\t\t// 0(Rd+1:Rd - Rr)\n\tESIL_A (\"r%d,0x80,&,!,!,\"\t\t\t// V\n\t\t\"0,RPICK,0x8000,&,!,\"\n\t\t\"&,vf,=,\", d + 1);\n\tESIL_A (\"0,RPICK,0x8000,&,!,!,nf,=,\");\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"r%d,0x80,&,!,\"\t\t\t\t// C\n\t\t\"0,RPICK,0x8000,&,!,!,\"\n\t\t\"&,cf,=,\", d + 1);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t// S\n\tESIL_A (\"r%d:r%d,=,\", d + 1, d);\t\t// Rd = result\n}\n\nINST_HANDLER (sbrx) {\t// SBRC Rr, b\n\t\t\t// SBRS Rr, b\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op = {0};\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to false, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t// Rr(b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t// SBRC => branch if cleared\n\t\t\t: \"!,!,\");\t// SBRS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (sleep) {\t// SLEEP\n\tESIL_A (\"BREAK\");\n}\n\nINST_HANDLER (spm) {\t// SPM Z+\n\tut64 spmcsr;\n\n\t// read SPM Control Register (SPMCR)\n\tr_anal_esil_reg_read (anal->esil, \"spmcsr\", &spmcsr, NULL);\n\n\t// clear SPMCSR\n\tESIL_A (\"0x7c,spmcsr,&=,\");\n\n\t// decide action depending on the old value of SPMCSR\n\tswitch (spmcsr & 0x7f) {\n\t\tcase 0x03: // PAGE ERASE\n\t\t\t// invoke SPM_CLEAR_PAGE (erases target page writing\n\t\t\t// the 0xff value\n\t\t\tESIL_A (\"16,rampz,<<,z,+,\"); // push target address\n\t\t\tESIL_A (\"SPM_PAGE_ERASE,\");  // do magic\n\t\t\tbreak;\n\n\t\tcase 0x01: // FILL TEMPORARY BUFFER\n\t\t\tESIL_A (\"r1,r0,\");           // push data\n\t\t\tESIL_A (\"z,\");               // push target address\n\t\t\tESIL_A (\"SPM_PAGE_FILL,\");   // do magic\n\t\t\tbreak;\n\n\t\tcase 0x05: // WRITE PAGE\n\t\t\tESIL_A (\"16,rampz,<<,z,+,\"); // push target address\n\t\t\tESIL_A (\"SPM_PAGE_WRITE,\");  // do magic\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\teprintf (\"SPM: I dont know what to do with SPMCSR %02x.\\n\",\n\t\t\t\t\t(unsigned int) spmcsr);\n\t}\n\n\top->cycles = 1;\t// This is truly false. Datasheets do not publish how\n\t\t\t// many cycles this instruction uses in all its\n\t\t\t// operation modes and I am pretty sure that this value\n\t\t\t// can vary substantially from one MCU type to another.\n\t\t\t// So... one cycle is fine.\n}\n\nINST_HANDLER (st) {\t// ST X, Rr\n\t\t\t// ST X+, Rr\n\t\t\t// ST -X, Rr\n\t// load register\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// write in memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\t'x',\t\t\t\t// use index register X\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t(buf[0] & 0xf) == 0xe\n\t\t\t? -1\t\t\t// pre decremented\n\t\t\t: (buf[0] & 0xf) == 0xd\n\t\t\t\t? 1\t\t// post increment\n\t\t\t\t: 0,\t\t// no increment\n\t\t0,\t\t\t\t// offset always 0\n\t\t1);\t\t\t\t// store operation (st)\n//\t// cycles\n//\top->cycles = buf[0] & 0x3 == 0\n//\t\t\t? 2\t\t\t// LD Rd, X\n//\t\t\t: buf[0] & 0x3 == 1\n//\t\t\t\t? 2\t\t// LD Rd, X+\n//\t\t\t\t: 3;\t\t// LD Rd, -X\n//\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n//\t\t// AT*mega optimizes 1 cycle!\n//\t\top->cycles--;\n//\t}\n}\n\nINST_HANDLER (std) {\t// ST Y, Rr\tST Z, Rr\n\t\t\t// ST Y+, Rr\tST Z+, Rr\n\t\t\t// ST -Y, Rr\tST -Z, Rr\n\t\t\t// ST Y+q, Rr\tST Z+q, Rr\n\t// load register\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// write in memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10)\n\t\t\t? (buf[1] & 0x20)\t// offset\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7)\n\t\t\t: 0,\t\t\t// no offset\n\t\t1);\t\t\t\t// load operation (!st)\n//\t// cycles\n//\top->cycles =\n//\t\tbuf[1] & 0x1 == 0\n//\t\t\t? !(offset ? 1 : 3)\t\t// LDD\n//\t\t\t: buf[0] & 0x3 == 0\n//\t\t\t\t? 1\t\t\t// LD Rd, X\n//\t\t\t\t: buf[0] & 0x3 == 1\n//\t\t\t\t\t? 2\t\t// LD Rd, X+\n//\t\t\t\t\t: 3;\t\t// LD Rd, -X\n//\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n//\t\t// AT*mega optimizes 1 cycle!\n//\t\top->cycles--;\n//\t}\n}\n\nINST_HANDLER (swap) {\t// SWAP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\tESIL_A (\"4,r%d,>>,0x0f,&,\", d);\t\t// (Rd >> 4) & 0xf\n\tESIL_A (\"4,r%d,<<,0xf0,&,\", d);\t\t// (Rd >> 4) & 0xf\n\tESIL_A (\"|,\", d);\t\t\t// S[0] | S[1]\n\tESIL_A (\"r%d,=,\", d);\t\t\t// Rd = result\n}\n\nOPCODE_DESC opcodes[] = {\n\t//         op      mask    select  cycles  size type\n\tINST_DECL (break,  0xffff, 0x9698, 1,      2,   TRAP   ), // BREAK\n\tINST_DECL (eicall, 0xffff, 0x9519, 0,      2,   UCALL  ), // EICALL\n\tINST_DECL (eijmp,  0xffff, 0x9419, 0,      2,   UJMP   ), // EIJMP\n\tINST_DECL (icall,  0xffff, 0x9509, 0,      2,   UCALL  ), // ICALL\n\tINST_DECL (ijmp,   0xffff, 0x9409, 0,      2,   UJMP   ), // IJMP\n\tINST_DECL (lpm,    0xffff, 0x95c8, 3,      2,   LOAD   ), // LPM\n\tINST_DECL (nop,    0xffff, 0x0000, 1,      2,   NOP    ), // NOP\n\tINST_DECL (ret,    0xffff, 0x9508, 4,      2,   RET    ), // RET\n\tINST_DECL (reti,   0xffff, 0x9518, 4,      2,   RET    ), // RETI\n\tINST_DECL (sleep,  0xffff, 0x9588, 1,      2,   NOP    ), // SLEEP\n\tINST_DECL (spm,    0xffff, 0x95e8, 1,      2,   TRAP   ), // SPM ...\n\tINST_DECL (bclr,   0xff8f, 0x9488, 1,      2,   SWI    ), // BCLR s\n\tINST_DECL (bset,   0xff8f, 0x9408, 1,      2,   SWI    ), // BSET s\n\tINST_DECL (fmul,   0xff88, 0x0308, 2,      2,   MUL    ), // FMUL Rd, Rr\n\tINST_DECL (fmuls,  0xff88, 0x0380, 2,      2,   MUL    ), // FMULS Rd, Rr\n\tINST_DECL (fmulsu, 0xff88, 0x0388, 2,      2,   MUL    ), // FMULSU Rd, Rr\n\tINST_DECL (mulsu,  0xff88, 0x0300, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (des,    0xff0f, 0x940b, 0,      2,   CRYPTO ), // DES k\n\tINST_DECL (adiw,   0xff00, 0x9600, 2,      2,   ADD    ), // ADIW Rd+1:Rd, K\n\tINST_DECL (sbiw,   0xff00, 0x9700, 2,      2,   SUB    ), // SBIW Rd+1:Rd, K\n\tINST_DECL (cbi,    0xff00, 0x9800, 1,      2,   IO     ), // CBI A, K\n\tINST_DECL (sbi,    0xff00, 0x9a00, 1,      2,   IO     ), // SBI A, K\n\tINST_DECL (movw,   0xff00, 0x0100, 1,      2,   MOV    ), // MOVW Rd+1:Rd, Rr+1:Rr\n\tINST_DECL (muls,   0xff00, 0x0200, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (asr,    0xfe0f, 0x9405, 1,      2,   SAR    ), // ASR Rd\n\tINST_DECL (com,    0xfe0f, 0x9400, 1,      2,   SWI    ), // BLD Rd, b\n\tINST_DECL (dec,    0xfe0f, 0x940a, 1,      2,   SUB    ), // DEC Rd\n\tINST_DECL (elpm,   0xfe0f, 0x9006, 0,      2,   LOAD   ), // ELPM Rd, Z\n\tINST_DECL (elpm,   0xfe0f, 0x9007, 0,      2,   LOAD   ), // ELPM Rd, Z+\n\tINST_DECL (inc,    0xfe0f, 0x9403, 1,      2,   ADD    ), // INC Rd\n\tINST_DECL (lac,    0xfe0f, 0x9206, 2,      2,   LOAD   ), // LAC Z, Rd\n\tINST_DECL (las,    0xfe0f, 0x9205, 2,      2,   LOAD   ), // LAS Z, Rd\n\tINST_DECL (lat,    0xfe0f, 0x9207, 2,      2,   LOAD   ), // LAT Z, Rd\n\tINST_DECL (ld,     0xfe0f, 0x900c, 0,      2,   LOAD   ), // LD Rd, X\n\tINST_DECL (ld,     0xfe0f, 0x900d, 0,      2,   LOAD   ), // LD Rd, X+\n\tINST_DECL (ld,     0xfe0f, 0x900e, 0,      2,   LOAD   ), // LD Rd, -X\n\tINST_DECL (lds,    0xfe0f, 0x9000, 0,      4,   LOAD   ), // LDS Rd, k\n\tINST_DECL (sts,    0xfe0f, 0x9200, 2,      4,   STORE  ), // STS k, Rr\n\tINST_DECL (lpm,    0xfe0f, 0x9004, 3,      2,   LOAD   ), // LPM Rd, Z\n\tINST_DECL (lpm,    0xfe0f, 0x9005, 3,      2,   LOAD   ), // LPM Rd, Z+\n\tINST_DECL (lsr,    0xfe0f, 0x9406, 1,      2,   SHR    ), // LSR Rd\n\tINST_DECL (neg,    0xfe0f, 0x9401, 2,      2,   SUB    ), // NEG Rd\n\tINST_DECL (pop,    0xfe0f, 0x900f, 2,      2,   POP    ), // POP Rd\n\tINST_DECL (push,   0xfe0f, 0x920f, 0,      2,   PUSH   ), // PUSH Rr\n\tINST_DECL (ror,    0xfe0f, 0x9407, 1,      2,   SAR    ), // ROR Rd\n\tINST_DECL (st,     0xfe0f, 0x920c, 2,      2,   STORE  ), // ST X, Rr\n\tINST_DECL (st,     0xfe0f, 0x920d, 0,      2,   STORE  ), // ST X+, Rr\n\tINST_DECL (st,     0xfe0f, 0x920e, 0,      2,   STORE  ), // ST -X, Rr\n\tINST_DECL (swap,   0xfe0f, 0x9402, 1,      2,   SAR    ), // SWAP Rd\n\tINST_DECL (call,   0xfe0e, 0x940e, 0,      4,   CALL   ), // CALL k\n\tINST_DECL (jmp,    0xfe0e, 0x940c, 2,      4,   JMP    ), // JMP k\n\tINST_DECL (bld,    0xfe08, 0xf800, 1,      2,   SWI    ), // BLD Rd, b\n\tINST_DECL (bst,    0xfe08, 0xfa00, 1,      2,   SWI    ), // BST Rd, b\n\tINST_DECL (sbix,   0xfe08, 0x9900, 2,      2,   CJMP   ), // SBIC A, b\n\tINST_DECL (sbix,   0xfe08, 0x9900, 2,      2,   CJMP   ), // SBIS A, b\n\tINST_DECL (sbrx,   0xfe08, 0xfc00, 2,      2,   CJMP   ), // SBRC Rr, b\n\tINST_DECL (sbrx,   0xfe08, 0xfe00, 2,      2,   CJMP   ), // SBRS Rr, b\n\tINST_DECL (ldd,    0xfe07, 0x9001, 0,      2,   LOAD   ), // LD Rd, Y/Z+\n\tINST_DECL (ldd,    0xfe07, 0x9002, 0,      2,   LOAD   ), // LD Rd, -Y/Z\n\tINST_DECL (std,    0xfe07, 0x9201, 0,      2,   STORE  ), // ST Y/Z+, Rr\n\tINST_DECL (std,    0xfe07, 0x9202, 0,      2,   STORE  ), // ST -Y/Z, Rr\n\tINST_DECL (adc,    0xfc00, 0x1c00, 1,      2,   ADD    ), // ADC Rd, Rr\n\tINST_DECL (add,    0xfc00, 0x0c00, 1,      2,   ADD    ), // ADD Rd, Rr\n\tINST_DECL (and,    0xfc00, 0x2000, 1,      2,   AND    ), // AND Rd, Rr\n\tINST_DECL (brbx,   0xfc00, 0xf000, 0,      2,   CJMP   ), // BRBS s, k\n\tINST_DECL (brbx,   0xfc00, 0xf400, 0,      2,   CJMP   ), // BRBC s, k\n\tINST_DECL (cp,     0xfc00, 0x1400, 1,      2,   CMP    ), // CP Rd, Rr\n\tINST_DECL (cpc,    0xfc00, 0x0400, 1,      2,   CMP    ), // CPC Rd, Rr\n\tINST_DECL (cpse,   0xfc00, 0x1000, 0,      2,   CJMP   ), // CPSE Rd, Rr\n\tINST_DECL (eor,    0xfc00, 0x2400, 1,      2,   XOR    ), // EOR Rd, Rr\n\tINST_DECL (mov,    0xfc00, 0x2c00, 1,      2,   MOV    ), // MOV Rd, Rr\n\tINST_DECL (mul,    0xfc00, 0x9c00, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (or,     0xfc00, 0x2800, 1,      2,   OR     ), // OR Rd, Rr\n\tINST_DECL (sbc,    0xfc00, 0x0800, 1,      2,   SUB    ), // SBC Rd, Rr\n\tINST_DECL (sub,    0xfc00, 0x1800, 1,      2,   SUB    ), // SUB Rd, Rr\n\tINST_DECL (in,     0xf800, 0xb000, 1,      2,   IO     ), // IN Rd, A\n\t//INST_DECL (lds16,  0xf800, 0xa000, 1,      2,   LOAD   ), // LDS Rd, k\n\tINST_DECL (out,    0xf800, 0xb800, 1,      2,   IO     ), // OUT A, Rr\n\tINST_DECL (andi,   0xf000, 0x7000, 1,      2,   AND    ), // ANDI Rd, K\n\tINST_DECL (cpi,    0xf000, 0x3000, 1,      2,   CMP    ), // CPI Rd, K\n\tINST_DECL (ldi,    0xf000, 0xe000, 1,      2,   LOAD   ), // LDI Rd, K\n\tINST_DECL (ori,    0xf000, 0x6000, 1,      2,   OR     ), // ORI Rd, K\n\tINST_DECL (rcall,  0xf000, 0xd000, 0,      2,   CALL   ), // RCALL k\n\tINST_DECL (rjmp,   0xf000, 0xc000, 2,      2,   JMP    ), // RJMP k\n\tINST_DECL (sbci,   0xf000, 0x4000, 1,      2,   SUB    ), // SBC Rd, Rr\n\tINST_DECL (subi,   0xf000, 0x5000, 1,      2,   SUB    ), // SUBI Rd, Rr\n\tINST_DECL (ldd,    0xd200, 0x8000, 0,      2,   LOAD   ), // LD Rd, Y/Z+q\n\tINST_DECL (std,    0xd200, 0x8200, 0,      2,   STORE  ), // ST Y/Z+q, Rr\n\n\tINST_LAST\n};\n\nstatic OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tif (len < 2) {\n\t\treturn NULL;\n\t}\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\n\t// initialize op struct\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\n\t// process opcode\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\n\t\t\t// copy default cycles/size values\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\t// op->fail = addr + op->size;\n\t\t\top->addr = addr;\n\n\t\t\t// start void esil expression\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\n\t\t\t// handle opcode\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\t// eprintf (\"opcode %s @%\"PFMT64x\" returned 0 cycles.\\n\", opcode_desc->name, op->addr);\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\n\t\t\t// remove trailing coma (COMETE LA COMA)\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\n\t// ignore reserved opcodes (if they have not been caught by the previous loop)\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\n\nINVALID_OP:\n\t// An unknown or invalid option has appeared.\n\t//  -- Throw pokeball!\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\t// launch esil trap (for communicating upper layers about this weird\n\t// and stinky situation\n\tr_strbuf_set (&op->esil, \"1,$\");\n\n\treturn NULL;\n}\n\nstatic int avr_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len) {\n\tCPU_MODEL *cpu;\n\tut64 offset;\n\n\t// init op\n\tif (!op) {\n\t\treturn 2;\n\t}\n\n\t// select cpu info\n\tcpu = get_cpu_model (anal->cpu);\n\n\t// set memory layout registers\n\tif (anal->esil) {\n\t\toffset = 0;\n\t\tr_anal_esil_reg_write (anal->esil, \"_prog\", offset);\n\n\t\toffset += (1 << cpu->pc);\n\t\tr_anal_esil_reg_write (anal->esil, \"_io\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"sram_start\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_sram\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"sram_size\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_eeprom\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"eeprom_size\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_page\", offset);\n\t}\n\t// process opcode\n\tavr_op_analyze (anal, op, addr, buf, len, cpu);\n\n\treturn op->size;\n}\n\nstatic int avr_custom_des (RAnalEsil *esil) {\n\tut64 key, encrypt, text,des_round;\n\tut32 key_lo, key_hi, buf_lo, buf_hi;\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\tif (!__esil_pop_argument (esil, &des_round)) {\n\t\treturn false;\n\t}\n\tr_anal_esil_reg_read (esil, \"hf\", &encrypt, NULL);\n\tr_anal_esil_reg_read (esil, \"deskey\", &key, NULL);\n\tr_anal_esil_reg_read (esil, \"text\", &text, NULL);\n\n\tkey_lo = key & UT32_MAX;\n\tkey_hi = key >> 32;\n\tbuf_lo = text & UT32_MAX;\n\tbuf_hi = text >> 32;\n\n\tif (des_round != desctx.round) {\n\t\tdesctx.round = des_round;\n\t}\n\n\tif (!desctx.round) {\n\t\tint i;\n\t\t//generating all round keys\n\t\tr_des_permute_key (&key_lo, &key_hi);\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tr_des_round_key (i, &desctx.round_key_lo[i], &desctx.round_key_hi[i], &key_lo, &key_hi);\n\t\t}\n\t\tr_des_permute_block0 (&buf_lo, &buf_hi);\n\t}\n\n\tif (encrypt) {\n\t\tr_des_round (&buf_lo, &buf_hi, &desctx.round_key_lo[desctx.round], &desctx.round_key_hi[desctx.round]);\n\t} else {\n\t\tr_des_round (&buf_lo, &buf_hi, &desctx.round_key_lo[15 - desctx.round], &desctx.round_key_hi[15 - desctx.round]);\n\t}\n\n\tif (desctx.round == 15) {\n\t\tr_des_permute_block1 (&buf_hi, &buf_lo);\n\t\tdesctx.round = 0;\n\t} else {\n\t\tdesctx.round++;\n\t}\n\n\tr_anal_esil_reg_write (esil, \"text\", text);\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_ERASE\nstatic int avr_custom_spm_page_erase(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tut8 c;\n\tut64 addr, page_size_bits, i;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address\n\tif (!__esil_pop_argument(esil, &addr)) {\n\t\treturn false;\n\t}\n\n\t// get details about current MCU and fix input address\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\n\t// align base address to page_size_bits\n\taddr &= ~(MASK (page_size_bits));\n\n\t// perform erase\n\t//eprintf (\"SPM_PAGE_ERASE %ld bytes @ 0x%08\" PFMT64x \".\\n\", page_size, addr);\n\tc = 0xff;\n\tfor (i = 0; i < (1ULL << page_size_bits); i++) {\n\t\tr_anal_esil_mem_write (\n\t\t\tesil, (addr + i) & CPU_PC_MASK (cpu), &c, 1);\n\t}\n\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_FILL\nstatic int avr_custom_spm_page_fill(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tut64 addr, page_size_bits, i;\n\tut8 r0, r1;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address, r0, r1\n\tif (!__esil_pop_argument(esil, &addr)) {\n\t\treturn false;\n\t}\n\n\tif (!__esil_pop_argument (esil, &i)) {\n\t\treturn false;\n\t}\n\tr0 = i;\n\n\tif (!__esil_pop_argument (esil, &i)) {\n\t\treturn false;\n\t}\n\tr1 = i;\n\n\t// get details about current MCU and fix input address\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\n\t// align and crop base address\n\taddr &= (MASK (page_size_bits) ^ 1);\n\n\t// perform write to temporary page\n\t//eprintf (\"SPM_PAGE_FILL bytes (%02x, %02x) @ 0x%08\" PFMT64x \".\\n\", r1, r0, addr);\n\tr_anal_esil_mem_write (esil, addr++, &r0, 1);\n\tr_anal_esil_mem_write (esil, addr++, &r1, 1);\n\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_WRITE\nstatic int avr_custom_spm_page_write(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tchar *t = NULL;\n\tut64 addr, page_size_bits, tmp_page;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address\n\tif (!__esil_pop_argument (esil, &addr)) {\n\t\treturn false;\n\t}\n\n\t// get details about current MCU and fix input address and base address\n\t// of the internal temporary page\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\tr_anal_esil_reg_read (esil, \"_page\", &tmp_page, NULL);\n\n\t// align base address to page_size_bits\n\taddr &= (~(MASK (page_size_bits)) & CPU_PC_MASK (cpu));\n\n\t// perform writing\n\t//eprintf (\"SPM_PAGE_WRITE %ld bytes @ 0x%08\" PFMT64x \".\\n\", page_size, addr);\n\tif (!(t = malloc (1 << page_size_bits))) {\n\t\teprintf (\"Cannot alloc a buffer for copying the temporary page.\\n\");\n\t\treturn false;\n\t}\n\tr_anal_esil_mem_read (esil, tmp_page, (ut8 *) t, 1 << page_size_bits);\n\tr_anal_esil_mem_write (esil, addr, (ut8 *) t, 1 << page_size_bits);\n\n\treturn true;\n}\n\nstatic int esil_avr_hook_reg_write(RAnalEsil *esil, const char *name, ut64 *val) {\n\tCPU_MODEL *cpu;\n\n\tif (!esil || !esil->anal) {\n\t\treturn 0;\n\t}\n\n\t// select cpu info\n\tcpu = get_cpu_model (esil->anal->cpu);\n\n\t// crop registers and force certain values\n\tif (!strcmp (name, \"pc\")) {\n\t\t*val &= CPU_PC_MASK (cpu);\n\t} else if (!strcmp (name, \"pcl\")) {\n\t\tif (cpu->pc < 8) {\n\t\t\t*val &= MASK (8);\n\t\t}\n\t} else if (!strcmp (name, \"pch\")) {\n\t\t*val = cpu->pc > 8\n\t\t\t? *val & MASK (cpu->pc - 8)\n\t\t\t: 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int esil_avr_init(RAnalEsil *esil) {\n\tif (!esil) {\n\t\treturn false;\n\t}\n\tdesctx.round = 0;\n\tr_anal_esil_set_op (esil, \"des\", avr_custom_des);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_ERASE\", avr_custom_spm_page_erase);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_FILL\", avr_custom_spm_page_fill);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_WRITE\", avr_custom_spm_page_write);\n\tesil->cb.hook_reg_write = esil_avr_hook_reg_write;\n\n\treturn true;\n}\n\nstatic int esil_avr_fini(RAnalEsil *esil) {\n\treturn true;\n}\n\nstatic int set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpcl\\n\"\n\t\t\"=SP\tsp\\n\"\n// explained in http://www.nongnu.org/avr-libc/user-manual/FAQ.html\n// and http://www.avrfreaks.net/forum/function-calling-convention-gcc-generated-assembly-file\n\t\t\"=A0\tr25\\n\"\n\t\t\"=A1\tr24\\n\"\n\t\t\"=A2\tr23\\n\"\n\t\t\"=A3\tr22\\n\"\n\t\t\"=R0\tr24\\n\"\n#if 0\nPC: 16- or 22-bit program counter\nSP: 8- or 16-bit stack pointer\nSREG: 8-bit status register\nRAMPX, RAMPY, RAMPZ, RAMPD and EIND:\n#endif\n// 8bit registers x 32\n\t\t\"gpr\tr0\t.8\t0\t0\\n\"\n\t\t\"gpr\tr1\t.8\t1\t0\\n\"\n\t\t\"gpr\tr2\t.8\t2\t0\\n\"\n\t\t\"gpr\tr3\t.8\t3\t0\\n\"\n\t\t\"gpr\tr4\t.8\t4\t0\\n\"\n\t\t\"gpr\tr5\t.8\t5\t0\\n\"\n\t\t\"gpr\tr6\t.8\t6\t0\\n\"\n\t\t\"gpr\tr7\t.8\t7\t0\\n\"\n\t\t\"gpr\ttext\t.64\t0\t0\\n\"\n\t\t\"gpr\tr8\t.8\t8\t0\\n\"\n\t\t\"gpr\tr9\t.8\t9\t0\\n\"\n\t\t\"gpr\tr10\t.8\t10\t0\\n\"\n\t\t\"gpr\tr11\t.8\t11\t0\\n\"\n\t\t\"gpr\tr12\t.8\t12\t0\\n\"\n\t\t\"gpr\tr13\t.8\t13\t0\\n\"\n\t\t\"gpr\tr14\t.8\t14\t0\\n\"\n\t\t\"gpr\tr15\t.8\t15\t0\\n\"\n\t\t\"gpr\tdeskey\t.64\t8\t0\\n\"\n\t\t\"gpr\tr16\t.8\t16\t0\\n\"\n\t\t\"gpr\tr17\t.8\t17\t0\\n\"\n\t\t\"gpr\tr18\t.8\t18\t0\\n\"\n\t\t\"gpr\tr19\t.8\t19\t0\\n\"\n\t\t\"gpr\tr20\t.8\t20\t0\\n\"\n\t\t\"gpr\tr21\t.8\t21\t0\\n\"\n\t\t\"gpr\tr22\t.8\t22\t0\\n\"\n\t\t\"gpr\tr23\t.8\t23\t0\\n\"\n\t\t\"gpr\tr24\t.8\t24\t0\\n\"\n\t\t\"gpr\tr25\t.8\t25\t0\\n\"\n\t\t\"gpr\tr26\t.8\t26\t0\\n\"\n\t\t\"gpr\tr27\t.8\t27\t0\\n\"\n\t\t\"gpr\tr28\t.8\t28\t0\\n\"\n\t\t\"gpr\tr29\t.8\t29\t0\\n\"\n\t\t\"gpr\tr30\t.8\t30\t0\\n\"\n\t\t\"gpr\tr31\t.8\t31\t0\\n\"\n\n// 16 bit overlapped registers for 16 bit math\n\t\t\"gpr\tr17:r16\t.16\t16\t0\\n\"\n\t\t\"gpr\tr19:r18\t.16\t18\t0\\n\"\n\t\t\"gpr\tr21:r20\t.16\t20\t0\\n\"\n\t\t\"gpr\tr23:r22\t.16\t22\t0\\n\"\n\t\t\"gpr\tr25:r24\t.16\t24\t0\\n\"\n\t\t\"gpr\tr27:r26\t.16\t26\t0\\n\"\n\t\t\"gpr\tr29:r28\t.16\t28\t0\\n\"\n\t\t\"gpr\tr31:r30\t.16\t30\t0\\n\"\n\n// 16 bit overlapped registers for memory addressing\n\t\t\"gpr\tx\t.16\t26\t0\\n\"\n\t\t\"gpr\ty\t.16\t28\t0\\n\"\n\t\t\"gpr\tz\t.16\t30\t0\\n\"\n// program counter\n// NOTE: program counter size in AVR depends on the CPU model. It seems that\n// the PC may range from 16 bits to 22 bits.\n\t\t\"gpr\tpc\t.32\t32\t0\\n\"\n\t\t\"gpr\tpcl\t.16\t32\t0\\n\"\n\t\t\"gpr\tpch\t.16\t34\t0\\n\"\n// special purpose registers\n\t\t\"gpr\tsp\t.16\t36\t0\\n\"\n\t\t\"gpr\tspl\t.8\t36\t0\\n\"\n\t\t\"gpr\tsph\t.8\t37\t0\\n\"\n// status bit register (SREG)\n\t\t\"gpr\tsreg\t.8\t38\t0\\n\"\n\t\t\"gpr\tcf\t.1\t38.0\t0\\n\" // Carry. This is a borrow flag on subtracts.\n\t\t\"gpr\tzf\t.1\t38.1\t0\\n\" // Zero. Set to 1 when an arithmetic result is zero.\n\t\t\"gpr\tnf\t.1\t38.2\t0\\n\" // Negative. Set to a copy of the most significant bit of an arithmetic result.\n\t\t\"gpr\tvf\t.1\t38.3\t0\\n\" // Overflow flag. Set in case of two's complement overflow.\n\t\t\"gpr\tsf\t.1\t38.4\t0\\n\" // Sign flag. Unique to AVR, this is always (N ^ V) (xor), and shows the true sign of a comparison.\n\t\t\"gpr\thf\t.1\t38.5\t0\\n\" // Half carry. This is an internal carry from additions and is used to support BCD arithmetic.\n\t\t\"gpr\ttf\t.1\t38.6\t0\\n\" // Bit copy. Special bit load and bit store instructions use this bit.\n\t\t\"gpr\tif\t.1\t38.7\t0\\n\" // Interrupt flag. Set when interrupts are enabled.\n// 8bit segment registers to be added to X, Y, Z to get 24bit offsets\n\t\t\"gpr\trampx\t.8\t39\t0\\n\"\n\t\t\"gpr\trampy\t.8\t40\t0\\n\"\n\t\t\"gpr\trampz\t.8\t41\t0\\n\"\n\t\t\"gpr\trampd\t.8\t42\t0\\n\"\n\t\t\"gpr\teind\t.8\t43\t0\\n\"\n// memory mapping emulator registers\n//      _prog\n//\t\tthe program flash. It has its own address space.\n//\t_ram\n//\t_io\n//\t\tstart of the data addres space. It is the same address of IO,\n//\t\tbecause IO is the first memory space addressable in the AVR.\n//\t_sram\n//\t\tstart of the SRAM (this offset depends on IO size, and it is\n//\t\tinside the _ram address space)\n//      _eeprom\n//              this is another address space, outside ram and flash\n//      _page\n//              this is the temporary page used by the SPM instruction. This\n//              memory is not directly addressable and it is used internally by\n//              the CPU when autoflashing.\n\t\t\"gpr\t_prog\t.32\t44\t0\\n\"\n\t\t\"gpr    _page   .32     48\t0\\n\"\n\t\t\"gpr\t_eeprom\t.32\t52\t0\\n\"\n\t\t\"gpr\t_ram\t.32\t56\t0\\n\"\n\t\t\"gpr\t_io\t.32\t56\t0\\n\"\n\t\t\"gpr\t_sram\t.32\t60\t0\\n\"\n// other important MCU registers\n//\tspmcsr/spmcr\n//\t\tStore Program Memory Control and Status Register (SPMCSR)\n\t\t\"gpr    spmcsr  .8      64      0\\n\"\n\t\t;\n\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n\nstatic int archinfo(RAnal *anal, int q) {\n\tif (q == R_ANAL_ARCHINFO_ALIGN)\n\t\treturn 2;\n\tif (q == R_ANAL_ARCHINFO_MAX_OP_SIZE)\n\t\treturn 4;\n\tif (q == R_ANAL_ARCHINFO_MIN_OP_SIZE)\n\t\treturn 2;\n\treturn 2; // XXX\n}\n\n\nstatic ut8 *anal_mask_avr(RAnal *anal, int size, const ut8 *data, ut64 at) {\n\tRAnalOp *op = NULL;\n\tut8 *ret = NULL;\n\tint idx;\n\n\tif (!(op = r_anal_op_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(ret = malloc (size))) {\n\t\tr_anal_op_free (op);\n\t\treturn NULL;\n\t}\n\n\tmemset (ret, 0xff, size);\n\n\tCPU_MODEL *cpu = get_cpu_model (anal->cpu);\n\n\tfor (idx = 0; idx + 1 < size; idx += op->size) {\n\t\tOPCODE_DESC* opcode_desc = avr_op_analyze (anal, op, at + idx, data + idx, size - idx, cpu);\n\n\t\tif (op->size < 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!opcode_desc) { // invalid instruction\n\t\t\tcontinue;\n\t\t}\n\n\t\t// the additional data for \"long\" opcodes (4 bytes) is usually something we want to ignore for matching\n\t\t// (things like memory offsets or jump addresses)\n\t\tif (op->size == 4) {\n\t\t\tret[idx + 2] = 0;\n\t\t\tret[idx + 3] = 0;\n\t\t}\n\n\t\tif (op->ptr != UT64_MAX || op->jump != UT64_MAX) {\n\t\t\tret[idx] = opcode_desc->mask;\n\t\t\tret[idx + 1] = opcode_desc->mask >> 8;\n\t\t}\n\t}\n\n\tr_anal_op_free (op);\n\n\treturn ret;\n}\n\nRAnalPlugin r_anal_plugin_avr = {\n\t.name = \"avr\",\n\t.desc = \"AVR code analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"avr\",\n\t.esil = true,\n\t.archinfo = archinfo,\n\t.bits = 8 | 16, // 24 big regs conflicts\n\t.op = &avr_op,\n\t.set_reg_profile = &set_reg_profile,\n\t.esil_init = esil_avr_init,\n\t.esil_fini = esil_avr_fini,\n\t.anal_mask = anal_mask_avr,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_avr,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare - LGPL - Copyright 2009-2018 - pancake, maijin */\n\n#include \"r_util.h\"\n#include \"r_core.h\"\n\nstatic const char *help_msg_a[] = {\n\t\"Usage:\", \"a\", \"[abdefFghoprxstc] [...]\",\n\t\"aa\", \"[?]\", \"analyze all (fcns + bbs) (aa0 to avoid sub renaming)\",\n\t\"a8\", \" [hexpairs]\", \"analyze bytes\",\n\t\"ab\", \"[b] [addr]\", \"analyze block at given address\",\n\t\"abb\", \" [len]\", \"analyze N basic blocks in [len] (section.size by default)\",\n\t\"ac\", \" [cycles]\", \"analyze which op could be executed in [cycles]\",\n\t\"ad\", \"[?]\", \"analyze data trampoline (wip)\",\n\t\"ad\", \" [from] [to]\", \"analyze data pointers to (from-to)\",\n\t\"ae\", \"[?] [expr]\", \"analyze opcode eval expression (see ao)\",\n\t\"af\", \"[?]\", \"analyze Functions\",\n\t\"aF\", \"\", \"same as above, but using anal.depth=1\",\n\t\"ag\", \"[?] [options]\", \"output Graphviz code\",\n\t\"ah\", \"[?]\", \"analysis hints (force opcode size, ...)\",\n\t\"ai\", \" [addr]\", \"address information (show perms, stack, heap, ...)\",\n\t\"an\",\" [name] [@addr]\",\"show/rename/create whatever flag/function is used at addr\",\n\t\"ao\", \"[?] [len]\", \"analyze Opcodes (or emulate it)\",\n\t\"aO\", \"[?] [len]\", \"Analyze N instructions in M bytes\",\n\t\"ap\", \"\", \"find prelude for current offset\",\n\t\"ar\", \"[?]\", \"like 'dr' but for the esil vm. (registers)\",\n\t\"as\", \"[?] [num]\", \"analyze syscall using dbg.reg\",\n\t\"av\", \"[?] [.]\", \"show vtables\",\n\t\"ax\", \"[?]\", \"manage refs/xrefs (see also afx?)\",\n\tNULL\n};\n\nstatic const char *help_msg_aa[] = {\n\t\"Usage:\", \"aa[0*?]\", \" # see also 'af' and 'afna'\",\n\t\"aa\", \" \", \"alias for 'af@@ sym.*;af@entry0;afva'\", //;.afna @@ fcn.*'\",\n\t\"aa*\", \"\", \"analyze all flags starting with sym. (af @@ sym.*)\",\n\t\"aaa\", \"[?]\", \"autoname functions after aa (see afna)\",\n\t\"aab\", \"\", \"aab across io.sections.text\",\n\t\"aac\", \" [len]\", \"analyze function calls (af @@ `pi len~call[1]`)\",\n\t\"aac*\", \" [len]\", \"flag function calls without performing a complete analysis\",\n\t\"aad\", \" [len]\", \"analyze data references to code\",\n\t\"aae\", \" [len] ([addr])\", \"analyze references with ESIL (optionally to address)\",\n\t\"aaE\", \"\", \"run aef on all functions (same as aef @@f)\",\n\t\"aaf\", \" \", \"analyze all functions (e anal.hasnext=1;afr @@c:isq)\",\n\t\"aai\", \"[j]\", \"show info of all analysis parameters\",\n\t\"aan\", \"\", \"autoname functions that either start with fcn.* or sym.func.*\",\n\t\"aap\", \"\", \"find and analyze function preludes\",\n\t\"aar\", \"[?] [len]\", \"analyze len bytes of instructions for references\",\n\t\"aas\", \" [len]\", \"analyze symbols (af @@= `isq~[0]`)\",\n\t\"aat\", \" [len]\", \"analyze all consecutive functions in section\",\n\t\"aaT\", \" [len]\", \"analyze code after trap-sleds\",\n\t\"aau\", \" [len]\", \"list mem areas (larger than len bytes) not covered by functions\",\n\t\"aav\", \" [sat]\", \"find values referencing a specific section or map\",\n\tNULL\n};\n\nstatic const char *help_msg_aar[] = {\n\t\"Usage:\", \"aar\", \"[j*] [sz] # search and analyze xrefs\",\n\t\"aar\", \" [sz]\", \"analyze xrefs in current section or sz bytes of code\",\n\t\"aar*\", \" [sz]\", \"list found xrefs in radare commands format\",\n\t\"aarj\", \" [sz]\", \"list found xrefs in JSON format\",\n\tNULL\n};\n\nstatic const char *help_msg_ab[] = {\n\t\"Usage:\", \"ab\", \"\",\n\t\"ab\", \" [addr]\", \"show basic block information at given address\",\n\t\"abb\", \" [length]\", \"analyze N bytes and extract basic blocks\",\n\t\"abj\", \"\", \"display basic block information in JSON\",\n\t\"abx\", \" [hexpair-bytes]\", \"analyze N bytes\",\n\tNULL\n};\n\nstatic const char *help_msg_ad[] = {\n\t\"Usage:\", \"ad\", \"[kt] [...]\",\n\t\"ad\", \" [N] [D]\", \"analyze N data words at D depth\",\n\t\"ad4\", \" [N] [D]\", \"analyze N data words at D depth (asm.bits=32)\",\n\t\"ad8\", \" [N] [D]\", \"analyze N data words at D depth (asm.bits=64)\",\n\t\"adf\", \"\", \"analyze data in function (use like .adf @@=`afl~[0]`\",\n\t\"adfg\", \"\", \"analyze data in function gaps\",\n\t\"adt\", \"\", \"analyze data trampolines (wip)\",\n\t\"adk\", \"\", \"analyze data kind (code, text, data, invalid, ...)\",\n\tNULL\n};\n\nstatic const char *help_msg_ae[] = {\n\t\"Usage:\", \"ae[idesr?] [arg]\", \"ESIL code emulation\",\n\t\"ae\", \" [expr]\", \"evaluate ESIL expression\",\n\t\"ae?\", \"\", \"show this help\",\n\t\"ae??\", \"\", \"show ESIL help\",\n\t\"ae[aA]\", \"[f] [count]\", \"analyse esil accesses (regs, mem..)\",\n\t\"aec\", \"[?]\", \"continue until ^C\",\n\t\"aecs\", \" [sn]\", \"continue until syscall number\",\n\t\"aecu\", \" [addr]\", \"continue until address\",\n\t\"aecue\", \" [esil]\", \"continue until esil expression match\",\n\t\"aef\", \" [addr]\", \"emulate function\",\n\t\"aei\", \"\", \"initialize ESIL VM state (aei- to deinitialize)\",\n\t\"aeim\", \" [addr] [size] [name]\", \"initialize ESIL VM stack (aeim- remove)\",\n\t\"aeip\", \"\", \"initialize ESIL program counter to curseek\",\n\t\"aek\", \" [query]\", \"perform sdb query on ESIL.info\",\n\t\"aek-\", \"\", \"resets the ESIL.info sdb instance\",\n\t\"aep\", \"[?] [addr]\", \"manage esil pin hooks\",\n\t\"aepc\", \" [addr]\", \"change esil PC to this address\",\n\t\"aer\", \" [..]\", \"handle ESIL registers like 'ar' or 'dr' does\",\n\t\"aets\", \"[?]\", \"ESIL Trace session\",\n\t\"aes\", \"\", \"perform emulated debugger step\",\n\t\"aesp\", \" [X] [N]\", \"evaluate N instr from offset X\",\n\t\"aesb\", \"\", \"step back\",\n\t\"aeso\", \" \", \"step over\",\n\t\"aesu\", \" [addr]\", \"step until given address\",\n\t\"aesue\", \" [esil]\", \"step until esil expression match\",\n\t\"aetr\", \"[esil]\", \"Convert an ESIL Expression to REIL\",\n\t\"aex\", \" [hex]\", \"evaluate opcode expression\",\n\tNULL\n};\n\nstatic const char *help_detail_ae[] = {\n\t\"Examples:\", \"ESIL\", \" examples and documentation\",\n\t\"+\", \"=\", \"A+=B => B,A,+=\",\n\t\"+\", \"\", \"A=A+B => B,A,+,A,=\",\n\t\"++\", \"\", \"increment, 2,A,++ == 3 (see rsi,--=[1], ... )\",\n\t\"--\", \"\", \"decrement, 2,A,-- == 1\",\n\t\"*\", \"=\", \"A*=B => B,A,*=\",\n\t\"/\", \"=\", \"A/=B => B,A,/=\",\n\t\"%\", \"=\", \"A%=B => B,A,%=\",\n\t\"&\", \"=\", \"and ax, bx => bx,ax,&=\",\n\t\"|\", \"\", \"or r0, r1, r2 => r2,r1,|,r0,=\",\n\t\"!\", \"=\", \"negate all bits\",\n\t\"^\", \"=\", \"xor ax, bx => bx,ax,^=\",\n\t\"\", \"[]\", \"mov eax,[eax] => eax,[],eax,=\",\n\t\"=\", \"[]\", \"mov [eax+3], 1 => 1,3,eax,+,=[]\",\n\t\"=\", \"[1]\", \"mov byte[eax],1 => 1,eax,=[1]\",\n\t\"=\", \"[8]\", \"mov [rax],1 => 1,rax,=[8]\",\n\t\"[]\", \"\", \"peek from random position\",\n\t\"[*]\", \"\", \"peek some from random position\",\n\t\"=\", \"[*]\", \"poke some at random position\",\n\t\"$\", \"\", \"int 0x80 => 0x80,$\",\n\t\"$$\", \"\", \"simulate a hardware trap\",\n\t\"==\", \"\", \"pops twice, compare and update esil flags\",\n\t\"<\", \"\", \"compare for smaller\",\n\t\"<\", \"=\", \"compare for smaller or equal\",\n\t\">\", \"\", \"compare for bigger\",\n\t\">\", \"=\", \"compare bigger for or equal\",\n\t\">>\", \"=\", \"shr ax, bx => bx,ax,>>=  # shift right\",\n\t\"<<\", \"=\", \"shl ax, bx => bx,ax,<<=  # shift left\",\n\t\">>>\", \"=\", \"ror ax, bx => bx,ax,>>>=  # rotate right\",\n\t\"<<<\", \"=\", \"rol ax, bx => bx,ax,<<<=  # rotate left\",\n\t\"?{\", \"\", \"if popped value != 0 run the block until }\",\n\t\"POP\", \"\", \"drops last element in the esil stack\",\n\t\"DUP\", \"\", \"duplicate last value in stack\",\n\t\"NUM\", \"\", \"evaluate last item in stack to number\",\n\t\"PICK\", \"\", \"pick Nth element in stack\",\n\t\"RPICK\", \"\", \"pick Nth element in reversed stack\",\n\t\"SWAP\", \"\", \"swap last two values in stack\",\n\t\"TRAP\", \"\", \"stop execution\",\n\t\"BITS\", \"\", \"16,BITS  # change bits, useful for arm/thumb\",\n\t\"TODO\", \"\", \"the instruction is not yet esilized\",\n\t\"STACK\", \"\", \"show contents of stack\",\n\t\"CLEAR\", \"\", \"clears the esil stack\",\n\t\"REPEAT\", \"\", \"repeat n times\",\n\t\"BREAK\", \"\", \"terminates the string parsing\",\n\t\"GOTO\", \"\", \"jump to the Nth word popped from the stack\",\n\tNULL\n};\n\nstatic const char *help_msg_aea[] = {\n\t\"Examples:\", \"aea\", \" show regs used in a range\",\n\t\"aea\", \" [ops]\", \"Show regs used in N instructions (all,read,{no,}written,memreads,memwrites)\",\n\t\"aea*\", \" [ops]\", \"Create mem.* flags for memory accesses\",\n\t\"aeaf\", \"\", \"Show regs used in current function\",\n\t\"aear\", \" [ops]\", \"Show regs read in N instructions\",\n\t\"aeaw\", \" [ops]\", \"Show regs written in N instructions\",\n\t\"aean\", \" [ops]\", \"Show regs not written in N instructions\",\n\t\"aeaj\", \" [ops]\", \"Show aea output in JSON format\",\n\t\"aeA\", \" [len]\", \"Show regs used in N bytes (subcommands are the same)\",\n\tNULL\n};\n\nstatic const char *help_msg_aec[] = {\n\t\"Examples:\", \"aec\", \" continue until ^c\",\n\t\"aec\", \"\", \"Continue until exception\",\n\t\"aecs\", \"\", \"Continue until syscall\",\n\t\"aecu\", \"[addr]\", \"Continue until address\",\n\t\"aecue\", \"[addr]\", \"Continue until esil expression\",\n\tNULL\n};\n\nstatic const char *help_msg_aep[] = {\n\t\"Usage:\", \"aep[-c] \", \" [...]\",\n\t\"aepc\", \" [addr]\", \"change program counter for esil\",\n\t\"aep\", \"-[addr]\", \"remove pin\",\n\t\"aep\", \" [name] @ [addr]\", \"set pin\",\n\t\"aep\", \"\", \"list pins\",\n\tNULL\n};\n\nstatic const char *help_msg_aets[] = {\n\t\"Usage:\", \"aets \", \" [...]\",\n\t\"aets\", \"\", \"List all ESIL trace sessions\",\n\t\"aets+\", \"\", \"Add ESIL trace session\",\n\tNULL\n};\n\nstatic const char *help_msg_af[] = {\n\t\"Usage:\", \"af\", \"\",\n\t\"af\", \" ([name]) ([addr])\", \"analyze functions (start at addr or $$)\",\n\t\"afr\", \" ([name]) ([addr])\", \"analyze functions recursively\",\n\t\"af+\", \" addr name [type] [diff]\", \"hand craft a function (requires afb+)\",\n\t\"af-\", \" [addr]\", \"clean all function analysis data (or function at addr)\",\n\t\"afb+\", \" fcnA bbA sz [j] [f] ([t]( [d]))\", \"add bb to function @ fcnaddr\",\n\t\"afb\", \"[?] [addr]\", \"List basic blocks of given function\",\n\t\"afB\", \" 16\", \"set current function as thumb (change asm.bits)\",\n\t\"afC[lc]\", \" ([addr])@[addr]\", \"calculate the Cycles (afC) or Cyclomatic Complexity (afCc)\",\n\t\"afc\", \"[?] type @[addr]\", \"set calling convention for function\",\n\t\"afd\", \"[addr]\",\"show function + delta for given offset\",\n\t\"aft\", \"[?]\", \"type matching, type propagation\",\n\t\"aff\", \"\", \"re-adjust function boundaries to fit\",\n\t\"afF\", \"[1|0|]\", \"fold/unfold/toggle\",\n\t\"afi\", \" [addr|fcn.name]\", \"show function(s) information (verbose afl)\",\n\t\"afl\", \"[?] [l*] [fcn name]\", \"list functions (addr, size, bbs, name) (see afll)\",\n\t\"afo\", \" [fcn.name]\", \"show address for the function named like this\",\n\t\"afm\", \" name\", \"merge two functions\",\n\t\"afM\", \" name\", \"print functions map\",\n\t\"afn\", \"[?] name [addr]\", \"rename name for function at address (change flag too)\",\n\t\"afna\", \"\", \"suggest automatic name for current offset\",\n\t\"afs\", \" [addr] [fcnsign]\", \"get/set function signature at current address\",\n\t\"afS\", \"[stack_size]\", \"set stack frame size for function at current address\",\n\t\"afu\", \" [addr]\", \"resize and analyze function from current address until addr\",\n\t\"afv[bsra]\", \"?\", \"manipulate args, registers and variables in function\",\n\t\"afx\", \"[cCd-] src dst\", \"add/remove code/Call/data/string reference\",\n\tNULL\n};\n\nstatic const char *help_msg_afb[] = {\n\t\"Usage:\", \"afb\", \" List basic blocks of given function\",\n\t\".afbr-\", \"\", \"Set breakpoint on every return address of the function\",\n\t\".afbr-*\", \"\", \"Remove breakpoint on every return address of the function\",\n\t\"afb\", \" [addr]\", \"list basic blocks of function\",\n\t\"afb.\", \" [addr]\", \"show info of current basic block\",\n\t\"afb+\", \" fcn_at bbat bbsz [jump] [fail] ([type] ([diff]))\", \"add basic block by hand\",\n\t\"afbr\", \"\", \"Show addresses of instructions which leave the function\",\n\t\"afbi\", \"\", \"print current basic block information\",\n\t\"afbj\", \"\", \"show basic blocks information in json\",\n\t\"afbe\", \" bbfrom bbto\", \"add basic-block edge for switch-cases\",\n\t\"afB\", \" [bits]\", \"define asm.bits for the given function\",\n\tNULL\n};\n\nstatic const char *help_msg_afc[] = {\n\t\"Usage:\", \"afc[agl?]\", \"\",\n\t\"afc\", \" convention\", \"Manually set calling convention for current function\",\n\t\"afc\", \"\", \"Show Calling convention for the Current function\",\n\t\"afcr\", \"[j]\", \"Show register usage for the current function\",\n\t\"afca\", \"\", \"Analyse function for finding the current calling convention\",\n\t\"afcl\", \"\", \"List all available calling conventions\",\n\t\"afco\", \" path\", \"Open Calling Convention sdb profile from given path\",\n\tNULL\n};\n\nstatic const char *help_msg_afC[] = {\n\t\"Usage:\", \"afC\", \" [addr]\",\n\t\"afC\", \"\", \"function cycles cost\",\n\t\"afCc\", \"\", \"cyclomatic complexity\",\n\t\"afCl\", \"\", \"loop count (backward jumps)\",\n\tNULL\n};\n\nstatic const char *help_msg_afi[] = {\n\t\"Usage:\", \"afi[jl*]\", \" <addr>\",\n\t\"afi\", \"\", \"show information of the function\",\n\t\"afi.\", \"\", \"show function name in current offset\",\n\t\"afi*\", \"\", \"function, variables and arguments\",\n\t\"afij\", \"\", \"function info in json format\",\n\t\"afil\", \"\", \"verbose function info\",\n\tNULL\n};\n\nstatic const char *help_msg_afl[] = {\n\t\"Usage:\", \"afl\", \" List all functions\",\n\t\"afl\", \"\", \"list functions\",\n\t\"aflc\", \"\", \"count of functions\",\n\t\"aflj\", \"\", \"list functions in json\",\n\t\"afll\", \"\", \"list functions in verbose mode\",\n\t\"afllj\", \"\", \"list functions in verbose mode (alias to aflj)\",\n\t\"aflq\", \"\", \"list functions in quiet mode\",\n\t\"aflqj\", \"\", \"list functions in json quiet mode\",\n\t\"afls\", \"\", \"print sum of sizes of all functions\",\n\tNULL\n};\n\nstatic const char *help_msg_afll[] = {\n\t\"Usage:\", \"\", \" List functions in verbose mode\",\n\t\"\", \"\", \"\",\n\t\"Table fields:\", \"\", \"\",\n\t\"\", \"\", \"\",\n\t\"address\", \"\", \"start address\",\n\t\"size\", \"\", \"function size (realsize)\",\n\t\"nbbs\", \"\", \"number of basic blocks\",\n\t\"edges\", \"\", \"number of edges between basic blocks\",\n\t\"cc\", \"\", \"cyclomatic complexity ( cc = edges - blocks + 2 * exit_blocks)\",\n\t\"cost\", \"\", \"cyclomatic cost\",\n\t\"min bound\", \"\", \"minimal address\",\n\t\"range\", \"\", \"function size\",\n\t\"max bound\", \"\", \"maximal address\",\n\t\"calls\", \"\", \"number of caller functions\",\n\t\"locals\", \"\", \"number of local variables\",\n\t\"args\", \"\", \"number of function arguments\",\n\t\"xref\", \"\", \"number of cross references\",\n\t\"frame\", \"\", \"function stack size\",\n\t\"name\", \"\", \"function name\",\n\tNULL\n};\n\nstatic const char *help_msg_afn[] = {\n\t\"Usage:\", \"afn[sa]\", \" Analyze function names\",\n\t\"afn\", \" [name]\", \"rename the function\",\n\t\"afna\", \"\", \"construct a function name for the current offset\",\n\t\"afns\", \"\", \"list all strings associated with the current function\",\n\tNULL\n};\n\nstatic const char *help_msg_aft[] = {\n\t\"Usage:\", \"aftm\", \"\",\n\t\"afta\", \"\", \"Setup memory and analyse do type matching analysis for all functions\",\n\t\"aftm\", \"\", \"type matching analysis\",\n\tNULL\n};\n\nstatic const char *help_msg_afv[] = {\n\t\"Usage:\", \"afv\",\"[rbs]\",\n\t\"afvr\", \"[?]\", \"manipulate register based arguments\",\n\t\"afvb\", \"[?]\", \"manipulate bp based arguments/locals\",\n\t\"afvs\", \"[?]\", \"manipulate sp based arguments/locals\",\n\t\"afvR\", \" [varname]\", \"list addresses where vars are accessed\",\n\t\"afvW\", \" [varname]\", \"list addresses where vars are accessed\",\n\t\"afva\", \"\", \"analyze function arguments/locals\",\n\t\"afvd\", \" name\", \"output r2 command for displaying the value of args/locals in the debugger\",\n\t\"afvn\", \" [old_name] [new_name]\", \"rename argument/local\",\n\t\"afvt\", \" [name] [new_type]\", \"change type for given argument/local\",\n\t\"afv-\", \"([name])\", \"remove all or given var\",\n\tNULL\n};\n\nstatic const char *help_msg_afvb[] = {\n\t\"Usage:\", \"afvb\", \" [idx] [name] ([type])\",\n\t\"afvb\", \"\", \"list base pointer based arguments, locals\",\n\t\"afvb*\", \"\", \"same as afvb but in r2 commands\",\n\t\"afvb\", \" [idx] [name] ([type])\", \"define base pointer based arguments, locals\",\n\t\"afvbj\", \"\", \"return list of base pointer based arguments, locals in JSON format\",\n\t\"afvb-\", \" [name]\", \"delete argument/locals at the given name\",\n\t\"afvbg\", \" [idx] [addr]\", \"define var get reference\",\n\t\"afvbs\", \" [idx] [addr]\", \"define var set reference\",\n\tNULL\n};\n\nstatic const char *help_msg_afvr[] = {\n\t\"Usage:\", \"afvr\", \" [reg] [type] [name]\",\n\t\"afvr\", \"\", \"list register based arguments\",\n\t\"afvr*\", \"\", \"same as afvr but in r2 commands\",\n\t\"afvr\", \" [reg] [name] ([type])\", \"define register arguments\",\n\t\"afvrj\", \"\", \"return list of register arguments in JSON format\",\n\t\"afvr-\", \" [name]\", \"delete register arguments at the given index\",\n\t\"afvrg\", \" [reg] [addr]\", \"define argument get reference\",\n\t\"afvrs\", \" [reg] [addr]\", \"define argument set reference\",\n\tNULL\n};\n\nstatic const char *help_msg_afvs[] = {\n\t\"Usage:\", \"afvs\", \" [idx] [type] [name]\",\n\t\"afvs\", \"\", \"list stack based arguments and locals\",\n\t\"afvs*\", \"\", \"same as afvs but in r2 commands\",\n\t\"afvs\", \" [idx] [name] [type]\", \"define stack based arguments,locals\",\n\t\"afvsj\", \"\", \"return list of stack based arguments and locals in JSON format\",\n\t\"afvs-\", \" [name]\", \"delete stack based argument or locals with the given name\",\n\t\"afvsg\", \" [idx] [addr]\", \"define var get reference\",\n\t\"afvss\", \" [idx] [addr]\", \"define var set reference\",\n\tNULL\n};\n\nstatic const char *help_msg_afx[] = {\n\t\"Usage:\", \"afx[-cCd?] [src] [dst]\", \" manage function references (see also ar?)\",\n\t\"afxc\", \" sym.main+0x38 sym.printf\", \"add code ref\",\n\t\"afxC\", \" sym.main sym.puts\", \"add call ref\",\n\t\"afxd\", \" sym.main str.helloworld\", \"add data ref\",\n\t\"afx-\", \" sym.main str.helloworld\", \"remove reference\",\n\tNULL\n};\n\nstatic const char *help_msg_ag[] = {\n\t\"Usage:\", \"ag[?f]\", \" Graphviz/graph code\",\n\t\"ag\", \" [addr]\", \"output graphviz code (bb at addr and children)\",\n\t\"ag-\", \"\", \"Reset the current ASCII art graph (see agn, age, agg?)\",\n\t\"aga\", \" [addr]\", \"idem, but only addresses\",\n\t\"agr\", \"[j] [addr]\", \"output graphviz call graph of function\",\n\t\"agg\", \"\", \"display current graph created with agn and age (see also ag-)\",\n\t\"agc\", \"[*j] [addr]\", \"output graphviz call graph of function\",\n\t\"agC\", \"[j]\", \"Same as agc -1. full program callgraph\",\n\t\"agd\", \" [fcn name]\", \"output graphviz code of diffed function\",\n\t\"age\", \"[?] title1 title2\", \"Add an edge to the current graph\",\n\t\"agf\", \" [addr]\", \"Show ASCII art graph of given function\",\n\t\"agg\", \"[?] [kdi*]\", \"Print graph in ASCII-Art, graphviz, k=v, r2 or visual\",\n\t\"agj\", \" [addr]\", \"idem, but in JSON format\",\n\t\"agJ\", \" [addr]\", \"idem, but in JSON format with formatted disassembly (like pdJ)\",\n\t\"agk\", \" [addr]\", \"idem, but in SDB key-value format\",\n\t\"agl\", \" [fcn name]\", \"output graphviz code using meta-data\",\n\t\"agn\", \"[?] title body\", \"Add a node to the current graph\",\n\t\"ags\", \" [addr]\", \"output simple graphviz call graph of function (only bb offset)\",\n\t\"agt\", \" [addr]\", \"find paths from current offset to given address\",\n\t\"agv\", \"\", \"Show function graph in web/png (see graph.web and cmd.graph) or agf for asciiart\",\n\tNULL\n};\n\nstatic const char *help_msg_age[] = {\n\t\"Usage:\", \"age [title1] [title2]\", \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"age\", \" title1 title2\", \"Add an edge from the node with \\\"title1\\\" as title to the one with title \\\"title2\\\"\",\n\t\"age\", \" \\\"title1 with spaces\\\" title2\", \"Add an edge from node \\\"title1 with spaces\\\" to node \\\"title2\\\"\",\n\t\"age-\", \" title1 title2\", \"Remove an edge from the node with \\\"title1\\\" as title to the one with title \\\"title2\\\"\",\n\t\"age?\", \"\", \"Show this help\",\n\tNULL\n};\n\nstatic const char *help_msg_agg[] = {\n\t\"Usage:\", \"agg[kid?*]\", \"print graph\",\n\t\"agg\", \"\", \"show current graph in ascii art\",\n\t\"aggk\", \"\", \"show graph in key=value form\",\n\t\"aggi\", \"\", \"enter interactive mode for the current graph\",\n\t\"aggd\", \"\", \"print the current graph in GRAPHVIZ dot format\",\n\t\"aggv\", \"\", \"run graphviz + viewer (see 'e cmd.graph')\",\n\t\"agg*\", \"\", \"in r2 commands, to save in projects, etc\",\n\tNULL\n};\n\nstatic const char *help_msg_agn[] = {\n\t\"Usage:\", \"agn [title] [body]\", \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"agn\", \" title1 body1\", \"Add a node with title \\\"title1\\\" and body \\\"body1\\\"\",\n\t\"agn\", \" \\\"title with space\\\" \\\"body with space\\\"\", \"Add a node with spaces in the title and in the body\",\n\t\"agn\", \" title1 base64:Ym9keTE=\", \"Add a node with the body specified as base64\",\n\t\"agn-\", \" title1\", \"Remove a node with title \\\"title1\\\"\",\n\t\"agn?\", \"\", \"Show this help\",\n\tNULL\n};\n\nstatic const char *help_msg_ah[] = {\n\t\"Usage:\", \"ah[lba-]\", \"Analysis Hints\",\n\t\"ah?\", \"\", \"show this help\",\n\t\"ah?\", \" offset\", \"show hint of given offset\",\n\t\"ah\", \"\", \"list hints in human-readable format\",\n\t\"ah.\", \"\", \"list hints in human-readable format from current offset\",\n\t\"ah-\", \"\", \"remove all hints\",\n\t\"ah-\", \" offset [size]\", \"remove hints at given offset\",\n\t\"ah*\", \" offset\", \"list hints in radare commands format\",\n\t\"aha\", \" ppc 51\", \"set arch for a range of N bytes\",\n\t\"ahb\", \" 16 @ $$\", \"force 16bit for current instruction\",\n\t\"ahc\", \" 0x804804\", \"override call/jump address\",\n\t\"ahe\", \" 3,eax,+=\", \"set vm analysis string\",\n\t\"ahf\", \" 0x804840\", \"override fallback address for call\",\n\t\"ahh\", \" 0x804840\", \"highlight this adrress offset in disasm\",\n\t\"ahi\", \"[?] 10\", \"define numeric base for immediates (1, 8, 10, 16, s)\",\n\t\"ahj\", \"\", \"list hints in JSON\",\n\t\"aho\", \" foo a0,33\", \"replace opcode string\",\n\t\"ahp\", \" addr\", \"set pointer hint\",\n\t\"ahs\", \" 4\", \"set opcode size=4\",\n\t\"ahS\", \" jz\", \"set asm.syntax=jz for this opcode\",\n\tNULL\n};\n\nstatic const char *help_msg_ahi[] = {\n\t\"Usage\", \"ahi [sbodh] [@ offset]\", \" Define numeric base\",\n\t\"ahi\", \" [base]\", \"set numeric base (1, 2, 8, 10, 16)\",\n\t\"ahi\", \" b\", \"set base to binary (2)\",\n\t\"ahi\", \" d\", \"set base to decimal (10)\",\n\t\"ahi\", \" h\", \"set base to hexadecimal (16)\",\n\t\"ahi\", \" o\", \"set base to octal (8)\",\n\t\"ahi\", \" p\", \"set base to htons(port) (3)\",\n\t\"ahi\", \" i\", \"set base to IP address (32)\",\n\t\"ahi\", \" S\", \"set base to syscall (80)\",\n\t\"ahi\", \" s\", \"set base to string (1)\",\n\tNULL\n};\n\nstatic const char *help_msg_ao[] = {\n\t\"Usage:\", \"ao[e?] [len]\", \"Analyze Opcodes\",\n\t\"aoj\", \" N\", \"display opcode analysis information in JSON for N opcodes\",\n\t\"aoe\", \" N\", \"display esil form for N opcodes\",\n\t\"aor\", \" N\", \"display reil form for N opcodes\",\n\t\"aos\", \" N\", \"display size of N opcodes\",\n\t\"ao\", \" 5\", \"display opcode analysis of 5 opcodes\",\n\t\"ao*\", \"\", \"display opcode in r commands\",\n\tNULL\n};\n\nstatic const char *help_msg_ar[] = {\n\t\"Usage: ar\", \"\", \"# Analysis Registers\",\n\t\"ar\", \"\", \"Show 'gpr' registers\",\n\t\"ar0\", \"\", \"Reset register arenas to 0\",\n\t\"ara\", \"[?]\", \"Manage register arenas\",\n\t\"ar\", \" 16\", \"Show 16 bit registers\",\n\t\"ar\", \" 32\", \"Show 32 bit registers\",\n\t\"ar\", \" all\", \"Show all bit registers\",\n\t\"ar\", \" <type>\", \"Show all registers of given type\",\n\t\"arC\", \"\", \"Display register profile comments\",\n\t\"arr\", \"\", \"Show register references (telescoping)\",\n\t\"ar=\", \"([size])(:[regs])\", \"Show register values in columns\",\n\t\"ar?\", \" <reg>\", \"Show register value\",\n\t\"arb\", \" <type>\", \"Display hexdump of the given arena\",\n\t\"arc\", \" <name>\", \"Conditional flag registers\",\n\t\"ard\", \" <name>\", \"Show only different registers\",\n\t\"arn\", \" <regalias>\", \"Get regname for pc,sp,bp,a0-3,zf,cf,of,sg\",\n\t\"aro\", \"\", \"Show old (previous) register values\",\n\t\"arp\", \"[?] <file>\", \"Load register profile from file\",\n\t\"ars\", \"\", \"Stack register state\",\n\t\"art\", \"\", \"List all register types\",\n\t\"arw\", \" <hexnum>\", \"Set contents of the register arena\",\n\t\".ar*\", \"\", \"Import register values as flags\",\n\t\".ar-\", \"\", \"Unflag all registers\",\n\tNULL\n};\n\nstatic const char *help_msg_ara[] = {\n\t\"Usage:\", \"ara[+-s]\", \"Register Arena Push/Pop/Swap\",\n\t\"ara\", \"\", \"show all register arenas allocated\",\n\t\"ara\", \"+\", \"push a new register arena for each type\",\n\t\"ara\", \"-\", \"pop last register arena\",\n\t\"aras\", \"\", \"swap last two register arenas\",\n\tNULL\n};\n\nstatic const char *help_msg_arw[] = {\n\t\"Usage:\", \"arw \", \"# Set contents of the register arena\",\n\t\"arw\", \" <hexnum>\", \"Set contents of the register arena\",\n\tNULL\n};\n\nstatic const char *help_msg_as[] = {\n\t\"Usage: as[ljk?]\", \"\", \"syscall name <-> number utility\",\n\t\"as\", \"\", \"show current syscall and arguments\",\n\t\"as\", \" 4\", \"show syscall 4 based on asm.os and current regs/mem\",\n\t\"asc[a]\", \" 4\", \"dump syscall info in .asm or .h\",\n\t\"asf\", \" [k[=[v]]]\", \"list/set/unset pf function signatures (see fcnsign)\",\n\t\"asj\", \"\", \"list of syscalls in JSON\",\n\t\"asl\", \"\", \"list of syscalls by asm.os and asm.arch\",\n\t\"asl\", \" close\", \"returns the syscall number for close\",\n\t\"asl\", \" 4\", \"returns the name of the syscall number 4\",\n\t\"ask\", \" [query]\", \"perform syscall/ queries\",\n\tNULL\n};\n\nstatic const char *help_msg_av[] = {\n\t\"Usage:\", \"av[?jr*]\", \" C++ vtables and RTTI\",\n\t\"av\", \"\", \"search for vtables in data sections and show results\",\n\t\"avj\", \"\", \"like av, but as json\",\n\t\"av*\", \"\", \"like av, but as r2 commands\",\n\t\"avr\", \"[j@addr]\", \"try to parse RTTI at vtable addr (see anal.cpp.abi)\",\n\t\"avra\", \"[j]\", \"search for vtables and try to parse RTTI at each of them\",\n\tNULL\n};\n\nstatic const char *help_msg_ax[] = {\n\t\"Usage:\", \"ax[?d-l*]\", \" # see also 'afx?'\",\n\t\"ax\", \"\", \"list refs\",\n\t\"ax\", \" addr [at]\", \"add code ref pointing to addr (from curseek)\",\n\t\"ax-\", \" [at]\", \"clean all refs (or refs from addr)\",\n\t\"axc\", \" addr [at]\", \"add code jmp ref // unused?\",\n\t\"axC\", \" addr [at]\", \"add code call ref\",\n\t\"axg\", \" [addr]\", \"show xrefs graph to reach current function\",\n\t\"axgj\", \" [addr]\", \"show xrefs graph to reach current function in json format\",\n\t\"axd\", \" addr [at]\", \"add data ref\",\n\t\"axq\", \"\", \"list refs in quiet/human-readable format\",\n\t\"axj\", \"\", \"list refs in json format\",\n\t\"axF\", \" [flg-glob]\", \"find data/code references of flags\",\n\t\"axt\", \" [addr]\", \"find data/code references to this address\",\n\t\"axf\", \" [addr]\", \"find data/code references from this address\",\n\t\"axk\", \" [query]\", \"perform sdb query\",\n\t\"ax*\", \"\", \"output radare commands\",\n\tNULL\n};\n\nstatic void cmd_anal_init(RCore *core) {\n\tDEFINE_CMD_DESCRIPTOR (core, a);\n\tDEFINE_CMD_DESCRIPTOR (core, aa);\n\tDEFINE_CMD_DESCRIPTOR (core, aar);\n\tDEFINE_CMD_DESCRIPTOR (core, ab);\n\tDEFINE_CMD_DESCRIPTOR (core, ad);\n\tDEFINE_CMD_DESCRIPTOR (core, ae);\n\tDEFINE_CMD_DESCRIPTOR (core, aea);\n\tDEFINE_CMD_DESCRIPTOR (core, aec);\n\tDEFINE_CMD_DESCRIPTOR (core, aep);\n\tDEFINE_CMD_DESCRIPTOR (core, af);\n\tDEFINE_CMD_DESCRIPTOR (core, afb);\n\tDEFINE_CMD_DESCRIPTOR (core, afc);\n\tDEFINE_CMD_DESCRIPTOR (core, afC);\n\tDEFINE_CMD_DESCRIPTOR (core, afi);\n\tDEFINE_CMD_DESCRIPTOR (core, afl);\n\tDEFINE_CMD_DESCRIPTOR (core, afll);\n\tDEFINE_CMD_DESCRIPTOR (core, afn);\n\tDEFINE_CMD_DESCRIPTOR (core, aft);\n\tDEFINE_CMD_DESCRIPTOR (core, afv);\n\tDEFINE_CMD_DESCRIPTOR (core, afvb);\n\tDEFINE_CMD_DESCRIPTOR (core, afvr);\n\tDEFINE_CMD_DESCRIPTOR (core, afvs);\n\tDEFINE_CMD_DESCRIPTOR (core, afx);\n\tDEFINE_CMD_DESCRIPTOR (core, ag);\n\tDEFINE_CMD_DESCRIPTOR (core, age);\n\tDEFINE_CMD_DESCRIPTOR (core, agg);\n\tDEFINE_CMD_DESCRIPTOR (core, agn);\n\tDEFINE_CMD_DESCRIPTOR (core, ah);\n\tDEFINE_CMD_DESCRIPTOR (core, ahi);\n\tDEFINE_CMD_DESCRIPTOR (core, ao);\n\tDEFINE_CMD_DESCRIPTOR (core, ar);\n\tDEFINE_CMD_DESCRIPTOR (core, ara);\n\tDEFINE_CMD_DESCRIPTOR (core, arw);\n\tDEFINE_CMD_DESCRIPTOR (core, as);\n\tDEFINE_CMD_DESCRIPTOR (core, ax);\n}\n\n/* better aac for windows-x86-32 */\n#define JAYRO_03 0\n\n#if JAYRO_03\n\nstatic bool anal_is_bad_call(RCore *core, ut64 from, ut64 to, ut64 addr, ut8 *buf, int bufi) {\n\tut64 align = R_ABS (addr % PE_ALIGN);\n\tut32 call_bytes;\n\n\t// XXX this is x86 specific\n\tif (align == 0) {\n\t\tcall_bytes = (ut32)((ut8*)buf)[bufi + 3] << 24;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 2] << 16;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 1] << 8;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi];\n\t} else {\n\t\tcall_bytes = (ut32)((ut8*)buf)[bufi - align + 3] << 24;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align + 2] << 16;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align + 1] << 8;\n\t\tcall_bytes |= (ut32)((ut8*)buf)[bufi - align];\n\t}\n\tif (call_bytes >= from && call_bytes <= to) {\n\t\treturn true;\n\t}\n\tcall_bytes = (ut32)((ut8*)buf)[bufi + 4] << 24;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 3] << 16;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 2] << 8;\n\tcall_bytes |= (ut32)((ut8*)buf)[bufi + 1];\n\tcall_bytes += addr + 5;\n\tif (call_bytes >= from && call_bytes <= to) {\n\t\treturn false;\n\t}\n\treturn false;\n}\n#endif\n\nstatic void type_cmd(RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tif (!fcn && *input != '?' && *input != 'a') {\n\t\teprintf (\"cant find function here\\n\");\n\t\treturn;\n\t}\n\tRListIter *it;\n\tut64 seek;\n\tbool io_cache =  r_config_get_i (core->config, \"io.cache\");\n\tr_cons_break_push (NULL, NULL);\n\tswitch (*input) {\n\tcase 'a': // \"afta\"\n\t\tif (r_config_get_i (core->config, \"cfg.debug\")) {\n\t\t\teprintf (\"TOFIX: afta can't run in debugger mode.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tseek = core->offset;\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tr_reg_arena_push (core->anal->reg);\n\t\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\t\tint ret = r_core_seek (core, fcn->addr, true);\n\t\t\tif (!ret) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_anal_esil_set_pc (core->anal->esil, fcn->addr);\n\t\t\tr_core_anal_type_match (core, fcn);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim-\");\n\t\tr_core_cmd0 (core, \"aei-\");\n\t\tr_core_seek (core, seek, true);\n\t\tr_reg_arena_pop (core->anal->reg);\n\t\tbreak;\n\tcase 'm': // \"aftm\"\n\t\tr_config_set_i (core->config, \"io.cache\", true);\n\t\tseek = core->offset;\n\t\tr_anal_esil_set_pc (core->anal->esil, fcn? fcn->addr: core->offset);\n\t\tr_core_anal_type_match (core, fcn);\n\t\tr_core_seek (core, seek, true);\n\t\tr_config_set_i (core->config, \"io.cache\", io_cache);\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_aft);\n\t\tbreak;\n\t}\n\tr_cons_break_pop ();\n}\n\nstatic int cc_print(void *p, const char *k, const char *v) {\n\tif (!strcmp (v, \"cc\")) {\n\t\tr_cons_println (k);\n\t}\n\treturn 1;\n}\n\nstatic void find_refs(RCore *core, const char *glob) {\n\tchar cmd[128];\n\tut64 curseek = core->offset;\n\twhile (*glob == ' ') glob++;\n\tif (!*glob) {\n\t\tglob = \"str.\";\n\t}\n\tif (*glob == '?') {\n\t\teprintf (\"Usage: arf [flag-str-filter]\\n\");\n\t\treturn;\n\t}\n\teprintf (\"Finding references of flags matching '%s'...\\n\", glob);\n\tsnprintf (cmd, sizeof (cmd) - 1, \".(findstref) @@= `f~%s[0]`\", glob);\n\tr_core_cmd0 (core, \"(findstref,f here=$$,s entry0,/r here,f-here)\");\n\tr_core_cmd0 (core, cmd);\n\tr_core_cmd0 (core, \"(-findstref)\");\n\tr_core_seek (core, curseek, 1);\n}\n\n/* set flags for every function */\nstatic void flag_every_function(RCore *core) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_flag_space_push (core->flags, \"functions\");\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tr_flag_set (core->flags, fcn->name,\n\t\t\tfcn->addr, r_anal_fcn_size (fcn));\n\t}\n\tr_flag_space_pop (core->flags);\n}\n\nstatic void var_help(RCore *core, char ch) {\n\tswitch (ch) {\n\tcase 'b':\n\t\tr_core_cmd_help (core, help_msg_afvb);\n\t\tbreak;\n\tcase 's':\n\t\tr_core_cmd_help (core, help_msg_afvs);\n\t\tbreak;\n\tcase 'r':\n\t\tr_core_cmd_help (core, help_msg_afvr);\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_afv);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"See afv?, afvb?, afvr? and afvs?\\n\");\n\t}\n}\n\nstatic void var_accesses_list(RAnal *a, RAnalFunction *fcn, int delta, const char *typestr) {\n\tconst char *var_local = sdb_fmt (\"var.0x%\"PFMT64x\".%d.%d.%s\",\n\t\t\tfcn->addr, 1, delta, typestr);\n\tconst char *xss = sdb_const_get (a->sdb_fcns, var_local, 0);\n\tif (xss && *xss) {\n\t\tr_cons_printf (\"%s\\n\", xss);\n\t} else {\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic void list_vars(RCore *core, RAnalFunction *fcn, int type, const char *name) {\n\tRAnalVar *var;\n\tRListIter *iter;\n\tRList *list = r_anal_var_list (core->anal, fcn, 0);\n\tif (type == '*') {\n\t\tconst char *bp = r_reg_get_name (core->anal->reg, R_REG_NAME_BP);\n\t\tr_cons_printf (\"f-fcnvar*\\n\");\n\t\tr_list_foreach (list, iter, var) {\n\t\t\tr_cons_printf (\"f fcnvar.%s @ %s%s%d\\n\", var->name, bp,\n\t\t\t\tvar->delta>=0? \"+\":\"\", var->delta);\n\t\t}\n\t\treturn;\n\t}\n\tif (type != 'W' && type != 'R') {\n\t\treturn;\n\t}\n\tconst char *typestr = type == 'R'?\"reads\":\"writes\";\n\tr_list_foreach (list, iter, var) {\n\t\tr_cons_printf (\"%10s  \", var->name);\n\t\tvar_accesses_list (core->anal, fcn, var->delta, typestr);\n\t}\n}\n\nstatic int cmd_an(RCore *core, bool use_json, const char *name)\n{\n\tut64 off = core->offset;\n\tRAnalOp op;\n\tchar *q = NULL;\n\tut64 tgt_addr = UT64_MAX;\n\n\tif (use_json) {\n\t\tr_cons_print (\"[\");\n\t}\n\n\tr_anal_op (core->anal, &op, off,\n\t\t\tcore->block + off - core->offset, 32, R_ANAL_OP_MASK_ALL);\n\n\ttgt_addr = op.jump != UT64_MAX ? op.jump : op.ptr;\n\tif (op.var) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, off, 0);\n\t\tif (fcn) {\n\t\t\tRAnalVar *bar = r_anal_var_get_byname (core->anal, fcn, op.var->name);\n\t\t\tif (!bar) {\n\t\t\t\tbar = r_anal_var_get_byname (core->anal, fcn, op.var->name);\n\t\t\t\tif (!bar) {\n\t\t\t\t\tbar = r_anal_var_get_byname (core->anal, fcn, op.var->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bar) {\n\t\t\t\tif (name) {\n\t\t\t\t\tr_anal_var_rename (core->anal, fcn->addr, bar->scope,\n\t\t\t\t\t\t\t\t\tbar->kind, bar->name, name);\n\t\t\t\t} else if (!use_json) {\n\t\t\t\t\tr_cons_println (bar->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"var\\\",\\\"name\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\t\tbar->name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot find variable\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot find function\\n\");\n\t\t}\n\t} else if (tgt_addr != UT64_MAX) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, tgt_addr, R_ANAL_FCN_TYPE_NULL);\n\t\tRFlagItem *f = r_flag_get_i (core->flags, tgt_addr);\n\t\tif (fcn) {\n\t\t\tif (name) {\n\t\t\t\tq = r_str_newf (\"afn %s 0x%\"PFMT64x, name, tgt_addr);\n\t\t\t} else if (!use_json) {\n\t\t\t\tr_cons_println (fcn->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"function\\\",\\\"name\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\tfcn->name);\n\t\t\t}\n\t\t} else if (f) {\n\t\t\tif (name) {\n\t\t\t\tq = r_str_newf (\"fr %s %s\", f->name, name);\n\t\t\t} else if (!use_json) {\n\t\t\t\tr_cons_println (f->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"flag\\\",\\\"name\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\tf->name);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name) {\n\t\t\t\tq = r_str_newf (\"f %s @ 0x%\"PFMT64x, name, tgt_addr);\n\t\t\t} else if (!use_json) {\n\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", tgt_addr);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"address\\\",\\\"offset\\\":\"\n\t\t\t\t\t\t\t   \"%\" PFMT64d \"}\", tgt_addr);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (use_json) {\n\t\tr_cons_print (\"]\\n\");\n\t}\n\n\tif (q) {\n\t\tr_core_cmd0 (core, q);\n\t\tfree (q);\n\t}\n\tr_anal_op_fini (&op);\n\treturn 0;\n}\n\nstatic int var_cmd(RCore *core, const char *str) {\n\tchar *p, *ostr;\n\tint delta, type = *str, res = true;\n\tRAnalVar *v1;\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tostr = p = NULL;\n\tif (!str[0]) {\n\t\t// \"afv\"\n\t\tif (fcn) {\n\t\t\tr_core_cmd0 (core, \"afvs\");\n\t\t\tr_core_cmd0 (core, \"afvb\");\n\t\t\tr_core_cmd0 (core, \"afvr\");\n\t\t\treturn true;\n\t\t}\n\t\teprintf (\"Cannot find function\\n\");\n\t\treturn false;\n\t}\n\tif (str[0] == 'j') {\n\t\t// \"afvj\"\n\t\tif (fcn) {\n\t\t\tr_cons_printf (\"{\\\"sp\\\":\");\n\t\t\tr_core_cmd0 (core, \"afvsj\");\n\t\t\tr_cons_printf (\",\\\"bp\\\":\");\n\t\t\tr_core_cmd0 (core, \"afvbj\");\n\t\t\tr_cons_printf (\",\\\"reg\\\":\");\n\t\t\tr_core_cmd0 (core, \"afvrj\");\n\t\t\tr_cons_printf (\"}\\n\");\n\t\t\treturn true;\n\t\t}\n\t\teprintf (\"Cannot find function\\n\");\n\t\treturn false;\n\t}\n\tif (!str[0] || str[1] == '?'|| str[0] == '?') {\n\t\tvar_help (core, *str);\n\t\treturn res;\n\t}\n\tif (!fcn) {\n\t\teprintf (\"Cannot find function in 0x%08\"PFMT64x\"\\n\", core->offset);\n\t\treturn false;\n\t}\n\tostr = p = strdup (str);\n\t/* Variable access CFvs = set fun var */\n\tswitch (str[0]) {\n\tcase '-':\n\t\t// \"afv\"\n\t\tif (fcn) {\n\t\t\tr_core_cmdf (core, \"afvs-%s\", str + 1);\n\t\t\tr_core_cmdf (core, \"afvb-%s\", str + 1);\n\t\t\tr_core_cmdf (core, \"afvr-%s\", str + 1);\n\t\t\treturn true;\n\t\t}\n\t\teprintf (\"Cannot find function\\n\");\n\t\treturn false;\n\tcase 'R': // \"afvR\"\n\tcase 'W': // \"afvW\"\n\tcase '*': // \"afv*\"\n\t\tlist_vars (core, fcn, str[0], str + 1);\n\t\tbreak;\n\tcase 'a': // \"afva\"\n\t\tr_anal_var_delete_all (core->anal, fcn->addr, R_ANAL_VAR_KIND_REG);\n\t\tr_anal_var_delete_all (core->anal, fcn->addr, R_ANAL_VAR_KIND_BPV);\n\t\tr_anal_var_delete_all (core->anal, fcn->addr, R_ANAL_VAR_KIND_SPV);\n\t\tfcn_callconv (core, fcn);\n\t\tfree (p);\n\t\treturn true;\n\tcase 'n':\n\t\tif (str[1]) { // \"afvn\"\n\t\t\tchar *old_name = r_str_trim_head (strchr (ostr, ' '));\n\t\t\tif (!old_name) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchar *new_name = strchr (old_name, ' ');\n\t\t\tif (!new_name) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t*new_name++ = 0;\n\t\t\tr_str_trim (new_name);\n\t\t\tv1 = r_anal_var_get_byname (core->anal, fcn, old_name);\n\t\t\tif (v1) {\n\t\t\t\tr_anal_var_rename (core->anal, fcn->addr, R_ANAL_VAR_SCOPE_LOCAL,\n\t\t\t\t\t\tv1->kind, old_name, new_name);\n\t\t\t\tr_anal_var_free (v1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Cant find var by name\\n\");\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t} else {\n\t\t\tRListIter *iter;\n\t\t\tRAnalVar *v;\n\t\t\tRList *list = r_anal_var_list (core->anal, fcn, 0);\n\t\t\tr_list_foreach (list, iter, v) {\n\t\t\t\tr_cons_printf (\"%s\\n\", v->name);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase 'd': // \"afvd\"\n\t\tif (str[1]) {\n\t\t\tp = r_str_trim (strchr (ostr, ' '));\n\t\t\tif (!p) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tv1 = r_anal_var_get_byname (core->anal, fcn, p);\n\t\t\tif (!v1) {\n\t\t\t\tfree (ostr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_anal_var_display (core->anal, v1->delta, v1->kind, v1->type);\n\t\t\tr_anal_var_free (v1);\n\t\t\tfree (ostr);\n\t\t} else {\n\t\t\tRListIter *iter;\n\t\t\tRAnalVar *p;\n\t\t\tRList *list = r_anal_var_list (core->anal, fcn, 0);\n\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\tchar *a = r_core_cmd_strf (core, \".afvd %s\", p->name);\n\t\t\t\tif ((a && !*a) || !a) {\n\t\t\t\t\tfree (a);\n\t\t\t\t\ta = strdup (\"\\n\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"var %s = %s\", p->name, a);\n\t\t\t\tfree (a);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t\t// args\n\t\t\tlist = r_anal_var_list (core->anal, fcn, 1);\n\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\tchar *a = r_core_cmd_strf (core, \".afvd %s\", p->name);\n\t\t\t\tif ((a && !*a) || !a) {\n\t\t\t\t\tfree (a);\n\t\t\t\t\ta = strdup (\"\\n\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"arg %s = %s\", p->name, a);\n\t\t\t\tfree (a);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\treturn true;\n\tcase 't':{ // \"afvt\"\n\t\tp = strchr (ostr, ' ');\n\t\tif (!p++) {\n\t\t\tfree (ostr);\n\t\t\treturn false;\n\t\t}\n\n\t\tchar *type = strchr (p, ' ');\n\t\tif (!type) {\n\t\t\tfree (ostr);\n\t\t\treturn false;\n\t\t}\n\t\t*type++ = 0;\n\t\tv1 = r_anal_var_get_byname (core->anal, fcn, p);\n\t\tif (!v1) {\n\t\t\teprintf (\"Cant find get by name %s\\n\", p);\n\t\t\tfree (ostr);\n\t\t\treturn false;\n\t\t}\n\t\tr_anal_var_retype (core->anal, fcn->addr,\n\t\t\tR_ANAL_VAR_SCOPE_LOCAL, -1, v1->kind, type, -1, p);\n\t\tr_anal_var_free (v1);\n\t\tfree (ostr);\n\t\treturn true;\n\n\t}\n\t}\n\tswitch (str[1]) {\n\tcase '\\0':\n\tcase '*':\n\tcase 'j':\n\t\tr_anal_var_list_show (core->anal, fcn, type, str[1]);\n\t\tbreak;\n\tcase '.':\n\t\tr_anal_var_list_show (core->anal, fcn, core->offset, 0);\n\t\tbreak;\n\tcase '-': // \"afv[bsr]-\"\n\t\tif (str[2] == '*') {\n\t\t\tr_anal_var_delete_all (core->anal, fcn->addr, type);\n\t\t} else {\n\t\t\tif (IS_DIGIT (str[2])) {\n\t\t\t\tr_anal_var_delete (core->anal, fcn->addr,\n\t\t\t\t\t\ttype, 1, (int)r_num_math (core->num, str + 1));\n\t\t\t} else {\n\t\t\t\tchar *name = r_str_trim ( strdup (str + 2));\n\t\t\t\tr_anal_var_delete_byname (core->anal, fcn, type, name);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\teprintf (\"This command is deprecated, use afvd instead\\n\");\n\t\tbreak;\n\tcase 't':\n\t\teprintf (\"This command is deprecated use afvt instead\\n\");\n\t\tbreak;\n\tcase 's':\n\tcase 'g':\n\t\tif (str[2] != '\\0') {\n\t\t\tint rw = 0; // 0 = read, 1 = write\n\t\t\tRAnalVar *var = r_anal_var_get (core->anal, fcn->addr,\n\t\t\t\t\t\t\t(char)type, atoi (str + 2), R_ANAL_VAR_SCOPE_LOCAL);\n\t\t\tif (!var) {\n\t\t\t\teprintf (\"Cannot find variable in: '%s'\\n\", str);\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (var != NULL) {\n\t\t\t\tint scope = (str[1] == 'g')? 0: 1;\n\t\t\t\tr_anal_var_access (core->anal, fcn->addr, (char)type,\n\t\t\t\t\t\tscope, atoi (str + 2), rw, core->offset);\n\t\t\t\tr_anal_var_free (var);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Missing argument\\n\");\n\t\t}\n\t\tbreak;\n\tcase ' ': {\n\t\tconst char *name;\n\t\tchar *vartype;\n\t\tint size = 4;\n\t\tint scope = 1;\n\t\t\tfor (str++; *str == ' ';) str++;\n\t\tp = strchr (str, ' ');\n\t\tif (!p) {\n\t\t\tvar_help (core, type);\n\t\t\tbreak;\n\t\t}\n\t\t*p++ = 0;\n\t\tif (type == 'r') { //registers\n\t\t\tRRegItem *i = r_reg_get (core->anal->reg, str, -1);\n\t\t\tif (!i) {\n\t\t\t\teprintf (\"Register not found\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelta = i->index;\n\t\t} else {\n\t\t\tdelta = r_num_math (core->num, str);\n\t\t}\n\t\tname = p;\n\t\tvartype = strchr (name, ' ');\n\t\tif (vartype) {\n\t\t\t*vartype++ = 0;\n\t\t\tr_anal_var_add (core->anal, fcn->addr,\n\t\t\t\t\tscope, delta, type,\n\t\t\t\t\tvartype, size, name);\n\t\t} else {\n\t\t\teprintf (\"Missing name\\n\");\n\t\t}\n\t\t}\n\t\tbreak;\n\t};\n\n\tfree (ostr);\n\treturn res;\n}\n\nstatic void print_trampolines(RCore *core, ut64 a, ut64 b, size_t element_size) {\n\tint i;\n\tfor (i = 0; i < core->blocksize; i += element_size) {\n\t\tut32 n;\n\t\tmemcpy (&n, core->block + i, sizeof (ut32));\n\t\tif (n >= a && n <= b) {\n\t\t\tif (element_size == 4) {\n\t\t\t\tr_cons_printf (\"f trampoline.%x @ 0x%\" PFMT64x \"\\n\", n, core->offset + i);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"f trampoline.%\" PFMT64x \" @ 0x%\" PFMT64x \"\\n\", n, core->offset + i);\n\t\t\t}\n\t\t\tr_cons_printf (\"Cd %u @ 0x%\" PFMT64x \":%u\\n\", element_size, core->offset + i, element_size);\n\t\t\t// TODO: add data xrefs\n\t\t}\n\t}\n}\n\nstatic void cmd_anal_trampoline(RCore *core, const char *input) {\n\tint bits = r_config_get_i (core->config, \"asm.bits\");\n\tchar *p, *inp = strdup (input);\n\tp = strchr (inp, ' ');\n\tif (p) {\n\t\t*p = 0;\n\t}\n\tut64 a = r_num_math (core->num, inp);\n\tut64 b = p? r_num_math (core->num, p + 1): 0;\n\tfree (inp);\n\n\tswitch (bits) {\n\tcase 32:\n\t\tprint_trampolines (core, a, b, 4);\n\t\tbreak;\n\tcase 64:\n\t\tprint_trampolines (core, a, b, 8);\n\t\tbreak;\n\t}\n}\n\nR_API char *cmd_syscall_dostr(RCore *core, int n) {\n\tchar *res = NULL;\n\tint i;\n\tchar str[64];\n\tif (n == -1) {\n\t\tn = (int)r_debug_reg_get (core->dbg, \"oeax\");\n\t\tif (!n || n == -1) {\n\t\t\tconst char *a0 = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\t\t\tn = (int)r_debug_reg_get (core->dbg, a0);\n\t\t}\n\t}\n\tRSyscallItem *item = r_syscall_get (core->anal->syscall, n, -1);\n\tif (!item) {\n\t\tres = r_str_appendf (res, \"%d = unknown ()\", n);\n\t\treturn res;\n\t}\n\tres = r_str_appendf (res, \"%d = %s (\", item->num, item->name);\n\t// TODO: move this to r_syscall\n\t//TODO replace the hardcoded CC with the sdb ones\n\tfor (i = 0; i < item->args; i++) {\n\t\t// XXX this is a hack to make syscall args work on x86-32 and x86-64\n\t\t// we need to shift sn first.. which is bad, but needs to be redesigned\n\t\tint regidx = i;\n\t\tif (core->assembler->bits == 32) {\n\t\t\tregidx++;\n\t\t}\n\t\tut64 arg = r_debug_arg_get (core->dbg, R_ANAL_CC_TYPE_FASTCALL, regidx);\n\t\t//r_cons_printf (\"(%d:0x%\"PFMT64x\")\\n\", i, arg);\n\t\tif (item->sargs) {\n\t\t\tswitch (item->sargs[i]) {\n\t\t\tcase 'p': // pointer\n\t\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x \"\", arg);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tres = r_str_appendf (res, \"%\" PFMT64d \"\", arg);\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tmemset (str, 0, sizeof (str));\n\t\t\t\tr_io_read_at (core->io, arg, (ut8 *)str, sizeof (str) - 1);\n\t\t\t\tr_str_filter (str, strlen (str));\n\t\t\t\tres = r_str_appendf (res, \"\\\"%s\\\"\", str);\n\t\t\t\tbreak;\n\t\t\tcase 'Z': {\n\t\t\t\t//TODO replace the hardcoded CC with the sdb ones\n\t\t\t\tut64 len = r_debug_arg_get (core->dbg, R_ANAL_CC_TYPE_FASTCALL, i + 2);\n\t\t\t\tlen = R_MIN (len + 1, sizeof (str) - 1);\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tlen = 16; // override default\n\t\t\t\t}\n\t\t\t\t(void)r_io_read_at (core->io, arg, (ut8 *)str, len);\n\t\t\t\tstr[len] = 0;\n\t\t\t\tr_str_filter (str, -1);\n\t\t\t\tres = r_str_appendf (res, \"\\\"%s\\\"\", str);\n\t\t\t} break;\n\t\t\tdefault:\n\t\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x \"\", arg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tres = r_str_appendf (res, \"0x%08\" PFMT64x \"\", arg);\n\t\t}\n\t\tif (i + 1 < item->args) {\n\t\t\tres = r_str_appendf (res, \", \");\n\t\t}\n\t}\n\tr_syscall_item_free (item);\n\tres = r_str_appendf (res, \")\");\n\treturn res;\n}\n\nstatic void cmd_syscall_do(RCore *core, int n) {\n\tchar *msg = cmd_syscall_dostr (core, n);\n\tif (msg) {\n\t\tr_cons_println (msg);\n\t\tfree (msg);\n\t}\n}\n\nstatic void core_anal_bytes(RCore *core, const ut8 *buf, int len, int nops, int fmt) {\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tbool iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tbool romem = r_config_get_i (core->config, \"esil.romem\");\n\tbool stats = r_config_get_i (core->config, \"esil.stats\");\n\tbool be = core->print->big_endian;\n\tbool use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tcore->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");\n\tint ret, i, j, idx, size;\n\tconst char *color = \"\";\n\tconst char *esilstr;\n\tconst char *opexstr;\n\tRAnalHint *hint;\n\tRAnalEsil *esil = NULL;\n\tRAsmOp asmop;\n\tRAnalOp op;\n\tut64 addr;\n\tbool isFirst = true;\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tint totalsize = 0;\n\n\t// Variables required for setting up ESIL to REIL conversion\n\tif (use_color) {\n\t\tcolor = core->cons->pal.label;\n\t}\n\tswitch (fmt) {\n\tcase 'j':\n\t\tr_cons_printf (\"[\");\n\t\tbreak;\n\tcase 'r':\n\t\t// Setup for ESIL to REIL conversion\n\t\tesil = r_anal_esil_new (stacksize, iotrap, addrsize);\n\t\tif (!esil) {\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_to_reil_setup (esil, core->anal, romem, stats);\n\t\tr_anal_esil_set_pc (esil, core->offset);\n\t\tbreak;\n\t}\n\tfor (i = idx = ret = 0; idx < len && (!nops || (nops && i < nops)); i++, idx += ret) {\n\t\taddr = core->offset + idx;\n\t\t// TODO: use more anal hints\n\t\thint = r_anal_hint_get (core->anal, addr);\n\t\tr_asm_set_pc (core->assembler, addr);\n\t\tret = r_asm_disassemble (core->assembler, &asmop, buf + idx, len - idx);\n\t\tret = r_anal_op (core->anal, &op, core->offset + idx, buf + idx, len - idx, R_ANAL_OP_MASK_ALL);\n\t\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\topexstr = R_STRBUF_SAFEGET (&op.opex);\n\t\tchar *mnem = strdup (asmop.buf_asm);\n\t\tchar *sp = strchr (mnem, ' ');\n\t\tif (sp) {\n\t\t\t*sp = 0;\n\t\t}\n\t\tif (ret < 1 && fmt != 'd') {\n\t\t\teprintf (\"Oops at 0x%08\" PFMT64x \" (\", core->offset + idx);\n\t\t\tfor (i = idx, j = 0; i < core->blocksize && j < 3; ++i, ++j) {\n\t\t\t\teprintf (\"%02x \", buf[i]);\n\t\t\t}\n\t\t\teprintf (\"...)\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tsize = (hint && hint->size)? hint->size: op.size;\n\t\tif (fmt == 'd') {\n\t\t\tchar *opname = strdup (asmop.buf_asm);\n\t\t\tr_str_split (opname, ' ');\n\t\t\tchar *d = r_asm_describe (core->assembler, opname);\n\t\t\tif (d && *d) {\n\t\t\t\tr_cons_printf (\"%s: %s\\n\", opname, d);\n\t\t\t\tfree (d);\n\t\t\t} else {\n\t\t\t\teprintf (\"Unknown opcode\\n\");\n\t\t\t}\n\t\t\tfree (opname);\n\t\t} else if (fmt == 'e') {\n\t\t\tif (*esilstr) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \" %s\\n\", color, core->offset + idx, esilstr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \" %s\\n\", core->offset + idx, esilstr);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fmt == 's') {\n\t\t\ttotalsize += op.size;\n\t\t} else if (fmt == 'r') {\n\t\t\tif (*esilstr) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \"\\n\", color, core->offset + idx);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\t\t}\n\t\t\t\tr_anal_esil_parse (esil, esilstr);\n\t\t\t\tr_anal_esil_dumpstack (esil);\n\t\t\t\tr_anal_esil_stack_free (esil);\n\t\t\t}\n\t\t} else if (fmt == 'j') {\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t} else {\n\t\t\t\tr_cons_print (\",\");\n\t\t\t}\n\t\t\tr_cons_printf (\"{\\\"opcode\\\":\\\"%s\\\",\", asmop.buf_asm);\n\t\t\t{\n\t\t\t\tchar strsub[128] = { 0 };\n\t\t\t\t// pc+33\n\t\t\t\tr_parse_varsub (core->parser, NULL,\n\t\t\t\t\tcore->offset + idx,\n\t\t\t\t\tasmop.size, asmop.buf_asm,\n\t\t\t\t\tstrsub, sizeof (strsub));\n\t\t\t\t{\n\t\t\t\t\tut64 killme = UT64_MAX;\n\t\t\t\t\tif (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {\n\t\t\t\t\t\tcore->parser->relsub_addr = killme;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 0x33->sym.xx\n\t\t\t\tchar *p = strdup (strsub);\n\t\t\t\tr_parse_filter (core->parser, core->flags, p,\n\t\t\t\t\t\tstrsub, sizeof (strsub), be);\n\t\t\t\tfree (p);\n\t\t\t\tr_cons_printf (\"\\\"disasm\\\":\\\"%s\\\",\", strsub);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"mnemonic\\\":\\\"%s\\\",\", mnem);\n\t\t\tif (hint && hint->opcode) {\n\t\t\t\tr_cons_printf (\"\\\"ophint\\\":\\\"%s\\\",\", hint->opcode);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"prefix\\\":%\" PFMT64d \",\", op.prefix);\n\t\t\tr_cons_printf (\"\\\"id\\\":%d,\", op.id);\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tr_cons_printf (\"\\\"opex\\\":%s,\", opexstr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"addr\\\":%\" PFMT64d \",\", core->offset + idx);\n\t\t\tr_cons_printf (\"\\\"bytes\\\":\\\"\");\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[j + idx]);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\",\");\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"val\\\": %\" PFMT64d \",\", op.val);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"ptr\\\": %\" PFMT64d \",\", op.ptr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"size\\\": %d,\", size);\n\t\t\tr_cons_printf (\"\\\"type\\\": \\\"%s\\\",\",\n\t\t\t\tr_anal_optype_to_string (op.type));\n\t\t\tif (op.reg) {\n\t\t\t\tr_cons_printf (\"\\\"reg\\\": \\\"%s\\\",\", op.reg);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tr_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", hint->esil);\n\t\t\t} else if (*esilstr) {\n\t\t\t\tr_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"jump\\\":%\" PFMT64d \",\", op.jump);\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.refptr != -1) {\n\t\t\t\tr_cons_printf (\"\\\"refptr\\\":%d,\", op.refptr);\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"fail\\\":%\" PFMT64d \",\", op.fail);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"cycles\\\":%d,\", op.cycles);\n\t\t\tif (op.failcycles) {\n\t\t\t\tr_cons_printf (\"\\\"failcycles\\\":%d,\", op.failcycles);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"delay\\\":%d,\", op.delay);\n\t\t\t{\n\t\t\t\tconst char *p = r_anal_stackop_tostring (op.stackop);\n\t\t\t\tif (p && *p && strcmp (p, \"null\"))\n\t\t\t\t\tr_cons_printf (\"\\\"stack\\\":\\\"%s\\\",\", p);\n\t\t\t}\n\t\t\tif (op.stackptr) {\n\t\t\t\tr_cons_printf (\"\\\"stackptr\\\":%d,\", op.stackptr);\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)\n\t\t\t\t\t? r_anal_cond_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tr_cons_printf (\"\\\"cond\\\":\\\"%s\\\",\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"family\\\":\\\"%s\\\"}\", r_anal_op_family_to_string (op.family));\n\t\t} else {\n#define printline(k, fmt, arg)\\\n\t{ \\\n\t\tif (use_color)\\\n\t\t\tr_cons_printf (\"%s%s: \" Color_RESET, color, k);\\\n\t\telse\\\n\t\t\tr_cons_printf (\"%s: \", k);\\\n\t\tif (fmt) r_cons_printf (fmt, arg);\\\n\t}\n\t\t\tprintline (\"address\", \"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\tprintline (\"opcode\", \"%s\\n\", asmop.buf_asm);\n\t\t\tprintline (\"mnemonic\", \"%s\\n\", mnem);\n\t\t\tif (hint) {\n\t\t\t\tif (hint->opcode) {\n\t\t\t\t\tprintline (\"ophint\", \"%s\\n\", hint->opcode);\n\t\t\t\t}\n#if 0\n\t\t\t\t// addr should not override core->offset + idx.. its silly\n\t\t\t\tif (hint->addr != UT64_MAX) {\n\t\t\t\t\tprintline (\"addr\", \"0x%08\" PFMT64x \"\\n\", (hint->addr + idx));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tprintline (\"prefix\", \"%\" PFMT64d \"\\n\", op.prefix);\n\t\t\tprintline (\"id\", \"%d\\n\", op.id);\n#if 0\n// no opex here to avoid lot of tests broken..and having json in here is not much useful imho\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tprintline (\"opex\", \"%s\\n\", opexstr);\n\t\t\t}\n#endif\n\t\t\tprintline (\"bytes\", NULL, 0);\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[j + idx]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tif (op.val != UT64_MAX)\n\t\t\t\tprintline (\"val\", \"0x%08\" PFMT64x \"\\n\", op.val);\n\t\t\tif (op.ptr != UT64_MAX)\n\t\t\t\tprintline (\"ptr\", \"0x%08\" PFMT64x \"\\n\", op.ptr);\n\t\t\tif (op.refptr != -1)\n\t\t\t\tprintline (\"refptr\", \"%d\\n\", op.refptr);\n\t\t\tprintline (\"size\", \"%d\\n\", size);\n\t\t\tprintline (\"type\", \"%s\\n\", r_anal_optype_to_string (op.type));\n\t\t\t{\n\t\t\t\tconst char *t2 = r_anal_optype_to_string (op.type2);\n\t\t\t\tif (t2 && strcmp (t2, \"null\")) {\n\t\t\t\t\tprintline (\"type2\", \"%s\\n\", t2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op.reg) {\n\t\t\t\tprintline (\"reg\", \"%s\\n\", op.reg);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", hint->esil);\n\t\t\t} else if (*esilstr) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tprintline (\"jump\", \"0x%08\" PFMT64x \"\\n\", op.jump);\n\t\t\t}\n\t\t\tif (op.direction != 0) {\n\t\t\t\tconst char * dir = op.direction == 1 ? \"read\"\n\t\t\t\t\t: op.direction == 2 ? \"write\"\n\t\t\t\t\t: op.direction == 4 ? \"exec\"\n\t\t\t\t\t: op.direction == 8 ? \"ref\": \"none\";\n\t\t\t\tprintline (\"direction\", \"%s\\n\", dir);\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tprintline (\"fail\", \"0x%08\" PFMT64x \"\\n\", op.fail);\n\t\t\t}\n\t\t\tif (op.delay) {\n\t\t\t\tprintline (\"delay\", \"%d\\n\", op.delay);\n\t\t\t}\n\t\t\tprintline (\"stack\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)?  r_anal_cond_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tprintline (\"cond\", \"%s\\n\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintline (\"family\", \"%s\\n\", r_anal_op_family_to_string (op.family));\n\t\t\tprintline (\"stackop\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\tif (op.stackptr) {\n\t\t\t\tprintline (\"stackptr\", \"%\"PFMT64d\"\\n\", op.stackptr);\n\t\t\t}\n\t\t}\n\t\t//r_cons_printf (\"false: 0x%08\"PFMT64x\"\\n\", core->offset+idx);\n\t\t//free (hint);\n\t\tfree (mnem);\n\t\tr_anal_hint_free (hint);\n\t}\n\tif (fmt == 'j') {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (fmt == 's') {\n\t\tr_cons_printf (\"%d\\n\", totalsize);\n\t}\n\tr_anal_esil_free (esil);\n}\n\nstatic int bb_cmp(const void *a, const void *b) {\n\tconst RAnalBlock *ba = a;\n\tconst RAnalBlock *bb = b;\n\treturn ba->addr - bb->addr;\n}\n\nstatic int anal_fcn_list_bb(RCore *core, const char *input, bool one) {\n\tRDebugTracepoint *tp = NULL;\n\tRListIter *iter;\n\tRAnalBlock *b;\n\tint mode = 0;\n\tut64 addr, bbaddr = UT64_MAX;\n\tbool firstItem = true;\n\n\tif (*input == '.') {\n\t\tone = true;\n\t\tinput++;\n\t}\n\tif (*input) {\n\t\tmode = *input;\n\t\tinput++;\n\t}\n\tif (*input == '.') {\n\t\tone = true;\n\t\tinput++;\n\t}\n\tif (input && *input) {\n\t\taddr = bbaddr = r_num_math (core->num, input);\n\t} else {\n\t\taddr = core->offset;\n\t}\n\tif (one) {\n\t\tbbaddr = addr;\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\tswitch (mode) {\n\tcase 'j':\n\t\tr_cons_printf (\"[\");\n\t\tbreak;\n\tcase '*':\n\t\tr_cons_printf (\"fs blocks\\n\");\n\t\tbreak;\n\t}\n\tr_list_sort (fcn->bbs, bb_cmp);\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tif (one) {\n\t\t\tif (bbaddr != UT64_MAX && (bbaddr < b->addr || bbaddr >= (b->addr + b->size))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (mode) {\n\t\tcase 'r':\n\t\t\tif (b->jump == UT64_MAX) {\n\t\t\t\tut64 retaddr = b->addr;\n\t\t\t\tif (b->op_pos) {\n\t\t\t\t\tretaddr += b->op_pos[b->ninstr - 2];\n\t\t\t\t}\n\t\t\t\tif (!strcmp (input, \"*\")) {\n\t\t\t\t\tr_cons_printf (\"db 0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t} else if (!strcmp (input, \"-*\")) {\n\t\t\t\t\tr_cons_printf (\"db-0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", retaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tr_cons_printf (\"f bb.%05\" PFMT64x \" = 0x%08\" PFMT64x \"\\n\",\n\t\t\t\tb->addr & 0xFFFFF, b->addr);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", b->addr);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\t//r_cons_printf (\"%\" PFMT64d \"%s\", b->addr, iter->n? \",\": \"\");\n\t\t\t{\n\t\t\tRListIter *iter2;\n\t\t\tRAnalBlock *b2;\n\t\t\tint inputs = 0;\n\t\t\tint outputs = 0;\n\t\t\tr_list_foreach (fcn->bbs, iter2, b2) {\n\t\t\t\tif (b2->jump == b->addr) {\n\t\t\t\t\tinputs++;\n\t\t\t\t}\n\t\t\t\tif (b2->fail == b->addr) {\n\t\t\t\t\tinputs++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\toutputs ++;\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\toutputs ++;\n\t\t\t}\n\t\t\tr_cons_printf (\"%s{\", firstItem? \"\": \",\");\n\t\t\tfirstItem = false;\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"jump\\\":%\"PFMT64d\",\", b->jump);\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"fail\\\":%\"PFMT64d\",\", b->fail);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"addr\\\":%\" PFMT64d \",\\\"size\\\":%d,\\\"inputs\\\":%d,\\\"outputs\\\":%d,\\\"ninstr\\\":%d,\\\"traced\\\":%s}\",\n\t\t\t\tb->addr, b->size, inputs, outputs, b->ninstr, r_str_bool (b->traced));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t{\n\t\t\tRListIter *iter2;\n\t\t\tRAnalBlock *b2;\n\t\t\tint inputs = 0;\n\t\t\tint outputs = 0;\n\t\t\tr_list_foreach (fcn->bbs, iter2, b2) {\n\t\t\t\tif (b2->jump == b->addr) {\n\t\t\t\t\tinputs++;\n\t\t\t\t}\n\t\t\t\tif (b2->fail == b->addr) {\n\t\t\t\t\tinputs++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\toutputs ++;\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\toutputs ++;\n\t\t\t}\n\t\t\tfirstItem = false;\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"jump: 0x%08\"PFMT64x\"\\n\", b->jump);\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"fail: 0x%08\"PFMT64x\"\\n\", b->fail);\n\t\t\t}\n\t\t\tr_cons_printf (\"addr: 0x%08\"PFMT64x\"\\nsize: %d\\ninputs: %d\\noutputs: %d\\nninstr: %d\\ntraced: %s\\n\",\n\t\t\t\tb->addr, b->size, inputs, outputs, b->ninstr, r_str_bool (b->traced));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttp = r_debug_trace_get (core->dbg, b->addr);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %02X:%04X %d\",\n\t\t\t\tb->addr, b->addr + b->size,\n\t\t\t\ttp? tp->times: 0, tp? tp->count: 0,\n\t\t\t\tb->size);\n\t\t\tif (b->jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" j 0x%08\" PFMT64x, b->jump);\n\t\t\t}\n\t\t\tif (b->fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" f 0x%08\" PFMT64x, b->fail);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_printf (\"]\\n\");\n\t}\n\treturn true;\n}\n\nstatic bool anal_bb_edge (RCore *core, const char *input) {\n\t// \"afbe\" switch-bb-addr case-bb-addr\n\tchar *arg = strdup (r_str_trim_ro(input));\n\tchar *sp = strchr (arg, ' ');\n\tif (sp) {\n\t\t*sp++ = 0;\n\t\tut64 sw_at = r_num_math (core->num, arg);\n\t\tut64 cs_at = r_num_math (core->num, sp);\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, sw_at, 0);\n\t\tif (fcn) {\n\t\t\tRAnalBlock *bb;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\tif (sw_at >= bb->addr && sw_at < (bb->addr + bb->size)) {\n\t\t\t\t\tif (!bb->switch_op) {\n\t\t\t\t\t\tbb->switch_op = r_anal_switch_op_new (\n\t\t\t\t\t\t\tsw_at, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tr_anal_switch_op_add_case (bb->switch_op, cs_at, 0, cs_at);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (arg);\n\t\t\treturn true;\n\t\t}\n\t}\n\tfree (arg);\n\treturn false;\n}\n\nstatic bool anal_fcn_del_bb(RCore *core, const char *input) {\n\tut64 addr = r_num_math (core->num, input);\n\tif (!addr) {\n\t\taddr = core->offset;\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tif (!strcmp (input, \"*\")) {\n\t\t\tr_list_free (fcn->bbs);\n\t\t\tfcn->bbs = NULL;\n\t\t} else {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tif (b->addr == addr) {\n\t\t\t\t\tr_list_delete (fcn->bbs, iter);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\teprintf (\"Cannot find basic block\\n\");\n\t\t}\n\t} else {\n\t\teprintf (\"Cannot find function\\n\");\n\t}\n\treturn false;\n}\n\nstatic int anal_fcn_add_bb(RCore *core, const char *input) {\n\t// fcn_addr bb_addr bb_size [jump] [fail]\n\tchar *ptr;\n\tconst char *ptr2 = NULL;\n\tut64 fcnaddr = -1LL, addr = -1LL;\n\tut64 size = 0LL;\n\tut64 jump = UT64_MAX;\n\tut64 fail = UT64_MAX;\n\tint type = R_ANAL_BB_TYPE_NULL;\n\tRAnalFunction *fcn = NULL;\n\tRAnalDiff *diff = NULL;\n\n\twhile (*input == ' ') input++;\n\tptr = strdup (input);\n\n\tswitch (r_str_word_set0 (ptr)) {\n\tcase 7:\n\t\tptr2 = r_str_word_get0 (ptr, 6);\n\t\tif (!(diff = r_anal_diff_new ())) {\n\t\t\teprintf (\"error: Cannot init RAnalDiff\\n\");\n\t\t\tfree (ptr);\n\t\t\treturn false;\n\t\t}\n\t\tif (ptr2[0] == 'm') {\n\t\t\tdiff->type = R_ANAL_DIFF_TYPE_MATCH;\n\t\t} else if (ptr2[0] == 'u') {\n\t\t\tdiff->type = R_ANAL_DIFF_TYPE_UNMATCH;\n\t\t}\n\tcase 6:\n\t\tptr2 = r_str_word_get0 (ptr, 5);\n\t\tif (strchr (ptr2, 'h')) {\n\t\t\ttype |= R_ANAL_BB_TYPE_HEAD;\n\t\t}\n\t\tif (strchr (ptr2, 'b')) {\n\t\t\ttype |= R_ANAL_BB_TYPE_BODY;\n\t\t}\n\t\tif (strchr (ptr2, 'l')) {\n\t\t\ttype |= R_ANAL_BB_TYPE_LAST;\n\t\t}\n\t\tif (strchr (ptr2, 'f')) {\n\t\t\ttype |= R_ANAL_BB_TYPE_FOOT;\n\t\t}\n\tcase 5: // get fail\n\t\tfail = r_num_math (core->num, r_str_word_get0 (ptr, 4));\n\tcase 4: // get jump\n\t\tjump = r_num_math (core->num, r_str_word_get0 (ptr, 3));\n\tcase 3: // get size\n\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 2));\n\tcase 2: // get addr\n\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\tcase 1: // get fcnaddr\n\t\tfcnaddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t}\n\tfcn = r_anal_get_fcn_in (core->anal, fcnaddr, 0);\n\tif (fcn) {\n\t\tint ret = r_anal_fcn_add_bb (core->anal, fcn, addr, size, jump, fail, type, diff);\n\t\tif (!ret) {\n\t\t\teprintf (\"Cannot add basic block\\n\");\n\t\t}\n\t} else {\n\t\teprintf (\"Cannot find function at 0x%\" PFMT64x \"\\n\", fcnaddr);\n\t}\n\tr_anal_diff_free (diff);\n\tfree (ptr);\n\treturn true;\n}\n\nstatic void r_core_anal_nofunclist  (RCore *core, const char *input) {\n\tint minlen = (int)(input[0]==' ') ? r_num_math (core->num, input + 1): 16;\n\tut64 code_size = r_num_get (core->num, \"$SS\");\n\tut64 base_addr = r_num_get (core->num, \"$S\");\n\tut64 chunk_size, chunk_offset, i;\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *b;\n\tchar* bitmap;\n\tint counter;\n\n\tif (minlen < 1) {\n\t\tminlen = 1;\n\t}\n\tif (code_size < 1) {\n\t\treturn;\n\t}\n\tbitmap = calloc (1, code_size+64);\n\tif (!bitmap) {\n\t\treturn;\n\t}\n\n\t// for each function\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t// for each basic block in the function\n\t\tr_list_foreach (fcn->bbs, iter2, b) {\n\t\t\t// if it is not withing range, continue\n\t\t\tif ((fcn->addr < base_addr) || (fcn->addr >= base_addr+code_size))\n\t\t\t\tcontinue;\n\t\t\t// otherwise mark each byte in the BB in the bitmap\n\t\t\tfor (counter = 0; counter < b->size; counter++) {\n\t\t\t\tbitmap[b->addr+counter-base_addr] = '=';\n\t\t\t}\n\t\t\t// finally, add a special marker to show the beginning of a\n\t\t\t// function\n\t\t\tbitmap[fcn->addr-base_addr] = 'F';\n\t\t}\n\t}\n\n\t// Now we print the list of memory regions that are not assigned to a function\n\tchunk_size = 0;\n\tchunk_offset = 0;\n\tfor (i = 0; i < code_size; i++) {\n\t\tif (bitmap[i]){\n\t\t\t// We only print a region is its size is bigger than 15 bytes\n\t\t\tif (chunk_size >= minlen){\n\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, base_addr+chunk_offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6d   %s\\n\", base_addr+chunk_offset, chunk_size, fcn->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6d\\n\", base_addr+chunk_offset, chunk_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\tchunk_size = 0;\n\t\t\tchunk_offset = i+1;\n\t\t\tcontinue;\n\t\t}\n\t\tchunk_size+=1;\n\t}\n\tif (chunk_size >= 16) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, base_addr+chunk_offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6d   %s\\n\", base_addr+chunk_offset, chunk_size, fcn->name);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %6d\\n\", base_addr+chunk_offset, chunk_size);\n\t\t}\n\t}\n\tfree(bitmap);\n}\n\nstatic void r_core_anal_fmap  (RCore *core, const char *input) {\n\tint show_color = r_config_get_i (core->config, \"scr.color\");\n\tint cols = r_config_get_i (core->config, \"hex.cols\") * 4;\n\tut64 code_size = r_num_get (core->num, \"$SS\");\n\tut64 base_addr = r_num_get (core->num, \"$S\");\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *b;\n\tchar* bitmap;\n\tint assigned;\n\tut64 i;\n\n\tif (code_size < 1) {\n\t\treturn;\n\t}\n\tbitmap = calloc (1, code_size+64);\n\tif (!bitmap) {\n\t\treturn;\n\t}\n\n\t// for each function\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t// for each basic block in the function\n\t\tr_list_foreach (fcn->bbs, iter2, b) {\n\t\t\t// if it is not within range, continue\n\t\t\tif ((fcn->addr < base_addr) || (fcn->addr >= base_addr+code_size))\n\t\t\t\tcontinue;\n\t\t\t// otherwise mark each byte in the BB in the bitmap\n\t\t\tint counter = 1;\n\t\t\tfor (counter = 0; counter < b->size; counter++) {\n\t\t\t\tbitmap[b->addr+counter-base_addr] = '=';\n\t\t\t}\n\t\t\tbitmap[fcn->addr-base_addr] = 'F';\n\t\t}\n\t}\n\t// print the bitmap\n\tassigned = 0;\n\tif (cols < 1) {\n\t\tcols = 1;\n\t}\n\tfor (i = 0; i < code_size; i += 1) {\n\t\tif (!(i % cols)) {\n\t\t\tr_cons_printf (\"\\n0x%08\"PFMT64x\"  \", base_addr+i);\n\t\t}\n\t\tif (bitmap[i]) {\n\t\t\tassigned++;\n\t\t}\n\t\tif (show_color) {\n\t\t\tif (bitmap[i]) {\n\t\t\t\tr_cons_printf (\"%s%c\\x1b[0m\", Color_GREEN, bitmap[i]);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\".\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_cons_printf (\"%c\", bitmap[i] ? bitmap[i] : '.' );\n\t\t}\n\t}\n\tr_cons_printf (\"\\n%d / %d (%.2lf%%) bytes assigned to a function\\n\", assigned, code_size, 100.0*( (float) assigned) / code_size);\n\tfree(bitmap);\n}\n\nstatic bool fcnNeedsPrefix(const char *name) {\n\tif (!strncmp (name, \"entry\", 5)) {\n\t\treturn false;\n\t}\n\tif (!strncmp (name, \"main\", 4)) {\n\t\treturn false;\n\t}\n\treturn (!strchr (name, '.'));\n}\n\n/* TODO: move into r_anal_fcn_rename(); */\nstatic bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {\n\tchar *name, *oname, *nname = NULL;\n\tRAnalFunction *fcn;\n\tif (!core || !_name) {\n\t\treturn false;\n\t}\n\tconst char *fcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\tif (!fcnpfx) {\n\t\tfcnpfx = \"fcn\";\n\t}\n\tif (r_reg_get (core->anal->reg, _name, -1)) {\n\t\tname = r_str_newf (\"%s.%s\", fcnpfx, _name);\n\t} else {\n\t\tname = strdup (_name);\n\t}\n\tfcn = r_anal_get_fcn_in (core->anal, off,\n\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\tif (prefix && fcnNeedsPrefix (name)) {\n\t\tnname = r_str_newf (\"%s.%s\", fcnpfx, name);\n\t} else {\n\t\tnname = strdup (name);\n\t}\n\toname = fcn->name;\n\tr_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);\n\tfcn->name = strdup (nname);\n\tif (core->anal->cb.on_fcn_rename) {\n\t\tcore->anal->cb.on_fcn_rename (core->anal,\n\t\t\t\t\tcore->anal->user, fcn, nname);\n\t}\n\tfree (oname);\n\tfree (nname);\n\tfree (name);\n\treturn true;\n}\n\nstatic void afCc(RCore *core, const char *input) {\n\tut64 addr;\n\tRAnalFunction *fcn;\n\tif (*input == ' ') {\n\t\taddr = r_num_math (core->num, input);\n\t} else {\n\t\taddr = core->offset;\n\t}\n\tif (addr == 0LL) {\n\t\tfcn = r_anal_fcn_find_name (core->anal, input + 3);\n\t} else {\n\t\tfcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t}\n\tif (fcn) {\n\t\tut32 totalCycles = r_anal_fcn_cost (core->anal, fcn);\n\t\t// FIXME: This defeats the purpose of the function, but afC is used in project files.\n\t\t// cf. canal.c\n\t\tr_cons_printf (\"%d\\n\", totalCycles);\n\t} else {\n\t\teprintf (\"Cannot find function\\n\");\n\t}\n}\n\nstatic int cmd_anal_fcn(RCore *core, const char *input) {\n\tchar i;\n\n\tr_cons_break_timeout (r_config_get_i (core->config, \"anal.timeout\"));\n\tswitch (input[1]) {\n\tcase 'f': // \"aff\"\n\t\tr_anal_fcn_fit_overlaps (core->anal, NULL);\n\t\tbreak;\n\tcase 'a':\n\t\tif (input[2] == 'l') { // afal : list function call arguments\n\t\t\tint show_args = r_config_get_i (core->config, \"dbg.funcarg\");\n\t\t\tif (show_args) {\n\t\t\t\tr_core_print_func_args (core);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase 'd': // \"afd\"\n\t\t{\n\t\tut64 addr = 0;\n\t\tif (input[2] == '?') {\n\t\t\teprintf (\"afd [offset]\\n\");\n\t\t} else if (input[2] == ' ') {\n\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\tif (fcn) {\n\t\t\tif (fcn->addr != addr) {\n\t\t\t\tr_cons_printf (\"%s + %d\\n\", fcn->name,\n\t\t\t\t\t\t(int)(addr - fcn->addr));\n\t\t\t} else {\n\t\t\t\tr_cons_println (fcn->name);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot find function\\n\");\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '-': // \"af-\"\n\t\tif (!input[2] || !strcmp (input + 2, \"*\")) {\n\t\t\tr_anal_fcn_del_locs (core->anal, UT64_MAX);\n\t\t\tr_anal_fcn_del (core->anal, UT64_MAX);\n\t\t} else {\n\t\t\tut64 addr = input[2]\n\t\t\t\t? r_num_math (core->num, input + 2)\n\t\t\t\t: core->offset;\n\t\t\tr_anal_fcn_del_locs (core->anal, addr);\n\t\t\tr_anal_fcn_del (core->anal, addr);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"afu\"\n\t\t{\n\t\tut64 addr = core->offset;\n\t\tut64 addr_end = r_num_math (core->num, input + 2);\n\t\tif (addr_end < addr) {\n\t\t\teprintf (\"Invalid address ranges\\n\");\n\t\t} else {\n\t\t\tint depth = 1;\n\t\t\tut64 a, b;\n\t\t\tconst char *c;\n\t\t\ta = r_config_get_i (core->config, \"anal.from\");\n\t\t\tb = r_config_get_i (core->config, \"anal.to\");\n\t\t\tc = r_config_get (core->config, \"anal.limits\");\n\t\t\tr_config_set_i (core->config, \"anal.from\", addr);\n\t\t\tr_config_set_i (core->config, \"anal.to\", addr_end);\n\t\t\tr_config_set (core->config, \"anal.limits\", \"true\");\n\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_fcn_resize (core->anal, fcn, addr_end - addr);\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, addr, UT64_MAX,\n\t\t\t\t\tR_ANAL_REF_TYPE_NULL, depth);\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_anal_fcn_resize (core->anal, fcn, addr_end - addr);\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"anal.from\", a);\n\t\t\tr_config_set_i (core->config, \"anal.to\", b);\n\t\t\tr_config_set (core->config, \"anal.limits\", c? c: \"\");\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+': { // \"af+\"\n\t\tif (input[2] != ' ') {\n\t\t\teprintf (\"Missing arguments\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tchar *ptr = strdup (input + 3);\n\t\tconst char *ptr2;\n\t\tint n = r_str_word_set0 (ptr);\n\t\tconst char *name = NULL;\n\t\tut64 addr = UT64_MAX;\n\t\tut64 size = 0LL;\n\t\tRAnalDiff *diff = NULL;\n\t\tint type = R_ANAL_FCN_TYPE_FCN;\n\t\tif (n > 1) {\n\t\t\tswitch (n) {\n\t\t\tcase 5:\n\t\t\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 4));\n\t\t\tcase 4:\n\t\t\t\tptr2 = r_str_word_get0 (ptr, 3);\n\t\t\t\tif (!(diff = r_anal_diff_new ())) {\n\t\t\t\t\teprintf (\"error: Cannot init RAnalDiff\\n\");\n\t\t\t\t\tfree (ptr);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ptr2[0] == 'm') {\n\t\t\t\t\tdiff->type = R_ANAL_DIFF_TYPE_MATCH;\n\t\t\t\t} else if (ptr2[0] == 'u') {\n\t\t\t\t\tdiff->type = R_ANAL_DIFF_TYPE_UNMATCH;\n\t\t\t\t}\n\t\t\tcase 3:\n\t\t\t\tptr2 = r_str_word_get0 (ptr, 2);\n\t\t\t\tif (strchr (ptr2, 'l')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_LOC;\n\t\t\t\t} else if (strchr (ptr2, 'i')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_IMP;\n\t\t\t\t} else if (strchr (ptr2, 's')) {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_SYM;\n\t\t\t\t} else {\n\t\t\t\t\ttype = R_ANAL_FCN_TYPE_FCN;\n\t\t\t\t}\n\t\t\tcase 2:\n\t\t\t\tname = r_str_word_get0 (ptr, 1);\n\t\t\tcase 1:\n\t\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t}\n\t\t\tif (!r_anal_fcn_add (core->anal, addr, size, name, type, diff)) {\n\t\t\t\teprintf (\"Cannot add function (duplicated)\\n\");\n\t\t\t}\n\t\t}\n\t\tr_anal_diff_free (diff);\n\t\tfree (ptr);\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"afo\"\n\t\t{\n\t\tRAnalFunction *fcn;\n\t\tut64 addr = core->offset;\n\t\tif (input[2] == ' ')\n\t\t\taddr = r_num_math (core->num, input + 3);\n\t\tif (addr == 0LL) {\n\t\t\tfcn = r_anal_fcn_find_name (core->anal, input + 3);\n\t\t} else {\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t}\n\t\tif (fcn) {\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"afi\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afi);\n\t\t\tbreak;\n\t\tcase '.': // \"afi.\"\n\t\t\t{\n\t\t\t\tut64 addr = core->offset;\n\t\t\t\tif (input[3] == ' ') {\n\t\t\t\t\taddr = r_num_math (core->num, input + 3);\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", fcn->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': // \"afil\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\t// TODO #7967 help refactor\n\t\t\t\thelp_msg_afll[1] = \"afil\";\n\t\t\t\tr_core_cmd_help (core, help_msg_afll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase 'j':   // \"afij\"\n\t\tcase '*':   // \"afi*\"\n\t\t\tr_core_anal_fcn_list (core, input + 3, input + 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = 1;\n\t\t\tr_core_anal_fcn_list (core, input + 2, &i);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"afl\"\n\t\tswitch (input[2]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afl);\n\t\t\tbreak;\n\t\tcase 'l': // \"afll\"\n\t\t\tif (input[3] == '?') {\n\t\t\t\t// TODO #7967 help refactor\n\t\t\t\thelp_msg_afll[1] = \"afll\";\n\t\t\t\tr_core_cmd_help (core, help_msg_afll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase 'j': // \"aflj\"\n\t\tcase 'q': // \"aflq\"\n\t\tcase 's': // \"afls\"\n\t\tcase '*': // \"afl*\"\n\t\t\tr_core_anal_fcn_list (core, NULL, input + 2);\n\t\t\tbreak;\n\t\tcase 'c': // \"aflc\"\n\t\t\tr_cons_printf (\"%d\\n\", r_list_length (core->anal->fcns));\n\t\t\tbreak;\n\t\tdefault: // \"afl \"\n\t\t\tr_core_anal_fcn_list (core, NULL, \"o\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 's': // \"afs\"\n\t\t{\n\t\tut64 addr;\n\t\tRAnalFunction *f;\n\t\tconst char *arg = input + 3;\n\t\tif (input[2] && (addr = r_num_math (core->num, arg))) {\n\t\t\targ = strchr (arg, ' ');\n\t\t\tif (arg) {\n\t\t\t\targ++;\n\t\t\t}\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tif ((f = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL))) {\n\t\t\tif (arg && *arg) {\n\t\t\t\tr_anal_str_to_fcn (core->anal, f, arg);\n\t\t\t} else {\n\t\t\t\tchar *str = r_anal_fcn_to_string (core->anal, f);\n\t\t\t\tr_cons_println (str);\n\t\t\t\tfree (str);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"No function defined at 0x%08\" PFMT64x \"\\n\", addr);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'm': // \"afm\" - merge two functions\n\t\tr_core_anal_fcn_merge (core, core->offset, r_num_math (core->num, input + 2));\n\t\tbreak;\n\tcase 'M': // \"afM\" - print functions map\n\t\tr_core_anal_fmap (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"afv\"\n\t\tvar_cmd (core, input + 2);\n\t\tbreak;\n\tcase 't': // \"aft\"\n\t\ttype_cmd (core, input + 2);\n\t\tbreak;\n\tcase 'C': // \"afC\"\n\t\tif (input[2] == 'c') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tif ((fcn = r_anal_get_fcn_in (core->anal, core->offset, 0)) != NULL) {\n\t\t\t\tr_cons_printf (\"%i\\n\", r_anal_fcn_cc (fcn));\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: Cannot find function at 0x08%\" PFMT64x \"\\n\", core->offset);\n\t\t\t}\n\t\t} else if (input[2] == 'l') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tif ((fcn = r_anal_get_fcn_in (core->anal, core->offset, 0)) != NULL) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_anal_fcn_loops (fcn));\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: Cannot find function at 0x08%\" PFMT64x \"\\n\", core->offset);\n\t\t\t}\n\t\t} else if (input[2] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_afC);\n\t\t} else {\n\t\t\tafCc (core, input + 3);\n\t\t}\n\t\tbreak;\n\tcase 'c':{ // \"afc\"\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (!fcn && !(input[2] == '?'|| input[2] == 'l' || input[2] == 'o')) {\n\t\t\teprintf (\"Cannot find function here\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (input[2]) {\n\t\tcase '\\0': // \"afc\"\n\t\t\tr_cons_println (fcn->cc);\n\t\t\tbreak;\n\t\tcase ' ': { // \"afc \"\n\t\t\tchar *cc = r_str_trim (strdup (input + 3));\n\t\t\tif (!r_anal_cc_exist (core->anal, cc)) {\n\t\t\t\teprintf (\"Unknown calling convention '%s'\\n\"\n\t\t\t\t\t\t\"See afcl for available types\\n\", cc);\n\t\t\t} else {\n\t\t\t\tfcn->cc = r_str_const (r_anal_cc_to_constant (core->anal, cc));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'a': // \"afca\"\"\n\t\t\teprintf (\"Todo\\n\");\n\t\t\tbreak;\n\t\tcase 'l': // \"afcl\" list all function Calling conventions.\n\t\t\tsdb_foreach (core->anal->sdb_cc, cc_print, NULL);\n\t\t\tbreak;\n\t\tcase 'o': { // \"afco\"\n\t\t\tchar *dbpath = r_str_trim (strdup (input + 3));\n\t\t\tif (r_file_exists (dbpath)) {\n\t\t\t\tSdb *db = sdb_new (0, dbpath, 0);\n\t\t\t\tsdb_merge (core->anal->sdb_cc, db);\n\t\t\t\tsdb_close (db);\n\t\t\t\tsdb_free (db);\n\t\t\t}\n\t\t\tfree (dbpath);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'r': {\t// \"afcr\"\n\t\t\tint i;\n\t\t\tchar *out, *cmd, *regname, *tmp;\n\t\t\tchar *subvec_str = r_str_new (\"\");\n\t\t\tchar *json_str = r_str_new (\"\");\n\t\t\t// if json_str initialize to NULL, it's possible for afcrj to output a (NULL)\n\t\t\t// subvec_str and json_str should be valid until exiting this code block\n\t\t\tbool json = input[3] == 'j'? true: false;\n\t\t\tfor (i = 0; i <= 11; i++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tcmd = r_str_newf (\"cc.%s.ret\", fcn->cc);\n\t\t\t\t} else {\n\t\t\t\t\tcmd = r_str_newf (\"cc.%s.arg%d\", fcn->cc, i);\n\t\t\t\t}\n\t\t\t\tif (i < 7) {\n\t\t\t\t\tregname = r_str_new (cmd);\n\t\t\t\t} else {\n\t\t\t\t\tregname = r_str_newf (\"cc.%s.float_arg%d\", fcn->cc, i - 6);\n\t\t\t\t}\n\t\t\t\tout = sdb_querys (core->anal->sdb_cc, NULL, 0, cmd);\n\t\t\t\tfree (cmd);\n\t\t\t\tif (out) {\n\t\t\t\t\tout[strlen (out) - 1] = 0;\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\ttmp = subvec_str;\n\t\t\t\t\t\tsubvec_str = r_str_newf (\"%s,\\\"%s\\\"\", subvec_str, out);\n\t\t\t\t\t\tfree (tmp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", regname, out);\n\t\t\t\t\t}\n\t\t\t\t\tfree (out);\n\t\t\t\t}\n\t\t\t\tfree (regname);\n\t\t\t\tif (!subvec_str[0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0: {\n\t\t\t\t\ttmp = json_str;\n\t\t\t\t\tjson_str = r_str_newf (\"%s,\\\"ret\\\":%s\", json_str, subvec_str + 1);\n\t\t\t\t\tfree (tmp);\n\t\t\t\t} break;\n\t\t\t\tcase 6: {\n\t\t\t\t\ttmp = json_str;\n\t\t\t\t\tjson_str = r_str_newf (\"%s,\\\"args\\\":[%s]\", json_str, subvec_str + 1);\n\t\t\t\t\tfree (tmp);\n\t\t\t\t} break;\n\t\t\t\tcase 11: {\n\t\t\t\t\ttmp = json_str;\n\t\t\t\t\tjson_str = r_str_newf (\"%s,\\\"float_args\\\":[%s]\", json_str, subvec_str + 1);\n\t\t\t\t\tfree (tmp);\n\t\t\t\t} break;\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfree (subvec_str);\n\t\t\t\tsubvec_str = r_str_new (\"\");\n\t\t\t}\n\t\t\tif (json && json_str[0]) {\n\t\t\t\tr_cons_printf (\"{%s}\\n\", json_str + 1);\n\t\t\t}\n\t\t\tfree (subvec_str);\n\t\t\tfree (json_str);\n\t\t} break;\n\t\tcase '?': // \"afc?\"\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afc);\n\t\t}\n\t\t}break;\n\tcase 'B': // \"afB\" // set function bits\n\t\tif (input[2] == ' ') {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\tif (fcn) {\n\t\t\t\tint bits = atoi (input + 3);\n\t\t\t\tr_anal_hint_set_bits (core->anal, fcn->addr, bits);\n\t\t\t\tr_anal_hint_set_bits (core->anal,\n\t\t\t\t\tfcn->addr + r_anal_fcn_size (fcn),\n\t\t\t\t\tcore->anal->bits);\n\t\t\t\tfcn->bits = bits;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot find function to set bits\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: afB [bits]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"afb\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"afb-\"\n\t\t\tanal_fcn_del_bb (core, input + 3);\n\t\t\tbreak;\n\t\tcase 'e': // \"afbe\"\n\t\t\tanal_bb_edge (core, input + 3);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase ' ': // \"afb \"\n\t\tcase 'q': // \"afbq\"\n\t\tcase 'r': // \"afbr\"\n\t\tcase '*': // \"afb*\"\n\t\tcase 'j': // \"afbj\"\n\t\t\tanal_fcn_list_bb (core, input + 2, false);\n\t\t\tbreak;\n\t\tcase 'i': // \"afbi\"\n\t\t\tanal_fcn_list_bb (core, input + 2, true);\n\t\t\tbreak;\n\t\tcase '.': // \"afb.\"\n\t\t\tanal_fcn_list_bb (core, input[2]? \" $$\": input + 2, true);\n\t\t\tbreak;\n\t\tcase '+': // \"afb+\"\n\t\t\tanal_fcn_add_bb (core, input + 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_afb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"afn\"\n\t\tswitch (input[2]) {\n\t\tcase 's': // \"afns\"\n\t\t\tfree (r_core_anal_fcn_autoname (core, core->offset, 1));\n\t\t\tbreak;\n\t\tcase 'a': // \"afna\"\n\t\t\t{\n\t\t\tchar *name = r_core_anal_fcn_autoname (core, core->offset, 0);\n\t\t\tif (name) {\n\t\t\t\tr_cons_printf (\"afn %s 0x%08\" PFMT64x \"\\n\", name, core->offset);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0: // \"afn\"\n\t\t\t{\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", fcn->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ': // \"afn \"\n\t\t\t{\n\t\t\tut64 off = core->offset;\n\t\t\tchar *p, *name = strdup (input + 3);\n\t\t\tif ((p = strchr (name, ' '))) {\n\t\t\t\t*p++ = 0;\n\t\t\t\toff = r_num_math (core->num, p);\n\t\t\t}\n\t\t\tif (*name) {\n\t\t\t\tif (!setFunctionName (core, off, name, false)) {\n\t\t\t\t\teprintf (\"Cannot find function '%s' at 0x%08\" PFMT64x \"\\n\", name, off);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: afn newname [off]   # set new name to given function\\n\");\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_afn);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': // afS\"\n\t\t{\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\tif (fcn) {\n\t\t\tfcn->maxstack = r_num_math (core->num, input + 3);\n\t\t\t//fcn->stack = fcn->maxstack;\n\t\t}\n\t\t}\n\t\tbreak;\n#if 0\n\t/* this is undocumented and probably have no uses. plz discuss */\n\tcase 'e': // \"afe\"\n\t\t{\n\t\tRAnalFunction *fcn;\n\t\tut64 off = core->offset;\n\t\tchar *p, *name = strdup ((input[2]&&input[3])? input + 3: \"\");\n\t\tif ((p = strchr (name, ' '))) {\n\t\t\t*p = 0;\n\t\t\toff = r_num_math (core->num, p + 1);\n\t\t}\n\t\tfcn = r_anal_get_fcn_in (core->anal, off, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tRAnalRef *r;\n\t\t\tr_list_foreach (fcn->refs, iter, r) {\n\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" -%c 0x%08\" PFMT64x \"\\n\", r->at, r->type, r->addr);\n\t\t\t}\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint ok = 0;\n\t\t\t\tif (b->type == R_ANAL_BB_TYPE_LAST) ok = 1;\n\t\t\t\tif (b->type == R_ANAL_BB_TYPE_FOOT) ok = 1;\n\t\t\t\tif (b->jump == UT64_MAX && b->fail == UT64_MAX) ok = 1;\n\t\t\t\tif (ok) {\n\t\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \" -r\\n\", b->addr);\n\t\t\t\t\t// TODO: check if destination is outside the function boundaries\n\t\t\t\t}\n\t\t\t}\n\t\t} else eprintf (\"Cannot find function at 0x%08\" PFMT64x \"\\n\", core->offset);\n\t\tfree (name);\n\t\t}\n\t\tbreak;\n#endif\n\tcase 'x': // \"afx\"\n\t\tswitch (input[2]) {\n\t\tcase '\\0': // \"afx\"\n\t\tcase 'j': // \"afxj\"\n\t\tcase ' ': // \"afx \"\n#if FCN_OLD\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tr_cons_printf (\"[\");\n\t\t\t}\n\t\t\t// TODO: sdbize!\n\t\t\t// list xrefs from current address\n\t\t\t{\n\t\t\t\tut64 addr = input[2]==' '? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tRList *refs = r_anal_fcn_get_refs (core->anal, fcn);\n\t\t\t\t\tr_list_foreach (refs, iter, ref) {\n\t\t\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\t\t\tr_cons_printf (\"{\\\"type\\\":\\\"%c\\\",\\\"from\\\":%\"PFMT64d\",\\\"to\\\":%\"PFMT64d\"}%s\",\n\t\t\t\t\t\t\t\t\tref->type, ref->at, ref->addr, iter->n? \",\": \"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"%c 0x%08\" PFMT64x \" -> 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\t\tref->type, ref->at, ref->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_list_free (refs);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Cannot find function at 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tr_cons_printf (\"]\\n\");\n\t\t\t}\n#else\n#warning TODO_ FCNOLD sdbize xrefs here\n\t\t\teprintf (\"TODO\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'c': // \"afxc\" add code xref\n\t\tcase 'd': // \"afxd\"\n\t\tcase 's': // \"afxs\"\n\t\tcase 'C': { // \"afxC\"\n\t\t\tchar *p;\n\t\t\tut64 a, b;\n\t\t\tchar *mi = strdup (input);\n\t\t\tif (mi && mi[3] == ' ' && (p = strchr (mi + 4, ' '))) {\n\t\t\t\t*p = 0;\n\t\t\t\ta = r_num_math (core->num, mi + 3);\n\t\t\t\tb = r_num_math (core->num, p + 1);\n\t\t\t\tr_anal_xrefs_set (core->anal, input[2], a, b);\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help (core, help_msg_afx);\n\t\t\t}\n\t\t\tfree (mi);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-': // \"afx-\"\n\t\t\t{\n\t\t\tchar *p;\n\t\t\tut64 a, b;\n\t\t\tchar *mi = strdup (input + 3);\n\t\t\tif (mi && *mi == ' ' && (p = strchr (mi + 1, ' '))) {\n\t\t\t\t*p = 0;\n\t\t\t\ta = r_num_math (core->num, mi);\n\t\t\t\tb = r_num_math (core->num, p + 1);\n\t\t\t\tr_anal_xrefs_deln (core->anal, -1, a, b);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: afx- [src] [dst]\\n\");\n\t\t\t}\n\t\t\tfree (mi);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase '?': // \"afx?\"\n\t\t\tr_core_cmd_help (core, help_msg_afx);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'F': // \"afF\"\n\t\t{\n\t\t\tint val = input[2] && r_num_math (core->num, input + 2);\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\t\tif (fcn) {\n\t\t\t\tfcn->folded = input[2]? val: !fcn->folded;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?': // \"af?\"\n\t\tr_core_cmd_help (core, help_msg_af);\n\t\tbreak;\n\tcase 'r': // \"afr\" // analyze function recursively\n\tcase ' ': // \"af \"\n\tcase '\\0': // \"af\"\n\t\t{\n\t\tchar *uaddr = NULL, *name = NULL;\n\t\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\t\tbool analyze_recursively = r_config_get_i (core->config, \"anal.calls\");\n\t\tRAnalFunction *fcn;\n\t\tut64 addr = core->offset;\n\t\tif (input[1] == 'r') {\n\t\t\tinput++;\n\t\t\tanalyze_recursively = true;\n\t\t}\n\n\t\t// first undefine\n\t\tif (input[0] && input[1] == ' ') {\n\t\t\tname = strdup (input + 2);\n\t\t\tuaddr = strchr (name, ' ');\n\t\t\tif (uaddr) {\n\t\t\t\t*uaddr++ = 0;\n\t\t\t\taddr = r_num_math (core->num, uaddr);\n\t\t\t}\n\t\t\t// depth = 1; // or 1?\n\t\t\t// disable hasnext\n\t\t}\n\n\t\t//r_core_anal_undefine (core, core->offset);\n\t\tr_core_anal_fcn (core, addr, UT64_MAX, R_ANAL_REF_TYPE_NULL, depth);\n\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\tif (fcn && r_config_get_i (core->config, \"anal.vars\")) {\n\t\t\tfcn_callconv (core, fcn);\n\t\t}\n\t\tif (fcn) {\n\t\t\t/* ensure we use a proper name */\n\t\t\tsetFunctionName (core, addr, fcn->name, false);\n\t\t}\n\t\tif (analyze_recursively) {\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, addr, 0); /// XXX wrong in case of nopskip\n\t\t\tif (fcn) {\n\t\t\t\tRAnalRef *ref;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRList *refs = r_anal_fcn_get_refs (core->anal, fcn);\n\t\t\t\tr_list_foreach (refs, iter, ref) {\n\t\t\t\t\tif (ref->addr == UT64_MAX) {\n\t\t\t\t\t\t//eprintf (\"Warning: ignore 0x%08\"PFMT64x\" call 0x%08\"PFMT64x\"\\n\", ref->at, ref->addr);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ref->type != 'c' && ref->type != 'C') {\n\t\t\t\t\t\t/* only follow code/call references */\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!r_io_is_valid_offset (core->io, ref->addr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (core, ref->addr, fcn->addr, R_ANAL_REF_TYPE_CALL, depth);\n\t\t\t\t\t/* use recursivity here */\n#if 1\n\t\t\t\t\tRAnalFunction *f = r_anal_get_fcn_at (core->anal, ref->addr, 0);\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tRListIter *iter;\n\t\t\t\t\t\tRAnalRef *ref;\n\t\t\t\t\t\tRList *refs1 = r_anal_fcn_get_refs (core->anal, f);\n\t\t\t\t\t\tr_list_foreach (refs1, iter, ref) {\n\t\t\t\t\t\t\tif (!r_io_is_valid_offset (core->io, ref->addr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ref->type != 'c' && ref->type != 'C') {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_core_anal_fcn (core, ref->addr, f->addr, R_ANAL_REF_TYPE_CALL, depth);\n\t\t\t\t\t\t\t// recursively follow fcn->refs again and again\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_list_free (refs1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf = r_anal_get_fcn_in (core->anal, fcn->addr, 0);\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\t/* cut function */\n\t\t\t\t\t\t\tr_anal_fcn_resize (core->anal, f, addr - fcn->addr);\n\t\t\t\t\t\t\tr_core_anal_fcn (core, ref->addr, fcn->addr,\n\t\t\t\t\t\t\t\t\tR_ANAL_REF_TYPE_CALL, depth);\n\t\t\t\t\t\t\tf = r_anal_get_fcn_at (core->anal, fcn->addr, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\teprintf (\"Cannot find function at 0x%08\" PFMT64x \"\\n\", fcn->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tr_list_free (refs);\n\t\t\t}\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (*name && !setFunctionName (core, addr, name, true)) {\n\t\t\t\teprintf (\"Cannot find function '%s' at 0x%08\" PFMT64x \"\\n\", name, (ut64)addr);\n\t\t\t}\n\t\t\tfree (name);\n\t\t}\n\t\tflag_every_function (core);\n\t}\n\tdefault:\n\t\treturn false;\n\t\tbreak;\n\t}\n\treturn true;\n}\n\n// size: 0: bits; -1: any; >0: exact size\nstatic void __anal_reg_list(RCore *core, int type, int bits, char mode) {\n\tRReg *hack = core->dbg->reg;\n\tconst char *use_color;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tif (use_colors) {\n#undef ConsP\n#define ConsP(x) (core->cons && core->cons->pal.x)? core->cons->pal.x\n\t\tuse_color = ConsP (creg) : Color_BWHITE;\n\t} else {\n\t\tuse_color = NULL;\n\t}\n\tif (bits < 0) {\n\t\t// TODO Change the `size` argument of r_debug_reg_list to use -1 for any and 0 for anal->bits\n\t\tbits = 0;\n\t} else if (!bits) {\n\t\tbits = core->anal->bits;\n\t}\n\tif (core->anal) {\n\t\tcore->dbg->reg = core->anal->reg;\n\t\tif (core->anal->cur && core->anal->cur->arch) {\n\t\t\t/* workaround for thumb */\n\t\t\tif (!strcmp (core->anal->cur->arch, \"arm\") && bits == 16) {\n\t\t\t\tbits = 32;\n\t\t\t}\n\t\t\t/* workaround for 6502 */\n\t\t\tif (!strcmp (core->anal->cur->arch, \"6502\") && bits == 8) {\n\t\t\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, 16, mode, use_color); // XXX detect which one is current usage\n\t\t\t}\n\t\t\tif (!strcmp (core->anal->cur->arch, \"avr\") && bits == 8) {\n\t\t\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, 16, mode, use_color); // XXX detect which one is current usage\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mode == '=') {\n\t\tint pcbits = 0;\n\t\tconst char *pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\tRRegItem *reg = r_reg_get (core->anal->reg, pcname, 0);\n\t\tif (bits != reg->size) {\n\t\t\tpcbits = reg->size;\n\t\t}\n\t\tif (pcbits) {\n\t\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, pcbits, 2, use_color); // XXX detect which one is current usage\n\t\t}\n\t}\n\tr_debug_reg_list (core->dbg, type, bits, mode, use_color);\n\tcore->dbg->reg = hack;\n}\n\n// XXX dup from drp :OOO\nvoid cmd_anal_reg(RCore *core, const char *str) {\n\tint size = 0, i, type = R_REG_TYPE_GPR;\n\tint bits = (core->anal->bits & R_SYS_BITS_64)? 64: 32;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tstruct r_reg_item_t *r;\n\tconst char *use_color;\n\tconst char *name;\n\tchar *arg;\n\n\tif (use_colors) {\n#define ConsP(x) (core->cons && core->cons->pal.x)? core->cons->pal.x\n\t\tuse_color = ConsP (creg)\n\t\t: Color_BWHITE;\n\t} else {\n\t\tuse_color = NULL;\n\t}\n\tswitch (str[0]) {\n\tcase 'l': // \"arl\"\n\t{\n\t\tRRegSet *rs = r_reg_regset_get (core->anal->reg, R_REG_TYPE_GPR);\n\t\tif (rs) {\n\t\t\tRRegItem *r;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (rs->regs, iter, r) {\n\t\t\t\tr_cons_println (r->name);\n\t\t\t}\n\t\t}\n\t} break;\n\tcase '0': // \"ar0\"\n\t\tr_reg_arena_zero (core->anal->reg);\n\t\tbreak;\n\tcase 'C': // \"arC\"\n\t\tif (core->anal->reg->reg_profile_cmt) {\n\t\t\tr_cons_println (core->anal->reg->reg_profile_cmt);\n\t\t}\n\t\tbreak;\n\tcase 'w': // \"arw\"\n\t\tswitch (str[1]) {\n\t\tcase '?': {\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ':\n\t\t\tr_reg_arena_set_bytes (core->anal->reg, str + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"ara\"\n\t\tswitch (str[1]) {\n\t\tcase '?': // \"ara?\"\n\t\t\tr_core_cmd_help (core, help_msg_ara);\n\t\t\tbreak;\n\t\tcase 's': // \"aras\"\n\t\t\tr_reg_arena_swap (core->anal->reg, false);\n\t\t\tbreak;\n\t\tcase '+': // \"ara+\"\n\t\t\tr_reg_arena_push (core->anal->reg);\n\t\t\tbreak;\n\t\tcase '-': // \"ara-\"\n\t\t\tr_reg_arena_pop (core->anal->reg);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tint i, j;\n\t\t\tRRegArena *a;\n\t\t\tRListIter *iter;\n\t\t\tfor (i = 0; i < R_REG_TYPE_LAST; i++) {\n\t\t\t\tRRegSet *rs = &core->anal->reg->regset[i];\n\t\t\t\tj = 0;\n\t\t\t\tr_list_foreach (rs->pool, iter, a) {\n\t\t\t\t\tr_cons_printf (\"%s %p %d %d %s %d\\n\",\n\t\t\t\t\t\t(a == rs->arena)? \"*\": \".\", a,\n\t\t\t\t\t\ti, j, r_reg_get_type (i), a->size);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ar?\"\n\t\tif (str[1]) {\n\t\t\tut64 off = r_reg_getv (core->anal->reg, str + 1);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", off);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"arr\"\n\t\tr_core_debug_rr (core, core->anal->reg);\n\t\tbreak;\n\tcase 'S': { // \"arS\"\n\t\tint sz;\n\t\tut8 *buf = r_reg_get_bytes (\n\t\t\tcore->anal->reg, R_REG_TYPE_GPR, &sz);\n\t\tr_cons_printf (\"%d\\n\", sz);\n\t\tfree (buf);\n\t\t} break;\n\tcase 'b': { // \"arb\" WORK IN PROGRESS // DEBUG COMMAND\n\t\tint len, type = R_REG_TYPE_GPR;\n\t\targ = strchr (str, ' ');\n\t\tif (arg) {\n\t\t\tchar *string = r_str_trim (strdup (arg + 1));\n\t\t\tif (string) {\n\t\t\t\ttype = r_reg_type_by_name (string);\n\t\t\t\tif (type == -1 && string[0] != 'a') {\n\t\t\t\t\ttype = R_REG_TYPE_GPR;\n\t\t\t\t}\n\t\t\t\tfree (string);\n\t\t\t}\n\t\t}\n\t\tut8 *buf = r_reg_get_bytes (core->dbg->reg, type, &len);\n\t\tif (buf) {\n\t\t\t//r_print_hexdump (core->print, 0LL, buf, len, 16, 16);\n\t\t\tr_print_hexdump (core->print, 0LL, buf, len, 32, 4, 1);\n\t\t\tfree (buf);\n\t\t}\n\t\t} break;\n\tcase 'c': // \"arc\"\n\t\t// TODO: set flag values with drc zf=1\n\t\t{\n\t\t\tRRegItem *r;\n\t\t\tconst char *name = str + 1;\n\t\t\twhile (*name == ' ') name++;\n\t\t\tif (*name && name[1]) {\n\t\t\t\tr = r_reg_cond_get (core->dbg->reg, name);\n\t\t\t\tif (r) {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t} else {\n\t\t\t\t\tint id = r_reg_cond_from_string (name);\n\t\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\t\tif (rf) {\n\t\t\t\t\t\tint o = r_reg_cond_bits (core->dbg->reg, id, rf);\n\t\t\t\t\t\tcore->num->value = o;\n\t\t\t\t\t\t// ORLY?\n\t\t\t\t\t\tr_cons_printf (\"%d\\n\", o);\n\t\t\t\t\t\tfree (rf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"unknown conditional or flag register\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\tif (rf) {\n\t\t\t\t\tr_cons_printf (\"| s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\t\tif (*name == '=') {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s:%d \",\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (i),\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%d %s\\n\",\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf),\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (rf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ars\"\n\t\tswitch (str[1]) {\n\t\tcase '-': // \"ars-\"\n\t\t\tr_reg_arena_pop (core->dbg->reg);\n\t\t\t// restore debug registers if in debugger mode\n\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, true);\n\t\t\tbreak;\n\t\tcase '+': // \"ars+\"\n\t\t\tr_reg_arena_push (core->dbg->reg);\n\t\t\tbreak;\n\t\tcase '?': { // \"ars?\"\n\t\t\t// TODO #7967 help refactor: dup from drp\n\t\t\tconst char *help_msg[] = {\n\t\t\t\t\"Usage:\", \"drs\", \" # Register states commands\",\n\t\t\t\t\"drs\", \"\", \"List register stack\",\n\t\t\t\t\"drs+\", \"\", \"Push register state\",\n\t\t\t\t\"drs-\", \"\", \"Pop register state\",\n\t\t\t\tNULL };\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\t} break;\n\t\tdefault:\n\t\t\tr_cons_printf (\"%d\\n\", r_list_length (\n\t\t\t\t\t\tcore->dbg->reg->regset[0].pool));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"arp\"\n\t\t// XXX we have to break out .h for these cmd_xxx files.\n\t\tcmd_reg_profile (core, 'a', str);\n\t\tbreak;\n\tcase 't': // \"art\"\n\t\tfor (i = 0; (name = r_reg_get_type (i)); i++)\n\t\t\tr_cons_println (name);\n\t\tbreak;\n\tcase 'n': // \"arn\"\n\t\tif (*(str + 1) == '\\0') {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tname = r_reg_get_name (core->dbg->reg, r_reg_get_name_idx (str + 2));\n\t\tif (name && *name) {\n\t\t\tr_cons_println (name);\n\t\t} else {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ard\"\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 3, use_color); // XXX detect which one is current usage\n\t\tbreak;\n\tcase 'o': // \"aro\"\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 0, use_color); // XXX detect which one is current usage\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tbreak;\n\tcase '=': // \"ar=\"\n\t\t{\n\t\t\tchar *p = NULL;\n\t\t\tchar *bits = NULL;\n\t\t\tif (str[1]) {\n\t\t\t\tp = strdup (str + 1);\n\t\t\t\tif (str[1] != ':') {\n\t\t\t\t\t// Bits were specified\n\t\t\t\t\tbits = strtok (p, \":\");\n\t\t\t\t\tif (r_str_isnumber (bits)) {\n\t\t\t\t\t\tst64 sz = r_num_math (core->num, bits);\n\t\t\t\t\t\tif (sz > 0) {\n\t\t\t\t\t\t\tsize = sz;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint len = bits ? strlen (bits) : 0;\n\t\t\t\tif (str[len + 1] == ':') {\n\t\t\t\t\t// We have some regs\n\t\t\t\t\tchar *regs = bits ? strtok (NULL, \":\") : strtok ((char *)str + 1, \":\");\n\t\t\t\t\tchar *reg = strtok (regs, \" \");\n\t\t\t\t\tRList *q_regs = r_list_new ();\n\t\t\t\t\tif (q_regs) {\n\t\t\t\t\t\twhile (reg) {\n\t\t\t\t\t\t\tr_list_append (q_regs, reg);\n\t\t\t\t\t\t\treg = strtok (NULL, \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcore->dbg->q_regs = q_regs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t__anal_reg_list (core, type, size, 2);\n\t\t\tif (!r_list_empty (core->dbg->q_regs)) {\n\t\t\t\tr_list_free (core->dbg->q_regs);\n\t\t\t}\n\t\t\tcore->dbg->q_regs = NULL;\n\t\t\tfree (p);\n\t\t}\n\t\tbreak;\n\tcase '-': // \"ar-\"\n\tcase '*': // \"ar*\"\n\tcase 'R': // \"arR\"\n\tcase 'j': // \"arj\"\n\tcase '\\0': // \"ar\"\n\t\t__anal_reg_list (core, type, size, str[0]);\n\t\tbreak;\n\tcase ' ': { // \"ar \"\n\t\targ = strchr (str + 1, '=');\n\t\tif (arg) {\n\t\t\tchar *ostr, *regname;\n\t\t\t*arg = 0;\n\t\t\tostr = r_str_trim (strdup (str + 1));\n\t\t\tregname = r_str_trim_nc (ostr);\n\t\t\tr = r_reg_get (core->dbg->reg, regname, -1);\n\t\t\tif (!r) {\n\t\t\t\tint role = r_reg_get_name_idx (regname);\n\t\t\t\tif (role != -1) {\n\t\t\t\t\tconst char *alias = r_reg_get_name (core->dbg->reg, role);\n\t\t\t\t\tr = r_reg_get (core->dbg->reg, alias, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\t//eprintf (\"%s 0x%08\"PFMT64x\" -> \", str,\n\t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n\t\t\t\tr_reg_set_value (core->dbg->reg, r,\n\t\t\t\t\t\tr_num_math (core->num, arg + 1));\n\t\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_ALL, true);\n\t\t\t\t//eprintf (\"0x%08\"PFMT64x\"\\n\",\n\t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n\t\t\t\tr_core_cmdf (core, \".dr*%d\", bits);\n\t\t\t} else {\n\t\t\t\teprintf (\"ar: Unknown register '%s'\\n\", regname);\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\treturn;\n\t\t}\n\t\tchar name[32];\n\t\tint i = 1, j;\n\t\twhile (str[i]) {\n\t\t\tif (str[i] == ',') {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tfor (j = i; str[++j] && str[j] != ','; );\n\t\t\t\tif (j - i + 1 <= sizeof name) {\n\t\t\t\t\tr_str_ncpy (name, str + i, j - i + 1);\n\t\t\t\t\tif (IS_DIGIT (name[0])) { // e.g. ar 32\n\t\t\t\t\t\t__anal_reg_list (core, R_REG_TYPE_GPR, atoi (name), '\\0');\n\t\t\t\t\t} else if (showreg (core, name) > 0) { // e.g. ar rax\n\t\t\t\t\t} else { // e.g. ar gpr ; ar all\n\t\t\t\t\t\ttype = r_reg_type_by_name (name);\n\t\t\t\t\t\t// TODO differentiate ALL and illegal register types and print error message for the latter\n\t\t\t\t\t\t__anal_reg_list (core, type, -1, '\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t}\n\t}\n}\n\nstatic ut64 initializeEsil(RCore *core) {\n\tconst char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tRAnalEsil *esil = core->anal->esil;\n\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\tint stats = r_config_get_i (core->config, \"esil.stats\");\n\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tint exectrap = r_config_get_i (core->config, \"esil.exectrap\");\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tif (!(core->anal->esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\treturn UT64_MAX;\n\t}\n\tut64 addr;\n\tesil = core->anal->esil;\n\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\tesil->exectrap = exectrap;\n\tRList *entries = r_bin_get_entries (core->bin);\n\tRBinAddr *entry = NULL;\n\tRBinInfo *info = NULL;\n\tif (entries && !r_list_empty (entries)) {\n\t\tentry = (RBinAddr *)r_list_pop (entries);\n\t\tinfo = r_bin_get_info (core->bin);\n\t\taddr = info->has_va? entry->vaddr: entry->paddr;\n\t\tr_list_push (entries, entry);\n\t} else {\n\t\taddr = core->offset;\n\t}\n\tr_reg_setv (core->anal->reg, name, addr);\n\t// set memory read only\n\treturn addr;\n}\n\nR_API int r_core_esil_step(RCore *core, ut64 until_addr, const char *until_expr, ut64 *prev_addr) {\n#define return_tail(x) { tail_return_value = x; goto tail_return; }\n\tint tail_return_value = 0;\n\tint ret;\n\tut8 code[32];\n\tRAnalOp op = {0};\n\tRAnalEsil *esil = core->anal->esil;\n\tconst char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!esil) {\n// TODO\t\tinititalizeEsil (core);\n\n\t\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\t\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\t\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\t\tint stats = r_config_get_i (core->config, \"esil.stats\");\n\t\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\t\tint verbose = r_config_get_i (core->config, \"esil.verbose\");\n\t\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\t\tif (!(esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\t\treturn 0;\n\t\t}\n\t\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\t\tcore->anal->esil = esil;\n\t\tesil->verbose = verbose;\n\t\t{\n\t\t\tconst char *s = r_config_get (core->config, \"cmd.esil.intr\");\n\t\t\tif (s) {\n\t\t\t\tchar *my = strdup (s);\n\t\t\t\tif (my) {\n\t\t\t\t\tr_config_set (core->config, \"cmd.esil.intr\", my);\n\t\t\t\t\tfree (my);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tesil->cmd = r_core_esil_cmd;\n\tut64 addr = r_reg_getv (core->anal->reg, name);\n\tr_cons_break_push (NULL, NULL);\nrepeat:\n\tif (r_cons_is_breaked ()) {\n\t\teprintf (\"[+] ESIL emulation interrupted at 0x%08\" PFMT64x \"\\n\", addr);\n\t\treturn_tail (0);\n\t}\n\tif (!esil) {\n\t\taddr = initializeEsil (core);\n\t\tesil = core->anal->esil;\n\t\tif (!esil) {\n\t\t\treturn_tail (0);\n\t\t}\n\t} else {\n\t\tesil->trap = 0;\n\t\taddr = r_reg_getv (core->anal->reg, name);\n\t\t//eprintf (\"PC=0x%\"PFMT64x\"\\n\", (ut64)addr);\n\t}\n\tif (prev_addr) {\n\t\t*prev_addr = addr;\n\t}\n\tif (esil->exectrap) {\n\t\tif (!r_io_is_valid_offset (core->io, addr, R_IO_EXEC)) {\n\t\t\tesil->trap = R_ANAL_TRAP_EXEC_ERR;\n\t\t\tesil->trap_code = addr;\n\t\t\teprintf (\"[ESIL] Trap, trying to execute on non-executable memory\\n\");\n\t\t\treturn_tail (1);\n\t\t}\n\t}\n\tr_asm_set_pc (core->assembler, addr);\n\t// run esil pin command here\n\tconst char *pincmd = r_anal_pin_call (core->anal, addr);\n\tif (pincmd) {\n\t\tr_core_cmd0 (core, pincmd);\n\t\tut64 pc = r_debug_reg_get (core->dbg, \"PC\");\n\t\tif (addr != pc) {\n\t\t\treturn_tail (1);\n\t\t}\n\t}\n\t(void)r_io_read_at (core->io, addr, code, sizeof (code));\n\t// TODO: sometimes this is dupe\n\tret = r_anal_op (core->anal, &op, addr, code, sizeof (code), R_ANAL_OP_MASK_ALL);\n// if type is JMP then we execute the next N instructions\n\t// update the esil pointer because RAnal.op() can change it\n\tesil = core->anal->esil;\n\tif (op.size < 1 || ret < 0) {\n\t\tif (esil->cmd && esil->cmd_todo) {\n\t\t\tesil->cmd (esil, esil->cmd_todo, addr, 0);\n\t\t}\n\t\top.size = 1; // avoid inverted stepping\n\t}\n\t{\n\t\t/* apply hint */\n\t\tRAnalHint *hint = r_anal_hint_get (core->anal, addr);\n\t\tr_anal_op_hint (&op, hint);\n\t\tr_anal_hint_free (hint);\n\t}\n\tr_reg_setv (core->anal->reg, name, addr + op.size);\n\tif (ret) {\n\t\tr_anal_esil_set_pc (esil, addr);\n\t\tif (core->dbg->trace->enabled) {\n\t\t\tRReg *reg = core->dbg->reg;\n\t\t\tcore->dbg->reg = core->anal->reg;\n\t\t\tr_debug_trace_pc (core->dbg, addr);\n\t\t\tcore->dbg->reg = reg;\n\t\t} else {\n\t\t\tr_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op.esil));\n\n\t\t\tif (core->anal->cur && core->anal->cur->esil_post_loop) {\n\t\t\t\tcore->anal->cur->esil_post_loop (esil, &op);\n\t\t\t}\n\t\t\tr_anal_esil_stack_free (esil);\n\t\t}\n\t\t// only support 1 slot for now\n\t\tif (op.delay) {\n\t\t\tut8 code2[32];\n\t\t\tut64 naddr = addr + op.size;\n\t\t\tRAnalOp op2 = {0};\n\t\t\t// emulate only 1 instruction\n\t\t\tr_anal_esil_set_pc (esil, naddr);\n\t\t\t(void)r_io_read_at (core->io, naddr, code2, sizeof (code2));\n\t\t\t// TODO: sometimes this is dupe\n\t\t\tret = r_anal_op (core->anal, &op2, naddr, code2, sizeof (code2), R_ANAL_OP_MASK_ALL);\n\t\t\tswitch (op2.type) {\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CRET:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\t\t// branches are illegal in a delay slot\n\t\t\t\tesil->trap = R_ANAL_TRAP_EXEC_ERR;\n\t\t\t\tesil->trap_code = addr;\n\t\t\t\teprintf (\"[ESIL] Trap, trying to execute a branch in a delay slot\\n\");\n\t\t\t\treturn_tail (1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op2.esil));\n\t\t\tr_anal_op_fini (&op2);\n\t\t}\n\t\ttail_return_value = 1;\n\t}\n\n\tst64 follow = (st64)r_config_get_i (core->config, \"dbg.follow\");\n\tut64 pc = r_debug_reg_get (core->dbg, \"PC\");\n\tif (follow > 0) {\n\t\tif ((pc < core->offset) || (pc > (core->offset + follow))) {\n\t\t\tr_core_cmd0 (core, \"sr PC\");\n\t\t}\n\t}\n\n\t// check addr\n\tif (until_addr != UT64_MAX) {\n\t\tif (r_reg_getv (core->anal->reg, name) == until_addr) {\n\t\t\treturn_tail (0);\n\t\t}\n\t\tgoto repeat;\n\t}\n\t// check esil\n\tif (esil && esil->trap) {\n\t\tif (core->anal->esil->verbose) {\n\t\t\teprintf (\"TRAP\\n\");\n\t\t}\n\t\treturn_tail (0);\n\t}\n\tif (until_expr) {\n\t\tif (r_anal_esil_condition (core->anal->esil, until_expr)) {\n\t\t\tif (core->anal->esil->verbose) {\n\t\t\t\teprintf (\"ESIL BREAK!\\n\");\n\t\t\t}\n\t\t\treturn_tail (0);\n\t\t}\n\t\tgoto repeat;\n\t}\ntail_return:\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\treturn tail_return_value;\n}\n\nR_API int r_core_esil_step_back(RCore *core) {\n\tRAnalEsil *esil = core->anal->esil;\n\tRListIter *tail;\n\tconst char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tut64 prev = 0;\n\tut64 end = r_reg_getv (core->anal->reg, name);\n\n\tif (!esil || !(tail = r_list_tail (esil->sessions))) {\n\t\treturn 0;\n\t}\n\tRAnalEsilSession *before = (RAnalEsilSession *) tail->data;\n\tif (!before) {\n\t\teprintf (\"Cannot find any previous state here\\n\");\n\t\treturn 0;\n\t}\n\teprintf (\"NOTE: step back in esil is setting an initial state and stepping into pc is the same.\\n\");\n\teprintf (\"NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\\n\");\n\teprintf (\"NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\\n\");\n\teprintf (\"Execute until 0x%08\"PFMT64x\"\\n\", end);\n\tr_anal_esil_session_set (esil, before);\n\tr_core_esil_step (core, end, NULL, &prev);\n\teprintf (\"Before 0x%08\"PFMT64x\"\\n\", prev);\n\tr_anal_esil_session_set (esil, before);\n\tr_core_esil_step (core, prev, NULL, NULL);\n\treturn 1;\n}\n\nstatic void cmd_address_info(RCore *core, const char *addrstr, int fmt) {\n\tut64 addr, type;\n\tif (!addrstr || !*addrstr) {\n\t\taddr = core->offset;\n\t} else {\n\t\taddr = r_num_math (core->num, addrstr);\n\t}\n\ttype = r_core_anal_address (core, addr);\n\tint isp = 0;\n\tswitch (fmt) {\n\tcase 'j':\n#define COMMA isp++? \",\": \"\"\n\t\tr_cons_printf (\"{\");\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM)\n\t\t\tr_cons_printf (\"%s\\\"program\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY)\n\t\t\tr_cons_printf (\"%s\\\"library\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC)\n\t\t\tr_cons_printf (\"%s\\\"exec\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_READ)\n\t\t\tr_cons_printf (\"%s\\\"read\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE)\n\t\t\tr_cons_printf (\"%s\\\"write\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_FLAG)\n\t\t\tr_cons_printf (\"%s\\\"flag\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_FUNC)\n\t\t\tr_cons_printf (\"%s\\\"func\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_STACK)\n\t\t\tr_cons_printf (\"%s\\\"stack\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP)\n\t\t\tr_cons_printf (\"%s\\\"heap\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_REG)\n\t\t\tr_cons_printf (\"%s\\\"reg\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII)\n\t\t\tr_cons_printf (\"%s\\\"ascii\\\":true\", COMMA);\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE)\n\t\t\tr_cons_printf (\"%s\\\"sequence\\\":true\", COMMA);\n\t\tr_cons_print (\"}\");\n\t\tbreak;\n\tdefault:\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM)\n\t\t\tr_cons_printf (\"program\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY)\n\t\t\tr_cons_printf (\"library\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC)\n\t\t\tr_cons_printf (\"exec\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_READ)\n\t\t\tr_cons_printf (\"read\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE)\n\t\t\tr_cons_printf (\"write\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_FLAG)\n\t\t\tr_cons_printf (\"flag\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_FUNC)\n\t\t\tr_cons_printf (\"func\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_STACK)\n\t\t\tr_cons_printf (\"stack\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP)\n\t\t\tr_cons_printf (\"heap\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_REG)\n\t\t\tr_cons_printf (\"reg\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII)\n\t\t\tr_cons_printf (\"ascii\\n\");\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE)\n\t\t\tr_cons_printf (\"sequence\\n\");\n\t}\n}\n\nstatic void cmd_anal_info(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '?':\n\t\teprintf (\"Usage: ai @ rsp\\n\");\n\t\tbreak;\n\tcase ' ':\n\t\tcmd_address_info (core, input, 0);\n\t\tbreak;\n\tcase 'j': // \"aij\"\n\t\tcmd_address_info (core, input + 1, 'j');\n\t\tbreak;\n\tdefault:\n\t\tcmd_address_info (core, NULL, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void initialize_stack (RCore *core, ut64 addr, ut64 size) {\n\tconst char *mode = r_config_get (core->config, \"esil.fillstack\");\n\tif (mode && *mode && *mode != '0') {\n\t\tconst int bs = 4096 * 32;\n\t\tut64 i;\n\t\tfor (i = 0; i < size; i += bs) {\n\t\t\tint left = R_MIN (bs, size - i);\n\t\t//\tr_core_cmdf (core, \"wx 10203040 @ 0x%llx\", addr);\n\t\t\tswitch (*mode) {\n\t\t\tcase 'd': // \"debrujn\"\n\t\t\t\tr_core_cmdf (core, \"wopD %\"PFMT64d\" @ 0x%\"PFMT64x, left, addr + i);\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"seq\"\n\t\t\t\tr_core_cmdf (core, \"woe 1 0xff 1 4 @ 0x%\"PFMT64x\"!0x%\"PFMT64x, addr + i, left);\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"random\"\n\t\t\t\tr_core_cmdf (core, \"woR %\"PFMT64d\" @ 0x%\"PFMT64x\"!0x%\"PFMT64x, left, addr + i, left);\n\t\t\t\tbreak;\n\t\t\tcase 'z': // \"zero\"\n\t\t\tcase '0':\n\t\t\t\tr_core_cmdf (core, \"wow 00 @ 0x%\"PFMT64x\"!0x%\"PFMT64x, addr + i, left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// eprintf (\"[*] Initializing ESIL stack with pattern\\n\");\n\t\t// r_core_cmdf (core, \"woe 0 10 4 @ 0x%\"PFMT64x, size, addr);\n\t}\n}\n\nstatic void cmd_esil_mem(RCore *core, const char *input) {\n\tRAnalEsil *esil = core->anal->esil;\n\tRIOMap *stack_map;\n\tut64 curoff = core->offset;\n\tconst char *patt = \"\";\n\tut64 addr = 0x100000;\n\tut32 size = 0xf0000;\n\tchar name[128];\n\tRFlagItem *fi;\n\tconst char *sp, *pc;\n\tchar uri[32];\n\tchar nomalloc[256];\n\tchar *p;\n\tif (!esil) {\n\t\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\t\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\t\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\t\tint stats = r_config_get_i (core->config, \"esil.stats\");\n\t\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\t\tint verbose = r_config_get_i (core->config, \"esil.verbose\");\n\t\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\t\tif (!(esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\t\tcore->anal->esil = esil;\n\t\tesil->verbose = verbose;\n\t\t{\n\t\t\tconst char *s = r_config_get (core->config, \"cmd.esil.intr\");\n\t\t\tif (s) {\n\t\t\t\tchar *my = strdup (s);\n\t\t\t\tif (my) {\n\t\t\t\t\tr_config_set (core->config, \"cmd.esil.intr\", my);\n\t\t\t\t\tfree (my);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (*input == '?') {\n\t\teprintf (\"Usage: aeim [addr] [size] [name] - initialize ESIL VM stack\\n\");\n\t\teprintf (\"Default: 0x100000 0xf0000\\n\");\n\t\teprintf (\"See ae? for more help\\n\");\n\t\treturn;\n\t}\n\n\tif (input[0] == 'p') {\n\t\tfi = r_flag_get (core->flags, \"aeim.stack\");\n\t\tif (fi) {\n\t\t\taddr = fi->offset;\n\t\t\tsize = fi->size;\n\t\t} else {\n\t\t\tcmd_esil_mem (core, \"\");\n\t\t}\n\t\tif (esil) {\n\t\t\tesil->stack_addr = addr;\n\t\t\tesil->stack_size = size;\n\t\t}\n\t\tinitialize_stack (core, addr, size);\n\t\treturn;\n\t}\n\n\tif (!*input) {\n\t\tRFlagItem *fi = r_flag_get (core->flags, \"aeim.fd\");\n\t\tif (fi) {\n\t\t\t// Close the fd associated with the aeim stack\n\t\t\t(void)r_io_fd_close (core->io, fi->offset);\n\t\t}\n\t}\n\taddr = r_config_get_i (core->config, \"esil.stack.addr\");\n\tsize = r_config_get_i (core->config, \"esil.stack.size\");\n\tpatt = r_config_get (core->config, \"esil.stack.pattern\");\n\n\tp = strncpy (nomalloc, input, 255);\n\tif ((p = strchr (p, ' '))) {\n\t\twhile (*p == ' ') p++;\n\t\taddr = r_num_math (core->num, p);\n\t\tif ((p = strchr (p, ' '))) {\n\t\t\twhile (*p == ' ') p++;\n\t\t\tsize = (ut32)r_num_math (core->num, p);\n\t\t\tif (size < 1) {\n\t\t\t\tsize = 0xf0000;\n\t\t\t}\n\t\t\tif ((p = strchr (p, ' '))) {\n\t\t\t\twhile (*p == ' ') p++;\n\t\t\t\tsnprintf (name, sizeof (name), \"mem.%s\", p);\n\t\t\t} else {\n\t\t\t\tsnprintf (name, sizeof (name), \"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf (name, sizeof (name), \"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t\t}\n\t} else {\n\t\tsnprintf (name, sizeof (name), \"mem.0x%\" PFMT64x \"_0x%x\", addr, size);\n\t}\n\tif (*input == '-') {\n\t\tif (esil->stack_fd > 2) {\t//0, 1, 2 are reserved for stdio/stderr\n\t\t\tr_io_fd_close (core->io, esil->stack_fd);\n\t\t\t// no need to kill the maps, r_io_map_cleanup does that for us in the close\n\t\t\tesil->stack_fd = 0;\n\t\t} else {\n\t\t\teprintf (\"Cannot deinitialize %s\\n\", name);\n\t\t}\n\t\tr_flag_unset_name (core->flags, name);\n\t\t// eprintf (\"Deinitialized %s\\n\", name);\n\t\treturn;\n\t}\n\n\tsnprintf (uri, sizeof (uri), \"malloc://%d\", (int)size);\n\tesil->stack_fd = r_io_fd_open (core->io, uri, R_IO_RW, 0);\n\tif (!(stack_map = r_io_map_add (core->io, esil->stack_fd,\n\t\t\tR_IO_RW, 0LL, addr, size, true))) {\n\t\tr_io_fd_close (core->io, esil->stack_fd);\n\t\teprintf (\"Cannot create map for tha stack, fd %d got closed again\\n\", esil->stack_fd);\n\t\tesil->stack_fd = 0;\n\t\treturn;\n\t}\n\tr_io_map_set_name (stack_map, name);\n\t// r_flag_set (core->flags, name, addr, size);\t//why is this here?\n\tr_flag_set (core->flags, \"aeim.stack\", addr, size);\n\tr_flag_set (core->flags, \"aeim.fd\", esil->stack_fd, 1);\n\tr_config_set_i (core->config, \"io.va\", true);\n\tif (patt && *patt) {\n\t\tswitch (*patt) {\n\t\tcase '0':\n\t\t\t// do nothing\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tr_core_cmdf (core, \"wopD %d @ 0x%\"PFMT64x, size, addr);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tr_core_cmdf (core, \"woe 0 255 1 @ 0x%\"PFMT64x\"!%d\",addr, size);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tr_core_cmdf (core, \"woe 0 0xffff 1 4 @ 0x%\"PFMT64x\"!%d\",addr, size);\n\t\t\tbreak;\n\t\t}\n\t}\n\t// SP\n\tsp = r_reg_get_name (core->dbg->reg, R_REG_NAME_SP);\n\tr_debug_reg_set (core->dbg, sp, addr + (size / 2));\n\t// BP\n\tsp = r_reg_get_name (core->dbg->reg, R_REG_NAME_BP);\n\tr_debug_reg_set (core->dbg, sp, addr + (size / 2));\n\t// PC\n\tpc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\tr_debug_reg_set (core->dbg, pc, curoff);\n\tr_core_cmd0 (core, \".ar*\");\n#if 0\n\tif (!r_io_section_get_name (core->io, ESIL_STACK_NAME)) {\n\t\tr_core_cmdf (core, \"om %d 0x%\"PFMT64x, cf->fd, addr);\n\t\tr_core_cmdf (core, \"S 0x%\"PFMT64x\" 0x%\"PFMT64x\" %d %d \"\n\t\t\tESIL_STACK_NAME, addr, addr, size, size);\n\t}\n#endif\n\tif (esil) {\n\t\tesil->stack_addr = addr;\n\t\tesil->stack_size = size;\n\t}\n\tinitialize_stack (core, addr, size);\n\tr_core_seek (core, curoff, 0);\n}\n\n#if 0\nstatic ut64 opc = UT64_MAX;\nstatic ut8 *regstate = NULL;\n\nstatic void esil_init (RCore *core) {\n\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\topc = r_reg_getv (core->anal->reg, pc);\n\tif (!opc || opc==UT64_MAX) {\n\t\topc = core->offset;\n\t}\n\tif (!core->anal->esil) {\n\t\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\t\tut64 stackSize = r_config_get_i (core->config, \"esil.stack.size\");\n\t\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\t\tif (!(core->anal->esil = r_anal_esil_new (stackSize, iotrap, addrsize))) {\n\t\t\tR_FREE (regstate);\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_setup (core->anal->esil, core->anal, 0, 0, noNULL);\n\t}\n\tfree (regstate);\n\tregstate = r_reg_arena_peek (core->anal->reg);\n}\n\nstatic void esil_fini(RCore *core) {\n\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tr_reg_arena_poke (core->anal->reg, regstate);\n\tr_reg_setv (core->anal->reg, pc, opc);\n\tR_FREE (regstate);\n}\n#endif\n\ntypedef struct {\n\tRList *regs;\n\tRList *regread;\n\tRList *regwrite;\n\tRList *inputregs;\n} AeaStats;\n\nstatic void aea_stats_init (AeaStats *stats) {\n\tstats->regs = r_list_newf (free);\n\tstats->regread = r_list_newf (free);\n\tstats->regwrite = r_list_newf (free);\n\tstats->inputregs = r_list_newf (free);\n}\n\nstatic void aea_stats_fini (AeaStats *stats) {\n\tR_FREE (stats->regs);\n\tR_FREE (stats->regread);\n\tR_FREE (stats->regwrite);\n\tR_FREE (stats->inputregs);\n}\n\nstatic bool contains(RList *list, const char *name) {\n\tRListIter *iter;\n\tconst char *n;\n\tr_list_foreach (list, iter, n) {\n\t\tif (!strcmp (name, n))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic char *oldregread = NULL;\nstatic RList *mymemxsr = NULL;\nstatic RList *mymemxsw = NULL;\n\n#define R_NEW_DUP(x) memcpy((void*)malloc(sizeof(x)), &(x), sizeof(x))\ntypedef struct {\n\tut64 addr;\n\tint size;\n} AeaMemItem;\n\nstatic int mymemwrite(RAnalEsil *esil, ut64 addr, const ut8 *buf, int len) {\n\tRListIter *iter;\n\tAeaMemItem *n;\n\tr_list_foreach (mymemxsw, iter, n) {\n\t\tif (addr == n->addr) {\n\t\t\treturn len;\n\t\t}\n\t}\n\tif (!r_io_is_valid_offset (esil->anal->iob.io, addr, 0)) {\n\t\treturn false;\n\t}\n\tn = R_NEW (AeaMemItem);\n\tif (n) {\n\t\tn->addr = addr;\n\t\tn->size = len;\n\t\tr_list_push (mymemxsw, n);\n\t}\n\treturn len;\n}\n\nstatic int mymemread(RAnalEsil *esil, ut64 addr, ut8 *buf, int len) {\n\tRListIter *iter;\n\tAeaMemItem *n;\n\tr_list_foreach (mymemxsr, iter, n) {\n\t\tif (addr == n->addr) {\n\t\t\treturn len;\n\t\t}\n\t}\n\tif (!r_io_is_valid_offset (esil->anal->iob.io, addr, 0)) {\n\t\treturn false;\n\t}\n\tn = R_NEW (AeaMemItem);\n\tif (n) {\n\t\tn->addr = addr;\n\t\tn->size = len;\n\t\tr_list_push (mymemxsr, n);\n\t}\n\treturn len;\n}\n\nstatic int myregwrite(RAnalEsil *esil, const char *name, ut64 *val) {\n\tAeaStats *stats = esil->user;\n\tif (oldregread && !strcmp (name, oldregread)) {\n\t\tr_list_pop (stats->regread);\n\t\tR_FREE (oldregread)\n\t}\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regwrite, name)) {\n\t\t\tr_list_push (stats->regwrite, strdup (name));\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int myregread(RAnalEsil *esil, const char *name, ut64 *val, int *len) {\n\tAeaStats *stats = esil->user;\n\tif (!IS_DIGIT (*name)) {\n\t\tif (!contains (stats->inputregs, name)) {\n\t\t\tif (!contains (stats->regwrite, name)) {\n\t\t\t\tr_list_push (stats->inputregs, strdup (name));\n\t\t\t}\n\t\t}\n\t\tif (!contains (stats->regs, name)) {\n\t\t\tr_list_push (stats->regs, strdup (name));\n\t\t}\n\t\tif (!contains (stats->regread, name)) {\n\t\t\tr_list_push (stats->regread, strdup (name));\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void showregs (RList *list) {\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tr_cons_print (reg);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_newline();\n}\n\nstatic void showregs_json (RList *list) {\n\tr_cons_printf (\"[\");\n\tif (!r_list_empty (list)) {\n\t\tchar *reg;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, reg) {\n\t\t\tr_cons_printf (\"\\\"%s\\\"\", reg);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_printf (\"]\");\n}\n\nstatic bool cmd_aea(RCore* core, int mode, ut64 addr, int length) {\n\tRAnalEsil *esil;\n\tint ptr, ops, ops_end = 0, len, buf_sz, maxopsize;\n\tut64 addr_end;\n\tAeaStats stats;\n\tconst char *esilstr;\n\tRAnalOp aop = R_EMPTY;\n\tut8 *buf;\n\tRList* regnow;\n\tif (!core) {\n\t\treturn false;\n\t}\n\tmaxopsize = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\tif (maxopsize < 1) {\n\t\tmaxopsize = 16;\n\t}\n\tif (mode & 1) {\n\t\t// number of bytes / length\n\t\tbuf_sz = length;\n\t} else {\n\t\t// number of instructions / opcodes\n\t\tops_end = length;\n\t\tif (ops_end < 1) {\n\t\t\tops_end = 1;\n\t\t}\n\t\tbuf_sz = ops_end * maxopsize;\n\t}\n\tif (buf_sz < 1) {\n\t\tbuf_sz = maxopsize;\n\t}\n\taddr_end = addr + buf_sz;\n\tbuf = malloc (buf_sz);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\t(void)r_io_read_at (core->io, addr, (ut8 *)buf, buf_sz);\n\taea_stats_init (&stats);\n\n\t//esil_init (core);\n\t//esil = core->anal->esil;\n\tr_reg_arena_push (core->anal->reg);\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tbool iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\tint stats1 = r_config_get_i (core->config, \"esil.stats\");\n\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tesil = r_anal_esil_new (stacksize, iotrap, addrsize);\n\tr_anal_esil_setup (esil, core->anal, romem, stats1, noNULL); // setup io\n#\tdefine hasNext(x) (x&1) ? (addr<addr_end) : (ops<ops_end)\n\n\tmymemxsr = r_list_new ();\n\tmymemxsw = r_list_new ();\n\tesil->user = &stats;\n\tesil->cb.hook_reg_write = myregwrite;\n\tesil->cb.hook_reg_read = myregread;\n\tesil->cb.hook_mem_write = mymemwrite;\n\tesil->cb.hook_mem_read = mymemread;\n\tesil->nowrite = true;\n\tfor (ops = ptr = 0; ptr < buf_sz && hasNext (mode); ops++, ptr += len) {\n\t\tlen = r_anal_op (core->anal, &aop, addr + ptr, buf + ptr, buf_sz - ptr, R_ANAL_OP_MASK_ALL);\n\t\tesilstr = R_STRBUF_SAFEGET (&aop.esil);\n\t\tif (len < 1) {\n\t\t\teprintf (\"Invalid 0x%08\"PFMT64x\" instruction %02x %02x\\n\",\n\t\t\t\taddr + ptr, buf[ptr], buf[ptr + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_parse (esil, esilstr);\n\t\tr_anal_esil_stack_free (esil);\n\t}\n\tesil->nowrite = false;\n\tesil->cb.hook_reg_write = NULL;\n\tesil->cb.hook_reg_read = NULL;\n\t//esil_fini (core);\n\tr_anal_esil_free (esil);\n\tr_reg_arena_pop (core->anal->reg);\n\tregnow = r_list_newf (free);\n\t{\n\t\tRListIter *iter;\n\t\tchar *reg;\n\t\tr_list_foreach (stats.regs, iter, reg) {\n\t\t\tif (!contains (stats.regwrite, reg)) {\n\t\t\t\tr_list_push (regnow, strdup (reg));\n\t\t\t}\n\t\t}\n\t}\n\tif ((mode >> 5) & 1) {\n\t\tRListIter *iter;\n\t\tAeaMemItem *n;\n\t\tint c = 0;\n\t\tr_cons_printf (\"f-mem.*\\n\");\n\t\tr_list_foreach (mymemxsr, iter, n) {\n\t\t\tr_cons_printf (\"f mem.read.%d 0x%08x @ 0x%08\"PFMT64x\"\\n\", c++, n->size, n->addr);\n\t\t}\n\t\tc = 0;\n\t\tr_list_foreach (mymemxsw, iter, n) {\n\t\t\tr_cons_printf (\"f mem.write.%d 0x%08x @ 0x%08\"PFMT64x\"\\n\", c++, n->size, n->addr);\n\t\t}\n\t}\n\n\t/* show registers used */\n\tif ((mode >> 1) & 1) {\n\t\tshowregs (stats.regread);\n\t} else if ((mode >> 2) & 1) {\n\t\tshowregs (stats.regwrite);\n\t} else if ((mode >> 3) & 1) {\n\t\tshowregs (regnow);\n\t} else if ((mode >> 4) & 1) {\n\t\tr_cons_printf (\"{\\\"A\\\":\");\n\t\tshowregs_json (stats.regs);\n\t\tr_cons_printf (\",\\\"I\\\":\");\n\t\tshowregs_json (stats.inputregs);\n\t\tr_cons_printf (\",\\\"R\\\":\");\n\t\tshowregs_json (stats.regread);\n\t\tr_cons_printf (\",\\\"W\\\":\");\n\t\tshowregs_json (stats.regwrite);\n\t\tr_cons_printf (\",\\\"N\\\":\");\n\t\tshowregs_json (regnow);\n\t\tr_cons_printf (\"}\");\n\t\tr_cons_newline();\n\t} else if ((mode >> 5) & 1) {\n\t\t// nothing\n\t} else {\n\t\tr_cons_printf (\" I: \");\n\t\tshowregs (stats.inputregs);\n\t\tr_cons_printf (\" A: \");\n\t\tshowregs (stats.regs);\n\t\tr_cons_printf (\" R: \");\n\t\tshowregs (stats.regread);\n\t\tr_cons_printf (\" W: \");\n\t\tshowregs (stats.regwrite);\n\t\tr_cons_printf (\"NW: \");\n\t\tif (r_list_length (regnow)) {\n\t\t\tshowregs (regnow);\n\t\t} else {\n\t\t\tr_cons_newline();\n\t\t}\n\t\tRListIter *iter;\n\t\tut64 *n;\n\t\tif (!r_list_empty (mymemxsr)) {\n\t\t\tr_cons_printf (\"@R:\");\n\t\t\tr_list_foreach (mymemxsr, iter, n) {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, *n);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tif (!r_list_empty (mymemxsw)) {\n\t\t\tr_cons_printf (\"@W:\");\n\t\t\tr_list_foreach (mymemxsw, iter, n) {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, *n);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\tr_list_free (mymemxsr);\n\tr_list_free (mymemxsw);\n\tmymemxsr = NULL;\n\tmymemxsw = NULL;\n\taea_stats_fini (&stats);\n\tfree (buf);\n\tR_FREE (regnow);\n\treturn true;\n}\n\nstatic void cmd_aespc(RCore *core, ut64 addr, int off) {\n\tRAnalEsil *esil = core->anal->esil;\n\tint i, j = 0;\n\tint instr_size = 0;\n\tut8 *buf;\n\tRAnalOp aop = {0};\n\tint ret , bsize = R_MAX (64, core->blocksize);\n\tconst int mininstrsz = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = R_MAX (1, mininstrsz);\n\tconst char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\tRRegItem *r = r_reg_get (core->dbg->reg, pc, -1);\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\n\tif (!esil) {\n\t\tif (!(esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\t\treturn;\n\t\t}\n\t}\n\tbuf = malloc (bsize);\n\tif (!buf) {\n\t\teprintf (\"Cannot allocate %d byte(s)\\n\", bsize);\n\t\tfree (buf);\n\t\treturn;\n\t}\n\tif (addr == -1) {\n\t\taddr = r_debug_reg_get (core->dbg, pc);\n\t}\n\tut64 curpc = addr;\n\tut64 oldoff = core->offset;\n\tfor (i = 0, j = 0; j < off ; i++, j++) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= (bsize - 32)) {\n\t\t\ti = 0;\n\t\t}\n\t\tif (!i) {\n\t\t\tr_core_read_at (core, addr, buf, bsize);\n\t\t}\n\t\tret = r_anal_op (core->anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_ALL);\n\t\tinstr_size += ret;\n\t\tint inc = (core->search->align > 0)? core->search->align - 1: ret - 1;\n\t\tif (inc < 0) {\n\t\t\tinc = minopcode;\n\t\t}\n\t\ti += inc;\n\t\taddr += inc;\n\t\tr_anal_op_fini (&aop);\n\t}\n\tr_reg_set_value (core->dbg->reg, r, curpc);\n\tr_core_esil_step (core, curpc + instr_size, NULL, NULL);\n\tr_core_seek (core, oldoff, 1);\n}\n\nstatic void cmd_anal_esil(RCore *core, const char *input) {\n\tRAnalEsil *esil = core->anal->esil;\n\tut64 addr = core->offset;\n\tut64 adr ;\n\tchar *n, *n1;\n\tint off;\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tint iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tint romem = r_config_get_i (core->config, \"esil.romem\");\n\tint stats = r_config_get_i (core->config, \"esil.stats\");\n\tint noNULL = r_config_get_i (core->config, \"esil.noNULL\");\n\tut64 until_addr = UT64_MAX;\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\n\tconst char *until_expr = NULL;\n\tRAnalOp *op;\n\n\tswitch (input[0]) {\n\tcase 'p': // \"aep\"\n\t\tswitch (input[1]) {\n\t\tcase 'c':\n\t\t\tif (input[2] == ' ') {\n\t\t\t\t// seek to this address\n\t\t\t\tr_core_cmdf (core, \"ar PC=%s\", input + 3);\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t} else {\n\t\t\t\teprintf (\"Missing argument\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tr_anal_pin_list (core->anal);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (input[2])\n\t\t\t\taddr = r_num_math (core->num, input + 2);\n\t\t\tr_anal_pin_unset (core->anal, addr);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tr_anal_pin (core->anal, addr, input + 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_aep);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"aer\"\n\t\t// 'aer' is an alias for 'ar'\n\t\tcmd_anal_reg (core, input + 1);\n\t\tbreak;\n\tcase '*':\n\t\t// XXX: this is wip, not working atm\n\t\tif (core->anal->esil) {\n\t\t\tr_cons_printf (\"trap: %d\\n\", core->anal->esil->trap);\n\t\t\tr_cons_printf (\"trap-code: %d\\n\", core->anal->esil->trap_code);\n\t\t} else {\n\t\t\teprintf (\"esil vm not initialized. run `aei`\\n\");\n\t\t}\n\t\tbreak;\n\tcase ' ':\n\t\t//r_anal_esil_eval (core->anal, input+1);\n\t\tif (!esil) {\n\t\t\tif (!(core->anal->esil = esil = r_anal_esil_new (stacksize, iotrap, addrsize)))\n\t\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\t\tr_anal_esil_set_pc (esil, core->offset);\n\t\tr_anal_esil_parse (esil, input + 1);\n\t\tr_anal_esil_dumpstack (esil);\n\t\tr_anal_esil_stack_free (esil);\n\t\tbreak;\n\tcase 's': // \"aes\"\n\t\t// \"aes\" \"aeso\" \"aesu\" \"aesue\"\n\t\t// aes -> single step\n\t\t// aesb -> single step back\n\t\t// aeso -> single step over\n\t\t// aesu -> until address\n\t\t// aesue -> until esil expression\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\teprintf (\"See: ae?~aes\\n\");\n\t\t\tbreak;\n\t\tcase 'l': // \"aesl\"\n\t\t{\n\t\t\tut64 pc = r_debug_reg_get (core->dbg, \"PC\");\n\t\t\tRAnalOp *op = r_core_anal_op (core, pc);\n// TODO: honor hint\n\t\t\tif (!op) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL);\n\t\t\tr_debug_reg_set (core->dbg, \"PC\", pc + op->size);\n\t\t\tr_anal_esil_set_pc (esil, pc + op->size);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t} break;\n\t\tcase 'b': // \"aesb\"\n\t\t\tif (!r_core_esil_step_back (core)) {\n\t\t\t\teprintf (\"cannnot step back\\n\");\n\t\t\t}\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'u': // \"aesu\"\n\t\t\tif (input[2] == 'e') {\n\t\t\t\tuntil_expr = input + 3;\n\t\t\t} else {\n\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\t}\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'o': // \"aeso\"\n\t\t\t// step over\n\t\t\top = r_core_anal_op (core, r_reg_getv (core->anal->reg,\n\t\t\t\tr_reg_get_name (core->anal->reg, R_REG_NAME_PC)));\n\t\t\tif (op && op->type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\tuntil_addr = op->addr + op->size;\n\t\t\t}\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\tr_anal_op_free (op);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\tcase 'p': //\"aesp\"\n\t\t\tn = strchr (input, ' ');\n\t\t\tn1 = n ? strchr (n + 1, ' ') : NULL;\n\t\t\tif ((!n || !n1) || (!(n + 1) || !(n1 + 1))) {\n\t\t\t\teprintf (\"aesp [offset] [num]\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadr = r_num_math (core->num, n + 1);\n\t\t\toff = r_num_math (core->num, n1 + 1);\n\t\t\tcmd_aespc (core, adr, off);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tn = strchr (input, ' ');\n\t\t\tif (!(n + 1)) {\n\t\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toff = r_num_math (core->num, n + 1);\n\t\t\tcmd_aespc (core, -1, off);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aec\"\n\t\tif (input[1] == '?') { // \"aec?\"\n\t\t\tr_core_cmd_help (core, help_msg_aec);\n\t\t} else if (input[1] == 's') { // \"aecs\"\n\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\tut64 newaddr;\n\t\t\tint ret;\n\t\t\tfor (;;) {\n\t\t\t\top = r_core_anal_op (core, addr);\n\t\t\t\tif (!op) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_SWI) {\n\t\t\t\t\teprintf (\"syscall at 0x%08\" PFMT64x \"\\n\", addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_TRAP) {\n\t\t\t\t\teprintf (\"trap at 0x%08\" PFMT64x \"\\n\", addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = r_core_esil_step (core, UT64_MAX, NULL, NULL);\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\top = NULL;\n\t\t\t\tif (core->anal->esil->trap || core->anal->esil->trap_code) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\t\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t\t\tnewaddr = r_num_get (core->num, pc);\n\t\t\t\tif (addr == newaddr) {\n\t\t\t\t\taddr++;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\taddr = newaddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t}\n\t\t} else {\n\t\t\t// \"aec\"  -> continue until ^C\n\t\t\t// \"aecu\" -> until address\n\t\t\t// \"aecue\" -> until esil expression\n\t\t\tif (input[1] == 'u' && input[2] == 'e')\n\t\t\t\tuntil_expr = input + 3;\n\t\t\telse if (input[1] == 'u')\n\t\t\t\tuntil_addr = r_num_math (core->num, input + 2);\n\t\t\telse until_expr = \"0\";\n\t\t\tr_core_esil_step (core, until_addr, until_expr, NULL);\n\t\t\tr_core_cmd0 (core, \".ar*\");\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"aei\"\n\t\tswitch (input[1]) {\n\t\tcase 's':\n\t\tcase 'm': // \"aeim\"\n\t\t\tcmd_esil_mem (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'p': // initialize pc = $$\n\t\t\tr_core_cmd0 (core, \"ar PC=$$\");\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tcmd_esil_mem (core, \"?\");\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (esil) {\n\t\t\t\tsdb_reset (esil->stats);\n\t\t\t}\n\t\t\tr_anal_esil_free (esil);\n\t\t\tcore->anal->esil = NULL;\n\t\t\tbreak;\n\t\tcase 0:\t\t\t\t//lolololol\n\t\t\tr_anal_esil_free (esil);\n\t\t\t// reinitialize\n\t\t\t{\n\t\t\t\tconst char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\t\t\t\tif (r_reg_getv (core->anal->reg, pc) == 0LL) {\n\t\t\t\t\tr_core_cmd0 (core, \"ar PC=$$\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(esil = core->anal->esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tr_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io\n\t\t\tesil->verbose = (int)r_config_get_i (core->config, \"esil.verbose\");\n\t\t\t/* restore user settings for interrupt handling */\n\t\t\t{\n\t\t\t\tconst char *s = r_config_get (core->config, \"cmd.esil.intr\");\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *my = strdup (s);\n\t\t\t\t\tif (my) {\n\t\t\t\t\t\tr_config_set (core->config, \"cmd.esil.intr\", my);\n\t\t\t\t\t\tfree (my);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"aek\"\n\t\tswitch (input[1]) {\n\t\tcase '\\0':\n\t\t\tinput = \"123*\";\n\t\t\t/* fall through */\n\t\tcase ' ':\n\t\t\tif (esil && esil->stats) {\n\t\t\t\tchar *out = sdb_querys (esil->stats, NULL, 0, input + 2);\n\t\t\t\tif (out) {\n\t\t\t\t\tr_cons_println (out);\n\t\t\t\t\tfree (out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"esil.stats is empty. Run 'aei'\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (esil) {\n\t\t\t\tsdb_reset (esil->stats);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"aef\"\n\t{\n\t\tRListIter *iter;\n\t\tRAnalBlock *bb;\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal,\n\t\t\t\t\t\t\tcore->offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\tif (fcn) {\n\t\t\t// emulate every instruction in the function recursively across all the basic blocks\n\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\tut64 pc = bb->addr;\n\t\t\t\tut64 end = bb->addr + bb->size;\n\t\t\t\tRAnalOp op;\n\t\t\t\tut8 *buf;\n\t\t\t\tint ret, bbs = end - pc;\n\t\t\t\tif (bbs < 1 || bbs > 0xfffff) {\n\t\t\t\t\teprintf (\"Invalid block size\\n\");\n\t\t\t\t}\n\t\t//\t\teprintf (\"[*] Emulating 0x%08\"PFMT64x\" basic block 0x%08\" PFMT64x \" - 0x%08\" PFMT64x \"\\r[\", fcn->addr, pc, end);\n\t\t\t\tbuf = calloc (1, bbs + 1);\n\t\t\t\tr_io_read_at (core->io, pc, buf, bbs);\n\t\t\t\tint left;\n\t\t\t\twhile (pc < end) {\n\t\t\t\t\tleft = R_MIN (end - pc, 32);\n\t\t\t\t\tr_asm_set_pc (core->assembler, pc);\n\t\t\t\t\tret = r_anal_op (core->anal, &op, addr, buf, left, R_ANAL_OP_MASK_ALL); // read overflow\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tr_reg_set_value_by_role (core->anal->reg, R_REG_NAME_PC, pc);\n\t\t\t\t\t\tr_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op.esil));\n\t\t\t\t\t\tr_anal_esil_dumpstack (esil);\n\t\t\t\t\t\tr_anal_esil_stack_free (esil);\n\t\t\t\t\t\tpc += op.size;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpc += 4; // XXX\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot find function at 0x%08\" PFMT64x \"\\n\", core->offset);\n\t\t}\n\t} break;\n\tcase 't': // \"aet\"\n\t\tswitch (input[1]) {\n\t\tcase 'r': // \"aetr\"\n\t\t{\n\t\t\t// anal ESIL to REIL.\n\t\t\tRAnalEsil *esil = r_anal_esil_new (stacksize, iotrap, addrsize);\n\t\t\tif (!esil) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tr_anal_esil_to_reil_setup (esil, core->anal, romem, stats);\n\t\t\tr_anal_esil_set_pc (esil, core->offset);\n\t\t\tr_anal_esil_parse (esil, input + 2);\n\t\t\tr_anal_esil_dumpstack (esil);\n\t\t\tr_anal_esil_free (esil);\n\t\t\tbreak;\n\t\t}\n\t\tcase 's': // \"aets\"\n\t\t\tswitch (input[2]) {\n\t\t\tcase 0:\n\t\t\t\tr_anal_esil_session_list (esil);\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tr_anal_esil_session_add (esil);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_core_cmd_help (core, help_msg_aets);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown command. Use `aetr`.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'A': // \"aeA\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aea);\n\t\t} else if (input[1] == 'r') {\n\t\t\tcmd_aea (core, 1 + (1<<1), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'w') {\n\t\t\tcmd_aea (core, 1 + (1<<2), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'n') {\n\t\t\tcmd_aea (core, 1 + (1<<3), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'j') {\n\t\t\tcmd_aea (core, 1 + (1<<4), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == '*') {\n\t\t\tcmd_aea (core, 1 + (1<<5), core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'f') {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\t\t\tif (fcn) {\n\t\t\t\tcmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));\n\t\t\t}\n\t\t} else {\n\t\t\tcmd_aea (core, 1, core->offset, (int)r_num_math (core->num, input+2));\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"aea\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_aea);\n\t\t} else if (input[1] == 'r') {\n\t\t\tcmd_aea (core, 1<<1, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'w') {\n\t\t\tcmd_aea (core, 1<<2, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'n') {\n\t\t\tcmd_aea (core, 1<<3, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'j') {\n\t\t\tcmd_aea (core, 1<<4, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == '*') {\n\t\t\tcmd_aea (core, 1<<5, core->offset, r_num_math (core->num, input+2));\n\t\t} else if (input[1] == 'f') {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n                        // \"aeafj\"\n\t\t\tif (fcn) {\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase 'j': // \"aeafj\"\n\t\t\t\t\tcmd_aea (core, 1<<4, fcn->addr, r_anal_fcn_size (fcn));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *arg = input[1]? input + 2: \"\";\n\t\t\tut64 len = r_num_math (core->num, arg);\n\t\t\tcmd_aea (core, 0, core->offset, len);\n\t\t}\n\t\tbreak;\n\tcase 'x': { // \"aex\"\n\t\tchar *hex;\n\t\tint ret, bufsz;\n\n\t\tinput = r_str_trim_ro (input + 1);\n\t\thex = strdup (input);\n\t\tif (!hex) {\n\t\t\tbreak;\n\t\t}\n\n\t\tRAnalOp aop = R_EMPTY;\n\t\tbufsz = r_hex_str2bin (hex, (ut8*)hex);\n\t\tret = r_anal_op (core->anal, &aop, core->offset,\n\t\t\t(const ut8*)hex, bufsz, R_ANAL_OP_MASK_ALL);\n\t\tif (ret>0) {\n\t\t\tconst char *str = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\tchar *str2 = r_str_newf (\" %s\", str);\n\t\t\tcmd_anal_esil (core, str2);\n\t\t\tfree (str2);\n\t\t}\n\t\tr_anal_op_fini (&aop);\n\t\tbreak;\n\t}\n\tcase '?': // \"ae?\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_detail_ae);\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_ae);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_bytes(RCore *core, const char *input) {\n\tint len = core->blocksize;\n\tint tbs = len;\n\tif (input[0]) {\n\t\tlen = (int)r_num_get (core->num, input + 1);\n\t\tif (len > tbs) {\n\t\t\tr_core_block_size (core, len);\n\t\t}\n\t}\n\tcore_anal_bytes (core, core->block, len, 0, input[0]);\n\tif (tbs != core->blocksize) {\n\t\tr_core_block_size (core, tbs);\n\t}\n}\n\nstatic void cmd_anal_opcode(RCore *core, const char *input) {\n\tint l, len = core->blocksize;\n\tut32 tbs = core->blocksize;\n\n\tswitch (input[0]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ao);\n\t\tbreak;\n\tcase 's': // \"aos\"\n\tcase 'j': // \"aoj\"\n\tcase 'e': // \"aoe\"\n\tcase 'r': {\n\t\tint count = 1;\n\t\tif (input[1] && input[2]) {\n\t\t\tl = (int)r_num_get (core->num, input + 1);\n\t\t\tif (l > 0) {\n\t\t\t\tcount = l;\n\t\t\t}\n\t\t\tif (l > tbs) {\n\t\t\t\tr_core_block_size (core, l * 4);\n\t\t\t//\tlen = l;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = l = core->blocksize;\n\t\t\tcount = 1;\n\t\t}\n\t\tcore_anal_bytes (core, core->block, len, count, input[0]);\n\t\t}\n\t\tbreak;\n\tcase '*':\n\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\tbreak;\n\tdefault: {\n\t\tint count = 0;\n\t\tif (input[0]) {\n\t\t\tl = (int)r_num_get (core->num, input + 1);\n\t\t\tif (l > 0) {\n\t\t\t\tcount = l;\n\t\t\t}\n\t\t\tif (l > tbs) {\n\t\t\t\tr_core_block_size (core, l * 4);\n\t\t\t\t//len = l;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = l = core->blocksize;\n\t\t\tcount = 1;\n\t\t}\n\t\tcore_anal_bytes (core, core->block, len, count, 0);\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic void cmd_anal_jumps(RCore *core, const char *input) {\n\tr_core_cmdf (core, \"af @@= `ax~ref.code.jmp[1]`\");\n}\n\n// TODO: cleanup to reuse code\nstatic void cmd_anal_aftertraps(RCore *core, const char *input) {\n\tint bufi, minop = 1; // 4\n\tut8 *buf;\n\tRBinFile *binfile;\n\tRAnalOp op;\n\tut64 addr, addr_end;\n\tut64 len = r_num_math (core->num, input);\n\tif (len > 0xffffff) {\n\t\teprintf (\"Too big\\n\");\n\t\treturn;\n\t}\n\tbinfile = r_core_bin_cur (core);\n\tif (!binfile) {\n\t\teprintf (\"cur binfile NULL\\n\");\n\t\treturn;\n\t}\n\taddr = core->offset;\n\tif (!len) {\n\t\t// ignore search.in to avoid problems. analysis != search\n\t\tRIOSection *sec = r_io_section_vget (core->io, addr);\n\t\tif (sec && sec->flags & 1) {\n\t\t\t// search in current section\n\t\t\tif (sec->size > binfile->size) {\n\t\t\t\taddr = sec->vaddr;\n\t\t\t\tif (binfile->size > sec->paddr) {\n\t\t\t\t\tlen = binfile->size - sec->paddr;\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Opps something went wrong aac\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr = sec->vaddr;\n\t\t\t\tlen = sec->size;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sec && sec->vaddr != sec->paddr && binfile->size > (core->offset - sec->vaddr + sec->paddr)) {\n\t\t\t\tlen = binfile->size - (core->offset - sec->vaddr + sec->paddr);\n\t\t\t} else {\n\t\t\t\tif (binfile->size > core->offset) {\n\t\t\t\t\tlen = binfile->size - core->offset;\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Oops invalid range\\n\");\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taddr_end = addr + len;\n\tif (!(buf = malloc (4096))) {\n\t\treturn;\n\t}\n\tbufi = 0;\n\tint trapcount = 0;\n\tint nopcount = 0;\n\tr_cons_break_push (NULL, NULL);\n\twhile (addr < addr_end) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > 4000) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\tr_io_read_at (core->io, addr, buf, 4096);\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, 4096 - bufi, R_ANAL_OP_MASK_ALL)) {\n\t\t\tif (op.size < 1) {\n\t\t\t\t// XXX must be +4 on arm/mips/.. like we do in disasm.c\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_TRAP) {\n\t\t\t\ttrapcount ++;\n\t\t\t} else if (op.type == R_ANAL_OP_TYPE_NOP) {\n\t\t\t\tnopcount ++;\n\t\t\t} else {\n\t\t\t\tif (nopcount > 1) {\n\t\t\t\t\tr_cons_printf (\"af @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\tnopcount = 0;\n\t\t\t\t}\n\t\t\t\tif (trapcount > 0) {\n\t\t\t\t\tr_cons_printf (\"af @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\t\t\t\ttrapcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += (op.size > 0)? op.size : 1;\n\t\tbufi += (op.size > 0)? op.size : 1;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n}\n\nstatic void cmd_anal_blocks(RCore *core, const char *input) {\n\tut64 from , to;\n\tchar *arg = strchr (input, ' ');\n\tr_cons_break_push (NULL, NULL);\n#if 0\n\tls_foreach (core->io->sections, iter, s) {\n\t\t/* is executable */\n\t\tif (!(s->flags & R_IO_EXEC)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmin = s->vaddr;\n\t\tmax = s->vaddr + s->vsize;\n\t\tr_core_cmdf (core, \"abb%s 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, input, (max - min), min);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tgoto ctrl_c;\n\t\t}\n\t}\n\tif (ls_empty (core->io->sections)) {\n\t\tmin = core->offset;\n\t\tmax = 0xffff + min;\n\t\tr_core_cmdf (core, \"abb%s 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, input, (max - min), min);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tgoto ctrl_c;\n\t\t}\n\t}\n#endif\n\tif (!arg) {\n\t\tRList *list = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, \"anal\");\n\t\tRListIter *iter;\n\t\tRIOMap* map;\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tfrom = map->itv.addr;\n\t\t\tto = r_itv_end (map->itv);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto ctrl_c;\n\t\t\t}\n\t\t\tif (!from && !to) {\n\t\t\t\teprintf (\"Cannot determine search boundaries\\n\");\n\t\t\t} else if (to - from > UT32_MAX) {\n\t\t\t\teprintf (\"Skipping huge range\\n\");\n\t\t\t} else {\n\t\t\t\tr_core_cmdf (core, \"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, (to - from), from);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint sz = r_num_math (core->num, arg + 1);\n\t\tr_core_cmdf (core, \"abb 0x%08\"PFMT64x\" @ 0x%08\"PFMT64x, sz, core->offset);\n\t}\nctrl_c:\n\tr_cons_break_pop ();\n}\n\nstatic void _anal_calls(RCore *core, ut64 addr, ut64 addr_end) {\n\tRAnalOp op;\n\tint bufi;\n\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\tconst int addrbytes = core->io->addrbytes;\n\tconst int bsz = 4096;\n\tut8 *buf;\n\tut8 *block;\n\tbufi = 0;\n\tif (addr_end - addr > UT32_MAX) {\n\t\treturn;\n\t}\n\tbuf = malloc (bsz);\n\tblock = malloc (bsz);\n\tif (!buf || !block) {\n\t\teprintf (\"Error: cannot allocate buf or block\\n\");\n\t\tfree (buf);\n\t\tfree (block);\n\t\treturn;\n\t}\n\n\tint minop = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tif (minop < 1) {\n\t\tminop = 1;\n\t}\n\twhile (addr < addr_end) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > 4000) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\tr_io_read_at (core->io, addr, buf, bsz);\n\t\t}\n\t\tmemset (block, -1, bsz);\n\t\tif (!memcmp (buf, block, bsz)) {\n\t\t\t//eprintf (\"Error: skipping uninitialized block \\n\");\n\t\t\taddr += bsz;\n\t\t\tcontinue;\n\t\t}\n\t\tmemset (block, 0, bsz);\n\t\tif (!memcmp (buf, block, bsz)) {\n\t\t\t//eprintf (\"Error: skipping uninitialized block \\n\");\n\t\t\taddr += bsz;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, bsz - bufi, 0) > 0) {\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CALL) {\n#if JAYRO_03\n#error FUCK\n\t\t\t\tif (!anal_is_bad_call (core, from, to, addr, buf, bufi)) {\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, op.jump, R_ANAL_FCN_TYPE_ROOT);\n\t\t\t\t\tif (!fcn) {\n\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr,\n\t\t\t\t\t\t  R_ANAL_REF_TYPE_NULL, depth);\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\t// add xref here\n\t\t\t\tr_anal_xrefs_set (core->anal, R_ANAL_REF_TYPE_CALL, addr, op.jump);\n\t\t\t\tif (r_io_is_valid_offset (core->io, op.jump, 1)) {\n\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_NULL, depth);\n\t\t\t\t}\n#endif\n\t\t\t}\n\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\tif ((int)op.size < 1) {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += op.size;\n\t\tbufi += addrbytes * op.size;\n\t\tr_anal_op_fini (&op);\n\t}\n\tfree (buf);\n\tfree (block);\n}\n\nstatic void cmd_anal_calls(RCore *core, const char *input, bool only_print_flag) {\n\tRList *ranges = NULL;\n\tRIOMap *r;\n\tRBinFile *binfile;\n\tut64 addr;\n\tut64 len = r_num_math (core->num, input);\n\tif (len > 0xffffff) {\n\t\teprintf (\"Too big\\n\");\n\t\treturn;\n\t}\n\tbinfile = r_core_bin_cur (core);\n\taddr = core->offset;\n\tif (binfile) {\n\t\tif (len) {\n\t\t\tRIOMap *m = R_NEW0 (RIOMap);\n\t\t\tm->itv.addr = addr;\n\t\t\tm->itv.size = len;\n\t\t\tr_list_append (ranges, m);\n\t\t} else {\n\t\t\tranges = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, \"anal\");\n\t\t}\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tif (!binfile || !r_list_length (ranges)) {\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tr_list_free (ranges);\n\t\tranges = r_core_get_boundaries_prot (core, 0, NULL, \"anal\");\n\t\tr_list_foreach (ranges, iter, map) {\n\t\t\tut64 addr = map->itv.addr;\n\t\t\tif (only_print_flag) {\n\t\t\t\tr_cons_printf (\"f fcn.0x%08\"PFMT64x\" %d 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\taddr, map->itv.size, addr);\n\t\t\t} else {\n\t\t\t\t_anal_calls (core, addr, r_itv_end (map->itv));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tRListIter *iter;\n\t\tif (binfile) {\n\t\t\tr_list_foreach (ranges, iter, r) {\n\t\t\t\taddr = r->itv.addr;\n\t\t\t\t//this normally will happen on fuzzed binaries, dunno if with huge\n\t\t\t\t//binaries as well\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (only_print_flag) {\n\t\t\t\t\tr_cons_printf (\"f fcn.0x%08\"PFMT64x\" %d 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\taddr, r->itv.size, addr);\n\t\t\t\t} else {\n\t\t\t\t\t_anal_calls (core, addr, r_itv_end (r->itv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tr_list_free (ranges);\n}\n\nstatic void cmd_asf(RCore *core, const char *input) {\n\tchar *ret;\n\tif (input[0] == ' ') {\n\t\tret = sdb_querys (core->anal->sdb_fcnsign, NULL, 0, input + 1);\n\t} else {\n\t\tret = sdb_querys (core->anal->sdb_fcnsign, NULL, 0, \"*\");\n\t}\n\tif (ret && *ret) {\n\t\tr_cons_println (ret);\n\t}\n\tfree (ret);\n}\n\nstatic void cmd_anal_syscall(RCore *core, const char *input) {\n\tRSyscallItem *si;\n\tRListIter *iter;\n\tRList *list;\n\tRNum *num = NULL;\n\tchar *out;\n\tint n;\n\n\tswitch (input[0]) {\n\tcase 'c': // \"asc\"\n\t\tif (input[1] == 'a') {\n\t\t\tif (input[2] == ' ') {\n\t\t\t\tif (!isalpha (input[3]) && (n = r_num_math (num, input + 3)) >= 0 ) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\t\tif (si)\n\t\t\t\t\t\tr_cons_printf (\".equ SYS_%s %d\\n\", si->name, n);\n\t\t\t\t\telse eprintf (\"Unknown syscall number\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 3);\n\t\t\t\t\tif (n != -1) {\n\t\t\t\t\t\tr_cons_printf (\".equ SYS_%s %d\\n\", input + 3, n);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Unknown syscall name\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\t\tr_cons_printf (\".equ SYS_%s %d\\n\",\n\t\t\t\t\t\tsi->name, (ut32)si->num);\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t} else {\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tif (!isalpha (input[2]) && (n = r_num_math (num, input + 2)) >= 0 ) {\n\t\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\t\tif (si)\n\t\t\t\t\t\tr_cons_printf (\"#define SYS_%s %d\\n\", si->name, n);\n\t\t\t\t\telse eprintf (\"Unknown syscall number\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 2);\n\t\t\t\t\tif (n != -1) {\n\t\t\t\t\t\tr_cons_printf (\"#define SYS_%s %d\\n\", input + 2, n);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Unknown syscall name\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\t\tr_cons_printf (\"#define SYS_%s %d\\n\",\n\t\t\t\t\t\tsi->name, (ut32)si->num);\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"asf\"\n\t\tcmd_asf (core, input + 1);\n\t\tbreak;\n\tcase 'l': // \"asl\"\n\t\tif (input[1] == ' ') {\n\t\t\tif (!isalpha (input[2]) && (n = r_num_math (num, input + 2)) >= 0 ) {\n\t\t\t\tsi = r_syscall_get (core->anal->syscall, n, -1);\n\t\t\t\tif (si)\n\t\t\t\t\tr_cons_println (si->name);\n\t\t\t\telse eprintf (\"Unknown syscall number\\n\");\n\t\t\t} else {\n\t\t\t\tn = r_syscall_get_num (core->anal->syscall, input + 2);\n\t\t\t\tif (n != -1) {\n\t\t\t\t\tr_cons_printf (\"%d\\n\", n);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Unknown syscall name\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist = r_syscall_list (core->anal->syscall);\n\t\t\tr_list_foreach (list, iter, si) {\n\t\t\t\tr_cons_printf (\"%s = 0x%02x.%u\\n\",\n\t\t\t\t\tsi->name, (ut32)si->swi, (ut32)si->num);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"asj\"\n\t\tlist = r_syscall_list (core->anal->syscall);\n\t\tr_cons_printf (\"[\");\n\t\tr_list_foreach (list, iter, si) {\n\t\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"swi\\\":\\\"%d\\\",\\\"num\\\":\\\"%d\\\"}\",\n\t\t\t\tsi->name, si->swi, si->num);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\"]\\n\");\n\t\tr_list_free (list);\n\t\t// JSON support\n\t\tbreak;\n\tcase '\\0':\n\t\tcmd_syscall_do (core, -1); //n);\n\t\tbreak;\n\tcase ' ':\n\t\tcmd_syscall_do (core, (int)r_num_get (core->num, input + 1));\n\t\tbreak;\n\tcase 'k': // \"ask\"\n\t\tif (input[1] == ' ') {\n\t\t\tout = sdb_querys (core->anal->syscall->db, NULL, 0, input + 2);\n\t\t\tif (out) {\n\t\t\t\tr_cons_println (out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t} else eprintf (\"|ERROR| Usage: ask [query]\\n\");\n\t\tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_as);\n\t\tbreak;\n\t}\n}\n\nstatic void anal_axg (RCore *core, const char *input, int level, Sdb *db, int opts) {\n\tchar arg[32], pre[128];\n\tRList *xrefs;\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tut64 addr = core->offset;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tif (input && *input) {\n\t\taddr = r_num_math (core->num, input);\n\t}\n\tint spaces = (level + 1) * 2;\n\tif (spaces > sizeof (pre) - 4) {\n\t\tspaces = sizeof (pre) - 4;\n\t}\n\tmemset (pre, ' ', sizeof (pre));\n\tstrcpy (pre+spaces, \"- \");\n\n\txrefs = r_anal_xrefs_get (core->anal, addr);\n\tif (!r_list_empty (xrefs)) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\t\tif (fcn) {\n\t\t\tif (is_json) {\n\t\t\t\tr_cons_printf (\"{\\\"%\"PFMT64d\"\\\":{\\\"type\\\":\\\"fcn\\\",\"\n\t\t\t\t\t\"\\\"fcn_addr\\\":%\"PFMT64d\",\\\"name\\\":\\\"%s\\\",\\\"refs\\\":[\",\n\t\t\t\t\taddr, fcn->addr, fcn->name);\n\t\t\t} else {\n\t\t\t\t//if (sdb_add (db, fcn->name, \"1\", 0)) {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" fcn 0x%08\"PFMT64x\" %s\\n\",\n\t\t\t\t\tpre + 2, addr, fcn->addr, fcn->name);\n\t\t\t\t//}\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_json) {\n\t\t\t\tr_cons_printf (\"{\\\"%\"PFMT64d\"\\\":{\\\"refs\\\":[\", addr);\n\t\t\t} else {\n\t\t\t//snprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, addr);\n\t\t\t//if (sdb_add (db, arg, \"1\", 0)) {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\"\\n\", pre+2, addr);\n\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\tr_list_foreach (xrefs, iter, ref) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, ref->addr, -1);\n\t\tif (fcn) {\n\t\t\tif (is_json) {\n\t\t\t\tif (level == 0) {\n\t\t\t\t\tr_cons_printf (\"{\\\"%\"PFMT64d\"\\\":{\\\"type\\\":\\\"fcn\\\",\\\"fcn_addr\\\": %\"PFMT64d\",\\\"name\\\":\\\"%s\\\",\\\"refs\\\":[\", ref->addr, fcn->addr, fcn->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"]}},{\\\"%\"PFMT64d\"\\\":{\\\"type\\\":\\\"fcn\\\",\\\"fcn_addr\\\": %\"PFMT64d\",\\\"name\\\":\\\"%s\\\",\\\"refs\\\":[\", ref->addr, fcn->addr, fcn->name);\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" fcn 0x%08\"PFMT64x\" %s\\n\", pre, ref->addr, fcn->addr, fcn->name);\n\t\t\t}\n\t\t\tif (sdb_add (db, fcn->name, \"1\", 0)) {\n\t\t\t\tsnprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, fcn->addr);\n\t\t\t\tanal_axg (core, arg, level+1, db, opts);\n\t\t\t} else {\n\t\t\t\tif (is_json) {\n\t\t\t\t\tr_cons_printf(\"]}}\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_json) {\n\t\t\t\tif (iter->n) {\n\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_json) {\n\t\t\t\tr_cons_printf (\"{\\\"%\"PFMT64d\"\\\":{\\\"type\\\":\\\"???\\\",\\\"refs\\\":[\", ref->addr);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" ???\\n\", pre, ref->addr);\n\t\t\t}\n\t\t\tsnprintf (arg, sizeof (arg), \"0x%08\"PFMT64x, ref->addr);\n\t\t\tif (sdb_add (db, arg, \"1\", 0)) {\n\t\t\t\tanal_axg (core, arg, level +1, db, opts);\n\t\t\t} else {\n\t\t\t\tif (is_json) {\n\t\t\t\t\tr_cons_printf(\"]}}\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_json) {\n\t\t\t\tif (iter->n) {\n\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (is_json) {\n\t\tr_cons_printf(\"]}}\");\n\t\tif (level == 0) {\n\t\t\tr_cons_printf(\"\\n\");\n\t\t}\n\t}\n\tr_list_free (xrefs);\n}\n\nstatic void cmd_anal_ucall_ref (RCore *core, ut64 addr) {\n\tRAnalFunction * fcn = r_anal_get_fcn_at (core->anal, addr, R_ANAL_FCN_TYPE_NULL);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}\n\nstatic bool cmd_anal_refs(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[0]) {\n\tcase '-': { // \"ax-\"\n\t\tRList *list;\n\t\tRListIter *iter;\n\t\tRAnalRef *ref;\n\t\tchar *cp_inp = strdup (input + 1);\n\t\tchar *ptr = r_str_trim_head (cp_inp);\n\t\tif (!strcmp (ptr, \"*\")) {\n\t\t\tr_anal_xrefs_init (core->anal);\n\t\t} else {\n\t\t\tint n = r_str_word_set0 (ptr);\n\t\t\tut64 from = UT64_MAX, to = UT64_MAX;\n\t\t\tswitch (n) {\n\t\t\tcase 2:\n\t\t\t\tfrom = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t\t//fall through\n\t\t\tcase 1: // get addr\n\t\t\t\tto = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tto = core->offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist = r_anal_xrefs_get (core->anal, to);\n\t\t\tif (list) {\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tif (from != UT64_MAX && from == ref->addr) {\n\t\t\t\t\t\tr_anal_ref_del (core->anal, ref->addr, ref->at);\n\t\t\t\t\t}\n\t\t\t\t\tif (from == UT64_MAX) {\n\t\t\t\t\t\tr_anal_ref_del (core->anal, ref->addr, ref->at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t}\n\t\tfree (cp_inp);\n\t} break;\n\tcase 'g': // \"axg\"\n\t\t{\n\t\t\tSdb *db = sdb_new0 ();\n\t\t\tif(input[1] == '\\0') {\n\t\t\t\tanal_axg (core, input[1] ? input + 2 : NULL, 0, db, 0);\n\t\t\t} else if(input[1] == 'j') {\n\t\t\t\tanal_axg (core, input[1] ? input + 2 : NULL, 0, db, R_CORE_ANAL_JSON);\n\t\t\t}\n\t\t\tsdb_free (db);\n\t\t}\n\t\tbreak;\n\tcase 'k': // \"axk\"\n\t\tif (input[1] == '?') {\n\t\t\teprintf (\"Usage: axk [query]\\n\");\n\t\t} else if (input[1] == ' ') {\n\t\t\tsdb_query (core->anal->sdb_xrefs, input + 2);\n\t\t} else {\n\t\t\tr_core_anal_ref_list (core, 'k');\n\t\t}\n\t\tbreak;\n\tcase '\\0': // \"ax\"\n\tcase 'j': // \"axj\"\n\tcase 'q': // \"axq\"\n\tcase '*': // \"ax*\"\n\t\tr_core_anal_ref_list (core, input[0]);\n\t\tbreak;\n\tcase 't': { // \"axt\"\n\t\tconst int size = 12;\n\t\tRList *list;\n\t\tRAnalFunction *fcn;\n\t\tRAnalRef *ref;\n\t\tRListIter *iter;\n\t\tut8 buf[12];\n\t\tRAsmOp asmop;\n\t\tchar *buf_asm = NULL;\n\t\tchar *space = strchr (input, ' ');\n\n\t\tif (space) {\n\t\t\taddr = r_num_math (core->num, space + 1);\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tlist = r_anal_xrefs_get (core->anal, addr);\n\t\tif (list) {\n\t\t\tif (input[1] == 'q') { // \"axtq\"\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", ref->addr);\n\t\t\t\t}\n\t\t\t} else if (input[1] == 'j') { // \"axtj\"\n\t\t\t\tbool asm_varsub = r_config_get_i (core->config, \"asm.varsub\");\n\t\t\t\tcore->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");\n\t\t\t\tcore->parser->localvar_only = r_config_get_i (core->config, \"asm.varsub_only\");\n\t\t\t\tr_cons_printf (\"[\");\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_core_read_at (core, ref->addr, buf, size);\n\t\t\t\t\tr_asm_set_pc (core->assembler, ref->addr);\n\t\t\t\t\tr_asm_disassemble (core->assembler, &asmop, buf, size);\n\t\t\t\t\tchar str[512];\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, ref->addr, 0);\n\t\t\t\t\tif (asm_varsub) {\n\t\t\t\t\t\tr_parse_varsub (core->parser, fcn, ref->addr, asmop.size,\n\t\t\t\t\t\t\t\tasmop.buf_asm, asmop.buf_asm, sizeof (asmop.buf_asm));\n\t\t\t\t\t}\n\t\t\t\t\tr_parse_filter (core->parser, core->flags,\n\t\t\t\t\t\t\tasmop.buf_asm, str, sizeof (str), core->print->big_endian);\n\n\t\t\t\t\tr_cons_printf (\"{\\\"from\\\":%\" PFMT64u \",\\\"type\\\":\\\"%s\\\",\\\"opcode\\\":\\\"%s\\\"\", ref->addr, r_anal_ref_to_string (ref->type), str);\n\t\t\t\t\tif (fcn) {\n\t\t\t\t\t\tr_cons_printf (\",\\\"fcn_addr\\\":%\"PFMT64d\",\\\"fcn_name\\\":\\\"%s\\\"\", fcn->addr, fcn->name);\n\t\t\t\t\t}\n\t\t\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, fcn? fcn->addr: ref->addr, true);\n\t\t\t\t\tif (fi) {\n\t\t\t\t\t\tif (fcn && strcmp (fcn->name, fi->name)) {\n\t\t\t\t\t\t\tr_cons_printf (\",\\\"flag\\\":\\\"%s\\\"\", fi->name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fi->realname && strcmp (fi->name, fi->realname)) {\n\t\t\t\t\t\t\tr_cons_printf (\",\\\"realname\\\":\\\"%s\\\"\", fi->realname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"}%s\", iter->n? \",\": \"\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\tr_cons_newline ();\n\t\t\t} else if (input[1] == 'g') { // axtg\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tchar *str = r_core_cmd_strf (core, \"fd 0x%\"PFMT64x, ref->addr);\n\t\t\t\t\tif (!str) {\n\t\t\t\t\t\tstr = strdup (\"?\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tr_str_trim_tail (str);\n\t\t\t\t\tr_cons_printf (\"agn 0x%\" PFMT64x \" \\\"%s\\\"\\n\", ref->addr, str);\n\t\t\t\t\tfree (str);\n\t\t\t\t}\n\t\t\t\tif (input[2] != '*') {\n\t\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\t\tr_cons_printf (\"agn 0x%\" PFMT64x \" \\\"%s\\\"\\n\", addr, fcn?fcn->name: \"$$\");\n\t\t\t\t}\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_cons_printf (\"age 0x%\" PFMT64x \" 0x%\"PFMT64x\"\\n\", ref->addr, addr);\n\t\t\t\t}\n\t\t\t} else if (input[1] == '*') { // axt*\n\t\t\t\t// TODO: implement multi-line comments\n\t\t\t\tr_list_foreach (list, iter, ref)\n\t\t\t\t\tr_cons_printf (\"CCa 0x%\" PFMT64x \" \\\"XREF type %d at 0x%\" PFMT64x\"%s\\n\",\n\t\t\t\t\t\tref->addr, ref->type, addr, iter->n? \",\": \"\");\n\t\t\t} else { // axt\n\t\t\t\tint has_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\t\t\t\tchar str[512];\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tchar *comment;\n\t\t\t\tbool asm_varsub = r_config_get_i (core->config, \"asm.varsub\");\n\t\t\t\tcore->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");\n\t\t\t\tcore->parser->localvar_only = r_config_get_i (core->config, \"asm.varsub_only\");\n\t\t\t\tif (core->parser->relsub) {\n\t\t\t\t\tcore->parser->relsub_addr = addr;\n\t\t\t\t}\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_core_read_at (core, ref->addr, buf, size);\n\t\t\t\t\tr_asm_set_pc (core->assembler, ref->addr);\n\t\t\t\t\tr_asm_disassemble (core->assembler, &asmop, buf, size);\n\n\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, ref->addr, 0);\n\t\t\t\t\tif (asm_varsub) {\n\t\t\t\t\t\tr_parse_varsub (core->parser, fcn, ref->addr, asmop.size,\n\t\t\t\t\t\t\t\tasmop.buf_asm, asmop.buf_asm, sizeof (asmop.buf_asm));\n\t\t\t\t\t}\n\t\t\t\t\tr_parse_filter (core->parser, core->flags,\n\t\t\t\t\t\t\tasmop.buf_asm, str, sizeof (str), core->print->big_endian);\n\t\t\t\t\tif (has_color) {\n\t\t\t\t\t\tbuf_asm = r_print_colorize_opcode (core->print, str,\n\t\t\t\t\t\t\tcore->cons->pal.reg, core->cons->pal.num, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf_asm = r_str_new (str);\n\t\t\t\t\t}\n\t\t\t\t\tcomment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, ref->addr);\n\t\t\t\t\tchar *buf_fcn = comment\n\t\t\t\t\t\t? r_str_newf (\"%s; %s\", fcn ?  fcn->name : \"(nofunc)\", strtok (comment, \"\\n\"))\n\t\t\t\t\t\t: r_str_newf (\"%s\", fcn ? fcn->name : \"(nofunc)\");\n\t\t\t\t\tr_cons_printf (\"%s 0x%\" PFMT64x \" [%s] %s\\n\",\n\t\t\t\t\t\tbuf_fcn, ref->addr, r_anal_ref_to_string (ref->type), buf_asm);\n\t\t\t\t\tfree (buf_asm);\n\t\t\t\t\tfree (buf_fcn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t} else {\n\t\t\tif (input[1] == 'j') { // \"axtj\"\n\t\t\t\tr_cons_print (\"[]\\n\");\n\t\t\t}\n\t\t}\n\t} break;\n\tcase 'f': { // \"axf\"\n\t\tut8 buf[12];\n\t\tRAsmOp asmop;\n\t\tchar *buf_asm = NULL;\n\t\tRList *list, *list_ = NULL;\n\t\tRAnalRef *ref;\n\t\tRListIter *iter;\n\t\tchar *space = strchr (input, ' ');\n\n\t\tif (space) {\n\t\t\taddr = r_num_math (core->num, space + 1);\n\t\t} else {\n\t\t\taddr = core->offset;\n\t\t}\n\t\tif (input[1] == '.') { // axf.\n\t\t\tlist = list_ = r_anal_xrefs_get_from (core->anal, addr);\n\t\t\tif (!list) {\n\t\t\t\tRAnalFunction * fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\t\tlist = r_anal_fcn_get_refs (core->anal, fcn);\n\t\t\t}\n\t\t} else {\n\t\t\tlist = r_anal_refs_get (core->anal, addr);\n\t\t}\n\n\t\tif (list) {\n\t\t\tif (input[1] == 'q') { // axfq\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", ref->at);\n\t\t\t\t}\n\t\t\t} else if (input[1] == 'j') { // axfj\n\t\t\t\tr_cons_print (\"[\");\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_core_read_at (core, ref->at, buf, 12);\n\t\t\t\t\tr_asm_set_pc (core->assembler, ref->at);\n\t\t\t\t\tr_asm_disassemble (core->assembler, &asmop, buf, 12);\n\t\t\t\t\tr_cons_printf (\"{\\\"from\\\":%\" PFMT64d \",\\\"to\\\":%\" PFMT64d \",\\\"type\\\":\\\"%s\\\",\\\"opcode\\\":\\\"%s\\\"}%s\",\n\t\t\t\t\t\tref->at, ref->addr, r_anal_ref_to_string (ref->type), asmop.buf_asm, iter->n? \",\": \"\");\n\t\t\t\t}\n\t\t\t\tr_cons_print (\"]\\n\");\n\t\t\t} else if (input[1] == '*') { // axf*\n\t\t\t\t// TODO: implement multi-line comments\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_cons_printf (\"CCa 0x%\" PFMT64x \" \\\"XREF from 0x%\" PFMT64x \"\\n\",\n\t\t\t\t\t\tref->at, ref->type, asmop.buf_asm, iter->n? \",\": \"\");\n\t\t\t\t}\n\t\t\t} else { // axf\n\t\t\t\tchar str[512];\n\t\t\t\tint has_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\t\t\t\tr_list_foreach (list, iter, ref) {\n\t\t\t\t\tr_core_read_at (core, ref->at, buf, 12);\n\t\t\t\t\tr_asm_set_pc (core->assembler, ref->at);\n\t\t\t\t\tr_asm_disassemble (core->assembler, &asmop, buf, 12);\n\t\t\t\t\tr_parse_filter (core->parser, core->flags,\n\t\t\t\t\t\t\tasmop.buf_asm, str, sizeof (str), core->print->big_endian);\n\t\t\t\t\tif (has_color) {\n\t\t\t\t\t\tbuf_asm = r_print_colorize_opcode (core->print, str,\n\t\t\t\t\t\t\tcore->cons->pal.reg, core->cons->pal.num, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf_asm = r_str_new (str);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"%c 0x%\" PFMT64x \" %s\",\n\t\t\t\t\t\tref->type, ref->at, buf_asm);\n\n\t\t\t\t\tif (ref->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\t\tRAnalOp aop;\n\t\t\t\t\t\tr_anal_op (core->anal, &aop, ref->at, buf, 12, R_ANAL_OP_MASK_ALL);\n\t\t\t\t\t\tif (aop.type == R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\t\t\t\tcmd_anal_ucall_ref (core, ref->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\tfree (buf_asm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_free (list_);\n\t\t\tr_list_free (list);\n\t\t} else {\n\t\t\tif (input[1] == 'j') { // axfj\n\t\t\t\tr_cons_print (\"[]\\n\");\n\t\t\t}\n\t\t}\n\t} break;\n\tcase 'F':\n\t\tfind_refs (core, input + 1);\n\t\tbreak;\n\tcase 'C': // \"axC\"\n\tcase 'c': // \"axc\"\n\tcase 'd': // \"axd\"\n\tcase ' ': // \"ax \"\n\t\t{\n\t\tchar *ptr = strdup (r_str_trim_head ((char *)input + 1));\n\t\tint n = r_str_word_set0 (ptr);\n\t\tut64 at = core->offset;\n\t\tut64 addr = UT64_MAX;\n\t\tswitch (n) {\n\t\tcase 2: // get at\n\t\t\tat = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t/* fall through */\n\t\tcase 1: // get addr\n\t\t\taddr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfree (ptr);\n\t\t\treturn false;\n\t\t}\n\t\tr_anal_xrefs_set (core->anal, input[0], at, addr);\n\t\tfree (ptr);\n\t\t}\n\t   \tbreak;\n\tdefault:\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_ax);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\nstatic void cmd_anal_hint(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '?':\n\t\tif (input[1]) {\n\t\t\tut64 addr = r_num_math (core->num, input + 1);\n\t\t\tr_core_anal_hint_print (core->anal, addr, 0);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ah);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"ah.\"\n\t\tr_core_anal_hint_print (core->anal, core->offset, 0);\n\t\tbreak;\n\tcase 'a': // \"aha\" set arch\n\t\tif (input[1]) {\n\t\t\tint i;\n\t\t\tchar *ptr = strdup (input + 2);\n\t\t\ti = r_str_word_set0 (ptr);\n\t\t\tif (i == 2) {\n\t\t\t\tr_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t}\n\t\t\tr_anal_hint_set_arch (core->anal, core->offset, r_str_word_get0 (ptr, 0));\n\t\t\tfree (ptr);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_arch (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Missing argument\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"ahb\" set bits\n\t\tif (input[1]) {\n\t\t\tchar *ptr = strdup (input + 2);\n\t\t\tint bits;\n\t\t\tint i = r_str_word_set0 (ptr);\n\t\t\tif (i == 2) {\n\t\t\t\tr_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t}\n\t\t\tbits = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tr_anal_hint_set_bits (core->anal, core->offset, bits);\n\t\t\tfree (ptr);\n\t\t}  else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_bits (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Missing argument\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"ahi\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_ahi);\n\t\t} else if (input[1] == ' ') {\n\t\t// You can either specify immbase with letters, or numbers\n\t\t\tconst int base =\n\t\t\t\t(input[2] == 's') ? 1 :\n\t\t\t\t(input[2] == 'b') ? 2 :\n\t\t\t\t(input[2] == 'p') ? 3 :\n\t\t\t\t(input[2] == 'o') ? 8 :\n\t\t\t\t(input[2] == 'd') ? 10 :\n\t\t\t\t(input[2] == 'h') ? 16 :\n\t\t\t\t(input[2] == 'i') ? 32 : // ip address\n\t\t\t\t(input[2] == 'S') ? 80 : // syscall\n\t\t\t\t(int) r_num_math (core->num, input + 1);\n\t\t\tr_anal_hint_set_immbase (core->anal, core->offset, base);\n\t\t} else if (input[1] == '-') { // \"ahi-\"\n\t\t\tr_anal_hint_set_immbase (core->anal, core->offset, 0);\n\t\t} else {\n\t\t\teprintf (\"|ERROR| Usage: ahi [base]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ahh\"\n\t\tif (input[1] == '-') {\n\t\t\tr_anal_hint_unset_high (core->anal, core->offset);\n\t\t} else if (input[1] == ' ') {\n\t\t\tr_anal_hint_set_high (core->anal, r_num_math (core->num, input + 1));\n\t\t} else {\n\t\t\tr_anal_hint_set_high (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"ahc\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_jump (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_jump (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"ahf\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_fail (\n\t\t\t\tcore->anal, core->offset,\n\t\t\t\tr_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_fail (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ahs\" set size (opcode length)\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_size (core->anal, core->offset, atoi (input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_size (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Usage: ahs 16\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'S': // \"ahS\" set size (opcode length)\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_syntax (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_syntax (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Usage: ahS att\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"aho\" set opcode string\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_opcode (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_opcode (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Usage: aho popall\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"ahe\" set ESIL string\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_esil (core->anal, core->offset, input + 2);\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_esil (core->anal, core->offset);\n\t\t} else {\n\t\t\teprintf (\"Usage: ahe r0,pc,=\\n\");\n\t\t}\n\t\tbreak;\n#if 0\n\tcase 'e': // set endian\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_opcode (core->anal, core->offset, atoi (input + 1));\n\t\t} else if (input[1] == '-') {\n\t\t\tr_anal_hint_unset_opcode (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n#endif\n\tcase 'p': // \"ahp\"\n\t\tif (input[1] == ' ') {\n\t\t\tr_anal_hint_set_pointer (core->anal, core->offset, r_num_math (core->num, input + 1));\n\t\t} else if (input[1] == '-') { // \"ahp-\"\n\t\t\tr_anal_hint_unset_pointer (core->anal, core->offset);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"ah*\"\n\t\tif (input[1] == ' ') {\n\t\t\tchar *ptr = strdup (r_str_trim_ro (input + 2));\n\t\t\tr_str_word_set0 (ptr);\n\t\t\tut64 addr = r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t\t\tr_core_anal_hint_print (core->anal, addr, '*');\n\t\t} else {\n\t\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"ahj\"\n\tcase '\\0': // \"ah\"\n\t\tr_core_anal_hint_list (core->anal, input[0]);\n\t\tbreak;\n\tcase '-': // \"ah-\"\n\t\tif (input[1]) {\n\t\t\tif (input[1] == '*') {\n\t\t\t\tr_anal_hint_clear (core->anal);\n\t\t\t} else {\n\t\t\t\tchar *ptr = strdup (r_str_trim_ro (input + 1));\n\t\t\t\tut64 addr;\n\t\t\t\tint size = 1;\n\t\t\t\tint i = r_str_word_set0 (ptr);\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tsize = r_num_math (core->num, r_str_word_get0 (ptr, 1));\n\t\t\t\t}\n\t\t\t\tconst char *a0 = r_str_word_get0 (ptr, 0);\n\t\t\t\tif (a0 && *a0) {\n\t\t\t\t\taddr = r_num_math (core->num, a0);\n\t\t\t\t} else {\n\t\t\t\t\taddr = core->offset;\n\t\t\t\t}\n\t\t\t\tr_anal_hint_del (core->anal, addr, size);\n\t\t\t\tfree (ptr);\n\t\t\t}\n\t\t} else {\n\t\t\tr_anal_hint_clear (core->anal);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void agraph_print_node_dot(RANode *n, void *user) {\n\tchar *label = strdup (n->body);\n\t//label = r_str_replace (label, \"\\n\", \"\\\\l\", 1);\n\tif (!label || !*label) {\n\t\tr_cons_printf (\"\\\"%s\\\" [URL=\\\"%s\\\", color=\\\"lightgray\\\", label=\\\"%s\\\"]\\n\",\n\t\t\t\tn->title, n->title, n->title);\n\t} else {\n\t\tr_cons_printf (\"\\\"%s\\\" [URL=\\\"%s\\\", color=\\\"lightgray\\\", label=\\\"%s\\\\n%s\\\"]\\n\",\n\t\t\t\tn->title, n->title, n->title, label);\n\t}\n\tfree (label);\n}\n\nstatic void agraph_print_node(RANode *n, void *user) {\n\tchar *encbody, *cmd;\n\tint len = strlen (n->body);\n\n\tif (n->body[len - 1] == '\\n') {\n\t\tlen--;\n\t}\n\tencbody = r_base64_encode_dyn (n->body, len);\n\tcmd = r_str_newf (\"agn \\\"%s\\\" base64:%s\\n\", n->title, encbody);\n\tr_cons_printf (cmd);\n\tfree (cmd);\n\tfree (encbody);\n}\n\nstatic void agraph_print_edge_dot(RANode *from, RANode *to, void *user) {\n\tr_cons_printf (\"\\\"%s\\\" -> \\\"%s\\\"\\n\", from->title, to->title);\n}\n\nstatic void agraph_print_edge(RANode *from, RANode *to, void *user) {\n\tr_cons_printf (\"age \\\"%s\\\" \\\"%s\\\"\\n\", from->title, to->title);\n}\n\nstatic void cmd_agraph_node(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase ' ': { // \"agn\"\n\t\tchar *newbody = NULL;\n\t\tchar **args, *body;\n\t\tint n_args, B_LEN = strlen (\"base64:\");\n\t\tinput++;\n\t\targs = r_str_argv (input, &n_args);\n\t\tif (n_args < 1 || n_args > 2) {\n\t\t\tr_cons_printf (\"Wrong arguments\\n\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\t// strdup cause there is double free in r_str_argv_free due to a realloc call\n\t\tif (n_args > 1) {\n\t\t\tbody = strdup (args[1]);\n\t\t\tif (strncmp (body, \"base64:\", B_LEN) == 0) {\n\t\t\t\tbody = r_str_replace (body, \"\\\\n\", \"\", true);\n\t\t\t\tnewbody = (char *)r_base64_decode_dyn (body + B_LEN, -1);\n\t\t\t\tfree (body);\n\t\t\t\tif (!newbody) {\n\t\t\t\t\teprintf (\"Cannot allocate buffer\\n\");\n\t\t\t\t\tr_str_argv_free (args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbody = newbody;\n\t\t\t}\n\t\t\tbody = r_str_append (body, \"\\n\");\n\t\t} else {\n\t\t\tbody = strdup (\"\");\n\t\t}\n\t\tr_agraph_add_node (core->graph, args[0], body);\n\t\tr_str_argv_free (args);\n\t\tfree (body);\n\t\t//free newbody it's not necessary since r_str_append reallocate the space\n\t\tbreak;\n\t}\n\tcase '-': { // \"agn-\"\n\t\tchar **args;\n\t\tint n_args;\n\n\t\tinput++;\n\t\targs = r_str_argv (input, &n_args);\n\t\tif (n_args != 1) {\n\t\t\tr_cons_printf (\"Wrong arguments\\n\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\tr_agraph_del_node (core->graph, args[0]);\n\t\tr_str_argv_free (args);\n\t\tbreak;\n\t}\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_agn);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_agraph_edge(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase ' ': // \"age\"\n\tcase '-': { // \"age-\"\n\t\tRANode *u, *v;\n\t\tchar **args;\n\t\tint n_args;\n\n\t\targs = r_str_argv (input + 1, &n_args);\n\t\tif (n_args != 2) {\n\t\t\tr_cons_printf (\"Wrong arguments\\n\");\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\n\t\tu = r_agraph_get_node (core->graph, args[0]);\n\t\tv = r_agraph_get_node (core->graph, args[1]);\n\t\tif (!u || !v) {\n\t\t\tif (!u) {\n\t\t\t\tr_cons_printf (\"Node %s not found!\\n\", args[0]);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"Node %s not found!\\n\", args[1]);\n\t\t\t}\n\t\t\tr_str_argv_free (args);\n\t\t\tbreak;\n\t\t}\n\t\tif (*input == ' ') {\n\t\t\tr_agraph_add_edge (core->graph, u, v);\n\t\t} else {\n\t\t\tr_agraph_del_edge (core->graph, u, v);\n\t\t}\n\t\tr_str_argv_free (args);\n\t\tbreak;\n\t}\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_age);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_agraph_print(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase 'k': // \"aggk\"\n\t{\n\t\tSdb *db = r_agraph_get_sdb (core->graph);\n\t\tchar *o = sdb_querys (db, \"null\", 0, \"*\");\n\t\tr_cons_print (o);\n\t\tfree (o);\n\t\tbreak;\n\t}\n\tcase 'v': // \"aggv\"\n\t{\n\t\tconst char *cmd = r_config_get (core->config, \"cmd.graph\");\n\t\tif (cmd && *cmd) {\n\t\t\tchar *newCmd = strdup (cmd);\n\t\t\tif (newCmd) {\n\t\t\t\tnewCmd = r_str_replace (newCmd, \"ag $$\", \"aggd\", 0);\n\t\t\t\tr_core_cmd0 (core, newCmd);\n\t\t\t\tfree (newCmd);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd0 (core, \"agf\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'i': // \"aggi\" - open current core->graph in interactive mode\n\t{\n\t\tRANode *ran = r_agraph_get_first_node (core->graph);\n\t\tif (ran) {\n\t\t\tr_agraph_set_title (core->graph, r_config_get (core->config, \"graph.title\"));\n\t\t\tr_agraph_set_curnode (core->graph, ran);\n\t\t\tcore->graph->force_update_seek = true;\n\t\t\tcore->graph->need_set_layout = true;\n\t\t\tcore->graph->layout = r_config_get_i (core->config, \"graph.layout\");\n\t\t\tint ov = r_config_get_i (core->config, \"scr.interactive\");\n\t\t\tcore->graph->need_update_dim = true;\n\t\t\tr_core_visual_graph (core, core->graph, NULL, true);\n\t\t\tr_config_set_i (core->config, \"scr.interactive\", ov);\n\t\t\tr_cons_show_cursor (true);\n\t\t} else {\n\t\t\teprintf (\"This graph contains no nodes\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'd': // \"aggd\" - dot format\n\t\tr_cons_printf (\"digraph code {\\ngraph [bgcolor=white];\\n\"\n\t\t\t\"node [color=lightgray, style=filled shape=box \"\n\t\t\t\"fontname=\\\"Courier\\\" fontsize=\\\"8\\\"];\\n\");\n\t\tr_agraph_foreach (core->graph, agraph_print_node_dot, NULL);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge_dot, NULL);\n\t\tr_cons_printf (\"}\\n\");\n\t\tbreak;\n\tcase '*': // \"agg*\" -\n\t\tr_agraph_foreach (core->graph, agraph_print_node, NULL);\n\t\tr_agraph_foreach_edge (core->graph, agraph_print_edge, NULL);\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_agg);\n\t\tbreak;\n\tdefault:\n\t\tcore->graph->can->linemode = r_config_get_i (core->config, \"graph.linemode\");\n\t\tcore->graph->can->color = r_config_get_i (core->config, \"scr.color\");\n\t\tr_agraph_set_title (core->graph,\n\t\t\tr_config_get (core->config, \"graph.title\"));\n\t\tr_agraph_print (core->graph);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_graph(RCore *core, const char *input) {\n\tRList *list;\n\tconst char *arg;\n\tswitch (input[0]) {\n\tcase 'f': // \"agf\"\n\t\tswitch (input[1]) {\n\t\tcase 't':// \"agft\" - tiny graph\n\t\t\tr_core_visual_graph (core, NULL, NULL, 2);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tr_core_visual_graph (core, NULL, NULL, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Usage: agf or agft (for tiny)\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '-': // \"ag-\"\n\t\tr_agraph_reset (core->graph);\n\t\tbreak;\n\tcase 'n': // \"agn\"\n\t\tcmd_agraph_node (core, input + 1);\n\t\tbreak;\n\tcase 'e': // \"age\"\n\t\tcmd_agraph_edge (core, input + 1);\n\t\tbreak;\n\tcase 'g': // \"agg\"\n\t\tcmd_agraph_print (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"ags\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), 0);\n\t\tbreak;\n\tcase 't': // \"agt\"\n\t\tlist = r_core_anal_graph_to (core, r_num_math (core->num, input + 1), 0);\n\t\tif (list) {\n\t\t\tRListIter *iter, *iter2;\n\t\t\tRList *list2;\n\t\t\tRAnalBlock *bb;\n\t\t\tr_list_foreach (list, iter, list2) {\n\t\t\t\tr_list_foreach (list2, iter2, bb) {\n\t\t\t\t\tr_cons_printf (\"-> 0x%08\" PFMT64x \"\\n\", bb->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_purge (list);\n\t\t\tfree (list);\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"agC\"\n\t\tr_core_anal_coderefs (core, UT64_MAX, input[1] == 'j'? 2: 1);\n\t\tbreak;\n\tcase 'r': // \"refs\"\n\t\tswitch (input[1]) {\n\t\tcase '*':\n\t\tcase 'j':\n\t\tcase ' ':\n\t\tcase 0:\n\t\t\t{\n\t\t\t\tut64 addr = input[2]? r_num_math (core->num, input + 2): core->offset;\n\t\t\t\tr_core_anal_codexrefs (core, addr, '*');\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"|ERROR| Usage: agr[*j]\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"agc\"\n\t\tif (input[1] == '*') {\n\t\t\tut64 addr = input[2]? r_num_math (core->num, input + 2): UT64_MAX;\n\t\t\tr_core_anal_coderefs (core, addr, '*');\n\t\t} else if (input[1] == 'j') {\n\t\t\tut64 addr = input[2]? r_num_math (core->num, input + 2): UT64_MAX;\n\t\t\tr_core_anal_coderefs (core, addr, 2);\n\t\t} else if (input[1] == ' ') {\n\t\t\tut64 addr = input[2]? r_num_math (core->num, input + 1): UT64_MAX;\n\t\t\tr_core_anal_coderefs (core, addr, 1);\n\t\t} else {\n\t\t\teprintf (\"|ERROR| Usage: agc[j*] ([addr])\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"agj\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_JSON);\n\t\tbreak;\n\tcase 'J': // \"agJ\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_JSON | R_CORE_ANAL_JSON_FORMAT_DISASM);\n\t\tbreak;\n\tcase 'k': // \"agk\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_KEYVALUE);\n\t\tbreak;\n\tcase 'l': // \"agl\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), R_CORE_ANAL_GRAPHLINES);\n\t\tbreak;\n\tcase 'a': // \"aga\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1), 0);\n\t\tbreak;\n\tcase 'd': // \"agd\"\n\t\tr_core_anal_graph (core, r_num_math (core->num, input + 1),\n\t\t\t\tR_CORE_ANAL_GRAPHBODY | R_CORE_ANAL_GRAPHDIFF);\n\t\tbreak;\n\tcase 'v': // \"agv\"\n\t\tif (r_config_get_i (core->config, \"graph.web\")) {\n\t\t\tr_core_cmd0 (core, \"=H /graph/\");\n\t\t} else {\n\t\t\tconst char *cmd = r_config_get (core->config, \"cmd.graph\");\n\t\t\tif (cmd && *cmd) {\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t} else {\n\t\t\t\tr_core_cmd0 (core, \"agf\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ag?\"\n\t\tr_core_cmd_help (core, help_msg_ag);\n\t\tbreak;\n\tcase ' ': // \"ag\"\n\t\targ = strchr (input, ' ');\n\t\tr_core_anal_graph (core, r_num_math (core->num, arg? arg + 1: NULL),\n\t\t\t\tR_CORE_ANAL_GRAPHBODY);\n\t\tbreak;\n\tcase 0:\n\t\teprintf (\"|ERROR| Usage: ag [addr]\\n\");\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"See ag?\\n\");\n\t\tbreak;\n\t}\n}\n\nR_API int r_core_anal_refs(RCore *core, const char *input) {\n\tint cfg_debug = r_config_get_i (core->config, \"cfg.debug\");\n\tut64 from, to;\n\tchar *ptr;\n\tint rad, n;\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_aar);\n\t\treturn 0;\n\t}\n\n\tif (*input == 'j' || *input == '*') {\n\t\trad = *input;\n\t\tinput++;\n\t} else {\n\t\trad = 0;\n\t}\n\n\tfrom = to = 0;\n\tptr = r_str_trim_head (strdup (input));\n\tn = r_str_word_set0 (ptr);\n\tif (!n) {\n\t\t// get boundaries of current memory map, section or io map\n\t\tif (cfg_debug) {\n\t\t\tRDebugMap *map = r_debug_map_get (core->dbg, core->offset);\n\t\t\tif (map) {\n\t\t\t\tfrom = map->addr;\n\t\t\t\tto = map->addr_end;\n\t\t\t}\n\t\t} else {\n\t\t\tRList *list = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, \"anal\");\n\t\t\tRListIter *iter;\n\t\t\tRIOMap* map;\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tfrom = map->itv.addr;\n\t\t\t\tto = r_itv_end (map->itv);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!from && !to) {\n\t\t\t\t\teprintf (\"Cannot determine xref search boundaries\\n\");\n\t\t\t\t} else if (to - from > UT32_MAX) {\n\t\t\t\t\teprintf (\"Skipping huge range\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tr_core_anal_search_xrefs (core, from, to, rad);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (ptr);\n\t\t\treturn 1;\n\t\t}\n\t} else if (n == 1) {\n\t\tfrom = core->offset;\n\t\tto = core->offset + r_num_math (core->num, r_str_word_get0 (ptr, 0));\n\t} else {\n\t\teprintf (\"Invalid number of arguments\\n\");\n\t}\n\tfree (ptr);\n\n\tif (from == UT64_MAX && to == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (!from && !to) {\n\t\treturn false;\n\t}\n\tif (to - from > r_io_size (core->io)) {\n\t\treturn false;\n\t}\n\treturn r_core_anal_search_xrefs (core, from, to, rad);\n}\n\nstatic const char *oldstr = NULL;\n\nstatic void rowlog(RCore *core, const char *str) {\n\tint use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tbool verbose = r_config_get_i (core->config, \"scr.prompt\");\n\toldstr = str;\n\tif (!verbose) {\n\t\treturn;\n\t}\n\tif (use_color) {\n\t\teprintf (\"[ ] \"Color_YELLOW\"%s\\r[\"Color_RESET, str);\n\t} else {\n\t\teprintf (\"[ ] %s\\r[\", str);\n\t}\n}\n\nstatic void rowlog_done(RCore *core) {\n\tint use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tbool verbose = r_config_get_i (core->config, \"scr.prompt\");\n\tif (verbose) {\n\t\tif (use_color)\n\t\t\teprintf (\"\\r\"Color_GREEN\"[x]\"Color_RESET\" %s\\n\", oldstr);\n\t\telse eprintf (\"\\r[x] %s\\n\", oldstr);\n\t}\n}\n\nstatic int compute_coverage(RCore *core) {\n\tRListIter *iter;\n\tSdbListIter *iter2;\n\tRAnalFunction *fcn;\n\tRIOSection *sec;\n\tint cov = 0;\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tls_foreach (core->io->sections, iter2, sec) {\n\t\t\tif (sec->flags & 1) {\n\t\t\t\tut64 section_end = sec->vaddr + sec->vsize;\n\t\t\t\tut64 s = r_anal_fcn_realsize (fcn);\n\t\t\t\tif (fcn->addr >= sec->vaddr && (fcn->addr + s) < section_end) {\n\t\t\t\t\tcov += s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cov;\n}\n\nstatic int compute_code (RCore* core) {\n\tint code = 0;\n\tSdbListIter *iter;\n\tRIOSection *sec;\n\tls_foreach (core->io->sections, iter, sec) {\n\t\tif (sec->flags & 1) {\n\t\t\tcode += sec->vsize;\n\t\t}\n\t}\n\treturn code;\n}\n\nstatic int compute_calls(RCore *core) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tRList *xrefs;\n\tint cov = 0;\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\txrefs = r_anal_fcn_get_xrefs (core->anal, fcn);\n\t\tif (xrefs) {\n\t\t\tcov += r_list_length (xrefs);\n\t\t\tr_list_free (xrefs);\n\t\t\txrefs = NULL;\n\t\t}\n\t}\n\treturn cov;\n}\n\nstatic void r_core_anal_info (RCore *core, const char *input) {\n\tint fcns = r_list_length (core->anal->fcns);\n\tint strs = r_flag_count (core->flags, \"str.*\");\n\tint syms = r_flag_count (core->flags, \"sym.*\");\n\tint imps = r_flag_count (core->flags, \"sym.imp.*\");\n\tint code = compute_code (core);\n\tint covr = compute_coverage (core);\n\tint call = compute_calls (core);\n\tint xrfs = r_anal_xrefs_count (core->anal);\n\tint cvpc = (code > 0)? (covr * 100 / code): 0;\n\tif (*input == 'j') {\n\t\tr_cons_printf (\"{\\\"fcns\\\":%d\", fcns);\n\t\tr_cons_printf (\",\\\"xrefs\\\":%d\", xrfs);\n\t\tr_cons_printf (\",\\\"calls\\\":%d\", call);\n\t\tr_cons_printf (\",\\\"strings\\\":%d\", strs);\n\t\tr_cons_printf (\",\\\"symbols\\\":%d\", syms);\n\t\tr_cons_printf (\",\\\"imports\\\":%d\", imps);\n\t\tr_cons_printf (\",\\\"covrage\\\":%d\", covr);\n\t\tr_cons_printf (\",\\\"codesz\\\":%d\", code);\n\t\tr_cons_printf (\",\\\"percent\\\":%d}\\n\", cvpc);\n\t} else {\n\t\tr_cons_printf (\"fcns    %d\\n\", fcns);\n\t\tr_cons_printf (\"xrefs   %d\\n\", xrfs);\n\t\tr_cons_printf (\"calls   %d\\n\", call);\n\t\tr_cons_printf (\"strings %d\\n\", strs);\n\t\tr_cons_printf (\"symbols %d\\n\", syms);\n\t\tr_cons_printf (\"imports %d\\n\", imps);\n\t\tr_cons_printf (\"covrage %d\\n\", covr);\n\t\tr_cons_printf (\"codesz  %d\\n\", code);\n\t\tr_cons_printf (\"percent %d%%\\n\", cvpc);\n\t}\n}\n\nstatic void cmd_anal_aad(RCore *core, const char *input) {\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tRList *list = r_list_newf (NULL);\n\tr_anal_xrefs_from (core->anal, list, \"xref\", R_ANAL_REF_TYPE_DATA, UT64_MAX);\n\tr_list_foreach (list, iter, ref) {\n\t\tif (r_io_is_valid_offset (core->io, ref->addr, false)) {\n\t\t\tr_core_anal_fcn (core, ref->at, ref->addr, R_ANAL_REF_TYPE_NULL, 1);\n\t\t}\n\t}\n\tr_list_free (list);\n}\n\n\nstatic bool archIsArmOrThumb(RCore *core) {\n\tRAsm *as = core ? core->assembler : NULL;\n\tif (as && as->cur && as->cur->arch) {\n\t\tif (r_str_startswith (as->cur->arch, \"mips\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (r_str_startswith (as->cur->arch, \"arm\")) {\n\t\t\tif (as->bits < 64) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nconst bool archIsMips (RCore *core) {\n\treturn strstr (core->assembler->cur->name, \"mips\");\n}\n\nvoid _CbInRangeAav(RCore *core, ut64 from, ut64 to, int vsize, bool asterisk, int count) {\n\tbool isarm = archIsArmOrThumb (core);\n\tif (isarm) {\n\t\tif (to & 1) {\n\t\t\t// .dword 0x000080b9 in reality is 0x000080b8\n\t\t\tto--;\n\t\t\tr_anal_hint_set_bits (core->anal, to, 16);\n\t\t\t// can we assume is gonna be always a function?\n\t\t} else {\n\t\t\tr_core_seek_archbits (core, from);\n\t\t\tut64 bits = r_config_get_i (core->config, \"asm.bits\");\n\t\t\tr_anal_hint_set_bits (core->anal, from, bits);\n\t\t}\n\t} else {\n\t\tbool ismips = archIsMips (core);\n\t\tif (ismips) {\n\t\t\tif (from % 4 || to % 4) {\n\t\t\t\teprintf (\"False positive\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (asterisk) {\n\t\tr_cons_printf (\"ax 0x%\"PFMT64x \" 0x%\"PFMT64x \"\\n\", to, from);\n\t\tr_cons_printf (\"Cd %d @ 0x%\"PFMT64x \"\\n\", vsize, from);\n\t\tr_cons_printf (\"f+ aav.0x%08\"PFMT64x \"= 0x%08\"PFMT64x, to, to);\n\t} else {\n#if 1\n\t\tr_anal_ref_add (core->anal, to, from, ' ');\n\t\tr_meta_add (core->anal, 'd', from, from + vsize, NULL);\n\t\tif (!r_flag_get_at (core->flags, to, false)) {\n\t\t\tchar *name = r_str_newf (\"aav.0x%08\"PFMT64x, to);\n\t\t\tr_flag_set (core->flags, name, to, vsize);\n\t\t\tfree (name);\n\t\t}\n#else\n\t\tr_core_cmdf (core, \"ax 0x%\"PFMT64x \" 0x%\"PFMT64x, to, from);\n\t\tr_core_cmdf (core, \"Cd %d @ 0x%\"PFMT64x, vsize, from);\n\t\tr_core_cmdf (core, \"f+ aav.0x%08\"PFMT64x \"= 0x%08\"PFMT64x, to, to);\n#endif\n\t}\n}\n\nstatic void cmd_anal_aav(RCore *core, const char *input) {\n#define seti(x,y) r_config_set_i(core->config, x, y);\n#define geti(x) r_config_get_i(core->config, x);\n\tut64 o_align = geti (\"search.align\");\n\tbool asterisk = strchr (input, '*');;\n\tbool is_debug = r_config_get_i (core->config, \"cfg.debug\");\n\n\t// pre\n\tint archAlign = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\tseti (\"search.align\", archAlign);\n\n\tint vsize = 4; // 32bit dword\n\tif (core->assembler->bits == 64) {\n\t\tvsize = 8;\n\t}\n\n\t// body\n\tr_cons_break_push (NULL, NULL);\n\tif (is_debug) {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, \"dbg.map\", \"anal\");\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teprintf (\"aav: from 0x%\"PFMT64x\" to 0x%\"PFMT64x\"\\n\", map->itv.addr, r_itv_end (map->itv));\n\t\t\t(void)r_core_search_value_in_range (core, map->itv,\n\t\t\t\tmap->itv.addr, r_itv_end (map->itv), vsize, asterisk, _CbInRangeAav);\n\t\t}\n\t\tr_list_free (list);\n\t} else {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, NULL, \"anal\");\n\t\tRListIter *iter, *iter2;\n\t\tRIOMap *map, *map2;\n\t\tut64 from = UT64_MAX;\n\t\tut64 to = UT64_MAX;\n\t\t// find values pointing to non-executable regions\n\t\tr_list_foreach (list, iter2, map2) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//TODO: Reduce multiple hits for same addr\n\t\t\tfrom = r_itv_begin (map2->itv);\n\t\t\tto = r_itv_end (map2->itv);\n\t\t\teprintf (\"Value from 0x%08\"PFMT64x \" to 0x%08\" PFMT64x \"\\n\", from, to);\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tut64 begin = map->itv.addr;\n\t\t\t\tut64 end = r_itv_end (map->itv);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (end - begin > UT32_MAX) {\n\t\t\t\t\teprintf (\"Skipping huge range\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\teprintf (\"aav: 0x%08\"PFMT64x\"-0x%08\"PFMT64x\" in 0x%\"PFMT64x\"-0x%\"PFMT64x\"\\n\", from, to, begin, end);\n\t\t\t\t(void)r_core_search_value_in_range (core, map->itv, from, to, vsize, asterisk, _CbInRangeAav);\n\t\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\n\tr_cons_break_pop ();\n\t// end\n\tseti (\"search.align\", o_align);\n}\n\nstatic bool should_aav(RCore *core) {\n\t// Don't aav on x86 for now\n\tif (r_str_startswith (r_config_get (core->config, \"asm.arch\"), \"x86\")) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int cmd_anal_all(RCore *core, const char *input) {\n\tswitch (*input) {\n\tcase '?': r_core_cmd_help (core, help_msg_aa); break;\n\tcase 'b': // \"aab\"\n\t\tcmd_anal_blocks (core, input + 1);\n\t\tbreak; // \"aab\"\n\tcase 'f': // \"aaf\"\n\t\t{\n\t\t\tint analHasnext = r_config_get_i (core->config, \"anal.hasnext\");\n\t\t\tr_config_set_i (core->config, \"anal.hasnext\", true);\n\t\t\tr_core_cmd0 (core, \"afr@@c:isq\");\n\t\t\tr_config_set_i (core->config, \"anal.hasnext\", analHasnext);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"aac\"\n\t\tswitch (input[1]) {\n\t\tcase '*':\n\t\t\tcmd_anal_calls (core, input + 1, true); break; // \"aac*\"\n\t\tdefault:\n\t\t\tcmd_anal_calls (core, input + 1, false); break; // \"aac\"\n\t\t}\n\tcase 'j': cmd_anal_jumps (core, input + 1); break; // \"aaj\"\n\tcase '*': // \"aa*\"\n\t\tr_core_cmd0 (core, \"af @@ sym.*\");\n\t\tr_core_cmd0 (core, \"af @@ entry*\");\n\t\tbreak;\n\tcase 'd': // \"aad\"\n\t\tcmd_anal_aad (core, input);\n\t\tbreak;\n\tcase 'v': // \"aav\"\n\t\tcmd_anal_aav (core, input);\n\t\tbreak;\n\tcase 'u': // \"aau\" - print areas not covered by functions\n\t\tr_core_anal_nofunclist (core, input + 1);\n\t\tbreak;\n\tcase 'i': // \"aai\"\n\t\tr_core_anal_info (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"aas\"\n\t\tr_core_cmd0 (core, \"af @@= `isq~[0]`\");\n\t\tr_core_cmd0 (core, \"af @@ entry*\");\n\t\tbreak;\n\tcase 'n': // \"aan\"\n\t\tr_core_anal_autoname_all_fcns (core);\n\t\tbreak; //aan\n\tcase 'p': // \"aap\"\n\t\tif (*input == '?') {\n\t\t\t// TODO: accept parameters for ranges\n\t\t\teprintf (\"Usage: /aap   ; find in memory for function preludes\");\n\t\t} else {\n\t\t\tr_core_search_preludes (core);\n\t\t}\n\t\tbreak;\n\tcase '\\0': // \"aa\"\n\tcase 'a':\n\t\tif (input[0] && (input[1] == '?' || (input[1] && input[2] == '?'))) {\n\t\t\tr_cons_println (\"Usage: See aa? for more help\");\n\t\t} else {\n\t\t\tchar *dh_orig = NULL;\n\t\t\tif (!strncmp (input, \"aaaaa\", 5)) {\n\t\t\t\teprintf (\"An r2 developer is coming to your place to manually analyze this program. Please wait for it\\n\");\n\t\t\t\tif (r_config_get_i (core->config, \"scr.interactive\")) {\n\t\t\t\t\tr_cons_any_key (NULL);\n\t\t\t\t}\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\t\t\tut64 curseek = core->offset;\n\t\t\trowlog (core, \"Analyze all flags starting with sym. and entry0 (aa)\");\n\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\tr_cons_break_timeout (r_config_get_i (core->config, \"anal.timeout\"));\n\t\t\tr_core_anal_all (core);\n\t\t\trowlog_done (core);\n\t\t\tdh_orig = core->dbg->h\n\t\t\t\t\t? strdup (core->dbg->h->name)\n\t\t\t\t\t: strdup (\"esil\");\n\t\t\tif (core->io && core->io->desc && core->io->desc->plugin && !core->io->desc->plugin->isdbg) {\n\t\t\t\t//use dh_origin if we are debugging\n\t\t\t\tR_FREE (dh_orig);\n\t\t\t}\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto jacuzzi;\n\t\t\t}\n\t\t\tr_cons_clear_line (1);\n\t\t\tif (*input == 'a') { // \"aaa\"\n\t\t\t\tif (dh_orig && strcmp (dh_orig, \"esil\")) {\n\t\t\t\t\tr_core_cmd0 (core, \"dL esil\");\n\t\t\t\t}\n\t\t\t\tint c = r_config_get_i (core->config, \"anal.calls\");\n\t\t\t\tif (should_aav (core)) {\n\t\t\t\t\trowlog (core, \"\\nAnalyze value pointers (aav)\");\n\t\t\t\t\tr_core_cmd0 (core, \"aav\");\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_config_set_i (core->config, \"anal.calls\", 1);\n\t\t\t\tr_core_cmd0 (core, \"s $S\");\n\t\t\t\trowlog (core, \"Analyze len bytes of instructions for references (aar)\");\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\t(void)r_core_anal_refs (core, \"\"); // \"aar\"\n\t\t\t\trowlog_done (core);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\trowlog (core, \"Analyze function calls (aac)\");\n\t\t\t\t(void) cmd_anal_calls (core, \"\", false); // \"aac\"\n\t\t\t\tr_core_seek (core, curseek, 1);\n\t\t\t\t// rowlog (core, \"Analyze data refs as code (LEA)\");\n\t\t\t\t// (void) cmd_anal_aad (core, NULL); // \"aad\"\n\t\t\t\trowlog_done (core);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\tif (input[1] == 'a') { // \"aaaa\"\n\t\t\t\t\tbool ioCache = r_config_get_i (core->config, \"io.pcache\");\n\t\t\t\t\tr_config_set_i (core->config, \"io.pcache\", 1);\n\t\t\t\t\trowlog (core, \"Emulate code to find computed references (aae)\");\n\t\t\t\t\tr_core_cmd0 (core, \"aae $SS @ $S\");\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t\trowlog (core, \"Analyze consecutive function (aat)\");\n\t\t\t\t\tr_core_cmd0 (core, \"aat\");\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t\t// drop cache writes is no cache was\n\t\t\t\t\tif (!ioCache) {\n\t\t\t\t\t\tr_core_cmd0 (core, \"wc-*\");\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set_i (core->config, \"io.pcache\", ioCache);\n\t\t\t\t} else {\n\t\t\t\t\trowlog (core, \"Use -AA or aaaa to perform additional experimental analysis.\");\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t}\n\t\t\t\tr_config_set_i (core->config, \"anal.calls\", c);\n\t\t\t\trowlog (core, \"Constructing a function name for fcn.* and sym.func.* functions (aan)\");\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tgoto jacuzzi;\n\t\t\t\t}\n\t\t\t\tif (r_config_get_i (core->config, \"anal.autoname\")) {\n\t\t\t\t\tr_core_anal_autoname_all_fcns (core);\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t}\n\t\t\t\tif (input[1] == 'a') { // \"aaaa\"\n\t\t\t\t\tbool ioCache = r_config_get_i (core->config, \"io.pcache\");\n\t\t\t\t\tr_config_set_i (core->config, \"io.pcache\", 1);\n\t\t\t\t\tif (sdb_count (core->anal->sdb_zigns) > 0) {\n\t\t\t\t\t\trowlog (core, \"Check for zignature from zigns folder (z/)\");\n\t\t\t\t\t\tr_core_cmd0 (core, \"z/\");\n\t\t\t\t\t}\n\t\t\t\t\trowlog (core, \"Type matching analysis for all functions (afta)\");\n\t\t\t\t\tr_core_cmd0 (core, \"afta\");\n\t\t\t\t\trowlog_done (core);\n\t\t\t\t\tif (!ioCache) {\n\t\t\t\t\t\tr_core_cmd0 (core, \"wc-*\");\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set_i (core->config, \"io.pcache\", ioCache);\n\t\t\t\t}\n\t\t\t\tr_core_cmd0 (core, \"s-\");\n\t\t\t\tif (dh_orig) {\n\t\t\t\t\tr_core_cmdf (core, \"dL %s;dpa\", dh_orig);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_seek (core, curseek, 1);\n\t\tjacuzzi:\n\t\t\tflag_every_function (core);\n\t\t\tr_cons_break_pop ();\n\t\t\tR_FREE (dh_orig);\n\t\t}\n\t\tbreak;\n\tcase 't': { // \"aat\"\n\t\tut64 cur = core->offset;\n\t\tbool hasnext = r_config_get_i (core->config, \"anal.hasnext\");\n\t\tRListIter *iter;\n\t\tRIOMap* map;\n\t\tRList *list = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, \"anal\");\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tr_core_seek (core, map->itv.addr, 1);\n\t\t\tr_config_set_i (core->config, \"anal.hasnext\", 1);\n\t\t\tr_core_cmd0 (core, \"afr\");\n\t\t\tr_config_set_i (core->config, \"anal.hasnext\", hasnext);\n\t\t}\n\t\tr_core_seek (core, cur, 1);\n\t\tbreak;\n\t}\n\tcase 'T': // \"aaT\"\n\t\tcmd_anal_aftertraps (core, input + 1);\n\t\tbreak;\n\tcase 'E': // \"aaE\"\n\t\tr_core_cmd0 (core, \"aef @@f\");\n\t\tbreak;\n\tcase 'e': // \"aae\"\n\t\tif (input[1]) {\n\t\t\tconst char *len = (char *) input + 1;\n\t\t\tchar *addr = strchr (input + 2, ' ');\n\t\t\tif (addr) {\n\t\t\t\t*addr++ = 0;\n\t\t\t}\n\t\t\tr_core_anal_esil (core, len, addr);\n\t\t} else {\n\t\t\tut64 at = core->offset;\n\t\t\tRIOMap* map;\n\t\t\tRListIter *iter;\n\t\t\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"anal\");\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tr_core_seek (core, map->itv.addr, 1);\n\t\t\t\tr_core_anal_esil (core, \"$SS\", NULL);\n\t\t\t}\n\t\t\tr_core_seek (core, at, 1);\n\t\t}\n\t\tbreak;\n\tcase 'r':\n\t\t(void)r_core_anal_refs (core, input + 1);\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_aa);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_fcn_size (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t\tgap = false;\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int cmpaddr (const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn a->addr - b->addr;\n}\n\nstatic bool anal_fcn_data_gaps (RCore *core, const char *input) {\n\tut64 end = UT64_MAX;\n\tRAnalFunction *fcn;\n\tRListIter *iter;\n\tint i, wordsize = (core->assembler->bits == 64)? 8: 4;\n\tr_list_sort (core->anal->fcns, cmpaddr);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tif (end != UT64_MAX) {\n\t\t\tint range = fcn->addr - end;\n\t\t\tif (range > 0) {\n\t\t\t\tfor (i = 0; i + wordsize < range; i+= wordsize) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", wordsize, end + i);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", range - i, end + i);\n\t\t\t\t//r_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", range, end);\n\t\t\t}\n\t\t}\n\t\tend = fcn->addr + r_anal_fcn_size (fcn);\n\t}\n\treturn true;\n}\n\nstatic void cmd_anal_rtti(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '\\0': // \"avr\"\n\tcase 'j': // \"avrj\"\n\t\tr_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);\n\t\tbreak;\n\tcase 'a': // \"avra\"\n\t\tr_anal_rtti_print_all (core->anal, input[1]);\n\t\tbreak;\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_anal_virtual_functions(RCore *core, const char* input) {\n\tswitch (input[0]) {\n\tcase '\\0': // \"av\"\n\tcase '*': // \"av*\"\n\tcase 'j': // \"avj\"\n\t\tr_anal_list_vtables (core->anal, input[0]);\n\t\tbreak;\n\tcase 'r': // \"avr\"\n\t\tcmd_anal_rtti (core, input + 1);\n\t\tbreak;\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}\n\nstatic int cmd_anal(void *data, const char *input) {\n\tconst char *r;\n\tRCore *core = (RCore *)data;\n\tut32 tbs = core->blocksize;\n\n\tswitch (input[0]) {\n\tcase 'p': // \"ap\"\n\t\t{\n\t\t\tconst ut8 *prelude = (const ut8*)\"\\xe9\\x2d\"; //:fffff000\";\n\t\t\tconst int prelude_sz = 2;\n\t\t\tconst int bufsz = 4096;\n\t\t\tut8 *buf = calloc (1, bufsz);\n\t\t\tut64 off = core->offset;\n\t\t\tif (input[1] == ' ') {\n\t\t\t\toff = r_num_math (core->num, input+1);\n\t\t\t\tr_io_read_at (core->io, off - bufsz + prelude_sz, buf, bufsz);\n\t\t\t} else {\n\t\t\t\tr_io_read_at (core->io, off - bufsz + prelude_sz, buf, bufsz);\n\t\t\t}\n\t\t\t//const char *prelude = \"\\x2d\\xe9\\xf0\\x47\"; //:fffff000\";\n\t\t\tr_mem_reverse (buf, bufsz);\n\t\t\t//r_print_hexdump (NULL, off, buf, bufsz, 16, -16);\n\t\t\tconst ut8 *pos = r_mem_mem (buf, bufsz, prelude, prelude_sz);\n\t\t\tif (pos) {\n\t\t\t\tint delta = (size_t)(pos - buf);\n\t\t\t\teprintf (\"POS = %d\\n\", delta);\n\t\t\t\teprintf (\"HIT = 0x%\"PFMT64x\"\\n\", off - delta);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", off - delta);\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot find prelude\\n\");\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase '8':\n\t\t{\n\t\t\tut8 *buf = malloc (strlen (input) + 1);\n\t\t\tif (buf) {\n\t\t\t\tint len = r_hex_str2bin (input + 1, buf);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tcore_anal_bytes (core, buf, len, 0, input[1]);\n\t\t\t\t}\n\t\t\t\tfree (buf);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'b':\n\t\tif (input[1] == 'b') { // \"abb\"\n\t\t\tcore_anal_bbs (core, input + 2);\n\t\t} else if (input[1] == 'r') { // \"abr\"\n\t\t\tcore_anal_bbs_range (core, input + 2);\n\t\t} else if (input[1] == ' ' || !input[1]) {\n\t\t\t// find block\n\t\t\tut64 addr = core->offset;\n\t\t\tif (input[1]) {\n\t\t\t\taddr = r_num_math (core->num, input + 1);\n\t\t\t}\n\t\t\tr_core_cmdf (core, \"afbi @ 0x%\"PFMT64x, addr);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ab);\n\t\t}\n\t\tbreak;\n\tcase 'i': cmd_anal_info (core, input + 1); break; // \"ai\"\n\tcase 'r': cmd_anal_reg (core, input + 1); break;  // \"ar\"\n\tcase 'e': cmd_anal_esil (core, input + 1); break; // \"ae\"\n\tcase 'o': cmd_anal_opcode (core, input + 1); break; // \"ao\"\n\tcase 'O': cmd_anal_bytes (core, input + 1); break; // \"aO\"\n\tcase 'F': // \"aF\"\n\t\tr_core_anal_fcn (core, core->offset, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n\t\tbreak;\n\tcase 'f': // \"af\"\n\t\t{\n\t\tint res = cmd_anal_fcn (core, input);\n\t\tif (!res) {\n\t\t\treturn false;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'n': // 'an'\n\t\t{\n\t\tconst char *name = NULL;\n\t\tbool use_json = false;\n\n\t\tif (input[1] == 'j') {\n\t\t\tuse_json = true;\n\t\t\tinput++;\n\t\t}\n\n\t\tif (input[1] == ' ') {\n\t\t\tname = input + 1;\n\t\t\twhile (name[0] == ' ') {\n\t\t\t\tname++;\n\t\t\t}\n\t\t\tchar *end = strchr (name, ' ');\n\t\t\tif (end) {\n\t\t\t\t*end = '\\0';\n\t\t\t}\n\t\t\tif (*name == '\\0') {\n\t\t\t\tname = NULL;\n\t\t\t}\n\t\t}\n\n\t\tcmd_an (core, use_json, name);\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"ag\"\n\t\tcmd_anal_graph (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"as\"\n\t\tcmd_anal_syscall (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"av\"\n\t\tcmd_anal_virtual_functions (core, input + 1);\n\t\tbreak;\n\tcase 'x': // \"ax\"\n\t\tif (!cmd_anal_refs (core, input + 1)) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"aa\"\n\t\tif (!cmd_anal_all (core, input + 1))\n\t\t\treturn false;\n\t\tbreak;\n\tcase 'c': // \"ac\"\n\t\t{\n\t\tRList *hooks;\n\t\tRListIter *iter;\n\t\tRAnalCycleHook *hook;\n\t\tchar *instr_tmp = NULL;\n\t\tint ccl = input[1]? r_num_math (core->num, &input[2]): 0; //get cycles to look for\n\t\tint cr = r_config_get_i (core->config, \"asm.cmt.right\");\n\t\tint fun = r_config_get_i (core->config, \"asm.functions\");\n\t\tint li = r_config_get_i (core->config, \"asm.lines\");\n\t\tint xr = r_config_get_i (core->config, \"asm.xrefs\");\n\n\t\tr_config_set_i (core->config, \"asm.cmt.right\", true);\n\t\tr_config_set_i (core->config, \"asm.functions\", false);\n\t\tr_config_set_i (core->config, \"asm.lines\", false);\n\t\tr_config_set_i (core->config, \"asm.xrefs\", false);\n\n\t\thooks = r_core_anal_cycles (core, ccl); //analyse\n\t\tr_cons_clear_line (1);\n\t\tr_list_foreach (hooks, iter, hook) {\n\t\t\tinstr_tmp = r_core_disassemble_instr (core, hook->addr, 1);\n\t\t\tr_cons_printf (\"After %4i cycles:\\t%s\", (ccl - hook->cycles), instr_tmp);\n\t\t\tr_cons_flush ();\n\t\t\tfree (instr_tmp);\n\t\t}\n\t\tr_list_free (hooks);\n\n\t\tr_config_set_i (core->config, \"asm.cmt.right\", cr); //reset settings\n\t\tr_config_set_i (core->config, \"asm.functions\", fun);\n\t\tr_config_set_i (core->config, \"asm.lines\", li);\n\t\tr_config_set_i (core->config, \"asm.xrefs\", xr);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ad\"\n\t\tswitch (input[1]) {\n\t\tcase 'f': // \"adf\"\n\t\t\tif (input[2] == 'g') {\n\t\t\t\tanal_fcn_data_gaps (core, input + 1);\n\t\t\t} else {\n\t\t\t\tanal_fcn_data (core, input + 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't': // \"adt\"\n\t\t\tcmd_anal_trampoline (core, input + 2);\n\t\t\tbreak;\n\t\tcase ' ': { // \"ad\"\n\t\t\tconst int default_depth = 1;\n\t\t\tconst char *p;\n\t\t\tint a, b;\n\t\t\ta = r_num_math (core->num, input + 2);\n\t\t\tp = strchr (input + 2, ' ');\n\t\t\tb = p? r_num_math (core->num, p + 1): default_depth;\n\t\t\tif (a < 1) {\n\t\t\t\ta = 1;\n\t\t\t}\n\t\t\tif (b < 1) {\n\t\t\t\tb = 1;\n\t\t\t}\n\t\t\tr_core_anal_data (core, core->offset, a, b, 0);\n\t\t} break;\n\t\tcase 'k': // \"adk\"\n\t\t\tr = r_anal_data_kind (core->anal,\n\t\t\t\t\tcore->offset, core->block, core->blocksize);\n\t\t\tr_cons_println (r);\n\t\t\tbreak;\n\t\tcase '\\0': // \"ad\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 0);\n\t\t\tbreak;\n\t\tcase '4': // \"ad4\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 4);\n\t\t\tbreak;\n\t\tcase '8': // \"ad8\"\n\t\t\tr_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_ad);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ah\"\n\t\tcmd_anal_hint (core, input + 1);\n\t\tbreak;\n\tcase '!': // \"a!\"\n\t\tif (core->anal && core->anal->cur && core->anal->cur->cmd_ext) {\n\t\t\treturn core->anal->cur->cmd_ext (core->anal, input + 1);\n\t\t} else {\n\t\t\tr_cons_printf (\"No plugins for this analysis plugin\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_a);\n#if 0\n\t\tr_cons_printf (\"Examples:\\n\"\n\t\t\t\" f ts @ `S*~text:0[3]`; f t @ section..text\\n\"\n\t\t\t\" f ds @ `S*~data:0[3]`; f d @ section..data\\n\"\n\t\t\t\" .ad t t+ts @ d:ds\\n\",\n\t\t\tNULL);\n#endif\n\t\tbreak;\n\t}\n\tif (tbs != core->blocksize) {\n\t\tr_core_block_size (core, tbs);\n\t}\n\tif (r_cons_is_breaked ()) {\n\t\tr_cons_clear_line (1);\n\t}\n\treturn 0;\n}\n"], "filenames": ["libr/anal/p/anal_avr.c", "libr/core/cmd_anal.c"], "buggy_code_start_loc": [622, 4353], "buggy_code_end_loc": [623, 4354], "fixing_code_start_loc": [622, 4353], "fixing_code_end_loc": [623, 4356], "type": "CWE-908", "message": "The r_strbuf_fini() function in radare2 2.5.0 allows remote attackers to cause a denial of service (invalid free and application crash) via a crafted ELF file because of an uninitialized variable in the CPSE handler in libr/anal/p/anal_avr.c.", "other": {"cve": {"id": "CVE-2018-11383", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-22T19:29:00.617", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The r_strbuf_fini() function in radare2 2.5.0 allows remote attackers to cause a denial of service (invalid free and application crash) via a crafted ELF file because of an uninitialized variable in the CPSE handler in libr/anal/p/anal_avr.c."}, {"lang": "es", "value": "La funci\u00f3n r_strbuf_fini() en radare2 2.5.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (liberaci\u00f3n no v\u00e1lida y cierre inesperado de la aplicaci\u00f3n) mediante un archivo ELF manipulado debido a una variable no inicializada en el manipulador CPSE en libr/anal/p/anal_avr.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "81E40EFA-5307-45F3-9722-CB499D21141F"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/9943", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a"}}