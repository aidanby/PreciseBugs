{"buggy_code": ["from ceph_volume.util import encryption\n\n\nclass TestStatus(object):\n\n    def test_skips_unuseful_lines(self, stub_call):\n        out = ['some line here', '  device: /dev/sdc1']\n        stub_call((out, '', 0))\n        assert encryption.status('/dev/sdc1') == {'device': '/dev/sdc1'}\n\n    def test_removes_extra_quotes(self, stub_call):\n        out = ['some line here', '  device: \"/dev/sdc1\"']\n        stub_call((out, '', 0))\n        assert encryption.status('/dev/sdc1') == {'device': '/dev/sdc1'}\n\n    def test_ignores_bogus_lines(self, stub_call):\n        out = ['some line here', '  ']\n        stub_call((out, '', 0))\n        assert encryption.status('/dev/sdc1') == {}\n\n\nclass TestDmcryptClose(object):\n\n    def test_mapper_exists(self, fake_run, tmpfile):\n        file_name = tmpfile(name='mapper-device')\n        encryption.dmcrypt_close(file_name)\n        arguments = fake_run.calls[0]['args'][0]\n        assert arguments[0] == 'cryptsetup'\n        assert arguments[1] == 'remove'\n        assert arguments[2].startswith('/')\n\n    def test_mapper_does_not_exist(self, fake_run):\n        file_name = '/path/does/not/exist'\n        encryption.dmcrypt_close(file_name)\n        assert fake_run.calls == []\n\n\nclass TestDmcryptKey(object):\n\n    def test_dmcrypt_with_default_size(self, conf_ceph_stub):\n        conf_ceph_stub('[global]\\nfsid=asdf-lkjh')\n        result = encryption.create_dmcrypt_key()\n        assert len(result) == 172\n\n    def test_dmcrypt_with_custom_size(self, conf_ceph_stub):\n        conf_ceph_stub('''\n        [global]\n        fsid=asdf\n        [osd]\n        osd_dmcrypt_size=8\n        ''')\n        result = encryption.create_dmcrypt_key()\n        assert len(result) == 172\n", "import base64\nimport os\nimport logging\nfrom ceph_volume import process, conf\nfrom ceph_volume.util import constants, system\nfrom ceph_volume.util.device import Device\nfrom .prepare import write_keyring\nfrom .disk import lsblk, device_family, get_part_entry_type\n\nlogger = logging.getLogger(__name__)\n\n\ndef create_dmcrypt_key():\n    \"\"\"\n    Create the secret dm-crypt key used to decrypt a device.\n    \"\"\"\n    # get the customizable dmcrypt key size (in bits) from ceph.conf fallback\n    # to the default of 1024\n    dmcrypt_key_size = conf.ceph.get_safe(\n        'osd',\n        'osd_dmcrypt_key_size',\n        default=1024,\n    )\n    # The size of the key is defined in bits, so we must transform that\n    # value to bytes (dividing by 8) because we read in bytes, not bits\n    random_string = os.urandom(int(dmcrypt_key_size / 8))\n    key = base64.b64encode(random_string).decode('utf-8')\n    return key\n\n\ndef luks_format(key, device):\n    \"\"\"\n    Decrypt (open) an encrypted device, previously prepared with cryptsetup\n\n    :param key: dmcrypt secret key, will be used for decrypting\n    :param device: Absolute path to device\n    \"\"\"\n    command = [\n        'cryptsetup',\n        '--batch-mode', # do not prompt\n        '--key-file', # misnomer, should be key\n        '-',          # because we indicate stdin for the key here\n        'luksFormat',\n        device,\n    ]\n    process.call(command, stdin=key, terminal_verbose=True, show_command=True)\n\n\ndef plain_open(key, device, mapping):\n    \"\"\"\n    Decrypt (open) an encrypted device, previously prepared with cryptsetup in plain mode\n\n    .. note: ceph-disk will require an additional b64decode call for this to work\n\n    :param key: dmcrypt secret key\n    :param device: absolute path to device\n    :param mapping: mapping name used to correlate device. Usually a UUID\n    \"\"\"\n    command = [\n        'cryptsetup',\n        '--key-file',\n        '-',\n        '--allow-discards',  # allow discards (aka TRIM) requests for device\n        'open',\n        device,\n        mapping,\n        '--type', 'plain',\n        '--key-size', '256',\n    ]\n\n    process.call(command, stdin=key, terminal_verbose=True, show_command=True)\n\n\ndef luks_open(key, device, mapping):\n    \"\"\"\n    Decrypt (open) an encrypted device, previously prepared with cryptsetup\n\n    .. note: ceph-disk will require an additional b64decode call for this to work\n\n    :param key: dmcrypt secret key\n    :param device: absolute path to device\n    :param mapping: mapping name used to correlate device. Usually a UUID\n    \"\"\"\n    command = [\n        'cryptsetup',\n        '--key-file',\n        '-',\n        '--allow-discards',  # allow discards (aka TRIM) requests for device\n        'luksOpen',\n        device,\n        mapping,\n    ]\n    process.call(command, stdin=key, terminal_verbose=True, show_command=True)\n\n\ndef dmcrypt_close(mapping):\n    \"\"\"\n    Encrypt (close) a device, previously decrypted with cryptsetup\n\n    :param mapping:\n    \"\"\"\n    if not os.path.exists(mapping):\n        logger.debug('device mapper path does not exist %s' % mapping)\n        logger.debug('will skip cryptsetup removal')\n        return\n    # don't be strict about the remove call, but still warn on the terminal if it fails\n    process.run(['cryptsetup', 'remove', mapping], stop_on_error=False)\n\n\ndef get_dmcrypt_key(osd_id, osd_fsid, lockbox_keyring=None):\n    \"\"\"\n    Retrieve the dmcrypt (secret) key stored initially on the monitor. The key\n    is sent initially with JSON, and the Monitor then mangles the name to\n    ``dm-crypt/osd/<fsid>/luks``\n\n    The ``lockbox.keyring`` file is required for this operation, and it is\n    assumed it will exist on the path for the same OSD that is being activated.\n    To support scanning, it is optionally configurable to a custom location\n    (e.g. inside a lockbox partition mounted in a temporary location)\n    \"\"\"\n    if lockbox_keyring is None:\n        lockbox_keyring = '/var/lib/ceph/osd/%s-%s/lockbox.keyring' % (conf.cluster, osd_id)\n    name = 'client.osd-lockbox.%s' % osd_fsid\n    config_key = 'dm-crypt/osd/%s/luks' % osd_fsid\n\n    stdout, stderr, returncode = process.call(\n        [\n            'ceph',\n            '--cluster', conf.cluster,\n            '--name', name,\n            '--keyring', lockbox_keyring,\n            'config-key',\n            'get',\n            config_key\n        ],\n        show_command=True\n    )\n    if returncode != 0:\n        raise RuntimeError('Unable to retrieve dmcrypt secret')\n    return ' '.join(stdout).strip()\n\n\ndef write_lockbox_keyring(osd_id, osd_fsid, secret):\n    \"\"\"\n    Helper to write the lockbox keyring. This is needed because the bluestore OSD will\n    not persist the keyring, and it can't be stored in the data device for filestore because\n    at the time this is needed, the device is encrypted.\n\n    For bluestore: A tmpfs filesystem is mounted, so the path can get written\n    to, but the files are ephemeral, which requires this file to be created\n    every time it is activated.\n    For filestore: The path for the OSD would exist at this point even if no\n    OSD data device is mounted, so the keyring is written to fetch the key, and\n    then the data device is mounted on that directory, making the keyring\n    \"disappear\".\n    \"\"\"\n    if os.path.exists('/var/lib/ceph/osd/%s-%s/lockbox.keyring' % (conf.cluster, osd_id)):\n        return\n\n    name = 'client.osd-lockbox.%s' % osd_fsid\n    write_keyring(\n        osd_id,\n        secret,\n        keyring_name='lockbox.keyring',\n        name=name\n    )\n\n\ndef status(device):\n    \"\"\"\n    Capture the metadata information of a possibly encrypted device, returning\n    a dictionary with all the values found (if any).\n\n    An encrypted device will contain information about a device. Example\n    successful output looks like::\n\n        $ cryptsetup status /dev/mapper/ed6b5a26-eafe-4cd4-87e3-422ff61e26c4\n        /dev/mapper/ed6b5a26-eafe-4cd4-87e3-422ff61e26c4 is active and is in use.\n          type:    LUKS1\n          cipher:  aes-xts-plain64\n          keysize: 256 bits\n          device:  /dev/sdc2\n          offset:  4096 sectors\n          size:    20740063 sectors\n          mode:    read/write\n\n    As long as the mapper device is in 'open' state, the ``status`` call will work.\n\n    :param device: Absolute path or UUID of the device mapper\n    \"\"\"\n    command = [\n        'cryptsetup',\n        'status',\n        device,\n    ]\n    out, err, code = process.call(command, show_command=True, verbose_on_failure=False)\n\n    metadata = {}\n    if code != 0:\n        logger.warning('failed to detect device mapper information')\n        return metadata\n    for line in out:\n        # get rid of lines that might not be useful to construct the report:\n        if not line.startswith(' '):\n            continue\n        try:\n            column, value = line.split(': ')\n        except ValueError:\n            continue\n        metadata[column.strip()] = value.strip().strip('\"')\n    return metadata\n\n\ndef legacy_encrypted(device):\n    \"\"\"\n    Detect if a device was encrypted with ceph-disk or not. In the case of\n    encrypted devices, include the type of encryption (LUKS, or PLAIN), and\n    infer what the lockbox partition is.\n\n    This function assumes that ``device`` will be a partition.\n    \"\"\"\n    if os.path.isdir(device):\n        mounts = system.get_mounts(paths=True)\n        # yes, rebind the device variable here because a directory isn't going\n        # to help with parsing\n        device = mounts.get(device, [None])[0]\n        if not device:\n            raise RuntimeError('unable to determine the device mounted at %s' % device)\n    metadata = {'encrypted': False, 'type': None, 'lockbox': '', 'device': device}\n    # check if the device is online/decrypted first\n    active_mapper = status(device)\n    if active_mapper:\n        # normalize a bit to ensure same values regardless of source\n        metadata['type'] = active_mapper['type'].lower().strip('12')  # turn LUKS1 or LUKS2 into luks\n        metadata['encrypted'] = True if metadata['type'] in ['plain', 'luks'] else False\n        # The true device is now available to this function, so it gets\n        # re-assigned here for the lockbox checks to succeed (it is not\n        # possible to guess partitions from a device mapper device otherwise\n        device = active_mapper.get('device', device)\n        metadata['device'] = device\n    else:\n        uuid = get_part_entry_type(device)\n        guid_match = constants.ceph_disk_guids.get(uuid, {})\n        encrypted_guid = guid_match.get('encrypted', False)\n        if encrypted_guid:\n            metadata['encrypted'] = True\n            metadata['type'] = guid_match['encryption_type']\n\n    # Lets find the lockbox location now, to do this, we need to find out the\n    # parent device name for the device so that we can query all of its\n    # associated devices and *then* look for one that has the 'lockbox' label\n    # on it. Thanks for being awesome ceph-disk\n    disk_meta = lsblk(device, abspath=True)\n    if not disk_meta:\n        return metadata\n    parent_device = disk_meta['PKNAME']\n    # With the parent device set, we can now look for the lockbox listing associated devices\n    devices = [Device(i['NAME']) for i in device_family(parent_device)]\n    for d in devices:\n        if d.ceph_disk.type == 'lockbox':\n            metadata['lockbox'] = d.abspath\n            break\n    return metadata\n"], "fixing_code": ["from ceph_volume.util import encryption\nimport base64\n\nclass TestGetKeySize(object):\n    def test_get_size_from_conf_default(self, conf_ceph_stub):\n        conf_ceph_stub('''\n        [global]\n        fsid=asdf\n        ''')\n        assert encryption.get_key_size_from_conf() == '512'\n\n    def test_get_size_from_conf_custom(self, conf_ceph_stub):\n        conf_ceph_stub('''\n        [global]\n        fsid=asdf\n        [osd]\n        osd_dmcrypt_key_size=256\n        ''')\n        assert encryption.get_key_size_from_conf() == '256'\n\n    def test_get_size_from_conf_custom_invalid(self, conf_ceph_stub):\n        conf_ceph_stub('''\n        [global]\n        fsid=asdf\n        [osd]\n        osd_dmcrypt_key_size=1024\n        ''')\n        assert encryption.get_key_size_from_conf() == '512'\n\nclass TestStatus(object):\n\n    def test_skips_unuseful_lines(self, stub_call):\n        out = ['some line here', '  device: /dev/sdc1']\n        stub_call((out, '', 0))\n        assert encryption.status('/dev/sdc1') == {'device': '/dev/sdc1'}\n\n    def test_removes_extra_quotes(self, stub_call):\n        out = ['some line here', '  device: \"/dev/sdc1\"']\n        stub_call((out, '', 0))\n        assert encryption.status('/dev/sdc1') == {'device': '/dev/sdc1'}\n\n    def test_ignores_bogus_lines(self, stub_call):\n        out = ['some line here', '  ']\n        stub_call((out, '', 0))\n        assert encryption.status('/dev/sdc1') == {}\n\n\nclass TestDmcryptClose(object):\n\n    def test_mapper_exists(self, fake_run, tmpfile):\n        file_name = tmpfile(name='mapper-device')\n        encryption.dmcrypt_close(file_name)\n        arguments = fake_run.calls[0]['args'][0]\n        assert arguments[0] == 'cryptsetup'\n        assert arguments[1] == 'remove'\n        assert arguments[2].startswith('/')\n\n    def test_mapper_does_not_exist(self, fake_run):\n        file_name = '/path/does/not/exist'\n        encryption.dmcrypt_close(file_name)\n        assert fake_run.calls == []\n\n\nclass TestDmcryptKey(object):\n\n    def test_dmcrypt(self):\n        result = encryption.create_dmcrypt_key()\n        assert len(base64.b64decode(result)) == 128\n", "import base64\nimport os\nimport logging\nfrom ceph_volume import process, conf\nfrom ceph_volume.util import constants, system\nfrom ceph_volume.util.device import Device\nfrom .prepare import write_keyring\nfrom .disk import lsblk, device_family, get_part_entry_type\n\nlogger = logging.getLogger(__name__)\n\ndef get_key_size_from_conf():\n    \"\"\"\n    Return the osd dmcrypt key size from config file.\n    Default is 512.\n    \"\"\"\n    default_key_size = '512'\n    key_size = conf.ceph.get_safe(\n        'osd',\n        'osd_dmcrypt_key_size',\n        default='512')\n\n    if key_size not in ['256', '512']:\n        logger.warning((\"Invalid value set for osd_dmcrypt_key_size ({}). \"\n                        \"Falling back to {}bits\".format(key_size, default_key_size)))\n        return default_key_size\n\n    return key_size\n\ndef create_dmcrypt_key():\n    \"\"\"\n    Create the secret dm-crypt key (KEK) used to encrypt/decrypt the Volume Key.\n    \"\"\"\n    random_string = os.urandom(128)\n    key = base64.b64encode(random_string).decode('utf-8')\n    return key\n\n\ndef luks_format(key, device):\n    \"\"\"\n    Decrypt (open) an encrypted device, previously prepared with cryptsetup\n\n    :param key: dmcrypt secret key, will be used for decrypting\n    :param device: Absolute path to device\n    \"\"\"\n    command = [\n        'cryptsetup',\n        '--batch-mode', # do not prompt\n        '--key-size',\n        get_key_size_from_conf(),\n        '--key-file', # misnomer, should be key\n        '-',          # because we indicate stdin for the key here\n        'luksFormat',\n        device,\n    ]\n    process.call(command, stdin=key, terminal_verbose=True, show_command=True)\n\n\ndef plain_open(key, device, mapping):\n    \"\"\"\n    Decrypt (open) an encrypted device, previously prepared with cryptsetup in plain mode\n\n    .. note: ceph-disk will require an additional b64decode call for this to work\n\n    :param key: dmcrypt secret key\n    :param device: absolute path to device\n    :param mapping: mapping name used to correlate device. Usually a UUID\n    \"\"\"\n    command = [\n        'cryptsetup',\n        '--key-file',\n        '-',\n        '--allow-discards',  # allow discards (aka TRIM) requests for device\n        'open',\n        device,\n        mapping,\n        '--type', 'plain',\n        '--key-size', '256',\n    ]\n\n    process.call(command, stdin=key, terminal_verbose=True, show_command=True)\n\n\ndef luks_open(key, device, mapping):\n    \"\"\"\n    Decrypt (open) an encrypted device, previously prepared with cryptsetup\n\n    .. note: ceph-disk will require an additional b64decode call for this to work\n\n    :param key: dmcrypt secret key\n    :param device: absolute path to device\n    :param mapping: mapping name used to correlate device. Usually a UUID\n    \"\"\"\n    command = [\n        'cryptsetup',\n        '--key-size',\n        get_key_size_from_conf(),\n        '--key-file',\n        '-',\n        '--allow-discards',  # allow discards (aka TRIM) requests for device\n        'luksOpen',\n        device,\n        mapping,\n    ]\n    process.call(command, stdin=key, terminal_verbose=True, show_command=True)\n\n\ndef dmcrypt_close(mapping):\n    \"\"\"\n    Encrypt (close) a device, previously decrypted with cryptsetup\n\n    :param mapping:\n    \"\"\"\n    if not os.path.exists(mapping):\n        logger.debug('device mapper path does not exist %s' % mapping)\n        logger.debug('will skip cryptsetup removal')\n        return\n    # don't be strict about the remove call, but still warn on the terminal if it fails\n    process.run(['cryptsetup', 'remove', mapping], stop_on_error=False)\n\n\ndef get_dmcrypt_key(osd_id, osd_fsid, lockbox_keyring=None):\n    \"\"\"\n    Retrieve the dmcrypt (secret) key stored initially on the monitor. The key\n    is sent initially with JSON, and the Monitor then mangles the name to\n    ``dm-crypt/osd/<fsid>/luks``\n\n    The ``lockbox.keyring`` file is required for this operation, and it is\n    assumed it will exist on the path for the same OSD that is being activated.\n    To support scanning, it is optionally configurable to a custom location\n    (e.g. inside a lockbox partition mounted in a temporary location)\n    \"\"\"\n    if lockbox_keyring is None:\n        lockbox_keyring = '/var/lib/ceph/osd/%s-%s/lockbox.keyring' % (conf.cluster, osd_id)\n    name = 'client.osd-lockbox.%s' % osd_fsid\n    config_key = 'dm-crypt/osd/%s/luks' % osd_fsid\n\n    stdout, stderr, returncode = process.call(\n        [\n            'ceph',\n            '--cluster', conf.cluster,\n            '--name', name,\n            '--keyring', lockbox_keyring,\n            'config-key',\n            'get',\n            config_key\n        ],\n        show_command=True\n    )\n    if returncode != 0:\n        raise RuntimeError('Unable to retrieve dmcrypt secret')\n    return ' '.join(stdout).strip()\n\n\ndef write_lockbox_keyring(osd_id, osd_fsid, secret):\n    \"\"\"\n    Helper to write the lockbox keyring. This is needed because the bluestore OSD will\n    not persist the keyring, and it can't be stored in the data device for filestore because\n    at the time this is needed, the device is encrypted.\n\n    For bluestore: A tmpfs filesystem is mounted, so the path can get written\n    to, but the files are ephemeral, which requires this file to be created\n    every time it is activated.\n    For filestore: The path for the OSD would exist at this point even if no\n    OSD data device is mounted, so the keyring is written to fetch the key, and\n    then the data device is mounted on that directory, making the keyring\n    \"disappear\".\n    \"\"\"\n    if os.path.exists('/var/lib/ceph/osd/%s-%s/lockbox.keyring' % (conf.cluster, osd_id)):\n        return\n\n    name = 'client.osd-lockbox.%s' % osd_fsid\n    write_keyring(\n        osd_id,\n        secret,\n        keyring_name='lockbox.keyring',\n        name=name\n    )\n\n\ndef status(device):\n    \"\"\"\n    Capture the metadata information of a possibly encrypted device, returning\n    a dictionary with all the values found (if any).\n\n    An encrypted device will contain information about a device. Example\n    successful output looks like::\n\n        $ cryptsetup status /dev/mapper/ed6b5a26-eafe-4cd4-87e3-422ff61e26c4\n        /dev/mapper/ed6b5a26-eafe-4cd4-87e3-422ff61e26c4 is active and is in use.\n          type:    LUKS1\n          cipher:  aes-xts-plain64\n          keysize: 256 bits\n          device:  /dev/sdc2\n          offset:  4096 sectors\n          size:    20740063 sectors\n          mode:    read/write\n\n    As long as the mapper device is in 'open' state, the ``status`` call will work.\n\n    :param device: Absolute path or UUID of the device mapper\n    \"\"\"\n    command = [\n        'cryptsetup',\n        'status',\n        device,\n    ]\n    out, err, code = process.call(command, show_command=True, verbose_on_failure=False)\n\n    metadata = {}\n    if code != 0:\n        logger.warning('failed to detect device mapper information')\n        return metadata\n    for line in out:\n        # get rid of lines that might not be useful to construct the report:\n        if not line.startswith(' '):\n            continue\n        try:\n            column, value = line.split(': ')\n        except ValueError:\n            continue\n        metadata[column.strip()] = value.strip().strip('\"')\n    return metadata\n\n\ndef legacy_encrypted(device):\n    \"\"\"\n    Detect if a device was encrypted with ceph-disk or not. In the case of\n    encrypted devices, include the type of encryption (LUKS, or PLAIN), and\n    infer what the lockbox partition is.\n\n    This function assumes that ``device`` will be a partition.\n    \"\"\"\n    if os.path.isdir(device):\n        mounts = system.get_mounts(paths=True)\n        # yes, rebind the device variable here because a directory isn't going\n        # to help with parsing\n        device = mounts.get(device, [None])[0]\n        if not device:\n            raise RuntimeError('unable to determine the device mounted at %s' % device)\n    metadata = {'encrypted': False, 'type': None, 'lockbox': '', 'device': device}\n    # check if the device is online/decrypted first\n    active_mapper = status(device)\n    if active_mapper:\n        # normalize a bit to ensure same values regardless of source\n        metadata['type'] = active_mapper['type'].lower().strip('12')  # turn LUKS1 or LUKS2 into luks\n        metadata['encrypted'] = True if metadata['type'] in ['plain', 'luks'] else False\n        # The true device is now available to this function, so it gets\n        # re-assigned here for the lockbox checks to succeed (it is not\n        # possible to guess partitions from a device mapper device otherwise\n        device = active_mapper.get('device', device)\n        metadata['device'] = device\n    else:\n        uuid = get_part_entry_type(device)\n        guid_match = constants.ceph_disk_guids.get(uuid, {})\n        encrypted_guid = guid_match.get('encrypted', False)\n        if encrypted_guid:\n            metadata['encrypted'] = True\n            metadata['type'] = guid_match['encryption_type']\n\n    # Lets find the lockbox location now, to do this, we need to find out the\n    # parent device name for the device so that we can query all of its\n    # associated devices and *then* look for one that has the 'lockbox' label\n    # on it. Thanks for being awesome ceph-disk\n    disk_meta = lsblk(device, abspath=True)\n    if not disk_meta:\n        return metadata\n    parent_device = disk_meta['PKNAME']\n    # With the parent device set, we can now look for the lockbox listing associated devices\n    devices = [Device(i['NAME']) for i in device_family(parent_device)]\n    for d in devices:\n        if d.ceph_disk.type == 'lockbox':\n            metadata['lockbox'] = d.abspath\n            break\n    return metadata\n"], "filenames": ["src/ceph-volume/ceph_volume/tests/util/test_encryption.py", "src/ceph-volume/ceph_volume/util/encryption.py"], "buggy_code_start_loc": [1, 12], "buggy_code_end_loc": [54, 85], "fixing_code_start_loc": [2, 12], "fixing_code_end_loc": [69, 98], "type": "CWE-327", "message": "A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.", "other": {"cve": {"id": "CVE-2021-3979", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-25T20:15:09.473", "lastModified": "2023-02-12T23:42:59.537", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks."}, {"lang": "es", "value": "Se ha encontrado un fallo de longitud de clave en Red Hat Ceph Storage. Un atacante puede explotar el hecho de que la longitud de la clave se pasa incorrectamente en un algoritmo de cifrado para crear una clave no aleatoria, que es m\u00e1s d\u00e9bil y puede ser explotada para la p\u00e9rdida de confidencialidad e integridad en los discos cifrados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-327"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-327"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "516F4E8E-ED2F-4282-9DAB-D8B378F61258"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:4.3:*:*:*:*:*:*:*", "matchCriteriaId": "634F0044-B81C-4EE4-A27A-24B5DF857D35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:5.1:*:*:*:*:*:*:*", "matchCriteriaId": "7EA89296-A701-46DA-BE5D-1FAAC2789D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_storage:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6FB187A4-F3A6-4993-AEF2-7808F1485EE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_data_foundation:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "0E2C021C-A9F0-4EB4-ADED-81D8B57B4563"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack_platform:13.0:*:*:*:*:*:*:*", "matchCriteriaId": "C52600BF-9E87-4CD2-91F3-685AFE478C1E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:ceph_storage_for_ibm_z_systems:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "9F26352C-A305-4A68-B9D8-367B440F6F62"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6E54096-5D45-4CB2-AC9A-DDB55BF2B94C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "4E37E1B3-6F68-4502-85D6-68333643BDFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage_for_power:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "178E0094-2ACA-4BDF-A83C-965CF856D41D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6E54096-5D45-4CB2-AC9A-DDB55BF2B94C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "4E37E1B3-6F68-4502-85D6-68333643BDFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage_for_power:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "178E0094-2ACA-4BDF-A83C-965CF856D41D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3979", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2024788", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/ceph/ceph/commit/47c33179f9a15ae95cc1579a421be89378602656", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ceph/ceph/pull/44765", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BPOK44BESMIFW6BIOGCN452AKKOIIT6Q/", "source": "secalert@redhat.com"}, {"url": "https://tracker.ceph.com/issues/54006", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ceph/ceph/commit/47c33179f9a15ae95cc1579a421be89378602656"}}