{"buggy_code": ["class EmailConfirmationsController < ApplicationController\n  before_action :redirect_to_signin, unless: :signed_in?, only: :unconfirmed\n  before_action :redirect_to_new_mfa, if: :mfa_required_not_yet_enabled?, only: :unconfirmed\n  before_action :redirect_to_settings_strong_mfa_required, if: :mfa_required_weak_level_enabled?, only: :unconfirmed\n  before_action :validate_confirmation_token, only: %i[update mfa_update]\n\n  def update\n    if @user.mfa_enabled?\n      @form_url = mfa_update_email_confirmations_url(token: @user.confirmation_token)\n      render template: \"multifactor_auths/otp_prompt\"\n    else\n      confirm_email\n    end\n  end\n\n  def mfa_update\n    if @user.mfa_enabled? && @user.otp_verified?(params[:otp])\n      confirm_email\n    else\n      @form_url       = mfa_update_email_confirmations_url(token: @user.confirmation_token)\n      flash.now.alert = t(\"multifactor_auths.incorrect_otp\")\n      render template: \"multifactor_auths/otp_prompt\", status: :unauthorized\n    end\n  end\n\n  def new\n  end\n\n  # used to resend confirmation mail for email validation\n  def create\n    user = find_user_for_create\n\n    if user\n      user.generate_confirmation_token\n      Delayed::Job.enqueue(EmailConfirmationMailer.new(user.id)) if user.save\n    end\n    redirect_to root_path, notice: t(\".promise_resend\")\n  end\n\n  # used to resend confirmation mail for unconfirmed_email validation\n  def unconfirmed\n    if current_user.generate_confirmation_token && current_user.save\n      Delayed::Job.enqueue EmailResetMailer.new(current_user.id)\n      flash[:notice] = t(\"profiles.update.confirmation_mail_sent\")\n    else\n      flash[:notice] = t(\"try_again\")\n    end\n    redirect_to edit_profile_path\n  end\n\n  private\n\n  def find_user_for_create\n    Clearance.configuration.user_model.find_by_normalized_email email_params\n  end\n\n  def validate_confirmation_token\n    @user = User.find_by(confirmation_token: token_params)\n    redirect_to root_path, alert: t(\"failure_when_forbidden\") unless @user&.valid_confirmation_token?\n  end\n\n  def confirm_email\n    if @user.confirm_email!\n      sign_in @user\n      redirect_to root_path, notice: t(\"email_confirmations.update.confirmed_email\")\n    else\n      redirect_to root_path, alert: @user.errors.full_messages.to_sentence\n    end\n  end\n\n  def email_params\n    params.permit(email_confirmation: :email).require(:email_confirmation).require(:email)\n  end\n\n  def token_params\n    params.permit(:token).require(:token)\n  end\nend\n", "class User < ApplicationRecord\n  include UserMultifactorMethods\n  include Clearance::User\n  include Gravtastic\n  is_gravtastic default: \"retro\"\n\n  PERMITTED_ATTRS = %i[\n    bio\n    email\n    handle\n    hide_email\n    location\n    password\n    website\n    twitter_username\n  ].freeze\n\n  before_save :generate_confirmation_token, if: :will_save_change_to_unconfirmed_email?\n  before_create :generate_confirmation_token\n  before_destroy :yank_gems\n\n  has_many :ownerships, -> { confirmed }, dependent: :destroy, inverse_of: :user\n\n  has_many :rubygems, through: :ownerships, source: :rubygem\n  has_many :subscriptions, dependent: :destroy\n  has_many :subscribed_gems, -> { order(\"name ASC\") }, through: :subscriptions, source: :rubygem\n\n  has_many :deletions, dependent: :nullify\n  has_many :web_hooks, dependent: :destroy\n\n  # used for deleting unconfirmed ownerships as well on user destroy\n  has_many :unconfirmed_ownerships, -> { unconfirmed }, dependent: :destroy, inverse_of: :user, class_name: \"Ownership\"\n  has_many :api_keys, dependent: :destroy\n\n  has_many :ownership_calls, -> { opened }, dependent: :destroy, inverse_of: :user\n  has_many :ownership_requests, -> { opened }, dependent: :destroy, inverse_of: :user\n\n  validates :email, length: { maximum: Gemcutter::MAX_FIELD_LENGTH }, format: { with: URI::MailTo::EMAIL_REGEXP }, presence: true\n  validates :unconfirmed_email, length: { maximum: Gemcutter::MAX_FIELD_LENGTH }, format: { with: URI::MailTo::EMAIL_REGEXP }, allow_blank: true\n\n  validates :handle, uniqueness: { case_sensitive: false }, allow_nil: true, if: :handle_changed?\n  validates :handle, format: {\n    with: /\\A[A-Za-z][A-Za-z_\\-0-9]*\\z/,\n    message: \"must start with a letter and can only contain letters, numbers, underscores, and dashes\"\n  }, allow_nil: true\n  validates :handle, length: { within: 2..40 }, allow_nil: true\n\n  validates :twitter_username, format: {\n    with: /\\A[a-zA-Z0-9_]*\\z/,\n    message: \"can only contain letters, numbers, and underscores\"\n  }, allow_nil: true\n\n  validates :twitter_username, length: { within: 0..20 }, allow_nil: true\n  validates :password,\n    length: { within: 10..200 },\n    unpwn: true,\n    allow_nil: true,\n    unless: :skip_password_validation?\n  validate :unconfirmed_email_uniqueness\n  validate :toxic_email_domain, on: :create\n\n  def self.authenticate(who, password)\n    user = find_by(email: who.downcase) || find_by(handle: who)\n    user if user&.authenticated?(password)\n  rescue BCrypt::Errors::InvalidHash\n    nil\n  end\n\n  def self.find_by_slug!(slug)\n    raise ActiveRecord::RecordNotFound if slug.blank?\n    find_by(id: slug) || find_by!(handle: slug)\n  end\n\n  def self.find_by_slug(slug)\n    return if slug.blank?\n    find_by(id: slug) || find_by(handle: slug)\n  end\n\n  def self.find_by_name(name)\n    return if name.blank?\n    find_by(email: name) || find_by(handle: name)\n  end\n\n  def self.find_by_blocked(slug)\n    return if slug.blank?\n    find_by(blocked_email: slug) || find_by(handle: slug)\n  end\n\n  def self.push_notifiable_owners\n    where(ownerships: { push_notifier: true })\n  end\n\n  def self.ownership_notifiable_owners\n    where(ownerships: { owner_notifier: true })\n  end\n\n  def self.ownership_request_notifiable_owners\n    where(ownerships: { ownership_request_notifier: true })\n  end\n\n  def name\n    handle || email\n  end\n\n  def display_handle\n    handle || \"##{id}\"\n  end\n\n  def display_id\n    handle || id\n  end\n\n  def reset_api_key!\n    generate_api_key && save!\n  end\n\n  def all_hooks\n    all     = web_hooks.specific.group_by { |hook| hook.rubygem.name }\n    globals = web_hooks.global.to_a\n    all[\"all gems\"] = globals if globals.present?\n    all\n  end\n\n  def payload\n    attrs = { \"id\" => id, \"handle\" => handle }\n    attrs[\"email\"] = email unless hide_email\n    attrs\n  end\n\n  def as_json(*)\n    payload\n  end\n\n  def to_xml(options = {})\n    payload.to_xml(options.merge(root: \"user\"))\n  end\n\n  def to_yaml(*args)\n    payload.to_yaml(*args)\n  end\n\n  def encode_with(coder)\n    coder.tag = nil\n    coder.implicit = true\n    coder.map = payload\n  end\n\n  def generate_api_key\n    self.api_key = SecureRandom.hex(16)\n  end\n\n  def total_downloads_count\n    rubygems.to_a.sum(&:downloads)\n  end\n\n  def rubygems_downloaded\n    rubygems.with_versions.sort_by { |rubygem| -rubygem.downloads }\n  end\n\n  def total_rubygems_count\n    rubygems.with_versions.count\n  end\n\n  def confirm_email!\n    return false if unconfirmed_email && !update_email\n    update!(email_confirmed: true, confirmation_token: nil)\n  end\n\n  # confirmation token expires after 15 minutes\n  def valid_confirmation_token?\n    token_expires_at > Time.zone.now\n  end\n\n  def generate_confirmation_token\n    self.confirmation_token = Clearance::Token.new\n    self.token_expires_at = Time.zone.now + Gemcutter::EMAIL_TOKEN_EXPRIES_AFTER\n  end\n\n  def unconfirmed?\n    !email_confirmed\n  end\n\n  def only_owner_gems\n    rubygems.with_versions.where('rubygems.id IN (\n      SELECT rubygem_id FROM ownerships GROUP BY rubygem_id HAVING count(rubygem_id) = 1)')\n  end\n\n  def remember_me!\n    self.remember_token = Clearance::Token.new\n    self.remember_token_expires_at = Gemcutter::REMEMBER_FOR.from_now\n    save!(validate: false)\n    remember_token\n  end\n\n  def remember_me?\n    remember_token_expires_at && remember_token_expires_at > Time.zone.now\n  end\n\n  def block!\n    original_email = email\n    transaction do\n      update_attribute(:email, \"security+locked-#{SecureRandom.hex(4)}-#{display_handle.downcase}@rubygems.org\")\n      confirm_email!\n      disable_mfa!\n      update_attribute(:password, SecureRandom.alphanumeric)\n      update!(\n        remember_token: nil,\n        remember_token_expires_at: nil,\n        api_key: nil,\n        blocked_email: original_email\n      )\n      api_keys.delete_all\n    end\n  end\n\n  def can_request_ownership?(rubygem)\n    !rubygem.owned_by?(self) && rubygem.ownership_requestable?\n  end\n\n  private\n\n  def update_email\n    self.attributes = { email: unconfirmed_email, unconfirmed_email: nil, mail_fails: 0 }\n    save\n  end\n\n  def unconfirmed_email_uniqueness\n    errors.add(:email, I18n.t(\"errors.messages.taken\")) if unconfirmed_email_exists?\n  end\n\n  def unconfirmed_email_exists?\n    User.exists?(email: unconfirmed_email)\n  end\n\n  def yank_gems\n    versions_to_yank = only_owner_gems.map(&:versions).flatten\n    versions_to_yank.each do |v|\n      deletions.create(version: v)\n    end\n  end\n\n  def toxic_email_domain\n    return unless (domain = email.split(\"@\").last)\n    toxic_domains_path = Pathname.new(Gemcutter::Application.config.toxic_domains_filepath)\n    toxic = toxic_domains_path.exist? && toxic_domains_path.readlines.grep(/^#{Regexp.escape(domain)}$/).any?\n\n    errors.add(:email, I18n.t(\"activerecord.errors.messages.blocked\", domain: domain)) if toxic\n  end\nend\n", "require \"test_helper\"\n\nclass PasswordResetTest < SystemTest\n  include ActiveJob::TestHelper\n\n  def password_reset_link\n    body = ActionMailer::Base.deliveries.last.parts[1].body.decoded.to_s\n    link = %r{http://localhost/users([^\";]*)}.match(body)\n    link[0]\n  end\n\n  setup do\n    @user = create(:user, handle: nil)\n  end\n\n  def forgot_password_with(email)\n    visit sign_in_path\n\n    click_link \"Forgot password?\"\n    fill_in \"Email address\", with: email\n    perform_enqueued_jobs { click_button \"Reset password\" }\n  end\n\n  test \"reset password form does not tell if a user exists\" do\n    forgot_password_with \"someone@example.com\"\n\n    assert page.has_content? \"instructions for changing your password\"\n  end\n\n  test \"resetting password without handle\" do\n    forgot_password_with @user.email\n\n    visit password_reset_link\n    expected_path = \"/users/#{@user.id}/password/edit\"\n    assert_equal expected_path, page.current_path, \"removes confirmation token from url\"\n\n    fill_in \"Password\", with: PasswordHelpers::SECURE_TEST_PASSWORD\n    click_button \"Save this password\"\n    assert_equal dashboard_path, page.current_path\n\n    click_link \"Sign out\"\n\n    visit sign_in_path\n    fill_in \"Email or Username\", with: @user.email\n    fill_in \"Password\", with: PasswordHelpers::SECURE_TEST_PASSWORD\n    click_button \"Sign in\"\n\n    assert page.has_content? \"Sign out\"\n  end\n\n  test \"resetting a password with a blank password\" do\n    forgot_password_with @user.email\n\n    visit password_reset_link\n\n    fill_in \"Password\", with: \"\"\n    click_button \"Save this password\"\n\n    assert page.has_content? \"Password can't be blank.\"\n    assert page.has_content? \"Sign in\"\n  end\n\n  test \"resetting a password when signed in\" do\n    visit sign_in_path\n\n    fill_in \"Email or Username\", with: @user.email\n    fill_in \"Password\", with: @user.password\n    click_button \"Sign in\"\n\n    visit edit_settings_path\n\n    click_link \"Reset password\"\n\n    fill_in \"Email address\", with: @user.email\n    perform_enqueued_jobs { click_button \"Reset password\" }\n\n    visit password_reset_link\n\n    fill_in \"Password\", with: PasswordHelpers::SECURE_TEST_PASSWORD\n    click_button \"Save this password\"\n\n    assert @user.reload.authenticated? PasswordHelpers::SECURE_TEST_PASSWORD\n  end\n\n  test \"restting password when mfa is enabled\" do\n    @user.enable_mfa!(ROTP::Base32.random_base32, :ui_only)\n    forgot_password_with @user.email\n\n    visit password_reset_link\n\n    fill_in \"otp\", with: ROTP::TOTP.new(@user.mfa_seed).now\n    click_button \"Authenticate\"\n\n    fill_in \"Password\", with: PasswordHelpers::SECURE_TEST_PASSWORD\n    click_button \"Save this password\"\n\n    assert page.has_content?(\"Sign out\")\n  end\nend\n"], "fixing_code": ["class EmailConfirmationsController < ApplicationController\n  before_action :redirect_to_signin, unless: :signed_in?, only: :unconfirmed\n  before_action :redirect_to_new_mfa, if: :mfa_required_not_yet_enabled?, only: :unconfirmed\n  before_action :redirect_to_settings_strong_mfa_required, if: :mfa_required_weak_level_enabled?, only: :unconfirmed\n  before_action :validate_confirmation_token, only: %i[update mfa_update]\n\n  def update\n    if @user.mfa_enabled?\n      @form_url = mfa_update_email_confirmations_url(token: @user.confirmation_token)\n      render template: \"multifactor_auths/otp_prompt\"\n    else\n      confirm_email\n    end\n  end\n\n  def mfa_update\n    if @user.mfa_enabled? && @user.otp_verified?(params[:otp])\n      confirm_email\n    else\n      @form_url       = mfa_update_email_confirmations_url(token: @user.confirmation_token)\n      flash.now.alert = t(\"multifactor_auths.incorrect_otp\")\n      render template: \"multifactor_auths/otp_prompt\", status: :unauthorized\n    end\n  end\n\n  def new\n  end\n\n  # used to resend confirmation mail for email validation\n  def create\n    user = find_user_for_create\n\n    if user\n      user.generate_confirmation_token(reset_unconfirmed_email: false)\n      Delayed::Job.enqueue(EmailConfirmationMailer.new(user.id)) if user.save\n    end\n    redirect_to root_path, notice: t(\".promise_resend\")\n  end\n\n  # used to resend confirmation mail for unconfirmed_email validation\n  def unconfirmed\n    if current_user.generate_confirmation_token(reset_unconfirmed_email: false) && current_user.save\n      Delayed::Job.enqueue EmailResetMailer.new(current_user.id)\n      flash[:notice] = t(\"profiles.update.confirmation_mail_sent\")\n    else\n      flash[:notice] = t(\"try_again\")\n    end\n    redirect_to edit_profile_path\n  end\n\n  private\n\n  def find_user_for_create\n    Clearance.configuration.user_model.find_by_normalized_email email_params\n  end\n\n  def validate_confirmation_token\n    @user = User.find_by(confirmation_token: token_params)\n    redirect_to root_path, alert: t(\"failure_when_forbidden\") unless @user&.valid_confirmation_token?\n  end\n\n  def confirm_email\n    if @user.confirm_email!\n      sign_in @user\n      redirect_to root_path, notice: t(\"email_confirmations.update.confirmed_email\")\n    else\n      redirect_to root_path, alert: @user.errors.full_messages.to_sentence\n    end\n  end\n\n  def email_params\n    params.permit(email_confirmation: :email).require(:email_confirmation).require(:email)\n  end\n\n  def token_params\n    params.permit(:token).require(:token)\n  end\nend\n", "class User < ApplicationRecord\n  include UserMultifactorMethods\n  include Clearance::User\n  include Gravtastic\n  is_gravtastic default: \"retro\"\n\n  PERMITTED_ATTRS = %i[\n    bio\n    email\n    handle\n    hide_email\n    location\n    password\n    website\n    twitter_username\n  ].freeze\n\n  before_save :_generate_confirmation_token_no_reset_unconfirmed_email, if: :will_save_change_to_unconfirmed_email?\n  before_create :_generate_confirmation_token_no_reset_unconfirmed_email\n  before_destroy :yank_gems\n\n  has_many :ownerships, -> { confirmed }, dependent: :destroy, inverse_of: :user\n\n  has_many :rubygems, through: :ownerships, source: :rubygem\n  has_many :subscriptions, dependent: :destroy\n  has_many :subscribed_gems, -> { order(\"name ASC\") }, through: :subscriptions, source: :rubygem\n\n  has_many :deletions, dependent: :nullify\n  has_many :web_hooks, dependent: :destroy\n\n  # used for deleting unconfirmed ownerships as well on user destroy\n  has_many :unconfirmed_ownerships, -> { unconfirmed }, dependent: :destroy, inverse_of: :user, class_name: \"Ownership\"\n  has_many :api_keys, dependent: :destroy\n\n  has_many :ownership_calls, -> { opened }, dependent: :destroy, inverse_of: :user\n  has_many :ownership_requests, -> { opened }, dependent: :destroy, inverse_of: :user\n\n  validates :email, length: { maximum: Gemcutter::MAX_FIELD_LENGTH }, format: { with: URI::MailTo::EMAIL_REGEXP }, presence: true\n  validates :unconfirmed_email, length: { maximum: Gemcutter::MAX_FIELD_LENGTH }, format: { with: URI::MailTo::EMAIL_REGEXP }, allow_blank: true\n\n  validates :handle, uniqueness: { case_sensitive: false }, allow_nil: true, if: :handle_changed?\n  validates :handle, format: {\n    with: /\\A[A-Za-z][A-Za-z_\\-0-9]*\\z/,\n    message: \"must start with a letter and can only contain letters, numbers, underscores, and dashes\"\n  }, allow_nil: true\n  validates :handle, length: { within: 2..40 }, allow_nil: true\n\n  validates :twitter_username, format: {\n    with: /\\A[a-zA-Z0-9_]*\\z/,\n    message: \"can only contain letters, numbers, and underscores\"\n  }, allow_nil: true\n\n  validates :twitter_username, length: { within: 0..20 }, allow_nil: true\n  validates :password,\n    length: { within: 10..200 },\n    unpwn: true,\n    allow_nil: true,\n    unless: :skip_password_validation?\n  validate :unconfirmed_email_uniqueness\n  validate :toxic_email_domain, on: :create\n\n  def self.authenticate(who, password)\n    user = find_by(email: who.downcase) || find_by(handle: who)\n    user if user&.authenticated?(password)\n  rescue BCrypt::Errors::InvalidHash\n    nil\n  end\n\n  def self.find_by_slug!(slug)\n    raise ActiveRecord::RecordNotFound if slug.blank?\n    find_by(id: slug) || find_by!(handle: slug)\n  end\n\n  def self.find_by_slug(slug)\n    return if slug.blank?\n    find_by(id: slug) || find_by(handle: slug)\n  end\n\n  def self.find_by_name(name)\n    return if name.blank?\n    find_by(email: name) || find_by(handle: name)\n  end\n\n  def self.find_by_blocked(slug)\n    return if slug.blank?\n    find_by(blocked_email: slug) || find_by(handle: slug)\n  end\n\n  def self.push_notifiable_owners\n    where(ownerships: { push_notifier: true })\n  end\n\n  def self.ownership_notifiable_owners\n    where(ownerships: { owner_notifier: true })\n  end\n\n  def self.ownership_request_notifiable_owners\n    where(ownerships: { ownership_request_notifier: true })\n  end\n\n  def name\n    handle || email\n  end\n\n  def display_handle\n    handle || \"##{id}\"\n  end\n\n  def display_id\n    handle || id\n  end\n\n  def reset_api_key!\n    generate_api_key && save!\n  end\n\n  def all_hooks\n    all     = web_hooks.specific.group_by { |hook| hook.rubygem.name }\n    globals = web_hooks.global.to_a\n    all[\"all gems\"] = globals if globals.present?\n    all\n  end\n\n  def payload\n    attrs = { \"id\" => id, \"handle\" => handle }\n    attrs[\"email\"] = email unless hide_email\n    attrs\n  end\n\n  def as_json(*)\n    payload\n  end\n\n  def to_xml(options = {})\n    payload.to_xml(options.merge(root: \"user\"))\n  end\n\n  def to_yaml(*args)\n    payload.to_yaml(*args)\n  end\n\n  def encode_with(coder)\n    coder.tag = nil\n    coder.implicit = true\n    coder.map = payload\n  end\n\n  def generate_api_key\n    self.api_key = SecureRandom.hex(16)\n  end\n\n  def total_downloads_count\n    rubygems.to_a.sum(&:downloads)\n  end\n\n  def rubygems_downloaded\n    rubygems.with_versions.sort_by { |rubygem| -rubygem.downloads }\n  end\n\n  def total_rubygems_count\n    rubygems.with_versions.count\n  end\n\n  def confirm_email!\n    return false if unconfirmed_email && !update_email\n    update!(email_confirmed: true, confirmation_token: nil)\n  end\n\n  # confirmation token expires after 15 minutes\n  def valid_confirmation_token?\n    token_expires_at > Time.zone.now\n  end\n\n  def generate_confirmation_token(reset_unconfirmed_email: true)\n    self.unconfirmed_email = nil if reset_unconfirmed_email\n    self.confirmation_token = Clearance::Token.new\n    self.token_expires_at = Time.zone.now + Gemcutter::EMAIL_TOKEN_EXPRIES_AFTER\n  end\n\n  def _generate_confirmation_token_no_reset_unconfirmed_email\n    generate_confirmation_token(reset_unconfirmed_email: false)\n  end\n\n  def unconfirmed?\n    !email_confirmed\n  end\n\n  def only_owner_gems\n    rubygems.with_versions.where('rubygems.id IN (\n      SELECT rubygem_id FROM ownerships GROUP BY rubygem_id HAVING count(rubygem_id) = 1)')\n  end\n\n  def remember_me!\n    self.remember_token = Clearance::Token.new\n    self.remember_token_expires_at = Gemcutter::REMEMBER_FOR.from_now\n    save!(validate: false)\n    remember_token\n  end\n\n  def remember_me?\n    remember_token_expires_at && remember_token_expires_at > Time.zone.now\n  end\n\n  def block!\n    original_email = email\n    transaction do\n      update_attribute(:email, \"security+locked-#{SecureRandom.hex(4)}-#{display_handle.downcase}@rubygems.org\")\n      confirm_email!\n      disable_mfa!\n      update_attribute(:password, SecureRandom.alphanumeric)\n      update!(\n        remember_token: nil,\n        remember_token_expires_at: nil,\n        api_key: nil,\n        blocked_email: original_email\n      )\n      api_keys.delete_all\n    end\n  end\n\n  def can_request_ownership?(rubygem)\n    !rubygem.owned_by?(self) && rubygem.ownership_requestable?\n  end\n\n  private\n\n  def update_email\n    self.attributes = { email: unconfirmed_email, unconfirmed_email: nil, mail_fails: 0 }\n    save\n  end\n\n  def unconfirmed_email_uniqueness\n    errors.add(:email, I18n.t(\"errors.messages.taken\")) if unconfirmed_email_exists?\n  end\n\n  def unconfirmed_email_exists?\n    User.exists?(email: unconfirmed_email)\n  end\n\n  def yank_gems\n    versions_to_yank = only_owner_gems.map(&:versions).flatten\n    versions_to_yank.each do |v|\n      deletions.create(version: v)\n    end\n  end\n\n  def toxic_email_domain\n    return unless (domain = email.split(\"@\").last)\n    toxic_domains_path = Pathname.new(Gemcutter::Application.config.toxic_domains_filepath)\n    toxic = toxic_domains_path.exist? && toxic_domains_path.readlines.grep(/^#{Regexp.escape(domain)}$/).any?\n\n    errors.add(:email, I18n.t(\"activerecord.errors.messages.blocked\", domain: domain)) if toxic\n  end\nend\n", "require \"test_helper\"\n\nclass PasswordResetTest < SystemTest\n  include ActiveJob::TestHelper\n\n  def password_reset_link\n    body = ActionMailer::Base.deliveries.last.parts[1].body.decoded.to_s\n    link = %r{http://localhost/users([^\";]*)}.match(body)\n    link[0]\n  end\n\n  setup do\n    @user = create(:user, handle: nil)\n  end\n\n  def forgot_password_with(email)\n    visit sign_in_path\n\n    click_link \"Forgot password?\"\n    fill_in \"Email address\", with: email\n    perform_enqueued_jobs { click_button \"Reset password\" }\n  end\n\n  test \"reset password form does not tell if a user exists\" do\n    forgot_password_with \"someone@example.com\"\n\n    assert page.has_content? \"instructions for changing your password\"\n  end\n\n  test \"resetting password without handle\" do\n    forgot_password_with @user.email\n\n    visit password_reset_link\n    expected_path = \"/users/#{@user.id}/password/edit\"\n    assert_equal expected_path, page.current_path, \"removes confirmation token from url\"\n\n    fill_in \"Password\", with: PasswordHelpers::SECURE_TEST_PASSWORD\n    click_button \"Save this password\"\n    assert_equal dashboard_path, page.current_path\n\n    click_link \"Sign out\"\n\n    visit sign_in_path\n    fill_in \"Email or Username\", with: @user.email\n    fill_in \"Password\", with: PasswordHelpers::SECURE_TEST_PASSWORD\n    click_button \"Sign in\"\n\n    assert page.has_content? \"Sign out\"\n  end\n\n  test \"resetting a password with a blank password\" do\n    forgot_password_with @user.email\n\n    visit password_reset_link\n\n    fill_in \"Password\", with: \"\"\n    click_button \"Save this password\"\n\n    assert page.has_content? \"Password can't be blank.\"\n    assert page.has_content? \"Sign in\"\n  end\n\n  test \"resetting a password when signed in\" do\n    visit sign_in_path\n\n    fill_in \"Email or Username\", with: @user.email\n    fill_in \"Password\", with: @user.password\n    click_button \"Sign in\"\n\n    visit edit_settings_path\n\n    click_link \"Reset password\"\n\n    fill_in \"Email address\", with: @user.email\n    perform_enqueued_jobs { click_button \"Reset password\" }\n\n    visit password_reset_link\n\n    fill_in \"Password\", with: PasswordHelpers::SECURE_TEST_PASSWORD\n    click_button \"Save this password\"\n\n    assert @user.reload.authenticated? PasswordHelpers::SECURE_TEST_PASSWORD\n  end\n\n  test \"restting password when mfa is enabled\" do\n    @user.enable_mfa!(ROTP::Base32.random_base32, :ui_only)\n    forgot_password_with @user.email\n\n    visit password_reset_link\n\n    fill_in \"otp\", with: ROTP::TOTP.new(@user.mfa_seed).now\n    click_button \"Authenticate\"\n\n    fill_in \"Password\", with: PasswordHelpers::SECURE_TEST_PASSWORD\n    click_button \"Save this password\"\n\n    assert page.has_content?(\"Sign out\")\n  end\n\n  test \"resetting password with pending email change\" do\n    visit sign_in_path\n\n    email = @user.email\n    new_email = \"hijack@example.com\"\n\n    fill_in \"Email or Username\", with: email\n    fill_in \"Password\", with: @user.password\n    click_button \"Sign in\"\n\n    visit edit_profile_path\n\n    fill_in \"Username\", with: \"username\"\n    fill_in \"Email address\", with: new_email\n    fill_in \"Password\", with: @user.password\n    perform_enqueued_jobs { click_button \"Update\" }\n\n    assert_equal new_email, @user.reload.unconfirmed_email\n\n    click_link \"Sign out\"\n\n    forgot_password_with email\n\n    assert_nil @user.reload.unconfirmed_email\n\n    token = /edit\\?token=(.+)$/.match(password_reset_link)[1]\n    visit update_email_confirmations_path(token: token)\n\n    assert @user.reload.authenticated? PasswordHelpers::SECURE_TEST_PASSWORD\n    assert_equal email, @user.email\n  end\nend\n"], "filenames": ["app/controllers/email_confirmations_controller.rb", "app/models/user.rb", "test/integration/password_reset_test.rb"], "buggy_code_start_loc": [34, 18, 98], "buggy_code_end_loc": [43, 176, 98], "fixing_code_start_loc": [34, 18, 99], "fixing_code_end_loc": [43, 182, 131], "type": "CWE-287", "message": "RubyGems.org is the Ruby community gem host. A bug in password & email change confirmation code allowed an attacker to change their RubyGems.org account's email to an unowned email address. Having access to an account whose email has been changed could enable an attacker to save API keys for that account, and when a legitimate user attempts to create an account with their email (and has to reset password to gain access) and is granted access to other gems, the attacker would then be able to publish and yank versions of those gems. Commit number 90c9e6aac2d91518b479c51d48275c57de492d4d contains a patch for this issue.", "other": {"cve": {"id": "CVE-2022-36073", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-07T20:15:11.223", "lastModified": "2022-09-12T18:34:13.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RubyGems.org is the Ruby community gem host. A bug in password & email change confirmation code allowed an attacker to change their RubyGems.org account's email to an unowned email address. Having access to an account whose email has been changed could enable an attacker to save API keys for that account, and when a legitimate user attempts to create an account with their email (and has to reset password to gain access) and is granted access to other gems, the attacker would then be able to publish and yank versions of those gems. Commit number 90c9e6aac2d91518b479c51d48275c57de492d4d contains a patch for this issue."}, {"lang": "es", "value": "RubyGems.org es el host de gemas de la comunidad Ruby. Un error en el c\u00f3digo de confirmaci\u00f3n de cambio de contrase\u00f1a y correo electr\u00f3nico permit\u00eda a un atacante cambiar el correo electr\u00f3nico de su cuenta de RubyGems.org a una direcci\u00f3n de correo electr\u00f3nico no propia. Tener acceso a una cuenta cuyo correo electr\u00f3nico ha sido cambiado podr\u00eda permitir a un atacante guardar las claves de la API para esa cuenta, y cuando un usuario leg\u00edtimo intente crear una cuenta con su correo electr\u00f3nico (y tenga que restablecer la contrase\u00f1a para acceder) y le sea concedido acceso a otras gemas, el atacante podr\u00eda entonces publicar y arrancar versiones de esas gemas. El commit n\u00famero 90c9e6aac2d91518b479c51d48275c57de492d4d contiene un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-08-31", "matchCriteriaId": "336CC931-B42D-442B-AC29-7A89975F8176"}]}]}], "references": [{"url": "https://github.com/rubygems/rubygems.org/commit/90c9e6aac2d91518b479c51d48275c57de492d4d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rubygems/rubygems.org/security/advisories/GHSA-8qpf-wf2p-25vg", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rubygems/rubygems.org/commit/90c9e6aac2d91518b479c51d48275c57de492d4d"}}