{"buggy_code": ["# CHANGELOG\n\n## 6.0.0\n\n**Breaking Changes**\n\n- Decode HTML characters automatically that would result in an XSS vulnerability when rendering links via a server rendered HTML file\n\n```js\n// decodes to javacript:alert('XSS')\nconst vulnerableUrl =\n  \"&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041\";\n\nsanitizeUrl(vulnerableUrl); // 'about:blank'\n\nconst okUrl = \"https://example.com/\" + vulnerableUrl;\n\n// since the javascript bit is in the path instead of the protocol\n// this is successfully sanitized\nsanitizeUrl(okUrl); // 'https://example.com/javascript:alert('XSS');\n```\n\n## 5.0.2\n\n- Fix issue where certain invisible white space characters were not being sanitized (#35)\n\n## 5.0.1\n\n- Fix issue where certain safe characters were being filtered out (#31 thanks @akirchmyer)\n\n## 5.0.0\n\n_Breaking Changes_\n\n- Sanitize vbscript urls (thanks @vicnicius)\n\n## 4.1.1\n\n- Fixup path to type declaration (closes #25)\n\n## 4.1.0\n\n- Add typescript types\n\n## 4.0.1\n\n- Fix issue where urls with accented characters were incorrectly sanitized\n\n## 4.0.0\n\n_Breaking Changes_\n\n- Protocol-less urls (ie: www.example.com) will be sanitised and passed on instead of sending out `about:blank` (Thanks @chawes13 #18)\n\n## 3.1.0\n\n- Trim whitespace from urls\n\n## 3.0.0\n\n_breaking changes_\n\n- Replace blank strings with about:blank\n- Replace null values with about:blank\n\n## 2.1.0\n\n- Allow relative urls to be sanitized\n\n## 2.0.2\n\n- Sanitize malicious URLs that begin with `\\s`\n\n## 2.0.1\n\n- Sanitize malicious URLs that begin with %20\n\n## 2.0.0\n\n- sanitize data: urls\n\n## 1.0.0\n\n- sanitize javascript: urls\n", "/* eslint-disable no-script-url */\nimport { sanitizeUrl } from \"..\";\n\ndescribe(\"sanitizeUrl\", () => {\n  it(\"does not alter http URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"http://example.com/path/to:something\")).toBe(\n      \"http://example.com/path/to:something\"\n    );\n  });\n\n  it(\"does not alter http URLs with ports with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"http://example.com:4567/path/to:something\")).toBe(\n      \"http://example.com:4567/path/to:something\"\n    );\n  });\n\n  it(\"does not alter https URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"https://example.com\")).toBe(\"https://example.com\");\n  });\n\n  it(\"does not alter https URLs with ports with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"https://example.com:4567/path/to:something\")).toBe(\n      \"https://example.com:4567/path/to:something\"\n    );\n  });\n\n  it(\"does not alter relative-path reference URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"./path/to/my.json\")).toBe(\"./path/to/my.json\");\n  });\n\n  it(\"does not alter absolute-path reference URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"/path/to/my.json\")).toBe(\"/path/to/my.json\");\n  });\n\n  it(\"does not alter protocol-less network-path URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"//google.com/robots.txt\")).toBe(\n      \"//google.com/robots.txt\"\n    );\n  });\n\n  it(\"does not alter protocol-less URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"www.example.com\")).toBe(\"www.example.com\");\n  });\n\n  it(\"does not alter deep-link urls with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"com.braintreepayments.demo://example\")).toBe(\n      \"com.braintreepayments.demo://example\"\n    );\n  });\n\n  it(\"does not alter mailto urls with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"mailto:test@example.com?subject=hello+world\")).toBe(\n      \"mailto:test@example.com?subject=hello+world\"\n    );\n  });\n\n  it(\"does not alter urls with accented characters\", () => {\n    expect(sanitizeUrl(\"www.example.com/with-\u00e1cc\u00eant\u0161\")).toBe(\n      \"www.example.com/with-\u00e1cc\u00eant\u0161\"\n    );\n  });\n\n  it(\"does not strip harmless unicode characters\", () => {\n    expect(sanitizeUrl(\"www.example.com/\u043b\u043e\u0442.\u0440\u0444\u0448\u0438\u0448\u043a\u0438\u00fc\u2013\")).toBe(\n      \"www.example.com/\u043b\u043e\u0442.\u0440\u0444\u0448\u0438\u0448\u043a\u0438\u00fc\u2013\"\n    );\n  });\n\n  it(\"strips out ctrl chars\", () => {\n    expect(\n      sanitizeUrl(\"www.example.com/\\u200D\\u0000\\u001F\\x00\\x1F\\uFEFFfoo\")\n    ).toBe(\"www.example.com/foo\");\n  });\n\n  it(\"replaces blank urls with about:blank\", () => {\n    expect(sanitizeUrl(\"\")).toBe(\"about:blank\");\n  });\n\n  it(\"replaces null values with about:blank\", () => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    expect(sanitizeUrl(null)).toBe(\"about:blank\");\n  });\n\n  it(\"replaces undefined values with about:blank\", () => {\n    expect(sanitizeUrl()).toBe(\"about:blank\");\n  });\n\n  it(\"removes whitespace from urls\", () => {\n    expect(sanitizeUrl(\"   http://example.com/path/to:something    \")).toBe(\n      \"http://example.com/path/to:something\"\n    );\n  });\n\n  it(\"decodes html entities\", () => {\n    // all these decode to javascript:alert('xss');\n    const attackVectors = [\n      \"&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041\",\n      \"&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;\",\n      \"&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29\",\n      \"jav&#x09;ascript:alert('XSS');\",\n      \" &#14; javascript:alert('XSS');\",\n    ];\n\n    attackVectors.forEach((vector) => {\n      expect(sanitizeUrl(vector)).toBe(\"about:blank\");\n    });\n\n    // https://example.com/javascript:alert('XSS')\n    // since the javascript is the url path, and not the protocol,\n    // this url is technically sanitized\n    expect(\n      sanitizeUrl(\n        \"&#104;&#116;&#116;&#112;&#115;&#0000058//&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;/&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041\"\n      )\n    ).toBe(\"https://example.com/javascript:alert('XSS')\");\n  });\n\n  describe(\"invalid protocols\", () => {\n    describe.each([\"javascript\", \"data\", \"vbscript\"])(\"%s\", (protocol) => {\n      it(`replaces ${protocol} urls with about:blank`, () => {\n        expect(sanitizeUrl(`${protocol}:alert(document.domain)`)).toBe(\n          \"about:blank\"\n        );\n      });\n\n      it(`allows ${protocol} urls that start with a letter prefix`, () => {\n        expect(sanitizeUrl(`not_${protocol}:alert(document.domain)`)).toBe(\n          `not_${protocol}:alert(document.domain)`\n        );\n      });\n\n      it(`disallows ${protocol} urls that start with non-\\w characters as a suffix for the protocol`, () => {\n        expect(sanitizeUrl(`&!*${protocol}:alert(document.domain)`)).toBe(\n          \"about:blank\"\n        );\n      });\n\n      it(`disregards capitalization for ${protocol} urls`, () => {\n        // upper case every other letter in protocol name\n        const mixedCapitalizationProtocol = protocol\n          .split(\"\")\n          .map((character, index) => {\n            if (index % 2 === 0) {\n              return character.toUpperCase();\n            }\n            return character;\n          })\n          .join(\"\");\n\n        expect(\n          sanitizeUrl(`${mixedCapitalizationProtocol}:alert(document.domain)`)\n        ).toBe(\"about:blank\");\n      });\n\n      it(`ignores invisible ctrl characters in ${protocol} urls`, () => {\n        const protocolWithControlCharacters = protocol\n          .split(\"\")\n          .map((character, index) => {\n            if (index === 1) {\n              return character + \"%EF%BB%BF%EF%BB%BF\";\n            } else if (index === 2) {\n              return character + \"%e2%80%8b\";\n            }\n            return character;\n          })\n          .join(\"\");\n\n        expect(\n          sanitizeUrl(\n            decodeURIComponent(\n              `${protocolWithControlCharacters}:alert(document.domain)`\n            )\n          )\n        ).toBe(\"about:blank\");\n      });\n\n      it(`replaces ${protocol} urls with about:blank when url begins with %20`, () => {\n        expect(\n          sanitizeUrl(\n            decodeURIComponent(`%20%20%20%20${protocol}:alert(document.domain)`)\n          )\n        ).toBe(\"about:blank\");\n      });\n\n      it(`replaces ${protocol} urls with about:blank when ${protocol} url begins with spaces`, () => {\n        expect(sanitizeUrl(`    ${protocol}:alert(document.domain)`)).toBe(\n          \"about:blank\"\n        );\n      });\n\n      it(`does not replace ${protocol}: if it is not in the scheme of the URL`, () => {\n        expect(sanitizeUrl(`http://example.com#${protocol}:foo`)).toBe(\n          `http://example.com#${protocol}:foo`\n        );\n      });\n    });\n  });\n});\n", "const invalidProtocolRegex = /^([^\\w]*)(javascript|data|vbscript)/im;\nconst htmlEntitiesRegex = /&#(\\w+)(^\\w|;)?/g;\nconst ctrlCharactersRegex =\n  /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nconst urlSchemeRegex = /^([^:]+):/gm;\nconst relativeFirstCharacters = [\".\", \"/\"];\n\nfunction isRelativeUrlWithoutProtocol(url: string): boolean {\n  return relativeFirstCharacters.indexOf(url[0]) > -1;\n}\n\n// adapted from https://stackoverflow.com/a/29824550/2601552\nfunction decodeHtmlCharacters(str: string) {\n  return str.replace(htmlEntitiesRegex, (match, dec) => {\n    return String.fromCharCode(dec);\n  });\n}\n\nexport function sanitizeUrl(url?: string): string {\n  const sanitizedUrl = decodeHtmlCharacters(url || \"\")\n    .replace(ctrlCharactersRegex, \"\")\n    .trim();\n\n  if (!sanitizedUrl) {\n    return \"about:blank\";\n  }\n\n  if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {\n    return sanitizedUrl;\n  }\n\n  const urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);\n\n  if (!urlSchemeParseResults) {\n    return sanitizedUrl;\n  }\n\n  const urlScheme = urlSchemeParseResults[0];\n\n  if (invalidProtocolRegex.test(urlScheme)) {\n    return \"about:blank\";\n  }\n\n  return sanitizedUrl;\n}\n"], "fixing_code": ["# CHANGELOG\n\n## unreleased\n\n- Fix issue where urls in the form `javascript&colon;alert('xss');` were not properly sanitized\n- Fix issue where urls in the form `javasc&Tab;ript:alert('XSS');` were not properly sanitized\n\n## 6.0.0\n\n**Breaking Changes**\n\n- Decode HTML characters automatically that would result in an XSS vulnerability when rendering links via a server rendered HTML file\n\n```js\n// decodes to javacript:alert('XSS')\nconst vulnerableUrl =\n  \"&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041\";\n\nsanitizeUrl(vulnerableUrl); // 'about:blank'\n\nconst okUrl = \"https://example.com/\" + vulnerableUrl;\n\n// since the javascript bit is in the path instead of the protocol\n// this is successfully sanitized\nsanitizeUrl(okUrl); // 'https://example.com/javascript:alert('XSS');\n```\n\n## 5.0.2\n\n- Fix issue where certain invisible white space characters were not being sanitized (#35)\n\n## 5.0.1\n\n- Fix issue where certain safe characters were being filtered out (#31 thanks @akirchmyer)\n\n## 5.0.0\n\n_Breaking Changes_\n\n- Sanitize vbscript urls (thanks @vicnicius)\n\n## 4.1.1\n\n- Fixup path to type declaration (closes #25)\n\n## 4.1.0\n\n- Add typescript types\n\n## 4.0.1\n\n- Fix issue where urls with accented characters were incorrectly sanitized\n\n## 4.0.0\n\n_Breaking Changes_\n\n- Protocol-less urls (ie: www.example.com) will be sanitised and passed on instead of sending out `about:blank` (Thanks @chawes13 #18)\n\n## 3.1.0\n\n- Trim whitespace from urls\n\n## 3.0.0\n\n_breaking changes_\n\n- Replace blank strings with about:blank\n- Replace null values with about:blank\n\n## 2.1.0\n\n- Allow relative urls to be sanitized\n\n## 2.0.2\n\n- Sanitize malicious URLs that begin with `\\s`\n\n## 2.0.1\n\n- Sanitize malicious URLs that begin with %20\n\n## 2.0.0\n\n- sanitize data: urls\n\n## 1.0.0\n\n- sanitize javascript: urls\n", "/* eslint-disable no-script-url */\nimport { sanitizeUrl } from \"..\";\n\ndescribe(\"sanitizeUrl\", () => {\n  it(\"does not alter http URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"http://example.com/path/to:something\")).toBe(\n      \"http://example.com/path/to:something\"\n    );\n  });\n\n  it(\"does not alter http URLs with ports with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"http://example.com:4567/path/to:something\")).toBe(\n      \"http://example.com:4567/path/to:something\"\n    );\n  });\n\n  it(\"does not alter https URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"https://example.com\")).toBe(\"https://example.com\");\n  });\n\n  it(\"does not alter https URLs with ports with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"https://example.com:4567/path/to:something\")).toBe(\n      \"https://example.com:4567/path/to:something\"\n    );\n  });\n\n  it(\"does not alter relative-path reference URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"./path/to/my.json\")).toBe(\"./path/to/my.json\");\n  });\n\n  it(\"does not alter absolute-path reference URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"/path/to/my.json\")).toBe(\"/path/to/my.json\");\n  });\n\n  it(\"does not alter protocol-less network-path URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"//google.com/robots.txt\")).toBe(\n      \"//google.com/robots.txt\"\n    );\n  });\n\n  it(\"does not alter protocol-less URLs with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"www.example.com\")).toBe(\"www.example.com\");\n  });\n\n  it(\"does not alter deep-link urls with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"com.braintreepayments.demo://example\")).toBe(\n      \"com.braintreepayments.demo://example\"\n    );\n  });\n\n  it(\"does not alter mailto urls with alphanumeric characters\", () => {\n    expect(sanitizeUrl(\"mailto:test@example.com?subject=hello+world\")).toBe(\n      \"mailto:test@example.com?subject=hello+world\"\n    );\n  });\n\n  it(\"does not alter urls with accented characters\", () => {\n    expect(sanitizeUrl(\"www.example.com/with-\u00e1cc\u00eant\u0161\")).toBe(\n      \"www.example.com/with-\u00e1cc\u00eant\u0161\"\n    );\n  });\n\n  it(\"does not strip harmless unicode characters\", () => {\n    expect(sanitizeUrl(\"www.example.com/\u043b\u043e\u0442.\u0440\u0444\u0448\u0438\u0448\u043a\u0438\u00fc\u2013\")).toBe(\n      \"www.example.com/\u043b\u043e\u0442.\u0440\u0444\u0448\u0438\u0448\u043a\u0438\u00fc\u2013\"\n    );\n  });\n\n  it(\"strips out ctrl chars\", () => {\n    expect(\n      sanitizeUrl(\"www.example.com/\\u200D\\u0000\\u001F\\x00\\x1F\\uFEFFfoo\")\n    ).toBe(\"www.example.com/foo\");\n  });\n\n  it(\"replaces blank urls with about:blank\", () => {\n    expect(sanitizeUrl(\"\")).toBe(\"about:blank\");\n  });\n\n  it(\"replaces null values with about:blank\", () => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    expect(sanitizeUrl(null)).toBe(\"about:blank\");\n  });\n\n  it(\"replaces undefined values with about:blank\", () => {\n    expect(sanitizeUrl()).toBe(\"about:blank\");\n  });\n\n  it(\"removes whitespace from urls\", () => {\n    expect(sanitizeUrl(\"   http://example.com/path/to:something    \")).toBe(\n      \"http://example.com/path/to:something\"\n    );\n  });\n\n  it(\"decodes html entities\", () => {\n    // all these decode to javascript:alert('xss');\n    const attackVectors = [\n      \"&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041\",\n      \"&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;\",\n      \"&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29\",\n      \"jav&#x09;ascript:alert('XSS');\",\n      \" &#14; javascript:alert('XSS');\",\n      \"javasc&Tab;ript: alert('XSS');\",\n    ];\n\n    attackVectors.forEach((vector) => {\n      expect(sanitizeUrl(vector)).toBe(\"about:blank\");\n    });\n\n    // https://example.com/javascript:alert('XSS')\n    // since the javascript is the url path, and not the protocol,\n    // this url is technically sanitized\n    expect(\n      sanitizeUrl(\n        \"&#104;&#116;&#116;&#112;&#115;&#0000058//&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;/&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041\"\n      )\n    ).toBe(\"https://example.com/javascript:alert('XSS')\");\n  });\n\n  describe(\"invalid protocols\", () => {\n    describe.each([\"javascript\", \"data\", \"vbscript\"])(\"%s\", (protocol) => {\n      it(`replaces ${protocol} urls with about:blank`, () => {\n        expect(sanitizeUrl(`${protocol}:alert(document.domain)`)).toBe(\n          \"about:blank\"\n        );\n      });\n\n      it(`allows ${protocol} urls that start with a letter prefix`, () => {\n        expect(sanitizeUrl(`not_${protocol}:alert(document.domain)`)).toBe(\n          `not_${protocol}:alert(document.domain)`\n        );\n      });\n\n      it(`disallows ${protocol} urls that start with non-\\w characters as a suffix for the protocol`, () => {\n        expect(sanitizeUrl(`&!*${protocol}:alert(document.domain)`)).toBe(\n          \"about:blank\"\n        );\n      });\n\n      it(`disallows ${protocol} urls that use &colon; for the colon portion of the url`, () => {\n        expect(sanitizeUrl(`${protocol}&colon;alert(document.domain)`)).toBe(\n          \"about:blank\"\n        );\n        expect(sanitizeUrl(`${protocol}&COLON;alert(document.domain)`)).toBe(\n          \"about:blank\"\n        );\n      });\n\n      it(`disregards capitalization for ${protocol} urls`, () => {\n        // upper case every other letter in protocol name\n        const mixedCapitalizationProtocol = protocol\n          .split(\"\")\n          .map((character, index) => {\n            if (index % 2 === 0) {\n              return character.toUpperCase();\n            }\n            return character;\n          })\n          .join(\"\");\n\n        expect(\n          sanitizeUrl(`${mixedCapitalizationProtocol}:alert(document.domain)`)\n        ).toBe(\"about:blank\");\n      });\n\n      it(`ignores invisible ctrl characters in ${protocol} urls`, () => {\n        const protocolWithControlCharacters = protocol\n          .split(\"\")\n          .map((character, index) => {\n            if (index === 1) {\n              return character + \"%EF%BB%BF%EF%BB%BF\";\n            } else if (index === 2) {\n              return character + \"%e2%80%8b\";\n            }\n            return character;\n          })\n          .join(\"\");\n\n        expect(\n          sanitizeUrl(\n            decodeURIComponent(\n              `${protocolWithControlCharacters}:alert(document.domain)`\n            )\n          )\n        ).toBe(\"about:blank\");\n      });\n\n      it(`replaces ${protocol} urls with about:blank when url begins with %20`, () => {\n        expect(\n          sanitizeUrl(\n            decodeURIComponent(`%20%20%20%20${protocol}:alert(document.domain)`)\n          )\n        ).toBe(\"about:blank\");\n      });\n\n      it(`replaces ${protocol} urls with about:blank when ${protocol} url begins with spaces`, () => {\n        expect(sanitizeUrl(`    ${protocol}:alert(document.domain)`)).toBe(\n          \"about:blank\"\n        );\n      });\n\n      it(`does not replace ${protocol}: if it is not in the scheme of the URL`, () => {\n        expect(sanitizeUrl(`http://example.com#${protocol}:foo`)).toBe(\n          `http://example.com#${protocol}:foo`\n        );\n      });\n    });\n  });\n});\n", "const invalidProtocolRegex = /^([^\\w]*)(javascript|data|vbscript)/im;\nconst htmlEntitiesRegex = /&#(\\w+)(^\\w|;)?/g;\nconst htmlTabEntityRegex = /&tab;/gi;\nconst ctrlCharactersRegex =\n  /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nconst urlSchemeRegex = /^.+(:|&colon;)/gim;\nconst relativeFirstCharacters = [\".\", \"/\"];\n\nfunction isRelativeUrlWithoutProtocol(url: string): boolean {\n  return relativeFirstCharacters.indexOf(url[0]) > -1;\n}\n\n// adapted from https://stackoverflow.com/a/29824550/2601552\nfunction decodeHtmlCharacters(str: string) {\n  str = str.replace(htmlTabEntityRegex, \"&#9;\");\n  return str.replace(htmlEntitiesRegex, (match, dec) => {\n    return String.fromCharCode(dec);\n  });\n}\n\nexport function sanitizeUrl(url?: string): string {\n  const sanitizedUrl = decodeHtmlCharacters(url || \"\")\n    .replace(ctrlCharactersRegex, \"\")\n    .trim();\n\n  if (!sanitizedUrl) {\n    return \"about:blank\";\n  }\n\n  if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {\n    return sanitizedUrl;\n  }\n\n  const urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);\n\n  if (!urlSchemeParseResults) {\n    return sanitizedUrl;\n  }\n\n  const urlScheme = urlSchemeParseResults[0];\n\n  if (invalidProtocolRegex.test(urlScheme)) {\n    return \"about:blank\";\n  }\n\n  return sanitizedUrl;\n}\n"], "filenames": ["CHANGELOG.md", "src/__tests__/test.ts", "src/index.ts"], "buggy_code_start_loc": [1, 102, 2], "buggy_code_end_loc": [1, 134, 13], "fixing_code_start_loc": [2, 103, 3], "fixing_code_end_loc": [7, 145, 16], "type": "CWE-79", "message": "sanitize-url (aka @braintree/sanitize-url) before 6.0.2 allows XSS via HTML entities.", "other": {"cve": {"id": "CVE-2022-48345", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-24T06:15:11.317", "lastModified": "2023-03-02T17:32:59.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sanitize-url (aka @braintree/sanitize-url) before 6.0.2 allows XSS via HTML entities."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:paypal:braintree\\/sanitize-url:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "6.0.2", "matchCriteriaId": "0DF46207-7F7D-4475-8CAB-9B30B0FC29AA"}]}]}], "references": [{"url": "https://github.com/braintree/sanitize-url/commit/d4bdc89f1743fe3cdb7c3f24b06e4c875f349b0c", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/braintree/sanitize-url/compare/v6.0.1...v6.0.2", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}]}, "github_commit_url": "https://github.com/braintree/sanitize-url/commit/d4bdc89f1743fe3cdb7c3f24b06e4c875f349b0c"}}