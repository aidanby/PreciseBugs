{"buggy_code": ["// Copyright 2017 Eric Zhou. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage base64Captcha\n\nimport (\n\t\"container/list\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expValue stores timestamp and id of captchas. It is used in the list inside\n// memoryStore for indexing generated captchas by timestamp to enable garbage\n// collection of expired captchas.\ntype idByTimeValue struct {\n\ttimestamp time.Time\n\tid        string\n}\n\n// memoryStore is an internal store for captcha ids and their values.\ntype memoryStore struct {\n\tsync.RWMutex\n\tdigitsById map[string]string\n\tidByTime   *list.List\n\t// Number of items stored since last collection.\n\tnumStored int\n\t// Number of saved items that triggers collection.\n\tcollectNum int\n\t// Expiration time of captchas.\n\texpiration time.Duration\n}\n\n// NewMemoryStore returns a new standard memory store for captchas with the\n// given collection threshold and expiration time (duration). The returned\n// store must be registered with SetCustomStore to replace the default one.\nfunc NewMemoryStore(collectNum int, expiration time.Duration) Store {\n\ts := new(memoryStore)\n\ts.digitsById = make(map[string]string)\n\ts.idByTime = list.New()\n\ts.collectNum = collectNum\n\ts.expiration = expiration\n\treturn s\n}\n\nfunc (s *memoryStore) Set(id string, value string) error {\n\ts.Lock()\n\ts.digitsById[id] = value\n\ts.idByTime.PushBack(idByTimeValue{time.Now(), id})\n\ts.numStored++\n\ts.Unlock()\n\tif s.numStored > s.collectNum {\n\t\tgo s.collect()\n\t}\n\treturn nil\n}\n\nfunc (s *memoryStore) Verify(id, answer string, clear bool) bool {\n\tv := s.Get(id, clear)\n\treturn v != \"\" && v == answer\n}\n\nfunc (s *memoryStore) Get(id string, clear bool) (value string) {\n\tif !clear {\n\t\t// When we don't need to clear captcha, acquire read lock.\n\t\ts.RLock()\n\t\tdefer s.RUnlock()\n\t} else {\n\t\ts.Lock()\n\t\tdefer s.Unlock()\n\t}\n\tvalue, ok := s.digitsById[id]\n\tif !ok {\n\t\treturn\n\t}\n\tif clear {\n\t\tdelete(s.digitsById, id)\n\t}\n\treturn\n}\n\nfunc (s *memoryStore) collect() {\n\tnow := time.Now()\n\ts.Lock()\n\tdefer s.Unlock()\n\tfor e := s.idByTime.Front(); e != nil; {\n\t\te = s.collectOne(e, now)\n\t}\n}\n\nfunc (s *memoryStore) collectOne(e *list.Element, specifyTime time.Time) *list.Element {\n\n\tev, ok := e.Value.(idByTimeValue)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tif ev.timestamp.Add(s.expiration).Before(specifyTime) {\n\t\tdelete(s.digitsById, ev.id)\n\t\tnext := e.Next()\n\t\ts.idByTime.Remove(e)\n\t\ts.numStored--\n\t\treturn next\n\t}\n\treturn nil\n}\n", "// Copyright 2017 Eric Zhou. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage base64Captcha\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSetGet(t *testing.T) {\n\ts := NewMemoryStore(GCLimitNumber, Expiration)\n\tid := \"captcha id\"\n\td := \"random-string\"\n\t_ = s.Set(id, d)\n\td2 := s.Get(id, false)\n\tif d2 != d {\n\t\tt.Errorf(\"saved %v, getDigits returned got %v\", d, d2)\n\t}\n}\n\nfunc TestGetClear(t *testing.T) {\n\ts := NewMemoryStore(GCLimitNumber, Expiration)\n\tid := \"captcha id\"\n\td := \"932839jfffjkdss\"\n\t_ = s.Set(id, d)\n\td2 := s.Get(id, true)\n\tif d != d2 {\n\t\tt.Errorf(\"saved %v, getDigitsClear returned got %v\", d, d2)\n\t}\n\td2 = s.Get(id, false)\n\tif d2 != \"\" {\n\t\tt.Errorf(\"getDigitClear didn't clear (%q=%v)\", id, d2)\n\t}\n}\n\nfunc BenchmarkSetCollect(b *testing.B) {\n\tb.StopTimer()\n\td := \"fdskfew9832232r\"\n\ts := NewMemoryStore(9999, -1)\n\tids := make([]string, 1000)\n\tfor i := range ids {\n\t\tids[i] = fmt.Sprintf(\"%d\", rand.Int63())\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor j := 0; j < 1000; j++ {\n\t\t\t_ = s.Set(ids[j], d)\n\t\t}\n\t}\n}\n\nfunc TestMemoryStore_SetGoCollect(t *testing.T) {\n\ts := NewMemoryStore(10, -1)\n\tfor i := 0; i <= 100; i++ {\n\t\t_ = s.Set(fmt.Sprint(i), fmt.Sprint(i))\n\t}\n}\n\nfunc TestMemoryStore_CollectNotExpire(t *testing.T) {\n\ts := NewMemoryStore(10, time.Hour)\n\tfor i := 0; i < 50; i++ {\n\t\t_ = s.Set(fmt.Sprint(i), fmt.Sprint(i))\n\t}\n\n\t// let background goroutine to go\n\ttime.Sleep(time.Second)\n\n\tif v := s.Get(\"0\", false); v != \"0\" {\n\t\tt.Error(\"mem store get failed\")\n\t}\n}\n\nfunc TestNewMemoryStore(t *testing.T) {\n\ttype args struct {\n\t\tcollectNum int\n\t\texpiration time.Duration\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant Store\n\t}{\n\t\t{\"\", args{20, time.Hour}, nil},\n\t\t{\"\", args{20, time.Hour * 5}, nil},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NewMemoryStore(tt.args.collectNum, tt.args.expiration); got == nil {\n\t\t\t\tt.Errorf(\"NewMemoryStore() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_memoryStore_Set(t *testing.T) {\n\tthisStore := NewMemoryStore(10, time.Hour)\n\ttype args struct {\n\t\tid    string\n\t\tvalue string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ts    Store\n\t\targs args\n\t}{\n\t\t{\"\", thisStore, args{RandomId(), RandomId()}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_ = tt.s.Set(tt.args.id, tt.args.value)\n\t\t})\n\t}\n}\n\nfunc Test_memoryStore_Verify(t *testing.T) {\n\tthisStore := NewMemoryStore(10, time.Hour)\n\t_ = thisStore.Set(\"xx\", \"xx\")\n\tgot := thisStore.Verify(\"xx\", \"xx\", false)\n\tif !got {\n\t\tt.Error(\"failed1\")\n\t}\n\tgot = thisStore.Verify(\"xx\", \"xx\", true)\n\n\tif !got {\n\t\tt.Error(\"failed2\")\n\t}\n\tgot = thisStore.Verify(\"xx\", \"xx\", true)\n\n\tif got {\n\t\tt.Error(\"failed3\")\n\t}\n}\n\nfunc Test_memoryStore_Get(t *testing.T) {\n\tthisStore := NewMemoryStore(10, time.Hour)\n\t_ = thisStore.Set(\"xx\", \"xx\")\n\tgot := thisStore.Get(\"xx\", false)\n\tif got != \"xx\" {\n\t\tt.Error(\"failed1\")\n\t}\n\tgot = thisStore.Get(\"xx\", true)\n\tif got != \"xx\" {\n\t\tt.Error(\"failed2\")\n\t}\n\tgot = thisStore.Get(\"xx\", false)\n\tif got == \"xx\" {\n\t\tt.Error(\"failed3\")\n\t}\n\n}\n"], "fixing_code": ["// Copyright 2017 Eric Zhou. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage base64Captcha\n\nimport (\n\t\"container/list\"\n\t\"sync\"\n\t\"time\"\n)\n\n// expValue stores timestamp and id of captchas. It is used in the list inside\n// memoryStore for indexing generated captchas by timestamp to enable garbage\n// collection of expired captchas.\ntype idByTimeValue struct {\n\ttimestamp time.Time\n\tid        string\n}\n\n// memoryStore is an internal store for captcha ids and their values.\ntype memoryStore struct {\n\tsync.RWMutex\n\tdigitsById map[string]string\n\tidByTime   *list.List\n\t// Number of items stored since last collection.\n\tnumStored int\n\t// Number of saved items that triggers collection.\n\tcollectNum int\n\t// Expiration time of captchas.\n\texpiration time.Duration\n}\n\n// NewMemoryStore returns a new standard memory store for captchas with the\n// given collection threshold and expiration time (duration). The returned\n// store must be registered with SetCustomStore to replace the default one.\nfunc NewMemoryStore(collectNum int, expiration time.Duration) Store {\n\ts := new(memoryStore)\n\ts.digitsById = make(map[string]string)\n\ts.idByTime = list.New()\n\ts.collectNum = collectNum\n\ts.expiration = expiration\n\treturn s\n}\n\nfunc (s *memoryStore) Set(id string, value string) error {\n\ts.Lock()\n\ts.digitsById[id] = value\n\ts.idByTime.PushBack(idByTimeValue{time.Now(), id})\n\ts.numStored++\n\ts.Unlock()\n\tif s.numStored > s.collectNum {\n\t\tgo s.collect()\n\t}\n\treturn nil\n}\n\nfunc (s *memoryStore) Verify(id, answer string, clear bool) bool {\n\tif id == \"\" || answer == \"\" {\n\t\treturn false\n\t}\n\tv := s.Get(id, clear)\n\treturn v != \"\" && v == answer\n}\n\nfunc (s *memoryStore) Get(id string, clear bool) (value string) {\n\tif !clear {\n\t\t// When we don't need to clear captcha, acquire read lock.\n\t\ts.RLock()\n\t\tdefer s.RUnlock()\n\t} else {\n\t\ts.Lock()\n\t\tdefer s.Unlock()\n\t}\n\tvalue, ok := s.digitsById[id]\n\tif !ok {\n\t\treturn\n\t}\n\tif clear {\n\t\tdelete(s.digitsById, id)\n\t}\n\treturn\n}\n\nfunc (s *memoryStore) collect() {\n\tnow := time.Now()\n\ts.Lock()\n\tdefer s.Unlock()\n\tfor e := s.idByTime.Front(); e != nil; {\n\t\te = s.collectOne(e, now)\n\t}\n}\n\nfunc (s *memoryStore) collectOne(e *list.Element, specifyTime time.Time) *list.Element {\n\n\tev, ok := e.Value.(idByTimeValue)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tif ev.timestamp.Add(s.expiration).Before(specifyTime) {\n\t\tdelete(s.digitsById, ev.id)\n\t\tnext := e.Next()\n\t\ts.idByTime.Remove(e)\n\t\ts.numStored--\n\t\treturn next\n\t}\n\treturn nil\n}\n", "// Copyright 2017 Eric Zhou. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage base64Captcha\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSetGet(t *testing.T) {\n\ts := NewMemoryStore(GCLimitNumber, Expiration)\n\tid := \"captcha id\"\n\td := \"random-string\"\n\t_ = s.Set(id, d)\n\td2 := s.Get(id, false)\n\tif d2 != d {\n\t\tt.Errorf(\"saved %v, getDigits returned got %v\", d, d2)\n\t}\n}\n\nfunc TestGetClear(t *testing.T) {\n\ts := NewMemoryStore(GCLimitNumber, Expiration)\n\tid := \"captcha id\"\n\td := \"932839jfffjkdss\"\n\t_ = s.Set(id, d)\n\td2 := s.Get(id, true)\n\tif d != d2 {\n\t\tt.Errorf(\"saved %v, getDigitsClear returned got %v\", d, d2)\n\t}\n\td2 = s.Get(id, false)\n\tif d2 != \"\" {\n\t\tt.Errorf(\"getDigitClear didn't clear (%q=%v)\", id, d2)\n\t}\n}\n\nfunc BenchmarkSetCollect(b *testing.B) {\n\tb.StopTimer()\n\td := \"fdskfew9832232r\"\n\ts := NewMemoryStore(9999, -1)\n\tids := make([]string, 1000)\n\tfor i := range ids {\n\t\tids[i] = fmt.Sprintf(\"%d\", rand.Int63())\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor j := 0; j < 1000; j++ {\n\t\t\t_ = s.Set(ids[j], d)\n\t\t}\n\t}\n}\n\nfunc TestMemoryStore_SetGoCollect(t *testing.T) {\n\ts := NewMemoryStore(10, -1)\n\tfor i := 0; i <= 100; i++ {\n\t\t_ = s.Set(fmt.Sprint(i), fmt.Sprint(i))\n\t}\n}\n\nfunc TestMemoryStore_CollectNotExpire(t *testing.T) {\n\ts := NewMemoryStore(10, time.Hour)\n\tfor i := 0; i < 50; i++ {\n\t\t_ = s.Set(fmt.Sprint(i), fmt.Sprint(i))\n\t}\n\n\t// let background goroutine to go\n\ttime.Sleep(time.Second)\n\n\tif v := s.Get(\"0\", false); v != \"0\" {\n\t\tt.Error(\"mem store get failed\")\n\t}\n}\n\nfunc TestNewMemoryStore(t *testing.T) {\n\ttype args struct {\n\t\tcollectNum int\n\t\texpiration time.Duration\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant Store\n\t}{\n\t\t{\"\", args{20, time.Hour}, nil},\n\t\t{\"\", args{20, time.Hour * 5}, nil},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NewMemoryStore(tt.args.collectNum, tt.args.expiration); got == nil {\n\t\t\t\tt.Errorf(\"NewMemoryStore() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_memoryStore_Set(t *testing.T) {\n\tthisStore := NewMemoryStore(10, time.Hour)\n\ttype args struct {\n\t\tid    string\n\t\tvalue string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ts    Store\n\t\targs args\n\t}{\n\t\t{\"\", thisStore, args{RandomId(), RandomId()}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_ = tt.s.Set(tt.args.id, tt.args.value)\n\t\t})\n\t}\n}\n\nfunc Test_memoryStore_Verify(t *testing.T) {\n\tthisStore := NewMemoryStore(10, time.Hour)\n\t_ = thisStore.Set(\"xx\", \"xx\")\n\tgot := thisStore.Verify(\"xx\", \"xx\", false)\n\tif !got {\n\t\tt.Error(\"failed1\")\n\t}\n\tgot = thisStore.Verify(\"xx\", \"xx\", true)\n\n\tif !got {\n\t\tt.Error(\"failed2\")\n\t}\n\tgot = thisStore.Verify(\"xx\", \"xx\", true)\n\n\tif got {\n\t\tt.Error(\"failed3\")\n\t}\n\tgot = DefaultMemStore.Verify(\"saaf\", \"\", true)\n\tif got {\n\t\tt.Error(\"CVE-2023-45292 GO-2023-2386\")\n\t}\n}\n\nfunc Test_memoryStore_Get(t *testing.T) {\n\tthisStore := NewMemoryStore(10, time.Hour)\n\t_ = thisStore.Set(\"xx\", \"xx\")\n\tgot := thisStore.Get(\"xx\", false)\n\tif got != \"xx\" {\n\t\tt.Error(\"failed1\")\n\t}\n\tgot = thisStore.Get(\"xx\", true)\n\tif got != \"xx\" {\n\t\tt.Error(\"failed2\")\n\t}\n\tgot = thisStore.Get(\"xx\", false)\n\tif got == \"xx\" {\n\t\tt.Error(\"failed3\")\n\t}\n\n}\n"], "filenames": ["store_memory.go", "store_memory_test.go"], "buggy_code_start_loc": [68, 145], "buggy_code_end_loc": [68, 145], "fixing_code_start_loc": [69, 146], "fixing_code_end_loc": [72, 150], "type": "CWE-345", "message": "When using the default implementation of Verify to check a Captcha, verification can be bypassed. For example, if the first parameter is a non-existent id, the second parameter is an empty string, and the third parameter is true, the function will always consider the Captcha to be correct.", "other": {"cve": {"id": "CVE-2023-45292", "sourceIdentifier": "security@golang.org", "published": "2023-12-11T22:15:06.677", "lastModified": "2023-12-14T16:26:54.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "When using the default implementation of Verify to check a Captcha, verification can be bypassed. For example, if the first parameter is a non-existent id, the second parameter is an empty string, and the third parameter is true, the function will always consider the Captcha to be correct."}, {"lang": "es", "value": "Cuando se utiliza la implementaci\u00f3n predeterminada de Verify para verificar un Captcha, se puede omitir la verificaci\u00f3n. Por ejemplo, si el primer par\u00e1metro es una identificaci\u00f3n inexistente, el segundo par\u00e1metro es una cadena vac\u00eda y el tercer par\u00e1metro es verdadero, la funci\u00f3n siempre considerar\u00e1 que el Captcha es correcto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mojotv:base64captcha:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.3.6", "matchCriteriaId": "20EF9A8D-B33C-468E-9928-2E80A0C1EA00"}]}]}], "references": [{"url": "https://github.com/mojocn/base64Captcha/commit/5ab86bd6f333aad3936f912fc52b411168dcd4a7", "source": "security@golang.org", "tags": ["Patch"]}, {"url": "https://github.com/mojocn/base64Captcha/commit/9b11012caca58925f1e47c770f79f2fa47e3ad13", "source": "security@golang.org", "tags": ["Patch"]}, {"url": "https://github.com/mojocn/base64Captcha/issues/120", "source": "security@golang.org", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://pkg.go.dev/vuln/GO-2023-2386", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mojocn/base64Captcha/commit/5ab86bd6f333aad3936f912fc52b411168dcd4a7"}}