{"buggy_code": ["import I18n from \"I18n\";\n\nfunction wrap(tag, attr, callback) {\n  return function (startToken, finishToken, tagInfo) {\n    startToken.tag = finishToken.tag = tag;\n    startToken.content = finishToken.content = \"\";\n\n    startToken.type = \"bbcode_open\";\n    finishToken.type = \"bbcode_close\";\n\n    startToken.nesting = 1;\n    finishToken.nesting = -1;\n\n    startToken.attrs = [\n      [attr, callback ? callback(tagInfo) : tagInfo.attrs._default],\n    ];\n  };\n}\n\nfunction setupMarkdownIt(md) {\n  const ruler = md.inline.bbcode.ruler;\n\n  ruler.push(\"size\", {\n    tag: \"size\",\n\n    wrap: wrap(\n      \"span\",\n      \"style\",\n      (tagInfo) => \"font-size:\" + tagInfo.attrs._default.trim() + \"%\"\n    ),\n  });\n\n  ruler.push(\"font\", {\n    tag: \"font\",\n\n    wrap: wrap(\n      \"span\",\n      \"style\",\n      (tagInfo) => `font-family:'${tagInfo.attrs._default.trim()}'`\n    ),\n  });\n\n  ruler.push(\"color\", {\n    tag: \"color\",\n\n    wrap: wrap(\n      \"span\",\n      \"style\",\n      (tagInfo) => \"color:\" + tagInfo.attrs._default.trim()\n    ),\n  });\n\n  ruler.push(\"bgcolor\", {\n    tag: \"bgcolor\",\n\n    wrap: wrap(\n      \"span\",\n      \"style\",\n      (tagInfo) => \"background-color:\" + tagInfo.attrs._default.trim()\n    ),\n  });\n\n  ruler.push(\"highlight\", {\n    tag: \"highlight\",\n    wrap: \"span.highlight\",\n  });\n\n  ruler.push(\"small\", {\n    tag: \"small\",\n    wrap: wrap(\"span\", \"style\", () => \"font-size:x-small\"),\n  });\n\n  ruler.push(\"aname\", {\n    tag: \"aname\",\n    wrap: wrap(\"a\", \"name\"),\n  });\n\n  ruler.push(\"jumpto\", {\n    tag: \"jumpto\",\n    wrap: wrap(\"a\", \"href\", (tagInfo) => \"#\" + tagInfo.attrs._default),\n  });\n\n  [\"left\", \"right\", \"center\"].forEach((dir) => {\n    md.block.bbcode.ruler.push(dir, {\n      tag: dir,\n      wrap: function (token) {\n        token.attrs = [[\"style\", \"text-align:\" + dir]];\n        return true;\n      },\n    });\n  });\n\n  md.block.bbcode.ruler.push(\"indent\", {\n    tag: \"indent\",\n    wrap: \"blockquote.indent\",\n  });\n\n  [\"ot\", \"edit\"].forEach((tag) => {\n    md.block.bbcode.ruler.push(\"ot\", {\n      tag,\n      before: function (state) {\n        let token = state.push(\"sepquote_open\", \"div\", 1);\n        token.attrs = [[\"class\", \"sepquote\"]];\n\n        token = state.push(\"span_open\", \"span\", 1);\n        token.block = false;\n        token.attrs = [[\"class\", \"smallfont\"]];\n\n        token = state.push(\"text\", \"\", 0);\n        token.content = I18n.t(\"bbcode.\" + tag);\n\n        token = state.push(\"span_close\", \"span\", -1);\n\n        state.push(\"soft_break\", \"br\", 0);\n        state.push(\"soft_break\", \"br\", 0);\n      },\n      after: function (state) {\n        state.push(\"sepquote_close\", \"div\", -1);\n      },\n    });\n  });\n\n  [\"list\", \"ul\", \"ol\"].forEach((tag) => {\n    md.block.bbcode.ruler.push(tag, {\n      tag,\n      replace: function (state, tagInfo, content) {\n        let ol = tag === \"ol\" || (tag === \"list\" && tagInfo.attrs._default);\n        let token;\n\n        if (ol) {\n          token = state.push(\"ordered_list_open\", \"ol\", 1);\n          if (tagInfo.attrs._default) {\n            token.attrs = [[\"type\", tagInfo.attrs._default]];\n          }\n        } else {\n          state.push(\"bullet_list_open\", \"ul\", 1);\n        }\n\n        let lines = content.split(\"\\n\");\n        let list = [null];\n        let index = 0;\n\n        for (let i = 0; i < lines.length; i++) {\n          let line = lines[i];\n\n          let match = line.match(/^\\s*\\[?\\*\\]?(.*)/);\n          if (match) {\n            index++;\n            list[index] = match[1];\n            continue;\n          }\n\n          match = line.match(/\\s*\\[li\\](.*)\\[\\/li\\]\\s*$/);\n          if (match) {\n            index++;\n            list[index] = match[1];\n            continue;\n          }\n\n          if (list[index]) {\n            list[index] += \"\\n\" + line;\n          } else {\n            list[index] = line;\n          }\n        }\n\n        list.forEach((li) => {\n          if (li !== null) {\n            state.push(\"list_item_open\", \"li\", 1);\n            // a bit lazy, we could use a block parser here\n            // but it means a lot of fussing with line marks\n            token = state.push(\"inline\", \"\", 0);\n            token.content = li;\n            token.children = [];\n\n            state.push(\"list_item_close\", \"li\", -1);\n          }\n        });\n\n        if (ol) {\n          state.push(\"ordered_list_close\", \"ol\", -1);\n        } else {\n          state.push(\"bullet_list_close\", \"ul\", -1);\n        }\n\n        return true;\n      },\n    });\n  });\n}\n\nexport function setup(helper) {\n  helper.allowList([\n    \"div.highlight\",\n    \"span.highlight\",\n    \"div.sepquote\",\n    \"span.smallfont\",\n    \"blockquote.indent\",\n    \"ol[type=*]\",\n  ]);\n\n  helper.allowList({\n    custom(tag, name, value) {\n      if (tag === \"span\" && name === \"style\") {\n        return /^(font-size:(xx-small|x-small|small|medium|large|x-large|xx-large|[0-9]{1,3}%)|background-color:#?[a-zA-Z0-9]+|color:#?[a-zA-Z0-9]+|font-family:[\\s\\S]+)$/.exec(\n          value\n        );\n      }\n\n      if (tag === \"div\" && name === \"style\") {\n        return /^text-align:(center|left|right)$/.exec(value);\n      }\n    },\n  });\n\n  helper.registerOptions((opts) => {\n    opts.features[\"bbcode\"] = true;\n  });\n\n  helper.registerPlugin(setupMarkdownIt);\n}\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe PrettyText do\n\n  it 'can apply color bbcode' do\n    cooked = PrettyText.cook \"hello [color=red]RED[/color] or [color=#00ff00]BLUE[/color] world\"\n    html = '<p>hello <span style=\"color:red\">RED</span> or <span style=\"color:#00ff00\">BLUE</span> world</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply size bbcode' do\n    cooked = PrettyText.cook \"hello [size=150]BIG[/size] text\"\n    html = '<p>hello <span style=\"font-size:150%\">BIG</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply font bbcode' do\n    cooked = PrettyText.cook \"hello [font=usa]usa[/font] text\"\n    html = '<p>hello <span style=\"font-family:\\'usa\\'\">usa</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply small bbcode' do\n    cooked = PrettyText.cook \"hello [small]usa[/small] text\"\n    html = '<p>hello <span style=\"font-size:x-small\">usa</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply highlight bbcode' do\n    cooked = PrettyText.cook \"hello [highlight]highlight[/highlight] text\"\n    html = '<p>hello <span class=\"highlight\">highlight</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply left center and right' do\n    markdown = <<~MD\n    [left]\n    I am aligned to the left\n\n    **yay**\n    [/left]\n\n    [center]\n\n    I am in the *middle*\n\n    [/center]\n\n    [right]\n\n    and I am too the right\n\n    [/right]\n    MD\n    cooked = PrettyText.cook markdown\n    html = <<~HTML\n      <div style=\"text-align:left\">\n      <p>I am aligned to the left</p>\n      <p><strong>yay</strong></p>\n      </div>\n      <div style=\"text-align:center\">\n      <p>I am in the <em>middle</em></p>\n      </div>\n      <div style=\"text-align:right\">\n      <p>and I am too the right</p>\n      </div>\n    HTML\n\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"supports edit and ot, indent\" do\n    markdown = <<~MD\n      [ot]\n      test\n      [/ot]\n\n      [edit]\n      i am edit\n      [/edit]\n\n      [indent]\n      test\n      [/indent]\n    MD\n\n    cooked = PrettyText.cook(markdown)\n\n    html = <<~HTML\n      <div class=\"sepquote\">\n      <span class=\"smallfont\">Off Topic:</span>\n      <br>\n      <br>\n      <p>test</p>\n      </div>\n      <div class=\"sepquote\">\n      <span class=\"smallfont\">Edit:</span>\n      <br>\n      <br>\n      <p>i am edit</p>\n      </div>\n      <blockquote class=\"indent\">\n      <p>test</p>\n      </blockquote>\n    HTML\n\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"supports aname and jumpto\" do\n    markdown = <<~MD\n      [aname=bob]I am an anchor[/aname]\n\n      [jumpto=bob]I am a href jump to[/jumpto]\n    MD\n\n    cooked = PrettyText.cook(markdown)\n    html = <<~HTML\n     <p><a name=\"bob\">I am an anchor</a></p>\n     <p><a href=\"#bob\">I am a href jump to</a></p>\n    HTML\n\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"supports the nightmare bbcode list\" do\n    markdown = <<~MD\n      [list=A]\n      [*] I am an **item**\n      [*] I am another **item**\n      [/list]\n\n      [list]\n      [*] I am an **item**\n      [*] I am another **item**\n      [/list]\n\n      [ol]\n      *another item\n      [*]and yet another\n      [/ol]\n\n      [ul]\n\n         [li]this is an item[/li]\n\n      *mix and match\n      and do multiline cause why not\n\n      even multi paragraph?\n\n      [*]mix\n\n      [/ul]\n\n      [list]\n      this is an invalid list\n      [/list]\n\n    MD\n\n    html = <<~HTML\n      <ol type=\"A\">\n      <li> I am an <strong>item</strong>\n      </li>\n      <li> I am another <strong>item</strong>\n      </li>\n      </ol>\n      <ul>\n      <li> I am an <strong>item</strong>\n      </li>\n      <li> I am another <strong>item</strong>\n      </li>\n      </ul>\n      <ol>\n      <li>another item</li>\n      <li>and yet another</li>\n      </ol>\n      <ul>\n      <li>\n      <li>this is an item<br>\n      </li>\n      <li>mix and match<br>\n      and do multiline cause why not<br>\n      <br>\n      even multi paragraph?<br>\n      </li>\n      <li>mix<br>\n      </li>\n      </ul>\n      <ul>\n      <li>this is an invalid list</li>\n      </ul>\n    HTML\n\n    cooked = PrettyText.cook markdown\n    expect(cooked).to eq(html.strip)\n  end\n\nend\n"], "fixing_code": ["import I18n from \"I18n\";\n\nfunction wrap(tag, attr, callback) {\n  return function (startToken, finishToken, tagInfo) {\n    startToken.tag = finishToken.tag = tag;\n    startToken.content = finishToken.content = \"\";\n\n    startToken.type = \"bbcode_open\";\n    finishToken.type = \"bbcode_close\";\n\n    startToken.nesting = 1;\n    finishToken.nesting = -1;\n\n    startToken.attrs = [\n      [attr, callback ? callback(tagInfo) : tagInfo.attrs._default],\n    ];\n  };\n}\n\nfunction setupMarkdownIt(md) {\n  const ruler = md.inline.bbcode.ruler;\n\n  ruler.push(\"size\", {\n    tag: \"size\",\n\n    wrap: wrap(\n      \"span\",\n      \"style\",\n      (tagInfo) => \"font-size:\" + tagInfo.attrs._default.trim() + \"%\"\n    ),\n  });\n\n  ruler.push(\"font\", {\n    tag: \"font\",\n\n    wrap: wrap(\n      \"span\",\n      \"style\",\n      (tagInfo) => `font-family:'${tagInfo.attrs._default.trim()}'`\n    ),\n  });\n\n  ruler.push(\"color\", {\n    tag: \"color\",\n\n    wrap: wrap(\n      \"span\",\n      \"style\",\n      (tagInfo) => \"color:\" + tagInfo.attrs._default.trim()\n    ),\n  });\n\n  ruler.push(\"bgcolor\", {\n    tag: \"bgcolor\",\n\n    wrap: wrap(\n      \"span\",\n      \"style\",\n      (tagInfo) => \"background-color:\" + tagInfo.attrs._default.trim()\n    ),\n  });\n\n  ruler.push(\"highlight\", {\n    tag: \"highlight\",\n    wrap: \"span.highlight\",\n  });\n\n  ruler.push(\"small\", {\n    tag: \"small\",\n    wrap: wrap(\"span\", \"style\", () => \"font-size:x-small\"),\n  });\n\n  ruler.push(\"aname\", {\n    tag: \"aname\",\n    wrap: wrap(\"a\", \"name\"),\n  });\n\n  ruler.push(\"jumpto\", {\n    tag: \"jumpto\",\n    wrap: wrap(\"a\", \"href\", (tagInfo) => \"#\" + tagInfo.attrs._default),\n  });\n\n  [\"left\", \"right\", \"center\"].forEach((dir) => {\n    md.block.bbcode.ruler.push(dir, {\n      tag: dir,\n      wrap: function (token) {\n        token.attrs = [[\"style\", \"text-align:\" + dir]];\n        return true;\n      },\n    });\n  });\n\n  md.block.bbcode.ruler.push(\"indent\", {\n    tag: \"indent\",\n    wrap: \"blockquote.indent\",\n  });\n\n  [\"ot\", \"edit\"].forEach((tag) => {\n    md.block.bbcode.ruler.push(\"ot\", {\n      tag,\n      before: function (state) {\n        let token = state.push(\"sepquote_open\", \"div\", 1);\n        token.attrs = [[\"class\", \"sepquote\"]];\n\n        token = state.push(\"span_open\", \"span\", 1);\n        token.block = false;\n        token.attrs = [[\"class\", \"smallfont\"]];\n\n        token = state.push(\"text\", \"\", 0);\n        token.content = I18n.t(\"bbcode.\" + tag);\n\n        token = state.push(\"span_close\", \"span\", -1);\n\n        state.push(\"soft_break\", \"br\", 0);\n        state.push(\"soft_break\", \"br\", 0);\n      },\n      after: function (state) {\n        state.push(\"sepquote_close\", \"div\", -1);\n      },\n    });\n  });\n\n  [\"list\", \"ul\", \"ol\"].forEach((tag) => {\n    md.block.bbcode.ruler.push(tag, {\n      tag,\n      replace: function (state, tagInfo, content) {\n        let ol = tag === \"ol\" || (tag === \"list\" && tagInfo.attrs._default);\n        let token;\n\n        if (ol) {\n          token = state.push(\"ordered_list_open\", \"ol\", 1);\n          if (tagInfo.attrs._default) {\n            token.attrs = [[\"type\", tagInfo.attrs._default]];\n          }\n        } else {\n          state.push(\"bullet_list_open\", \"ul\", 1);\n        }\n\n        let lines = content.split(\"\\n\");\n        let list = [null];\n        let index = 0;\n\n        for (let i = 0; i < lines.length; i++) {\n          let line = lines[i];\n\n          let match = line.match(/^\\s*\\[?\\*\\]?(.*)/);\n          if (match) {\n            index++;\n            list[index] = match[1];\n            continue;\n          }\n\n          match = line.match(/\\s*\\[li\\](.*)\\[\\/li\\]\\s*$/);\n          if (match) {\n            index++;\n            list[index] = match[1];\n            continue;\n          }\n\n          if (list[index]) {\n            list[index] += \"\\n\" + line;\n          } else {\n            list[index] = line;\n          }\n        }\n\n        list.forEach((li) => {\n          if (li !== null) {\n            state.push(\"list_item_open\", \"li\", 1);\n            // a bit lazy, we could use a block parser here\n            // but it means a lot of fussing with line marks\n            token = state.push(\"inline\", \"\", 0);\n            token.content = li;\n            token.children = [];\n\n            state.push(\"list_item_close\", \"li\", -1);\n          }\n        });\n\n        if (ol) {\n          state.push(\"ordered_list_close\", \"ol\", -1);\n        } else {\n          state.push(\"bullet_list_close\", \"ul\", -1);\n        }\n\n        return true;\n      },\n    });\n  });\n}\n\nexport function setup(helper) {\n  helper.allowList([\n    \"div.highlight\",\n    \"span.highlight\",\n    \"div.sepquote\",\n    \"span.smallfont\",\n    \"blockquote.indent\",\n    \"ol[type=*]\",\n  ]);\n\n  helper.allowList({\n    custom(tag, name, value) {\n      if (tag === \"span\" && name === \"style\") {\n        return /^(font-size:(xx-small|x-small|small|medium|large|x-large|xx-large|[0-9]{1,3}%)|background-color:#?[a-zA-Z0-9]+|color:#?[a-zA-Z0-9]+|font-family:'[a-zA-Z0-9\\s-]+')$/.exec(\n          value\n        );\n      }\n\n      if (tag === \"div\" && name === \"style\") {\n        return /^text-align:(center|left|right)$/.exec(value);\n      }\n    },\n  });\n\n  helper.registerOptions((opts) => {\n    opts.features[\"bbcode\"] = true;\n  });\n\n  helper.registerPlugin(setupMarkdownIt);\n}\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe PrettyText do\n\n  it 'can apply color bbcode' do\n    cooked = PrettyText.cook \"hello [color=red]RED[/color] or [color=#00ff00]BLUE[/color] world\"\n    html = '<p>hello <span style=\"color:red\">RED</span> or <span style=\"color:#00ff00\">BLUE</span> world</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply size bbcode' do\n    cooked = PrettyText.cook \"hello [size=150]BIG[/size] text\"\n    html = '<p>hello <span style=\"font-size:150%\">BIG</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply font bbcode' do\n    cooked = PrettyText.cook \"hello [font=usa]usa[/font] text\"\n    html = '<p>hello <span style=\"font-family:\\'usa\\'\">usa</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply font bbcode with hyphen' do\n    cooked = PrettyText.cook \"hello [font=sans-serif]sans-serif[/font] text\"\n    html = '<p>hello <span style=\"font-family:\\'sans-serif\\'\">sans-serif</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply font bbcode with space' do\n    cooked = PrettyText.cook \"hello [font=Times New Roman]Times New Roman[/font] text\"\n    html = '<p>hello <span style=\"font-family:\\'Times New Roman\\'\">Times New Roman</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'only uses fonts with valid text' do\n    cooked = PrettyText.cook \"hello [font=ui-monospace';]usa[/font] text\"\n    html = '<p>hello <span>usa</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply small bbcode' do\n    cooked = PrettyText.cook \"hello [small]usa[/small] text\"\n    html = '<p>hello <span style=\"font-size:x-small\">usa</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply highlight bbcode' do\n    cooked = PrettyText.cook \"hello [highlight]highlight[/highlight] text\"\n    html = '<p>hello <span class=\"highlight\">highlight</span> text</p>'\n\n    expect(cooked).to eq(html)\n  end\n\n  it 'can apply left center and right' do\n    markdown = <<~MD\n    [left]\n    I am aligned to the left\n\n    **yay**\n    [/left]\n\n    [center]\n\n    I am in the *middle*\n\n    [/center]\n\n    [right]\n\n    and I am too the right\n\n    [/right]\n    MD\n    cooked = PrettyText.cook markdown\n    html = <<~HTML\n      <div style=\"text-align:left\">\n      <p>I am aligned to the left</p>\n      <p><strong>yay</strong></p>\n      </div>\n      <div style=\"text-align:center\">\n      <p>I am in the <em>middle</em></p>\n      </div>\n      <div style=\"text-align:right\">\n      <p>and I am too the right</p>\n      </div>\n    HTML\n\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"supports edit and ot, indent\" do\n    markdown = <<~MD\n      [ot]\n      test\n      [/ot]\n\n      [edit]\n      i am edit\n      [/edit]\n\n      [indent]\n      test\n      [/indent]\n    MD\n\n    cooked = PrettyText.cook(markdown)\n\n    html = <<~HTML\n      <div class=\"sepquote\">\n      <span class=\"smallfont\">Off Topic:</span>\n      <br>\n      <br>\n      <p>test</p>\n      </div>\n      <div class=\"sepquote\">\n      <span class=\"smallfont\">Edit:</span>\n      <br>\n      <br>\n      <p>i am edit</p>\n      </div>\n      <blockquote class=\"indent\">\n      <p>test</p>\n      </blockquote>\n    HTML\n\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"supports aname and jumpto\" do\n    markdown = <<~MD\n      [aname=bob]I am an anchor[/aname]\n\n      [jumpto=bob]I am a href jump to[/jumpto]\n    MD\n\n    cooked = PrettyText.cook(markdown)\n    html = <<~HTML\n     <p><a name=\"bob\">I am an anchor</a></p>\n     <p><a href=\"#bob\">I am a href jump to</a></p>\n    HTML\n\n    expect(cooked).to eq(html.strip)\n  end\n\n  it \"supports the nightmare bbcode list\" do\n    markdown = <<~MD\n      [list=A]\n      [*] I am an **item**\n      [*] I am another **item**\n      [/list]\n\n      [list]\n      [*] I am an **item**\n      [*] I am another **item**\n      [/list]\n\n      [ol]\n      *another item\n      [*]and yet another\n      [/ol]\n\n      [ul]\n\n         [li]this is an item[/li]\n\n      *mix and match\n      and do multiline cause why not\n\n      even multi paragraph?\n\n      [*]mix\n\n      [/ul]\n\n      [list]\n      this is an invalid list\n      [/list]\n\n    MD\n\n    html = <<~HTML\n      <ol type=\"A\">\n      <li> I am an <strong>item</strong>\n      </li>\n      <li> I am another <strong>item</strong>\n      </li>\n      </ol>\n      <ul>\n      <li> I am an <strong>item</strong>\n      </li>\n      <li> I am another <strong>item</strong>\n      </li>\n      </ul>\n      <ol>\n      <li>another item</li>\n      <li>and yet another</li>\n      </ol>\n      <ul>\n      <li>\n      <li>this is an item<br>\n      </li>\n      <li>mix and match<br>\n      and do multiline cause why not<br>\n      <br>\n      even multi paragraph?<br>\n      </li>\n      <li>mix<br>\n      </li>\n      </ul>\n      <ul>\n      <li>this is an invalid list</li>\n      </ul>\n    HTML\n\n    cooked = PrettyText.cook markdown\n    expect(cooked).to eq(html.strip)\n  end\n\nend\n"], "filenames": ["assets/javascripts/lib/discourse-markdown/bbcode.js", "spec/pretty_text_spec.rb"], "buggy_code_start_loc": [205, 23], "buggy_code_end_loc": [206, 23], "fixing_code_start_loc": [205, 24], "fixing_code_end_loc": [206, 45], "type": "CWE-74", "message": "discourse-bbcode is the official BBCode plugin for Discourse. Prior to commit 91478f5, CSS injection can occur when rendering content generated with the discourse-bccode plugin. This vulnerability only affects sites which have the discourse-bbcode plugin installed and enabled. This issue is patched in commit 91478f5. As a workaround, ensure that the Content Security Policy is enabled and monitor any posts that contain bbcode.", "other": {"cve": {"id": "CVE-2022-46162", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-30T23:15:10.673", "lastModified": "2022-12-02T16:36:09.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "discourse-bbcode is the official BBCode plugin for Discourse. Prior to commit 91478f5, CSS injection can occur when rendering content generated with the discourse-bccode plugin. This vulnerability only affects sites which have the discourse-bbcode plugin installed and enabled. This issue is patched in commit 91478f5. As a workaround, ensure that the Content Security Policy is enabled and monitor any posts that contain bbcode."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse_bbcode:*:*:*:*:*:discourse:*:*", "versionEndExcluding": "2022-11-30", "matchCriteriaId": "1B6A75CF-23CB-4D5D-93AF-9F63489B9945"}]}]}], "references": [{"url": "https://github.com/discourse/discourse-bbcode/commit/91478f5cfecdcc43cf85b997168a8ecfd0f8df90", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse-bbcode/security/advisories/GHSA-8c87-xpqv-c7mp", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-bbcode/commit/91478f5cfecdcc43cf85b997168a8ecfd0f8df90"}}