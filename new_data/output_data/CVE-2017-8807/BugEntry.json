{"buggy_code": ["/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2015 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include \"cache.h\"\n#include \"cache_director.h\"\n#include \"cache_filter.h\"\n#include \"hash/hash_slinger.h\"\n#include \"storage/storage.h\"\n#include \"vcl.h\"\n#include \"vtim.h\"\n\n/*--------------------------------------------------------------------\n * Allocate an object, with fall-back to Transient.\n * XXX: This somewhat overlaps the stuff in stevedore.c\n * XXX: Should this be merged over there ?\n */\n\nstatic int\nvbf_allocobj(struct busyobj *bo, unsigned l)\n{\n\tstruct objcore *oc;\n\tconst struct stevedore *stv;\n\tdouble lifetime;\n\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\toc = bo->fetch_objcore;\n\tCHECK_OBJ_NOTNULL(oc, OBJCORE_MAGIC);\n\n\tlifetime = oc->ttl + oc->grace + oc->keep;\n\n\tif (bo->uncacheable || lifetime < cache_param->shortlived)\n\t\tstv = stv_transient;\n\telse\n\t\tstv = bo->storage;\n\n\tbo->storage = NULL;\n\tbo->storage_hint = NULL;\n\n\tif (stv == NULL)\n\t\treturn (0);\n\n\tif (STV_NewObject(bo->wrk, bo->fetch_objcore, stv, l))\n\t\treturn (1);\n\n\tif (stv == stv_transient)\n\t\treturn (0);\n\n\t/*\n\t * Try to salvage the transaction by allocating a shortlived object\n\t * on Transient storage.\n\t */\n\n\tif (oc->ttl > cache_param->shortlived)\n\t\toc->ttl = cache_param->shortlived;\n\toc->grace = 0.0;\n\toc->keep = 0.0;\n\treturn (STV_NewObject(bo->wrk, bo->fetch_objcore, stv_transient, l));\n}\n\n/*--------------------------------------------------------------------\n * Turn the beresp into a obj\n */\n\nstatic int\nvbf_beresp2obj(struct busyobj *bo)\n{\n\tunsigned l, l2;\n\tconst char *b;\n\tuint8_t *bp;\n\tstruct vsb *vary = NULL;\n\tint varyl = 0;\n\n\tl = 0;\n\n\t/* Create Vary instructions */\n\tif (!(bo->fetch_objcore->flags & OC_F_PRIVATE)) {\n\t\tvaryl = VRY_Create(bo, &vary);\n\t\tif (varyl > 0) {\n\t\t\tAN(vary);\n\t\t\tassert(varyl == VSB_len(vary));\n\t\t\tl += PRNDUP((intptr_t)varyl);\n\t\t} else if (varyl < 0) {\n\t\t\t/*\n\t\t\t * Vary parse error\n\t\t\t * Complain about it, and make this a pass.\n\t\t\t */\n\t\t\tVSLb(bo->vsl, SLT_Error,\n\t\t\t    \"Illegal 'Vary' header from backend, \"\n\t\t\t    \"making this a pass.\");\n\t\t\tbo->uncacheable = 1;\n\t\t\tAZ(vary);\n\t\t} else\n\t\t\t/* No vary */\n\t\t\tAZ(vary);\n\t}\n\n\tl2 = http_EstimateWS(bo->beresp,\n\t    bo->uncacheable ? HTTPH_A_PASS : HTTPH_A_INS);\n\tl += l2;\n\n\tif (bo->uncacheable)\n\t\tbo->fetch_objcore->flags |= OC_F_PASS;\n\n\tif (!vbf_allocobj(bo, l))\n\t\treturn (-1);\n\n\tif (vary != NULL) {\n\t\tAN(ObjSetAttr(bo->wrk, bo->fetch_objcore, OA_VARY, varyl,\n\t\t\tVSB_data(vary)));\n\t\tVSB_destroy(&vary);\n\t}\n\n\tAZ(ObjSetU32(bo->wrk, bo->fetch_objcore, OA_VXID, VXID(bo->vsl->wid)));\n\n\t/* for HTTP_Encode() VSLH call */\n\tbo->beresp->logtag = SLT_ObjMethod;\n\n\t/* Filter into object */\n\tbp = ObjSetAttr(bo->wrk, bo->fetch_objcore, OA_HEADERS, l2, NULL);\n\tAN(bp);\n\tHTTP_Encode(bo->beresp, bp, l2,\n\t    bo->uncacheable ? HTTPH_A_PASS : HTTPH_A_INS);\n\n\tif (http_GetHdr(bo->beresp, H_Last_Modified, &b))\n\t\tAZ(ObjSetDouble(bo->wrk, bo->fetch_objcore, OA_LASTMODIFIED,\n\t\t    VTIM_parse(b)));\n\telse\n\t\tAZ(ObjSetDouble(bo->wrk, bo->fetch_objcore, OA_LASTMODIFIED,\n\t\t    floor(bo->fetch_objcore->t_origin)));\n\n\treturn (0);\n}\n\n/*--------------------------------------------------------------------\n * Copy req->bereq and release req if not pass fetch\n */\n\nstatic enum fetch_step\nvbf_stp_mkbereq(struct worker *wrk, struct busyobj *bo)\n{\n\tconst char *q;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->req, REQ_MAGIC);\n\n\tassert(bo->fetch_objcore->boc->state == BOS_INVALID);\n\tAZ(bo->storage);\n\tAZ(bo->storage_hint);\n\n\tHTTP_Setup(bo->bereq0, bo->ws, bo->vsl, SLT_BereqMethod);\n\thttp_FilterReq(bo->bereq0, bo->req->http,\n\t    bo->do_pass ? HTTPH_R_PASS : HTTPH_R_FETCH);\n\n\tif (!bo->do_pass) {\n\t\thttp_ForceField(bo->bereq0, HTTP_HDR_METHOD, \"GET\");\n\t\thttp_ForceField(bo->bereq0, HTTP_HDR_PROTO, \"HTTP/1.1\");\n\t\tif (cache_param->http_gzip_support)\n\t\t\thttp_ForceHeader(bo->bereq0, H_Accept_Encoding, \"gzip\");\n\t} else {\n\t\tAZ(bo->stale_oc);\n\t\tif (bo->bereq0->protover > 11)\n\t\t\thttp_ForceField(bo->bereq0, HTTP_HDR_PROTO, \"HTTP/1.1\");\n\t}\n\thttp_CopyHome(bo->bereq0);\n\n\tif (bo->stale_oc != NULL &&\n\t    ObjCheckFlag(bo->wrk, bo->stale_oc, OF_IMSCAND) &&\n\t    (bo->stale_oc->boc != NULL || ObjGetLen(wrk, bo->stale_oc) != 0)) {\n\t\tAZ(bo->stale_oc->flags & OC_F_PASS);\n\t\tq = HTTP_GetHdrPack(bo->wrk, bo->stale_oc, H_Last_Modified);\n\t\tif (q != NULL)\n\t\t\thttp_PrintfHeader(bo->bereq0,\n\t\t\t    \"If-Modified-Since: %s\", q);\n\t\tq = HTTP_GetHdrPack(bo->wrk, bo->stale_oc, H_ETag);\n\t\tif (q != NULL)\n\t\t\thttp_PrintfHeader(bo->bereq0,\n\t\t\t    \"If-None-Match: %s\", q);\n\t}\n\n\tHTTP_Setup(bo->bereq, bo->ws, bo->vsl, SLT_BereqMethod);\n\tbo->ws_bo = WS_Snapshot(bo->ws);\n\tHTTP_Copy(bo->bereq, bo->bereq0);\n\n\tif (bo->req->req_body_status == REQ_BODY_NONE) {\n\t\tbo->req = NULL;\n\t\tObjSetState(bo->wrk, bo->fetch_objcore, BOS_REQ_DONE);\n\t}\n\treturn (F_STP_STARTFETCH);\n}\n\n/*--------------------------------------------------------------------\n * Start a new VSL transaction and try again\n * Prepare the busyobj and fetch processors\n */\n\nstatic enum fetch_step\nvbf_stp_retry(struct worker *wrk, struct busyobj *bo)\n{\n\tstruct vfp_ctx *vfc;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tvfc = bo->vfc;\n\tCHECK_OBJ_NOTNULL(vfc, VFP_CTX_MAGIC);\n\n\tassert(bo->fetch_objcore->boc->state <= BOS_REQ_DONE);\n\n\tVSLb_ts_busyobj(bo, \"Retry\", W_TIM_real(wrk));\n\n\t/* VDI_Finish must have been called before */\n\tassert(bo->director_state == DIR_S_NULL);\n\n\t/* reset other bo attributes - See VBO_GetBusyObj */\n\tbo->storage = NULL;\n\tbo->storage_hint = NULL;\n\tbo->do_esi = 0;\n\tbo->do_stream = 1;\n\n\t/* reset fetch processors */\n\tVFP_Setup(vfc);\n\n\t// XXX: BereqEnd + BereqAcct ?\n\tVSL_ChgId(bo->vsl, \"bereq\", \"retry\", VXID_Get(wrk, VSL_BACKENDMARKER));\n\tVSLb_ts_busyobj(bo, \"Start\", bo->t_prev);\n\thttp_VSL_log(bo->bereq);\n\n\treturn (F_STP_STARTFETCH);\n}\n\n/*--------------------------------------------------------------------\n * Setup bereq from bereq0, run vcl_backend_fetch\n */\n\nstatic enum fetch_step\nvbf_stp_startfetch(struct worker *wrk, struct busyobj *bo)\n{\n\tint i;\n\tdouble now;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\n\tAZ(bo->storage);\n\tAZ(bo->storage_hint);\n\n\tbo->storage = STV_next();\n\n\tif (bo->retries > 0)\n\t\thttp_Unset(bo->bereq, \"\\012X-Varnish:\");\n\n\thttp_PrintfHeader(bo->bereq, \"X-Varnish: %u\", VXID(bo->vsl->wid));\n\n\tVCL_backend_fetch_method(bo->vcl, wrk, NULL, bo, NULL);\n\n\tbo->uncacheable = bo->do_pass;\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL)\n\t\treturn (F_STP_FAIL);\n\n\tassert (wrk->handling == VCL_RET_FETCH);\n\n\tHTTP_Setup(bo->beresp, bo->ws, bo->vsl, SLT_BerespMethod);\n\n\tassert(bo->fetch_objcore->boc->state <= BOS_REQ_DONE);\n\n\tAZ(bo->htc);\n\ti = VDI_GetHdr(wrk, bo);\n\n\tnow = W_TIM_real(wrk);\n\tVSLb_ts_busyobj(bo, \"Beresp\", now);\n\n\tif (i) {\n\t\tassert(bo->director_state == DIR_S_NULL);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\thttp_VSL_log(bo->beresp);\n\n\tif (!http_GetHdr(bo->beresp, H_Date, NULL)) {\n\t\t/*\n\t\t * RFC 2616 14.18 Date: The Date general-header field\n\t\t * represents the date and time at which the message was\n\t\t * originated, having the same semantics as orig-date in\n\t\t * RFC 822. ... A received message that does not have a\n\t\t * Date header field MUST be assigned one by the recipient\n\t\t * if the message will be cached by that recipient or\n\t\t * gatewayed via a protocol which requires a Date.\n\t\t *\n\t\t * If we didn't get a Date header, we assign one here.\n\t\t */\n\t\thttp_TimeHeader(bo->beresp, \"Date: \", now);\n\t}\n\n\t/*\n\t * These two headers can be spread over multiple actual headers\n\t * and we rely on their content outside of VCL, so collect them\n\t * into one line here.\n\t */\n\thttp_CollectHdr(bo->beresp, H_Cache_Control);\n\thttp_CollectHdr(bo->beresp, H_Vary);\n\n\t/*\n\t * Figure out how the fetch is supposed to happen, before the\n\t * headers are adultered by VCL\n\t */\n\tif (!strcasecmp(http_GetMethod(bo->bereq), \"head\")) {\n\t\t/*\n\t\t * A HEAD request can never have a body in the reply,\n\t\t * no matter what the headers might say.\n\t\t * [RFC7231 4.3.2 p25]\n\t\t */\n\t\twrk->stats->fetch_head++;\n\t\tbo->htc->body_status = BS_NONE;\n\t} else if (http_GetStatus(bo->beresp) <= 199) {\n\t\t/*\n\t\t * 1xx responses never have a body.\n\t\t * [RFC7230 3.3.2 p31]\n\t\t * ... but we should never see them.\n\t\t */\n\t\twrk->stats->fetch_1xx++;\n\t\tbo->htc->body_status = BS_ERROR;\n\t} else if (http_IsStatus(bo->beresp, 204)) {\n\t\t/*\n\t\t * 204 is \"No Content\", obviously don't expect a body.\n\t\t * [RFC7230 3.3.1 p29 and 3.3.2 p31]\n\t\t */\n\t\twrk->stats->fetch_204++;\n\t\tif ((http_GetHdr(bo->beresp, H_Content_Length, NULL) &&\n\t\t    bo->htc->content_length != 0) ||\n\t\t    http_GetHdr(bo->beresp, H_Transfer_Encoding, NULL))\n\t\t\tbo->htc->body_status = BS_ERROR;\n\t\telse\n\t\t\tbo->htc->body_status = BS_NONE;\n\t} else if (http_IsStatus(bo->beresp, 304)) {\n\t\t/*\n\t\t * 304 is \"Not Modified\" it has no body.\n\t\t * [RFC7230 3.3 p28]\n\t\t */\n\t\twrk->stats->fetch_304++;\n\t\tbo->htc->body_status = BS_NONE;\n\t} else if (bo->htc->body_status == BS_CHUNKED) {\n\t\twrk->stats->fetch_chunked++;\n\t} else if (bo->htc->body_status == BS_LENGTH) {\n\t\tassert(bo->htc->content_length > 0);\n\t\twrk->stats->fetch_length++;\n\t} else if (bo->htc->body_status == BS_EOF) {\n\t\twrk->stats->fetch_eof++;\n\t} else if (bo->htc->body_status == BS_ERROR) {\n\t\twrk->stats->fetch_bad++;\n\t} else if (bo->htc->body_status == BS_NONE) {\n\t\twrk->stats->fetch_none++;\n\t} else {\n\t\tWRONG(\"wrong bodystatus\");\n\t}\n\n\tif (bo->htc->body_status == BS_ERROR) {\n\t\tbo->htc->doclose = SC_RX_BODY;\n\t\tVDI_Finish(bo->wrk, bo);\n\t\tVSLb(bo->vsl, SLT_Error, \"Body cannot be fetched\");\n\t\tassert(bo->director_state == DIR_S_NULL);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tif (bo->fetch_objcore->flags & OC_F_PRIVATE) {\n\t\t/* private objects have negative TTL */\n\t\tbo->fetch_objcore->t_origin = now;\n\t\tbo->fetch_objcore->ttl = -1.;\n\t\tbo->fetch_objcore->grace = 0;\n\t\tbo->fetch_objcore->keep = 0;\n\t} else {\n\t\t/* What does RFC2616 think about TTL ? */\n\t\tRFC2616_Ttl(bo, now,\n\t\t    &bo->fetch_objcore->t_origin,\n\t\t    &bo->fetch_objcore->ttl,\n\t\t    &bo->fetch_objcore->grace,\n\t\t    &bo->fetch_objcore->keep\n\t\t    );\n\t}\n\n\tAZ(bo->do_esi);\n\tAZ(bo->was_304);\n\n\tif (http_IsStatus(bo->beresp, 304)) {\n\t\tif (bo->stale_oc != NULL &&\n\t\t    ObjCheckFlag(bo->wrk, bo->stale_oc, OF_IMSCAND)) {\n\t\t\tif (ObjCheckFlag(bo->wrk, bo->stale_oc, OF_CHGGZIP)) {\n\t\t\t\t/*\n\t\t\t\t * If we changed the gzip status of the object\n\t\t\t\t * the stored Content_Encoding controls we\n\t\t\t\t * must weaken any new ETag we get.\n\t\t\t\t */\n\t\t\t\thttp_Unset(bo->beresp, H_Content_Encoding);\n\t\t\t\tRFC2616_Weaken_Etag(bo->beresp);\n\t\t\t}\n\t\t\thttp_Unset(bo->beresp, H_Content_Length);\n\t\t\tHTTP_Merge(bo->wrk, bo->stale_oc, bo->beresp);\n\t\t\tassert(http_IsStatus(bo->beresp, 200));\n\t\t\tbo->was_304 = 1;\n\t\t} else if (!bo->do_pass) {\n\t\t\t/*\n\t\t\t * Backend sent unallowed 304\n\t\t\t */\n\t\t\tVSLb(bo->vsl, SLT_Error,\n\t\t\t    \"304 response but not conditional fetch\");\n\t\t\tbo->htc->doclose = SC_RX_BAD;\n\t\t\tVDI_Finish(bo->wrk, bo);\n\t\t\treturn (F_STP_ERROR);\n\t\t}\n\t}\n\n\tbo->vfc->bo = bo;\n\tbo->vfc->oc = bo->fetch_objcore;\n\tbo->vfc->wrk = bo->wrk;\n\tbo->vfc->http = bo->beresp;\n\tbo->vfc->esi_req = bo->bereq;\n\n\tVCL_backend_response_method(bo->vcl, wrk, NULL, bo, NULL);\n\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL) {\n\t\tbo->htc->doclose = SC_RESP_CLOSE;\n\t\tVDI_Finish(bo->wrk, bo);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tif (wrk->handling == VCL_RET_RETRY) {\n\t\tif (bo->htc->body_status != BS_NONE)\n\t\t\tbo->htc->doclose = SC_RESP_CLOSE;\n\t\tif (bo->director_state != DIR_S_NULL)\n\t\t\tVDI_Finish(bo->wrk, bo);\n\n\t\tif (bo->retries++ < cache_param->max_retries)\n\t\t\treturn (F_STP_RETRY);\n\n\t\tVSLb(bo->vsl, SLT_VCL_Error,\n\t\t    \"Too many retries, delivering 503\");\n\t\tassert(bo->director_state == DIR_S_NULL);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tassert(bo->fetch_objcore->boc->state <= BOS_REQ_DONE);\n\tif (bo->fetch_objcore->boc->state != BOS_REQ_DONE) {\n\t\tbo->req = NULL;\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_REQ_DONE);\n\t}\n\n\tif (bo->do_esi)\n\t\tbo->do_stream = 0;\n\tif (wrk->handling == VCL_RET_PASS) {\n\t\tbo->fetch_objcore->flags |= OC_F_HFP;\n\t\tbo->uncacheable = 1;\n\t\twrk->handling = VCL_RET_DELIVER;\n\t}\n\tif (bo->do_pass || bo->uncacheable)\n\t\tbo->fetch_objcore->flags |= OC_F_PASS;\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\treturn (bo->was_304 ? F_STP_CONDFETCH : F_STP_FETCH);\n}\n\n/*--------------------------------------------------------------------\n */\n\nstatic enum fetch_step\nvbf_stp_fetchbody(struct worker *wrk, struct busyobj *bo)\n{\n\tssize_t l;\n\tuint8_t *ptr;\n\tenum vfp_status vfps = VFP_ERROR;\n\tssize_t est;\n\tstruct vfp_ctx *vfc;\n\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tvfc = bo->vfc;\n\tCHECK_OBJ_NOTNULL(vfc, VFP_CTX_MAGIC);\n\n\tAN(vfc->vfp_nxt);\n\n\test = bo->htc->content_length;\n\tif (est < 0)\n\t\test = 0;\n\n\tdo {\n\t\tif (vfc->oc->flags & OC_F_ABANDON) {\n\t\t\t/*\n\t\t\t * A pass object and delivery was terminated\n\t\t\t * We don't fail the fetch, in order for hit-for-pass\n\t\t\t * objects to be created.\n\t\t\t */\n\t\t\tAN(vfc->oc->flags & OC_F_PASS);\n\t\t\tVSLb(wrk->vsl, SLT_FetchError,\n\t\t\t    \"Pass delivery abandoned\");\n\t\t\tbo->htc->doclose = SC_RX_BODY;\n\t\t\tbreak;\n\t\t}\n\t\tAZ(vfc->failed);\n\t\tl = est;\n\t\tassert(l >= 0);\n\t\tif (VFP_GetStorage(vfc, &l, &ptr) != VFP_OK) {\n\t\t\tbo->htc->doclose = SC_RX_BODY;\n\t\t\tbreak;\n\t\t}\n\n\t\tAZ(vfc->failed);\n\t\tvfps = VFP_Suck(vfc, ptr, &l);\n\t\tif (l > 0 && vfps != VFP_ERROR) {\n\t\t\tbo->acct.beresp_bodybytes += l;\n\t\t\tVFP_Extend(vfc, l);\n\t\t\tif (est >= l)\n\t\t\t\test -= l;\n\t\t\telse\n\t\t\t\test = 0;\n\t\t}\n\t} while (vfps == VFP_OK);\n\n\tif (vfc->failed) {\n\t\t(void)VFP_Error(vfc, \"Fetch pipeline failed to process\");\n\t\tbo->htc->doclose = SC_RX_BODY;\n\t\tVFP_Close(vfc);\n\t\tVDI_Finish(wrk, bo);\n\t\tif (!bo->do_stream) {\n\t\t\tassert(bo->fetch_objcore->boc->state < BOS_STREAM);\n\t\t\t// XXX: doclose = ?\n\t\t\treturn (F_STP_ERROR);\n\t\t} else {\n\t\t\twrk->stats->fetch_failed++;\n\t\t\treturn (F_STP_FAIL);\n\t\t}\n\t}\n\n\tObjTrimStore(wrk, vfc->oc);\n\treturn (F_STP_FETCHEND);\n}\n\n/*--------------------------------------------------------------------\n */\n\n#define vbf_vfp_push(bo, vfp, top)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (VFP_Push((bo)->vfc, (vfp), (top)) == NULL) {\t\\\n\t\t\tassert (WS_Overflowed((bo)->vfc->http->ws));\t\\\n\t\t\t(void)VFP_Error((bo)->vfc,\t\t\t\\\n\t\t\t    \"workspace_backend overflow\");\t\t\\\n\t\t\t(bo)->htc->doclose = SC_OVERLOAD;\t\t\\\n\t\t\tVDI_Finish((bo)->wrk, bo);\t\t\t\\\n\t\t\treturn (F_STP_ERROR);\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic enum fetch_step\nvbf_stp_fetch(struct worker *wrk, struct busyobj *bo)\n{\n\tconst char *p;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\t/*\n\t * The VCL variables beresp.do_g[un]zip tells us how we want the\n\t * object processed before it is stored.\n\t *\n\t * The backend Content-Encoding header tells us what we are going\n\t * to receive, which we classify in the following three classes:\n\t *\n\t *\t\"Content-Encoding: gzip\"\t--> object is gzip'ed.\n\t *\tno Content-Encoding\t\t--> object is not gzip'ed.\n\t *\tanything else\t\t\t--> do nothing wrt gzip\n\t *\n\t */\n\n\t/* We do nothing unless the param is set */\n\tif (!cache_param->http_gzip_support)\n\t\tbo->do_gzip = bo->do_gunzip = 0;\n\n\tif (bo->htc->content_length == 0)\n\t\thttp_Unset(bo->beresp, H_Content_Encoding);\n\n\tif (bo->htc->body_status != BS_NONE) {\n\t\tbo->is_gzip =\n\t\t    http_HdrIs(bo->beresp, H_Content_Encoding, \"gzip\");\n\t\tbo->is_gunzip =\n\t\t    !http_GetHdr(bo->beresp, H_Content_Encoding, NULL);\n\t\tassert(bo->is_gzip == 0 || bo->is_gunzip == 0);\n\t}\n\n\t/* We won't gunzip unless it is non-empty and gzip'ed */\n\tif (bo->htc->body_status == BS_NONE ||\n\t    bo->htc->content_length == 0 ||\n\t    (bo->do_gunzip && !bo->is_gzip))\n\t\tbo->do_gunzip = 0;\n\n\t/* We wont gzip unless it is non-empty and ungzip'ed */\n\tif (bo->htc->body_status == BS_NONE ||\n\t    bo->htc->content_length == 0 ||\n\t    (bo->do_gzip && !bo->is_gunzip))\n\t\tbo->do_gzip = 0;\n\n\t/* But we can't do both at the same time */\n\tassert(bo->do_gzip == 0 || bo->do_gunzip == 0);\n\n\tif (bo->do_gunzip || (bo->is_gzip && bo->do_esi))\n\t\tvbf_vfp_push(bo, &vfp_gunzip, 1);\n\n\tif (bo->htc->content_length != 0) {\n\t\tif (bo->do_esi && bo->do_gzip) {\n\t\t\tvbf_vfp_push(bo, &vfp_esi_gzip, 1);\n\t\t} else if (bo->do_esi && bo->is_gzip && !bo->do_gunzip) {\n\t\t\tvbf_vfp_push(bo, &vfp_esi_gzip, 1);\n\t\t} else if (bo->do_esi) {\n\t\t\tvbf_vfp_push(bo, &vfp_esi, 1);\n\t\t} else if (bo->do_gzip) {\n\t\t\tvbf_vfp_push(bo, &vfp_gzip, 1);\n\t\t} else if (bo->is_gzip && !bo->do_gunzip) {\n\t\t\tvbf_vfp_push(bo, &vfp_testgunzip, 1);\n\t\t}\n\t}\n\n\tif (bo->fetch_objcore->flags & OC_F_PRIVATE)\n\t\tAN(bo->uncacheable);\n\n\t/* No reason to try streaming a non-existing body */\n\tif (bo->htc->body_status == BS_NONE)\n\t\tbo->do_stream = 0;\n\n\tbo->fetch_objcore->boc->len_so_far = 0;\n\n\tif (VFP_Open(bo->vfc)) {\n\t\t(void)VFP_Error(bo->vfc, \"Fetch pipeline failed to open\");\n\t\tbo->htc->doclose = SC_RX_BODY;\n\t\tVDI_Finish(bo->wrk, bo);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tif (vbf_beresp2obj(bo)) {\n\t\t(void)VFP_Error(bo->vfc, \"Could not get storage\");\n\t\tbo->htc->doclose = SC_RX_BODY;\n\t\tVFP_Close(bo->vfc);\n\t\tVDI_Finish(bo->wrk, bo);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tif (bo->do_esi)\n\t\tObjSetFlag(bo->wrk, bo->fetch_objcore, OF_ESIPROC, 1);\n\n\tif (bo->do_gzip || (bo->is_gzip && !bo->do_gunzip))\n\t\tObjSetFlag(bo->wrk, bo->fetch_objcore, OF_GZIPED, 1);\n\n\tif (bo->do_gzip || bo->do_gunzip)\n\t\tObjSetFlag(bo->wrk, bo->fetch_objcore, OF_CHGGZIP, 1);\n\n\tif (!(bo->fetch_objcore->flags & OC_F_PASS) &&\n\t    http_IsStatus(bo->beresp, 200) && (\n\t      http_GetHdr(bo->beresp, H_Last_Modified, &p) ||\n\t      http_GetHdr(bo->beresp, H_ETag, &p)))\n\t\tObjSetFlag(bo->wrk, bo->fetch_objcore, OF_IMSCAND, 1);\n\n\tif (bo->htc->body_status != BS_NONE &&\n\t    VDI_GetBody(bo->wrk, bo) != 0) {\n\t\t(void)VFP_Error(bo->vfc,\n\t\t    \"GetBody failed - workspace_backend overflow?\");\n\t\tVFP_Close(bo->vfc);\n\t\tbo->htc->doclose = SC_OVERLOAD;\n\t\tVDI_Finish(bo->wrk, bo);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tassert(bo->fetch_objcore->boc->refcount >= 1);\n\n\tassert(bo->fetch_objcore->boc->state == BOS_REQ_DONE);\n\n\tif (bo->do_stream) {\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_PREP_STREAM);\n\t\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_STREAM);\n\t}\n\n\tVSLb(bo->vsl, SLT_Fetch_Body, \"%u %s %s\",\n\t    bo->htc->body_status, body_status_2str(bo->htc->body_status),\n\t    bo->do_stream ? \"stream\" : \"-\");\n\n\tif (bo->htc->body_status != BS_NONE) {\n\t\tassert(bo->htc->body_status != BS_ERROR);\n\t\treturn (F_STP_FETCHBODY);\n\t}\n\tAZ(bo->vfc->failed);\n\treturn (F_STP_FETCHEND);\n}\n\nstatic enum fetch_step\nvbf_stp_fetchend(struct worker *wrk, struct busyobj *bo)\n{\n\n\tAZ(bo->vfc->failed);\n\tVFP_Close(bo->vfc);\n\n\tAZ(ObjSetU64(wrk, bo->fetch_objcore, OA_LEN,\n\t    bo->fetch_objcore->boc->len_so_far));\n\n\tif (bo->do_stream)\n\t\tassert(bo->fetch_objcore->boc->state == BOS_STREAM);\n\telse {\n\t\tassert(bo->fetch_objcore->boc->state == BOS_REQ_DONE);\n\t\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\t}\n\n\t/* Recycle the backend connection before setting BOS_FINISHED to\n\t   give predictable backend reuse behavior for varnishtest */\n\tVDI_Finish(bo->wrk, bo);\n\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FINISHED);\n\tVSLb_ts_busyobj(bo, \"BerespBody\", W_TIM_real(wrk));\n\tif (bo->stale_oc != NULL)\n\t\tHSH_Kill(bo->stale_oc);\n\treturn (F_STP_DONE);\n}\n\n/*--------------------------------------------------------------------\n */\n\nstatic int\nvbf_objiterator(void *priv, int flush, const void *ptr, ssize_t len)\n{\n\tstruct busyobj *bo;\n\tssize_t l;\n\tconst uint8_t *ps = ptr;\n\tuint8_t *pd;\n\n\t(void)flush;\n\tCAST_OBJ_NOTNULL(bo, priv, BUSYOBJ_MAGIC);\n\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (VFP_GetStorage(bo->vfc, &l, &pd) != VFP_OK)\n\t\t\treturn (1);\n\t\tif (len < l)\n\t\t\tl = len;\n\t\tmemcpy(pd, ps, l);\n\t\tVFP_Extend(bo->vfc, l);\n\t\tps += l;\n\t\tlen -= l;\n\t}\n\treturn (0);\n}\n\nstatic enum fetch_step\nvbf_stp_condfetch(struct worker *wrk, struct busyobj *bo)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\n\tAZ(vbf_beresp2obj(bo));\n\n\tif (ObjHasAttr(bo->wrk, bo->stale_oc, OA_ESIDATA))\n\t\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc,\n\t\t    OA_ESIDATA));\n\n\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc, OA_FLAGS));\n\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc, OA_GZIPBITS));\n\n\tif (bo->do_stream) {\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_PREP_STREAM);\n\t\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_STREAM);\n\t}\n\n\tif (ObjIterate(wrk, bo->stale_oc, bo, vbf_objiterator, 0))\n\t\t(void)VFP_Error(bo->vfc, \"Template object failed\");\n\n\tif (bo->stale_oc->flags & OC_F_FAILED)\n\t\t(void)VFP_Error(bo->vfc, \"Template object failed\");\n\tif (bo->vfc->failed) {\n\t\tVDI_Finish(bo->wrk, bo);\n\t\twrk->stats->fetch_failed++;\n\t\treturn (F_STP_FAIL);\n\t}\n\treturn (F_STP_FETCHEND);\n}\n\n/*--------------------------------------------------------------------\n * Create synth object\n */\n\nstatic enum fetch_step\nvbf_stp_error(struct worker *wrk, struct busyobj *bo)\n{\n\tssize_t l, ll, o;\n\tdouble now;\n\tuint8_t *ptr;\n\tstruct vsb *synth_body;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\tAN(bo->fetch_objcore->flags & OC_F_BUSY);\n\tassert(bo->director_state == DIR_S_NULL);\n\n\twrk->stats->fetch_failed++;\n\n\tnow = W_TIM_real(wrk);\n\tVSLb_ts_busyobj(bo, \"Error\", now);\n\n\tif (bo->fetch_objcore->stobj->stevedore != NULL)\n\t\tObjFreeObj(bo->wrk, bo->fetch_objcore);\n\n\t// XXX: reset all beresp flags ?\n\n\tHTTP_Setup(bo->beresp, bo->ws, bo->vsl, SLT_BerespMethod);\n\thttp_PutResponse(bo->beresp, \"HTTP/1.1\", 503, \"Backend fetch failed\");\n\thttp_TimeHeader(bo->beresp, \"Date: \", now);\n\thttp_SetHeader(bo->beresp, \"Server: Varnish\");\n\n\tbo->fetch_objcore->t_origin = now;\n\tif (!VTAILQ_EMPTY(&bo->fetch_objcore->objhead->waitinglist)) {\n\t\t/*\n\t\t * If there is a waitinglist, it means that there is no\n\t\t * grace-able object, so cache the error return for a\n\t\t * short time, so the waiting list can drain, rather than\n\t\t * each objcore on the waiting list sequentially attempt\n\t\t * to fetch from the backend.\n\t\t */\n\t\tbo->fetch_objcore->ttl = 1;\n\t\tbo->fetch_objcore->grace = 5;\n\t\tbo->fetch_objcore->keep = 5;\n\t} else {\n\t\tbo->fetch_objcore->ttl = 0;\n\t\tbo->fetch_objcore->grace = 0;\n\t\tbo->fetch_objcore->keep = 0;\n\t}\n\n\tsynth_body = VSB_new_auto();\n\tAN(synth_body);\n\n\tVCL_backend_error_method(bo->vcl, wrk, NULL, bo, synth_body);\n\n\tAZ(VSB_finish(synth_body));\n\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL) {\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tif (wrk->handling == VCL_RET_RETRY) {\n\t\tVSB_destroy(&synth_body);\n\t\tif (bo->retries++ < cache_param->max_retries)\n\t\t\treturn (F_STP_RETRY);\n\t\tVSLb(bo->vsl, SLT_VCL_Error, \"Too many retries, failing\");\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\tbo->vfc->bo = bo;\n\tbo->vfc->wrk = bo->wrk;\n\tbo->vfc->oc = bo->fetch_objcore;\n\tbo->vfc->http = bo->beresp;\n\tbo->vfc->esi_req = bo->bereq;\n\n\tif (vbf_beresp2obj(bo)) {\n\t\t(void)VFP_Error(bo->vfc, \"Could not get storage\");\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tll = VSB_len(synth_body);\n\to = 0;\n\twhile (ll > 0) {\n\t\tl = ll;\n\t\tif (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK)\n\t\t\tbreak;\n\t\tmemcpy(ptr, VSB_data(synth_body) + o, l);\n\t\tVFP_Extend(bo->vfc, l);\n\t\tll -= l;\n\t\to += l;\n\t}\n\tAZ(ObjSetU64(wrk, bo->fetch_objcore, OA_LEN, o));\n\tVSB_destroy(&synth_body);\n\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FINISHED);\n\treturn (F_STP_DONE);\n}\n\n/*--------------------------------------------------------------------\n */\n\nstatic enum fetch_step\nvbf_stp_fail(struct worker *wrk, const struct busyobj *bo)\n{\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\n\tassert(bo->fetch_objcore->boc->state < BOS_FINISHED);\n\tHSH_Fail(bo->fetch_objcore);\n\tif (!(bo->fetch_objcore->flags & OC_F_BUSY))\n\t\tHSH_Kill(bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FAILED);\n\treturn (F_STP_DONE);\n}\n\n/*--------------------------------------------------------------------\n */\n\nstatic enum fetch_step\nvbf_stp_done(void)\n{\n\tWRONG(\"Just plain wrong\");\n\tNEEDLESS(return(F_STP_DONE));\n}\n\nstatic void __match_proto__(task_func_t)\nvbf_fetch_thread(struct worker *wrk, void *priv)\n{\n\tstruct busyobj *bo;\n\tenum fetch_step stp;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCAST_OBJ_NOTNULL(bo, priv, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->req, REQ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\n\tTHR_SetBusyobj(bo);\n\tstp = F_STP_MKBEREQ;\n\tassert(isnan(bo->t_first));\n\tassert(isnan(bo->t_prev));\n\tVSLb_ts_busyobj(bo, \"Start\", W_TIM_real(wrk));\n\n\tbo->wrk = wrk;\n\twrk->vsl = bo->vsl;\n\n#if 0\n\tif (bo->stale_oc != NULL) {\n\t\tCHECK_OBJ_NOTNULL(bo->stale_oc, OBJCORE_MAGIC);\n\t\t/* We don't want the oc/stevedore ops in fetching thread */\n\t\tif (!ObjCheckFlag(wrk, bo->stale_oc, OF_IMSCAND))\n\t\t\t(void)HSH_DerefObjCore(wrk, &bo->stale_oc, 0);\n\t}\n#endif\n\n\twhile (stp != F_STP_DONE) {\n\t\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\t\tassert(bo->fetch_objcore->boc->refcount >= 1);\n\t\tswitch (stp) {\n#define FETCH_STEP(l, U, arg)\t\t\t\t\t\t\\\n\t\tcase F_STP_##U:\t\t\t\t\t\t\\\n\t\t\tstp = vbf_stp_##l arg;\t\t\t\t\\\n\t\t\tbreak;\n#include \"tbl/steps.h\"\n\t\tdefault:\n\t\t\tWRONG(\"Illegal fetch_step\");\n\t\t}\n\t}\n\n\tassert(bo->director_state == DIR_S_NULL);\n\n\thttp_Teardown(bo->bereq);\n\thttp_Teardown(bo->beresp);\n\n\tif (bo->fetch_objcore->boc->state == BOS_FINISHED) {\n\t\tAZ(bo->fetch_objcore->flags & OC_F_FAILED);\n\t\tVSLb(bo->vsl, SLT_Length, \"%ju\",\n\t\t    (uintmax_t)ObjGetLen(bo->wrk, bo->fetch_objcore));\n\t}\n\t// AZ(bo->fetch_objcore->boc);\t// XXX\n\n\tif (bo->stale_oc != NULL)\n\t\t(void)HSH_DerefObjCore(wrk, &bo->stale_oc, 0);\n\n\twrk->vsl = NULL;\n\tHSH_DerefBoc(wrk, bo->fetch_objcore);\n\tSES_Rel(bo->sp);\n\tVBO_ReleaseBusyObj(wrk, &bo);\n\tTHR_SetBusyobj(NULL);\n}\n\n/*--------------------------------------------------------------------\n */\n\nvoid\nVBF_Fetch(struct worker *wrk, struct req *req, struct objcore *oc,\n    struct objcore *oldoc, enum vbf_fetch_mode_e mode)\n{\n\tstruct boc *boc;\n\tstruct busyobj *bo;\n\tconst char *how;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(req, REQ_MAGIC);\n\tCHECK_OBJ_NOTNULL(oc, OBJCORE_MAGIC);\n\tAN(oc->flags & OC_F_BUSY);\n\tCHECK_OBJ_ORNULL(oldoc, OBJCORE_MAGIC);\n\n\tbo = VBO_GetBusyObj(wrk, req);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\n\tboc = HSH_RefBoc(oc);\n\tCHECK_OBJ_NOTNULL(boc, BOC_MAGIC);\n\n\tswitch (mode) {\n\tcase VBF_PASS:\n\t\thow = \"pass\";\n\t\tbo->do_pass = 1;\n\t\tbreak;\n\tcase VBF_NORMAL:\n\t\thow = \"fetch\";\n\t\tbreak;\n\tcase VBF_BACKGROUND:\n\t\thow = \"bgfetch\";\n\t\tbo->is_bgfetch = 1;\n\t\tbreak;\n\tdefault:\n\t\tWRONG(\"Wrong fetch mode\");\n\t}\n\n\tVSLb(bo->vsl, SLT_Begin, \"bereq %u %s\", VXID(req->vsl->wid), how);\n\tVSLb(req->vsl, SLT_Link, \"bereq %u %s\", VXID(bo->vsl->wid), how);\n\n\tTHR_SetBusyobj(bo);\n\n\tbo->sp = req->sp;\n\tSES_Ref(bo->sp);\n\n\tAN(bo->vcl);\n\n\toc->boc->vary = req->vary_b;\n\treq->vary_b = NULL;\n\n\tHSH_Ref(oc);\n\tAZ(bo->fetch_objcore);\n\tbo->fetch_objcore = oc;\n\n\tAZ(bo->stale_oc);\n\tif (oldoc != NULL) {\n\t\tassert(oldoc->refcnt > 0);\n\t\tHSH_Ref(oldoc);\n\t\tbo->stale_oc = oldoc;\n\t}\n\n\tAZ(bo->req);\n\tbo->req = req;\n\n\tbo->fetch_task.priv = bo;\n\tbo->fetch_task.func = vbf_fetch_thread;\n\n\tif (Pool_Task(wrk->pool, &bo->fetch_task, TASK_QUEUE_BO)) {\n\t\twrk->stats->fetch_no_thread++;\n\t\t(void)vbf_stp_fail(req->wrk, bo);\n\t\tif (bo->stale_oc != NULL)\n\t\t\t(void)HSH_DerefObjCore(wrk, &bo->stale_oc, 0);\n\t\tHSH_DerefBoc(wrk, oc);\n\t\tSES_Rel(bo->sp);\n\t\tVBO_ReleaseBusyObj(wrk, &bo);\n\t} else {\n\t\tbo = NULL; /* ref transferred to fetch thread */\n\t\tif (mode == VBF_BACKGROUND) {\n\t\t\tObjWaitState(oc, BOS_REQ_DONE);\n\t\t\t(void)VRB_Ignore(req);\n\t\t} else {\n\t\t\tObjWaitState(oc, BOS_STREAM);\n\t\t\tif (oc->boc->state == BOS_FAILED) {\n\t\t\t\tAN((oc->flags & OC_F_FAILED));\n\t\t\t} else {\n\t\t\t\tAZ(oc->flags & OC_F_BUSY);\n\t\t\t}\n\t\t}\n\t}\n\tAZ(bo);\n\tVSLb_ts_req(req, \"Fetch\", W_TIM_real(wrk));\n\tassert(oc->boc == boc);\n\tHSH_DerefBoc(wrk, oc);\n\tif (mode == VBF_BACKGROUND)\n\t\t(void)HSH_DerefObjCore(wrk, &oc, HSH_RUSH_POLICY);\n\tTHR_SetBusyobj(NULL);\n}\n"], "fixing_code": ["/*-\n * Copyright (c) 2006 Verdens Gang AS\n * Copyright (c) 2006-2015 Varnish Software AS\n * All rights reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#include \"cache.h\"\n#include \"cache_director.h\"\n#include \"cache_filter.h\"\n#include \"hash/hash_slinger.h\"\n#include \"storage/storage.h\"\n#include \"vcl.h\"\n#include \"vtim.h\"\n\n/*--------------------------------------------------------------------\n * Allocate an object, with fall-back to Transient.\n * XXX: This somewhat overlaps the stuff in stevedore.c\n * XXX: Should this be merged over there ?\n */\n\nstatic int\nvbf_allocobj(struct busyobj *bo, unsigned l)\n{\n\tstruct objcore *oc;\n\tconst struct stevedore *stv;\n\tdouble lifetime;\n\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\toc = bo->fetch_objcore;\n\tCHECK_OBJ_NOTNULL(oc, OBJCORE_MAGIC);\n\n\tlifetime = oc->ttl + oc->grace + oc->keep;\n\n\tif (bo->uncacheable || lifetime < cache_param->shortlived)\n\t\tstv = stv_transient;\n\telse\n\t\tstv = bo->storage;\n\n\tbo->storage = NULL;\n\tbo->storage_hint = NULL;\n\n\tif (stv == NULL)\n\t\treturn (0);\n\n\tif (STV_NewObject(bo->wrk, bo->fetch_objcore, stv, l))\n\t\treturn (1);\n\n\tif (stv == stv_transient)\n\t\treturn (0);\n\n\t/*\n\t * Try to salvage the transaction by allocating a shortlived object\n\t * on Transient storage.\n\t */\n\n\tif (oc->ttl > cache_param->shortlived)\n\t\toc->ttl = cache_param->shortlived;\n\toc->grace = 0.0;\n\toc->keep = 0.0;\n\treturn (STV_NewObject(bo->wrk, bo->fetch_objcore, stv_transient, l));\n}\n\n/*--------------------------------------------------------------------\n * Turn the beresp into a obj\n */\n\nstatic int\nvbf_beresp2obj(struct busyobj *bo)\n{\n\tunsigned l, l2;\n\tconst char *b;\n\tuint8_t *bp;\n\tstruct vsb *vary = NULL;\n\tint varyl = 0;\n\n\tl = 0;\n\n\t/* Create Vary instructions */\n\tif (!(bo->fetch_objcore->flags & OC_F_PRIVATE)) {\n\t\tvaryl = VRY_Create(bo, &vary);\n\t\tif (varyl > 0) {\n\t\t\tAN(vary);\n\t\t\tassert(varyl == VSB_len(vary));\n\t\t\tl += PRNDUP((intptr_t)varyl);\n\t\t} else if (varyl < 0) {\n\t\t\t/*\n\t\t\t * Vary parse error\n\t\t\t * Complain about it, and make this a pass.\n\t\t\t */\n\t\t\tVSLb(bo->vsl, SLT_Error,\n\t\t\t    \"Illegal 'Vary' header from backend, \"\n\t\t\t    \"making this a pass.\");\n\t\t\tbo->uncacheable = 1;\n\t\t\tAZ(vary);\n\t\t} else\n\t\t\t/* No vary */\n\t\t\tAZ(vary);\n\t}\n\n\tl2 = http_EstimateWS(bo->beresp,\n\t    bo->uncacheable ? HTTPH_A_PASS : HTTPH_A_INS);\n\tl += l2;\n\n\tif (bo->uncacheable)\n\t\tbo->fetch_objcore->flags |= OC_F_PASS;\n\n\tif (!vbf_allocobj(bo, l))\n\t\treturn (-1);\n\n\tif (vary != NULL) {\n\t\tAN(ObjSetAttr(bo->wrk, bo->fetch_objcore, OA_VARY, varyl,\n\t\t\tVSB_data(vary)));\n\t\tVSB_destroy(&vary);\n\t}\n\n\tAZ(ObjSetU32(bo->wrk, bo->fetch_objcore, OA_VXID, VXID(bo->vsl->wid)));\n\n\t/* for HTTP_Encode() VSLH call */\n\tbo->beresp->logtag = SLT_ObjMethod;\n\n\t/* Filter into object */\n\tbp = ObjSetAttr(bo->wrk, bo->fetch_objcore, OA_HEADERS, l2, NULL);\n\tAN(bp);\n\tHTTP_Encode(bo->beresp, bp, l2,\n\t    bo->uncacheable ? HTTPH_A_PASS : HTTPH_A_INS);\n\n\tif (http_GetHdr(bo->beresp, H_Last_Modified, &b))\n\t\tAZ(ObjSetDouble(bo->wrk, bo->fetch_objcore, OA_LASTMODIFIED,\n\t\t    VTIM_parse(b)));\n\telse\n\t\tAZ(ObjSetDouble(bo->wrk, bo->fetch_objcore, OA_LASTMODIFIED,\n\t\t    floor(bo->fetch_objcore->t_origin)));\n\n\treturn (0);\n}\n\n/*--------------------------------------------------------------------\n * Copy req->bereq and release req if not pass fetch\n */\n\nstatic enum fetch_step\nvbf_stp_mkbereq(struct worker *wrk, struct busyobj *bo)\n{\n\tconst char *q;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->req, REQ_MAGIC);\n\n\tassert(bo->fetch_objcore->boc->state == BOS_INVALID);\n\tAZ(bo->storage);\n\tAZ(bo->storage_hint);\n\n\tHTTP_Setup(bo->bereq0, bo->ws, bo->vsl, SLT_BereqMethod);\n\thttp_FilterReq(bo->bereq0, bo->req->http,\n\t    bo->do_pass ? HTTPH_R_PASS : HTTPH_R_FETCH);\n\n\tif (!bo->do_pass) {\n\t\thttp_ForceField(bo->bereq0, HTTP_HDR_METHOD, \"GET\");\n\t\thttp_ForceField(bo->bereq0, HTTP_HDR_PROTO, \"HTTP/1.1\");\n\t\tif (cache_param->http_gzip_support)\n\t\t\thttp_ForceHeader(bo->bereq0, H_Accept_Encoding, \"gzip\");\n\t} else {\n\t\tAZ(bo->stale_oc);\n\t\tif (bo->bereq0->protover > 11)\n\t\t\thttp_ForceField(bo->bereq0, HTTP_HDR_PROTO, \"HTTP/1.1\");\n\t}\n\thttp_CopyHome(bo->bereq0);\n\n\tif (bo->stale_oc != NULL &&\n\t    ObjCheckFlag(bo->wrk, bo->stale_oc, OF_IMSCAND) &&\n\t    (bo->stale_oc->boc != NULL || ObjGetLen(wrk, bo->stale_oc) != 0)) {\n\t\tAZ(bo->stale_oc->flags & OC_F_PASS);\n\t\tq = HTTP_GetHdrPack(bo->wrk, bo->stale_oc, H_Last_Modified);\n\t\tif (q != NULL)\n\t\t\thttp_PrintfHeader(bo->bereq0,\n\t\t\t    \"If-Modified-Since: %s\", q);\n\t\tq = HTTP_GetHdrPack(bo->wrk, bo->stale_oc, H_ETag);\n\t\tif (q != NULL)\n\t\t\thttp_PrintfHeader(bo->bereq0,\n\t\t\t    \"If-None-Match: %s\", q);\n\t}\n\n\tHTTP_Setup(bo->bereq, bo->ws, bo->vsl, SLT_BereqMethod);\n\tbo->ws_bo = WS_Snapshot(bo->ws);\n\tHTTP_Copy(bo->bereq, bo->bereq0);\n\n\tif (bo->req->req_body_status == REQ_BODY_NONE) {\n\t\tbo->req = NULL;\n\t\tObjSetState(bo->wrk, bo->fetch_objcore, BOS_REQ_DONE);\n\t}\n\treturn (F_STP_STARTFETCH);\n}\n\n/*--------------------------------------------------------------------\n * Start a new VSL transaction and try again\n * Prepare the busyobj and fetch processors\n */\n\nstatic enum fetch_step\nvbf_stp_retry(struct worker *wrk, struct busyobj *bo)\n{\n\tstruct vfp_ctx *vfc;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tvfc = bo->vfc;\n\tCHECK_OBJ_NOTNULL(vfc, VFP_CTX_MAGIC);\n\n\tassert(bo->fetch_objcore->boc->state <= BOS_REQ_DONE);\n\n\tVSLb_ts_busyobj(bo, \"Retry\", W_TIM_real(wrk));\n\n\t/* VDI_Finish must have been called before */\n\tassert(bo->director_state == DIR_S_NULL);\n\n\t/* reset other bo attributes - See VBO_GetBusyObj */\n\tbo->storage = NULL;\n\tbo->storage_hint = NULL;\n\tbo->do_esi = 0;\n\tbo->do_stream = 1;\n\n\t/* reset fetch processors */\n\tVFP_Setup(vfc);\n\n\t// XXX: BereqEnd + BereqAcct ?\n\tVSL_ChgId(bo->vsl, \"bereq\", \"retry\", VXID_Get(wrk, VSL_BACKENDMARKER));\n\tVSLb_ts_busyobj(bo, \"Start\", bo->t_prev);\n\thttp_VSL_log(bo->bereq);\n\n\treturn (F_STP_STARTFETCH);\n}\n\n/*--------------------------------------------------------------------\n * Setup bereq from bereq0, run vcl_backend_fetch\n */\n\nstatic enum fetch_step\nvbf_stp_startfetch(struct worker *wrk, struct busyobj *bo)\n{\n\tint i;\n\tdouble now;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\n\tAZ(bo->storage);\n\tAZ(bo->storage_hint);\n\n\tbo->storage = STV_next();\n\n\tif (bo->retries > 0)\n\t\thttp_Unset(bo->bereq, \"\\012X-Varnish:\");\n\n\thttp_PrintfHeader(bo->bereq, \"X-Varnish: %u\", VXID(bo->vsl->wid));\n\n\tVCL_backend_fetch_method(bo->vcl, wrk, NULL, bo, NULL);\n\n\tbo->uncacheable = bo->do_pass;\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL)\n\t\treturn (F_STP_FAIL);\n\n\tassert (wrk->handling == VCL_RET_FETCH);\n\n\tHTTP_Setup(bo->beresp, bo->ws, bo->vsl, SLT_BerespMethod);\n\n\tassert(bo->fetch_objcore->boc->state <= BOS_REQ_DONE);\n\n\tAZ(bo->htc);\n\ti = VDI_GetHdr(wrk, bo);\n\n\tnow = W_TIM_real(wrk);\n\tVSLb_ts_busyobj(bo, \"Beresp\", now);\n\n\tif (i) {\n\t\tassert(bo->director_state == DIR_S_NULL);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\thttp_VSL_log(bo->beresp);\n\n\tif (!http_GetHdr(bo->beresp, H_Date, NULL)) {\n\t\t/*\n\t\t * RFC 2616 14.18 Date: The Date general-header field\n\t\t * represents the date and time at which the message was\n\t\t * originated, having the same semantics as orig-date in\n\t\t * RFC 822. ... A received message that does not have a\n\t\t * Date header field MUST be assigned one by the recipient\n\t\t * if the message will be cached by that recipient or\n\t\t * gatewayed via a protocol which requires a Date.\n\t\t *\n\t\t * If we didn't get a Date header, we assign one here.\n\t\t */\n\t\thttp_TimeHeader(bo->beresp, \"Date: \", now);\n\t}\n\n\t/*\n\t * These two headers can be spread over multiple actual headers\n\t * and we rely on their content outside of VCL, so collect them\n\t * into one line here.\n\t */\n\thttp_CollectHdr(bo->beresp, H_Cache_Control);\n\thttp_CollectHdr(bo->beresp, H_Vary);\n\n\t/*\n\t * Figure out how the fetch is supposed to happen, before the\n\t * headers are adultered by VCL\n\t */\n\tif (!strcasecmp(http_GetMethod(bo->bereq), \"head\")) {\n\t\t/*\n\t\t * A HEAD request can never have a body in the reply,\n\t\t * no matter what the headers might say.\n\t\t * [RFC7231 4.3.2 p25]\n\t\t */\n\t\twrk->stats->fetch_head++;\n\t\tbo->htc->body_status = BS_NONE;\n\t} else if (http_GetStatus(bo->beresp) <= 199) {\n\t\t/*\n\t\t * 1xx responses never have a body.\n\t\t * [RFC7230 3.3.2 p31]\n\t\t * ... but we should never see them.\n\t\t */\n\t\twrk->stats->fetch_1xx++;\n\t\tbo->htc->body_status = BS_ERROR;\n\t} else if (http_IsStatus(bo->beresp, 204)) {\n\t\t/*\n\t\t * 204 is \"No Content\", obviously don't expect a body.\n\t\t * [RFC7230 3.3.1 p29 and 3.3.2 p31]\n\t\t */\n\t\twrk->stats->fetch_204++;\n\t\tif ((http_GetHdr(bo->beresp, H_Content_Length, NULL) &&\n\t\t    bo->htc->content_length != 0) ||\n\t\t    http_GetHdr(bo->beresp, H_Transfer_Encoding, NULL))\n\t\t\tbo->htc->body_status = BS_ERROR;\n\t\telse\n\t\t\tbo->htc->body_status = BS_NONE;\n\t} else if (http_IsStatus(bo->beresp, 304)) {\n\t\t/*\n\t\t * 304 is \"Not Modified\" it has no body.\n\t\t * [RFC7230 3.3 p28]\n\t\t */\n\t\twrk->stats->fetch_304++;\n\t\tbo->htc->body_status = BS_NONE;\n\t} else if (bo->htc->body_status == BS_CHUNKED) {\n\t\twrk->stats->fetch_chunked++;\n\t} else if (bo->htc->body_status == BS_LENGTH) {\n\t\tassert(bo->htc->content_length > 0);\n\t\twrk->stats->fetch_length++;\n\t} else if (bo->htc->body_status == BS_EOF) {\n\t\twrk->stats->fetch_eof++;\n\t} else if (bo->htc->body_status == BS_ERROR) {\n\t\twrk->stats->fetch_bad++;\n\t} else if (bo->htc->body_status == BS_NONE) {\n\t\twrk->stats->fetch_none++;\n\t} else {\n\t\tWRONG(\"wrong bodystatus\");\n\t}\n\n\tif (bo->htc->body_status == BS_ERROR) {\n\t\tbo->htc->doclose = SC_RX_BODY;\n\t\tVDI_Finish(bo->wrk, bo);\n\t\tVSLb(bo->vsl, SLT_Error, \"Body cannot be fetched\");\n\t\tassert(bo->director_state == DIR_S_NULL);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tif (bo->fetch_objcore->flags & OC_F_PRIVATE) {\n\t\t/* private objects have negative TTL */\n\t\tbo->fetch_objcore->t_origin = now;\n\t\tbo->fetch_objcore->ttl = -1.;\n\t\tbo->fetch_objcore->grace = 0;\n\t\tbo->fetch_objcore->keep = 0;\n\t} else {\n\t\t/* What does RFC2616 think about TTL ? */\n\t\tRFC2616_Ttl(bo, now,\n\t\t    &bo->fetch_objcore->t_origin,\n\t\t    &bo->fetch_objcore->ttl,\n\t\t    &bo->fetch_objcore->grace,\n\t\t    &bo->fetch_objcore->keep\n\t\t    );\n\t}\n\n\tAZ(bo->do_esi);\n\tAZ(bo->was_304);\n\n\tif (http_IsStatus(bo->beresp, 304)) {\n\t\tif (bo->stale_oc != NULL &&\n\t\t    ObjCheckFlag(bo->wrk, bo->stale_oc, OF_IMSCAND)) {\n\t\t\tif (ObjCheckFlag(bo->wrk, bo->stale_oc, OF_CHGGZIP)) {\n\t\t\t\t/*\n\t\t\t\t * If we changed the gzip status of the object\n\t\t\t\t * the stored Content_Encoding controls we\n\t\t\t\t * must weaken any new ETag we get.\n\t\t\t\t */\n\t\t\t\thttp_Unset(bo->beresp, H_Content_Encoding);\n\t\t\t\tRFC2616_Weaken_Etag(bo->beresp);\n\t\t\t}\n\t\t\thttp_Unset(bo->beresp, H_Content_Length);\n\t\t\tHTTP_Merge(bo->wrk, bo->stale_oc, bo->beresp);\n\t\t\tassert(http_IsStatus(bo->beresp, 200));\n\t\t\tbo->was_304 = 1;\n\t\t} else if (!bo->do_pass) {\n\t\t\t/*\n\t\t\t * Backend sent unallowed 304\n\t\t\t */\n\t\t\tVSLb(bo->vsl, SLT_Error,\n\t\t\t    \"304 response but not conditional fetch\");\n\t\t\tbo->htc->doclose = SC_RX_BAD;\n\t\t\tVDI_Finish(bo->wrk, bo);\n\t\t\treturn (F_STP_ERROR);\n\t\t}\n\t}\n\n\tbo->vfc->bo = bo;\n\tbo->vfc->oc = bo->fetch_objcore;\n\tbo->vfc->wrk = bo->wrk;\n\tbo->vfc->http = bo->beresp;\n\tbo->vfc->esi_req = bo->bereq;\n\n\tVCL_backend_response_method(bo->vcl, wrk, NULL, bo, NULL);\n\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL) {\n\t\tbo->htc->doclose = SC_RESP_CLOSE;\n\t\tVDI_Finish(bo->wrk, bo);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tif (wrk->handling == VCL_RET_RETRY) {\n\t\tif (bo->htc->body_status != BS_NONE)\n\t\t\tbo->htc->doclose = SC_RESP_CLOSE;\n\t\tif (bo->director_state != DIR_S_NULL)\n\t\t\tVDI_Finish(bo->wrk, bo);\n\n\t\tif (bo->retries++ < cache_param->max_retries)\n\t\t\treturn (F_STP_RETRY);\n\n\t\tVSLb(bo->vsl, SLT_VCL_Error,\n\t\t    \"Too many retries, delivering 503\");\n\t\tassert(bo->director_state == DIR_S_NULL);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tassert(bo->fetch_objcore->boc->state <= BOS_REQ_DONE);\n\tif (bo->fetch_objcore->boc->state != BOS_REQ_DONE) {\n\t\tbo->req = NULL;\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_REQ_DONE);\n\t}\n\n\tif (bo->do_esi)\n\t\tbo->do_stream = 0;\n\tif (wrk->handling == VCL_RET_PASS) {\n\t\tbo->fetch_objcore->flags |= OC_F_HFP;\n\t\tbo->uncacheable = 1;\n\t\twrk->handling = VCL_RET_DELIVER;\n\t}\n\tif (bo->do_pass || bo->uncacheable)\n\t\tbo->fetch_objcore->flags |= OC_F_PASS;\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\treturn (bo->was_304 ? F_STP_CONDFETCH : F_STP_FETCH);\n}\n\n/*--------------------------------------------------------------------\n */\n\nstatic enum fetch_step\nvbf_stp_fetchbody(struct worker *wrk, struct busyobj *bo)\n{\n\tssize_t l;\n\tuint8_t *ptr;\n\tenum vfp_status vfps = VFP_ERROR;\n\tssize_t est;\n\tstruct vfp_ctx *vfc;\n\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tvfc = bo->vfc;\n\tCHECK_OBJ_NOTNULL(vfc, VFP_CTX_MAGIC);\n\n\tAN(vfc->vfp_nxt);\n\n\test = bo->htc->content_length;\n\tif (est < 0)\n\t\test = 0;\n\n\tdo {\n\t\tif (vfc->oc->flags & OC_F_ABANDON) {\n\t\t\t/*\n\t\t\t * A pass object and delivery was terminated\n\t\t\t * We don't fail the fetch, in order for hit-for-pass\n\t\t\t * objects to be created.\n\t\t\t */\n\t\t\tAN(vfc->oc->flags & OC_F_PASS);\n\t\t\tVSLb(wrk->vsl, SLT_FetchError,\n\t\t\t    \"Pass delivery abandoned\");\n\t\t\tbo->htc->doclose = SC_RX_BODY;\n\t\t\tbreak;\n\t\t}\n\t\tAZ(vfc->failed);\n\t\tl = est;\n\t\tassert(l >= 0);\n\t\tif (VFP_GetStorage(vfc, &l, &ptr) != VFP_OK) {\n\t\t\tbo->htc->doclose = SC_RX_BODY;\n\t\t\tbreak;\n\t\t}\n\n\t\tAZ(vfc->failed);\n\t\tvfps = VFP_Suck(vfc, ptr, &l);\n\t\tif (l > 0 && vfps != VFP_ERROR) {\n\t\t\tbo->acct.beresp_bodybytes += l;\n\t\t\tVFP_Extend(vfc, l);\n\t\t\tif (est >= l)\n\t\t\t\test -= l;\n\t\t\telse\n\t\t\t\test = 0;\n\t\t}\n\t} while (vfps == VFP_OK);\n\n\tif (vfc->failed) {\n\t\t(void)VFP_Error(vfc, \"Fetch pipeline failed to process\");\n\t\tbo->htc->doclose = SC_RX_BODY;\n\t\tVFP_Close(vfc);\n\t\tVDI_Finish(wrk, bo);\n\t\tif (!bo->do_stream) {\n\t\t\tassert(bo->fetch_objcore->boc->state < BOS_STREAM);\n\t\t\t// XXX: doclose = ?\n\t\t\treturn (F_STP_ERROR);\n\t\t} else {\n\t\t\twrk->stats->fetch_failed++;\n\t\t\treturn (F_STP_FAIL);\n\t\t}\n\t}\n\n\tObjTrimStore(wrk, vfc->oc);\n\treturn (F_STP_FETCHEND);\n}\n\n/*--------------------------------------------------------------------\n */\n\n#define vbf_vfp_push(bo, vfp, top)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (VFP_Push((bo)->vfc, (vfp), (top)) == NULL) {\t\\\n\t\t\tassert (WS_Overflowed((bo)->vfc->http->ws));\t\\\n\t\t\t(void)VFP_Error((bo)->vfc,\t\t\t\\\n\t\t\t    \"workspace_backend overflow\");\t\t\\\n\t\t\t(bo)->htc->doclose = SC_OVERLOAD;\t\t\\\n\t\t\tVDI_Finish((bo)->wrk, bo);\t\t\t\\\n\t\t\treturn (F_STP_ERROR);\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic enum fetch_step\nvbf_stp_fetch(struct worker *wrk, struct busyobj *bo)\n{\n\tconst char *p;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\t/*\n\t * The VCL variables beresp.do_g[un]zip tells us how we want the\n\t * object processed before it is stored.\n\t *\n\t * The backend Content-Encoding header tells us what we are going\n\t * to receive, which we classify in the following three classes:\n\t *\n\t *\t\"Content-Encoding: gzip\"\t--> object is gzip'ed.\n\t *\tno Content-Encoding\t\t--> object is not gzip'ed.\n\t *\tanything else\t\t\t--> do nothing wrt gzip\n\t *\n\t */\n\n\t/* We do nothing unless the param is set */\n\tif (!cache_param->http_gzip_support)\n\t\tbo->do_gzip = bo->do_gunzip = 0;\n\n\tif (bo->htc->content_length == 0)\n\t\thttp_Unset(bo->beresp, H_Content_Encoding);\n\n\tif (bo->htc->body_status != BS_NONE) {\n\t\tbo->is_gzip =\n\t\t    http_HdrIs(bo->beresp, H_Content_Encoding, \"gzip\");\n\t\tbo->is_gunzip =\n\t\t    !http_GetHdr(bo->beresp, H_Content_Encoding, NULL);\n\t\tassert(bo->is_gzip == 0 || bo->is_gunzip == 0);\n\t}\n\n\t/* We won't gunzip unless it is non-empty and gzip'ed */\n\tif (bo->htc->body_status == BS_NONE ||\n\t    bo->htc->content_length == 0 ||\n\t    (bo->do_gunzip && !bo->is_gzip))\n\t\tbo->do_gunzip = 0;\n\n\t/* We wont gzip unless it is non-empty and ungzip'ed */\n\tif (bo->htc->body_status == BS_NONE ||\n\t    bo->htc->content_length == 0 ||\n\t    (bo->do_gzip && !bo->is_gunzip))\n\t\tbo->do_gzip = 0;\n\n\t/* But we can't do both at the same time */\n\tassert(bo->do_gzip == 0 || bo->do_gunzip == 0);\n\n\tif (bo->do_gunzip || (bo->is_gzip && bo->do_esi))\n\t\tvbf_vfp_push(bo, &vfp_gunzip, 1);\n\n\tif (bo->htc->content_length != 0) {\n\t\tif (bo->do_esi && bo->do_gzip) {\n\t\t\tvbf_vfp_push(bo, &vfp_esi_gzip, 1);\n\t\t} else if (bo->do_esi && bo->is_gzip && !bo->do_gunzip) {\n\t\t\tvbf_vfp_push(bo, &vfp_esi_gzip, 1);\n\t\t} else if (bo->do_esi) {\n\t\t\tvbf_vfp_push(bo, &vfp_esi, 1);\n\t\t} else if (bo->do_gzip) {\n\t\t\tvbf_vfp_push(bo, &vfp_gzip, 1);\n\t\t} else if (bo->is_gzip && !bo->do_gunzip) {\n\t\t\tvbf_vfp_push(bo, &vfp_testgunzip, 1);\n\t\t}\n\t}\n\n\tif (bo->fetch_objcore->flags & OC_F_PRIVATE)\n\t\tAN(bo->uncacheable);\n\n\t/* No reason to try streaming a non-existing body */\n\tif (bo->htc->body_status == BS_NONE)\n\t\tbo->do_stream = 0;\n\n\tbo->fetch_objcore->boc->len_so_far = 0;\n\n\tif (VFP_Open(bo->vfc)) {\n\t\t(void)VFP_Error(bo->vfc, \"Fetch pipeline failed to open\");\n\t\tbo->htc->doclose = SC_RX_BODY;\n\t\tVDI_Finish(bo->wrk, bo);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tif (vbf_beresp2obj(bo)) {\n\t\t(void)VFP_Error(bo->vfc, \"Could not get storage\");\n\t\tbo->htc->doclose = SC_RX_BODY;\n\t\tVFP_Close(bo->vfc);\n\t\tVDI_Finish(bo->wrk, bo);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tif (bo->do_esi)\n\t\tObjSetFlag(bo->wrk, bo->fetch_objcore, OF_ESIPROC, 1);\n\n\tif (bo->do_gzip || (bo->is_gzip && !bo->do_gunzip))\n\t\tObjSetFlag(bo->wrk, bo->fetch_objcore, OF_GZIPED, 1);\n\n\tif (bo->do_gzip || bo->do_gunzip)\n\t\tObjSetFlag(bo->wrk, bo->fetch_objcore, OF_CHGGZIP, 1);\n\n\tif (!(bo->fetch_objcore->flags & OC_F_PASS) &&\n\t    http_IsStatus(bo->beresp, 200) && (\n\t      http_GetHdr(bo->beresp, H_Last_Modified, &p) ||\n\t      http_GetHdr(bo->beresp, H_ETag, &p)))\n\t\tObjSetFlag(bo->wrk, bo->fetch_objcore, OF_IMSCAND, 1);\n\n\tif (bo->htc->body_status != BS_NONE &&\n\t    VDI_GetBody(bo->wrk, bo) != 0) {\n\t\t(void)VFP_Error(bo->vfc,\n\t\t    \"GetBody failed - workspace_backend overflow?\");\n\t\tVFP_Close(bo->vfc);\n\t\tbo->htc->doclose = SC_OVERLOAD;\n\t\tVDI_Finish(bo->wrk, bo);\n\t\treturn (F_STP_ERROR);\n\t}\n\n\tassert(bo->fetch_objcore->boc->refcount >= 1);\n\n\tassert(bo->fetch_objcore->boc->state == BOS_REQ_DONE);\n\n\tif (bo->do_stream) {\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_PREP_STREAM);\n\t\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_STREAM);\n\t}\n\n\tVSLb(bo->vsl, SLT_Fetch_Body, \"%u %s %s\",\n\t    bo->htc->body_status, body_status_2str(bo->htc->body_status),\n\t    bo->do_stream ? \"stream\" : \"-\");\n\n\tif (bo->htc->body_status != BS_NONE) {\n\t\tassert(bo->htc->body_status != BS_ERROR);\n\t\treturn (F_STP_FETCHBODY);\n\t}\n\tAZ(bo->vfc->failed);\n\treturn (F_STP_FETCHEND);\n}\n\nstatic enum fetch_step\nvbf_stp_fetchend(struct worker *wrk, struct busyobj *bo)\n{\n\n\tAZ(bo->vfc->failed);\n\tVFP_Close(bo->vfc);\n\n\tAZ(ObjSetU64(wrk, bo->fetch_objcore, OA_LEN,\n\t    bo->fetch_objcore->boc->len_so_far));\n\n\tif (bo->do_stream)\n\t\tassert(bo->fetch_objcore->boc->state == BOS_STREAM);\n\telse {\n\t\tassert(bo->fetch_objcore->boc->state == BOS_REQ_DONE);\n\t\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\t}\n\n\t/* Recycle the backend connection before setting BOS_FINISHED to\n\t   give predictable backend reuse behavior for varnishtest */\n\tVDI_Finish(bo->wrk, bo);\n\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FINISHED);\n\tVSLb_ts_busyobj(bo, \"BerespBody\", W_TIM_real(wrk));\n\tif (bo->stale_oc != NULL)\n\t\tHSH_Kill(bo->stale_oc);\n\treturn (F_STP_DONE);\n}\n\n/*--------------------------------------------------------------------\n */\n\nstatic int\nvbf_objiterator(void *priv, int flush, const void *ptr, ssize_t len)\n{\n\tstruct busyobj *bo;\n\tssize_t l;\n\tconst uint8_t *ps = ptr;\n\tuint8_t *pd;\n\n\t(void)flush;\n\tCAST_OBJ_NOTNULL(bo, priv, BUSYOBJ_MAGIC);\n\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (VFP_GetStorage(bo->vfc, &l, &pd) != VFP_OK)\n\t\t\treturn (1);\n\t\tif (len < l)\n\t\t\tl = len;\n\t\tmemcpy(pd, ps, l);\n\t\tVFP_Extend(bo->vfc, l);\n\t\tps += l;\n\t\tlen -= l;\n\t}\n\treturn (0);\n}\n\nstatic enum fetch_step\nvbf_stp_condfetch(struct worker *wrk, struct busyobj *bo)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\n\tAZ(vbf_beresp2obj(bo));\n\n\tif (ObjHasAttr(bo->wrk, bo->stale_oc, OA_ESIDATA))\n\t\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc,\n\t\t    OA_ESIDATA));\n\n\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc, OA_FLAGS));\n\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc, OA_GZIPBITS));\n\n\tif (bo->do_stream) {\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_PREP_STREAM);\n\t\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_STREAM);\n\t}\n\n\tif (ObjIterate(wrk, bo->stale_oc, bo, vbf_objiterator, 0))\n\t\t(void)VFP_Error(bo->vfc, \"Template object failed\");\n\n\tif (bo->stale_oc->flags & OC_F_FAILED)\n\t\t(void)VFP_Error(bo->vfc, \"Template object failed\");\n\tif (bo->vfc->failed) {\n\t\tVDI_Finish(bo->wrk, bo);\n\t\twrk->stats->fetch_failed++;\n\t\treturn (F_STP_FAIL);\n\t}\n\treturn (F_STP_FETCHEND);\n}\n\n/*--------------------------------------------------------------------\n * Create synth object\n */\n\nstatic enum fetch_step\nvbf_stp_error(struct worker *wrk, struct busyobj *bo)\n{\n\tssize_t l, ll, o;\n\tdouble now;\n\tuint8_t *ptr;\n\tstruct vsb *synth_body;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\tAN(bo->fetch_objcore->flags & OC_F_BUSY);\n\tassert(bo->director_state == DIR_S_NULL);\n\n\twrk->stats->fetch_failed++;\n\n\tnow = W_TIM_real(wrk);\n\tVSLb_ts_busyobj(bo, \"Error\", now);\n\n\tif (bo->fetch_objcore->stobj->stevedore != NULL)\n\t\tObjFreeObj(bo->wrk, bo->fetch_objcore);\n\n\t// XXX: reset all beresp flags ?\n\n\tHTTP_Setup(bo->beresp, bo->ws, bo->vsl, SLT_BerespMethod);\n\thttp_PutResponse(bo->beresp, \"HTTP/1.1\", 503, \"Backend fetch failed\");\n\thttp_TimeHeader(bo->beresp, \"Date: \", now);\n\thttp_SetHeader(bo->beresp, \"Server: Varnish\");\n\n\tbo->fetch_objcore->t_origin = now;\n\tif (!VTAILQ_EMPTY(&bo->fetch_objcore->objhead->waitinglist)) {\n\t\t/*\n\t\t * If there is a waitinglist, it means that there is no\n\t\t * grace-able object, so cache the error return for a\n\t\t * short time, so the waiting list can drain, rather than\n\t\t * each objcore on the waiting list sequentially attempt\n\t\t * to fetch from the backend.\n\t\t */\n\t\tbo->fetch_objcore->ttl = 1;\n\t\tbo->fetch_objcore->grace = 5;\n\t\tbo->fetch_objcore->keep = 5;\n\t} else {\n\t\tbo->fetch_objcore->ttl = 0;\n\t\tbo->fetch_objcore->grace = 0;\n\t\tbo->fetch_objcore->keep = 0;\n\t}\n\n\tsynth_body = VSB_new_auto();\n\tAN(synth_body);\n\n\tVCL_backend_error_method(bo->vcl, wrk, NULL, bo, synth_body);\n\n\tAZ(VSB_finish(synth_body));\n\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL) {\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tif (wrk->handling == VCL_RET_RETRY) {\n\t\tVSB_destroy(&synth_body);\n\t\tif (bo->retries++ < cache_param->max_retries)\n\t\t\treturn (F_STP_RETRY);\n\t\tVSLb(bo->vsl, SLT_VCL_Error, \"Too many retries, failing\");\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\tbo->vfc->bo = bo;\n\tbo->vfc->wrk = bo->wrk;\n\tbo->vfc->oc = bo->fetch_objcore;\n\tbo->vfc->http = bo->beresp;\n\tbo->vfc->esi_req = bo->bereq;\n\n\tif (vbf_beresp2obj(bo)) {\n\t\t(void)VFP_Error(bo->vfc, \"Could not get storage\");\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tll = VSB_len(synth_body);\n\to = 0;\n\twhile (ll > 0) {\n\t\tl = ll;\n\t\tif (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK)\n\t\t\tbreak;\n\t\tif (l > ll)\n\t\t\tl = ll;\n\t\tmemcpy(ptr, VSB_data(synth_body) + o, l);\n\t\tVFP_Extend(bo->vfc, l);\n\t\tll -= l;\n\t\to += l;\n\t}\n\tAZ(ObjSetU64(wrk, bo->fetch_objcore, OA_LEN, o));\n\tVSB_destroy(&synth_body);\n\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FINISHED);\n\treturn (F_STP_DONE);\n}\n\n/*--------------------------------------------------------------------\n */\n\nstatic enum fetch_step\nvbf_stp_fail(struct worker *wrk, const struct busyobj *bo)\n{\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\n\tassert(bo->fetch_objcore->boc->state < BOS_FINISHED);\n\tHSH_Fail(bo->fetch_objcore);\n\tif (!(bo->fetch_objcore->flags & OC_F_BUSY))\n\t\tHSH_Kill(bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FAILED);\n\treturn (F_STP_DONE);\n}\n\n/*--------------------------------------------------------------------\n */\n\nstatic enum fetch_step\nvbf_stp_done(void)\n{\n\tWRONG(\"Just plain wrong\");\n\tNEEDLESS(return(F_STP_DONE));\n}\n\nstatic void __match_proto__(task_func_t)\nvbf_fetch_thread(struct worker *wrk, void *priv)\n{\n\tstruct busyobj *bo;\n\tenum fetch_step stp;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCAST_OBJ_NOTNULL(bo, priv, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->req, REQ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\n\tTHR_SetBusyobj(bo);\n\tstp = F_STP_MKBEREQ;\n\tassert(isnan(bo->t_first));\n\tassert(isnan(bo->t_prev));\n\tVSLb_ts_busyobj(bo, \"Start\", W_TIM_real(wrk));\n\n\tbo->wrk = wrk;\n\twrk->vsl = bo->vsl;\n\n#if 0\n\tif (bo->stale_oc != NULL) {\n\t\tCHECK_OBJ_NOTNULL(bo->stale_oc, OBJCORE_MAGIC);\n\t\t/* We don't want the oc/stevedore ops in fetching thread */\n\t\tif (!ObjCheckFlag(wrk, bo->stale_oc, OF_IMSCAND))\n\t\t\t(void)HSH_DerefObjCore(wrk, &bo->stale_oc, 0);\n\t}\n#endif\n\n\twhile (stp != F_STP_DONE) {\n\t\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\t\tassert(bo->fetch_objcore->boc->refcount >= 1);\n\t\tswitch (stp) {\n#define FETCH_STEP(l, U, arg)\t\t\t\t\t\t\\\n\t\tcase F_STP_##U:\t\t\t\t\t\t\\\n\t\t\tstp = vbf_stp_##l arg;\t\t\t\t\\\n\t\t\tbreak;\n#include \"tbl/steps.h\"\n\t\tdefault:\n\t\t\tWRONG(\"Illegal fetch_step\");\n\t\t}\n\t}\n\n\tassert(bo->director_state == DIR_S_NULL);\n\n\thttp_Teardown(bo->bereq);\n\thttp_Teardown(bo->beresp);\n\n\tif (bo->fetch_objcore->boc->state == BOS_FINISHED) {\n\t\tAZ(bo->fetch_objcore->flags & OC_F_FAILED);\n\t\tVSLb(bo->vsl, SLT_Length, \"%ju\",\n\t\t    (uintmax_t)ObjGetLen(bo->wrk, bo->fetch_objcore));\n\t}\n\t// AZ(bo->fetch_objcore->boc);\t// XXX\n\n\tif (bo->stale_oc != NULL)\n\t\t(void)HSH_DerefObjCore(wrk, &bo->stale_oc, 0);\n\n\twrk->vsl = NULL;\n\tHSH_DerefBoc(wrk, bo->fetch_objcore);\n\tSES_Rel(bo->sp);\n\tVBO_ReleaseBusyObj(wrk, &bo);\n\tTHR_SetBusyobj(NULL);\n}\n\n/*--------------------------------------------------------------------\n */\n\nvoid\nVBF_Fetch(struct worker *wrk, struct req *req, struct objcore *oc,\n    struct objcore *oldoc, enum vbf_fetch_mode_e mode)\n{\n\tstruct boc *boc;\n\tstruct busyobj *bo;\n\tconst char *how;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(req, REQ_MAGIC);\n\tCHECK_OBJ_NOTNULL(oc, OBJCORE_MAGIC);\n\tAN(oc->flags & OC_F_BUSY);\n\tCHECK_OBJ_ORNULL(oldoc, OBJCORE_MAGIC);\n\n\tbo = VBO_GetBusyObj(wrk, req);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\n\tboc = HSH_RefBoc(oc);\n\tCHECK_OBJ_NOTNULL(boc, BOC_MAGIC);\n\n\tswitch (mode) {\n\tcase VBF_PASS:\n\t\thow = \"pass\";\n\t\tbo->do_pass = 1;\n\t\tbreak;\n\tcase VBF_NORMAL:\n\t\thow = \"fetch\";\n\t\tbreak;\n\tcase VBF_BACKGROUND:\n\t\thow = \"bgfetch\";\n\t\tbo->is_bgfetch = 1;\n\t\tbreak;\n\tdefault:\n\t\tWRONG(\"Wrong fetch mode\");\n\t}\n\n\tVSLb(bo->vsl, SLT_Begin, \"bereq %u %s\", VXID(req->vsl->wid), how);\n\tVSLb(req->vsl, SLT_Link, \"bereq %u %s\", VXID(bo->vsl->wid), how);\n\n\tTHR_SetBusyobj(bo);\n\n\tbo->sp = req->sp;\n\tSES_Ref(bo->sp);\n\n\tAN(bo->vcl);\n\n\toc->boc->vary = req->vary_b;\n\treq->vary_b = NULL;\n\n\tHSH_Ref(oc);\n\tAZ(bo->fetch_objcore);\n\tbo->fetch_objcore = oc;\n\n\tAZ(bo->stale_oc);\n\tif (oldoc != NULL) {\n\t\tassert(oldoc->refcnt > 0);\n\t\tHSH_Ref(oldoc);\n\t\tbo->stale_oc = oldoc;\n\t}\n\n\tAZ(bo->req);\n\tbo->req = req;\n\n\tbo->fetch_task.priv = bo;\n\tbo->fetch_task.func = vbf_fetch_thread;\n\n\tif (Pool_Task(wrk->pool, &bo->fetch_task, TASK_QUEUE_BO)) {\n\t\twrk->stats->fetch_no_thread++;\n\t\t(void)vbf_stp_fail(req->wrk, bo);\n\t\tif (bo->stale_oc != NULL)\n\t\t\t(void)HSH_DerefObjCore(wrk, &bo->stale_oc, 0);\n\t\tHSH_DerefBoc(wrk, oc);\n\t\tSES_Rel(bo->sp);\n\t\tVBO_ReleaseBusyObj(wrk, &bo);\n\t} else {\n\t\tbo = NULL; /* ref transferred to fetch thread */\n\t\tif (mode == VBF_BACKGROUND) {\n\t\t\tObjWaitState(oc, BOS_REQ_DONE);\n\t\t\t(void)VRB_Ignore(req);\n\t\t} else {\n\t\t\tObjWaitState(oc, BOS_STREAM);\n\t\t\tif (oc->boc->state == BOS_FAILED) {\n\t\t\t\tAN((oc->flags & OC_F_FAILED));\n\t\t\t} else {\n\t\t\t\tAZ(oc->flags & OC_F_BUSY);\n\t\t\t}\n\t\t}\n\t}\n\tAZ(bo);\n\tVSLb_ts_req(req, \"Fetch\", W_TIM_real(wrk));\n\tassert(oc->boc == boc);\n\tHSH_DerefBoc(wrk, oc);\n\tif (mode == VBF_BACKGROUND)\n\t\t(void)HSH_DerefObjCore(wrk, &oc, HSH_RUSH_POLICY);\n\tTHR_SetBusyobj(NULL);\n}\n"], "filenames": ["bin/varnishd/cache/cache_fetch.c"], "buggy_code_start_loc": [901], "buggy_code_end_loc": [901], "fixing_code_start_loc": [902], "fixing_code_end_loc": [904], "type": "CWE-119", "message": "vbf_stp_error in bin/varnishd/cache/cache_fetch.c in Varnish HTTP Cache 4.1.x before 4.1.9 and 5.x before 5.2.1 allows remote attackers to obtain sensitive information from process memory because a VFP_GetStorage buffer is larger than intended in certain circumstances involving -sfile Stevedore transient objects.", "other": {"cve": {"id": "CVE-2017-8807", "sourceIdentifier": "security@debian.org", "published": "2017-11-16T02:29:05.660", "lastModified": "2022-08-02T16:29:08.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vbf_stp_error in bin/varnishd/cache/cache_fetch.c in Varnish HTTP Cache 4.1.x before 4.1.9 and 5.x before 5.2.1 allows remote attackers to obtain sensitive information from process memory because a VFP_GetStorage buffer is larger than intended in certain circumstances involving -sfile Stevedore transient objects."}, {"lang": "es", "value": "vbf_stp_error en bin/varnishd/cache/cache_fetch.c en Varnish HTTP Cache en versiones 4.1.x anteriores a la 4.1.9 y las versiones 5.x anteriores a la 5.2.1 permite que atacantes remotos obtengan informaci\u00f3n sensible de la memoria de procesos debido a que un b\u00fafer VFP_GetStorage es m\u00e1s grande de lo planeado en ciertas circunstancias relacionadas con objetos transitorios -sfile Stevedore."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:varnish-cache:varnish:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.9", "matchCriteriaId": "0870F626-489C-4652-9D6E-6914226A1ED4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:varnish_cache_project:varnish_cache:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.1", "matchCriteriaId": "4E9ADE7F-7963-4A1A-9C57-1880888D23EB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://varnish-cache.org/security/VSV00002.html", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/101886", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/881808", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/varnishcache/varnish-cache/commit/176f8a075a963ffbfa56f1c460c15f6a1a6af5a7", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/varnishcache/varnish-cache/pull/2429", "source": "security@debian.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4034", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/varnishcache/varnish-cache/commit/176f8a075a963ffbfa56f1c460c15f6a1a6af5a7"}}