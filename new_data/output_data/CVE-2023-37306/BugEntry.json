{"buggy_code": ["<?php\nApp::uses('AppController', 'Controller');\nApp::uses('Xml', 'Utility');\nApp::uses('AttachmentTool', 'Tools');\nApp::uses('JsonTool', 'Tools');\nApp::uses('SecurityAudit', 'Tools');\n\n/**\n * @property Server $Server\n */\nclass ServersController extends AppController\n{\n    public $components = array('RequestHandler');   // XXX ACL component\n\n    public $paginate = array(\n        'limit' => 60,\n        'recursive' => -1,\n        'contain' => array(\n            'User' => array(\n                'fields' => array('User.id', 'User.org_id', 'User.email'),\n            ),\n            'Organisation' => array(\n                'fields' => array('Organisation.name', 'Organisation.id'),\n            ),\n            'RemoteOrg' => array(\n                'fields' => array('RemoteOrg.name', 'RemoteOrg.id'),\n            ),\n        ),\n        'maxLimit' => 9999,\n        'order' => array(\n            'Server.priority' => 'ASC'\n        ),\n    );\n\n    public $uses = array('Server', 'Event');\n\n    public function beforeFilter()\n    {\n        $this->Auth->allow(['cspReport']); // cspReport must work without authentication\n\n        parent::beforeFilter();\n        $this->Security->unlockedActions[] = 'cspReport';\n        // permit reuse of CSRF tokens on some pages.\n        switch ($this->request->params['action']) {\n            case 'push':\n            case 'pull':\n            case 'getVersion':\n            case 'testConnection':\n                $this->Security->csrfUseOnce = false;\n        }\n    }\n\n    public function index()\n    {\n        // Do not fetch server authkey from DB\n        $fields = $this->Server->schema();\n        unset($fields['authkey']);\n        $fields = array_keys($fields);\n\n        $filters = $this->IndexFilter->harvestParameters(['search']);\n        $conditions = [];\n        if (!empty($filters['search'])) {\n            $strSearch = '%' . trim(strtolower($filters['search'])) . '%';\n            $conditions['OR'][]['LOWER(Server.name) LIKE'] = $strSearch;\n            $conditions['OR'][]['LOWER(Server.url) LIKE'] = $strSearch;\n        }\n\n        if ($this->_isRest()) {\n            $params = array(\n                'fields' => $fields,\n                'recursive' => -1,\n                'contain' => array(\n                    'User' => array(\n                        'fields' => array('User.id', 'User.org_id', 'User.email'),\n                    ),\n                    'Organisation' => array(\n                        'fields' => array('Organisation.id', 'Organisation.name', 'Organisation.uuid', 'Organisation.nationality', 'Organisation.sector', 'Organisation.type'),\n                    ),\n                    'RemoteOrg' => array(\n                        'fields' => array('RemoteOrg.id', 'RemoteOrg.name', 'RemoteOrg.uuid', 'RemoteOrg.nationality', 'RemoteOrg.sector', 'RemoteOrg.type'),\n                    ),\n                ),\n                'conditions' => $conditions,\n            );\n            $servers = $this->Server->find('all', $params);\n            $servers = $this->Server->attachServerCacheTimestamps($servers);\n            return $this->RestResponse->viewData($servers, $this->response->type());\n        } else {\n            $this->paginate['fields'] = $fields;\n            $this->paginate['conditions'] = $conditions;\n            $servers = $this->paginate();\n            $servers = $this->Server->attachServerCacheTimestamps($servers);\n            $this->set('servers', $servers);\n            $collection = array();\n            $collection['orgs'] = $this->Server->Organisation->find('list', array(\n                  'fields' => array('id', 'name'),\n            ));\n            $this->loadModel('Tag');\n            $collection['tags'] = $this->Tag->find('list', array(\n                  'fields' => array('id', 'name'),\n            ));\n            $this->set('collection', $collection);\n        }\n    }\n\n    public function previewIndex($id)\n    {\n        $urlparams = '';\n        $passedArgs = array();\n\n        $server = $this->Server->find('first', array('conditions' => array('Server.id' => $id), 'recursive' => -1));\n        if (empty($server)) {\n            throw new NotFoundException('Invalid server ID.');\n        }\n        $validFilters = $this->Server->validEventIndexFilters;\n        foreach ($validFilters as $k => $filter) {\n            if (isset($this->passedArgs[$filter])) {\n                $passedArgs[$filter] = $this->passedArgs[$filter];\n                if ($k != 0) {\n                    $urlparams .= '/';\n                }\n                $urlparams .= $filter . ':' . $this->passedArgs[$filter];\n            }\n        }\n        $combinedArgs = array_merge($this->passedArgs, $passedArgs);\n        if (!isset($combinedArgs['sort'])) {\n            $combinedArgs['sort'] = 'timestamp';\n            $combinedArgs['direction'] = 'desc';\n        }\n        if (empty($combinedArgs['page'])) {\n            $combinedArgs['page'] = 1;\n        }\n        if (empty($combinedArgs['limit'])) {\n            $combinedArgs['limit'] = 60;\n        }\n        try {\n            list($events, $total_count) = $this->Server->previewIndex($server, $this->Auth->user(), $combinedArgs);\n        } catch (Exception $e) {\n            if ($this->_isRest()) {\n                return $this->RestResponse->throwException(500, $e->getMessage());\n            } else {\n                $this->Flash->error(__('Download failed.') . ' ' . $e->getMessage());\n                $this->redirect(array('action' => 'index'));\n            }\n        }\n\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($events, $this->response->type());\n        }\n\n        $this->loadModel('Event');\n        $this->set('threatLevels', $this->Event->ThreatLevel->listThreatLevels());\n        App::uses('CustomPaginationTool', 'Tools');\n        $customPagination = new CustomPaginationTool();\n        $params = $customPagination->createPaginationRules($events, $this->passedArgs, $this->alias);\n        if (!empty($total_count)) {\n            $params['pageCount'] = ceil($total_count / $params['limit']);\n        }\n        $this->params->params['paging'] = array($this->modelClass => $params);\n        if (count($events) > 60) {\n            $customPagination->truncateByPagination($events, $params);\n        }\n        $this->set('events', $events);\n        $this->set('eventDescriptions', $this->Event->fieldDescriptions);\n        $this->set('analysisLevels', $this->Event->analysisLevels);\n        $this->set('distributionLevels', $this->Event->distributionLevels);\n\n        $shortDist = array(0 => 'Organisation', 1 => 'Community', 2 => 'Connected', 3 => 'All', 4 => ' sharing Group');\n        $this->set('shortDist', $shortDist);\n        $this->set('id', $id);\n        $this->set('urlparams', $urlparams);\n        $this->set('passedArgs', json_encode($passedArgs));\n        $this->set('passedArgsArray', $passedArgs);\n        $this->set('server', $server);\n    }\n\n    public function previewEvent($serverId, $eventId, $all = false)\n    {\n        $server = $this->Server->find('first', array(\n            'conditions' => array('Server.id' => $serverId),\n            'recursive' => -1,\n        ));\n        if (empty($server)) {\n            throw new NotFoundException('Invalid server ID.');\n        }\n        try {\n            $event = $this->Server->previewEvent($server, $eventId);\n        } catch (NotFoundException $e) {\n            throw new NotFoundException(__(\"Event '%s' not found.\", $eventId));\n        } catch (Exception $e) {\n            $this->Flash->error(__('Download failed. %s', $e->getMessage()));\n            $this->redirect(array('action' => 'previewIndex', $serverId));\n        }\n\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($event, $this->response->type());\n        }\n\n        $this->loadModel('Warninglist');\n        if (isset($event['Event']['Attribute'])) {\n            $this->Warninglist->attachWarninglistToAttributes($event['Event']['Attribute']);\n        }\n        if (isset($event['Event']['ShadowAttribute'])) {\n            $this->Warninglist->attachWarninglistToAttributes($event['Event']['ShadowAttribute']);\n        }\n\n        $this->loadModel('Event');\n        $params = $this->Event->rearrangeEventForView($event, $this->passedArgs, $all);\n        $this->__removeGalaxyClusterTags($event);\n        $this->params->params['paging'] = array('Server' => $params);\n        $this->set('event', $event);\n        $this->set('server', $server);\n        $dataForView = array(\n                'Attribute' => array('attrDescriptions' => 'fieldDescriptions', 'distributionDescriptions' => 'distributionDescriptions', 'distributionLevels' => 'distributionLevels'),\n                'Event' => array('eventDescriptions' => 'fieldDescriptions', 'analysisLevels' => 'analysisLevels'),\n                'Object' => array()\n        );\n        foreach ($dataForView as $m => $variables) {\n            if ($m === 'Event') {\n                $currentModel = $this->Event;\n            } elseif ($m === 'Attribute') {\n                $currentModel = $this->Event->Attribute;\n            } elseif ($m === 'Object') {\n                $currentModel = $this->Event->Object;\n            }\n            foreach ($variables as $alias => $variable) {\n                $this->set($alias, $currentModel->{$variable});\n            }\n        }\n        $this->set('threatLevels', $this->Event->ThreatLevel->listThreatLevels());\n        $this->set('title_for_layout', __('Remote event preview'));\n    }\n\n    private function __removeGalaxyClusterTags(array &$event)\n    {\n        $galaxyTagIds = [];\n        foreach ($event['Galaxy'] as $galaxy) {\n            foreach ($galaxy['GalaxyCluster'] as $galaxyCluster) {\n                $galaxyTagIds[$galaxyCluster['tag_id']] = true;\n            }\n        }\n\n        if (empty($galaxyTagIds)) {\n            return;\n        }\n\n        foreach ($event['Tag'] as $k => $eventTag) {\n            if (isset($galaxyTagIds[$eventTag['id']])) {\n                unset($event['Tag'][$k]);\n            }\n        }\n    }\n\n    public function compareServers()\n    {\n        list($servers, $overlap) = $this->Server->serverEventsOverlap();\n        $this->set('servers', $servers);\n        $this->set('overlap', $overlap);\n        $this->set('title_for_layout', __('Server overlap analysis matrix'));\n    }\n\n    public function filterEventIndex($id)\n    {\n        if (!$this->_isSiteAdmin()) {\n            throw new MethodNotAllowedException('You are not authorised to do that.');\n        }\n        $validFilters = $this->Server->validEventIndexFilters;\n        $validatedFilterString = '';\n        foreach ($this->passedArgs as $k => $v) {\n            if (in_array('' . $k, $validFilters)) {\n                if ($validatedFilterString != '') {\n                    $validatedFilterString .= '/';\n                }\n                $validatedFilterString .= $k . ':' . $v;\n            }\n        }\n        $this->set('id', $id);\n        $this->set('validFilters', $validFilters);\n        $this->set('filter', $validatedFilterString);\n    }\n\n    public function add()\n    {\n        if ($this->request->is('post')) {\n            if ($this->_isRest()) {\n                if (!isset($this->request->data['Server'])) {\n                    $this->request->data = array('Server' => $this->request->data);\n                }\n            }\n            if (!empty($this->request->data['Server']['json'])) {\n                $json = json_decode($this->request->data['Server']['json'], true);\n            } elseif ($this->_isRest()) {\n                if (empty($this->request->data['Server']['remote_org_id'])) {\n                    throw new MethodNotAllowedException('No remote org ID set. Please pass it as remote_org_id');\n                }\n            }\n            $fail = false;\n            if (empty(Configure::read('MISP.host_org_id'))) {\n                $this->request->data['Server']['internal'] = 0;\n            }\n            // test the filter fields\n            if (!empty($this->request->data['Server']['pull_rules']) && !JsonTool::isValid($this->request->data['Server']['pull_rules'])) {\n                $fail = true;\n                $error_msg = __('The pull filter rules must be in valid JSON format.');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'add', false, array('pull_rules' => $error_msg), $this->response->type());\n                } else {\n                    $this->Flash->error($error_msg);\n                }\n            }\n\n            if (!$fail && !empty($this->request->data['Server']['push_rules']) && !JsonTool::isValid($this->request->data['Server']['push_rules'])) {\n                $fail = true;\n                $error_msg = __('The push filter rules must be in valid JSON format.');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'add', false, array('push_rules' => $error_msg), $this->response->type());\n                } else {\n                    $this->Flash->error($error_msg);\n                }\n            }\n            if (!$fail) {\n                if ($this->_isRest()) {\n                    $defaultPushRules = json_encode([\"tags\" => [\"OR\" => [], \"NOT\" => []], \"orgs\" => [\"OR\" => [], \"NOT\" => []]]);\n                    $defaultPullRules = json_encode([\"tags\" => [\"OR\" => [], \"NOT\" => []], \"orgs\" => [\"OR\" => [], \"NOT\" => []], \"type_attributes\" => [\"NOT\" => []], \"type_objects\" => [\"NOT\" => []], \"url_params\" => \"\"]);\n                    $defaults = array(\n                        'push' => 0,\n                        'pull' => 0,\n                        'push_sightings' => 0,\n                        'push_galaxy_clusters' => 0,\n                        'pull_galaxy_clusters' => 0,\n                        'caching_enabled' => 0,\n                        'json' => '[]',\n                        'push_rules' => $defaultPushRules,\n                        'pull_rules' => $defaultPullRules,\n                        'self_signed' => 0,\n                        'remove_missing_tags' => 0\n                    );\n                    foreach ($defaults as $default => $dvalue) {\n                        if (!isset($this->request->data['Server'][$default])) {\n                            $this->request->data['Server'][$default] = $dvalue;\n                        }\n                    }\n                }\n                // force check userid and orgname to be from yourself\n                $this->request->data['Server']['org_id'] = $this->Auth->user('org_id');\n                if ($this->_isRest()) {\n                    if (empty($this->request->data['Server']['remote_org_id'])) {\n                        return $this->RestResponse->saveFailResponse('Servers', 'add', false, array('Organisation' => 'Remote Organisation\\'s id/uuid not given (remote_org_id)'), $this->response->type());\n                    }\n                    if (Validation::uuid($this->request->data['Server']['remote_org_id'])) {\n                        $orgCondition = array('uuid' => $this->request->data['Server']['remote_org_id']);\n                    } else {\n                        $orgCondition = array('id' => $this->request->data['Server']['remote_org_id']);\n                    }\n                    $existingOrgs = $this->Server->Organisation->find('first', array(\n                            'conditions' => $orgCondition,\n                            'recursive' => -1,\n                            'fields' => array('id', 'uuid')\n                    ));\n                    if (empty($existingOrgs)) {\n                        return $this->RestResponse->saveFailResponse('Servers', 'add', false, array('Organisation' => 'Invalid Remote Organisation'), $this->response->type());\n                    }\n                } else {\n                    if ($this->request->data['Server']['organisation_type'] < 2) {\n                        $this->request->data['Server']['remote_org_id'] = $json['id'];\n                    } else {\n                        $existingOrgs = $this->Server->Organisation->find('first', array(\n                                'conditions' => array('uuid' => $json['uuid']),\n                                'recursive' => -1,\n                                'fields' => array('id', 'uuid')\n                        ));\n                        if (!empty($existingOrgs)) {\n                            $fail = true;\n                            $this->Flash->error(__('That organisation could not be created as the uuid is in use already.'));\n                        }\n                        if (!$fail) {\n                            $this->Server->Organisation->create();\n                            $orgSave = $this->Server->Organisation->save(array(\n                                    'name' => $json['name'],\n                                    'uuid' => $json['uuid'],\n                                    'local' => 0,\n                                    'created_by' => $this->Auth->user('id')\n                            ));\n\n                            if (!$orgSave) {\n                                $this->Flash->error(__('Couldn\\'t save the new organisation, are you sure that the uuid is in the correct format? Also, make sure the organisation\\'s name doesn\\'t clash with an existing one.'));\n                                $fail = true;\n                                $this->request->data['Server']['external_name'] = $json['name'];\n                                $this->request->data['Server']['external_uuid'] = $json['uuid'];\n                            } else {\n                                $this->request->data['Server']['remote_org_id'] = $this->Server->Organisation->id;\n                                $this->request->data['Server']['organisation_type'] = 1;\n                            }\n                        }\n                    }\n                }\n                if (!$fail) {\n                    if (Configure::read('MISP.host_org_id') == 0 || $this->request->data['Server']['remote_org_id'] != Configure::read('MISP.host_org_id')) {\n                        $this->request->data['Server']['internal'] = 0;\n                    }\n                    $this->request->data['Server']['org_id'] = $this->Auth->user('org_id');\n                    if (empty($this->request->data['Server']['push_rules'])) {\n                        $this->request->data['Server']['push_rules'] = $defaultPushRules;\n                    }\n                    if (empty($this->request->data['Server']['pull_rules'])) {\n                        $this->request->data['Server']['pull_rules'] = $defaultPullRules;\n                    }\n                    if ($this->Server->save($this->request->data)) {\n                        if (isset($this->request->data['Server']['submitted_cert'])) {\n                            $this->__saveCert($this->request->data, $this->Server->id, false);\n                        }\n                        if (isset($this->request->data['Server']['submitted_client_cert'])) {\n                            $this->__saveCert($this->request->data, $this->Server->id, true);\n                        }\n                        if ($this->_isRest()) {\n                            $server = $this->Server->find('first', array(\n                                    'conditions' => array('Server.id' => $this->Server->id),\n                                    'recursive' => -1\n                            ));\n                            return $this->RestResponse->viewData($server, $this->response->type());\n                        } else {\n                            $this->Flash->success(__('The server has been saved'));\n                            $this->redirect(array('action' => 'index'));\n                        }\n                    } else {\n                        if ($this->_isRest()) {\n                            return $this->RestResponse->saveFailResponse('Servers', 'add', false, $this->Server->validationErrors, $this->response->type());\n                        } else {\n                            $this->Flash->error(__('The server could not be saved. Please, try again.'));\n                        }\n                    }\n                }\n            }\n        }\n        if ($this->_isRest()) {\n            return $this->RestResponse->describe('Servers', 'add', false, $this->response->type());\n        } else {\n            $organisationOptions = array(0 => 'Local organisation', 1 => 'External organisation', 2 => 'New external organisation');\n\n            $temp = $this->Server->Organisation->find('all', array(\n                'fields' => array('id', 'name', 'local'),\n                'order' => array('lower(Organisation.name) ASC')\n            ));\n            $allOrgs = [];\n            $localOrganisations = array();\n            $externalOrganisations = array();\n            foreach ($temp as $o) {\n                if ($o['Organisation']['local']) {\n                    $localOrganisations[$o['Organisation']['id']] = $o['Organisation']['name'];\n                } else {\n                    $externalOrganisations[$o['Organisation']['id']] = $o['Organisation']['name'];\n                }\n                $allOrgs[] = array('id' => $o['Organisation']['id'], 'name' => $o['Organisation']['name']);\n            }\n\n            $allTypes = $this->Server->getAllTypes();\n\n            $this->set('host_org_id', Configure::read('MISP.host_org_id'));\n            $this->set('organisationOptions', $organisationOptions);\n            $this->set('localOrganisations', $localOrganisations);\n            $this->set('externalOrganisations', $externalOrganisations);\n            $this->set('allOrganisations', $allOrgs);\n            $this->set('allAttributeTypes', $allTypes['attribute']);\n            $this->set('allObjectTypes', $allTypes['object']);\n\n            $this->set('allTags', $this->__getTags());\n            $this->set('host_org_id', Configure::read('MISP.host_org_id'));\n            $this->set('pull_scope', 'server');\n            $this->render('edit');\n        }\n    }\n\n    public function edit($id = null)\n    {\n        $this->Server->id = $id;\n        if (!$this->Server->exists()) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $s = $this->Server->read(null, $id);\n        if ($this->request->is('post') || $this->request->is('put')) {\n            if ($this->_isRest()) {\n                if (!isset($this->request->data['Server'])) {\n                    $this->request->data = array('Server' => $this->request->data);\n                }\n            }\n            if (empty(Configure::read('MISP.host_org_id'))) {\n                $this->request->data['Server']['internal'] = 0;\n            }\n            if (isset($this->request->data['Server']['json'])) {\n                $json = json_decode($this->request->data['Server']['json'], true);\n            } else {\n                $json = null;\n            }\n            $fail = false;\n\n            // test the filter fields\n            if (!empty($this->request->data['Server']['pull_rules']) && !JsonTool::isValid($this->request->data['Server']['pull_rules'])) {\n                $fail = true;\n                $error_msg = __('The pull filter rules must be in valid JSON format.');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'edit', false, array('pull_rules' => $error_msg), $this->response->type());\n                } else {\n                    $this->Flash->error($error_msg);\n                }\n            }\n\n            if (!$fail && !empty($this->request->data['Server']['push_rules']) && !JsonTool::isValid($this->request->data['Server']['push_rules'])) {\n                $fail = true;\n                $error_msg = __('The push filter rules must be in valid JSON format.');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'edit', false, array('push_rules' => $error_msg), $this->response->type());\n                } else {\n                    $this->Flash->error($error_msg);\n                }\n            }\n            $pushRules = $this->_jsonDecode($this->request->data['Server']['push_rules']);\n            $this->loadModel('Tag');\n            foreach ($pushRules['tags'] as $operator => $list) {\n                foreach ($list as $i => $tagName) {\n                    if (!is_numeric($tagName)) { // tag added from freetext\n                        $tag_id = $this->Tag->captureTag(['name' => $tagName], $this->Auth->user());\n                        $list[$i] = $tag_id;\n                    }\n                }\n            }\n            if (!$fail) {\n                // say what fields are to be updated\n                $fieldList = array('id', 'url', 'push', 'pull', 'push_sightings', 'push_galaxy_clusters', 'pull_galaxy_clusters', 'caching_enabled', 'unpublish_event', 'publish_without_email', 'remote_org_id', 'name' ,'self_signed', 'remove_missing_tags', 'cert_file', 'client_cert_file', 'push_rules', 'pull_rules', 'internal', 'skip_proxy');\n                $this->request->data['Server']['id'] = $id;\n                if (isset($this->request->data['Server']['authkey']) && \"\" != $this->request->data['Server']['authkey']) {\n                    $fieldList[] = 'authkey';\n                }\n                if (isset($this->request->data['Server']['organisation_type']) && isset($json)) {\n                    // adds 'remote_org_id' in the fields to update\n                    $fieldList[] = 'remote_org_id';\n                    if ($this->request->data['Server']['organisation_type'] < 2) {\n                        $this->request->data['Server']['remote_org_id'] = $json['id'];\n                    } else {\n                        $existingOrgs = $this->Server->Organisation->find('first', array(\n                                'conditions' => array('uuid' => $json['uuid']),\n                                'recursive' => -1,\n                                'fields' => array('id', 'uuid')\n                        ));\n                        if (!empty($existingOrgs)) {\n                            $fail = true;\n                            if ($this->_isRest()) {\n                                return $this->RestResponse->saveFailResponse('Servers', 'edit', false, array('Organisation' => 'Remote Organisation\\'s uuid already used'), $this->response->type());\n                            } else {\n                                $this->Flash->error(__('That organisation could not be created as the uuid is in use already.'));\n                            }\n                        }\n\n                        if (!$fail) {\n                            $this->Server->Organisation->create();\n                            $orgSave = $this->Server->Organisation->save(array(\n                                    'name' => $json['name'],\n                                    'uuid' => $json['uuid'],\n                                    'local' => 0,\n                                    'created_by' => $this->Auth->user('id')\n                            ));\n\n                            if (!$orgSave) {\n                                if ($this->_isRest()) {\n                                    return $this->RestResponse->saveFailResponse('Servers', 'edit', false, $this->Server->Organisation->validationError, $this->response->type());\n                                } else {\n                                    $this->Flash->error(__('Couldn\\'t save the new organisation, are you sure that the uuid is in the correct format?.'));\n                                }\n                                $fail = true;\n                                $this->request->data['Server']['external_name'] = $json['name'];\n                                $this->request->data['Server']['external_uuid'] = $json['uuid'];\n                            } else {\n                                $this->request->data['Server']['remote_org_id'] = $this->Server->Organisation->id;\n                            }\n                        }\n                    }\n                    if (empty(Configure::read('MISP.host_org_id')) || $this->request->data['Server']['remote_org_id'] != Configure::read('MISP.host_org_id')) {\n                        $this->request->data['Server']['internal'] = 0;\n                    }\n                }\n            }\n            if (!$fail) {\n                // Save the data\n                if ($this->Server->save($this->request->data, true, $fieldList)) {\n                    if (isset($this->request->data['Server']['submitted_cert']) && (!isset($this->request->data['Server']['delete_cert']) || !$this->request->data['Server']['delete_cert'])) {\n                        $this->__saveCert($this->request->data, $this->Server->id, false);\n                    } else {\n                        if (isset($this->request->data['Server']['delete_cert']) && $this->request->data['Server']['delete_cert']) {\n                            $this->__saveCert($this->request->data, $this->Server->id, false, true);\n                        }\n                    }\n                    if (isset($this->request->data['Server']['submitted_client_cert']) && (!isset($this->request->data['Server']['delete_client_cert']) || !$this->request->data['Server']['delete_client_cert'])) {\n                        $this->__saveCert($this->request->data, $this->Server->id, true);\n                    } else {\n                        if (isset($this->request->data['Server']['delete_client_cert']) && $this->request->data['Server']['delete_client_cert']) {\n                            $this->__saveCert($this->request->data, $this->Server->id, true, true);\n                        }\n                    }\n                    if ($this->_isRest()) {\n                        $server = $this->Server->find('first', array(\n                                'conditions' => array('Server.id' => $this->Server->id),\n                                'recursive' => -1\n                        ));\n                        return $this->RestResponse->viewData($server, $this->response->type());\n                    } else {\n                        $this->Flash->success(__('The server has been saved'));\n                        $this->redirect(array('action' => 'index'));\n                    }\n                } else {\n                    if ($this->_isRest()) {\n                        return $this->RestResponse->saveFailResponse('Servers', 'edit', false, $this->Server->validationError, $this->response->type());\n                    } else {\n                        $this->Flash->error(__('The server could not be saved. Please, try again.'));\n                    }\n                }\n            }\n        } else {\n            $this->Server->read(null, $id);\n            $this->Server->set('authkey', '');\n            $this->request->data = $this->Server->data;\n        }\n        if ($this->_isRest()) {\n            return $this->RestResponse->describe('Servers', 'edit', false, $this->response->type());\n        } else {\n            $organisationOptions = array(0 => 'Local organisation', 1 => 'External organisation', 2 => 'New external organisation');\n\n            $temp = $this->Server->Organisation->find('all', array(\n                'fields' => array('id', 'name', 'local'),\n                'order' => array('lower(Organisation.name) ASC')\n            ));\n            $allOrgs = [];\n            $localOrganisations = array();\n            $externalOrganisations = array();\n            foreach ($temp as $o) {\n                if ($o['Organisation']['local']) {\n                    $localOrganisations[$o['Organisation']['id']] = $o['Organisation']['name'];\n                } else {\n                    $externalOrganisations[$o['Organisation']['id']] = $o['Organisation']['name'];\n                }\n                $allOrgs[] = array('id' => $o['Organisation']['id'], 'name' => $o['Organisation']['name']);\n            }\n\n            $allTypes = $this->Server->getAllTypes();\n\n            $oldRemoteSetting = 0;\n            if (!$this->Server->data['RemoteOrg']['local']) {\n                $oldRemoteSetting = 1;\n            }\n            $this->set('host_org_id', Configure::read('MISP.host_org_id'));\n            $this->set('oldRemoteSetting', $oldRemoteSetting);\n            $this->set('oldRemoteOrg', $this->Server->data['RemoteOrg']['id']);\n\n            $this->set('organisationOptions', $organisationOptions);\n            $this->set('localOrganisations', $localOrganisations);\n            $this->set('externalOrganisations', $externalOrganisations);\n            $this->set('allOrganisations', $allOrgs);\n\n            $this->set('allTags', $this->__getTags());\n            $this->set('allAttributeTypes', $allTypes['attribute']);\n            $this->set('allObjectTypes', $allTypes['object']);\n            $this->set('server', $s);\n            $this->set('id', $id);\n            $this->set('host_org_id', Configure::read('MISP.host_org_id'));\n            $this->set('pull_scope', 'server');\n        }\n    }\n\n    public function delete($id = null)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException(__('This endpoint expects POST requests.'));\n        }\n        $this->Server->id = $id;\n        if (!$this->Server->exists()) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $s = $this->Server->read(null, $id);\n        if ($this->Server->delete()) {\n            $message = __('Server deleted');\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'delete', $message, $this->response->type());\n            } else {\n                $this->Flash->success($message);\n                $this->redirect(array('controller' => 'servers', 'action' => 'index'));\n            }\n\n        }\n        $message = __('Server was not deleted');\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveFailResponse('Servers', 'delete', $id, $message, $this->response->type());\n        } else {\n            $this->Flash->error($message);\n            $this->redirect(array('action' => 'index'));\n        }\n    }\n\n    public function eventBlockRule()\n    {\n        $this->AdminSetting = ClassRegistry::init('AdminSetting');\n        $setting = $this->AdminSetting->find('first', [\n            'conditions' => ['setting' => 'eventBlockRule'],\n            'recursive' => -1\n        ]);\n        if (empty($setting)) {\n            $setting = ['setting' => 'eventBlockRule'];\n            if ($this->request->is('post')) {\n                $this->AdminSetting->create();\n            }\n        }\n        if ($this->request->is('post')) {\n            if (!empty($this->request->data['Server'])) {\n                $this->request->data = $this->request->data['Server'];\n            }\n            $setting['AdminSetting']['setting'] = 'eventBlockRule';\n            $setting['AdminSetting']['value'] = $this->request->data['value'];\n            $result = $this->AdminSetting->save($setting);\n            if ($result) {\n                $message = __('Settings saved');\n            } else {\n                $message = __('Could not save the settings. Invalid input.');\n            }\n            if ($this->_isRest()) {\n                if ($result) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'eventBlockRule', false, $message, $this->response->type());\n                } else {\n                    return $this->RestResponse->saveSuccessResponse('Servers', 'eventBlockRule', $message, $this->response->type());\n                }\n            } else {\n                if ($result) {\n                    $this->Flash->success($message);\n                    $this->redirect('/');\n                } else {\n                    $this->Flash->error($message);\n                }\n            }\n        }\n        $this->set('setting', $setting);\n    }\n\n    /**\n     * Pull one or more events with attributes from a remote instance.\n     * Set $technique to\n     *      full - download everything\n     *      incremental - only new events\n     *      <int>   - specific id of the event to pull\n     */\n    public function pull($id = null, $technique = 'full')\n    {\n        if (empty($id)) {\n            if (!empty($this->request->data['id'])) {\n                $id = $this->request->data['id'];\n            } else {\n                throw new NotFoundException(__('Invalid server'));\n            }\n        }\n\n        $s = $this->Server->find('first', [\n            'conditions' => ['id' => $id],\n            'recursive' => -1,\n        ]);\n        if (empty($s)) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $error = false;\n\n        if (false == $s['Server']['pull'] && ($technique === 'full' || $technique === 'incremental')) {\n            $error = __('Pull setting not enabled for this server.');\n        }\n        if (false == $s['Server']['pull_galaxy_clusters'] && ($technique === 'pull_relevant_clusters')) {\n            $error = __('Pull setting not enabled for this server.');\n        }\n        if (empty($error)) {\n            if (!Configure::read('MISP.background_jobs')) {\n                $result = $this->Server->pull($this->Auth->user(), $technique, $s);\n                if (is_array($result)) {\n                    $success = __('Pull completed. %s events pulled, %s events could not be pulled, %s proposals pulled, %s sightings pulled, %s clusters pulled.', count($result[0]), count($result[1]), $result[2], $result[3], $result[4]);\n                } else {\n                    $error = $result;\n                }\n                $this->set('successes', $result[0]);\n                $this->set('fails', $result[1]);\n                $this->set('pulledProposals', $result[2]);\n                $this->set('pulledSightings', $result[3]);\n            } else {\n                $this->loadModel('Job');\n                $jobId = $this->Job->createJob(\n                    $this->Auth->user(),\n                    Job::WORKER_DEFAULT,\n                    'pull',\n                    'Server: ' . $id,\n                    __('Pulling.')\n                );\n\n                $this->Server->getBackgroundJobsTool()->enqueue(\n                    BackgroundJobsTool::DEFAULT_QUEUE,\n                    BackgroundJobsTool::CMD_SERVER,\n                    [\n                        'pull',\n                        $this->Auth->user('id'),\n                        $id,\n                        $technique,\n                        $jobId\n                    ],\n                    false,\n                    $jobId\n                );\n\n                $success = __('Pull queued for background execution. Job ID: %s', $jobId);\n            }\n        }\n        if ($this->_isRest()) {\n            if (!empty($error)) {\n                return $this->RestResponse->saveFailResponse('Servers', 'pull', $id, $error, $this->response->type());\n            } else {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'pull', $id, $this->response->type(), $success);\n            }\n        } else {\n            if (!empty($error)) {\n                $this->Flash->error($error);\n                $this->redirect(array('action' => 'index'));\n            } else {\n                $this->Flash->success($success);\n                $this->redirect($this->referer());\n            }\n        }\n    }\n\n    public function push($id = null, $technique=false)\n    {\n        if (!empty($id)) {\n            $this->Server->id = $id;\n        } else if (!empty($this->request->data['id'])) {\n            $this->Server->id = $this->request->data['id'];\n        } else {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        if (!empty($this->request->data['technique'])) {\n            $technique = $this->request->data['technique'];\n        }\n        if (!$this->Server->exists()) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $s = $this->Server->read(null, $id);\n\n        if (!Configure::read('MISP.background_jobs')) {\n            App::uses('SyncTool', 'Tools');\n            $syncTool = new SyncTool();\n            $HttpSocket = $syncTool->setupHttpSocket($s);\n            $result = $this->Server->push($id, $technique, false, $HttpSocket, $this->Auth->user());\n            if ($result === false) {\n                $error = __('The remote server is too outdated to initiate a push towards it. Please notify the hosting organisation of the remote instance.');\n            } elseif (!is_array($result)) {\n                $error = $result;\n            }\n            if (!empty($error)) {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'push', false, $error, $this->response->type());\n                } else {\n                    $this->Flash->info($error);\n                    $this->redirect(array('action' => 'index'));\n                }\n            }\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'push', $id, $this->response->type(), __('Push complete. %s events pushed, %s events could not be pushed.', count($result[0]), count($result[1])));\n            } else {\n                $this->set('successes', $result[0]);\n                $this->set('fails', $result[1]);\n            }\n        } else {\n            $this->loadModel('Job');\n            $jobId = $this->Job->createJob(\n                $this->Auth->user(),\n                Job::WORKER_DEFAULT,\n                'push',\n                'Server: ' . $id,\n                __('Pushing.')\n            );\n\n            $this->Server->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::DEFAULT_QUEUE,\n                BackgroundJobsTool::CMD_SERVER,\n                [\n                    'push',\n                    $this->Auth->user('id'),\n                    $id,\n                    $technique,\n                    $jobId\n                ],\n                false,\n                $jobId\n            );\n\n            $message = sprintf(__('Push queued for background execution. Job ID: %s'), $jobId);\n\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'push', $message, $this->response->type());\n            }\n            $this->Flash->success($message);\n            $this->redirect(array('action' => 'index'));\n        }\n    }\n\n    private function __saveCert($server, $id, $client = false, $delete = false)\n    {\n        if ($client) {\n            $subm = 'submitted_client_cert';\n            $attr = 'client_cert_file';\n            $ins  = '_client';\n        } else {\n            $subm = 'submitted_cert';\n            $attr = 'cert_file';\n            $ins  = '';\n        }\n        if (!$delete) {\n            $ext = '';\n            App::uses('File', 'Utility');\n            App::uses('Folder', 'Utility');\n            App::uses('FileAccessTool', 'Tools');\n            if (isset($server['Server'][$subm]['name'])) {\n                if ($this->request->data['Server'][$subm]['size'] != 0) {\n                    if (!$this->Server->checkFilename($server['Server'][$subm]['name'])) {\n                        throw new Exception(__('Filename not allowed'));\n                    }\n                    $file = new File($server['Server'][$subm]['name']);\n                    $ext = $file->ext();\n                    if (!$server['Server'][$subm]['size'] > 0) {\n                        $this->Flash->error(__('Incorrect extension or empty file.'));\n                        $this->redirect(array('action' => 'index'));\n                    }\n\n                    // read pem file data\n                    $pemData = FileAccessTool::readFromFile($server['Server'][$subm]['tmp_name'], $server['Server'][$subm]['size']);\n                } else {\n                    return true;\n                }\n            } else {\n                $pemData = base64_decode($server['Server'][$subm]);\n            }\n            $destpath = APP . \"files\" . DS . \"certs\" . DS;\n            $dir = new Folder(APP . \"files\" . DS . \"certs\", true);\n            $pemfile = new File($destpath . $id . $ins . '.' . $ext);\n            $result = $pemfile->write($pemData);\n            $s = $this->Server->read(null, $id);\n            $s['Server'][$attr] = $s['Server']['id'] . $ins . '.' . $ext;\n            if ($result) {\n                $this->Server->save($s);\n            }\n        } else {\n            $s = $this->Server->read(null, $id);\n            $s['Server'][$attr] = '';\n            $this->Server->save($s);\n        }\n        return true;\n    }\n\n    public function serverSettingsReloadSetting($setting, $id)\n    {\n        $pathToSetting = explode('.', $setting);\n        if (\n            strpos($setting, 'Plugin.Enrichment') !== false ||\n            strpos($setting, 'Plugin.Import') !== false ||\n            strpos($setting, 'Plugin.Export') !== false ||\n            strpos($setting, 'Plugin.Cortex') !== false ||\n            strpos($setting, 'Plugin.Action') !== false ||\n            strpos($setting, 'Plugin.Workflow') !== false\n        ) {\n            $settingObject = $this->Server->getCurrentServerSettings();\n        } else {\n            $settingObject = $this->Server->serverSettings;\n        }\n        foreach ($pathToSetting as $key) {\n            if (!isset($settingObject[$key])) {\n                throw new MethodNotAllowedException();\n            }\n            $settingObject = $settingObject[$key];\n        }\n        $result = $this->Server->serverSettingReadSingle($settingObject, $setting, $key);\n        $this->set('setting', $result);\n        $priorityErrorColours = array(0 => 'red', 1 => 'yellow', 2 => 'green');\n        $this->set('priorityErrorColours', $priorityErrorColours);\n        $priorities = array(0 => 'Critical', 1 => 'Recommended', 2 => 'Optional', 3 => 'Deprecated');\n        $this->set('priorities', $priorities);\n        $this->set('k', $id);\n        $this->layout = false;\n\n        $subGroup = 'general';\n        if ($pathToSetting[0] === 'Plugin') {\n            $subGroup = explode('_', $pathToSetting[1])[0];\n        }\n        $this->set('subGroup', $subGroup);\n\n        $this->render('/Elements/healthElements/settings_row');\n    }\n\n    public function serverSettings($tab=false)\n    {\n        if (!$this->request->is('get')) {\n            throw new MethodNotAllowedException('Just GET method is allowed.');\n        }\n        $tabs = array(\n            'MISP' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'Encryption' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'Proxy' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'Security' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'Plugin' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'SimpleBackgroundJobs' => array('count' => 0, 'errors' => 0, 'severity' => 5)\n        );\n\n        $writeableErrors = array(0 => __('OK'), 1 => __('not found'), 2 => __('is not writeable'));\n        $readableErrors = array(0 => __('OK'), 1 => __('not readable'));\n        $gpgErrors = array(0 => __('OK'), 1 => __('FAIL: settings not set'), 2 => __('FAIL: Failed to load GnuPG'), 3 => __('FAIL: Issues with the key/passphrase'), 4 => __('FAIL: sign failed'));\n        $proxyErrors = array(0 => __('OK'), 1 => __('not configured (so not tested)'), 2 => __('Getting URL via proxy failed'));\n        $zmqErrors = array(0 => __('OK'), 1 => __('not enabled (so not tested)'), 2 => __('Python ZeroMQ library not installed correctly.'), 3 => __('ZeroMQ script not running.'));\n        $sessionErrors = array(\n            0 => __('OK'),\n            1 => __('Too many expired sessions in the database, please clear the expired sessions'),\n            2 => __('PHP session handler is using the default file storage. This is not recommended, please use the redis or database storage'),\n            8 => __('Alternative setting used'),\n            9 => __('Test failed')\n        );\n        $moduleErrors = array(0 => __('OK'), 1 => __('System not enabled'), 2 => __('No modules found'));\n        $backgroundJobsErrors = array(\n            0 => __('OK'),\n            1 => __('Not configured (so not tested)'),\n            2 => __('Error connecting to Redis.'),\n            3 => __('Error connecting to Supervisor.'),\n            4 => __('Error connecting to Redis and Supervisor.')\n        );\n\n        $finalSettings = $this->Server->serverSettingsRead();\n        $issues = array(\n            'errors' => array(\n                0 => array(\n                    'value' => 0,\n                    'description' => __('MISP will not operate correctly or will be unsecure until these issues are resolved.')\n                ),\n                1 => array(\n                    'value' => 0,\n                    'description' => __('Some of the features of MISP cannot be utilised until these issues are resolved.')\n                ),\n                2 => array(\n                    'value' => 0,\n                    'description' => __('There are some optional tweaks that could be done to improve the looks of your MISP instance.')\n                ),\n            ),\n            'deprecated' => array(),\n            'overallHealth' => 3,\n        );\n        $dumpResults = array();\n        $tempArray = array();\n        foreach ($finalSettings as $k => $result) {\n            if ($result['level'] == 3) {\n                $issues['deprecated']++;\n            }\n            $tabs[$result['tab']]['count']++;\n            if (isset($result['error']) && $result['level'] < 3) {\n                $issues['errors'][$result['level']]['value']++;\n                if ($result['level'] < $issues['overallHealth']) {\n                    $issues['overallHealth'] = $result['level'];\n                }\n                $tabs[$result['tab']]['errors']++;\n                if ($result['level'] < $tabs[$result['tab']]['severity']) {\n                    $tabs[$result['tab']]['severity'] = $result['level'];\n                }\n            }\n            if (isset($result['optionsSource']) && is_callable($result['optionsSource'])) {\n                $result['options'] = $result['optionsSource']();\n            }\n            $dumpResults[] = $result;\n            if ($result['tab'] == $tab) {\n                if (isset($result['subGroup'])) {\n                    $tempArray[$result['subGroup']][] = $result;\n                } else {\n                    $tempArray['general'][] = $result;\n                }\n            }\n        }\n        $finalSettings = $tempArray;\n        // Diagnostics portion\n        $diagnostic_errors = 0;\n        App::uses('File', 'Utility');\n        App::uses('Folder', 'Utility');\n        if ($tab === 'correlations') {\n            $this->loadModel('Correlation');\n            $correlation_metrics = $this->Correlation->collectMetrics();\n            $this->set('correlation_metrics', $correlation_metrics);\n        }\n        if ($tab === 'files') {\n            if (!empty(Configure::read('Security.disable_instance_file_uploads'))) {\n                throw new MethodNotAllowedException(__('This functionality is disabled.'));\n            }\n            $files = $this->Server->grabFiles();\n            $this->set('files', $files);\n        }\n        // Only run this check on the diagnostics tab\n        if ($tab === 'diagnostics' || $tab === 'download' || $this->_isRest()) {\n            $php_ini = php_ini_loaded_file();\n            $this->set('php_ini', $php_ini);\n\n            $attachmentTool = new AttachmentTool();\n            try {\n                $advanced_attachments = $attachmentTool->checkAdvancedExtractionStatus();\n            } catch (Exception $e) {\n                $this->log($e->getMessage(), LOG_NOTICE);\n                $advanced_attachments = false;\n            }\n\n            $this->set('advanced_attachments', $advanced_attachments);\n\n            $gitStatus = $this->Server->getCurrentGitStatus(true);\n            $this->set('branch', $gitStatus['branch']);\n            $this->set('commit', $gitStatus['commit']);\n            $this->set('latestCommit', $gitStatus['latestCommit']);\n            $this->set('version', $gitStatus['version']);\n\n            $phpSettings = array(\n                'max_execution_time' => array(\n                    'explanation' => 'The maximum duration that a script can run (does not affect the background workers). A too low number will break long running scripts like comprehensive API exports',\n                    'recommended' => 300,\n                    'unit' => 'seconds',\n                ),\n                'memory_limit' => array(\n                    'explanation' => 'The maximum memory that PHP can consume. It is recommended to raise this number since certain exports can generate a fair bit of memory usage',\n                    'recommended' => 2048,\n                    'unit' => 'MB'\n                ),\n                'upload_max_filesize' => array(\n                    'explanation' => 'The maximum size that an uploaded file can be. It is recommended to raise this number to allow for the upload of larger samples',\n                    'recommended' => 50,\n                    'unit' => 'MB'\n                ),\n                'post_max_size' => array(\n                    'explanation' => 'The maximum size of a POSTed message, this has to be at least the same size as the upload_max_filesize setting',\n                    'recommended' => 50,\n                    'unit' => 'MB'\n                )\n            );\n\n            foreach ($phpSettings as $setting => $settingArray) {\n                $phpSettings[$setting]['value'] = $this->Server->getIniSetting($setting);\n                if ($phpSettings[$setting]['value'] && $settingArray['unit'] && $settingArray['unit'] === 'MB') {\n                    // convert basic unit to M\n                    $phpSettings[$setting]['value'] = (int) floor($phpSettings[$setting]['value'] / 1024 / 1024);\n                }\n            }\n            $this->set('phpSettings', $phpSettings);\n\n            if ($gitStatus['version'] && $gitStatus['version']['upToDate'] === 'older') {\n                $diagnostic_errors++;\n            }\n\n            // check if the STIX and Cybox libraries are working and the correct version using the test script stixtest.py\n            $stix = $this->Server->stixDiagnostics($diagnostic_errors);\n\n            $yaraStatus = $this->Server->yaraDiagnostics($diagnostic_errors);\n\n            // if GnuPG is set up in the settings, try to encrypt a test message\n            $gpgStatus = $this->Server->gpgDiagnostics($diagnostic_errors);\n\n            // if the message queue pub/sub is enabled, check whether the extension works\n            $zmqStatus = $this->Server->zmqDiagnostics($diagnostic_errors);\n\n            // if Proxy is set up in the settings, try to connect to a test URL\n            $proxyStatus = $this->Server->proxyDiagnostics($diagnostic_errors);\n\n            // if SimpleBackgroundJobs is set up in the settings, try to connect to Redis\n            $backgroundJobsStatus = $this->Server->backgroundJobsDiagnostics($diagnostic_errors);\n\n            // get the DB diagnostics\n            $dbDiagnostics = $this->Server->dbSpaceUsage();\n            $dbSchemaDiagnostics = $this->Server->dbSchemaDiagnostic();\n            $dbConfiguration = $this->Server->dbConfiguration();\n\n            $redisInfo = $this->Server->redisInfo();\n\n            $moduleTypes = array('Enrichment', 'Import', 'Export', 'Cortex');\n            foreach ($moduleTypes as $type) {\n                $moduleStatus[$type] = $this->Server->moduleDiagnostics($diagnostic_errors, $type);\n            }\n\n            // get php session diagnostics\n            $sessionStatus = $this->Server->sessionDiagnostics($diagnostic_errors);\n\n            $this->loadModel('AttachmentScan');\n            try {\n                $attachmentScan = ['status' => true, 'software' => $this->AttachmentScan->diagnostic()];\n            } catch (Exception $e) {\n                $attachmentScan = ['status' => false, 'error' => $e->getMessage()];\n            }\n\n            $securityAudit = (new SecurityAudit())->run($this->Server);\n\n            $view = compact('gpgStatus', 'sessionErrors', 'proxyStatus', 'sessionStatus', 'zmqStatus', 'moduleStatus', 'yaraStatus', 'gpgErrors', 'proxyErrors', 'zmqErrors', 'stix', 'moduleErrors', 'moduleTypes', 'dbDiagnostics', 'dbSchemaDiagnostics', 'dbConfiguration', 'redisInfo', 'attachmentScan', 'securityAudit');\n        } else {\n            $view = [];\n        }\n\n        // check whether the files are writeable\n        $writeableDirs = $this->Server->writeableDirsDiagnostics($diagnostic_errors);\n        $writeableFiles = $this->Server->writeableFilesDiagnostics($diagnostic_errors);\n        $readableFiles = $this->Server->readableFilesDiagnostics($diagnostic_errors);\n        $extensions = $this->Server->extensionDiagnostics();\n\n        // check if the encoding is not set to utf8\n        $dbEncodingStatus = $this->Server->databaseEncodingDiagnostics($diagnostic_errors);\n\n        $view = array_merge($view, compact('diagnostic_errors', 'tabs', 'tab', 'issues', 'finalSettings', 'writeableErrors', 'readableErrors', 'writeableDirs', 'writeableFiles', 'readableFiles', 'extensions', 'dbEncodingStatus'));\n        $this->set($view);\n\n        $workerIssueCount = 4;\n        $worker_array = array();\n        if (Configure::read('MISP.background_jobs')) {\n            $workerIssueCount = 0;\n            $worker_array = $this->Server->workerDiagnostics($workerIssueCount);\n        }\n        $this->set('worker_array', $worker_array);\n        if ($tab === 'download' || $this->_isRest()) {\n            foreach ($dumpResults as $key => $dr) {\n                unset($dumpResults[$key]['description']);\n            }\n            $dump = array(\n                'version' => $gitStatus['version'],\n                'phpSettings' => $phpSettings,\n                'gpgStatus' => $gpgErrors[$gpgStatus['status']],\n                'proxyStatus' => $proxyErrors[$proxyStatus],\n                'zmqStatus' => $zmqStatus,\n                'stix' => $stix,\n                'moduleStatus' => $moduleStatus,\n                'writeableDirs' => $writeableDirs,\n                'writeableFiles' => $writeableFiles,\n                'readableFiles' => $readableFiles,\n                'dbDiagnostics' => $dbDiagnostics,\n                'dbSchemaDiagnostics' => $dbSchemaDiagnostics,\n                'dbConfiguration' => $dbConfiguration,\n                'redisInfo' => $redisInfo,\n                'finalSettings' => $dumpResults,\n                'extensions' => $extensions,\n                'workers' => $worker_array,\n                'backgroundJobsStatus' => $backgroundJobsErrors[$backgroundJobsStatus]\n            );\n            foreach ($dump['finalSettings'] as $k => $v) {\n                if (!empty($v['redacted'])) {\n                    $dump['finalSettings'][$k]['value'] = '*****';\n                }\n            }\n            $this->response->body(json_encode($dump, JSON_PRETTY_PRINT));\n            $this->response->type('json');\n            $this->response->download('MISP.report.json');\n            return $this->response;\n        }\n\n        $priorities = array(0 => 'Critical', 1 => 'Recommended', 2 => 'Optional', 3 => 'Deprecated');\n        $this->set('priorities', $priorities);\n        $this->set('workerIssueCount', $workerIssueCount);\n        $priorityErrorColours = array(0 => 'red', 1 => 'yellow', 2 => 'green');\n        $this->set('priorityErrorColours', $priorityErrorColours);\n        $this->set('phpversion', phpversion());\n        $this->set('phpmin', $this->phpmin);\n        $this->set('phprec', $this->phprec);\n        $this->set('phptoonew', $this->phptoonew);\n        $this->set('pythonmin', $this->pythonmin);\n        $this->set('pythonrec', $this->pythonrec);\n        $this->set('title_for_layout', __('Diagnostics'));\n    }\n\n    public function startWorker($type)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $message = __('Worker start signal sent');\n            $this->Server->getBackgroundJobsTool()->startWorkerByQueue($type);\n\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'startWorker', $type, $this->response->type(), $message);\n            } else {\n                $this->Flash->info($message);\n                $this->redirect('/servers/serverSettings/workers');\n            }\n        }\n\n        // CakeResque\n        $validTypes = array('default', 'email', 'scheduler', 'cache', 'prio', 'update');\n        if (!in_array($type, $validTypes)) {\n            throw new MethodNotAllowedException('Invalid worker type.');\n        }\n\n        $prepend = '';\n        if ($type != 'scheduler') {\n            $workerIssueCount = 0;\n            $workerDiagnostic = $this->Server->workerDiagnostics($workerIssueCount);\n            if ($type == 'update' && isset($workerDiagnostic['update']['ok']) && $workerDiagnostic['update']['ok']) {\n                $message = __('Only one `update` worker can run at a time');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'startWorker', false, $message, $this->response->type());\n                } else {\n                    $this->Flash->error($message);\n                    $this->redirect('/servers/serverSettings/workers');\n                }\n            }\n            shell_exec($prepend . APP . 'Console' . DS . 'cake CakeResque.CakeResque start --interval 5 --queue ' . $type .' > /dev/null 2>&1 &');\n        } else {\n            shell_exec($prepend . APP . 'Console' . DS . 'cake CakeResque.CakeResque startscheduler -i 5 > /dev/null 2>&1 &');\n        }\n        $message = __('Worker start signal sent');\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Servers', 'startWorker', $type, $this->response->type(), $message);\n        } else {\n            $this->Flash->info($message);\n            $this->redirect('/servers/serverSettings/workers');\n        }\n    }\n\n    public function stopWorker($pid)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n\n        $message = __('Worker stop signal sent');\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $this->Server->getBackgroundJobsTool()->stopWorker($pid);\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'stopWorker', $pid, $this->response->type(), $message);\n            } else {\n                $this->Flash->info($message);\n                $this->redirect('/servers/serverSettings/workers');\n            }\n        }\n\n        // CakeResque\n        $this->Server->killWorker($pid, $this->Auth->user());\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Servers', 'stopWorker', $pid, $this->response->type(), $message);\n        } else {\n            $this->Flash->info($message);\n            $this->redirect('/servers/serverSettings/workers');\n        }\n    }\n\n    public function getWorkers()\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $workerIssueCount = 0;\n            $worker_array = $this->Server->workerDiagnostics($workerIssueCount);\n        } else {\n            $worker_array = [__('Background jobs not enabled')];\n        }\n        return $this->RestResponse->viewData($worker_array);\n    }\n\n    public function idTranslator($localId = null)\n    {\n        // We retrieve the list of remote servers that we can query\n        $servers = $this->Server->find('all', [\n            'conditions' => ['OR' => ['pull' => true, 'push' => true]],\n            'recursive' => -1,\n            'order' => ['Server.priority ASC'],\n        ]);\n\n        // We generate the list of servers for the dropdown\n        $displayServers = array();\n        foreach ($servers as $s) {\n            $displayServers[] = [\n                'name' => $s['Server']['name'],\n                'value' => $s['Server']['id'],\n            ];\n        }\n        $this->set('servers', $displayServers);\n\n        if ($localId || $this->request->is('post')) {\n            if ($localId && $this->request->is('get')) {\n                $this->request->data['Event']['local'] = 'local';\n                $this->request->data['Event']['uuid'] = $localId;\n            }\n            $remote_events = array();\n            if (!empty($this->request->data['Event']['uuid']) && $this->request->data['Event']['local'] === \"local\") {\n                $local_event = $this->Event->fetchSimpleEvent($this->Auth->user(), $this->request->data['Event']['uuid']);\n            } else if (!empty($this->request->data['Event']['uuid']) && $this->request->data['Event']['local'] === \"remote\" && !empty($this->request->data['Server']['id'])) {\n                //We check on the remote server for any event with this id and try to find a match locally\n                $conditions = array('AND' => array('Server.id' => $this->request->data['Server']['id'], 'Server.pull' => true));\n                $remote_server = $this->Server->find('first', array('conditions' => $conditions));\n                if (!empty($remote_server)) {\n                    try {\n                        $remote_event = $this->Event->downloadEventMetadataFromServer($this->request->data['Event']['uuid'], $remote_server);\n                    } catch (Exception $e) {\n                        $this->Flash->error(__(\"Issue while contacting the remote server to retrieve event information\"));\n                        return;\n                    }\n\n                    if (empty($remote_event)) {\n                        $this->Flash->error(__(\"This event could not be found or you don't have permissions to see it.\"));\n                        return;\n                    }\n\n                    $local_event = $this->Event->fetchSimpleEvent($this->Auth->user(), $remote_event['uuid']);\n                    // we record it to avoid re-querying the same server in the 2nd phase\n                    if (!empty($local_event)) {\n                        $remote_events[] = array(\n                            \"server_id\" => $remote_server['Server']['id'],\n                            \"server_name\" => $remote_server['Server']['name'],\n                            \"url\" => $remote_server['Server']['url'].\"/events/view/\".$remote_event['id'],\n                            \"remote_id\" => $remote_event['id']\n                        );\n                    }\n                }\n            }\n            if (empty($local_event)) {\n                $this->Flash->error(__(\"This event could not be found or you don't have permissions to see it.\"));\n                return;\n            } else {\n                $this->Flash->success(__('The event has been found.'));\n            }\n\n            // In the second phase, we query all configured sync servers to get their info on the event\n            foreach ($servers as $server) {\n                // We check if the server was not already contacted in phase 1\n                if (count($remote_events) > 0 && $remote_events[0]['server_id'] == $server['Server']['id']) {\n                    continue;\n                }\n\n                $exception = null;\n                try {\n                    $remoteEvent = $this->Event->downloadEventMetadataFromServer($local_event['Event']['uuid'], $server);\n                } catch (Exception $e) {\n                    $remoteEvent = null;\n                    $exception = $e->getMessage();\n                }\n                $remoteEventId = isset($remoteEvent['id']) ? $remoteEvent['id'] : null;\n                $remote_events[] = array(\n                    \"server_id\" => $server['Server']['id'],\n                    \"server_name\" => $server['Server']['name'],\n                    \"url\" => isset($remoteEventId) ? $server['Server']['url'] . \"/events/view/\" . $remoteEventId : $server['Server']['url'],\n                    \"remote_id\" => isset($remoteEventId) ? $remoteEventId : false,\n                    \"exception\" => $exception,\n                );\n            }\n\n            $this->set('local_event', $local_event);\n            $this->set('remote_events', $remote_events);\n        }\n        $this->set('title_for_layout', __('Event ID translator'));\n    }\n\n    public function getSubmodulesStatus()\n    {\n        $this->set('submodules', $this->Server->getSubmodulesGitStatus());\n        $this->render('ajax/submoduleStatus');\n    }\n\n    public function getSetting($settingName)\n    {\n        $setting = $this->Server->getSettingData($settingName);\n        if (!$setting) {\n            throw new NotFoundException(__('Setting %s is invalid.', $settingName));\n        }\n        if (!empty($setting[\"redacted\"])) {\n            throw new ForbiddenException(__('This setting is redacted.'));\n        }\n        if (Configure::check($settingName)) {\n            $setting['value'] = Configure::read($settingName);\n        }\n        return $this->RestResponse->viewData($setting);\n    }\n\n    public function serverSettingsEdit($settingName, $id = false, $forceSave = false)\n    {\n        if (!$this->_isRest()) {\n            if (!isset($id)) {\n                throw new MethodNotAllowedException();\n            }\n            $this->set('id', $id);\n        }\n        $setting = $this->Server->getSettingData($settingName);\n        if ($setting === false) {\n            throw new NotFoundException(__('Setting %s is invalid.', $settingName));\n        }\n        if (!empty($setting['cli_only'])) {\n            throw new MethodNotAllowedException(__('This setting can only be edited via the CLI.'));\n        }\n        if ($this->request->is('get')) {\n            $value = Configure::read($setting['name']);\n            if (isset($value)) {\n                $setting['value'] = $value;\n            }\n            $setting['setting'] = $setting['name'];\n            if (isset($setting['optionsSource']) && is_callable($setting['optionsSource'])) {\n                $setting['options'] = $setting['optionsSource']();\n            }\n            $subGroup = explode('.', $setting['name']);\n            if ($subGroup[0] === 'Plugin') {\n                $subGroup = explode('_', $subGroup[1])[0];\n            } else {\n                $subGroup = 'general';\n            }\n            if ($this->_isRest()) {\n                if (!empty($setting['redacted'])) {\n                    throw new ForbiddenException(__('This setting is redacted.'));\n                }\n                return $this->RestResponse->viewData([$setting['name'] => $setting['value']]);\n            } else {\n                $this->set('subGroup', $subGroup);\n                $this->set('setting', $setting);\n                $this->render('ajax/server_settings_edit');\n            }\n        } else if ($this->request->is('post')) {\n            if (!isset($this->request->data['Server'])) {\n                $this->request->data = array('Server' => $this->request->data);\n            }\n            if (!isset($this->request->data['Server']['value']) || !is_scalar($this->request->data['Server']['value'])) {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'serverSettingsEdit', false, 'Invalid input. Expected: {\"value\": \"new_setting\"}', $this->response->type());\n                }\n            }\n            if (!empty($this->request->data['Server']['force'])) {\n                $forceSave = $this->request->data['Server']['force'];\n            }\n            if (trim($this->request->data['Server']['value']) === '*****') {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'serverSettingsEdit', false, 'No change.', $this->response->type());\n                } else {\n                    return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => 'No change.')), 'status'=>200, 'type' => 'json'));\n                }\n            }\n            $this->autoRender = false;\n            if (!Configure::read('MISP.system_setting_db') && !is_writeable(APP . 'Config/config.php')) {\n                $this->loadModel('Log');\n                $this->Log->create();\n                $this->Log->save(array(\n                    'org' => $this->Auth->user('Organisation')['name'],\n                    'model' => 'Server',\n                    'model_id' => 0,\n                    'email' => $this->Auth->user('email'),\n                    'action' => 'serverSettingsEdit',\n                    'user_id' => $this->Auth->user('id'),\n                    'title' => 'Server setting issue',\n                    'change' => 'There was an issue witch changing ' . $setting['name'] . ' to ' . $this->request->data['Server']['value']  . '. The error message returned is: app/Config.config.php is not writeable to the apache user. No changes were made.',\n                ));\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'serverSettingsEdit', false, 'app/Config.config.php is not writeable to the apache user.', $this->response->type());\n                } else {\n                    return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => 'app/Config.config.php is not writeable to the apache user.')), 'status'=>200, 'type' => 'json'));\n                }\n            }\n            $result = $this->Server->serverSettingsEditValue($this->Auth->user(), $setting, $this->request->data['Server']['value'], $forceSave);\n            if ($result === true) {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveSuccessResponse('Servers', 'serverSettingsEdit', false, $this->response->type(), 'Field updated');\n                } else {\n                    return new CakeResponse(array('body'=> json_encode(array('saved' => true, 'success' => 'Field updated.')), 'status'=>200, 'type' => 'json'));\n                }\n            } else {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'serverSettingsEdit', false, $result, $this->response->type());\n                } else {\n                    return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => $result)), 'status'=>200, 'type' => 'json'));\n                }\n            }\n        }\n    }\n\n    public function killAllWorkers($force = false)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        $this->Server->killAllWorkers($this->Auth->user(), $force);\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Server', 'killAllWorkers', false, $this->response->type(), __('Killing workers.'));\n        }\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'workers'));\n    }\n\n    public function restartWorkers()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $this->Server->getBackgroundJobsTool()->restartWorkers();\n        } else {\n            // CakeResque\n            $this->Server->restartWorkers($this->Auth->user());\n        }\n\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Server', 'restartWorkers', false, $this->response->type(), __('Restarting workers.'));\n        }\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'workers'));\n    }\n\n    public function restartDeadWorkers()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $this->Server->getBackgroundJobsTool()->restartDeadWorkers();\n        } else {\n            // CakeResque\n            $this->Server->restartDeadWorkers($this->Auth->user());\n        }\n\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Server', 'restartDeadWorkers', false, $this->response->type(), __('Restarting workers.'));\n        }\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'workers'));\n    }\n\n    public function deleteFile($type, $filename)\n    {\n        if ($this->request->is('post')) {\n            $validItems = $this->Server->getFileRules();\n            App::uses('File', 'Utility');\n            $existingFile = new File($validItems[$type]['path'] . DS . $filename);\n            if (!$existingFile->exists()) {\n                $this->Flash->error(__('File not found.', true), 'default', array(), 'error');\n                $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n            }\n            if ($existingFile->delete()) {\n                $this->Flash->success('File deleted.');\n            } else {\n                $this->Flash->error(__('File could not be deleted.', true), 'default', array(), 'error');\n            }\n            $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n        } else {\n            throw new MethodNotAllowedException('This action expects a POST request.');\n        }\n    }\n\n    public function uploadFile($type)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        if (!empty(Configure::read('Security.disable_instance_file_uploads'))) {\n            throw new MethodNotAllowedException(__('Feature disabled.'));\n        }\n        $validItems = $this->Server->getFileRules();\n\n        // Check if there were problems with the file upload\n        // only keep the last part of the filename, this should prevent directory attacks\n        $filename = basename($this->request->data['Server']['file']['name']);\n        if (!preg_match(\"/\" . $validItems[$type]['regex'] . \"/\", $filename)) {\n            $this->Flash->error($validItems[$type]['regex_error'], 'default', array(), 'error');\n            $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n        }\n        if (empty($this->request->data['Server']['file']['tmp_name']) || !is_uploaded_file($this->request->data['Server']['file']['tmp_name'])) {\n            $this->Flash->error(__('Upload failed.', true), 'default', array(), 'error');\n            $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n        }\n\n        // check if the file already exists\n        App::uses('File', 'Utility');\n        $existingFile = new File($validItems[$type]['path'] . DS . $filename);\n        if ($existingFile->exists()) {\n            $this->Flash->info(__('File already exists. If you would like to replace it, remove the old one first.', true), 'default', array(), 'error');\n            $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n        }\n\n        $result = move_uploaded_file($this->request->data['Server']['file']['tmp_name'], $validItems[$type]['path'] . DS . $filename);\n        if ($result) {\n            $this->Flash->success('File uploaded.');\n        } else {\n            $this->Flash->error(__('Upload failed.', true), 'default', array(), 'error');\n        }\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n    }\n\n    public function fetchServersForSG($idList = '{}')\n    {\n        $id_exclusion_list = json_decode($idList, true);\n        $temp = $this->Server->find('all', array(\n                'conditions' => array(\n                        'id !=' => $id_exclusion_list,\n                ),\n                'recursive' => -1,\n                'fields' => array('id', 'name', 'url')\n        ));\n        $servers = array();\n        foreach ($temp as $server) {\n            $servers[] = array('id' => $server['Server']['id'], 'name' => $server['Server']['name'], 'url' => $server['Server']['url']);\n        }\n        $this->layout = false;\n        $this->autoRender = false;\n        $this->set('servers', $servers);\n        $this->render('ajax/fetch_servers_for_sg');\n    }\n\n    public function postTest()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException('Invalid request, expecting a POST request.');\n        }\n        // Fix for PHP-FPM / Nginx / etc\n        // Fix via https://www.popmartian.com/tipsntricks/2015/07/14/howto-use-php-getallheaders-under-fastcgi-php-fpm-nginx-etc/\n        if (!function_exists('getallheaders')) {\n            $headers = [];\n            foreach ($_SERVER as $name => $value) {\n                $name = strtolower($name);\n                if (substr($name, 0, 5) === 'http_') {\n                    $headers[str_replace('_', '-', substr($name, 5))] = $value;\n                }\n            }\n        } else {\n            $headers = getallheaders();\n            $headers = array_change_key_case($headers, CASE_LOWER);\n        }\n        $result = [\n            'body' => $this->request->data,\n            'headers' => [\n                'Content-type' => isset($headers['content-type']) ? $headers['content-type'] : 0,\n                'Accept' => isset($headers['accept']) ? $headers['accept'] : 0,\n                'Authorization' => isset($headers['authorization']) ? 'OK' : 0,\n            ],\n        ];\n        return $this->RestResponse->viewData($result, 'json');\n    }\n\n    public function getRemoteUser($id)\n    {\n        $user = $this->Server->getRemoteUser($id);\n        if ($user === null) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        return $this->RestResponse->viewData($user);\n    }\n\n    public function testConnection($id = false)\n    {\n        $server = $this->Server->find('first', ['conditions' => ['Server.id' => $id]]);\n        if (!$server) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        @session_write_close(); // close session to allow concurrent requests\n        $result = $this->Server->runConnectionTest($server);\n        if ($result['status'] == 1) {\n            if (isset($result['info']['version']) && preg_match('/^[0-9]+\\.+[0-9]+\\.[0-9]+$/', $result['info']['version'])) {\n                $perm_sync = isset($result['info']['perm_sync']) ? $result['info']['perm_sync'] : false;\n                $perm_sighting = isset($result['info']['perm_sighting']) ? $result['info']['perm_sighting'] : false;\n                $local_version = $this->Server->checkMISPVersion();\n                $version = explode('.', $result['info']['version']);\n                $mismatch = false;\n                $newer = false;\n                $parts = array('major', 'minor', 'hotfix');\n                foreach ($parts as $k => $v) {\n                    if (!$mismatch) {\n                        if ($version[$k] > $local_version[$v]) {\n                            $mismatch = $v;\n                            $newer = 'remote';\n                        } elseif ($version[$k] < $local_version[$v]) {\n                            $mismatch = $v;\n                            $newer = 'local';\n                        }\n                    }\n                }\n                if (!$mismatch && $version[2] < 111) {\n                    $mismatch = 'proposal';\n                }\n                if (!$perm_sync && !$perm_sighting) {\n                    $result['status'] = 7;\n                    return new CakeResponse(array('body'=> json_encode($result), 'type' => 'json'));\n                }\n                if (!$perm_sync && $perm_sighting) {\n                    $result['status'] = 8;\n                    return new CakeResponse(array('body'=> json_encode($result), 'type' => 'json'));\n                }\n                return $this->RestResponse->viewData([\n                    'status' => 1,\n                    'local_version' => implode('.', $local_version),\n                    'version' => implode('.', $version),\n                    'mismatch' => $mismatch,\n                    'newer' => $newer,\n                    'post' => isset($result['post']) ? $result['post']['status'] : 'too old',\n                    'response_encoding' => isset($result['post']['content-encoding']) ? $result['post']['content-encoding'] : null,\n                    'request_encoding' => isset($result['info']['request_encoding']) ? $result['info']['request_encoding'] : null,\n                    'client_certificate' => $result['client_certificate'],\n                ], 'json');\n            } else {\n                $result['status'] = 3;\n            }\n        }\n        return new CakeResponse(array('body'=> json_encode($result), 'type' => 'json'));\n    }\n\n    public function startZeroMQServer()\n    {\n        $pubSubTool = $this->Server->getPubSubTool();\n        $result = $pubSubTool->restartServer();\n        if ($result === true) {\n            return new CakeResponse(array('body'=> json_encode(array('saved' => true, 'success' => 'ZeroMQ server successfully started.')), 'status'=>200, 'type' => 'json'));\n        } else {\n            return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => $result)), 'status'=>200, 'type' => 'json'));\n        }\n    }\n\n    public function stopZeroMQServer()\n    {\n        $pubSubTool = $this->Server->getPubSubTool();\n        $result = $pubSubTool->killService();\n        if ($result === true) {\n            return new CakeResponse(array('body'=> json_encode(array('saved' => true, 'success' => 'ZeroMQ server successfully killed.')), 'status'=>200, 'type' => 'json'));\n        } else {\n            return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => 'Could not kill the previous instance of the ZeroMQ script.')), 'status'=>200, 'type' => 'json'));\n        }\n    }\n\n    public function statusZeroMQServer()\n    {\n        $pubSubTool = $this->Server->getPubSubTool();\n        $result = $pubSubTool->statusCheck();\n        if (!empty($result)) {\n            $this->set('events', $result['publishCount']);\n            $this->set('messages', $result['messageCount']);\n            $this->set('time', $result['timestamp']);\n            $this->set('time2', $result['timestampSettings']);\n        }\n        $this->render('ajax/zeromqstatus');\n    }\n\n    public function purgeSessions()\n    {\n        if ($this->Server->updateDatabase('cleanSessionTable') == false) {\n            $this->Flash->error('Could not purge the session table.');\n        }\n        $this->redirect('/servers/serverSettings/diagnostics');\n    }\n\n    public function clearWorkerQueue($worker)\n    {\n        if (!$this->request->is('Post') || $this->request->is('ajax')) {\n            throw new MethodNotAllowedException();\n        }\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $this->Server->getBackgroundJobsTool()->purgeQueue($worker);\n        } else {\n            // CakeResque\n            $worker_array = array('cache', 'default', 'email', 'prio');\n            if (!in_array($worker, $worker_array)) {\n                throw new MethodNotAllowedException('Invalid worker');\n            }\n            $redis = Resque::redis();\n            $redis->del('queue:' . $worker);\n        }\n\n        $this->Flash->success('Queue cleared.');\n        $this->redirect($this->referer());\n    }\n\n    public function getVersion()\n    {\n        $user = $this->_closeSession();\n        $versionArray = $this->Server->checkMISPVersion();\n        $response = [\n            'version' => $versionArray['major'] . '.' . $versionArray['minor'] . '.' . $versionArray['hotfix'],\n            'pymisp_recommended_version' => $this->pyMispVersion,\n            'perm_sync' => (bool) $user['Role']['perm_sync'],\n            'perm_sighting' => (bool) $user['Role']['perm_sighting'],\n            'perm_galaxy_editor' => (bool) $user['Role']['perm_galaxy_editor'],\n            'request_encoding' => $this->CompressedRequestHandler->supportedEncodings(),\n            'filter_sightings' => true, // check if Sightings::filterSightingUuidsForPush method is supported\n        ];\n        return $this->RestResponse->viewData($response, 'json');\n    }\n\n    /**\n     * @deprecated Use field `pymisp_recommended_version` from getVersion instead\n     */\n    public function getPyMISPVersion()\n    {\n        $this->set('response', array('version' => $this->pyMispVersion));\n        $this->set('_serialize', 'response');\n    }\n\n    public function checkout()\n    {\n        $result = $this->Server->checkoutMain();\n    }\n\n    public function update($branch = false)\n    {\n        if ($this->request->is('post')) {\n            $filterData = array(\n                'request' => $this->request,\n                'named_params' => $this->params['named'],\n                'paramArray' => ['branch'],\n                'ordered_url_params' => [],\n                'additional_delimiters' => PHP_EOL\n            );\n            $exception = false;\n            $settings = $this->_harvestParameters($filterData, $exception);\n            $status = $this->Server->getCurrentGitStatus();\n            $raw = array();\n            if (empty($status['branch'])) { // do not try to update if you are not on branch\n                $msg = 'Update failed, you are not on branch';\n                $raw[] = $msg;\n                $update = $msg;\n            } else {\n                if ($settings === false) {\n                    $settings = [];\n                }\n                $update = $this->Server->update($status, $raw, $settings);\n            }\n            if ($this->_isRest()) {\n                return $this->RestResponse->viewData(array('results' => $raw), $this->response->type());\n            } else {\n                return new CakeResponse(array('body' => $update, 'type' => 'txt'));\n            }\n        } else {\n            $this->set('isUpdatePossible', $this->Server->isUpdatePossible());\n            $this->set('branch', $this->Server->getCurrentBranch());\n            $this->render('ajax/update');\n        }\n    }\n\n    public function ondemandAction()\n    {\n        $this->AdminSetting = ClassRegistry::init('AdminSetting');\n        $actions = $this->Server->actions_description;\n        $default_fields = array(\n            'title' => '',\n            'description' => '',\n            'liveOff' => false,\n            'recommendBackup' => false,\n            'exitOnError' => false,\n            'requirements' => '',\n            'url' => $this->baseurl . '/'\n        );\n        foreach($actions as $id => $action) {\n            foreach($default_fields as $field => $value) {\n                if (!isset($action[$field])) {\n                    $actions[$id][$field] = $value;\n                }\n            }\n            $done = $this->AdminSetting->getSetting($id);\n            $actions[$id]['done'] = ($done == '1');\n        }\n        $this->set('actions', $actions);\n        $this->set('updateLocked', $this->Server->isUpdateLocked());\n    }\n\n    public function updateProgress($ajaxHtml=false)\n    {\n        $this->AdminSetting = ClassRegistry::init('AdminSetting');\n        $dbVersion = $this->AdminSetting->getSetting('db_version');\n        $updateProgress = $this->Server->getUpdateProgress();\n        $updateProgress['db_version'] = $dbVersion;\n        $maxUpdateNumber = max(array_keys(Server::DB_CHANGES));\n        $updateProgress['complete_update_remaining'] = max($maxUpdateNumber - $dbVersion, 0);\n        $updateProgress['update_locked'] = $this->Server->isUpdateLocked();\n        $updateProgress['lock_remaining_time'] = $this->Server->getLockRemainingTime();\n        $updateProgress['update_fail_number_reached'] = $this->Server->UpdateFailNumberReached();\n        $currentIndex = $updateProgress['current'];\n        $currentCommand = !isset($updateProgress['commands'][$currentIndex]) ? '' : $updateProgress['commands'][$currentIndex];\n        $lookupString = preg_replace('/\\s{2,}/', '', substr($currentCommand, 0, -1));\n        $sqlInfo = $this->Server->query(\"SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST;\");\n        if (empty($sqlInfo)) {\n            $updateProgress['process_list'] = array();\n        } else {\n            // retrieve current update process\n            foreach($sqlInfo as $row) {\n                if (preg_replace('/\\s{2,}/', '', $row['PROCESSLIST']['INFO']) == $lookupString) {\n                    $sqlInfo = $row['PROCESSLIST'];\n                    break;\n                }\n            }\n            $updateProgress['process_list'] = array();\n            $updateProgress['process_list']['STATE'] = isset($sqlInfo['STATE']) ? $sqlInfo['STATE'] : '';\n            $updateProgress['process_list']['PROGRESS'] = isset($sqlInfo['PROGRESS']) ? $sqlInfo['PROGRESS'] : 0;\n            $updateProgress['process_list']['STAGE'] = isset($sqlInfo['STAGE']) ? $sqlInfo['STAGE'] : 0;\n            $updateProgress['process_list']['MAX_STAGE'] = isset($sqlInfo['MAX_STAGE']) ? $sqlInfo['MAX_STAGE'] : 0;\n        }\n        $this->set('ajaxHtml', $ajaxHtml);\n        if ($this->request->is('ajax') && $ajaxHtml) {\n            $this->set('updateProgress', $updateProgress);\n            $this->layout = false;\n        } elseif ($this->request->is('ajax') || $this->_isRest()) {\n            return $this->RestResponse->viewData(h($updateProgress), $this->response->type());\n        } else {\n            $this->set('updateProgress', $updateProgress);\n        }\n    }\n\n\n    public function getSubmoduleQuickUpdateForm($submodule_path=false) {\n        $this->set('submodule', base64_decode($submodule_path));\n        $this->render('ajax/submodule_quick_update_form');\n    }\n\n    public function updateSubmodule()\n    {\n        if ($this->request->is('post')) {\n            $request = $this->request->data;\n            $submodule = $request['Server']['submodule'];\n            $res = $this->Server->updateSubmodule($this->Auth->user(), $submodule);\n            return new CakeResponse(array('body'=> json_encode($res), 'type' => 'json'));\n        } else {\n            throw new MethodNotAllowedException();\n        }\n    }\n\n    public function getInstanceUUID()\n    {\n        return $this->RestResponse->viewData(array('uuid' => Configure::read('MISP.uuid')), $this->response->type());\n    }\n\n    public function cache($id = 'all')\n    {\n        if (Configure::read('MISP.background_jobs')) {\n\n            $this->loadModel('Job');\n            $jobId = $this->Job->createJob(\n                $this->Auth->user(),\n                Job::WORKER_DEFAULT,\n                'cache_servers',\n                intval($id) ? $id : 'all',\n                __('Starting server caching.')\n            );\n\n            $this->Server->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::DEFAULT_QUEUE,\n                BackgroundJobsTool::CMD_SERVER,\n                [\n                    'cacheServer',\n                    $this->Auth->user('id'),\n                    $id,\n                    $jobId\n                ],\n                false,\n                $jobId\n            );\n\n            $message = 'Server caching job initiated.';\n        } else {\n            $result = $this->Server->cacheServerInitiator($this->Auth->user(), $id);\n            if (!$result) {\n                $this->Flash->error(__('Caching the servers has failed.'));\n                $this->redirect(array('action' => 'index'));\n            }\n            $message = __('Caching the servers has successfully completed.');\n        }\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Server', 'cache', false, $this->response->type(), $message);\n        } else {\n            $this->Flash->info($message);\n            $this->redirect(array('action' => 'index'));\n        }\n    }\n\n    public function updateJSON()\n    {\n        $results = $this->Server->updateJSON();\n        return $this->RestResponse->viewData($results, $this->response->type());\n    }\n\n    public function createSync()\n    {\n        if ($this->_isSiteAdmin()) {\n            throw new MethodNotAllowedException('Site admin accounts cannot be used to create server sync configurations.');\n        }\n        $baseurl = Configure::read('MISP.external_baseurl');\n        if (empty($baseurl)) {\n            $baseurl = Configure::read('MISP.baseurl');\n            if (empty($baseurl)) {\n                $baseurl = Router::url('/', true);\n            }\n        }\n        $host_org_id = Configure::read('MISP.host_org_id');\n        if (empty($host_org_id)) {\n            throw new MethodNotAllowedException(__('Cannot create sync config - no host org ID configured for the instance.'));\n        }\n        $this->loadModel('Organisation');\n        $host_org = $this->Organisation->find('first', array(\n            'conditions' => array('Organisation.id' => $host_org_id),\n            'recursive' => -1,\n            'fields' => array('name', 'uuid')\n        ));\n        if (empty($host_org)) {\n            throw new MethodNotAllowedException(__('Configured host org not found. Please make sure that the setting is current on the instance.'));\n        }\n        if (Configure::read('Security.advanced_authkeys')) {\n            $this->loadModel('AuthKey');\n            $authkey = $this->AuthKey->createnewkey($this->Auth->user('id'), null, __('Auto generated sync key - %s', date('Y-m-d H:i:s')));\n        } else {\n            $this->loadModel('User');\n            $authkey = $this->User->find('column', [\n                'conditions' => ['User.id' => $this->Auth->user('id')],\n                'recursive' => -1,\n                'fields' => ['User.authkey']\n            ]);\n            $authkey = $authkey[0];\n        }\n        $server = array(\n            'Server' => array(\n                'url' => $baseurl,\n                'uuid' => Configure::read('MISP.uuid'),\n                'authkey' => h($authkey),\n                'Organisation' => array(\n                    'name' => $host_org['Organisation']['name'],\n                    'uuid' => $host_org['Organisation']['uuid'],\n                )\n            )\n        );\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($server, $this->response->type());\n        } else {\n            $this->set('server', $server);\n        }\n    }\n\n    public function import()\n    {\n        if ($this->request->is('post')) {\n            $server = $this->request->data;\n            if (isset($server['Server'])) {\n                $server = $server['Server'];\n            }\n            if (isset($server['json'])) {\n                $server = json_decode($server['json'], true)['Server'];\n            }\n            $this->loadModel('Organisation');\n            $org_id = $this->Organisation->captureOrg($server['Organisation'], $this->Auth->user());\n            $toSave = array(\n                'push' => 0,\n                'pull' => 0,\n                'caching_enabled' => 0,\n                'json' => '[]',\n                'push_rules' => '[]',\n                'pull_rules' => '[]',\n                'self_signed' => 0,\n                'org_id' => $this->Auth->user('org_id'),\n                'remote_org_id' => $org_id,\n                'name' => empty($server['name']) ? $server['url'] : $server['name'],\n                'url' => $server['url'],\n                'uuid' => $server['uuid'],\n                'authkey' => $server['authkey']\n            );\n            $this->Server->create();\n            $result = $this->Server->save($toSave);\n            if ($result) {\n                if ($this->_isRest()) {\n                    $server = $this->Server->find('first', array(\n                        'conditions' => array('Server.id' => $this->Server->id),\n                        'recursive' => -1\n                    ));\n                    return $this->RestResponse->viewData($server, $this->response->type());\n                } else {\n                    $this->Flash->success(__('The server has been saved'));\n                    $this->redirect(array('action' => 'index', $this->Server->id));\n                }\n            } else {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'addFromJson', false, $this->Server->validationErrors, $this->response->type());\n                } else {\n                    $this->Flash->error(__('Could not save the server. Error: %s', json_encode($this->Server->validationErrors, true)));\n                    $this->redirect(array('action' => 'index'));\n                }\n            }\n        }\n    }\n\n    public function resetRemoteAuthKey($id)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException(__('This endpoint expects POST requests.'));\n        }\n        $result = $this->Server->resetRemoteAuthkey($id);\n        if ($result !== true) {\n            if (!$this->_isRest()) {\n                $this->Flash->error($result);\n                $this->redirect(array('action' => 'index'));\n            } else {\n                return $this->RestResponse->saveFailResponse('Servers', 'resetRemoteAuthKey', $id, $message, $this->response->type());\n            }\n        } else {\n            $message = __('API key updated.');\n            if (!$this->_isRest()) {\n                $this->Flash->success($message);\n                $this->redirect(array('action' => 'index'));\n            } else {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'resetRemoteAuthKey', $message, $this->response->type());\n            }\n        }\n    }\n\n    public function changePriority($id = false, $direction = 'down')\n    {\n        $this->Server->id = $id;\n        if (!$this->Server->exists()) {\n            throw new InvalidArgumentException(__('ID has to be a valid server connection'));\n        }\n        if ($direction !== 'up' && $direction !== 'down') {\n            throw new InvalidArgumentException(__('Invalid direction. Valid options: ', 'up', 'down'));\n        }\n        $success = $this->Server->reprioritise($id, $direction);\n        if ($success) {\n            $message = __('Priority changed.');\n            return $this->RestResponse->saveSuccessResponse('Servers', 'changePriority', $message, $this->response->type());\n        } else {\n            $message = __('Priority could not be changed.');\n            return $this->RestResponse->saveFailResponse('Servers', 'changePriority', $id, $message, $this->response->type());\n        }\n    }\n\n    public function releaseUpdateLock()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException(__('This endpoint expects POST requests.'));\n        }\n        $this->Server->changeLockState(false);\n        $this->Server->resetUpdateFailNumber();\n        $this->redirect(array('action' => 'updateProgress'));\n    }\n\n    public function dbSchemaDiagnostic()\n    {\n        $dbSchemaDiagnostics = $this->Server->dbSchemaDiagnostic();\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($dbSchemaDiagnostics, $this->response->type());\n        } else {\n            $this->set('checkedTableColumn', $dbSchemaDiagnostics['checked_table_column']);\n            $this->set('dbSchemaDiagnostics', $dbSchemaDiagnostics['diagnostic']);\n            $this->set('dbIndexDiagnostics', $dbSchemaDiagnostics['diagnostic_index']);\n            $this->set('expectedDbVersion', $dbSchemaDiagnostics['expected_db_version']);\n            $this->set('actualDbVersion', $dbSchemaDiagnostics['actual_db_version']);\n            $this->set('error', $dbSchemaDiagnostics['error']);\n            $this->set('remainingLockTime', $dbSchemaDiagnostics['remaining_lock_time']);\n            $this->set('updateFailNumberReached', $dbSchemaDiagnostics['update_fail_number_reached']);\n            $this->set('updateLocked', $dbSchemaDiagnostics['update_locked']);\n            $this->set('dataSource', $dbSchemaDiagnostics['dataSource']);\n            $this->set('columnPerTable', $dbSchemaDiagnostics['columnPerTable']);\n            $this->set('indexes', $dbSchemaDiagnostics['indexes']);\n            $this->render('/Elements/healthElements/db_schema_diagnostic');\n        }\n    }\n\n    public function dbConfiguration()\n    {\n        $dbConfiguration = $this->Server->dbConfiguration();\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($dbConfiguration, $this->response->type());\n        } else {\n            $this->set('dbConfiguration', $dbConfiguration);\n            $this->render('/Elements/healthElements/db_config_diagnostic');\n        }\n    }\n\n    public function cspReport()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException('This action expects a POST request.');\n        }\n\n        $report = JsonTool::decode($this->request->input());\n        if (!isset($report['csp-report'])) {\n            throw new RuntimeException(\"Invalid report\");\n        }\n\n        $message = 'CSP reported violation';\n        $remoteIp = $this->_remoteIp();\n        if ($remoteIp) {\n            $message .= ' from IP ' . $remoteIp;\n        }\n        $report = JsonTool::encode($report['csp-report'], true);\n        if (strlen($report) > 1024 * 1024) { // limit report to 1 kB\n            $report = substr($report, 0, 1024 * 1024) . '...';\n        }\n        $this->log(\"$message: $report\");\n\n        return new CakeResponse(['status' => 204]);\n    }\n\n    /**\n     * List all tags for the rule picker.\n     *\n     * @return array\n     */\n    private function __getTags()\n    {\n        $this->loadModel('Tag');\n        $list = $this->Tag->find('list', array(\n            'recursive' => -1,\n            'order' => array('LOWER(TRIM(Tag.name))' => 'ASC'),\n            'fields' => array('name'),\n        ));\n        $allTags = array();\n        foreach ($list as $id => $name) {\n            $allTags[] = array('id' => $id, 'name' => trim($name));\n        }\n        return $allTags;\n    }\n\n    public function removeOrphanedCorrelations()\n    {\n        $count = $this->Server->removeOrphanedCorrelations();\n        $message = __('%s orphaned correlation removed', $count);\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($message, $this->response->type());\n        } else {\n            $this->Flash->success($message);\n            $this->redirect(array('action' => 'serverSettings', 'diagnostics'));\n        }\n    }\n\n    public function queryAvailableSyncFilteringRules($serverID)\n    {\n        if (!$this->_isRest()) {\n            throw new MethodNotAllowedException(__('This method can only be access via REST'));\n        }\n        $server = $this->Server->find('first', ['conditions' => ['Server.id' => $serverID]]);\n        if (!$server) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $syncFilteringRules = $this->Server->queryAvailableSyncFilteringRules($server);\n        return $this->RestResponse->viewData($syncFilteringRules);\n    }\n\n    public function getAvailableSyncFilteringRules()\n    {\n        if (!$this->_isRest()) {\n            throw new MethodNotAllowedException(__('This method can only be access via REST'));\n        }\n        $syncFilteringRules = $this->Server->getAvailableSyncFilteringRules($this->Auth->user());\n        return $this->RestResponse->viewData($syncFilteringRules);\n    }\n\n    public function pruneDuplicateUUIDs()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        $this->loadModel('Attribute');\n        $duplicates = $this->Attribute->find('all', array(\n            'fields' => array('Attribute.uuid', 'count(*) as occurance'),\n            'recursive' => -1,\n            'group' => array('Attribute.uuid HAVING COUNT(*) > 1'),\n        ));\n        $counter = 0;\n        foreach ($duplicates as $duplicate) {\n            $attributes = $this->Attribute->find('all', array(\n                'recursive' => -1,\n                'conditions' => array('uuid' => $duplicate['Attribute']['uuid'])\n            ));\n            foreach ($attributes as $k => $attribute) {\n                if ($k > 0) {\n                    $this->Attribute->delete($attribute['Attribute']['id']);\n                    $counter++;\n                }\n            }\n        }\n        $this->Server->updateDatabase('makeAttributeUUIDsUnique');\n        $this->Flash->success('Done. Deleted ' . $counter . ' duplicate attribute(s).');\n        $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n    }\n\n    public function removeDuplicateEvents()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        $this->loadModel('Event');\n        $duplicates = $this->Event->find('all', array(\n            'fields' => array('Event.uuid', 'count(*) as occurance'),\n            'recursive' => -1,\n            'group' => array('Event.uuid HAVING COUNT(*) > 1'),\n        ));\n        $counter = 0;\n\n        // load this so we can remove the blocklist item that will be created, this is the one case when we do not want it.\n        if (Configure::read('MISP.enableEventBlocklisting') !== false) {\n            $this->EventBlocklist = ClassRegistry::init('EventBlocklist');\n        }\n\n        foreach ($duplicates as $duplicate) {\n            $events = $this->Event->find('all', array(\n                'recursive' => -1,\n                'conditions' => array('uuid' => $duplicate['Event']['uuid'])\n            ));\n            foreach ($events as $k => $event) {\n                if ($k > 0) {\n                    $uuid = $event['Event']['uuid'];\n                    $this->Event->delete($event['Event']['id']);\n                    $counter++;\n                    // remove the blocklist entry that we just created with the event deletion, if the feature is enabled\n                    // We do not want to block the UUID, since we just deleted a copy\n                    if (Configure::read('MISP.enableEventBlocklisting') !== false) {\n                        $this->EventBlocklist->deleteAll(array('EventBlocklist.event_uuid' => $uuid));\n                    }\n                }\n            }\n        }\n        $this->Server->updateDatabase('makeEventUUIDsUnique');\n        $this->Flash->success('Done. Removed ' . $counter . ' duplicate events.');\n        $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n    }\n\n    public function upgrade2324()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        if (!Configure::read('MISP.background_jobs')) {\n            $this->Server->upgrade2324($this->Auth->user('id'));\n            $this->Flash->success('Done. For more details check the audit logs.');\n            $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n        } else {\n\n            $this->loadModel('Job');\n            $jobId = $this->Job->createJob(\n                $this->Auth->user(),\n                Job::WORKER_DEFAULT,\n                'upgrade_24',\n                'Old database',\n                __('Job created.')\n            );\n\n            $this->Server->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::DEFAULT_QUEUE,\n                BackgroundJobsTool::CMD_ADMIN,\n                [\n                    'jobUpgrade24',\n                    $jobId,\n                    $this->Auth->user('id'),\n                ],\n                true,\n                $jobId\n            );\n\n            $this->Flash->success(__('Job queued. You can view the progress if you navigate to the active jobs view (administration -> jobs).'));\n            $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n        }\n    }\n\n    public function cleanModelCaches()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        $this->Server->cleanCacheFiles();\n        $this->Flash->success('Caches cleared.');\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'diagnostics'));\n    }\n\n    public function updateDatabase($command)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        if (is_numeric($command)) {\n            $command = intval($command);\n        }\n        $this->Server->updateDatabase($command);\n        $this->Flash->success('Done.');\n        if ($liveOff) {\n            $this->redirect(array('controller' => 'servers', 'action' => 'updateProgress'));\n        } else {\n            $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n        }\n    }\n\n    public function ipUser($input = false)\n    {\n        $params = $this->IndexFilter->harvestParameters(['ip']);\n        if (!empty($params['ip'])) {\n            $input = $params['ip'];\n        }\n        $redis = $this->Server->setupRedis();\n        if (!is_array($input)) {\n            $input = [$input];\n        }\n        $users = [];\n        foreach ($input as $ip) {\n            if (!filter_var($ip, FILTER_VALIDATE_IP)) {\n                continue;\n            }\n            $user_id = $redis->get('misp:ip_user:' . $ip);\n            if (empty($user_id)) {\n                continue;\n            }\n            $this->loadModel('User');\n            $user = $this->User->find('first', [\n                'recursive' => -1,\n                'conditions' => ['User.id' => $user_id],\n                'contain' => ['Organisation.name']\n            ]);\n            if (empty($user)) {\n                throw new NotFoundException(__('User not found (perhaps it has been removed?).'));\n            }\n            $users[$ip] = [\n                'id' => $user['User']['id'],\n                'email' => $user['User']['email'],\n            ];\n        }\n        return $this->RestResponse->viewData($users, $this->response->type());\n    }\n\n    /**\n     * @deprecated\n     * @return void\n     */\n    public function rest()\n    {\n        $this->redirect(['controller' => 'api', 'action' => 'rest']);\n    }\n}\n", "<?php\n\nclass SyncTool\n{\n    /**\n     * Take a server as parameter and return a HttpSocket object using the ssl options defined in the server settings\n     * @param array|null $server\n     * @param false $timeout\n     * @param string $model\n     * @return HttpSocketExtended\n     * @throws Exception\n     */\n    public function setupHttpSocket($server = null, $timeout = false, $model = 'Server')\n    {\n        $params = ['compress' => true];\n        if (!empty($server)) {\n            if (!empty($server[$model]['cert_file'])) {\n                $params['ssl_cafile'] = APP . \"files\" . DS . \"certs\" . DS . $server[$model]['id'] . '.pem';\n            }\n            if (!empty($server[$model]['client_cert_file'])) {\n                $params['ssl_local_cert'] = APP . \"files\" . DS . \"certs\" . DS . $server[$model]['id'] . '_client.pem';\n            }\n            if (!empty($server[$model]['self_signed'])) {\n                $params['ssl_allow_self_signed'] = true;\n                $params['ssl_verify_peer_name'] = false;\n                if (!isset($server[$model]['cert_file'])) {\n                    $params['ssl_verify_peer'] = false;\n                }\n            }\n            if (!empty($server[$model]['skip_proxy'])) {\n                $params['skip_proxy'] = 1;\n            }\n            if (!empty($timeout)) {\n                $params['timeout'] = $timeout;\n            }\n        }\n\n        return $this->createHttpSocket($params);\n    }\n\n    public function setupHttpSocketFeed()\n    {\n        return $this->createHttpSocket(['compress' => true]);\n    }\n\n    /**\n     * @param array $params\n     * @return HttpSocketExtended\n     * @throws Exception\n     */\n    public function createHttpSocket($params = array())\n    {\n        // Use own CA PEM file\n        $caPath = Configure::read('MISP.ca_path');\n        if (!isset($params['ssl_cafile']) && $caPath) {\n            if (!file_exists($caPath)) {\n                throw new Exception(\"CA file '$caPath' doesn't exists.\");\n            }\n            $params['ssl_cafile'] = $caPath;\n        }\n\n        if ($minTlsVersion = Configure::read('Security.min_tls_version')) {\n            $version = 0;\n            switch ($minTlsVersion) {\n                case 'tlsv1_0':\n                    $version |= STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT;\n                case 'tlsv1_1':\n                    $version |= STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT;\n                case 'tlsv1_2':\n                    $version |= STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT;\n                case 'tlsv1_3':\n                    if (defined('STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT')) {\n                        $version |= STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT;\n                    } else if ($minTlsVersion === 'tlsv1_3') {\n                        throw new Exception(\"TLSv1.3 is not supported by PHP.\");\n                    }\n                    break;\n                default:\n                    throw new InvalidArgumentException(\"Invalid `Security.min_tls_version` option $minTlsVersion\");\n            }\n            $params['ssl_crypto_method'] = $version;\n        }\n\n        App::uses('HttpSocketExtended', 'Tools');\n        $HttpSocket = new HttpSocketExtended($params);\n        $proxy = Configure::read('Proxy');\n        if (empty($params['skip_proxy']) && isset($proxy['host']) && !empty($proxy['host'])) {\n            $HttpSocket->configProxy($proxy['host'], $proxy['port'], $proxy['method'], $proxy['user'], $proxy['password']);\n        }\n        return $HttpSocket;\n    }\n\n    /**\n     * @param array $server\n     * @return array|void\n     * @throws Exception\n     */\n    public static function getServerClientCertificateInfo(array $server)\n    {\n        if (!$server['Server']['client_cert_file']) {\n            return;\n        }\n\n        $clientCertificate = new File(APP . \"files\" . DS . \"certs\" . DS . $server['Server']['id'] . '_client.pem');\n        if (!$clientCertificate->exists()) {\n            throw new Exception(\"Certificate file '{$clientCertificate->pwd()}' doesn't exists.\");\n        }\n\n        $certificateContent = $clientCertificate->read();\n        if ($certificateContent === false) {\n            throw new Exception(\"Could not read '{$clientCertificate->pwd()}' file with client certificate.\");\n        }\n\n        return self::getClientCertificateInfo($certificateContent);\n    }\n\n    /**\n     * @param array $server\n     * @return array|void\n     * @throws Exception\n     */\n    public static function getServerCaCertificateInfo(array $server)\n    {\n        if (!$server['Server']['cert_file']) {\n            return;\n        }\n\n        $caCertificate = new File(APP . \"files\" . DS . \"certs\" . DS . $server['Server']['id'] . '.pem');\n        if (!$caCertificate->exists()) {\n            throw new Exception(\"Certificate file '{$caCertificate->pwd()}' doesn't exists.\");\n        }\n\n        $certificateContent = $caCertificate->read();\n        if ($certificateContent === false) {\n            throw new Exception(\"Could not read '{$caCertificate->pwd()}' file with certificate.\");\n        }\n\n        $certificate = openssl_x509_read($certificateContent);\n        if (!$certificate) {\n            throw new Exception(\"Couldn't read certificate: \" . openssl_error_string());\n        }\n\n        return self::parseCertificate($certificate);\n    }\n\n    /**\n     * @param string $certificateContent PEM encoded certificate and private key.\n     * @return array\n     * @throws Exception\n     */\n    private static function getClientCertificateInfo($certificateContent)\n    {\n        $certificate = openssl_x509_read($certificateContent);\n        if (!$certificate) {\n            throw new Exception(\"Couldn't read certificate: \" . openssl_error_string());\n        }\n        $privateKey = openssl_pkey_get_private($certificateContent);\n        if (!$privateKey) {\n            throw new Exception(\"Couldn't get private key from certificate: \" . openssl_error_string());\n        }\n        $verify = openssl_x509_check_private_key($certificate, $privateKey);\n        if (!$verify) {\n            throw new Exception('Public and private key do not match.');\n        }\n        return self::parseCertificate($certificate);\n    }\n\n    /**\n     * @param mixed $certificate\n     * @return array\n     * @throws Exception\n     */\n    private static function parseCertificate($certificate)\n    {\n        $parsed = openssl_x509_parse($certificate);\n        if (!$parsed) {\n            throw new Exception(\"Couldn't get parse X.509 certificate: \" . openssl_error_string());\n        }\n        $currentTime = new DateTime();\n        $output = [\n            'serial_number' => $parsed['serialNumberHex'],\n            'signature_type' => $parsed['signatureTypeSN'],\n            'valid_from' => isset($parsed['validFrom_time_t']) ? new DateTime(\"@{$parsed['validFrom_time_t']}\") : null,\n            'valid_to' => isset($parsed['validTo_time_t']) ? new DateTime(\"@{$parsed['validTo_time_t']}\") : null,\n            'public_key_size' => null,\n            'public_key_type' => null,\n            'public_key_size_ok' => null,\n        ];\n\n        $output['valid_from_ok'] = $output['valid_from'] ? ($output['valid_from'] <= $currentTime) : null;\n        $output['valid_to_ok'] = $output['valid_to'] ? ($output['valid_to'] >= $currentTime) : null;\n\n        $subject = [];\n        foreach ($parsed['subject'] as $type => $value) {\n            $subject[] = \"$type=$value\";\n        }\n        $output['subject'] = implode(', ', $subject);\n\n        $issuer = [];\n        foreach ($parsed['issuer'] as $type => $value) {\n            $issuer[] = \"$type=$value\";\n        }\n        $output['issuer'] = implode(', ', $issuer);\n\n        $publicKey = openssl_pkey_get_public($certificate);\n        if ($publicKey) {\n            $publicKeyDetails = openssl_pkey_get_details($publicKey);\n            if ($publicKeyDetails) {\n                $output['public_key_size'] = $publicKeyDetails['bits'];\n                switch ($publicKeyDetails['type']) {\n                    case OPENSSL_KEYTYPE_RSA:\n                        $output['public_key_type'] = 'RSA';\n                        $output['public_key_size_ok'] = $output['public_key_size'] >= 2048;\n                        break;\n                    case OPENSSL_KEYTYPE_DSA:\n                        $output['public_key_type'] = 'DSA';\n                        $output['public_key_size_ok'] = $output['public_key_size'] >= 2048;\n                        break;\n                    case OPENSSL_KEYTYPE_DH:\n                        $output['public_key_type'] = 'DH';\n                        break;\n                    case OPENSSL_KEYTYPE_EC:\n                        $output['public_key_type'] = \"EC ({$publicKeyDetails['ec']['curve_name']})\";\n                        $output['public_key_size_ok'] = $output['public_key_size'] >= 224;\n                        break;\n                }\n            }\n        }\n\n        return $output;\n    }\n}\n"], "fixing_code": ["<?php\nApp::uses('AppController', 'Controller');\nApp::uses('Xml', 'Utility');\nApp::uses('AttachmentTool', 'Tools');\nApp::uses('JsonTool', 'Tools');\nApp::uses('SecurityAudit', 'Tools');\n\n/**\n * @property Server $Server\n */\nclass ServersController extends AppController\n{\n    public $components = array('RequestHandler');   // XXX ACL component\n\n    public $paginate = array(\n        'limit' => 60,\n        'recursive' => -1,\n        'contain' => array(\n            'User' => array(\n                'fields' => array('User.id', 'User.org_id', 'User.email'),\n            ),\n            'Organisation' => array(\n                'fields' => array('Organisation.name', 'Organisation.id'),\n            ),\n            'RemoteOrg' => array(\n                'fields' => array('RemoteOrg.name', 'RemoteOrg.id'),\n            ),\n        ),\n        'maxLimit' => 9999,\n        'order' => array(\n            'Server.priority' => 'ASC'\n        ),\n    );\n\n    public $uses = array('Server', 'Event');\n\n    public function beforeFilter()\n    {\n        $this->Auth->allow(['cspReport']); // cspReport must work without authentication\n\n        parent::beforeFilter();\n        $this->Security->unlockedActions[] = 'cspReport';\n        // permit reuse of CSRF tokens on some pages.\n        switch ($this->request->params['action']) {\n            case 'push':\n            case 'pull':\n            case 'getVersion':\n            case 'testConnection':\n                $this->Security->csrfUseOnce = false;\n        }\n    }\n\n    public function index()\n    {\n        // Do not fetch server authkey from DB\n        $fields = $this->Server->schema();\n        unset($fields['authkey']);\n        $fields = array_keys($fields);\n\n        $filters = $this->IndexFilter->harvestParameters(['search']);\n        $conditions = [];\n        if (!empty($filters['search'])) {\n            $strSearch = '%' . trim(strtolower($filters['search'])) . '%';\n            $conditions['OR'][]['LOWER(Server.name) LIKE'] = $strSearch;\n            $conditions['OR'][]['LOWER(Server.url) LIKE'] = $strSearch;\n        }\n\n        if ($this->_isRest()) {\n            $params = array(\n                'fields' => $fields,\n                'recursive' => -1,\n                'contain' => array(\n                    'User' => array(\n                        'fields' => array('User.id', 'User.org_id', 'User.email'),\n                    ),\n                    'Organisation' => array(\n                        'fields' => array('Organisation.id', 'Organisation.name', 'Organisation.uuid', 'Organisation.nationality', 'Organisation.sector', 'Organisation.type'),\n                    ),\n                    'RemoteOrg' => array(\n                        'fields' => array('RemoteOrg.id', 'RemoteOrg.name', 'RemoteOrg.uuid', 'RemoteOrg.nationality', 'RemoteOrg.sector', 'RemoteOrg.type'),\n                    ),\n                ),\n                'conditions' => $conditions,\n            );\n            $servers = $this->Server->find('all', $params);\n            $servers = $this->Server->attachServerCacheTimestamps($servers);\n            return $this->RestResponse->viewData($servers, $this->response->type());\n        } else {\n            $this->paginate['fields'] = $fields;\n            $this->paginate['conditions'] = $conditions;\n            $servers = $this->paginate();\n            $servers = $this->Server->attachServerCacheTimestamps($servers);\n            $this->set('servers', $servers);\n            $collection = array();\n            $collection['orgs'] = $this->Server->Organisation->find('list', array(\n                  'fields' => array('id', 'name'),\n            ));\n            $this->loadModel('Tag');\n            $collection['tags'] = $this->Tag->find('list', array(\n                  'fields' => array('id', 'name'),\n            ));\n            $this->set('collection', $collection);\n        }\n    }\n\n    public function previewIndex($id)\n    {\n        $urlparams = '';\n        $passedArgs = array();\n\n        $server = $this->Server->find('first', array('conditions' => array('Server.id' => $id), 'recursive' => -1));\n        if (empty($server)) {\n            throw new NotFoundException('Invalid server ID.');\n        }\n        $validFilters = $this->Server->validEventIndexFilters;\n        foreach ($validFilters as $k => $filter) {\n            if (isset($this->passedArgs[$filter])) {\n                $passedArgs[$filter] = $this->passedArgs[$filter];\n                if ($k != 0) {\n                    $urlparams .= '/';\n                }\n                $urlparams .= $filter . ':' . $this->passedArgs[$filter];\n            }\n        }\n        $combinedArgs = array_merge($this->passedArgs, $passedArgs);\n        if (!isset($combinedArgs['sort'])) {\n            $combinedArgs['sort'] = 'timestamp';\n            $combinedArgs['direction'] = 'desc';\n        }\n        if (empty($combinedArgs['page'])) {\n            $combinedArgs['page'] = 1;\n        }\n        if (empty($combinedArgs['limit'])) {\n            $combinedArgs['limit'] = 60;\n        }\n        try {\n            list($events, $total_count) = $this->Server->previewIndex($server, $this->Auth->user(), $combinedArgs);\n        } catch (Exception $e) {\n            if ($this->_isRest()) {\n                return $this->RestResponse->throwException(500, $e->getMessage());\n            } else {\n                $this->Flash->error(__('Download failed.') . ' ' . $e->getMessage());\n                $this->redirect(array('action' => 'index'));\n            }\n        }\n\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($events, $this->response->type());\n        }\n\n        $this->loadModel('Event');\n        $this->set('threatLevels', $this->Event->ThreatLevel->listThreatLevels());\n        App::uses('CustomPaginationTool', 'Tools');\n        $customPagination = new CustomPaginationTool();\n        $params = $customPagination->createPaginationRules($events, $this->passedArgs, $this->alias);\n        if (!empty($total_count)) {\n            $params['pageCount'] = ceil($total_count / $params['limit']);\n        }\n        $this->params->params['paging'] = array($this->modelClass => $params);\n        if (count($events) > 60) {\n            $customPagination->truncateByPagination($events, $params);\n        }\n        $this->set('events', $events);\n        $this->set('eventDescriptions', $this->Event->fieldDescriptions);\n        $this->set('analysisLevels', $this->Event->analysisLevels);\n        $this->set('distributionLevels', $this->Event->distributionLevels);\n\n        $shortDist = array(0 => 'Organisation', 1 => 'Community', 2 => 'Connected', 3 => 'All', 4 => ' sharing Group');\n        $this->set('shortDist', $shortDist);\n        $this->set('id', $id);\n        $this->set('urlparams', $urlparams);\n        $this->set('passedArgs', json_encode($passedArgs));\n        $this->set('passedArgsArray', $passedArgs);\n        $this->set('server', $server);\n    }\n\n    public function previewEvent($serverId, $eventId, $all = false)\n    {\n        $server = $this->Server->find('first', array(\n            'conditions' => array('Server.id' => $serverId),\n            'recursive' => -1,\n        ));\n        if (empty($server)) {\n            throw new NotFoundException('Invalid server ID.');\n        }\n        try {\n            $event = $this->Server->previewEvent($server, $eventId);\n        } catch (NotFoundException $e) {\n            throw new NotFoundException(__(\"Event '%s' not found.\", $eventId));\n        } catch (Exception $e) {\n            $this->Flash->error(__('Download failed. %s', $e->getMessage()));\n            $this->redirect(array('action' => 'previewIndex', $serverId));\n        }\n\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($event, $this->response->type());\n        }\n\n        $this->loadModel('Warninglist');\n        if (isset($event['Event']['Attribute'])) {\n            $this->Warninglist->attachWarninglistToAttributes($event['Event']['Attribute']);\n        }\n        if (isset($event['Event']['ShadowAttribute'])) {\n            $this->Warninglist->attachWarninglistToAttributes($event['Event']['ShadowAttribute']);\n        }\n\n        $this->loadModel('Event');\n        $params = $this->Event->rearrangeEventForView($event, $this->passedArgs, $all);\n        $this->__removeGalaxyClusterTags($event);\n        $this->params->params['paging'] = array('Server' => $params);\n        $this->set('event', $event);\n        $this->set('server', $server);\n        $dataForView = array(\n                'Attribute' => array('attrDescriptions' => 'fieldDescriptions', 'distributionDescriptions' => 'distributionDescriptions', 'distributionLevels' => 'distributionLevels'),\n                'Event' => array('eventDescriptions' => 'fieldDescriptions', 'analysisLevels' => 'analysisLevels'),\n                'Object' => array()\n        );\n        foreach ($dataForView as $m => $variables) {\n            if ($m === 'Event') {\n                $currentModel = $this->Event;\n            } elseif ($m === 'Attribute') {\n                $currentModel = $this->Event->Attribute;\n            } elseif ($m === 'Object') {\n                $currentModel = $this->Event->Object;\n            }\n            foreach ($variables as $alias => $variable) {\n                $this->set($alias, $currentModel->{$variable});\n            }\n        }\n        $this->set('threatLevels', $this->Event->ThreatLevel->listThreatLevels());\n        $this->set('title_for_layout', __('Remote event preview'));\n    }\n\n    private function __removeGalaxyClusterTags(array &$event)\n    {\n        $galaxyTagIds = [];\n        foreach ($event['Galaxy'] as $galaxy) {\n            foreach ($galaxy['GalaxyCluster'] as $galaxyCluster) {\n                $galaxyTagIds[$galaxyCluster['tag_id']] = true;\n            }\n        }\n\n        if (empty($galaxyTagIds)) {\n            return;\n        }\n\n        foreach ($event['Tag'] as $k => $eventTag) {\n            if (isset($galaxyTagIds[$eventTag['id']])) {\n                unset($event['Tag'][$k]);\n            }\n        }\n    }\n\n    public function compareServers()\n    {\n        list($servers, $overlap) = $this->Server->serverEventsOverlap();\n        $this->set('servers', $servers);\n        $this->set('overlap', $overlap);\n        $this->set('title_for_layout', __('Server overlap analysis matrix'));\n    }\n\n    public function filterEventIndex($id)\n    {\n        if (!$this->_isSiteAdmin()) {\n            throw new MethodNotAllowedException('You are not authorised to do that.');\n        }\n        $validFilters = $this->Server->validEventIndexFilters;\n        $validatedFilterString = '';\n        foreach ($this->passedArgs as $k => $v) {\n            if (in_array('' . $k, $validFilters)) {\n                if ($validatedFilterString != '') {\n                    $validatedFilterString .= '/';\n                }\n                $validatedFilterString .= $k . ':' . $v;\n            }\n        }\n        $this->set('id', $id);\n        $this->set('validFilters', $validFilters);\n        $this->set('filter', $validatedFilterString);\n    }\n\n    public function add()\n    {\n        if ($this->request->is('post')) {\n            if ($this->_isRest()) {\n                if (!isset($this->request->data['Server'])) {\n                    $this->request->data = array('Server' => $this->request->data);\n                }\n            }\n            if (!empty($this->request->data['Server']['json'])) {\n                $json = json_decode($this->request->data['Server']['json'], true);\n            } elseif ($this->_isRest()) {\n                if (empty($this->request->data['Server']['remote_org_id'])) {\n                    throw new MethodNotAllowedException('No remote org ID set. Please pass it as remote_org_id');\n                }\n            }\n            $fail = false;\n            if (empty(Configure::read('MISP.host_org_id'))) {\n                $this->request->data['Server']['internal'] = 0;\n            }\n            // test the filter fields\n            if (!empty($this->request->data['Server']['pull_rules']) && !JsonTool::isValid($this->request->data['Server']['pull_rules'])) {\n                $fail = true;\n                $error_msg = __('The pull filter rules must be in valid JSON format.');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'add', false, array('pull_rules' => $error_msg), $this->response->type());\n                } else {\n                    $this->Flash->error($error_msg);\n                }\n            }\n\n            if (!$fail && !empty($this->request->data['Server']['push_rules']) && !JsonTool::isValid($this->request->data['Server']['push_rules'])) {\n                $fail = true;\n                $error_msg = __('The push filter rules must be in valid JSON format.');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'add', false, array('push_rules' => $error_msg), $this->response->type());\n                } else {\n                    $this->Flash->error($error_msg);\n                }\n            }\n            if (!$fail) {\n                if ($this->_isRest()) {\n                    $defaultPushRules = json_encode([\"tags\" => [\"OR\" => [], \"NOT\" => []], \"orgs\" => [\"OR\" => [], \"NOT\" => []]]);\n                    $defaultPullRules = json_encode([\"tags\" => [\"OR\" => [], \"NOT\" => []], \"orgs\" => [\"OR\" => [], \"NOT\" => []], \"type_attributes\" => [\"NOT\" => []], \"type_objects\" => [\"NOT\" => []], \"url_params\" => \"\"]);\n                    $defaults = array(\n                        'push' => 0,\n                        'pull' => 0,\n                        'push_sightings' => 0,\n                        'push_galaxy_clusters' => 0,\n                        'pull_galaxy_clusters' => 0,\n                        'caching_enabled' => 0,\n                        'json' => '[]',\n                        'push_rules' => $defaultPushRules,\n                        'pull_rules' => $defaultPullRules,\n                        'self_signed' => 0,\n                        'remove_missing_tags' => 0\n                    );\n                    foreach ($defaults as $default => $dvalue) {\n                        if (!isset($this->request->data['Server'][$default])) {\n                            $this->request->data['Server'][$default] = $dvalue;\n                        }\n                    }\n                }\n                // force check userid and orgname to be from yourself\n                $this->request->data['Server']['org_id'] = $this->Auth->user('org_id');\n                if ($this->_isRest()) {\n                    if (empty($this->request->data['Server']['remote_org_id'])) {\n                        return $this->RestResponse->saveFailResponse('Servers', 'add', false, array('Organisation' => 'Remote Organisation\\'s id/uuid not given (remote_org_id)'), $this->response->type());\n                    }\n                    if (Validation::uuid($this->request->data['Server']['remote_org_id'])) {\n                        $orgCondition = array('uuid' => $this->request->data['Server']['remote_org_id']);\n                    } else {\n                        $orgCondition = array('id' => $this->request->data['Server']['remote_org_id']);\n                    }\n                    $existingOrgs = $this->Server->Organisation->find('first', array(\n                            'conditions' => $orgCondition,\n                            'recursive' => -1,\n                            'fields' => array('id', 'uuid')\n                    ));\n                    if (empty($existingOrgs)) {\n                        return $this->RestResponse->saveFailResponse('Servers', 'add', false, array('Organisation' => 'Invalid Remote Organisation'), $this->response->type());\n                    }\n                } else {\n                    if ($this->request->data['Server']['organisation_type'] < 2) {\n                        $this->request->data['Server']['remote_org_id'] = $json['id'];\n                    } else {\n                        $existingOrgs = $this->Server->Organisation->find('first', array(\n                                'conditions' => array('uuid' => $json['uuid']),\n                                'recursive' => -1,\n                                'fields' => array('id', 'uuid')\n                        ));\n                        if (!empty($existingOrgs)) {\n                            $fail = true;\n                            $this->Flash->error(__('That organisation could not be created as the uuid is in use already.'));\n                        }\n                        if (!$fail) {\n                            $this->Server->Organisation->create();\n                            $orgSave = $this->Server->Organisation->save(array(\n                                    'name' => $json['name'],\n                                    'uuid' => $json['uuid'],\n                                    'local' => 0,\n                                    'created_by' => $this->Auth->user('id')\n                            ));\n\n                            if (!$orgSave) {\n                                $this->Flash->error(__('Couldn\\'t save the new organisation, are you sure that the uuid is in the correct format? Also, make sure the organisation\\'s name doesn\\'t clash with an existing one.'));\n                                $fail = true;\n                                $this->request->data['Server']['external_name'] = $json['name'];\n                                $this->request->data['Server']['external_uuid'] = $json['uuid'];\n                            } else {\n                                $this->request->data['Server']['remote_org_id'] = $this->Server->Organisation->id;\n                                $this->request->data['Server']['organisation_type'] = 1;\n                            }\n                        }\n                    }\n                }\n                if (!$fail) {\n                    if (Configure::read('MISP.host_org_id') == 0 || $this->request->data['Server']['remote_org_id'] != Configure::read('MISP.host_org_id')) {\n                        $this->request->data['Server']['internal'] = 0;\n                    }\n                    $this->request->data['Server']['org_id'] = $this->Auth->user('org_id');\n                    if (empty($this->request->data['Server']['push_rules'])) {\n                        $this->request->data['Server']['push_rules'] = $defaultPushRules;\n                    }\n                    if (empty($this->request->data['Server']['pull_rules'])) {\n                        $this->request->data['Server']['pull_rules'] = $defaultPullRules;\n                    }\n                    if ($this->Server->save($this->request->data)) {\n                        if (isset($this->request->data['Server']['submitted_cert'])) {\n                            $this->__saveCert($this->request->data, $this->Server->id, false);\n                        }\n                        if (isset($this->request->data['Server']['submitted_client_cert'])) {\n                            $this->__saveCert($this->request->data, $this->Server->id, true);\n                        }\n                        if ($this->_isRest()) {\n                            $server = $this->Server->find('first', array(\n                                    'conditions' => array('Server.id' => $this->Server->id),\n                                    'recursive' => -1\n                            ));\n                            return $this->RestResponse->viewData($server, $this->response->type());\n                        } else {\n                            $this->Flash->success(__('The server has been saved'));\n                            $this->redirect(array('action' => 'index'));\n                        }\n                    } else {\n                        if ($this->_isRest()) {\n                            return $this->RestResponse->saveFailResponse('Servers', 'add', false, $this->Server->validationErrors, $this->response->type());\n                        } else {\n                            $this->Flash->error(__('The server could not be saved. Please, try again.'));\n                        }\n                    }\n                }\n            }\n        }\n        if ($this->_isRest()) {\n            return $this->RestResponse->describe('Servers', 'add', false, $this->response->type());\n        } else {\n            $organisationOptions = array(0 => 'Local organisation', 1 => 'External organisation', 2 => 'New external organisation');\n\n            $temp = $this->Server->Organisation->find('all', array(\n                'fields' => array('id', 'name', 'local'),\n                'order' => array('lower(Organisation.name) ASC')\n            ));\n            $allOrgs = [];\n            $localOrganisations = array();\n            $externalOrganisations = array();\n            foreach ($temp as $o) {\n                if ($o['Organisation']['local']) {\n                    $localOrganisations[$o['Organisation']['id']] = $o['Organisation']['name'];\n                } else {\n                    $externalOrganisations[$o['Organisation']['id']] = $o['Organisation']['name'];\n                }\n                $allOrgs[] = array('id' => $o['Organisation']['id'], 'name' => $o['Organisation']['name']);\n            }\n\n            $allTypes = $this->Server->getAllTypes();\n\n            $this->set('host_org_id', Configure::read('MISP.host_org_id'));\n            $this->set('organisationOptions', $organisationOptions);\n            $this->set('localOrganisations', $localOrganisations);\n            $this->set('externalOrganisations', $externalOrganisations);\n            $this->set('allOrganisations', $allOrgs);\n            $this->set('allAttributeTypes', $allTypes['attribute']);\n            $this->set('allObjectTypes', $allTypes['object']);\n\n            $this->set('allTags', $this->__getTags());\n            $this->set('host_org_id', Configure::read('MISP.host_org_id'));\n            $this->set('pull_scope', 'server');\n            $this->render('edit');\n        }\n    }\n\n    public function edit($id = null)\n    {\n        $this->Server->id = $id;\n        if (!$this->Server->exists()) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $s = $this->Server->read(null, $id);\n        if ($this->request->is('post') || $this->request->is('put')) {\n            if ($this->_isRest()) {\n                if (!isset($this->request->data['Server'])) {\n                    $this->request->data = array('Server' => $this->request->data);\n                }\n            }\n            if (empty(Configure::read('MISP.host_org_id'))) {\n                $this->request->data['Server']['internal'] = 0;\n            }\n            if (isset($this->request->data['Server']['json'])) {\n                $json = json_decode($this->request->data['Server']['json'], true);\n            } else {\n                $json = null;\n            }\n            $fail = false;\n\n            // test the filter fields\n            if (!empty($this->request->data['Server']['pull_rules']) && !JsonTool::isValid($this->request->data['Server']['pull_rules'])) {\n                $fail = true;\n                $error_msg = __('The pull filter rules must be in valid JSON format.');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'edit', false, array('pull_rules' => $error_msg), $this->response->type());\n                } else {\n                    $this->Flash->error($error_msg);\n                }\n            }\n\n            if (!$fail && !empty($this->request->data['Server']['push_rules']) && !JsonTool::isValid($this->request->data['Server']['push_rules'])) {\n                $fail = true;\n                $error_msg = __('The push filter rules must be in valid JSON format.');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'edit', false, array('push_rules' => $error_msg), $this->response->type());\n                } else {\n                    $this->Flash->error($error_msg);\n                }\n            }\n            $pushRules = $this->_jsonDecode($this->request->data['Server']['push_rules']);\n            $this->loadModel('Tag');\n            foreach ($pushRules['tags'] as $operator => $list) {\n                foreach ($list as $i => $tagName) {\n                    if (!is_numeric($tagName)) { // tag added from freetext\n                        $tag_id = $this->Tag->captureTag(['name' => $tagName], $this->Auth->user());\n                        $list[$i] = $tag_id;\n                    }\n                }\n            }\n            if (!$fail) {\n                // say what fields are to be updated\n                $fieldList = array('id', 'url', 'push', 'pull', 'push_sightings', 'push_galaxy_clusters', 'pull_galaxy_clusters', 'caching_enabled', 'unpublish_event', 'publish_without_email', 'remote_org_id', 'name' ,'self_signed', 'remove_missing_tags', 'cert_file', 'client_cert_file', 'push_rules', 'pull_rules', 'internal', 'skip_proxy');\n                $this->request->data['Server']['id'] = $id;\n                if (isset($this->request->data['Server']['authkey']) && \"\" != $this->request->data['Server']['authkey']) {\n                    $fieldList[] = 'authkey';\n                }\n                if (isset($this->request->data['Server']['organisation_type']) && isset($json)) {\n                    // adds 'remote_org_id' in the fields to update\n                    $fieldList[] = 'remote_org_id';\n                    if ($this->request->data['Server']['organisation_type'] < 2) {\n                        $this->request->data['Server']['remote_org_id'] = $json['id'];\n                    } else {\n                        $existingOrgs = $this->Server->Organisation->find('first', array(\n                                'conditions' => array('uuid' => $json['uuid']),\n                                'recursive' => -1,\n                                'fields' => array('id', 'uuid')\n                        ));\n                        if (!empty($existingOrgs)) {\n                            $fail = true;\n                            if ($this->_isRest()) {\n                                return $this->RestResponse->saveFailResponse('Servers', 'edit', false, array('Organisation' => 'Remote Organisation\\'s uuid already used'), $this->response->type());\n                            } else {\n                                $this->Flash->error(__('That organisation could not be created as the uuid is in use already.'));\n                            }\n                        }\n\n                        if (!$fail) {\n                            $this->Server->Organisation->create();\n                            $orgSave = $this->Server->Organisation->save(array(\n                                    'name' => $json['name'],\n                                    'uuid' => $json['uuid'],\n                                    'local' => 0,\n                                    'created_by' => $this->Auth->user('id')\n                            ));\n\n                            if (!$orgSave) {\n                                if ($this->_isRest()) {\n                                    return $this->RestResponse->saveFailResponse('Servers', 'edit', false, $this->Server->Organisation->validationError, $this->response->type());\n                                } else {\n                                    $this->Flash->error(__('Couldn\\'t save the new organisation, are you sure that the uuid is in the correct format?.'));\n                                }\n                                $fail = true;\n                                $this->request->data['Server']['external_name'] = $json['name'];\n                                $this->request->data['Server']['external_uuid'] = $json['uuid'];\n                            } else {\n                                $this->request->data['Server']['remote_org_id'] = $this->Server->Organisation->id;\n                            }\n                        }\n                    }\n                    if (empty(Configure::read('MISP.host_org_id')) || $this->request->data['Server']['remote_org_id'] != Configure::read('MISP.host_org_id')) {\n                        $this->request->data['Server']['internal'] = 0;\n                    }\n                }\n            }\n            if (!$fail) {\n                // Save the data\n                if ($this->Server->save($this->request->data, true, $fieldList)) {\n                    if (isset($this->request->data['Server']['submitted_cert']) && (!isset($this->request->data['Server']['delete_cert']) || !$this->request->data['Server']['delete_cert'])) {\n                        $this->__saveCert($this->request->data, $this->Server->id, false);\n                    } else {\n                        if (isset($this->request->data['Server']['delete_cert']) && $this->request->data['Server']['delete_cert']) {\n                            $this->__saveCert($this->request->data, $this->Server->id, false, true);\n                        }\n                    }\n                    if (isset($this->request->data['Server']['submitted_client_cert']) && (!isset($this->request->data['Server']['delete_client_cert']) || !$this->request->data['Server']['delete_client_cert'])) {\n                        $this->__saveCert($this->request->data, $this->Server->id, true);\n                    } else {\n                        if (isset($this->request->data['Server']['delete_client_cert']) && $this->request->data['Server']['delete_client_cert']) {\n                            $this->__saveCert($this->request->data, $this->Server->id, true, true);\n                        }\n                    }\n                    if ($this->_isRest()) {\n                        $server = $this->Server->find('first', array(\n                                'conditions' => array('Server.id' => $this->Server->id),\n                                'recursive' => -1\n                        ));\n                        return $this->RestResponse->viewData($server, $this->response->type());\n                    } else {\n                        $this->Flash->success(__('The server has been saved'));\n                        $this->redirect(array('action' => 'index'));\n                    }\n                } else {\n                    if ($this->_isRest()) {\n                        return $this->RestResponse->saveFailResponse('Servers', 'edit', false, $this->Server->validationError, $this->response->type());\n                    } else {\n                        $this->Flash->error(__('The server could not be saved. Please, try again.'));\n                    }\n                }\n            }\n        } else {\n            $this->Server->read(null, $id);\n            $this->Server->set('authkey', '');\n            $this->request->data = $this->Server->data;\n        }\n        if ($this->_isRest()) {\n            return $this->RestResponse->describe('Servers', 'edit', false, $this->response->type());\n        } else {\n            $organisationOptions = array(0 => 'Local organisation', 1 => 'External organisation', 2 => 'New external organisation');\n\n            $temp = $this->Server->Organisation->find('all', array(\n                'fields' => array('id', 'name', 'local'),\n                'order' => array('lower(Organisation.name) ASC')\n            ));\n            $allOrgs = [];\n            $localOrganisations = array();\n            $externalOrganisations = array();\n            foreach ($temp as $o) {\n                if ($o['Organisation']['local']) {\n                    $localOrganisations[$o['Organisation']['id']] = $o['Organisation']['name'];\n                } else {\n                    $externalOrganisations[$o['Organisation']['id']] = $o['Organisation']['name'];\n                }\n                $allOrgs[] = array('id' => $o['Organisation']['id'], 'name' => $o['Organisation']['name']);\n            }\n\n            $allTypes = $this->Server->getAllTypes();\n\n            $oldRemoteSetting = 0;\n            if (!$this->Server->data['RemoteOrg']['local']) {\n                $oldRemoteSetting = 1;\n            }\n            $this->set('host_org_id', Configure::read('MISP.host_org_id'));\n            $this->set('oldRemoteSetting', $oldRemoteSetting);\n            $this->set('oldRemoteOrg', $this->Server->data['RemoteOrg']['id']);\n\n            $this->set('organisationOptions', $organisationOptions);\n            $this->set('localOrganisations', $localOrganisations);\n            $this->set('externalOrganisations', $externalOrganisations);\n            $this->set('allOrganisations', $allOrgs);\n\n            $this->set('allTags', $this->__getTags());\n            $this->set('allAttributeTypes', $allTypes['attribute']);\n            $this->set('allObjectTypes', $allTypes['object']);\n            $this->set('server', $s);\n            $this->set('id', $id);\n            $this->set('host_org_id', Configure::read('MISP.host_org_id'));\n            $this->set('pull_scope', 'server');\n        }\n    }\n\n    public function delete($id = null)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException(__('This endpoint expects POST requests.'));\n        }\n        $this->Server->id = $id;\n        if (!$this->Server->exists()) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $s = $this->Server->read(null, $id);\n        if ($this->Server->delete()) {\n            $message = __('Server deleted');\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'delete', $message, $this->response->type());\n            } else {\n                $this->Flash->success($message);\n                $this->redirect(array('controller' => 'servers', 'action' => 'index'));\n            }\n\n        }\n        $message = __('Server was not deleted');\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveFailResponse('Servers', 'delete', $id, $message, $this->response->type());\n        } else {\n            $this->Flash->error($message);\n            $this->redirect(array('action' => 'index'));\n        }\n    }\n\n    public function eventBlockRule()\n    {\n        $this->AdminSetting = ClassRegistry::init('AdminSetting');\n        $setting = $this->AdminSetting->find('first', [\n            'conditions' => ['setting' => 'eventBlockRule'],\n            'recursive' => -1\n        ]);\n        if (empty($setting)) {\n            $setting = ['setting' => 'eventBlockRule'];\n            if ($this->request->is('post')) {\n                $this->AdminSetting->create();\n            }\n        }\n        if ($this->request->is('post')) {\n            if (!empty($this->request->data['Server'])) {\n                $this->request->data = $this->request->data['Server'];\n            }\n            $setting['AdminSetting']['setting'] = 'eventBlockRule';\n            $setting['AdminSetting']['value'] = $this->request->data['value'];\n            $result = $this->AdminSetting->save($setting);\n            if ($result) {\n                $message = __('Settings saved');\n            } else {\n                $message = __('Could not save the settings. Invalid input.');\n            }\n            if ($this->_isRest()) {\n                if ($result) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'eventBlockRule', false, $message, $this->response->type());\n                } else {\n                    return $this->RestResponse->saveSuccessResponse('Servers', 'eventBlockRule', $message, $this->response->type());\n                }\n            } else {\n                if ($result) {\n                    $this->Flash->success($message);\n                    $this->redirect('/');\n                } else {\n                    $this->Flash->error($message);\n                }\n            }\n        }\n        $this->set('setting', $setting);\n    }\n\n    /**\n     * Pull one or more events with attributes from a remote instance.\n     * Set $technique to\n     *      full - download everything\n     *      incremental - only new events\n     *      <int>   - specific id of the event to pull\n     */\n    public function pull($id = null, $technique = 'full')\n    {\n        if (empty($id)) {\n            if (!empty($this->request->data['id'])) {\n                $id = $this->request->data['id'];\n            } else {\n                throw new NotFoundException(__('Invalid server'));\n            }\n        }\n\n        $s = $this->Server->find('first', [\n            'conditions' => ['id' => $id],\n            'recursive' => -1,\n        ]);\n        if (empty($s)) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $error = false;\n\n        if (false == $s['Server']['pull'] && ($technique === 'full' || $technique === 'incremental')) {\n            $error = __('Pull setting not enabled for this server.');\n        }\n        if (false == $s['Server']['pull_galaxy_clusters'] && ($technique === 'pull_relevant_clusters')) {\n            $error = __('Pull setting not enabled for this server.');\n        }\n        if (empty($error)) {\n            if (!Configure::read('MISP.background_jobs')) {\n                $result = $this->Server->pull($this->Auth->user(), $technique, $s);\n                if (is_array($result)) {\n                    $success = __('Pull completed. %s events pulled, %s events could not be pulled, %s proposals pulled, %s sightings pulled, %s clusters pulled.', count($result[0]), count($result[1]), $result[2], $result[3], $result[4]);\n                } else {\n                    $error = $result;\n                }\n                $this->set('successes', $result[0]);\n                $this->set('fails', $result[1]);\n                $this->set('pulledProposals', $result[2]);\n                $this->set('pulledSightings', $result[3]);\n            } else {\n                $this->loadModel('Job');\n                $jobId = $this->Job->createJob(\n                    $this->Auth->user(),\n                    Job::WORKER_DEFAULT,\n                    'pull',\n                    'Server: ' . $id,\n                    __('Pulling.')\n                );\n\n                $this->Server->getBackgroundJobsTool()->enqueue(\n                    BackgroundJobsTool::DEFAULT_QUEUE,\n                    BackgroundJobsTool::CMD_SERVER,\n                    [\n                        'pull',\n                        $this->Auth->user('id'),\n                        $id,\n                        $technique,\n                        $jobId\n                    ],\n                    false,\n                    $jobId\n                );\n\n                $success = __('Pull queued for background execution. Job ID: %s', $jobId);\n            }\n        }\n        if ($this->_isRest()) {\n            if (!empty($error)) {\n                return $this->RestResponse->saveFailResponse('Servers', 'pull', $id, $error, $this->response->type());\n            } else {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'pull', $id, $this->response->type(), $success);\n            }\n        } else {\n            if (!empty($error)) {\n                $this->Flash->error($error);\n                $this->redirect(array('action' => 'index'));\n            } else {\n                $this->Flash->success($success);\n                $this->redirect($this->referer());\n            }\n        }\n    }\n\n    public function push($id = null, $technique=false)\n    {\n        if (!empty($id)) {\n            $this->Server->id = $id;\n        } else if (!empty($this->request->data['id'])) {\n            $this->Server->id = $this->request->data['id'];\n        } else {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        if (!empty($this->request->data['technique'])) {\n            $technique = $this->request->data['technique'];\n        }\n        if (!$this->Server->exists()) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $s = $this->Server->read(null, $id);\n\n        if (!Configure::read('MISP.background_jobs')) {\n            App::uses('SyncTool', 'Tools');\n            $syncTool = new SyncTool();\n            $HttpSocket = $syncTool->setupHttpSocket($s);\n            $result = $this->Server->push($id, $technique, false, $HttpSocket, $this->Auth->user());\n            if ($result === false) {\n                $error = __('The remote server is too outdated to initiate a push towards it. Please notify the hosting organisation of the remote instance.');\n            } elseif (!is_array($result)) {\n                $error = $result;\n            }\n            if (!empty($error)) {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'push', false, $error, $this->response->type());\n                } else {\n                    $this->Flash->info($error);\n                    $this->redirect(array('action' => 'index'));\n                }\n            }\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'push', $id, $this->response->type(), __('Push complete. %s events pushed, %s events could not be pushed.', count($result[0]), count($result[1])));\n            } else {\n                $this->set('successes', $result[0]);\n                $this->set('fails', $result[1]);\n            }\n        } else {\n            $this->loadModel('Job');\n            $jobId = $this->Job->createJob(\n                $this->Auth->user(),\n                Job::WORKER_DEFAULT,\n                'push',\n                'Server: ' . $id,\n                __('Pushing.')\n            );\n\n            $this->Server->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::DEFAULT_QUEUE,\n                BackgroundJobsTool::CMD_SERVER,\n                [\n                    'push',\n                    $this->Auth->user('id'),\n                    $id,\n                    $technique,\n                    $jobId\n                ],\n                false,\n                $jobId\n            );\n\n            $message = sprintf(__('Push queued for background execution. Job ID: %s'), $jobId);\n\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'push', $message, $this->response->type());\n            }\n            $this->Flash->success($message);\n            $this->redirect(array('action' => 'index'));\n        }\n    }\n\n    private function __saveCert($server, $id, $client = false, $delete = false)\n    {\n        if ($client) {\n            $subm = 'submitted_client_cert';\n            $attr = 'client_cert_file';\n            $ins  = '_client';\n        } else {\n            $subm = 'submitted_cert';\n            $attr = 'cert_file';\n            $ins  = '';\n        }\n        if (!$delete) {\n            $ext = '';\n            App::uses('File', 'Utility');\n            App::uses('Folder', 'Utility');\n            App::uses('FileAccessTool', 'Tools');\n            App::uses('SyncTool', 'Tools');\n            if (isset($server['Server'][$subm]['name'])) {\n                if ($this->request->data['Server'][$subm]['size'] != 0) {\n                    if (!$this->Server->checkFilename($server['Server'][$subm]['name'])) {\n                        throw new Exception(__('Filename not allowed'));\n                    }\n\n                    if (!is_uploaded_file($server['Server'][$subm]['tmp_name'])) {\n                        throw new Exception(__('File not uploaded correctly'));\n                    }\n\n                    $ext = pathinfo($server['Server'][$subm]['name'], PATHINFO_EXTENSION);\n                    if (!in_array($ext, SyncTool::ALLOWED_CERT_FILE_EXTENSIONS)) {\n                        $this->Flash->error(__('Invalid extension.'));\n                        $this->redirect(array('action' => 'index'));\n                    }\n\n                    if (!$server['Server'][$subm]['size'] > 0) {\n                        $this->Flash->error(__('Incorrect extension or empty file.'));\n                        $this->redirect(array('action' => 'index'));\n                    }\n\n                    // read certificate file data\n                    $certData = FileAccessTool::readFromFile($server['Server'][$subm]['tmp_name'], $server['Server'][$subm]['size']);\n                } else {\n                    return true;\n                }\n            } else {\n                $ext = 'pem';\n                $certData = base64_decode($server['Server'][$subm]);\n            }\n\n            // check if the file is a valid x509 certificate\n            try {\n                $cert = openssl_x509_parse($certData);\n                if (!$cert) {\n                    throw new Exception(__('Invalid certificate.'));\n                }\n            } catch (Exception $e) {\n                $this->Flash->error(__('Invalid certificate.'));\n                $this->redirect(array('action' => 'index'));\n            }\n\n            $destpath = APP . \"files\" . DS . \"certs\" . DS;\n            $pemfile = new File($destpath . $id . $ins . '.' . $ext);\n            $result = $pemfile->write($certData);\n            $s = $this->Server->read(null, $id);\n            $s['Server'][$attr] = $s['Server']['id'] . $ins . '.' . $ext;\n            if ($result) {\n                $this->Server->save($s);\n            }\n        } else {\n            $s = $this->Server->read(null, $id);\n            $s['Server'][$attr] = '';\n            $this->Server->save($s);\n        }\n        return true;\n    }\n\n    public function serverSettingsReloadSetting($setting, $id)\n    {\n        $pathToSetting = explode('.', $setting);\n        if (\n            strpos($setting, 'Plugin.Enrichment') !== false ||\n            strpos($setting, 'Plugin.Import') !== false ||\n            strpos($setting, 'Plugin.Export') !== false ||\n            strpos($setting, 'Plugin.Cortex') !== false ||\n            strpos($setting, 'Plugin.Action') !== false ||\n            strpos($setting, 'Plugin.Workflow') !== false\n        ) {\n            $settingObject = $this->Server->getCurrentServerSettings();\n        } else {\n            $settingObject = $this->Server->serverSettings;\n        }\n        foreach ($pathToSetting as $key) {\n            if (!isset($settingObject[$key])) {\n                throw new MethodNotAllowedException();\n            }\n            $settingObject = $settingObject[$key];\n        }\n        $result = $this->Server->serverSettingReadSingle($settingObject, $setting, $key);\n        $this->set('setting', $result);\n        $priorityErrorColours = array(0 => 'red', 1 => 'yellow', 2 => 'green');\n        $this->set('priorityErrorColours', $priorityErrorColours);\n        $priorities = array(0 => 'Critical', 1 => 'Recommended', 2 => 'Optional', 3 => 'Deprecated');\n        $this->set('priorities', $priorities);\n        $this->set('k', $id);\n        $this->layout = false;\n\n        $subGroup = 'general';\n        if ($pathToSetting[0] === 'Plugin') {\n            $subGroup = explode('_', $pathToSetting[1])[0];\n        }\n        $this->set('subGroup', $subGroup);\n\n        $this->render('/Elements/healthElements/settings_row');\n    }\n\n    public function serverSettings($tab=false)\n    {\n        if (!$this->request->is('get')) {\n            throw new MethodNotAllowedException('Just GET method is allowed.');\n        }\n        $tabs = array(\n            'MISP' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'Encryption' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'Proxy' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'Security' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'Plugin' => array('count' => 0, 'errors' => 0, 'severity' => 5),\n            'SimpleBackgroundJobs' => array('count' => 0, 'errors' => 0, 'severity' => 5)\n        );\n\n        $writeableErrors = array(0 => __('OK'), 1 => __('not found'), 2 => __('is not writeable'));\n        $readableErrors = array(0 => __('OK'), 1 => __('not readable'));\n        $gpgErrors = array(0 => __('OK'), 1 => __('FAIL: settings not set'), 2 => __('FAIL: Failed to load GnuPG'), 3 => __('FAIL: Issues with the key/passphrase'), 4 => __('FAIL: sign failed'));\n        $proxyErrors = array(0 => __('OK'), 1 => __('not configured (so not tested)'), 2 => __('Getting URL via proxy failed'));\n        $zmqErrors = array(0 => __('OK'), 1 => __('not enabled (so not tested)'), 2 => __('Python ZeroMQ library not installed correctly.'), 3 => __('ZeroMQ script not running.'));\n        $sessionErrors = array(\n            0 => __('OK'),\n            1 => __('Too many expired sessions in the database, please clear the expired sessions'),\n            2 => __('PHP session handler is using the default file storage. This is not recommended, please use the redis or database storage'),\n            8 => __('Alternative setting used'),\n            9 => __('Test failed')\n        );\n        $moduleErrors = array(0 => __('OK'), 1 => __('System not enabled'), 2 => __('No modules found'));\n        $backgroundJobsErrors = array(\n            0 => __('OK'),\n            1 => __('Not configured (so not tested)'),\n            2 => __('Error connecting to Redis.'),\n            3 => __('Error connecting to Supervisor.'),\n            4 => __('Error connecting to Redis and Supervisor.')\n        );\n\n        $finalSettings = $this->Server->serverSettingsRead();\n        $issues = array(\n            'errors' => array(\n                0 => array(\n                    'value' => 0,\n                    'description' => __('MISP will not operate correctly or will be unsecure until these issues are resolved.')\n                ),\n                1 => array(\n                    'value' => 0,\n                    'description' => __('Some of the features of MISP cannot be utilised until these issues are resolved.')\n                ),\n                2 => array(\n                    'value' => 0,\n                    'description' => __('There are some optional tweaks that could be done to improve the looks of your MISP instance.')\n                ),\n            ),\n            'deprecated' => array(),\n            'overallHealth' => 3,\n        );\n        $dumpResults = array();\n        $tempArray = array();\n        foreach ($finalSettings as $k => $result) {\n            if ($result['level'] == 3) {\n                $issues['deprecated']++;\n            }\n            $tabs[$result['tab']]['count']++;\n            if (isset($result['error']) && $result['level'] < 3) {\n                $issues['errors'][$result['level']]['value']++;\n                if ($result['level'] < $issues['overallHealth']) {\n                    $issues['overallHealth'] = $result['level'];\n                }\n                $tabs[$result['tab']]['errors']++;\n                if ($result['level'] < $tabs[$result['tab']]['severity']) {\n                    $tabs[$result['tab']]['severity'] = $result['level'];\n                }\n            }\n            if (isset($result['optionsSource']) && is_callable($result['optionsSource'])) {\n                $result['options'] = $result['optionsSource']();\n            }\n            $dumpResults[] = $result;\n            if ($result['tab'] == $tab) {\n                if (isset($result['subGroup'])) {\n                    $tempArray[$result['subGroup']][] = $result;\n                } else {\n                    $tempArray['general'][] = $result;\n                }\n            }\n        }\n        $finalSettings = $tempArray;\n        // Diagnostics portion\n        $diagnostic_errors = 0;\n        App::uses('File', 'Utility');\n        App::uses('Folder', 'Utility');\n        if ($tab === 'correlations') {\n            $this->loadModel('Correlation');\n            $correlation_metrics = $this->Correlation->collectMetrics();\n            $this->set('correlation_metrics', $correlation_metrics);\n        }\n        if ($tab === 'files') {\n            if (!empty(Configure::read('Security.disable_instance_file_uploads'))) {\n                throw new MethodNotAllowedException(__('This functionality is disabled.'));\n            }\n            $files = $this->Server->grabFiles();\n            $this->set('files', $files);\n        }\n        // Only run this check on the diagnostics tab\n        if ($tab === 'diagnostics' || $tab === 'download' || $this->_isRest()) {\n            $php_ini = php_ini_loaded_file();\n            $this->set('php_ini', $php_ini);\n\n            $attachmentTool = new AttachmentTool();\n            try {\n                $advanced_attachments = $attachmentTool->checkAdvancedExtractionStatus();\n            } catch (Exception $e) {\n                $this->log($e->getMessage(), LOG_NOTICE);\n                $advanced_attachments = false;\n            }\n\n            $this->set('advanced_attachments', $advanced_attachments);\n\n            $gitStatus = $this->Server->getCurrentGitStatus(true);\n            $this->set('branch', $gitStatus['branch']);\n            $this->set('commit', $gitStatus['commit']);\n            $this->set('latestCommit', $gitStatus['latestCommit']);\n            $this->set('version', $gitStatus['version']);\n\n            $phpSettings = array(\n                'max_execution_time' => array(\n                    'explanation' => 'The maximum duration that a script can run (does not affect the background workers). A too low number will break long running scripts like comprehensive API exports',\n                    'recommended' => 300,\n                    'unit' => 'seconds',\n                ),\n                'memory_limit' => array(\n                    'explanation' => 'The maximum memory that PHP can consume. It is recommended to raise this number since certain exports can generate a fair bit of memory usage',\n                    'recommended' => 2048,\n                    'unit' => 'MB'\n                ),\n                'upload_max_filesize' => array(\n                    'explanation' => 'The maximum size that an uploaded file can be. It is recommended to raise this number to allow for the upload of larger samples',\n                    'recommended' => 50,\n                    'unit' => 'MB'\n                ),\n                'post_max_size' => array(\n                    'explanation' => 'The maximum size of a POSTed message, this has to be at least the same size as the upload_max_filesize setting',\n                    'recommended' => 50,\n                    'unit' => 'MB'\n                )\n            );\n\n            foreach ($phpSettings as $setting => $settingArray) {\n                $phpSettings[$setting]['value'] = $this->Server->getIniSetting($setting);\n                if ($phpSettings[$setting]['value'] && $settingArray['unit'] && $settingArray['unit'] === 'MB') {\n                    // convert basic unit to M\n                    $phpSettings[$setting]['value'] = (int) floor($phpSettings[$setting]['value'] / 1024 / 1024);\n                }\n            }\n            $this->set('phpSettings', $phpSettings);\n\n            if ($gitStatus['version'] && $gitStatus['version']['upToDate'] === 'older') {\n                $diagnostic_errors++;\n            }\n\n            // check if the STIX and Cybox libraries are working and the correct version using the test script stixtest.py\n            $stix = $this->Server->stixDiagnostics($diagnostic_errors);\n\n            $yaraStatus = $this->Server->yaraDiagnostics($diagnostic_errors);\n\n            // if GnuPG is set up in the settings, try to encrypt a test message\n            $gpgStatus = $this->Server->gpgDiagnostics($diagnostic_errors);\n\n            // if the message queue pub/sub is enabled, check whether the extension works\n            $zmqStatus = $this->Server->zmqDiagnostics($diagnostic_errors);\n\n            // if Proxy is set up in the settings, try to connect to a test URL\n            $proxyStatus = $this->Server->proxyDiagnostics($diagnostic_errors);\n\n            // if SimpleBackgroundJobs is set up in the settings, try to connect to Redis\n            $backgroundJobsStatus = $this->Server->backgroundJobsDiagnostics($diagnostic_errors);\n\n            // get the DB diagnostics\n            $dbDiagnostics = $this->Server->dbSpaceUsage();\n            $dbSchemaDiagnostics = $this->Server->dbSchemaDiagnostic();\n            $dbConfiguration = $this->Server->dbConfiguration();\n\n            $redisInfo = $this->Server->redisInfo();\n\n            $moduleTypes = array('Enrichment', 'Import', 'Export', 'Cortex');\n            foreach ($moduleTypes as $type) {\n                $moduleStatus[$type] = $this->Server->moduleDiagnostics($diagnostic_errors, $type);\n            }\n\n            // get php session diagnostics\n            $sessionStatus = $this->Server->sessionDiagnostics($diagnostic_errors);\n\n            $this->loadModel('AttachmentScan');\n            try {\n                $attachmentScan = ['status' => true, 'software' => $this->AttachmentScan->diagnostic()];\n            } catch (Exception $e) {\n                $attachmentScan = ['status' => false, 'error' => $e->getMessage()];\n            }\n\n            $securityAudit = (new SecurityAudit())->run($this->Server);\n\n            $view = compact('gpgStatus', 'sessionErrors', 'proxyStatus', 'sessionStatus', 'zmqStatus', 'moduleStatus', 'yaraStatus', 'gpgErrors', 'proxyErrors', 'zmqErrors', 'stix', 'moduleErrors', 'moduleTypes', 'dbDiagnostics', 'dbSchemaDiagnostics', 'dbConfiguration', 'redisInfo', 'attachmentScan', 'securityAudit');\n        } else {\n            $view = [];\n        }\n\n        // check whether the files are writeable\n        $writeableDirs = $this->Server->writeableDirsDiagnostics($diagnostic_errors);\n        $writeableFiles = $this->Server->writeableFilesDiagnostics($diagnostic_errors);\n        $readableFiles = $this->Server->readableFilesDiagnostics($diagnostic_errors);\n        $extensions = $this->Server->extensionDiagnostics();\n\n        // check if the encoding is not set to utf8\n        $dbEncodingStatus = $this->Server->databaseEncodingDiagnostics($diagnostic_errors);\n\n        $view = array_merge($view, compact('diagnostic_errors', 'tabs', 'tab', 'issues', 'finalSettings', 'writeableErrors', 'readableErrors', 'writeableDirs', 'writeableFiles', 'readableFiles', 'extensions', 'dbEncodingStatus'));\n        $this->set($view);\n\n        $workerIssueCount = 4;\n        $worker_array = array();\n        if (Configure::read('MISP.background_jobs')) {\n            $workerIssueCount = 0;\n            $worker_array = $this->Server->workerDiagnostics($workerIssueCount);\n        }\n        $this->set('worker_array', $worker_array);\n        if ($tab === 'download' || $this->_isRest()) {\n            foreach ($dumpResults as $key => $dr) {\n                unset($dumpResults[$key]['description']);\n            }\n            $dump = array(\n                'version' => $gitStatus['version'],\n                'phpSettings' => $phpSettings,\n                'gpgStatus' => $gpgErrors[$gpgStatus['status']],\n                'proxyStatus' => $proxyErrors[$proxyStatus],\n                'zmqStatus' => $zmqStatus,\n                'stix' => $stix,\n                'moduleStatus' => $moduleStatus,\n                'writeableDirs' => $writeableDirs,\n                'writeableFiles' => $writeableFiles,\n                'readableFiles' => $readableFiles,\n                'dbDiagnostics' => $dbDiagnostics,\n                'dbSchemaDiagnostics' => $dbSchemaDiagnostics,\n                'dbConfiguration' => $dbConfiguration,\n                'redisInfo' => $redisInfo,\n                'finalSettings' => $dumpResults,\n                'extensions' => $extensions,\n                'workers' => $worker_array,\n                'backgroundJobsStatus' => $backgroundJobsErrors[$backgroundJobsStatus]\n            );\n            foreach ($dump['finalSettings'] as $k => $v) {\n                if (!empty($v['redacted'])) {\n                    $dump['finalSettings'][$k]['value'] = '*****';\n                }\n            }\n            $this->response->body(json_encode($dump, JSON_PRETTY_PRINT));\n            $this->response->type('json');\n            $this->response->download('MISP.report.json');\n            return $this->response;\n        }\n\n        $priorities = array(0 => 'Critical', 1 => 'Recommended', 2 => 'Optional', 3 => 'Deprecated');\n        $this->set('priorities', $priorities);\n        $this->set('workerIssueCount', $workerIssueCount);\n        $priorityErrorColours = array(0 => 'red', 1 => 'yellow', 2 => 'green');\n        $this->set('priorityErrorColours', $priorityErrorColours);\n        $this->set('phpversion', phpversion());\n        $this->set('phpmin', $this->phpmin);\n        $this->set('phprec', $this->phprec);\n        $this->set('phptoonew', $this->phptoonew);\n        $this->set('pythonmin', $this->pythonmin);\n        $this->set('pythonrec', $this->pythonrec);\n        $this->set('title_for_layout', __('Diagnostics'));\n    }\n\n    public function startWorker($type)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $message = __('Worker start signal sent');\n            $this->Server->getBackgroundJobsTool()->startWorkerByQueue($type);\n\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'startWorker', $type, $this->response->type(), $message);\n            } else {\n                $this->Flash->info($message);\n                $this->redirect('/servers/serverSettings/workers');\n            }\n        }\n\n        // CakeResque\n        $validTypes = array('default', 'email', 'scheduler', 'cache', 'prio', 'update');\n        if (!in_array($type, $validTypes)) {\n            throw new MethodNotAllowedException('Invalid worker type.');\n        }\n\n        $prepend = '';\n        if ($type != 'scheduler') {\n            $workerIssueCount = 0;\n            $workerDiagnostic = $this->Server->workerDiagnostics($workerIssueCount);\n            if ($type == 'update' && isset($workerDiagnostic['update']['ok']) && $workerDiagnostic['update']['ok']) {\n                $message = __('Only one `update` worker can run at a time');\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'startWorker', false, $message, $this->response->type());\n                } else {\n                    $this->Flash->error($message);\n                    $this->redirect('/servers/serverSettings/workers');\n                }\n            }\n            shell_exec($prepend . APP . 'Console' . DS . 'cake CakeResque.CakeResque start --interval 5 --queue ' . $type .' > /dev/null 2>&1 &');\n        } else {\n            shell_exec($prepend . APP . 'Console' . DS . 'cake CakeResque.CakeResque startscheduler -i 5 > /dev/null 2>&1 &');\n        }\n        $message = __('Worker start signal sent');\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Servers', 'startWorker', $type, $this->response->type(), $message);\n        } else {\n            $this->Flash->info($message);\n            $this->redirect('/servers/serverSettings/workers');\n        }\n    }\n\n    public function stopWorker($pid)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n\n        $message = __('Worker stop signal sent');\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $this->Server->getBackgroundJobsTool()->stopWorker($pid);\n            if ($this->_isRest()) {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'stopWorker', $pid, $this->response->type(), $message);\n            } else {\n                $this->Flash->info($message);\n                $this->redirect('/servers/serverSettings/workers');\n            }\n        }\n\n        // CakeResque\n        $this->Server->killWorker($pid, $this->Auth->user());\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Servers', 'stopWorker', $pid, $this->response->type(), $message);\n        } else {\n            $this->Flash->info($message);\n            $this->redirect('/servers/serverSettings/workers');\n        }\n    }\n\n    public function getWorkers()\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $workerIssueCount = 0;\n            $worker_array = $this->Server->workerDiagnostics($workerIssueCount);\n        } else {\n            $worker_array = [__('Background jobs not enabled')];\n        }\n        return $this->RestResponse->viewData($worker_array);\n    }\n\n    public function idTranslator($localId = null)\n    {\n        // We retrieve the list of remote servers that we can query\n        $servers = $this->Server->find('all', [\n            'conditions' => ['OR' => ['pull' => true, 'push' => true]],\n            'recursive' => -1,\n            'order' => ['Server.priority ASC'],\n        ]);\n\n        // We generate the list of servers for the dropdown\n        $displayServers = array();\n        foreach ($servers as $s) {\n            $displayServers[] = [\n                'name' => $s['Server']['name'],\n                'value' => $s['Server']['id'],\n            ];\n        }\n        $this->set('servers', $displayServers);\n\n        if ($localId || $this->request->is('post')) {\n            if ($localId && $this->request->is('get')) {\n                $this->request->data['Event']['local'] = 'local';\n                $this->request->data['Event']['uuid'] = $localId;\n            }\n            $remote_events = array();\n            if (!empty($this->request->data['Event']['uuid']) && $this->request->data['Event']['local'] === \"local\") {\n                $local_event = $this->Event->fetchSimpleEvent($this->Auth->user(), $this->request->data['Event']['uuid']);\n            } else if (!empty($this->request->data['Event']['uuid']) && $this->request->data['Event']['local'] === \"remote\" && !empty($this->request->data['Server']['id'])) {\n                //We check on the remote server for any event with this id and try to find a match locally\n                $conditions = array('AND' => array('Server.id' => $this->request->data['Server']['id'], 'Server.pull' => true));\n                $remote_server = $this->Server->find('first', array('conditions' => $conditions));\n                if (!empty($remote_server)) {\n                    try {\n                        $remote_event = $this->Event->downloadEventMetadataFromServer($this->request->data['Event']['uuid'], $remote_server);\n                    } catch (Exception $e) {\n                        $this->Flash->error(__(\"Issue while contacting the remote server to retrieve event information\"));\n                        return;\n                    }\n\n                    if (empty($remote_event)) {\n                        $this->Flash->error(__(\"This event could not be found or you don't have permissions to see it.\"));\n                        return;\n                    }\n\n                    $local_event = $this->Event->fetchSimpleEvent($this->Auth->user(), $remote_event['uuid']);\n                    // we record it to avoid re-querying the same server in the 2nd phase\n                    if (!empty($local_event)) {\n                        $remote_events[] = array(\n                            \"server_id\" => $remote_server['Server']['id'],\n                            \"server_name\" => $remote_server['Server']['name'],\n                            \"url\" => $remote_server['Server']['url'].\"/events/view/\".$remote_event['id'],\n                            \"remote_id\" => $remote_event['id']\n                        );\n                    }\n                }\n            }\n            if (empty($local_event)) {\n                $this->Flash->error(__(\"This event could not be found or you don't have permissions to see it.\"));\n                return;\n            } else {\n                $this->Flash->success(__('The event has been found.'));\n            }\n\n            // In the second phase, we query all configured sync servers to get their info on the event\n            foreach ($servers as $server) {\n                // We check if the server was not already contacted in phase 1\n                if (count($remote_events) > 0 && $remote_events[0]['server_id'] == $server['Server']['id']) {\n                    continue;\n                }\n\n                $exception = null;\n                try {\n                    $remoteEvent = $this->Event->downloadEventMetadataFromServer($local_event['Event']['uuid'], $server);\n                } catch (Exception $e) {\n                    $remoteEvent = null;\n                    $exception = $e->getMessage();\n                }\n                $remoteEventId = isset($remoteEvent['id']) ? $remoteEvent['id'] : null;\n                $remote_events[] = array(\n                    \"server_id\" => $server['Server']['id'],\n                    \"server_name\" => $server['Server']['name'],\n                    \"url\" => isset($remoteEventId) ? $server['Server']['url'] . \"/events/view/\" . $remoteEventId : $server['Server']['url'],\n                    \"remote_id\" => isset($remoteEventId) ? $remoteEventId : false,\n                    \"exception\" => $exception,\n                );\n            }\n\n            $this->set('local_event', $local_event);\n            $this->set('remote_events', $remote_events);\n        }\n        $this->set('title_for_layout', __('Event ID translator'));\n    }\n\n    public function getSubmodulesStatus()\n    {\n        $this->set('submodules', $this->Server->getSubmodulesGitStatus());\n        $this->render('ajax/submoduleStatus');\n    }\n\n    public function getSetting($settingName)\n    {\n        $setting = $this->Server->getSettingData($settingName);\n        if (!$setting) {\n            throw new NotFoundException(__('Setting %s is invalid.', $settingName));\n        }\n        if (!empty($setting[\"redacted\"])) {\n            throw new ForbiddenException(__('This setting is redacted.'));\n        }\n        if (Configure::check($settingName)) {\n            $setting['value'] = Configure::read($settingName);\n        }\n        return $this->RestResponse->viewData($setting);\n    }\n\n    public function serverSettingsEdit($settingName, $id = false, $forceSave = false)\n    {\n        if (!$this->_isRest()) {\n            if (!isset($id)) {\n                throw new MethodNotAllowedException();\n            }\n            $this->set('id', $id);\n        }\n        $setting = $this->Server->getSettingData($settingName);\n        if ($setting === false) {\n            throw new NotFoundException(__('Setting %s is invalid.', $settingName));\n        }\n        if (!empty($setting['cli_only'])) {\n            throw new MethodNotAllowedException(__('This setting can only be edited via the CLI.'));\n        }\n        if ($this->request->is('get')) {\n            $value = Configure::read($setting['name']);\n            if (isset($value)) {\n                $setting['value'] = $value;\n            }\n            $setting['setting'] = $setting['name'];\n            if (isset($setting['optionsSource']) && is_callable($setting['optionsSource'])) {\n                $setting['options'] = $setting['optionsSource']();\n            }\n            $subGroup = explode('.', $setting['name']);\n            if ($subGroup[0] === 'Plugin') {\n                $subGroup = explode('_', $subGroup[1])[0];\n            } else {\n                $subGroup = 'general';\n            }\n            if ($this->_isRest()) {\n                if (!empty($setting['redacted'])) {\n                    throw new ForbiddenException(__('This setting is redacted.'));\n                }\n                return $this->RestResponse->viewData([$setting['name'] => $setting['value']]);\n            } else {\n                $this->set('subGroup', $subGroup);\n                $this->set('setting', $setting);\n                $this->render('ajax/server_settings_edit');\n            }\n        } else if ($this->request->is('post')) {\n            if (!isset($this->request->data['Server'])) {\n                $this->request->data = array('Server' => $this->request->data);\n            }\n            if (!isset($this->request->data['Server']['value']) || !is_scalar($this->request->data['Server']['value'])) {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'serverSettingsEdit', false, 'Invalid input. Expected: {\"value\": \"new_setting\"}', $this->response->type());\n                }\n            }\n            if (!empty($this->request->data['Server']['force'])) {\n                $forceSave = $this->request->data['Server']['force'];\n            }\n            if (trim($this->request->data['Server']['value']) === '*****') {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'serverSettingsEdit', false, 'No change.', $this->response->type());\n                } else {\n                    return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => 'No change.')), 'status'=>200, 'type' => 'json'));\n                }\n            }\n            $this->autoRender = false;\n            if (!Configure::read('MISP.system_setting_db') && !is_writeable(APP . 'Config/config.php')) {\n                $this->loadModel('Log');\n                $this->Log->create();\n                $this->Log->save(array(\n                    'org' => $this->Auth->user('Organisation')['name'],\n                    'model' => 'Server',\n                    'model_id' => 0,\n                    'email' => $this->Auth->user('email'),\n                    'action' => 'serverSettingsEdit',\n                    'user_id' => $this->Auth->user('id'),\n                    'title' => 'Server setting issue',\n                    'change' => 'There was an issue witch changing ' . $setting['name'] . ' to ' . $this->request->data['Server']['value']  . '. The error message returned is: app/Config.config.php is not writeable to the apache user. No changes were made.',\n                ));\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'serverSettingsEdit', false, 'app/Config.config.php is not writeable to the apache user.', $this->response->type());\n                } else {\n                    return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => 'app/Config.config.php is not writeable to the apache user.')), 'status'=>200, 'type' => 'json'));\n                }\n            }\n            $result = $this->Server->serverSettingsEditValue($this->Auth->user(), $setting, $this->request->data['Server']['value'], $forceSave);\n            if ($result === true) {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveSuccessResponse('Servers', 'serverSettingsEdit', false, $this->response->type(), 'Field updated');\n                } else {\n                    return new CakeResponse(array('body'=> json_encode(array('saved' => true, 'success' => 'Field updated.')), 'status'=>200, 'type' => 'json'));\n                }\n            } else {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'serverSettingsEdit', false, $result, $this->response->type());\n                } else {\n                    return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => $result)), 'status'=>200, 'type' => 'json'));\n                }\n            }\n        }\n    }\n\n    public function killAllWorkers($force = false)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        $this->Server->killAllWorkers($this->Auth->user(), $force);\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Server', 'killAllWorkers', false, $this->response->type(), __('Killing workers.'));\n        }\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'workers'));\n    }\n\n    public function restartWorkers()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $this->Server->getBackgroundJobsTool()->restartWorkers();\n        } else {\n            // CakeResque\n            $this->Server->restartWorkers($this->Auth->user());\n        }\n\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Server', 'restartWorkers', false, $this->response->type(), __('Restarting workers.'));\n        }\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'workers'));\n    }\n\n    public function restartDeadWorkers()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $this->Server->getBackgroundJobsTool()->restartDeadWorkers();\n        } else {\n            // CakeResque\n            $this->Server->restartDeadWorkers($this->Auth->user());\n        }\n\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Server', 'restartDeadWorkers', false, $this->response->type(), __('Restarting workers.'));\n        }\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'workers'));\n    }\n\n    public function deleteFile($type, $filename)\n    {\n        if ($this->request->is('post')) {\n            $validItems = $this->Server->getFileRules();\n            App::uses('File', 'Utility');\n            $existingFile = new File($validItems[$type]['path'] . DS . $filename);\n            if (!$existingFile->exists()) {\n                $this->Flash->error(__('File not found.', true), 'default', array(), 'error');\n                $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n            }\n            if ($existingFile->delete()) {\n                $this->Flash->success('File deleted.');\n            } else {\n                $this->Flash->error(__('File could not be deleted.', true), 'default', array(), 'error');\n            }\n            $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n        } else {\n            throw new MethodNotAllowedException('This action expects a POST request.');\n        }\n    }\n\n    public function uploadFile($type)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        if (!empty(Configure::read('Security.disable_instance_file_uploads'))) {\n            throw new MethodNotAllowedException(__('Feature disabled.'));\n        }\n        $validItems = $this->Server->getFileRules();\n\n        // Check if there were problems with the file upload\n        // only keep the last part of the filename, this should prevent directory attacks\n        $filename = basename($this->request->data['Server']['file']['name']);\n        if (!preg_match(\"/\" . $validItems[$type]['regex'] . \"/\", $filename)) {\n            $this->Flash->error($validItems[$type]['regex_error'], 'default', array(), 'error');\n            $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n        }\n        if (empty($this->request->data['Server']['file']['tmp_name']) || !is_uploaded_file($this->request->data['Server']['file']['tmp_name'])) {\n            $this->Flash->error(__('Upload failed.', true), 'default', array(), 'error');\n            $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n        }\n\n        // check if the file already exists\n        App::uses('File', 'Utility');\n        $existingFile = new File($validItems[$type]['path'] . DS . $filename);\n        if ($existingFile->exists()) {\n            $this->Flash->info(__('File already exists. If you would like to replace it, remove the old one first.', true), 'default', array(), 'error');\n            $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n        }\n\n        $result = move_uploaded_file($this->request->data['Server']['file']['tmp_name'], $validItems[$type]['path'] . DS . $filename);\n        if ($result) {\n            $this->Flash->success('File uploaded.');\n        } else {\n            $this->Flash->error(__('Upload failed.', true), 'default', array(), 'error');\n        }\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'files'));\n    }\n\n    public function fetchServersForSG($idList = '{}')\n    {\n        $id_exclusion_list = json_decode($idList, true);\n        $temp = $this->Server->find('all', array(\n                'conditions' => array(\n                        'id !=' => $id_exclusion_list,\n                ),\n                'recursive' => -1,\n                'fields' => array('id', 'name', 'url')\n        ));\n        $servers = array();\n        foreach ($temp as $server) {\n            $servers[] = array('id' => $server['Server']['id'], 'name' => $server['Server']['name'], 'url' => $server['Server']['url']);\n        }\n        $this->layout = false;\n        $this->autoRender = false;\n        $this->set('servers', $servers);\n        $this->render('ajax/fetch_servers_for_sg');\n    }\n\n    public function postTest()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException('Invalid request, expecting a POST request.');\n        }\n        // Fix for PHP-FPM / Nginx / etc\n        // Fix via https://www.popmartian.com/tipsntricks/2015/07/14/howto-use-php-getallheaders-under-fastcgi-php-fpm-nginx-etc/\n        if (!function_exists('getallheaders')) {\n            $headers = [];\n            foreach ($_SERVER as $name => $value) {\n                $name = strtolower($name);\n                if (substr($name, 0, 5) === 'http_') {\n                    $headers[str_replace('_', '-', substr($name, 5))] = $value;\n                }\n            }\n        } else {\n            $headers = getallheaders();\n            $headers = array_change_key_case($headers, CASE_LOWER);\n        }\n        $result = [\n            'body' => $this->request->data,\n            'headers' => [\n                'Content-type' => isset($headers['content-type']) ? $headers['content-type'] : 0,\n                'Accept' => isset($headers['accept']) ? $headers['accept'] : 0,\n                'Authorization' => isset($headers['authorization']) ? 'OK' : 0,\n            ],\n        ];\n        return $this->RestResponse->viewData($result, 'json');\n    }\n\n    public function getRemoteUser($id)\n    {\n        $user = $this->Server->getRemoteUser($id);\n        if ($user === null) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        return $this->RestResponse->viewData($user);\n    }\n\n    public function testConnection($id = false)\n    {\n        $server = $this->Server->find('first', ['conditions' => ['Server.id' => $id]]);\n        if (!$server) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        @session_write_close(); // close session to allow concurrent requests\n        $result = $this->Server->runConnectionTest($server);\n        if ($result['status'] == 1) {\n            if (isset($result['info']['version']) && preg_match('/^[0-9]+\\.+[0-9]+\\.[0-9]+$/', $result['info']['version'])) {\n                $perm_sync = isset($result['info']['perm_sync']) ? $result['info']['perm_sync'] : false;\n                $perm_sighting = isset($result['info']['perm_sighting']) ? $result['info']['perm_sighting'] : false;\n                $local_version = $this->Server->checkMISPVersion();\n                $version = explode('.', $result['info']['version']);\n                $mismatch = false;\n                $newer = false;\n                $parts = array('major', 'minor', 'hotfix');\n                foreach ($parts as $k => $v) {\n                    if (!$mismatch) {\n                        if ($version[$k] > $local_version[$v]) {\n                            $mismatch = $v;\n                            $newer = 'remote';\n                        } elseif ($version[$k] < $local_version[$v]) {\n                            $mismatch = $v;\n                            $newer = 'local';\n                        }\n                    }\n                }\n                if (!$mismatch && $version[2] < 111) {\n                    $mismatch = 'proposal';\n                }\n                if (!$perm_sync && !$perm_sighting) {\n                    $result['status'] = 7;\n                    return new CakeResponse(array('body'=> json_encode($result), 'type' => 'json'));\n                }\n                if (!$perm_sync && $perm_sighting) {\n                    $result['status'] = 8;\n                    return new CakeResponse(array('body'=> json_encode($result), 'type' => 'json'));\n                }\n                return $this->RestResponse->viewData([\n                    'status' => 1,\n                    'local_version' => implode('.', $local_version),\n                    'version' => implode('.', $version),\n                    'mismatch' => $mismatch,\n                    'newer' => $newer,\n                    'post' => isset($result['post']) ? $result['post']['status'] : 'too old',\n                    'response_encoding' => isset($result['post']['content-encoding']) ? $result['post']['content-encoding'] : null,\n                    'request_encoding' => isset($result['info']['request_encoding']) ? $result['info']['request_encoding'] : null,\n                    'client_certificate' => $result['client_certificate'],\n                ], 'json');\n            } else {\n                $result['status'] = 3;\n            }\n        }\n        return new CakeResponse(array('body'=> json_encode($result), 'type' => 'json'));\n    }\n\n    public function startZeroMQServer()\n    {\n        $pubSubTool = $this->Server->getPubSubTool();\n        $result = $pubSubTool->restartServer();\n        if ($result === true) {\n            return new CakeResponse(array('body'=> json_encode(array('saved' => true, 'success' => 'ZeroMQ server successfully started.')), 'status'=>200, 'type' => 'json'));\n        } else {\n            return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => $result)), 'status'=>200, 'type' => 'json'));\n        }\n    }\n\n    public function stopZeroMQServer()\n    {\n        $pubSubTool = $this->Server->getPubSubTool();\n        $result = $pubSubTool->killService();\n        if ($result === true) {\n            return new CakeResponse(array('body'=> json_encode(array('saved' => true, 'success' => 'ZeroMQ server successfully killed.')), 'status'=>200, 'type' => 'json'));\n        } else {\n            return new CakeResponse(array('body'=> json_encode(array('saved' => false, 'errors' => 'Could not kill the previous instance of the ZeroMQ script.')), 'status'=>200, 'type' => 'json'));\n        }\n    }\n\n    public function statusZeroMQServer()\n    {\n        $pubSubTool = $this->Server->getPubSubTool();\n        $result = $pubSubTool->statusCheck();\n        if (!empty($result)) {\n            $this->set('events', $result['publishCount']);\n            $this->set('messages', $result['messageCount']);\n            $this->set('time', $result['timestamp']);\n            $this->set('time2', $result['timestampSettings']);\n        }\n        $this->render('ajax/zeromqstatus');\n    }\n\n    public function purgeSessions()\n    {\n        if ($this->Server->updateDatabase('cleanSessionTable') == false) {\n            $this->Flash->error('Could not purge the session table.');\n        }\n        $this->redirect('/servers/serverSettings/diagnostics');\n    }\n\n    public function clearWorkerQueue($worker)\n    {\n        if (!$this->request->is('Post') || $this->request->is('ajax')) {\n            throw new MethodNotAllowedException();\n        }\n\n        if (Configure::read('SimpleBackgroundJobs.enabled')) {\n            $this->Server->getBackgroundJobsTool()->purgeQueue($worker);\n        } else {\n            // CakeResque\n            $worker_array = array('cache', 'default', 'email', 'prio');\n            if (!in_array($worker, $worker_array)) {\n                throw new MethodNotAllowedException('Invalid worker');\n            }\n            $redis = Resque::redis();\n            $redis->del('queue:' . $worker);\n        }\n\n        $this->Flash->success('Queue cleared.');\n        $this->redirect($this->referer());\n    }\n\n    public function getVersion()\n    {\n        $user = $this->_closeSession();\n        $versionArray = $this->Server->checkMISPVersion();\n        $response = [\n            'version' => $versionArray['major'] . '.' . $versionArray['minor'] . '.' . $versionArray['hotfix'],\n            'pymisp_recommended_version' => $this->pyMispVersion,\n            'perm_sync' => (bool) $user['Role']['perm_sync'],\n            'perm_sighting' => (bool) $user['Role']['perm_sighting'],\n            'perm_galaxy_editor' => (bool) $user['Role']['perm_galaxy_editor'],\n            'request_encoding' => $this->CompressedRequestHandler->supportedEncodings(),\n            'filter_sightings' => true, // check if Sightings::filterSightingUuidsForPush method is supported\n        ];\n        return $this->RestResponse->viewData($response, 'json');\n    }\n\n    /**\n     * @deprecated Use field `pymisp_recommended_version` from getVersion instead\n     */\n    public function getPyMISPVersion()\n    {\n        $this->set('response', array('version' => $this->pyMispVersion));\n        $this->set('_serialize', 'response');\n    }\n\n    public function checkout()\n    {\n        $result = $this->Server->checkoutMain();\n    }\n\n    public function update($branch = false)\n    {\n        if ($this->request->is('post')) {\n            $filterData = array(\n                'request' => $this->request,\n                'named_params' => $this->params['named'],\n                'paramArray' => ['branch'],\n                'ordered_url_params' => [],\n                'additional_delimiters' => PHP_EOL\n            );\n            $exception = false;\n            $settings = $this->_harvestParameters($filterData, $exception);\n            $status = $this->Server->getCurrentGitStatus();\n            $raw = array();\n            if (empty($status['branch'])) { // do not try to update if you are not on branch\n                $msg = 'Update failed, you are not on branch';\n                $raw[] = $msg;\n                $update = $msg;\n            } else {\n                if ($settings === false) {\n                    $settings = [];\n                }\n                $update = $this->Server->update($status, $raw, $settings);\n            }\n            if ($this->_isRest()) {\n                return $this->RestResponse->viewData(array('results' => $raw), $this->response->type());\n            } else {\n                return new CakeResponse(array('body' => $update, 'type' => 'txt'));\n            }\n        } else {\n            $this->set('isUpdatePossible', $this->Server->isUpdatePossible());\n            $this->set('branch', $this->Server->getCurrentBranch());\n            $this->render('ajax/update');\n        }\n    }\n\n    public function ondemandAction()\n    {\n        $this->AdminSetting = ClassRegistry::init('AdminSetting');\n        $actions = $this->Server->actions_description;\n        $default_fields = array(\n            'title' => '',\n            'description' => '',\n            'liveOff' => false,\n            'recommendBackup' => false,\n            'exitOnError' => false,\n            'requirements' => '',\n            'url' => $this->baseurl . '/'\n        );\n        foreach($actions as $id => $action) {\n            foreach($default_fields as $field => $value) {\n                if (!isset($action[$field])) {\n                    $actions[$id][$field] = $value;\n                }\n            }\n            $done = $this->AdminSetting->getSetting($id);\n            $actions[$id]['done'] = ($done == '1');\n        }\n        $this->set('actions', $actions);\n        $this->set('updateLocked', $this->Server->isUpdateLocked());\n    }\n\n    public function updateProgress($ajaxHtml=false)\n    {\n        $this->AdminSetting = ClassRegistry::init('AdminSetting');\n        $dbVersion = $this->AdminSetting->getSetting('db_version');\n        $updateProgress = $this->Server->getUpdateProgress();\n        $updateProgress['db_version'] = $dbVersion;\n        $maxUpdateNumber = max(array_keys(Server::DB_CHANGES));\n        $updateProgress['complete_update_remaining'] = max($maxUpdateNumber - $dbVersion, 0);\n        $updateProgress['update_locked'] = $this->Server->isUpdateLocked();\n        $updateProgress['lock_remaining_time'] = $this->Server->getLockRemainingTime();\n        $updateProgress['update_fail_number_reached'] = $this->Server->UpdateFailNumberReached();\n        $currentIndex = $updateProgress['current'];\n        $currentCommand = !isset($updateProgress['commands'][$currentIndex]) ? '' : $updateProgress['commands'][$currentIndex];\n        $lookupString = preg_replace('/\\s{2,}/', '', substr($currentCommand, 0, -1));\n        $sqlInfo = $this->Server->query(\"SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST;\");\n        if (empty($sqlInfo)) {\n            $updateProgress['process_list'] = array();\n        } else {\n            // retrieve current update process\n            foreach($sqlInfo as $row) {\n                if (preg_replace('/\\s{2,}/', '', $row['PROCESSLIST']['INFO']) == $lookupString) {\n                    $sqlInfo = $row['PROCESSLIST'];\n                    break;\n                }\n            }\n            $updateProgress['process_list'] = array();\n            $updateProgress['process_list']['STATE'] = isset($sqlInfo['STATE']) ? $sqlInfo['STATE'] : '';\n            $updateProgress['process_list']['PROGRESS'] = isset($sqlInfo['PROGRESS']) ? $sqlInfo['PROGRESS'] : 0;\n            $updateProgress['process_list']['STAGE'] = isset($sqlInfo['STAGE']) ? $sqlInfo['STAGE'] : 0;\n            $updateProgress['process_list']['MAX_STAGE'] = isset($sqlInfo['MAX_STAGE']) ? $sqlInfo['MAX_STAGE'] : 0;\n        }\n        $this->set('ajaxHtml', $ajaxHtml);\n        if ($this->request->is('ajax') && $ajaxHtml) {\n            $this->set('updateProgress', $updateProgress);\n            $this->layout = false;\n        } elseif ($this->request->is('ajax') || $this->_isRest()) {\n            return $this->RestResponse->viewData(h($updateProgress), $this->response->type());\n        } else {\n            $this->set('updateProgress', $updateProgress);\n        }\n    }\n\n\n    public function getSubmoduleQuickUpdateForm($submodule_path=false) {\n        $this->set('submodule', base64_decode($submodule_path));\n        $this->render('ajax/submodule_quick_update_form');\n    }\n\n    public function updateSubmodule()\n    {\n        if ($this->request->is('post')) {\n            $request = $this->request->data;\n            $submodule = $request['Server']['submodule'];\n            $res = $this->Server->updateSubmodule($this->Auth->user(), $submodule);\n            return new CakeResponse(array('body'=> json_encode($res), 'type' => 'json'));\n        } else {\n            throw new MethodNotAllowedException();\n        }\n    }\n\n    public function getInstanceUUID()\n    {\n        return $this->RestResponse->viewData(array('uuid' => Configure::read('MISP.uuid')), $this->response->type());\n    }\n\n    public function cache($id = 'all')\n    {\n        if (Configure::read('MISP.background_jobs')) {\n\n            $this->loadModel('Job');\n            $jobId = $this->Job->createJob(\n                $this->Auth->user(),\n                Job::WORKER_DEFAULT,\n                'cache_servers',\n                intval($id) ? $id : 'all',\n                __('Starting server caching.')\n            );\n\n            $this->Server->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::DEFAULT_QUEUE,\n                BackgroundJobsTool::CMD_SERVER,\n                [\n                    'cacheServer',\n                    $this->Auth->user('id'),\n                    $id,\n                    $jobId\n                ],\n                false,\n                $jobId\n            );\n\n            $message = 'Server caching job initiated.';\n        } else {\n            $result = $this->Server->cacheServerInitiator($this->Auth->user(), $id);\n            if (!$result) {\n                $this->Flash->error(__('Caching the servers has failed.'));\n                $this->redirect(array('action' => 'index'));\n            }\n            $message = __('Caching the servers has successfully completed.');\n        }\n        if ($this->_isRest()) {\n            return $this->RestResponse->saveSuccessResponse('Server', 'cache', false, $this->response->type(), $message);\n        } else {\n            $this->Flash->info($message);\n            $this->redirect(array('action' => 'index'));\n        }\n    }\n\n    public function updateJSON()\n    {\n        $results = $this->Server->updateJSON();\n        return $this->RestResponse->viewData($results, $this->response->type());\n    }\n\n    public function createSync()\n    {\n        if ($this->_isSiteAdmin()) {\n            throw new MethodNotAllowedException('Site admin accounts cannot be used to create server sync configurations.');\n        }\n        $baseurl = Configure::read('MISP.external_baseurl');\n        if (empty($baseurl)) {\n            $baseurl = Configure::read('MISP.baseurl');\n            if (empty($baseurl)) {\n                $baseurl = Router::url('/', true);\n            }\n        }\n        $host_org_id = Configure::read('MISP.host_org_id');\n        if (empty($host_org_id)) {\n            throw new MethodNotAllowedException(__('Cannot create sync config - no host org ID configured for the instance.'));\n        }\n        $this->loadModel('Organisation');\n        $host_org = $this->Organisation->find('first', array(\n            'conditions' => array('Organisation.id' => $host_org_id),\n            'recursive' => -1,\n            'fields' => array('name', 'uuid')\n        ));\n        if (empty($host_org)) {\n            throw new MethodNotAllowedException(__('Configured host org not found. Please make sure that the setting is current on the instance.'));\n        }\n        if (Configure::read('Security.advanced_authkeys')) {\n            $this->loadModel('AuthKey');\n            $authkey = $this->AuthKey->createnewkey($this->Auth->user('id'), null, __('Auto generated sync key - %s', date('Y-m-d H:i:s')));\n        } else {\n            $this->loadModel('User');\n            $authkey = $this->User->find('column', [\n                'conditions' => ['User.id' => $this->Auth->user('id')],\n                'recursive' => -1,\n                'fields' => ['User.authkey']\n            ]);\n            $authkey = $authkey[0];\n        }\n        $server = array(\n            'Server' => array(\n                'url' => $baseurl,\n                'uuid' => Configure::read('MISP.uuid'),\n                'authkey' => h($authkey),\n                'Organisation' => array(\n                    'name' => $host_org['Organisation']['name'],\n                    'uuid' => $host_org['Organisation']['uuid'],\n                )\n            )\n        );\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($server, $this->response->type());\n        } else {\n            $this->set('server', $server);\n        }\n    }\n\n    public function import()\n    {\n        if ($this->request->is('post')) {\n            $server = $this->request->data;\n            if (isset($server['Server'])) {\n                $server = $server['Server'];\n            }\n            if (isset($server['json'])) {\n                $server = json_decode($server['json'], true)['Server'];\n            }\n            $this->loadModel('Organisation');\n            $org_id = $this->Organisation->captureOrg($server['Organisation'], $this->Auth->user());\n            $toSave = array(\n                'push' => 0,\n                'pull' => 0,\n                'caching_enabled' => 0,\n                'json' => '[]',\n                'push_rules' => '[]',\n                'pull_rules' => '[]',\n                'self_signed' => 0,\n                'org_id' => $this->Auth->user('org_id'),\n                'remote_org_id' => $org_id,\n                'name' => empty($server['name']) ? $server['url'] : $server['name'],\n                'url' => $server['url'],\n                'uuid' => $server['uuid'],\n                'authkey' => $server['authkey']\n            );\n            $this->Server->create();\n            $result = $this->Server->save($toSave);\n            if ($result) {\n                if ($this->_isRest()) {\n                    $server = $this->Server->find('first', array(\n                        'conditions' => array('Server.id' => $this->Server->id),\n                        'recursive' => -1\n                    ));\n                    return $this->RestResponse->viewData($server, $this->response->type());\n                } else {\n                    $this->Flash->success(__('The server has been saved'));\n                    $this->redirect(array('action' => 'index', $this->Server->id));\n                }\n            } else {\n                if ($this->_isRest()) {\n                    return $this->RestResponse->saveFailResponse('Servers', 'addFromJson', false, $this->Server->validationErrors, $this->response->type());\n                } else {\n                    $this->Flash->error(__('Could not save the server. Error: %s', json_encode($this->Server->validationErrors, true)));\n                    $this->redirect(array('action' => 'index'));\n                }\n            }\n        }\n    }\n\n    public function resetRemoteAuthKey($id)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException(__('This endpoint expects POST requests.'));\n        }\n        $result = $this->Server->resetRemoteAuthkey($id);\n        if ($result !== true) {\n            if (!$this->_isRest()) {\n                $this->Flash->error($result);\n                $this->redirect(array('action' => 'index'));\n            } else {\n                return $this->RestResponse->saveFailResponse('Servers', 'resetRemoteAuthKey', $id, $message, $this->response->type());\n            }\n        } else {\n            $message = __('API key updated.');\n            if (!$this->_isRest()) {\n                $this->Flash->success($message);\n                $this->redirect(array('action' => 'index'));\n            } else {\n                return $this->RestResponse->saveSuccessResponse('Servers', 'resetRemoteAuthKey', $message, $this->response->type());\n            }\n        }\n    }\n\n    public function changePriority($id = false, $direction = 'down')\n    {\n        $this->Server->id = $id;\n        if (!$this->Server->exists()) {\n            throw new InvalidArgumentException(__('ID has to be a valid server connection'));\n        }\n        if ($direction !== 'up' && $direction !== 'down') {\n            throw new InvalidArgumentException(__('Invalid direction. Valid options: ', 'up', 'down'));\n        }\n        $success = $this->Server->reprioritise($id, $direction);\n        if ($success) {\n            $message = __('Priority changed.');\n            return $this->RestResponse->saveSuccessResponse('Servers', 'changePriority', $message, $this->response->type());\n        } else {\n            $message = __('Priority could not be changed.');\n            return $this->RestResponse->saveFailResponse('Servers', 'changePriority', $id, $message, $this->response->type());\n        }\n    }\n\n    public function releaseUpdateLock()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException(__('This endpoint expects POST requests.'));\n        }\n        $this->Server->changeLockState(false);\n        $this->Server->resetUpdateFailNumber();\n        $this->redirect(array('action' => 'updateProgress'));\n    }\n\n    public function dbSchemaDiagnostic()\n    {\n        $dbSchemaDiagnostics = $this->Server->dbSchemaDiagnostic();\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($dbSchemaDiagnostics, $this->response->type());\n        } else {\n            $this->set('checkedTableColumn', $dbSchemaDiagnostics['checked_table_column']);\n            $this->set('dbSchemaDiagnostics', $dbSchemaDiagnostics['diagnostic']);\n            $this->set('dbIndexDiagnostics', $dbSchemaDiagnostics['diagnostic_index']);\n            $this->set('expectedDbVersion', $dbSchemaDiagnostics['expected_db_version']);\n            $this->set('actualDbVersion', $dbSchemaDiagnostics['actual_db_version']);\n            $this->set('error', $dbSchemaDiagnostics['error']);\n            $this->set('remainingLockTime', $dbSchemaDiagnostics['remaining_lock_time']);\n            $this->set('updateFailNumberReached', $dbSchemaDiagnostics['update_fail_number_reached']);\n            $this->set('updateLocked', $dbSchemaDiagnostics['update_locked']);\n            $this->set('dataSource', $dbSchemaDiagnostics['dataSource']);\n            $this->set('columnPerTable', $dbSchemaDiagnostics['columnPerTable']);\n            $this->set('indexes', $dbSchemaDiagnostics['indexes']);\n            $this->render('/Elements/healthElements/db_schema_diagnostic');\n        }\n    }\n\n    public function dbConfiguration()\n    {\n        $dbConfiguration = $this->Server->dbConfiguration();\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($dbConfiguration, $this->response->type());\n        } else {\n            $this->set('dbConfiguration', $dbConfiguration);\n            $this->render('/Elements/healthElements/db_config_diagnostic');\n        }\n    }\n\n    public function cspReport()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException('This action expects a POST request.');\n        }\n\n        $report = JsonTool::decode($this->request->input());\n        if (!isset($report['csp-report'])) {\n            throw new RuntimeException(\"Invalid report\");\n        }\n\n        $message = 'CSP reported violation';\n        $remoteIp = $this->_remoteIp();\n        if ($remoteIp) {\n            $message .= ' from IP ' . $remoteIp;\n        }\n        $report = JsonTool::encode($report['csp-report'], true);\n        if (strlen($report) > 1024 * 1024) { // limit report to 1 kB\n            $report = substr($report, 0, 1024 * 1024) . '...';\n        }\n        $this->log(\"$message: $report\");\n\n        return new CakeResponse(['status' => 204]);\n    }\n\n    /**\n     * List all tags for the rule picker.\n     *\n     * @return array\n     */\n    private function __getTags()\n    {\n        $this->loadModel('Tag');\n        $list = $this->Tag->find('list', array(\n            'recursive' => -1,\n            'order' => array('LOWER(TRIM(Tag.name))' => 'ASC'),\n            'fields' => array('name'),\n        ));\n        $allTags = array();\n        foreach ($list as $id => $name) {\n            $allTags[] = array('id' => $id, 'name' => trim($name));\n        }\n        return $allTags;\n    }\n\n    public function removeOrphanedCorrelations()\n    {\n        $count = $this->Server->removeOrphanedCorrelations();\n        $message = __('%s orphaned correlation removed', $count);\n        if ($this->_isRest()) {\n            return $this->RestResponse->viewData($message, $this->response->type());\n        } else {\n            $this->Flash->success($message);\n            $this->redirect(array('action' => 'serverSettings', 'diagnostics'));\n        }\n    }\n\n    public function queryAvailableSyncFilteringRules($serverID)\n    {\n        if (!$this->_isRest()) {\n            throw new MethodNotAllowedException(__('This method can only be access via REST'));\n        }\n        $server = $this->Server->find('first', ['conditions' => ['Server.id' => $serverID]]);\n        if (!$server) {\n            throw new NotFoundException(__('Invalid server'));\n        }\n        $syncFilteringRules = $this->Server->queryAvailableSyncFilteringRules($server);\n        return $this->RestResponse->viewData($syncFilteringRules);\n    }\n\n    public function getAvailableSyncFilteringRules()\n    {\n        if (!$this->_isRest()) {\n            throw new MethodNotAllowedException(__('This method can only be access via REST'));\n        }\n        $syncFilteringRules = $this->Server->getAvailableSyncFilteringRules($this->Auth->user());\n        return $this->RestResponse->viewData($syncFilteringRules);\n    }\n\n    public function pruneDuplicateUUIDs()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        $this->loadModel('Attribute');\n        $duplicates = $this->Attribute->find('all', array(\n            'fields' => array('Attribute.uuid', 'count(*) as occurance'),\n            'recursive' => -1,\n            'group' => array('Attribute.uuid HAVING COUNT(*) > 1'),\n        ));\n        $counter = 0;\n        foreach ($duplicates as $duplicate) {\n            $attributes = $this->Attribute->find('all', array(\n                'recursive' => -1,\n                'conditions' => array('uuid' => $duplicate['Attribute']['uuid'])\n            ));\n            foreach ($attributes as $k => $attribute) {\n                if ($k > 0) {\n                    $this->Attribute->delete($attribute['Attribute']['id']);\n                    $counter++;\n                }\n            }\n        }\n        $this->Server->updateDatabase('makeAttributeUUIDsUnique');\n        $this->Flash->success('Done. Deleted ' . $counter . ' duplicate attribute(s).');\n        $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n    }\n\n    public function removeDuplicateEvents()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        $this->loadModel('Event');\n        $duplicates = $this->Event->find('all', array(\n            'fields' => array('Event.uuid', 'count(*) as occurance'),\n            'recursive' => -1,\n            'group' => array('Event.uuid HAVING COUNT(*) > 1'),\n        ));\n        $counter = 0;\n\n        // load this so we can remove the blocklist item that will be created, this is the one case when we do not want it.\n        if (Configure::read('MISP.enableEventBlocklisting') !== false) {\n            $this->EventBlocklist = ClassRegistry::init('EventBlocklist');\n        }\n\n        foreach ($duplicates as $duplicate) {\n            $events = $this->Event->find('all', array(\n                'recursive' => -1,\n                'conditions' => array('uuid' => $duplicate['Event']['uuid'])\n            ));\n            foreach ($events as $k => $event) {\n                if ($k > 0) {\n                    $uuid = $event['Event']['uuid'];\n                    $this->Event->delete($event['Event']['id']);\n                    $counter++;\n                    // remove the blocklist entry that we just created with the event deletion, if the feature is enabled\n                    // We do not want to block the UUID, since we just deleted a copy\n                    if (Configure::read('MISP.enableEventBlocklisting') !== false) {\n                        $this->EventBlocklist->deleteAll(array('EventBlocklist.event_uuid' => $uuid));\n                    }\n                }\n            }\n        }\n        $this->Server->updateDatabase('makeEventUUIDsUnique');\n        $this->Flash->success('Done. Removed ' . $counter . ' duplicate events.');\n        $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n    }\n\n    public function upgrade2324()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        if (!Configure::read('MISP.background_jobs')) {\n            $this->Server->upgrade2324($this->Auth->user('id'));\n            $this->Flash->success('Done. For more details check the audit logs.');\n            $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n        } else {\n\n            $this->loadModel('Job');\n            $jobId = $this->Job->createJob(\n                $this->Auth->user(),\n                Job::WORKER_DEFAULT,\n                'upgrade_24',\n                'Old database',\n                __('Job created.')\n            );\n\n            $this->Server->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::DEFAULT_QUEUE,\n                BackgroundJobsTool::CMD_ADMIN,\n                [\n                    'jobUpgrade24',\n                    $jobId,\n                    $this->Auth->user('id'),\n                ],\n                true,\n                $jobId\n            );\n\n            $this->Flash->success(__('Job queued. You can view the progress if you navigate to the active jobs view (administration -> jobs).'));\n            $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n        }\n    }\n\n    public function cleanModelCaches()\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        $this->Server->cleanCacheFiles();\n        $this->Flash->success('Caches cleared.');\n        $this->redirect(array('controller' => 'servers', 'action' => 'serverSettings', 'diagnostics'));\n    }\n\n    public function updateDatabase($command)\n    {\n        if (!$this->request->is('post')) {\n            throw new MethodNotAllowedException();\n        }\n        if (is_numeric($command)) {\n            $command = intval($command);\n        }\n        $this->Server->updateDatabase($command);\n        $this->Flash->success('Done.');\n        if ($liveOff) {\n            $this->redirect(array('controller' => 'servers', 'action' => 'updateProgress'));\n        } else {\n            $this->redirect(array('controller' => 'pages', 'action' => 'display', 'administration'));\n        }\n    }\n\n    public function ipUser($input = false)\n    {\n        $params = $this->IndexFilter->harvestParameters(['ip']);\n        if (!empty($params['ip'])) {\n            $input = $params['ip'];\n        }\n        $redis = $this->Server->setupRedis();\n        if (!is_array($input)) {\n            $input = [$input];\n        }\n        $users = [];\n        foreach ($input as $ip) {\n            if (!filter_var($ip, FILTER_VALIDATE_IP)) {\n                continue;\n            }\n            $user_id = $redis->get('misp:ip_user:' . $ip);\n            if (empty($user_id)) {\n                continue;\n            }\n            $this->loadModel('User');\n            $user = $this->User->find('first', [\n                'recursive' => -1,\n                'conditions' => ['User.id' => $user_id],\n                'contain' => ['Organisation.name']\n            ]);\n            if (empty($user)) {\n                throw new NotFoundException(__('User not found (perhaps it has been removed?).'));\n            }\n            $users[$ip] = [\n                'id' => $user['User']['id'],\n                'email' => $user['User']['email'],\n            ];\n        }\n        return $this->RestResponse->viewData($users, $this->response->type());\n    }\n\n    /**\n     * @deprecated\n     * @return void\n     */\n    public function rest()\n    {\n        $this->redirect(['controller' => 'api', 'action' => 'rest']);\n    }\n}\n", "<?php\n\nclass SyncTool\n{\n\n    const ALLOWED_CERT_FILE_EXTENSIONS = ['pem', 'crt'];\n\n    /**\n     * Take a server as parameter and return a HttpSocket object using the ssl options defined in the server settings\n     * @param array|null $server\n     * @param false $timeout\n     * @param string $model\n     * @return HttpSocketExtended\n     * @throws Exception\n     */\n    public function setupHttpSocket($server = null, $timeout = false, $model = 'Server')\n    {\n        $params = ['compress' => true];\n        if (!empty($server)) {\n            if (!empty($server[$model]['cert_file'])) {\n                $params['ssl_cafile'] = APP . \"files\" . DS . \"certs\" . DS . $server[$model]['cert_file'];\n            }\n            if (!empty($server[$model]['client_cert_file'])) {\n                $params['ssl_local_cert'] = APP . \"files\" . DS . \"certs\" . DS . $server[$model]['client_cert_file'];\n            }\n            if (!empty($server[$model]['self_signed'])) {\n                $params['ssl_allow_self_signed'] = true;\n                $params['ssl_verify_peer_name'] = false;\n                if (!isset($server[$model]['cert_file'])) {\n                    $params['ssl_verify_peer'] = false;\n                }\n            }\n            if (!empty($server[$model]['skip_proxy'])) {\n                $params['skip_proxy'] = 1;\n            }\n            if (!empty($timeout)) {\n                $params['timeout'] = $timeout;\n            }\n        }\n\n        return $this->createHttpSocket($params);\n    }\n\n    public function setupHttpSocketFeed()\n    {\n        return $this->createHttpSocket(['compress' => true]);\n    }\n\n    /**\n     * @param array $params\n     * @return HttpSocketExtended\n     * @throws Exception\n     */\n    public function createHttpSocket($params = array())\n    {\n        // Use own CA PEM file\n        $caPath = Configure::read('MISP.ca_path');\n        if (!isset($params['ssl_cafile']) && $caPath) {\n            if (!file_exists($caPath)) {\n                throw new Exception(\"CA file '$caPath' doesn't exists.\");\n            }\n            $params['ssl_cafile'] = $caPath;\n        }\n\n        if ($minTlsVersion = Configure::read('Security.min_tls_version')) {\n            $version = 0;\n            switch ($minTlsVersion) {\n                case 'tlsv1_0':\n                    $version |= STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT;\n                case 'tlsv1_1':\n                    $version |= STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT;\n                case 'tlsv1_2':\n                    $version |= STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT;\n                case 'tlsv1_3':\n                    if (defined('STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT')) {\n                        $version |= STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT;\n                    } else if ($minTlsVersion === 'tlsv1_3') {\n                        throw new Exception(\"TLSv1.3 is not supported by PHP.\");\n                    }\n                    break;\n                default:\n                    throw new InvalidArgumentException(\"Invalid `Security.min_tls_version` option $minTlsVersion\");\n            }\n            $params['ssl_crypto_method'] = $version;\n        }\n\n        App::uses('HttpSocketExtended', 'Tools');\n        $HttpSocket = new HttpSocketExtended($params);\n        $proxy = Configure::read('Proxy');\n        if (empty($params['skip_proxy']) && isset($proxy['host']) && !empty($proxy['host'])) {\n            $HttpSocket->configProxy($proxy['host'], $proxy['port'], $proxy['method'], $proxy['user'], $proxy['password']);\n        }\n        return $HttpSocket;\n    }\n\n    /**\n     * @param array $server\n     * @return array|void\n     * @throws Exception\n     */\n    public static function getServerClientCertificateInfo(array $server)\n    {\n        if (!$server['Server']['client_cert_file']) {\n            return;\n        }\n\n        $clientCertificate = new File(APP . \"files\" . DS . \"certs\" . DS . $server['Server']['id'] . '_client.pem');\n        if (!$clientCertificate->exists()) {\n            throw new Exception(\"Certificate file '{$clientCertificate->pwd()}' doesn't exists.\");\n        }\n\n        $certificateContent = $clientCertificate->read();\n        if ($certificateContent === false) {\n            throw new Exception(\"Could not read '{$clientCertificate->pwd()}' file with client certificate.\");\n        }\n\n        return self::getClientCertificateInfo($certificateContent);\n    }\n\n    /**\n     * @param array $server\n     * @return array|void\n     * @throws Exception\n     */\n    public static function getServerCaCertificateInfo(array $server)\n    {\n        if (!$server['Server']['cert_file']) {\n            return;\n        }\n\n        $caCertificate = new File(APP . \"files\" . DS . \"certs\" . DS . $server['Server']['id'] . '.pem');\n        if (!$caCertificate->exists()) {\n            throw new Exception(\"Certificate file '{$caCertificate->pwd()}' doesn't exists.\");\n        }\n\n        $certificateContent = $caCertificate->read();\n        if ($certificateContent === false) {\n            throw new Exception(\"Could not read '{$caCertificate->pwd()}' file with certificate.\");\n        }\n\n        $certificate = openssl_x509_read($certificateContent);\n        if (!$certificate) {\n            throw new Exception(\"Couldn't read certificate: \" . openssl_error_string());\n        }\n\n        return self::parseCertificate($certificate);\n    }\n\n    /**\n     * @param string $certificateContent PEM encoded certificate and private key.\n     * @return array\n     * @throws Exception\n     */\n    private static function getClientCertificateInfo($certificateContent)\n    {\n        $certificate = openssl_x509_read($certificateContent);\n        if (!$certificate) {\n            throw new Exception(\"Couldn't read certificate: \" . openssl_error_string());\n        }\n        $privateKey = openssl_pkey_get_private($certificateContent);\n        if (!$privateKey) {\n            throw new Exception(\"Couldn't get private key from certificate: \" . openssl_error_string());\n        }\n        $verify = openssl_x509_check_private_key($certificate, $privateKey);\n        if (!$verify) {\n            throw new Exception('Public and private key do not match.');\n        }\n        return self::parseCertificate($certificate);\n    }\n\n    /**\n     * @param mixed $certificate\n     * @return array\n     * @throws Exception\n     */\n    private static function parseCertificate($certificate)\n    {\n        $parsed = openssl_x509_parse($certificate);\n        if (!$parsed) {\n            throw new Exception(\"Couldn't get parse X.509 certificate: \" . openssl_error_string());\n        }\n        $currentTime = new DateTime();\n        $output = [\n            'serial_number' => $parsed['serialNumberHex'],\n            'signature_type' => $parsed['signatureTypeSN'],\n            'valid_from' => isset($parsed['validFrom_time_t']) ? new DateTime(\"@{$parsed['validFrom_time_t']}\") : null,\n            'valid_to' => isset($parsed['validTo_time_t']) ? new DateTime(\"@{$parsed['validTo_time_t']}\") : null,\n            'public_key_size' => null,\n            'public_key_type' => null,\n            'public_key_size_ok' => null,\n        ];\n\n        $output['valid_from_ok'] = $output['valid_from'] ? ($output['valid_from'] <= $currentTime) : null;\n        $output['valid_to_ok'] = $output['valid_to'] ? ($output['valid_to'] >= $currentTime) : null;\n\n        $subject = [];\n        foreach ($parsed['subject'] as $type => $value) {\n            $subject[] = \"$type=$value\";\n        }\n        $output['subject'] = implode(', ', $subject);\n\n        $issuer = [];\n        foreach ($parsed['issuer'] as $type => $value) {\n            $issuer[] = \"$type=$value\";\n        }\n        $output['issuer'] = implode(', ', $issuer);\n\n        $publicKey = openssl_pkey_get_public($certificate);\n        if ($publicKey) {\n            $publicKeyDetails = openssl_pkey_get_details($publicKey);\n            if ($publicKeyDetails) {\n                $output['public_key_size'] = $publicKeyDetails['bits'];\n                switch ($publicKeyDetails['type']) {\n                    case OPENSSL_KEYTYPE_RSA:\n                        $output['public_key_type'] = 'RSA';\n                        $output['public_key_size_ok'] = $output['public_key_size'] >= 2048;\n                        break;\n                    case OPENSSL_KEYTYPE_DSA:\n                        $output['public_key_type'] = 'DSA';\n                        $output['public_key_size_ok'] = $output['public_key_size'] >= 2048;\n                        break;\n                    case OPENSSL_KEYTYPE_DH:\n                        $output['public_key_type'] = 'DH';\n                        break;\n                    case OPENSSL_KEYTYPE_EC:\n                        $output['public_key_type'] = \"EC ({$publicKeyDetails['ec']['curve_name']})\";\n                        $output['public_key_size_ok'] = $output['public_key_size'] >= 224;\n                        break;\n                }\n            }\n        }\n\n        return $output;\n    }\n}\n"], "filenames": ["app/Controller/ServersController.php", "app/Lib/Tools/SyncTool.php"], "buggy_code_start_loc": [917, 4], "buggy_code_end_loc": [942, 22], "fixing_code_start_loc": [918, 5], "fixing_code_end_loc": [964, 25], "type": "CWE-209", "message": "MISP 2.4.172 mishandles different certificate file extensions in server sync. An attacker can obtain sensitive information because of the nature of the error messages.", "other": {"cve": {"id": "CVE-2023-37306", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-30T17:15:09.757", "lastModified": "2023-07-07T19:00:31.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MISP 2.4.172 mishandles different certificate file extensions in server sync. An attacker can obtain sensitive information because of the nature of the error messages."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp-project:malware_information_sharing_platform:2.4.172:*:*:*:*:*:*:*", "matchCriteriaId": "08CB9C04-9845-4D45-B9A3-D473B10E5E0D"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/f125630c1c2d0f5d11079d3653ab7bb2ab5cd908", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/f125630c1c2d0f5d11079d3653ab7bb2ab5cd908"}}