{"buggy_code": ["\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 16\nVisualStudioVersion = 16.0.29609.76\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB\", \"LiteDB\\LiteDB.csproj\", \"{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB.Tests\", \"LiteDB.Tests\\LiteDB.Tests.csproj\", \"{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB.Shell\", \"LiteDB.Shell\\LiteDB.Shell.csproj\", \"{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB.Benchmarks\", \"LiteDB.Benchmarks\\LiteDB.Benchmarks.csproj\", \"{DF9C82C1-446F-458A-AA50-78E58BA17273}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB.Stress\", \"LiteDB.Stress\\LiteDB.Stress.csproj\", \"{FFBC5669-DA32-4907-8793-7B414279DA3B}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{DF9C82C1-446F-458A-AA50-78E58BA17273}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{DF9C82C1-446F-458A-AA50-78E58BA17273}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{DF9C82C1-446F-458A-AA50-78E58BA17273}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{DF9C82C1-446F-458A-AA50-78E58BA17273}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{FFBC5669-DA32-4907-8793-7B414279DA3B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{FFBC5669-DA32-4907-8793-7B414279DA3B}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{FFBC5669-DA32-4907-8793-7B414279DA3B}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{FFBC5669-DA32-4907-8793-7B414279DA3B}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {45099B85-2AE1-434B-913A-6AD14FD3AF4A}\n\tEndGlobalSection\n\tGlobalSection(Performance) = preSolution\n\t\tHasPerformanceSessions = true\n\tEndGlobalSection\nEndGlobal\n", "using System;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Reflection;\nusing static LiteDB.Constants;\n\nnamespace LiteDB\n{\n    public partial class BsonMapper\n    {\n        #region Basic direct .NET convert types\n\n        // direct bson types\n        private HashSet<Type> _bsonTypes = new HashSet<Type>\n        {\n            typeof(String),\n            typeof(Int32),\n            typeof(Int64),\n            typeof(Boolean),\n            typeof(Guid),\n            typeof(DateTime),\n            typeof(Byte[]),\n            typeof(ObjectId),\n            typeof(Double),\n            typeof(Decimal)\n        };\n\n        // simple convert types\n        private HashSet<Type> _basicTypes = new HashSet<Type>\n        {\n            typeof(Int16),\n            typeof(UInt16),\n            typeof(UInt32),\n            typeof(Single),\n            typeof(Char),\n            typeof(Byte),\n            typeof(SByte)\n        };\n\n        #endregion\n\n        /// <summary>\n        /// Deserialize a BsonDocument to entity class\n        /// </summary>\n        public virtual object ToObject(Type type, BsonDocument doc)\n        {\n            if (doc == null) throw new ArgumentNullException(nameof(doc));\n\n            // if T is BsonDocument, just return them\n            if (type == typeof(BsonDocument)) return doc;\n\n            return this.Deserialize(type, doc);\n        }\n\n        /// <summary>\n        /// Deserialize a BsonDocument to entity class\n        /// </summary>\n        public virtual T ToObject<T>(BsonDocument doc)\n        {\n            return (T)this.ToObject(typeof(T), doc);\n        }\n\n        /// <summary>\n        /// Deserialize a BsonValue to .NET object typed in T\n        /// </summary>\n        public T Deserialize<T>(BsonValue value)\n        {\n            if (value == null) return default(T);\n\n            var result = this.Deserialize(typeof(T), value);\n\n            return (T)result;\n        }\n\n        /// <summary>\n        /// Deserilize a BsonValue to .NET object based on type parameter\n        /// </summary>\n        public object Deserialize(Type type, BsonValue value)\n        {\n            // null value - null returns\n            if (value.IsNull) return null;\n\n            // if is nullable, get underlying type\n            if (Reflection.IsNullable(type))\n            {\n                type = Reflection.UnderlyingTypeOf(type);\n            }\n\n            // test if has a custom type implementation\n            if (_customDeserializer.TryGetValue(type, out Func<BsonValue, object> custom))\n            {\n                return custom(value);\n            }\n\n            var typeInfo = type.GetTypeInfo();\n\n            // check if your type is already a BsonValue/BsonDocument/BsonArray\n            if (type == typeof(BsonValue))\n            {\n                return value;\n            }\n            else if (type == typeof(BsonDocument))\n            {\n                return value.AsDocument;\n            }\n            else if (type == typeof(BsonArray))\n            {\n                return value.AsArray;\n            }\n\n            // raw values to native bson values\n            else if (_bsonTypes.Contains(type))\n            {\n                return value.RawValue;\n            }\n\n            // simple ConvertTo to basic .NET types\n            else if (_basicTypes.Contains(type))\n            {\n                return Convert.ChangeType(value.RawValue, type);\n            }\n\n            // special cast to UInt64 to Int64\n            else if (type == typeof(UInt64))\n            {\n                return unchecked((UInt64)value.AsInt64);\n            }\n\n            // enum value is an int\n            else if (typeInfo.IsEnum)\n            {\n                if (value.IsString) return Enum.Parse(type, value.AsString);\n\n                if (value.IsNumber) return Enum.ToObject(type, value.AsInt32);\n            }\n\n            // if value is array, deserialize as array\n            else if (value.IsArray)\n            {\n                // when array are from an object (like in Dictionary<string, object> { [\"array\"] = new string[] { \"a\", \"b\" } \n                if (type == typeof(object))\n                {\n                    return this.DeserializeArray(typeof(object), value.AsArray);\n                }\n                if (type.IsArray)\n                {\n                    return this.DeserializeArray(type.GetElementType(), value.AsArray);\n                }\n                else\n                {\n                    return this.DeserializeList(type, value.AsArray);\n                }\n            }\n\n            // if value is document, deserialize as document\n            else if (value.IsDocument)\n            {\n                // if type is anonymous use special handler\n                if (type.IsAnonymousType())\n                {\n                    return this.DeserializeAnonymousType(type, value.AsDocument);\n                }\n\n                var doc = value.AsDocument;\n\n                // test if value is object and has _type\n                if (doc.TryGetValue(\"_type\", out var typeField) && typeField.IsString)\n                {\n                    var actualType = _typeNameBinder.GetType(typeField.AsString);\n\n                    if (actualType == null) throw LiteException.InvalidTypedName(typeField.AsString);\n                    if (!type.IsAssignableFrom(actualType)) throw LiteException.DataTypeNotAssignable(type.FullName, actualType.FullName);\n\n                    type = actualType;\n                }\n                // when complex type has no definition (== typeof(object)) use Dictionary<string, object> to better set values\n                else if (type == typeof(object))\n                {\n                    type = typeof(Dictionary<string, object>);\n                }\n\n                var entity = this.GetEntityMapper(type);\n\n                // initialize CreateInstance\n                if (entity.CreateInstance == null)\n                {\n                    entity.CreateInstance =\n                        this.GetTypeCtor(entity) ??\n                        ((BsonDocument v) => Reflection.CreateInstance(entity.ForType));\n                }\n\n                var o = _typeInstantiator(type) ?? entity.CreateInstance(doc);\n\n                if (o is IDictionary dict)\n                {\n                    if (o.GetType().GetTypeInfo().IsGenericType)\n                    {\n                        var k = type.GetGenericArguments()[0];\n                        var t = type.GetGenericArguments()[1];\n\n                        this.DeserializeDictionary(k, t, dict, value.AsDocument);\n                    }\n                    else\n                    {\n                        this.DeserializeDictionary(typeof(object), typeof(object), dict, value.AsDocument);\n                    }\n                }\n                else\n                {\n                    this.DeserializeObject(entity, o, doc);\n                }\n\n                return o;\n            }\n\n            // in last case, return value as-is - can cause \"cast error\"\n            // it's used for \"public object MyInt { get; set; }\"\n            return value.RawValue;\n        }\n\n        private object DeserializeArray(Type type, BsonArray array)\n        {\n            var arr = Array.CreateInstance(type, array.Count);\n            var idx = 0;\n\n            foreach (var item in array)\n            {\n                arr.SetValue(this.Deserialize(type, item), idx++);\n            }\n\n            return arr;\n        }\n\n        private object DeserializeList(Type type, BsonArray value)\n        {\n            var itemType = Reflection.GetListItemType(type);\n            var enumerable = (IEnumerable)Reflection.CreateInstance(type);\n\n            if (enumerable is IList list)\n            {\n                foreach (BsonValue item in value)\n                {\n                    list.Add(this.Deserialize(itemType, item));\n                }\n            }\n            else\n            {\n                var addMethod = type.GetMethod(\"Add\");\n\n                foreach (BsonValue item in value)\n                {\n                    addMethod.Invoke(enumerable, new[] { this.Deserialize(itemType, item) });\n                }\n            }\n\n            return enumerable;\n        }\n\n        private void DeserializeDictionary(Type K, Type T, IDictionary dict, BsonDocument value)\n        {\n            var isKEnum = K.GetTypeInfo().IsEnum;\n            foreach (var el in value.GetElements())\n            {\n                var k = isKEnum ? Enum.Parse(K, el.Key) : K == typeof(Uri) ? new Uri(el.Key) : Convert.ChangeType(el.Key, K);\n                var v = this.Deserialize(T, el.Value);\n\n                dict.Add(k, v);\n            }\n        }\n\n        private void DeserializeObject(EntityMapper entity, object obj, BsonDocument value)\n        {\n            foreach (var member in entity.Members.Where(x => x.Setter != null))\n            {\n                if (value.TryGetValue(member.FieldName, out var val))\n                {\n                    // check if has a custom deserialize function\n                    if (member.Deserialize != null)\n                    {\n                        member.Setter(obj, member.Deserialize(val, this));\n                    }\n                    else\n                    {\n                        member.Setter(obj, this.Deserialize(member.DataType, val));\n                    }\n                }\n            }\n        }\n\n        private object DeserializeAnonymousType(Type type, BsonDocument value)\n        {\n            var args = new List<object>();\n            var ctor = type.GetConstructors()[0];\n\n            foreach (var par in ctor.GetParameters())\n            {\n                var arg = this.Deserialize(par.ParameterType, value[par.Name]);\n\n                args.Add(arg);\n            }\n\n            var obj = Activator.CreateInstance(type, args.ToArray());\n\n            return obj;\n        }\n    }\n}", "<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <TargetFrameworks>net45;netstandard1.3;netstandard2.0</TargetFrameworks>\r\n    <AssemblyVersion>5.0.12</AssemblyVersion>\r\n    <FileVersion>5.0.12</FileVersion>\r\n    <VersionPrefix>5.0.12</VersionPrefix>\r\n    <Authors>Maur\u00edcio David</Authors>\r\n    <Product>LiteDB</Product>\r\n    <Description>LiteDB - A lightweight embedded .NET NoSQL document store in a single datafile</Description>\r\n    <Copyright>MIT</Copyright>\r\n    <NeutralLanguage>en-US</NeutralLanguage>\r\n    <Title>LiteDB</Title>\r\n    <PackageId>LiteDB</PackageId>\r\n    <PackageVersion>5.0.12</PackageVersion>\r\n    <PackageTags>database nosql embedded</PackageTags>\r\n    <PackageIcon>icon_64x64.png</PackageIcon>\r\n    <PackageLicenseFile>LICENSE</PackageLicenseFile>\r\n    <PackageProjectUrl>https://www.litedb.org</PackageProjectUrl>\r\n    <RepositoryUrl>https://github.com/mbdavid/LiteDB</RepositoryUrl>\r\n    <RepositoryType>git</RepositoryType>\r\n    <RootNamespace>LiteDB</RootNamespace>\r\n    <AssemblyName>LiteDB</AssemblyName>\r\n    <GenerateDocumentationFile>true</GenerateDocumentationFile>\r\n    <NetStandardImplicitPackageVersion Condition=\" '$(TargetFramework)' == 'netstandard1.3' \">1.6.1</NetStandardImplicitPackageVersion>\r\n    <NoWarn>1701;1702;1705;1591;0618</NoWarn>\r\n    <DocumentationFile>bin\\$(Configuration)\\$(TargetFramework)\\LiteDB.xml</DocumentationFile>\r\n    <SignAssembly Condition=\"'$(OS)'=='Windows_NT'\">true</SignAssembly>\r\n    <AssemblyOriginatorKeyFile Condition=\"'$(Configuration)' == 'Release'\">LiteDB.snk</AssemblyOriginatorKeyFile>\r\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\r\n  </PropertyGroup>\r\n  \r\n  <!--\r\n  == All variables ==\r\n  HAVE_APP_DOMAIN\r\n  HAVE_PROCESS\r\n  HAVE_ENVIRONMENT\r\n  HAVE_SHA1_MANAGED\r\n  -->\r\n\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'\">\r\n    <DefineConstants>TRACE;DEBUG</DefineConstants>\r\n  </PropertyGroup>\r\n\r\n  <PropertyGroup Condition=\"'$(TargetFramework)' == 'net45'\">\r\n    <DefineConstants>HAVE_SHA1_MANAGED;HAVE_APP_DOMAIN;HAVE_PROCESS;HAVE_ENVIRONMENT</DefineConstants>\r\n  </PropertyGroup>\r\n\r\n  <PropertyGroup Condition=\"'$(TargetFramework)' == 'netstandard2.0'\">\r\n    <DefineConstants>HAVE_SHA1_MANAGED</DefineConstants>\r\n  </PropertyGroup>\r\n\r\n  <!-- Begin References -->\r\n  <ItemGroup>\r\n    <None Include=\"..\\LICENSE\" Pack=\"true\" PackagePath=\"\" />\r\n    <None Include=\"..\\icon_64x64.png\" Pack=\"true\" PackagePath=\"\\\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup Condition=\"'$(TargetFramework)' == 'net45'\">\r\n    <Reference Include=\"System\" />\r\n    <Reference Include=\"System.Runtime\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup Condition=\"'$(TargetFramework)' == 'netstandard1.3'\">\r\n    <PackageReference Include=\"System.Reflection.TypeExtensions\" Version=\"4.5.1\" />\r\n    <PackageReference Include=\"System.Security.Cryptography.Algorithms\" Version=\"4.3.1\" />\r\n  </ItemGroup>\r\n  \r\n  <!-- End References -->\r\n\r\n</Project>\r\n", "using LiteDB.Engine;\nusing System;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static LiteDB.Constants;\n\nnamespace LiteDB\n{\n    /// <summary>\n    /// The main exception for LiteDB\n    /// </summary>\n    public class LiteException : Exception\n    {\n        #region Errors code\n\n        public const int FILE_NOT_FOUND = 101;\n        public const int DATABASE_SHUTDOWN = 102;\n        public const int INVALID_DATABASE = 103;\n        public const int FILE_SIZE_EXCEEDED = 105;\n        public const int COLLECTION_LIMIT_EXCEEDED = 106;\n        public const int INDEX_DROP_ID = 108;\n        public const int INDEX_DUPLICATE_KEY = 110;\n        public const int INVALID_INDEX_KEY = 111;\n        public const int INDEX_NOT_FOUND = 112;\n        public const int INVALID_DBREF = 113;\n        public const int LOCK_TIMEOUT = 120;\n        public const int INVALID_COMMAND = 121;\n        public const int ALREADY_EXISTS_COLLECTION_NAME = 122;\n        public const int ALREADY_OPEN_DATAFILE = 124;\n        public const int INVALID_TRANSACTION_STATE = 126;\n        public const int INDEX_NAME_LIMIT_EXCEEDED = 128;\n        public const int INVALID_INDEX_NAME = 129;\n        public const int INVALID_COLLECTION_NAME = 130;\n        public const int TEMP_ENGINE_ALREADY_DEFINED = 131;\n        public const int INVALID_EXPRESSION_TYPE = 132;\n        public const int COLLECTION_NOT_FOUND = 133;\n        public const int COLLECTION_ALREADY_EXIST = 134;\n        public const int INDEX_ALREADY_EXIST = 135;\n        public const int INVALID_UPDATE_FIELD = 136;\n\n        public const int INVALID_FORMAT = 200;\n        public const int DOCUMENT_MAX_DEPTH = 201;\n        public const int INVALID_CTOR = 202;\n        public const int UNEXPECTED_TOKEN = 203;\n        public const int INVALID_DATA_TYPE = 204;\n        public const int PROPERTY_NOT_MAPPED = 206;\n        public const int INVALID_TYPED_NAME = 207;\n        public const int PROPERTY_READ_WRITE = 209;\n        public const int INITIALSIZE_CRYPTO_NOT_SUPPORTED = 210;\n        public const int INVALID_INITIALSIZE = 211;\n        public const int INVALID_NULL_CHAR_STRING = 212;\n        public const int INVALID_FREE_SPACE_PAGE = 213;\n        public const int DATA_TYPE_NOT_ASSIGNABLE = 214;\n\n        #endregion\n\n        #region Ctor\n\n        public int ErrorCode { get; private set; }\n        public long Position { get; private set; }\n\n        public LiteException(int code, string message)\n            : base(message)\n        {\n            this.ErrorCode = code;\n        }\n\n        internal LiteException(int code, string message, params object[] args)\n            : base(string.Format(message, args))\n        {\n            this.ErrorCode = code;\n        }\n\n        internal LiteException (int code, Exception inner, string message, params object[] args)\n        : base (string.Format (message, args), inner)\n        {\n            this.ErrorCode = code;\n        }\n\n        #endregion\n\n        #region Method Errors\n\n        internal static LiteException FileNotFound(object fileId)\n        {\n            return new LiteException(FILE_NOT_FOUND, \"File '{0}' not found.\", fileId);\n        }\n\n        internal static LiteException DatabaseShutdown()\n        {\n            return new LiteException(DATABASE_SHUTDOWN, \"Database is in shutdown process.\");\n        }\n\n        internal static LiteException InvalidDatabase()\n        {\n            return new LiteException(INVALID_DATABASE, \"File is not a valid LiteDB database format or contains a invalid password.\");\n        }\n\n        internal static LiteException FileSizeExceeded(long limit)\n        {\n            return new LiteException(FILE_SIZE_EXCEEDED, \"Database size exceeds limit of {0}.\", FileHelper.FormatFileSize(limit));\n        }\n\n        internal static LiteException CollectionLimitExceeded(int limit)\n        {\n            return new LiteException(COLLECTION_LIMIT_EXCEEDED, \"This database exceeded the maximum limit of collection names size: {0} bytes\", limit);\n        }\n\n        internal static LiteException IndexNameLimitExceeded(int limit)\n        {\n            return new LiteException(INDEX_NAME_LIMIT_EXCEEDED, \"This collection exceeded the maximum limit of indexes names/expression size: {0} bytes\", limit);\n        }\n\n        internal static LiteException InvalidIndexName(string name, string collection, string reason)\n        {\n            return new LiteException(INVALID_INDEX_NAME, \"Invalid index name '{0}' on collection '{1}': {2}\", name, collection, reason);\n        }\n\n        internal static LiteException InvalidCollectionName(string name, string reason)\n        {\n            return new LiteException(INVALID_COLLECTION_NAME, \"Invalid collection name '{0}': {1}\", name, reason);\n        }\n\n        internal static LiteException IndexDropId()\n        {\n            return new LiteException(INDEX_DROP_ID, \"Primary key index '_id' can't be dropped.\");\n        }\n\n        internal static LiteException TempEngineAlreadyDefined()\n        {\n            return new LiteException(TEMP_ENGINE_ALREADY_DEFINED, \"Temporary engine already defined or auto created.\");\n        }\n\n        internal static LiteException CollectionNotFound(string key)\n        {\n            return new LiteException(COLLECTION_NOT_FOUND, \"Collection not found: '{0}'\", key);\n        }\n\n        internal static LiteException InvalidExpressionType(BsonExpression expr, BsonExpressionType type)\n        {\n            return new LiteException(INVALID_EXPRESSION_TYPE, \"Expression '{0}' must be a {1} type.\", expr.Source, type);\n        }\n\n        internal static LiteException InvalidExpressionTypePredicate(BsonExpression expr)\n        {\n            return new LiteException(INVALID_EXPRESSION_TYPE, \"Expression '{0}' are not supported as predicate expression.\", expr.Source);\n        }\n\n        internal static LiteException CollectionAlreadyExist(string key)\n        {\n            return new LiteException(COLLECTION_ALREADY_EXIST, \"Collection already exist: '{0}'\", key);\n        }\n\n        internal static LiteException IndexAlreadyExist(string name)\n        {\n            return new LiteException(INDEX_ALREADY_EXIST, \"Index name '{0}' already exist with a differnt expression. Try drop index first.\", name);\n        }\n\n        internal static LiteException InvalidUpdateField(string field)\n        {\n            return new LiteException(INVALID_UPDATE_FIELD, \"'{0}' can't be modified in UPDATE command.\", field);\n        }\n\n        internal static LiteException IndexDuplicateKey(string field, BsonValue key)\n        {\n            return new LiteException(INDEX_DUPLICATE_KEY, \"Cannot insert duplicate key in unique index '{0}'. The duplicate value is '{1}'.\", field, key);\n        }\n\n        internal static LiteException InvalidIndexKey(string text)\n        {\n            return new LiteException(INVALID_INDEX_KEY, text);\n        }\n\n        internal static LiteException IndexNotFound(string name)\n        {\n            return new LiteException(INDEX_NOT_FOUND, \"Index not found '{0}'.\", name);\n        }\n\n        internal static LiteException LockTimeout(string mode, TimeSpan ts)\n        {\n            return new LiteException(LOCK_TIMEOUT, \"Database lock timeout when entering in {0} mode after {1}\", mode, ts.ToString());\n        }\n\n        internal static LiteException LockTimeout(string mode, string collection, TimeSpan ts)\n        {\n            return new LiteException(LOCK_TIMEOUT, \"Collection '{0}' lock timeout when entering in {1} mode after {2}\", collection, mode, ts.ToString());\n        }\n\n        internal static LiteException InvalidCommand(string command)\n        {\n            return new LiteException(INVALID_COMMAND, \"Command '{0}' is not a valid shell command.\", command);\n        }\n\n        internal static LiteException AlreadyExistsCollectionName(string newName)\n        {\n            return new LiteException(ALREADY_EXISTS_COLLECTION_NAME, \"New collection name '{0}' already exists.\", newName);\n        }\n\n        internal static LiteException AlreadyOpenDatafile(string filename)\n        {\n            return new LiteException(ALREADY_OPEN_DATAFILE, \"Your datafile '{0}' is open in another process.\", filename);\n        }\n\n        internal static LiteException InvalidDbRef(string path)\n        {\n            return new LiteException(INVALID_DBREF, \"Invalid value for DbRef in path '{0}'. Value must be document like {{ $ref: \\\"?\\\", $id: ? }}\", path);\n        }\n\n        internal static LiteException AlreadyExistsTransaction()\n        {\n            return new LiteException(INVALID_TRANSACTION_STATE, \"The current thread already contains an open transaction. Use the Commit/Rollback method to release the previous transaction.\");\n        }\n\n        internal static LiteException CollectionLockerNotFound(string collection)\n        {\n            return new LiteException(INVALID_TRANSACTION_STATE, \"Collection locker '{0}' was not found inside dictionary.\", collection);\n        }\n\n        internal static LiteException InvalidFormat(string field)\n        {\n            return new LiteException(INVALID_FORMAT, \"Invalid format: {0}\", field);\n        }\n\n        internal static LiteException DocumentMaxDepth(int depth, Type type)\n        {\n            return new LiteException(DOCUMENT_MAX_DEPTH, \"Document has more than {0} nested documents in '{1}'. Check for circular references (use DbRef).\", depth, type == null ? \"-\" : type.Name);\n        }\n\n        internal static LiteException InvalidCtor(Type type, Exception inner)\n        {\n            return new LiteException(INVALID_CTOR, inner, \"Failed to create instance for type '{0}' from assembly '{1}'. Checks if the class has a public constructor with no parameters.\", type.FullName, type.AssemblyQualifiedName);\n        }\n\n        internal static LiteException UnexpectedToken(Token token, string expected = null)\n        {\n            var position = (token?.Position - (token?.Value?.Length ?? 0)) ?? 0;\n            var str = token?.Type == TokenType.EOF ? \"[EOF]\" : token?.Value ?? \"\";\n            var exp = expected == null ? \"\" : $\" Expected `{expected}`.\";\n\n            return new LiteException(UNEXPECTED_TOKEN, $\"Unexpected token `{str}` in position {position}.{exp}\")\n            {\n                Position = position\n            };\n        }\n\n        internal static LiteException UnexpectedToken(string message, Token token)\n        {\n            var position = (token?.Position - (token?.Value?.Length ?? 0)) ?? 0;\n\n            return new LiteException(UNEXPECTED_TOKEN, message)\n            {\n                Position = position\n            };\n        }\n\n        internal static LiteException InvalidDataType(string field, BsonValue value)\n        {\n            return new LiteException(INVALID_DATA_TYPE, \"Invalid BSON data type '{0}' on field '{1}'.\", value.Type, field);\n        }\n\n        internal static LiteException PropertyReadWrite(PropertyInfo prop)\n        {\n            return new LiteException(PROPERTY_READ_WRITE, \"'{0}' property must have public getter and setter.\", prop.Name);\n        }\n\n        internal static LiteException PropertyNotMapped(string name)\n        {\n            return new LiteException(PROPERTY_NOT_MAPPED, \"Property '{0}' was not mapped into BsonDocument.\", name);\n        }\n\n        internal static LiteException InvalidTypedName(string type)\n        {\n            return new LiteException(INVALID_TYPED_NAME, \"Type '{0}' not found in current domain (_type format is 'Type.FullName, AssemblyName').\", type);\n        }\n\n        internal static LiteException InitialSizeCryptoNotSupported()\n        {\n            return new LiteException(INITIALSIZE_CRYPTO_NOT_SUPPORTED, \"Initial Size option is not supported for encrypted datafiles.\");\n        }\n\n        internal static LiteException InvalidInitialSize()\n        {\n            return new LiteException(INVALID_INITIALSIZE, \"Initial Size must be a multiple of page size ({0} bytes).\", PAGE_SIZE);\n        }\n\n        internal static LiteException InvalidNullCharInString()\n        {\n            return new LiteException(INVALID_NULL_CHAR_STRING, \"Invalid null character (\\\\0) was found in the string\");\n        }\n\n        internal static LiteException InvalidPageType(PageType pageType, BasePage page)\n        {\n            var sb = new StringBuilder($\"Invalid {pageType} on {page.PageID}. \");\n\n            sb.Append($\"Full zero: {page.Buffer.All(0)}. \");\n            sb.Append($\"Page Type: {page.PageType}. \");\n            sb.Append($\"Prev/Next: {page.PrevPageID}/{page.NextPageID}. \");\n            sb.Append($\"UniqueID: {page.Buffer.UniqueID}. \");\n            sb.Append($\"ShareCounter: {page.Buffer.ShareCounter}. \");\n\n            return new LiteException(0, sb.ToString());\n        }\n\n        internal static LiteException InvalidFreeSpacePage(uint pageID, int freeBytes, int length)\n        {\n            return new LiteException(INVALID_FREE_SPACE_PAGE, $\"An operation that would corrupt page {pageID} was prevented. The operation required {length} free bytes, but the page had only {freeBytes} available.\");\n        }\n\n        internal static LiteException DataTypeNotAssignable(string type1, string type2)\n        {\n            return new LiteException(DATA_TYPE_NOT_ASSIGNABLE, $\"Data type {type1} is not assignable from data type {type2}\");\n        }\n\n        #endregion\n    }\n}"], "fixing_code": ["\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.1.32328.378\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB\", \"LiteDB\\LiteDB.csproj\", \"{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB.Tests\", \"LiteDB.Tests\\LiteDB.Tests.csproj\", \"{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB.Shell\", \"LiteDB.Shell\\LiteDB.Shell.csproj\", \"{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB.Benchmarks\", \"LiteDB.Benchmarks\\LiteDB.Benchmarks.csproj\", \"{DF9C82C1-446F-458A-AA50-78E58BA17273}\"\nEndProject\nProject(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"LiteDB.Stress\", \"LiteDB.Stress\\LiteDB.Stress.csproj\", \"{FFBC5669-DA32-4907-8793-7B414279DA3B}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|Any CPU = Debug|Any CPU\n\t\tRelease|Any CPU = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{9497DA19-1FCA-4C2E-A1AB-8DFAACBC76E1}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{74E32E43-2A57-4A38-BD8C-9108B0DCAEAA}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{99887C89-CAE4-4A8D-AC4B-87E28B9B1F87}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{DF9C82C1-446F-458A-AA50-78E58BA17273}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{DF9C82C1-446F-458A-AA50-78E58BA17273}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{DF9C82C1-446F-458A-AA50-78E58BA17273}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{DF9C82C1-446F-458A-AA50-78E58BA17273}.Release|Any CPU.Build.0 = Release|Any CPU\n\t\t{FFBC5669-DA32-4907-8793-7B414279DA3B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n\t\t{FFBC5669-DA32-4907-8793-7B414279DA3B}.Debug|Any CPU.Build.0 = Debug|Any CPU\n\t\t{FFBC5669-DA32-4907-8793-7B414279DA3B}.Release|Any CPU.ActiveCfg = Release|Any CPU\n\t\t{FFBC5669-DA32-4907-8793-7B414279DA3B}.Release|Any CPU.Build.0 = Release|Any CPU\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {45099B85-2AE1-434B-913A-6AD14FD3AF4A}\n\tEndGlobalSection\n\tGlobalSection(Performance) = preSolution\n\t\tHasPerformanceSessions = true\n\tEndGlobalSection\nEndGlobal\n", "using System;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Reflection;\nusing static LiteDB.Constants;\n\nnamespace LiteDB\n{\n    public partial class BsonMapper\n    {\n        #region Basic direct .NET convert types\n\n        // direct bson types\n        private HashSet<Type> _bsonTypes = new HashSet<Type>\n        {\n            typeof(String),\n            typeof(Int32),\n            typeof(Int64),\n            typeof(Boolean),\n            typeof(Guid),\n            typeof(DateTime),\n            typeof(Byte[]),\n            typeof(ObjectId),\n            typeof(Double),\n            typeof(Decimal)\n        };\n\n        // simple convert types\n        private HashSet<Type> _basicTypes = new HashSet<Type>\n        {\n            typeof(Int16),\n            typeof(UInt16),\n            typeof(UInt32),\n            typeof(Single),\n            typeof(Char),\n            typeof(Byte),\n            typeof(SByte)\n        };\n\n        #endregion\n\n        /// <summary>\n        /// Deserialize a BsonDocument to entity class\n        /// </summary>\n        public virtual object ToObject(Type type, BsonDocument doc)\n        {\n            if (doc == null) throw new ArgumentNullException(nameof(doc));\n\n            // if T is BsonDocument, just return them\n            if (type == typeof(BsonDocument)) return doc;\n\n            return this.Deserialize(type, doc);\n        }\n\n        /// <summary>\n        /// Deserialize a BsonDocument to entity class\n        /// </summary>\n        public virtual T ToObject<T>(BsonDocument doc)\n        {\n            return (T)this.ToObject(typeof(T), doc);\n        }\n\n        /// <summary>\n        /// Deserialize a BsonValue to .NET object typed in T\n        /// </summary>\n        public T Deserialize<T>(BsonValue value)\n        {\n            if (value == null) return default(T);\n\n            var result = this.Deserialize(typeof(T), value);\n\n            return (T)result;\n        }\n\n        /// <summary>\n        /// Deserilize a BsonValue to .NET object based on type parameter\n        /// </summary>\n        public object Deserialize(Type type, BsonValue value)\n        {\n            // null value - null returns\n            if (value.IsNull) return null;\n\n            // if is nullable, get underlying type\n            if (Reflection.IsNullable(type))\n            {\n                type = Reflection.UnderlyingTypeOf(type);\n            }\n\n            // test if has a custom type implementation\n            if (_customDeserializer.TryGetValue(type, out Func<BsonValue, object> custom))\n            {\n                return custom(value);\n            }\n\n            var typeInfo = type.GetTypeInfo();\n\n            // check if your type is already a BsonValue/BsonDocument/BsonArray\n            if (type == typeof(BsonValue))\n            {\n                return value;\n            }\n            else if (type == typeof(BsonDocument))\n            {\n                return value.AsDocument;\n            }\n            else if (type == typeof(BsonArray))\n            {\n                return value.AsArray;\n            }\n\n            // raw values to native bson values\n            else if (_bsonTypes.Contains(type))\n            {\n                return value.RawValue;\n            }\n\n            // simple ConvertTo to basic .NET types\n            else if (_basicTypes.Contains(type))\n            {\n                return Convert.ChangeType(value.RawValue, type);\n            }\n\n            // special cast to UInt64 to Int64\n            else if (type == typeof(UInt64))\n            {\n                return unchecked((UInt64)value.AsInt64);\n            }\n\n            // enum value is an int\n            else if (typeInfo.IsEnum)\n            {\n                if (value.IsString) return Enum.Parse(type, value.AsString);\n\n                if (value.IsNumber) return Enum.ToObject(type, value.AsInt32);\n            }\n\n            // if value is array, deserialize as array\n            else if (value.IsArray)\n            {\n                // when array are from an object (like in Dictionary<string, object> { [\"array\"] = new string[] { \"a\", \"b\" } \n                if (type == typeof(object))\n                {\n                    return this.DeserializeArray(typeof(object), value.AsArray);\n                }\n                if (type.IsArray)\n                {\n                    return this.DeserializeArray(type.GetElementType(), value.AsArray);\n                }\n                else\n                {\n                    return this.DeserializeList(type, value.AsArray);\n                }\n            }\n\n            // if value is document, deserialize as document\n            else if (value.IsDocument)\n            {\n                // if type is anonymous use special handler\n                if (type.IsAnonymousType())\n                {\n                    return this.DeserializeAnonymousType(type, value.AsDocument);\n                }\n\n                var doc = value.AsDocument;\n\n                // test if value is object and has _type\n                if (doc.TryGetValue(\"_type\", out var typeField) && typeField.IsString)\n                {\n                    var actualType = _typeNameBinder.GetType(typeField.AsString);\n\n                    if (actualType == null) throw LiteException.InvalidTypedName(typeField.AsString);\n\n                    // avoid initialize class that are not assignable \n                    if (!type.IsAssignableFrom(actualType))\n                    {\n                        throw LiteException.DataTypeNotAssignable(type.FullName, actualType.FullName);\n                    }\n\n                    // avoid use of \"System.Diagnostics.Process\" in object type definition\n                    // using String test to work in .netstandard 1.3\n                    if (actualType.FullName.Equals(\"System.Diagnostics.Process\", StringComparison.OrdinalIgnoreCase) &&\n                        actualType.Assembly.GetName().Name.Equals(\"System\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        throw LiteException.AvoidUseOfProcess();\n                    }\n\n                    type = actualType;\n                }\n                // when complex type has no definition (== typeof(object)) use Dictionary<string, object> to better set values\n                else if (type == typeof(object))\n                {\n                    type = typeof(Dictionary<string, object>);\n                }\n\n                var entity = this.GetEntityMapper(type);\n\n                // initialize CreateInstance\n                if (entity.CreateInstance == null)\n                {\n                    entity.CreateInstance =\n                        this.GetTypeCtor(entity) ??\n                        ((BsonDocument v) => Reflection.CreateInstance(entity.ForType));\n                }\n\n                var o = _typeInstantiator(type) ?? entity.CreateInstance(doc);\n\n                if (o is IDictionary dict)\n                {\n                    if (o.GetType().GetTypeInfo().IsGenericType)\n                    {\n                        var k = type.GetGenericArguments()[0];\n                        var t = type.GetGenericArguments()[1];\n\n                        this.DeserializeDictionary(k, t, dict, value.AsDocument);\n                    }\n                    else\n                    {\n                        this.DeserializeDictionary(typeof(object), typeof(object), dict, value.AsDocument);\n                    }\n                }\n                else\n                {\n                    this.DeserializeObject(entity, o, doc);\n                }\n\n                return o;\n            }\n\n            // in last case, return value as-is - can cause \"cast error\"\n            // it's used for \"public object MyInt { get; set; }\"\n            return value.RawValue;\n        }\n\n        private object DeserializeArray(Type type, BsonArray array)\n        {\n            var arr = Array.CreateInstance(type, array.Count);\n            var idx = 0;\n\n            foreach (var item in array)\n            {\n                arr.SetValue(this.Deserialize(type, item), idx++);\n            }\n\n            return arr;\n        }\n\n        private object DeserializeList(Type type, BsonArray value)\n        {\n            var itemType = Reflection.GetListItemType(type);\n            var enumerable = (IEnumerable)Reflection.CreateInstance(type);\n\n            if (enumerable is IList list)\n            {\n                foreach (BsonValue item in value)\n                {\n                    list.Add(this.Deserialize(itemType, item));\n                }\n            }\n            else\n            {\n                var addMethod = type.GetMethod(\"Add\");\n\n                foreach (BsonValue item in value)\n                {\n                    addMethod.Invoke(enumerable, new[] { this.Deserialize(itemType, item) });\n                }\n            }\n\n            return enumerable;\n        }\n\n        private void DeserializeDictionary(Type K, Type T, IDictionary dict, BsonDocument value)\n        {\n            var isKEnum = K.GetTypeInfo().IsEnum;\n            foreach (var el in value.GetElements())\n            {\n                var k = isKEnum ? Enum.Parse(K, el.Key) : K == typeof(Uri) ? new Uri(el.Key) : Convert.ChangeType(el.Key, K);\n                var v = this.Deserialize(T, el.Value);\n\n                dict.Add(k, v);\n            }\n        }\n\n        private void DeserializeObject(EntityMapper entity, object obj, BsonDocument value)\n        {\n            foreach (var member in entity.Members.Where(x => x.Setter != null))\n            {\n                if (value.TryGetValue(member.FieldName, out var val))\n                {\n                    // check if has a custom deserialize function\n                    if (member.Deserialize != null)\n                    {\n                        member.Setter(obj, member.Deserialize(val, this));\n                    }\n                    else\n                    {\n                        member.Setter(obj, this.Deserialize(member.DataType, val));\n                    }\n                }\n            }\n        }\n\n        private object DeserializeAnonymousType(Type type, BsonDocument value)\n        {\n            var args = new List<object>();\n            var ctor = type.GetConstructors()[0];\n\n            foreach (var par in ctor.GetParameters())\n            {\n                var arg = this.Deserialize(par.ParameterType, value[par.Name]);\n\n                args.Add(arg);\n            }\n\n            var obj = Activator.CreateInstance(type, args.ToArray());\n\n            return obj;\n        }\n    }\n}", "<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <TargetFrameworks>net4.5;netstandard1.3;netstandard2.0</TargetFrameworks>\r\n    <AssemblyVersion>5.0.12</AssemblyVersion>\r\n    <FileVersion>5.0.12</FileVersion>\r\n    <VersionPrefix>5.0.12</VersionPrefix>\r\n    <Authors>Maur\u00edcio David</Authors>\r\n    <Product>LiteDB</Product>\r\n    <Description>LiteDB - A lightweight embedded .NET NoSQL document store in a single datafile</Description>\r\n    <Copyright>MIT</Copyright>\r\n    <NeutralLanguage>en-US</NeutralLanguage>\r\n    <Title>LiteDB</Title>\r\n    <PackageId>LiteDB</PackageId>\r\n    <PackageVersion>5.0.12</PackageVersion>\r\n    <PackageTags>database nosql embedded</PackageTags>\r\n    <PackageIcon>icon_64x64.png</PackageIcon>\r\n    <PackageLicenseFile>LICENSE</PackageLicenseFile>\r\n    <PackageProjectUrl>https://www.litedb.org</PackageProjectUrl>\r\n    <RepositoryUrl>https://github.com/mbdavid/LiteDB</RepositoryUrl>\r\n    <RepositoryType>git</RepositoryType>\r\n    <RootNamespace>LiteDB</RootNamespace>\r\n    <AssemblyName>LiteDB</AssemblyName>\r\n    <GenerateDocumentationFile>true</GenerateDocumentationFile>\r\n    <NetStandardImplicitPackageVersion Condition=\" '$(TargetFramework)' == 'netstandard1.3' \">1.6.1</NetStandardImplicitPackageVersion>\r\n    <NoWarn>1701;1702;1705;1591;0618</NoWarn>\r\n    <DocumentationFile>bin\\$(Configuration)\\$(TargetFramework)\\LiteDB.xml</DocumentationFile>\r\n    <SignAssembly Condition=\"'$(OS)'=='Windows_NT'\">true</SignAssembly>\r\n    <AssemblyOriginatorKeyFile Condition=\"'$(Configuration)' == 'Release'\">LiteDB.snk</AssemblyOriginatorKeyFile>\r\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\r\n  </PropertyGroup>\r\n  \r\n  <!--\r\n  == All variables ==\r\n  HAVE_APP_DOMAIN\r\n  HAVE_PROCESS\r\n  HAVE_ENVIRONMENT\r\n  HAVE_SHA1_MANAGED\r\n  -->\r\n\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'\">\r\n    <DefineConstants>TRACE;DEBUG</DefineConstants>\r\n  </PropertyGroup>\r\n\r\n  <PropertyGroup Condition=\"'$(TargetFramework)' == 'net45'\">\r\n    <DefineConstants>HAVE_SHA1_MANAGED;HAVE_APP_DOMAIN;HAVE_PROCESS;HAVE_ENVIRONMENT</DefineConstants>\r\n  </PropertyGroup>\r\n\r\n  <PropertyGroup Condition=\"'$(TargetFramework)' == 'netstandard2.0'\">\r\n    <DefineConstants>HAVE_SHA1_MANAGED</DefineConstants>\r\n  </PropertyGroup>\r\n\r\n  <!-- Begin References -->\r\n  <ItemGroup>\r\n    <None Include=\"..\\LICENSE\" Pack=\"true\" PackagePath=\"\" />\r\n    <None Include=\"..\\icon_64x64.png\" Pack=\"true\" PackagePath=\"\\\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup Condition=\"'$(TargetFramework)' == 'net45'\">\r\n    <Reference Include=\"System\" />\r\n    <Reference Include=\"System.Runtime\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup Condition=\"'$(TargetFramework)' == 'netstandard1.3'\">\r\n    <PackageReference Include=\"System.Reflection.TypeExtensions\" Version=\"4.5.1\" />\r\n    <PackageReference Include=\"System.Security.Cryptography.Algorithms\" Version=\"4.3.1\" />\r\n  </ItemGroup>\r\n  \r\n  <!-- End References -->\r\n\r\n</Project>\r\n", "using LiteDB.Engine;\nusing System;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static LiteDB.Constants;\n\nnamespace LiteDB\n{\n    /// <summary>\n    /// The main exception for LiteDB\n    /// </summary>\n    public class LiteException : Exception\n    {\n        #region Errors code\n\n        public const int FILE_NOT_FOUND = 101;\n        public const int DATABASE_SHUTDOWN = 102;\n        public const int INVALID_DATABASE = 103;\n        public const int FILE_SIZE_EXCEEDED = 105;\n        public const int COLLECTION_LIMIT_EXCEEDED = 106;\n        public const int INDEX_DROP_ID = 108;\n        public const int INDEX_DUPLICATE_KEY = 110;\n        public const int INVALID_INDEX_KEY = 111;\n        public const int INDEX_NOT_FOUND = 112;\n        public const int INVALID_DBREF = 113;\n        public const int LOCK_TIMEOUT = 120;\n        public const int INVALID_COMMAND = 121;\n        public const int ALREADY_EXISTS_COLLECTION_NAME = 122;\n        public const int ALREADY_OPEN_DATAFILE = 124;\n        public const int INVALID_TRANSACTION_STATE = 126;\n        public const int INDEX_NAME_LIMIT_EXCEEDED = 128;\n        public const int INVALID_INDEX_NAME = 129;\n        public const int INVALID_COLLECTION_NAME = 130;\n        public const int TEMP_ENGINE_ALREADY_DEFINED = 131;\n        public const int INVALID_EXPRESSION_TYPE = 132;\n        public const int COLLECTION_NOT_FOUND = 133;\n        public const int COLLECTION_ALREADY_EXIST = 134;\n        public const int INDEX_ALREADY_EXIST = 135;\n        public const int INVALID_UPDATE_FIELD = 136;\n\n        public const int INVALID_FORMAT = 200;\n        public const int DOCUMENT_MAX_DEPTH = 201;\n        public const int INVALID_CTOR = 202;\n        public const int UNEXPECTED_TOKEN = 203;\n        public const int INVALID_DATA_TYPE = 204;\n        public const int PROPERTY_NOT_MAPPED = 206;\n        public const int INVALID_TYPED_NAME = 207;\n        public const int PROPERTY_READ_WRITE = 209;\n        public const int INITIALSIZE_CRYPTO_NOT_SUPPORTED = 210;\n        public const int INVALID_INITIALSIZE = 211;\n        public const int INVALID_NULL_CHAR_STRING = 212;\n        public const int INVALID_FREE_SPACE_PAGE = 213;\n        public const int DATA_TYPE_NOT_ASSIGNABLE = 214;\n        public const int AVOID_USE_OF_PROCESS = 215;\n\n        #endregion\n\n        #region Ctor\n\n        public int ErrorCode { get; private set; }\n        public long Position { get; private set; }\n\n        public LiteException(int code, string message)\n            : base(message)\n        {\n            this.ErrorCode = code;\n        }\n\n        internal LiteException(int code, string message, params object[] args)\n            : base(string.Format(message, args))\n        {\n            this.ErrorCode = code;\n        }\n\n        internal LiteException (int code, Exception inner, string message, params object[] args)\n        : base (string.Format (message, args), inner)\n        {\n            this.ErrorCode = code;\n        }\n\n        #endregion\n\n        #region Method Errors\n\n        internal static LiteException FileNotFound(object fileId)\n        {\n            return new LiteException(FILE_NOT_FOUND, \"File '{0}' not found.\", fileId);\n        }\n\n        internal static LiteException DatabaseShutdown()\n        {\n            return new LiteException(DATABASE_SHUTDOWN, \"Database is in shutdown process.\");\n        }\n\n        internal static LiteException InvalidDatabase()\n        {\n            return new LiteException(INVALID_DATABASE, \"File is not a valid LiteDB database format or contains a invalid password.\");\n        }\n\n        internal static LiteException FileSizeExceeded(long limit)\n        {\n            return new LiteException(FILE_SIZE_EXCEEDED, \"Database size exceeds limit of {0}.\", FileHelper.FormatFileSize(limit));\n        }\n\n        internal static LiteException CollectionLimitExceeded(int limit)\n        {\n            return new LiteException(COLLECTION_LIMIT_EXCEEDED, \"This database exceeded the maximum limit of collection names size: {0} bytes\", limit);\n        }\n\n        internal static LiteException IndexNameLimitExceeded(int limit)\n        {\n            return new LiteException(INDEX_NAME_LIMIT_EXCEEDED, \"This collection exceeded the maximum limit of indexes names/expression size: {0} bytes\", limit);\n        }\n\n        internal static LiteException InvalidIndexName(string name, string collection, string reason)\n        {\n            return new LiteException(INVALID_INDEX_NAME, \"Invalid index name '{0}' on collection '{1}': {2}\", name, collection, reason);\n        }\n\n        internal static LiteException InvalidCollectionName(string name, string reason)\n        {\n            return new LiteException(INVALID_COLLECTION_NAME, \"Invalid collection name '{0}': {1}\", name, reason);\n        }\n\n        internal static LiteException IndexDropId()\n        {\n            return new LiteException(INDEX_DROP_ID, \"Primary key index '_id' can't be dropped.\");\n        }\n\n        internal static LiteException TempEngineAlreadyDefined()\n        {\n            return new LiteException(TEMP_ENGINE_ALREADY_DEFINED, \"Temporary engine already defined or auto created.\");\n        }\n\n        internal static LiteException CollectionNotFound(string key)\n        {\n            return new LiteException(COLLECTION_NOT_FOUND, \"Collection not found: '{0}'\", key);\n        }\n\n        internal static LiteException InvalidExpressionType(BsonExpression expr, BsonExpressionType type)\n        {\n            return new LiteException(INVALID_EXPRESSION_TYPE, \"Expression '{0}' must be a {1} type.\", expr.Source, type);\n        }\n\n        internal static LiteException InvalidExpressionTypePredicate(BsonExpression expr)\n        {\n            return new LiteException(INVALID_EXPRESSION_TYPE, \"Expression '{0}' are not supported as predicate expression.\", expr.Source);\n        }\n\n        internal static LiteException CollectionAlreadyExist(string key)\n        {\n            return new LiteException(COLLECTION_ALREADY_EXIST, \"Collection already exist: '{0}'\", key);\n        }\n\n        internal static LiteException IndexAlreadyExist(string name)\n        {\n            return new LiteException(INDEX_ALREADY_EXIST, \"Index name '{0}' already exist with a differnt expression. Try drop index first.\", name);\n        }\n\n        internal static LiteException InvalidUpdateField(string field)\n        {\n            return new LiteException(INVALID_UPDATE_FIELD, \"'{0}' can't be modified in UPDATE command.\", field);\n        }\n\n        internal static LiteException IndexDuplicateKey(string field, BsonValue key)\n        {\n            return new LiteException(INDEX_DUPLICATE_KEY, \"Cannot insert duplicate key in unique index '{0}'. The duplicate value is '{1}'.\", field, key);\n        }\n\n        internal static LiteException InvalidIndexKey(string text)\n        {\n            return new LiteException(INVALID_INDEX_KEY, text);\n        }\n\n        internal static LiteException IndexNotFound(string name)\n        {\n            return new LiteException(INDEX_NOT_FOUND, \"Index not found '{0}'.\", name);\n        }\n\n        internal static LiteException LockTimeout(string mode, TimeSpan ts)\n        {\n            return new LiteException(LOCK_TIMEOUT, \"Database lock timeout when entering in {0} mode after {1}\", mode, ts.ToString());\n        }\n\n        internal static LiteException LockTimeout(string mode, string collection, TimeSpan ts)\n        {\n            return new LiteException(LOCK_TIMEOUT, \"Collection '{0}' lock timeout when entering in {1} mode after {2}\", collection, mode, ts.ToString());\n        }\n\n        internal static LiteException InvalidCommand(string command)\n        {\n            return new LiteException(INVALID_COMMAND, \"Command '{0}' is not a valid shell command.\", command);\n        }\n\n        internal static LiteException AlreadyExistsCollectionName(string newName)\n        {\n            return new LiteException(ALREADY_EXISTS_COLLECTION_NAME, \"New collection name '{0}' already exists.\", newName);\n        }\n\n        internal static LiteException AlreadyOpenDatafile(string filename)\n        {\n            return new LiteException(ALREADY_OPEN_DATAFILE, \"Your datafile '{0}' is open in another process.\", filename);\n        }\n\n        internal static LiteException InvalidDbRef(string path)\n        {\n            return new LiteException(INVALID_DBREF, \"Invalid value for DbRef in path '{0}'. Value must be document like {{ $ref: \\\"?\\\", $id: ? }}\", path);\n        }\n\n        internal static LiteException AlreadyExistsTransaction()\n        {\n            return new LiteException(INVALID_TRANSACTION_STATE, \"The current thread already contains an open transaction. Use the Commit/Rollback method to release the previous transaction.\");\n        }\n\n        internal static LiteException CollectionLockerNotFound(string collection)\n        {\n            return new LiteException(INVALID_TRANSACTION_STATE, \"Collection locker '{0}' was not found inside dictionary.\", collection);\n        }\n\n        internal static LiteException InvalidFormat(string field)\n        {\n            return new LiteException(INVALID_FORMAT, \"Invalid format: {0}\", field);\n        }\n\n        internal static LiteException DocumentMaxDepth(int depth, Type type)\n        {\n            return new LiteException(DOCUMENT_MAX_DEPTH, \"Document has more than {0} nested documents in '{1}'. Check for circular references (use DbRef).\", depth, type == null ? \"-\" : type.Name);\n        }\n\n        internal static LiteException InvalidCtor(Type type, Exception inner)\n        {\n            return new LiteException(INVALID_CTOR, inner, \"Failed to create instance for type '{0}' from assembly '{1}'. Checks if the class has a public constructor with no parameters.\", type.FullName, type.AssemblyQualifiedName);\n        }\n\n        internal static LiteException UnexpectedToken(Token token, string expected = null)\n        {\n            var position = (token?.Position - (token?.Value?.Length ?? 0)) ?? 0;\n            var str = token?.Type == TokenType.EOF ? \"[EOF]\" : token?.Value ?? \"\";\n            var exp = expected == null ? \"\" : $\" Expected `{expected}`.\";\n\n            return new LiteException(UNEXPECTED_TOKEN, $\"Unexpected token `{str}` in position {position}.{exp}\")\n            {\n                Position = position\n            };\n        }\n\n        internal static LiteException UnexpectedToken(string message, Token token)\n        {\n            var position = (token?.Position - (token?.Value?.Length ?? 0)) ?? 0;\n\n            return new LiteException(UNEXPECTED_TOKEN, message)\n            {\n                Position = position\n            };\n        }\n\n        internal static LiteException InvalidDataType(string field, BsonValue value)\n        {\n            return new LiteException(INVALID_DATA_TYPE, \"Invalid BSON data type '{0}' on field '{1}'.\", value.Type, field);\n        }\n\n        internal static LiteException PropertyReadWrite(PropertyInfo prop)\n        {\n            return new LiteException(PROPERTY_READ_WRITE, \"'{0}' property must have public getter and setter.\", prop.Name);\n        }\n\n        internal static LiteException PropertyNotMapped(string name)\n        {\n            return new LiteException(PROPERTY_NOT_MAPPED, \"Property '{0}' was not mapped into BsonDocument.\", name);\n        }\n\n        internal static LiteException InvalidTypedName(string type)\n        {\n            return new LiteException(INVALID_TYPED_NAME, \"Type '{0}' not found in current domain (_type format is 'Type.FullName, AssemblyName').\", type);\n        }\n\n        internal static LiteException InitialSizeCryptoNotSupported()\n        {\n            return new LiteException(INITIALSIZE_CRYPTO_NOT_SUPPORTED, \"Initial Size option is not supported for encrypted datafiles.\");\n        }\n\n        internal static LiteException InvalidInitialSize()\n        {\n            return new LiteException(INVALID_INITIALSIZE, \"Initial Size must be a multiple of page size ({0} bytes).\", PAGE_SIZE);\n        }\n\n        internal static LiteException InvalidNullCharInString()\n        {\n            return new LiteException(INVALID_NULL_CHAR_STRING, \"Invalid null character (\\\\0) was found in the string\");\n        }\n\n        internal static LiteException InvalidPageType(PageType pageType, BasePage page)\n        {\n            var sb = new StringBuilder($\"Invalid {pageType} on {page.PageID}. \");\n\n            sb.Append($\"Full zero: {page.Buffer.All(0)}. \");\n            sb.Append($\"Page Type: {page.PageType}. \");\n            sb.Append($\"Prev/Next: {page.PrevPageID}/{page.NextPageID}. \");\n            sb.Append($\"UniqueID: {page.Buffer.UniqueID}. \");\n            sb.Append($\"ShareCounter: {page.Buffer.ShareCounter}. \");\n\n            return new LiteException(0, sb.ToString());\n        }\n\n        internal static LiteException InvalidFreeSpacePage(uint pageID, int freeBytes, int length)\n        {\n            return new LiteException(INVALID_FREE_SPACE_PAGE, $\"An operation that would corrupt page {pageID} was prevented. The operation required {length} free bytes, but the page had only {freeBytes} available.\");\n        }\n\n        internal static LiteException DataTypeNotAssignable(string type1, string type2)\n        {\n            return new LiteException(DATA_TYPE_NOT_ASSIGNABLE, $\"Data type {type1} is not assignable from data type {type2}\");\n        }\n\n        internal static LiteException AvoidUseOfProcess()\n        {\n            return new LiteException(AVOID_USE_OF_PROCESS, $\"LiteDB do not accept System.Diagnostics.Process class in deserialize mapper\");\n        }\n\n        #endregion\n    }\n}"], "filenames": ["LiteDB.sln", "LiteDB/Client/Mapper/BsonMapper.Deserialize.cs", "LiteDB/LiteDB.csproj", "LiteDB/Utils/LiteException.cs"], "buggy_code_start_loc": [3, 173, 4, 54], "buggy_code_end_loc": [5, 174, 5, 314], "fixing_code_start_loc": [3, 173, 4, 55], "fixing_code_end_loc": [5, 187, 5, 321], "type": "CWE-502", "message": "LiteDB is a small, fast and lightweight .NET NoSQL embedded database. Versions prior to 5.0.13 are subject to Deserialization of Untrusted Data. LiteDB uses a special field in JSON documents to cast different types from `BsonDocument` to POCO classes. When instances of an object are not the same of class, `BsonMapper` use a special field `_type` string info with full class name with assembly to be loaded and fit into your model. If your end-user can send to your app a plain JSON string, deserialization can load an unsafe object to fit into your model. This issue is patched in version 5.0.13 with some basic fixes to avoid this, but is not 100% guaranteed when using `Object` type. The next major version will contain an allow-list to select what kind of Assembly can be loaded. Workarounds are detailed in the vendor advisory.", "other": {"cve": {"id": "CVE-2022-23535", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-24T23:15:10.663", "lastModified": "2023-03-06T18:52:10.373", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LiteDB is a small, fast and lightweight .NET NoSQL embedded database. Versions prior to 5.0.13 are subject to Deserialization of Untrusted Data. LiteDB uses a special field in JSON documents to cast different types from `BsonDocument` to POCO classes. When instances of an object are not the same of class, `BsonMapper` use a special field `_type` string info with full class name with assembly to be loaded and fit into your model. If your end-user can send to your app a plain JSON string, deserialization can load an unsafe object to fit into your model. This issue is patched in version 5.0.13 with some basic fixes to avoid this, but is not 100% guaranteed when using `Object` type. The next major version will contain an allow-list to select what kind of Assembly can be loaded. Workarounds are detailed in the vendor advisory."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:litedb:litedb:*:*:*:*:*:.net:*:*", "versionEndExcluding": "5.0.13", "matchCriteriaId": "4E7140DC-3C15-4592-94CE-0BD0D07A3106"}]}]}], "references": [{"url": "https://github.com/mbdavid/LiteDB/commit/4382ff4dd0dd8b8b16a4e37dfd29727c5f70f93f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mbdavid/LiteDB/security/advisories/GHSA-3x49-g6rc-c284", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mbdavid/LiteDB/commit/4382ff4dd0dd8b8b16a4e37dfd29727c5f70f93f"}}