{"buggy_code": ["/*\n   Copyright (C) 2006-2016,2018,2021 Con Kolivas\n   Copyright (C) 2011 Peter Hyman\n   Copyright (C) 1998-2003 Andrew Tridgell\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#include <fcntl.h>\n#include <sys/statvfs.h>\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n#include <arpa/inet.h>\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <termios.h>\n#ifdef HAVE_ENDIAN_H\n# include <endian.h>\n#elif HAVE_SYS_ENDIAN_H\n# include <sys/endian.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n# include <arpa/inet.h>\n#endif\n#include <math.h>\n#include <utime.h>\n#include <inttypes.h>\n\n#include \"md5.h\"\n#include \"rzip.h\"\n#include \"runzip.h\"\n#include \"util.h\"\n#include \"stream.h\"\n\n#define MAGIC_LEN (24)\n\nstatic void release_hashes(rzip_control *control);\n\nstatic i64 fdout_seekto(rzip_control *control, i64 pos)\n{\n\tif (TMP_OUTBUF) {\n\t\tpos -= control->out_relofs;\n\t\tcontrol->out_ofs = pos;\n\t\tif (unlikely(pos > control->out_len || pos < 0)) {\n\t\t\tprint_err(\"Trying to seek to %lld outside tmp outbuf in fdout_seekto\\n\", pos);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn lseek(control->fd_out, pos, SEEK_SET);\n}\n\n#ifdef __APPLE__\n# include <sys/sysctl.h>\ni64 get_ram(rzip_control *control)\n{\n\tint mib[2];\n\tsize_t len;\n\ti64 *p, ramsize;\n\n\tmib[0] = CTL_HW;\n\tmib[1] = HW_MEMSIZE;\n\tsysctl(mib, 2, NULL, &len, NULL, 0);\n\tp = malloc(len);\n\tsysctl(mib, 2, p, &len, NULL, 0);\n\tramsize = *p;\n\n\treturn ramsize;\n}\n#else /* __APPLE__ */\ni64 get_ram(rzip_control *control)\n{\n\ti64 ramsize;\n\tFILE *meminfo;\n\tchar aux[256];\n\n\tramsize = (i64)sysconf(_SC_PHYS_PAGES) * PAGE_SIZE;\n\tif (ramsize > 0)\n\t\treturn ramsize;\n\n\t/* Workaround for uclibc which doesn't properly support sysconf */\n\tif(!(meminfo = fopen(\"/proc/meminfo\", \"r\")))\n\t\tfatal_return((\"fopen\\n\"), -1);\n\n\twhile(!feof(meminfo) && !fscanf(meminfo, \"MemTotal: %\"PRId64\" kB\", &ramsize)) {\n\t\tif (unlikely(fgets(aux, sizeof(aux), meminfo) == NULL)) {\n\t\t\tfclose(meminfo);\n\t\t\tfatal_return((\"Failed to fgets in get_ram\\n\"), -1);\n\t\t}\n\t}\n\tif (fclose(meminfo) == -1)\n\t\tfatal_return((\"fclose\"), -1);\n\tramsize *= 1000;\n\n\treturn ramsize;\n}\n#endif\n\ni64 nloops(i64 seconds, uchar *b1, uchar *b2)\n{\n\ti64 nloops;\n\tint nbits;\n\n\tnloops = ARBITRARY_AT_EPOCH * pow(MOORE_TIMES_PER_SECOND, seconds);\n\tif (nloops < ARBITRARY)\n\t\tnloops = ARBITRARY;\n\tfor (nbits = 0; nloops > 255; nbits ++)\n\t\tnloops = nloops >> 1;\n\t*b1 = nbits;\n\t*b2 = nloops;\n\treturn nloops << nbits;\n}\n\n\nbool write_magic(rzip_control *control)\n{\n\tchar magic[MAGIC_LEN] = { \n\t\t'L', 'R', 'Z', 'I', LRZIP_MAJOR_VERSION, LRZIP_MINOR_VERSION \n\t};\n\n\t/* File size is stored as zero for streaming STDOUT blocks when the\n\t * file size is unknown. In encrypted files, the size is left unknown\n\t * and instead the salt is stored here to preserve space. */\n\tif (ENCRYPT)\n\t\tmemcpy(&magic[6], &control->salt, 8);\n\telse if (!STDIN || !STDOUT || control->eof) {\n\t\ti64 esize = htole64(control->st_size);\n\n\t\tmemcpy(&magic[6], &esize, 8);\n\t}\n\n\t/* save LZMA compression flags */\n\tif (LZMA_COMPRESS) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tmagic[i + 16] = (char)control->lzma_properties[i];\n\t}\n\n\t/* This is a flag that the archive contains an md5 sum at the end\n\t * which can be used as an integrity check instead of crc check.\n\t * crc is still stored for compatibility with 0.5 versions.\n\t */\n\tif (!NO_MD5)\n\t\tmagic[21] = 1;\n\tif (ENCRYPT)\n\t\tmagic[22] = 1;\n\n\tif (unlikely(fdout_seekto(control, 0)))\n\t\tfatal_return((\"Failed to seek to BOF to write Magic Header\\n\"), false);\n\n\tif (unlikely(put_fdout(control, magic, MAGIC_LEN) != MAGIC_LEN))\n\t\tfatal_return((\"Failed to write magic header\\n\"), false);\n\tcontrol->magic_written = 1;\n\treturn true;\n}\n\nstatic inline i64 enc_loops(uchar b1, uchar b2)\n{\n\treturn (i64)b2 << (i64)b1;\n}\n\nstatic bool get_magic(rzip_control *control, char *magic)\n{\n\tint encrypted, md5, i;\n\ti64 expected_size;\n\tuint32_t v;\n\n\tif (unlikely(strncmp(magic, \"LRZI\", 4)))\n\t\tfailure_return((\"Not an lrzip file\\n\"), false);\n\n\tmemcpy(&control->major_version, &magic[4], 1);\n\tmemcpy(&control->minor_version, &magic[5], 1);\n\n\tprint_verbose(\"Detected lrzip version %d.%d file.\\n\", control->major_version, control->minor_version);\n\tif (control->major_version > LRZIP_MAJOR_VERSION ||\n\t    (control->major_version == LRZIP_MAJOR_VERSION && control->minor_version > LRZIP_MINOR_VERSION))\n\t\tprint_output(\"Attempting to work with file produced by newer lrzip version %d.%d file.\\n\", control->major_version, control->minor_version);\n\n\t/* Support the convoluted way we described size in versions < 0.40 */\n\tif (control->major_version == 0 && control->minor_version < 4) {\n\t\tmemcpy(&v, &magic[6], 4);\n\t\texpected_size = ntohl(v);\n\t\tmemcpy(&v, &magic[10], 4);\n\t\texpected_size |= ((i64)ntohl(v)) << 32;\n\t} else {\n\t\tmemcpy(&expected_size, &magic[6], 8);\n\t\texpected_size = le64toh(expected_size);\n\t}\n\tcontrol->st_size = expected_size;\n\tif (control->major_version == 0 && control->minor_version < 6)\n\t\tcontrol->eof = 1;\n\n\t/* restore LZMA compression flags only if stored */\n\tif ((int) magic[16]) {\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tcontrol->lzma_properties[i] = magic[i + 16];\n\t\t/* Cludge to allow us to read possibly corrupted archives */\n\t\tif (!control->lzma_properties[0])\n\t\t\tcontrol->lzma_properties[0] = 93;\n\t}\n\n\t/* Whether this archive contains md5 data at the end or not */\n\tmd5 = magic[21];\n\tif (md5 && MD5_RELIABLE) {\n\t\tif (md5 == 1)\n\t\t\tcontrol->flags |= FLAG_MD5;\n\t\telse\n\t\t\tprint_verbose(\"Unknown hash, falling back to CRC\\n\");\n\t}\n\tencrypted = magic[22];\n\tif (encrypted) {\n\t\tif (encrypted == 1)\n\t\t\tcontrol->flags |= FLAG_ENCRYPT;\n\t\telse\n\t\t\tfailure_return((\"Unknown encryption\\n\"), false);\n\t\t/* In encrypted files, the size field is used to store the salt\n\t\t * instead and the size is unknown, just like a STDOUT chunked\n\t\t * file */\n\t\tmemcpy(&control->salt, &magic[6], 8);\n\t\tcontrol->st_size = expected_size = 0;\n\t\tcontrol->encloops = enc_loops(control->salt[0], control->salt[1]);\n\t\tprint_maxverbose(\"Encryption hash loops %lld\\n\", control->encloops);\n\t} else if (ENCRYPT) {\n\t\tprint_output(\"Asked to decrypt a non-encrypted archive. Bypassing decryption.\\n\");\n\t\tcontrol->flags &= ~FLAG_ENCRYPT;\n\t}\n\treturn true;\n}\n\nbool read_magic(rzip_control *control, int fd_in, i64 *expected_size)\n{\n\tchar magic[MAGIC_LEN];\n\n\tmemset(magic, 0, sizeof(magic));\n\t/* Initially read only <v0.6x header */\n\tif (unlikely(read(fd_in, magic, 24) != 24))\n\t\tfatal_return((\"Failed to read magic header\\n\"), false);\n\n\tif (unlikely(!get_magic(control, magic)))\n\t\treturn false;\n\t*expected_size = control->st_size;\n\treturn true;\n}\n\n/* preserve ownership and permissions where possible */\nstatic bool preserve_perms(rzip_control *control, int fd_in, int fd_out)\n{\n\tstruct stat st;\n\n\tif (unlikely(fstat(fd_in, &st)))\n\t\tfatal_return((\"Failed to fstat input file\\n\"), false);\n\tif (unlikely(fchmod(fd_out, (st.st_mode & 0666))))\n\t\tprint_verbose(\"Warning, unable to set permissions on %s\\n\", control->outfile);\n\n\t/* chown fail is not fatal_return(( */\n\tif (unlikely(fchown(fd_out, st.st_uid, st.st_gid)))\n\t\tprint_verbose(\"Warning, unable to set owner on %s\\n\", control->outfile);\n\treturn true;\n}\n\nstatic bool preserve_times(rzip_control *control, int fd_in)\n{\n\tstruct utimbuf times;\n\tstruct stat st;\n\n\tif (unlikely(fstat(fd_in, &st)))\n\t\tfatal_return((\"Failed to fstat input file\\n\"), false);\n\ttimes.actime = 0;\n\ttimes.modtime = st.st_mtime;\n\tif (unlikely(utime(control->outfile, &times)))\n\t\tprint_verbose(\"Warning, unable to set time on %s\\n\", control->outfile);\n\n\treturn true;\n}\n\n/* Open a temporary outputfile to emulate stdout */\nint open_tmpoutfile(rzip_control *control)\n{\n\tint fd_out;\n\n\tif (STDOUT && !TEST_ONLY)\n\t\tprint_verbose(\"Outputting to stdout.\\n\");\n\tif (control->tmpdir) {\n\t\tcontrol->outfile = realloc(NULL, strlen(control->tmpdir) + 16);\n\t\tif (unlikely(!control->outfile))\n\t\t\tfatal_return((\"Failed to allocate outfile name\\n\"), -1);\n\t\tstrcpy(control->outfile, control->tmpdir);\n\t\tstrcat(control->outfile, \"lrzipout.XXXXXX\");\n\t}\n\n\tfd_out = mkstemp(control->outfile);\n\tif (fd_out == -1) {\n\t\tprint_progress(\"WARNING: Failed to create out tmpfile: %s, will fail if cannot perform %scompression entirely in ram\\n\",\n\t\t\t       control->outfile, DECOMPRESS ? \"de\" : \"\");\n\t} else\n\t\tregister_outfile(control, control->outfile, TEST_ONLY || STDOUT || !KEEP_BROKEN);\n\treturn fd_out;\n}\n\nstatic bool fwrite_stdout(rzip_control *control, void *buf, i64 len)\n{\n\tuchar *offset_buf = buf;\n\tssize_t ret;\n\ti64 total;\n\n\ttotal = 0;\n\twhile (len > 0) {\n\t\tssize_t wrote;\n\n\t\tif (len > one_g)\n\t\t\tret = one_g;\n\t\telse\n\t\t\tret = len;\n\t\twrote = fwrite(offset_buf, 1, ret, control->outFILE);\n\t\tif (unlikely(wrote != ret))\n\t\t\tfatal_return((\"Failed to fwrite in fwrite_stdout\\n\"), false);\n\t\tlen -= ret;\n\t\toffset_buf += ret;\n\t\ttotal += ret;\n\t}\n\tfflush(control->outFILE);\n\treturn true;\n}\n\nbool write_fdout(rzip_control *control, void *buf, i64 len)\n{\n\tuchar *offset_buf = buf;\n\tssize_t ret;\n\n\twhile (len > 0) {\n\t\tret = MIN(len, one_g);\n\t\tret = write(control->fd_out, offset_buf, (size_t)ret);\n\t\tif (unlikely(ret <= 0))\n\t\t\tfatal_return((\"Failed to write to fd_out in write_fdout\\n\"), false);\n\t\tlen -= ret;\n\t\toffset_buf += ret;\n\t}\n\treturn true;\n}\n\nbool flush_tmpoutbuf(rzip_control *control)\n{\n\tif (!TEST_ONLY) {\n\t\tprint_maxverbose(\"Dumping buffer to physical file.\\n\");\n\t\tif (STDOUT) {\n\t\t\tif (unlikely(!fwrite_stdout(control, control->tmp_outbuf, control->out_len)))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (unlikely(!write_fdout(control, control->tmp_outbuf, control->out_len)))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tcontrol->out_relofs += control->out_len;\n\tcontrol->out_ofs = control->out_len = 0;\n\treturn true;\n}\n\n/* Dump temporary outputfile to perform stdout */\nbool dump_tmpoutfile(rzip_control *control, int fd_out)\n{\n\tFILE *tmpoutfp;\n\tint tmpchar;\n\n\tif (unlikely(fd_out == -1))\n\t\tfatal_return((\"Failed: No temporary outfile created, unable to do in ram\\n\"), false);\n\t/* flush anything not yet in the temporary file */\n\tfsync(fd_out);\n\ttmpoutfp = fdopen(fd_out, \"r\");\n\tif (unlikely(tmpoutfp == NULL))\n\t\tfatal_return((\"Failed to fdopen out tmpfile\\n\"), false);\n\trewind(tmpoutfp);\n\n\tif (!TEST_ONLY) {\n\t\tprint_verbose(\"Dumping temporary file to control->outFILE.\\n\");\n\t\twhile ((tmpchar = fgetc(tmpoutfp)) != EOF)\n\t\t\tputchar(tmpchar);\n\t\tfflush(control->outFILE);\n\t\trewind(tmpoutfp);\n\t}\n\n\tif (unlikely(ftruncate(fd_out, 0)))\n\t\tfatal_return((\"Failed to ftruncate fd_out in dump_tmpoutfile\\n\"), false);\n\treturn true;\n}\n\n/* Used if we're unable to read STDIN into the temporary buffer, shunts data\n * to temporary file */\nbool write_fdin(rzip_control *control)\n{\n\tuchar *offset_buf = control->tmp_inbuf;\n\ti64 len = control->in_len;\n\tssize_t ret;\n\n\twhile (len > 0) {\n\t\tret = MIN(len, one_g);\n\t\tret = write(control->fd_in, offset_buf, (size_t)ret);\n\t\tif (unlikely(ret <= 0))\n\t\t\tfatal_return((\"Failed to write to fd_in in write_fdin\\n\"), false);\n\t\tlen -= ret;\n\t\toffset_buf += ret;\n\t}\n\treturn true;\n}\n\n/* Open a temporary inputfile to perform stdin decompression */\nint open_tmpinfile(rzip_control *control)\n{\n\tint fd_in = -1;\n\n\t/* Use temporary directory if there is one */\n\tif (control->tmpdir) {\n\t\tcontrol->infile = malloc(strlen(control->tmpdir) + 15);\n\t\tif (unlikely(!control->infile))\n\t\t\tfatal_return((\"Failed to allocate infile name\\n\"), -1);\n\t\tstrcpy(control->infile, control->tmpdir);\n\t\tstrcat(control->infile, \"lrzipin.XXXXXX\");\n\t\tfd_in = mkstemp(control->infile);\n\t}\n\n\t/* Try the current directory */\n\tif (fd_in == -1) {\n\t\tdealloc(control->infile);\n\t\tcontrol->infile = malloc(16);\n\t\tif (unlikely(!control->infile))\n\t\t\tfatal_return((\"Failed to allocate infile name\\n\"), -1);\n\t\tstrcpy(control->infile, \"lrzipin.XXXXXX\");\n\t\tfd_in = mkstemp(control->infile);\n\t}\n\n\t/* Use /tmp if nothing is writeable so far */\n\tif (fd_in == -1) {\n\t\tdealloc(control->infile);\n\t\tcontrol->infile = malloc(20);\n\t\tif (unlikely(!control->infile))\n\t\t\tfatal_return((\"Failed to allocate infile name\\n\"), -1);\n\t\tstrcpy(control->infile, \"/tmp/lrzipin.XXXXXX\");\n\t\tfd_in = mkstemp(control->infile);\n\t}\n\n\tif (fd_in == -1) {\n\t\tprint_progress(\"WARNING: Failed to create in tmpfile: %s, will fail if cannot perform %scompression entirely in ram\\n\",\n\t\t\t       control->infile, DECOMPRESS ? \"de\" : \"\");\n\t} else {\n\t\tregister_infile(control, control->infile, (DECOMPRESS || TEST_ONLY) && STDIN);\n\t\t/* Unlink temporary file immediately to minimise chance of files left\n\t\t* lying around in cases of failure_return((. */\n\t\tif (unlikely(unlink(control->infile))) {\n\t\t\tfatal(\"Failed to unlink tmpfile: %s\\n\", control->infile);\n\t\t\tclose(fd_in);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn fd_in;\n}\n\nstatic bool read_tmpinmagic(rzip_control *control)\n{\n\tchar magic[MAGIC_LEN];\n\tint i, tmpchar;\n\n\tmemset(magic, 0, sizeof(magic));\n\tfor (i = 0; i < 24; i++) {\n\t\ttmpchar = getchar();\n\t\tif (unlikely(tmpchar == EOF))\n\t\t\tfailure_return((\"Reached end of file on STDIN prematurely on v05 magic read\\n\"), false);\n\t\tmagic[i] = (char)tmpchar;\n\t}\n\treturn get_magic(control, magic);\n}\n\n/* Read data from stdin into temporary inputfile */\nbool read_tmpinfile(rzip_control *control, int fd_in)\n{\n\tFILE *tmpinfp;\n\tint tmpchar;\n\n\tif (fd_in == -1)\n\t\treturn false;\n\tif (control->flags & FLAG_SHOW_PROGRESS)\n\t\tfprintf(control->msgout, \"Copying from stdin.\\n\");\n\ttmpinfp = fdopen(fd_in, \"w+\");\n\tif (unlikely(tmpinfp == NULL))\n\t\tfatal_return((\"Failed to fdopen in tmpfile\\n\"), false);\n\n\twhile ((tmpchar = getchar()) != EOF)\n\t\tfputc(tmpchar, tmpinfp);\n\n\tfflush(tmpinfp);\n\trewind(tmpinfp);\n\treturn true;\n}\n\n/* To perform STDOUT, we allocate a proportion of ram that is then used as\n * a pseudo-temporary file */\nstatic bool open_tmpoutbuf(rzip_control *control)\n{\n\ti64 maxlen = control->maxram;\n\tvoid *buf;\n\n\twhile (42) {\n\t\tround_to_page(&maxlen);\n\t\tbuf = malloc(maxlen);\n\t\tif (buf) {\n\t\t\tprint_maxverbose(\"Malloced %\"PRId64\" for tmp_outbuf\\n\", maxlen);\n\t\t\tbreak;\n\t\t}\n\t\tmaxlen = maxlen / 3 * 2;\n\t\tif (maxlen < 100000000)\n\t\t\tfatal_return((\"Unable to even malloc 100MB for tmp_outbuf\\n\"), false);\n\t}\n\tcontrol->flags |= FLAG_TMP_OUTBUF;\n\t/* Allocate slightly more so we can cope when the buffer overflows and\n\t * fall back to a real temporary file */\n\tcontrol->out_maxlen = maxlen - control->page_size;\n\tcontrol->tmp_outbuf = buf;\n\tif (!DECOMPRESS && !TEST_ONLY)\n\t\tcontrol->out_ofs = control->out_len = MAGIC_LEN;\\\n\treturn true;\n}\n\n/* We've decided to use a temporary output file instead of trying to store\n * all the output buffer in ram so we can free up the ram and increase the\n * maximum sizes of ram we can allocate */\nvoid close_tmpoutbuf(rzip_control *control)\n{\n\tcontrol->flags &= ~FLAG_TMP_OUTBUF;\n\tdealloc(control->tmp_outbuf);\n\tif (!BITS32)\n\t\tcontrol->usable_ram = control->maxram += control->ramsize / 18;\n}\n\nstatic bool open_tmpinbuf(rzip_control *control)\n{\n\tcontrol->flags |= FLAG_TMP_INBUF;\n\tcontrol->in_maxlen = control->maxram;\n\tcontrol->tmp_inbuf = malloc(control->maxram + control->page_size);\n\tif (unlikely(!control->tmp_inbuf))\n\t\tfatal_return((\"Failed to malloc tmp_inbuf in open_tmpinbuf\\n\"), false);\n\treturn true;\n}\n\nvoid clear_tmpinbuf(rzip_control *control)\n{\n\tcontrol->in_len = control->in_ofs = 0;\n}\n\nbool clear_tmpinfile(rzip_control *control)\n{\n\tif (unlikely(lseek(control->fd_in, 0, SEEK_SET)))\n\t\tfatal_return((\"Failed to lseek on fd_in in clear_tmpinfile\\n\"), false);\n\tif (unlikely(ftruncate(control->fd_in, 0)))\n\t\tfatal_return((\"Failed to truncate fd_in in clear_tmpinfile\\n\"), false);\n\treturn true;\n}\n\n/* As per temporary output file but for input file */\nvoid close_tmpinbuf(rzip_control *control)\n{\n\tcontrol->flags &= ~FLAG_TMP_INBUF;\n\tdealloc(control->tmp_inbuf);\n\tif (!BITS32)\n\t\tcontrol->usable_ram = control->maxram += control->ramsize / 18;\n}\n\nstatic int get_pass(rzip_control *control, char *s)\n{\n\tint len;\n\n\tmemset(s, 0, PASS_LEN - SALT_LEN);\n\tif (control->passphrase)\n\t\tstrncpy(s, control->passphrase, PASS_LEN - SALT_LEN - 1);\n\telse if (unlikely(fgets(s, PASS_LEN - SALT_LEN, stdin) == NULL))\n\t\tfailure_return((\"Failed to retrieve passphrase\\n\"), -1);\n\tlen = strlen(s);\n\tif (len > 0 && ('\\r' ==  s[len - 1] || '\\n' == s[len - 1]))\n\t\ts[len - 1] = '\\0';\n\tif (len > 1 && ('\\r' ==  s[len - 2] || '\\n' == s[len - 2]))\n\t\ts[len - 2] = '\\0';\n\tlen = strlen(s);\n\tif (unlikely(0 == len))\n\t\tfailure_return((\"Empty passphrase\\n\"), -1);\n\treturn len;\n}\n\nstatic bool get_hash(rzip_control *control, int make_hash)\n{\n\tchar *passphrase, *testphrase;\n\tstruct termios termios_p;\n\tint prompt = control->passphrase == NULL;\n\n\tpassphrase = calloc(PASS_LEN, 1);\n\ttestphrase = calloc(PASS_LEN, 1);\n\tcontrol->salt_pass = calloc(PASS_LEN, 1);\n\tcontrol->hash = calloc(HASH_LEN, 1);\n\tif (unlikely(!passphrase || !testphrase || !control->salt_pass || !control->hash)) {\n\t\tfatal(\"Failed to calloc encrypt buffers in compress_file\\n\");\n\t\tdealloc(testphrase);\n\t\tdealloc(passphrase);\n\t\treturn false;\n\t}\n\tmlock(passphrase, PASS_LEN);\n\tmlock(testphrase, PASS_LEN);\n\tmlock(control->salt_pass, PASS_LEN);\n\tmlock(control->hash, HASH_LEN);\n\n\tif (control->pass_cb) {\n\t\tcontrol->pass_cb(control->pass_data, passphrase, PASS_LEN - SALT_LEN);\n\t\tif (!passphrase[0]) {\n\t\t\tfatal(\"Supplied password was null!\");\n\t\t\tmunlock(passphrase, PASS_LEN);\n\t\t\tmunlock(testphrase, PASS_LEN);\n\t\t\tdealloc(testphrase);\n\t\t\tdealloc(passphrase);\n\t\t\trelease_hashes(control);\n\t\t\treturn false;\n\t\t}\n\t\tcontrol->salt_pass_len = strlen(passphrase) + SALT_LEN;\n\t} else {\n\t\t/* Disable stdin echo to screen */\n\t\ttcgetattr(fileno(stdin), &termios_p);\n\t\ttermios_p.c_lflag &= ~ECHO;\n\t\ttcsetattr(fileno(stdin), 0, &termios_p);\nretry_pass:\n\t\tif (prompt)\n\t\t\tprint_output(\"Enter passphrase: \");\n\t\tcontrol->salt_pass_len = get_pass(control, passphrase) + SALT_LEN;\n\t\tif (prompt)\n\t\t\tprint_output(\"\\n\");\n\t\tif (make_hash) {\n\t\t\tif (prompt)\n\t\t\t\tprint_output(\"Re-enter passphrase: \");\n\t\t\tget_pass(control, testphrase);\n\t\t\tif (prompt)\n\t\t\t\tprint_output(\"\\n\");\n\t\t\tif (strcmp(passphrase, testphrase)) {\n\t\t\t\tprint_output(\"Passwords do not match. Try again.\\n\");\n\t\t\t\tgoto retry_pass;\n\t\t\t}\n\t\t}\n\t\ttermios_p.c_lflag |= ECHO;\n\t\ttcsetattr(fileno(stdin), 0, &termios_p);\n\t\tmemset(testphrase, 0, PASS_LEN);\n\t}\n\tmemcpy(control->salt_pass, control->salt, SALT_LEN);\n\tmemcpy(control->salt_pass + SALT_LEN, passphrase, PASS_LEN - SALT_LEN);\n\tlrz_stretch(control);\n\tmemset(passphrase, 0, PASS_LEN);\n\tmunlock(passphrase, PASS_LEN);\n\tmunlock(testphrase, PASS_LEN);\n\tdealloc(testphrase);\n\tdealloc(passphrase);\n\treturn true;\n}\n\nstatic void release_hashes(rzip_control *control)\n{\n\tmemset(control->salt_pass, 0, PASS_LEN);\n\tmemset(control->hash, 0, SALT_LEN);\n\tmunlock(control->salt_pass, PASS_LEN);\n\tmunlock(control->hash, HASH_LEN);\n\tdealloc(control->salt_pass);\n\tdealloc(control->hash);\n}\n\n/*\n  decompress one file from the command line\n*/\nbool decompress_file(rzip_control *control)\n{\n\tchar *tmp, *tmpoutfile, *infilecopy = NULL;\n\tint fd_in, fd_out = -1, fd_hist = -1;\n\ti64 expected_size = 0, free_space;\n\tstruct statvfs fbuf;\n\n\tif (!STDIN && !IS_FROM_FILE) {\n\t\tstruct stat fdin_stat;\n\n\t\tstat(control->infile, &fdin_stat);\n\t\tif (!S_ISREG(fdin_stat.st_mode) && (tmp = strrchr(control->infile, '.')) &&\n\t\t    strcmp(tmp,control->suffix)) {\n\t\t\t/* make sure infile has an extension. If not, add it\n\t\t\t  * because manipulations may be made to input filename, set local ptr\n\t\t\t*/\n\t\t\tinfilecopy = alloca(strlen(control->infile) + strlen(control->suffix) + 1);\n\t\t\tstrcpy(infilecopy, control->infile);\n\t\t\tstrcat(infilecopy, control->suffix);\n\t\t} else\n\t\t\tinfilecopy = strdupa(control->infile);\n\t\t/* regardless, infilecopy has the input filename */\n\t}\n\n\tif (!STDOUT && !TEST_ONLY) {\n\t\t/* if output name already set, use it */\n\t\tif (control->outname) {\n\t\t\tcontrol->outfile = strdup(control->outname);\n\t\t} else {\n\t\t\t/* default output name from infilecopy\n\t\t\t * test if outdir specified. If so, strip path from filename of\n\t\t\t * infilecopy, then remove suffix.\n\t\t\t*/\n\t\t\tif (control->outdir && (tmp = strrchr(infilecopy, '/')))\n\t\t\t\ttmpoutfile = strdupa(tmp + 1);\n\t\t\telse\n\t\t\t\ttmpoutfile = strdupa(infilecopy);\n\n\t\t\t/* remove suffix to make outfile name */\n\t\t\tif ((tmp = strrchr(tmpoutfile, '.')) && !strcmp(tmp, control->suffix))\n\t\t\t\t*tmp='\\0';\n\n\t\t\tcontrol->outfile = malloc((control->outdir == NULL? 0: strlen(control->outdir)) + strlen(tmpoutfile) + 1);\n\t\t\tif (unlikely(!control->outfile))\n\t\t\t\tfatal_return((\"Failed to allocate outfile name\\n\"), false);\n\n\t\t\tif (control->outdir) {\t/* prepend control->outdir */\n\t\t\t\tstrcpy(control->outfile, control->outdir);\n\t\t\t\tstrcat(control->outfile, tmpoutfile);\n\t\t\t} else\n\t\t\t\tstrcpy(control->outfile, tmpoutfile);\n\t\t}\n\n\t\tif (!STDOUT)\n\t\t\tprint_progress(\"Output filename is: %s\\n\", control->outfile);\n\t}\n\n\tif ( IS_FROM_FILE ) {\n\t\tfd_in = fileno(control->inFILE);\n\t}\n\telse if (STDIN) {\n\t\tfd_in = open_tmpinfile(control);\n\t\tread_tmpinmagic(control);\n\t\tif (ENCRYPT)\n\t\t\tfailure_return((\"Cannot decompress encrypted file from STDIN\\n\"), false);\n\t\texpected_size = control->st_size;\n\t\tif (unlikely(!open_tmpinbuf(control)))\n\t\t\treturn false;\n\t} else {\n\t\tfd_in = open(infilecopy, O_RDONLY);\n\t\tif (unlikely(fd_in == -1)) {\n\t\t\tfatal_return((\"Failed to open %s\\n\", infilecopy), false);\n\t\t}\n\t}\n\tcontrol->fd_in = fd_in;\n\n\tif (!(TEST_ONLY | STDOUT)) {\n\t\tfd_out = open(control->outfile, O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t\tif (FORCE_REPLACE && (-1 == fd_out) && (EEXIST == errno)) {\n\t\t\tif (unlikely(unlink(control->outfile)))\n\t\t\t\tfatal_return((\"Failed to unlink an existing file: %s\\n\", control->outfile), false);\n\t\t\tfd_out = open(control->outfile, O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t\t}\n\t\tif (unlikely(fd_out == -1)) {\n\t\t\t/* We must ensure we don't delete a file that already\n\t\t\t * exists just because we tried to create a new one */\n\t\t\tcontrol->flags |= FLAG_KEEP_BROKEN;\n\t\t\tfatal_return((\"Failed to create %s\\n\", control->outfile), false);\n\t\t}\n\t\tfd_hist = open(control->outfile, O_RDONLY);\n\t\tif (unlikely(fd_hist == -1))\n\t\t\tfatal_return((\"Failed to open history file %s\\n\", control->outfile), false);\n\n\t\t/* Can't copy permissions from STDIN */\n\t\tif (!STDIN)\n\t\t\tif (unlikely(!preserve_perms(control, fd_in, fd_out)))\n\t\t\t\treturn false;\n\t} else {\n\t\tfd_out = open_tmpoutfile(control);\n\t\tif (fd_out == -1) {\n\t\t\tfd_hist = -1;\n\t\t} else {\n\t\t\tfd_hist = open(control->outfile, O_RDONLY);\n\t\t\tif (unlikely(fd_hist == -1))\n\t\t\t\tfatal_return((\"Failed to open history file %s\\n\", control->outfile), false);\n\t\t\t/* Unlink temporary file as soon as possible */\n\t\t\tif (unlikely(unlink(control->outfile)))\n\t\t\t\tfatal_return((\"Failed to unlink tmpfile: %s\\n\", control->outfile), false);\n\t\t}\n\t}\n\n\tif (STDOUT) {\n\t\tif (unlikely(!open_tmpoutbuf(control)))\n\t\t\treturn false;\n\t}\n\n\tif (!STDIN) {\n\t\tif (unlikely(!read_magic(control, fd_in, &expected_size)))\n\t\t\treturn false;\n\t\tif (unlikely(expected_size < 0))\n\t\t\tfatal_return((\"Invalid expected size %lld\\n\", expected_size), false);\n\t}\n\n\tif (!STDOUT && !TEST_ONLY) {\n\t\t/* Check if there's enough free space on the device chosen to fit the\n\t\t* decompressed file. */\n\t\tif (unlikely(fstatvfs(fd_out, &fbuf)))\n\t\t\tfatal_return((\"Failed to fstatvfs in decompress_file\\n\"), false);\n\t\tfree_space = (i64)fbuf.f_bsize * (i64)fbuf.f_bavail;\n\t\tif (free_space < expected_size) {\n\t\t\tif (FORCE_REPLACE)\n\t\t\t\tprint_err(\"Warning, inadequate free space detected, but attempting to decompress due to -f option being used.\\n\");\n\t\t\telse\n\t\t\t\tfailure_return((\"Inadequate free space to decompress file, use -f to override.\\n\"), false);\n\t\t}\n\t}\n\tcontrol->fd_out = fd_out;\n\tcontrol->fd_hist = fd_hist;\n\n\tif (NO_MD5)\n\t\tprint_verbose(\"Not performing MD5 hash check\\n\");\n\tif (HAS_MD5)\n\t\tprint_verbose(\"MD5 \");\n\telse\n\t\tprint_verbose(\"CRC32 \");\n\tprint_verbose(\"being used for integrity testing.\\n\");\n\n\tif (ENCRYPT)\n\t\tif (unlikely(!get_hash(control, 0)))\n\t\t\treturn false;\n\n\tprint_progress(\"Decompressing...\\n\");\n\n\tif (unlikely(runzip_fd(control, fd_in, fd_out, fd_hist, expected_size) < 0))\n\t\treturn false;\n\n\tif (STDOUT && !TMP_OUTBUF) {\n\t\tif (unlikely(!dump_tmpoutfile(control, fd_out)))\n\t\t\treturn false;\n\t}\n\n\t/* if we get here, no fatal_return(( errors during decompression */\n\tprint_progress(\"\\r\");\n\tif (!(STDOUT | TEST_ONLY))\n\t\tprint_progress(\"Output filename is: %s: \", control->outfile);\n\tif (!expected_size)\n\t\texpected_size = control->st_size;\n\tif (!ENCRYPT)\n\t\tprint_progress(\"[OK] - %lld bytes                                \\n\", expected_size);\n\telse\n\t\tprint_progress(\"[OK]                                             \\n\");\n\n\tif (TMP_OUTBUF)\n\t\tclose_tmpoutbuf(control);\n\n\tif (fd_out > 0) {\n\t\tif (unlikely(close(fd_hist) || close(fd_out)))\n\t\t\tfatal_return((\"Failed to close files\\n\"), false);\n\t}\n\n\tif (unlikely(!STDIN && !STDOUT && !TEST_ONLY && !preserve_times(control, fd_in)))\n\t\treturn false;\n\n\tif ( ! IS_FROM_FILE ) {\n\t\tclose(fd_in);\n\t}\n\n\tif (!KEEP_FILES && !STDIN) {\n\t\tif (unlikely(unlink(control->infile)))\n\t\t\tfatal_return((\"Failed to unlink %s\\n\", infilecopy), false);\n\t}\n\n\tif (ENCRYPT)\n\t\trelease_hashes(control);\n\n\tdealloc(control->outfile);\n\treturn true;\n}\n\nbool get_header_info(rzip_control *control, int fd_in, uchar *ctype, i64 *c_len,\n\t\t     i64 *u_len, i64 *last_head, int chunk_bytes)\n{\n\tif (unlikely(read(fd_in, ctype, 1) != 1))\n\t\tfatal_return((\"Failed to read in get_header_info\\n\"), false);\n\n\t*c_len = *u_len = *last_head = 0;\n\tif (control->major_version == 0 && control->minor_version < 4) {\n\t\tu32 c_len32, u_len32, last_head32;\n\n\t\tif (unlikely(read(fd_in, &c_len32, 4) != 4))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tif (unlikely(read(fd_in, &u_len32, 4) != 4))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tif (unlikely(read(fd_in, &last_head32, 4) != 4))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tc_len32 = le32toh(c_len32);\n\t\tu_len32 = le32toh(u_len32);\n\t\tlast_head32 = le32toh(last_head32);\n\t\t*c_len = c_len32;\n\t\t*u_len = u_len32;\n\t\t*last_head = last_head32;\n\t} else {\n\t\tint read_len;\n\n\t\tif (control->major_version == 0 && control->minor_version == 5)\n\t\t\tread_len = 8;\n\t\telse\n\t\t\tread_len = chunk_bytes;\n\t\tif (unlikely(read(fd_in, c_len, read_len) != read_len))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tif (unlikely(read(fd_in, u_len, read_len) != read_len))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tif (unlikely(read(fd_in, last_head, read_len) != read_len))\n\t\t\tfatal_return((\"Failed to read_i64 in get_header_info\"), false);\n\t\t*c_len = le64toh(*c_len);\n\t\t*u_len = le64toh(*u_len);\n\t\t*last_head = le64toh(*last_head);\n\t}\n\treturn true;\n}\n\nstatic double percentage(i64 num, i64 den)\n{\n\tdouble d_num, d_den;\n\n\tif (den < 100) {\n\t\td_num = num * 100;\n\t\td_den = den;\n\t\tif (!d_den)\n\t\t\td_den = 1;\n\t} else {\n\t\td_num = num;\n\t\td_den = den / 100;\n\t}\n\treturn d_num / d_den;\n}\n\nbool get_fileinfo(rzip_control *control)\n{\n\ti64 u_len, c_len, second_last, last_head, utotal = 0, ctotal = 0, ofs = 25, stream_head[2];\n\ti64 expected_size, infile_size, chunk_size = 0, chunk_total = 0;\n\tint header_length, stream = 0, chunk = 0;\n\tchar *tmp, *infilecopy = NULL;\n\tchar chunk_byte = 0;\n\tlong double cratio;\n\tuchar ctype = 0;\n\tuchar save_ctype = 255;\n\tstruct stat st;\n\tint fd_in;\n\n\tif (!STDIN) {\n\t\tstruct stat fdin_stat;\n\n\t\tstat(control->infile, &fdin_stat);\n\t\tif (!S_ISREG(fdin_stat.st_mode) && (tmp = strrchr(control->infile, '.')) &&\n\t\t    strcmp(tmp,control->suffix)) {\n\t\t\tinfilecopy = alloca(strlen(control->infile) + strlen(control->suffix) + 1);\n\t\t\tstrcpy(infilecopy, control->infile);\n\t\t\tstrcat(infilecopy, control->suffix);\n\t\t} else\n\t\t\tinfilecopy = strdupa(control->infile);\n\t}\n\n\tif ( IS_FROM_FILE )\n\t\tfd_in = fileno(control->inFILE);\n\telse if (STDIN)\n\t\tfd_in = 0;\n\telse {\n\t\tfd_in = open(infilecopy, O_RDONLY);\n\t\tif (unlikely(fd_in == -1))\n\t\t\tfatal_return((\"Failed to open %s\\n\", infilecopy), false);\n\t}\n\n\t/* Get file size */\n\tif (unlikely(fstat(fd_in, &st)))\n\t\tfatal_goto((\"bad magic file descriptor!?\\n\"), error);\n\tinfile_size = st.st_size;\n\n\t/* Get decompressed size */\n\tif (unlikely(!read_magic(control, fd_in, &expected_size)))\n\t\tgoto error;\n\n\tif (ENCRYPT) {\n\t\tprint_output(\"Encrypted lrzip archive. No further information available\\n\");\n\t\tif (!STDIN && !IS_FROM_FILE)\n\t\t\tclose(fd_in);\n\t\tgoto out;\n\t}\n\n\tif (control->major_version == 0 && control->minor_version > 4) {\n\t\tif (unlikely(read(fd_in, &chunk_byte, 1) != 1))\n\t\t\tfatal_goto((\"Failed to read chunk_byte in get_fileinfo\\n\"), error);\n\t\tif (unlikely(chunk_byte < 1 || chunk_byte > 8))\n\t\t\tfatal_goto((\"Invalid chunk bytes %d\\n\", chunk_byte), error);\n\t\tif (control->major_version == 0 && control->minor_version > 5) {\n\t\t\tif (unlikely(read(fd_in, &control->eof, 1) != 1))\n\t\t\t\tfatal_goto((\"Failed to read eof in get_fileinfo\\n\"), error);\n\t\t\tif (unlikely(read(fd_in, &chunk_size, chunk_byte) != chunk_byte))\n\t\t\t\tfatal_goto((\"Failed to read chunk_size in get_fileinfo\\n\"), error);\n\t\t\tchunk_size = le64toh(chunk_size);\n\t\t\tif (unlikely(chunk_size < 0))\n\t\t\t\tfatal_goto((\"Invalid chunk size %lld\\n\", chunk_size), error);\n\t\t}\n\t}\n\n\tif (control->major_version == 0 && control->minor_version < 4) {\n\t\tofs = 24;\n\t\theader_length = 13;\n\t} else if (control->major_version == 0 && control->minor_version == 4) {\n\t\tofs = 24;\n\t\theader_length = 25;\n\t} else if (control->major_version == 0 && control->minor_version == 5) {\n\t\tofs = 25;\n\t\theader_length = 25;\n\t} else {\n\t\tofs = 26 + chunk_byte;\n\t\theader_length = 1 + (chunk_byte * 3);\n\t}\n\tif (control->major_version == 0 && control->minor_version < 6 &&\n\t\t!expected_size)\n\t\t\tgoto done;\nnext_chunk:\n\tstream = 0;\n\tstream_head[0] = 0;\n\tstream_head[1] = stream_head[0] + header_length;\n\n\tprint_verbose(\"Rzip chunk %d:\\n\", ++chunk);\n\tif (chunk_byte)\n\t\tprint_verbose(\"Chunk byte width: %d\\n\", chunk_byte);\n\tif (chunk_size) {\n\t\tchunk_total += chunk_size;\n\t\tprint_verbose(\"Chunk size: %lld\\n\", chunk_size);\n\t}\n\tif (unlikely(chunk_byte && (chunk_byte > 8 || chunk_size < 0)))\n\t\tfailure(\"Invalid chunk data\\n\");\n\twhile (stream < NUM_STREAMS) {\n\t\tint block = 1;\n\n\t\tsecond_last = 0;\n\t\tif (unlikely(lseek(fd_in, stream_head[stream] + ofs, SEEK_SET) == -1))\n\t\t\tfatal_goto((\"Failed to seek to header data in get_fileinfo\\n\"), error);\n\t\tif (unlikely(!get_header_info(control, fd_in, &ctype, &c_len, &u_len, &last_head, chunk_byte)))\n\t\t\treturn false;\n\n\t\tprint_verbose(\"Stream: %d\\n\", stream);\n\t\tprint_maxverbose(\"Offset: %lld\\n\", stream_head[stream] + ofs);\n\t\tprint_verbose(\"Block\\tComp\\tPercent\\tSize\\n\");\n\t\tdo {\n\t\t\ti64 head_off;\n\n\t\t\tif (unlikely(last_head && last_head < second_last))\n\t\t\t\tfailure_goto((\"Invalid earlier last_head position, corrupt archive.\\n\"), error);\n\t\t\tsecond_last = last_head;\n\t\t\tif (unlikely(last_head + ofs > infile_size))\n\t\t\t\tfailure_goto((\"Offset greater than archive size, likely corrupted/truncated archive.\\n\"), error);\n\t\t\tif (unlikely((head_off = lseek(fd_in, last_head + ofs, SEEK_SET)) == -1))\n\t\t\t\tfatal_goto((\"Failed to seek to header data in get_fileinfo\\n\"), error);\n\t\t\tif (unlikely(!get_header_info(control, fd_in, &ctype, &c_len, &u_len,\n\t\t\t\t\t&last_head, chunk_byte)))\n\t\t\t\treturn false;\n\t\t\tif (unlikely(last_head < 0 || c_len < 0 || u_len < 0))\n\t\t\t\tfailure_goto((\"Entry negative, likely corrupted archive.\\n\"), error);\n\t\t\tprint_verbose(\"%d\\t\", block);\n\t\t\tif (ctype == CTYPE_NONE)\n\t\t\t\tprint_verbose(\"none\");\n\t\t\telse if (ctype == CTYPE_BZIP2)\n\t\t\t\tprint_verbose(\"bzip2\");\n\t\t\telse if (ctype == CTYPE_LZO)\n\t\t\t\tprint_verbose(\"lzo\");\n\t\t\telse if (ctype == CTYPE_LZMA)\n\t\t\t\tprint_verbose(\"lzma\");\n\t\t\telse if (ctype == CTYPE_GZIP)\n\t\t\t\tprint_verbose(\"gzip\");\n\t\t\telse if (ctype == CTYPE_ZPAQ)\n\t\t\t\tprint_verbose(\"zpaq\");\n\t\t\telse\n\t\t\t\tprint_verbose(\"Dunno wtf\");\n\t\t\tif (save_ctype == 255)\n\t\t\t\tsave_ctype = ctype; /* need this for lzma when some chunks could have no compression\n\t\t\t\t\t\t     * and info will show rzip + none on info display if last chunk\n\t\t\t\t\t\t     * is not compressed. Adjust for all types in case it's used in\n\t\t\t\t\t\t     * the future */\n\t\t\tutotal += u_len;\n\t\t\tctotal += c_len;\n\t\t\tprint_verbose(\"\\t%.1f%%\\t%lld / %lld\", percentage(c_len, u_len), c_len, u_len);\n\t\t\tprint_maxverbose(\"\\tOffset: %lld\\tHead: %lld\", head_off, last_head);\n\t\t\tprint_verbose(\"\\n\");\n\t\t\tblock++;\n\t\t} while (last_head);\n\t\t++stream;\n\t}\n\n\tif (unlikely((ofs = lseek(fd_in, c_len, SEEK_CUR)) == -1))\n\t\tfatal_goto((\"Failed to lseek c_len in get_fileinfo\\n\"), error);\n\n\tif (ofs >= infile_size - (HAS_MD5 ? MD5_DIGEST_SIZE : 0))\n\t\tgoto done;\n\t/* Chunk byte entry */\n\tif (control->major_version == 0 && control->minor_version > 4) {\n\t\tif (unlikely(read(fd_in, &chunk_byte, 1) != 1))\n\t\t\tfatal_goto((\"Failed to read chunk_byte in get_fileinfo\\n\"), error);\n\t\tif (unlikely(chunk_byte < 1 || chunk_byte > 8))\n\t\t\tfatal_goto((\"Invalid chunk bytes %d\\n\", chunk_byte), error);\n\t\tofs++;\n\t\tif (control->major_version == 0 && control->minor_version > 5) {\n\t\t\tif (unlikely(read(fd_in, &control->eof, 1) != 1))\n\t\t\t\tfatal_goto((\"Failed to read eof in get_fileinfo\\n\"), error);\n\t\t\tif (unlikely(read(fd_in, &chunk_size, chunk_byte) != chunk_byte))\n\t\t\t\tfatal_goto((\"Failed to read chunk_size in get_fileinfo\\n\"), error);\n\t\t\tchunk_size = le64toh(chunk_size);\n\t\t\tif (unlikely(chunk_size < 0))\n\t\t\t\tfatal_goto((\"Invalid chunk size %lld\\n\", chunk_size), error);\n\t\t\tofs += 1 + chunk_byte;\n\t\t\theader_length = 1 + (chunk_byte * 3);\n\t\t}\n\t}\n\tgoto next_chunk;\ndone:\n\tif (unlikely(ofs > infile_size))\n\t\tfailure_goto((\"Offset greater than archive size, likely corrupted/truncated archive.\\n\"), error);\n\tprint_verbose(\"Rzip compression: %.1f%% %lld / %lld\\n\",\n\t\t\tpercentage (utotal, expected_size),\n\t\t\tutotal, expected_size);\n\tprint_verbose(\"Back end compression: %.1f%% %lld / %lld\\n\",\n\t\t\tpercentage(ctotal, utotal),\n\t\t\tctotal, utotal);\n\tprint_verbose(\"Overall compression: %.1f%% %lld / %lld\\n\",\n\t\t\tpercentage(ctotal, expected_size),\n\t\t\tctotal, expected_size);\n\n\tcratio = (long double)expected_size / (long double)infile_size;\n\n\tprint_output(\"%s:\\nlrzip version: %d.%d file\\n\", infilecopy, control->major_version, control->minor_version);\n\n\tprint_output(\"Compression: \");\n\tif (save_ctype == CTYPE_NONE)\n\t\tprint_output(\"rzip alone\\n\");\n\telse if (save_ctype == CTYPE_BZIP2)\n\t\tprint_output(\"rzip + bzip2\\n\");\n\telse if (save_ctype == CTYPE_LZO)\n\t\tprint_output(\"rzip + lzo\\n\");\n\telse if (save_ctype == CTYPE_LZMA)\n\t\tprint_output(\"rzip + lzma\\n\");\n\telse if (save_ctype == CTYPE_GZIP)\n\t\tprint_output(\"rzip + gzip\\n\");\n\telse if (save_ctype == CTYPE_ZPAQ)\n\t\tprint_output(\"rzip + zpaq\\n\");\n\telse\n\t\tprint_output(\"Dunno wtf\\n\");\n\tprint_output(\"Decompressed file size: %llu\\n\", expected_size);\n\tprint_output(\"Compressed file size: %llu\\n\", infile_size);\n\tprint_output(\"Compression ratio: %.3Lf\\n\", cratio);\n\n\tif (HAS_MD5) {\n\t\tchar md5_stored[MD5_DIGEST_SIZE];\n\t\tint i;\n\n\t\tprint_output(\"MD5 used for integrity testing\\n\");\n\t\tif (unlikely(lseek(fd_in, -MD5_DIGEST_SIZE, SEEK_END) == -1))\n\t\t\tfatal_goto((\"Failed to seek to md5 data in runzip_fd\\n\"), error);\n\t\tif (unlikely(read(fd_in, md5_stored, MD5_DIGEST_SIZE) != MD5_DIGEST_SIZE))\n\t\t\tfatal_goto((\"Failed to read md5 data in runzip_fd\\n\"), error);\n\t\tprint_output(\"MD5: \");\n\t\tfor (i = 0; i < MD5_DIGEST_SIZE; i++)\n\t\t\tprint_output(\"%02x\", md5_stored[i] & 0xFF);\n\t\tprint_output(\"\\n\");\n\t} else\n\t\tprint_output(\"CRC32 used for integrity testing\\n\");\n\tif ( !IS_FROM_FILE )\n\t\tif (unlikely(close(fd_in)))\n\t\t\tfatal_return((\"Failed to close fd_in in get_fileinfo\\n\"), false);\n\nout:\n\tdealloc(control->outfile);\n\treturn true;\nerror:\n\tif (!STDIN && ! IS_FROM_FILE) close(fd_in);\n\treturn false;\n}\n\n/*\n  compress one file from the command line\n*/\nbool compress_file(rzip_control *control)\n{\n\tconst char *tmp, *tmpinfile; \t/* we're just using this as a proxy for control->infile.\n\t\t\t\t\t * Spares a compiler warning\n\t\t\t\t\t */\n\tint fd_in = -1, fd_out = -1;\n\tchar header[MAGIC_LEN];\n\n\tif (MD5_RELIABLE)\n\t\tcontrol->flags |= FLAG_MD5;\n\tif (ENCRYPT)\n\t\tif (unlikely(!get_hash(control, 1)))\n\t\t\treturn false;\n\tmemset(header, 0, sizeof(header));\n\n\tif ( IS_FROM_FILE )\n\t\tfd_in = fileno(control->inFILE);\n\telse if (!STDIN) {\n\t\t /* is extension at end of infile? */\n\t\tif ((tmp = strrchr(control->infile, '.')) && !strcmp(tmp, control->suffix)) {\n\t\t\tprint_err(\"%s: already has %s suffix. Skipping...\\n\", control->infile, control->suffix);\n\t\t\treturn false;\n\t\t}\n\n        fd_in = open(control->infile, O_RDONLY);\n\t\tif (unlikely(fd_in == -1))\n\t\t\tfatal_return((\"Failed to open %s\\n\", control->infile), false);\n\t} \n\telse\n\t\tfd_in = 0;\n\n\tif (!STDOUT) {\n\t\tif (control->outname) {\n\t\t\t\t/* check if outname has control->suffix */\n\t\t\t\tif (*(control->suffix) == '\\0') /* suffix is empty string */\n\t\t\t\t\tcontrol->outfile = strdup(control->outname);\n\t\t\t\telse if ((tmp=strrchr(control->outname, '.')) && strcmp(tmp, control->suffix)) {\n\t\t\t\t\tcontrol->outfile = malloc(strlen(control->outname) + strlen(control->suffix) + 1);\n\t\t\t\t\tif (unlikely(!control->outfile))\n\t\t\t\t\t\tfatal_goto((\"Failed to allocate outfile name\\n\"), error);\n\t\t\t\t\tstrcpy(control->outfile, control->outname);\n\t\t\t\t\tstrcat(control->outfile, control->suffix);\n\t\t\t\t\tprint_output(\"Suffix added to %s.\\nFull pathname is: %s\\n\", control->outname, control->outfile);\n\t\t\t\t} else\t/* no, already has suffix */\n\t\t\t\t\tcontrol->outfile = strdup(control->outname);\n\t\t} else {\n\t\t\t/* default output name from control->infile\n\t\t\t * test if outdir specified. If so, strip path from filename of\n\t\t\t * control->infile\n\t\t\t*/\n\t\t\tif (control->outdir && (tmp = strrchr(control->infile, '/')))\n\t\t\t\ttmpinfile = tmp + 1;\n\t\t\telse\n\t\t\t\ttmpinfile = control->infile;\n\n\t\t\tcontrol->outfile = malloc((control->outdir == NULL? 0: strlen(control->outdir)) + strlen(tmpinfile) + strlen(control->suffix) + 1);\n\t\t\tif (unlikely(!control->outfile))\n\t\t\t\tfatal_goto((\"Failed to allocate outfile name\\n\"), error);\n\n\t\t\tif (control->outdir) {\t/* prepend control->outdir */\n\t\t\t\tstrcpy(control->outfile, control->outdir);\n\t\t\t\tstrcat(control->outfile, tmpinfile);\n\t\t\t} else\n\t\t\t\tstrcpy(control->outfile, tmpinfile);\n\t\t\tstrcat(control->outfile, control->suffix);\n\t\t\tprint_progress(\"Output filename is: %s\\n\", control->outfile);\n\t\t}\n\n\t\tfd_out = open(control->outfile, O_RDWR | O_CREAT | O_EXCL, 0666);\n\t\tif (FORCE_REPLACE && (-1 == fd_out) && (EEXIST == errno)) {\n\t\t\tif (unlikely(unlink(control->outfile)))\n\t\t\t\tfatal_goto((\"Failed to unlink an existing file: %s\\n\", control->outfile), error);\n\t\t\tfd_out = open(control->outfile, O_RDWR | O_CREAT | O_EXCL, 0666);\n\t\t}\n\t\tif (unlikely(fd_out == -1)) {\n\t\t\t/* We must ensure we don't delete a file that already\n\t\t\t * exists just because we tried to create a new one */\n\t\t\tcontrol->flags |= FLAG_KEEP_BROKEN;\n\t\t\tfatal_goto((\"Failed to create %s\\n\", control->outfile), error);\n\t\t}\n\t\tcontrol->fd_out = fd_out;\n\t\tif (!STDIN) {\n\t\t\tif (unlikely(!preserve_perms(control, fd_in, fd_out)))\n\t\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tif (unlikely(!open_tmpoutbuf(control)))\n\t\t\tgoto error;\n\t}\n\n\t/* Write zeroes to header at beginning of file */\n\tif (unlikely(!STDOUT && write(fd_out, header, sizeof(header)) != sizeof(header)))\n\t\tfatal_goto((\"Cannot write file header\\n\"), error);\n\n\trzip_fd(control, fd_in, fd_out);\n\n\t/* Wwrite magic at end b/c lzma does not tell us properties until it is done */\n\tif (!STDOUT) {\n\t\tif (unlikely(!write_magic(control)))\n\t\t\tgoto error;\n\t}\n\n\tif (ENCRYPT)\n\t\trelease_hashes(control);\n\n\tif (unlikely(!STDIN && !STDOUT && !preserve_times(control, fd_in))) {\n\t\tfatal(\"Failed to preserve times on output file\\n\");\n\t\tgoto error;\n\t}\n\n\tif (unlikely(close(fd_in))) {\n\t\tfatal(\"Failed to close fd_in\\n\");\n\t\tfd_in = -1;\n\t\tgoto error;\n\t}\n\tif (unlikely(!STDOUT && close(fd_out)))\n\t\tfatal_return((\"Failed to close fd_out\\n\"), false);\n\tif (TMP_OUTBUF)\n\t\tclose_tmpoutbuf(control);\n\n\tif (!KEEP_FILES && !STDIN) {\n\t\tif (unlikely(unlink(control->infile)))\n\t\t\tfatal_return((\"Failed to unlink %s\\n\", control->infile), false);\n\t}\n\n\tdealloc(control->outfile);\n\treturn true;\nerror:\n\tif (! IS_FROM_FILE && STDIN && (fd_in > 0))\n\t\tclose(fd_in);\n\tif ((!STDOUT) && (fd_out > 0))\n\t\tclose(fd_out);\n\treturn false;\n}\n\nbool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; /* for environment */\n\tsize_t len;\n\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\t/* for testing single CPU */\n\tcontrol->threads = PROCESSORS;\t/* get CPUs for LZMA */\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\n\t/* The first 5 bytes of the salt is the time in seconds.\n\t * The next 2 bytes encode how many times to hash the password.\n\t * The last 9 bytes are random data, making 16 bytes of salt */\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\t/* Workaround for CPUs no longer keeping up with Moore's law!\n\t * This way we keep the magic header format unchanged. */\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\n\t/* Get Temp Dir. Try variations on canonical unix environment variable */\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; /* need a trailing slash */\n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}\n", "/*\n   Copyright (C) 2006-2016,2021 Con Kolivas\n   Copyright (C) 2011 Peter Hyman\n   Copyright (C) 1998-2003 Andrew Tridgell\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n/* lrzip compression - main program */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <signal.h>\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_RESOURCE_H\n# include <sys/resource.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n\n#include <termios.h>\n#ifdef HAVE_ENDIAN_H\n# include <endian.h>\n#elif HAVE_SYS_ENDIAN_H\n# include <sys/endian.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n# include <arpa/inet.h>\n#endif\n\n#include <dirent.h>\n#include <getopt.h>\n#include <libgen.h>\n\n#include \"rzip.h\"\n#include \"lrzip_core.h\"\n#include \"util.h\"\n#include \"stream.h\"\n\n/* needed for CRC routines */\n#include \"lzma/C/7zCrc.h\"\n\n#define MAX_PATH_LEN 4096\n\nstatic rzip_control base_control, local_control, *control;\n\nstatic void usage(bool compat)\n{\n\tprint_output(\"lrz%s version %s\\n\", compat ? \"\" : \"ip\", PACKAGE_VERSION);\n\tprint_output(\"Copyright (C) Con Kolivas 2006-2021\\n\");\n\tprint_output(\"Based on rzip \");\n\tprint_output(\"Copyright (C) Andrew Tridgell 1998-2003\\n\\n\");\n\tprint_output(\"Usage: lrz%s [options] <file...>\\n\", compat ? \"\" : \"ip\");\n\tprint_output(\"General options:\\n\");\n\tif (compat) {\n\t\tprint_output(\"\t-c, --stdout\t\toutput to STDOUT\\n\");\n\t\tprint_output(\"\t-C, --check\t\tcheck integrity of file written on decompression\\n\");\n\t} else\n\t\tprint_output(\"\t-c, -C, --check\t\tcheck integrity of file written on decompression\\n\");\n\tprint_output(\"\t-d, --decompress\tdecompress\\n\");\n\tprint_output(\"\t-e, --encrypt[=password] password protected sha512/aes128 encryption on compression\\n\");\n\tprint_output(\"\t-h, -?, --help\t\tshow help\\n\");\n\tprint_output(\"\t-H, --hash\t\tdisplay md5 hash integrity information\\n\");\n\tprint_output(\"\t-i, --info\t\tshow compressed file information\\n\");\n\tif (compat) {\n\t\tprint_output(\"\t-L, --license\t\tdisplay software version and license\\n\");\n\t\tprint_output(\"\t-P, --progress\t\tshow compression progress\\n\");\n\t} else\n\t\tprint_output(\"\t-q, --quiet\t\tdon't show compression progress\\n\");\n\tprint_output(\"\t-r, --recursive\t\toperate recursively on directories\\n\");\n\tprint_output(\"\t-t, --test\t\ttest compressed file integrity\\n\");\n\tprint_output(\"\t-v[v%s], --verbose\tIncrease verbosity\\n\", compat ? \"v\" : \"\");\n\tprint_output(\"\t-V, --version\t\tshow version\\n\");\n\tprint_output(\"Options affecting output:\\n\");\n\tif (!compat)\n\t\tprint_output(\"\t-D, --delete\t\tdelete existing files\\n\");\n\tprint_output(\"\t-f, --force\t\tforce overwrite of any existing files\\n\");\n\tif (compat)\n\t\tprint_output(\"\t-k, --keep\t\tdon't delete source files on de/compression\\n\");\n\tprint_output(\"\t-K, --keep-broken\tkeep broken or damaged output files\\n\");\n\tprint_output(\"\t-o, --outfile filename\tspecify the output file name and/or path\\n\");\n\tprint_output(\"\t-O, --outdir directory\tspecify the output directory when -o is not used\\n\");\n\tprint_output(\"\t-S, --suffix suffix\tspecify compressed suffix (default '.lrz')\\n\");\n\tprint_output(\"Options affecting compression:\\n\");\n\tprint_output(\"\t--lzma\t\t\tlzma compression (default)\\n\");\n\tprint_output(\"\t-b, --bzip2\t\tbzip2 compression\\n\");\n\tprint_output(\"\t-g, --gzip\t\tgzip compression using zlib\\n\");\n\tprint_output(\"\t-l, --lzo\t\tlzo compression (ultra fast)\\n\");\n\tprint_output(\"\t-n, --no-compress\tno backend compression - prepare for other compressor\\n\");\n\tprint_output(\"\t-z, --zpaq\t\tzpaq compression (best, extreme compression, extremely slow)\\n\");\n\tprint_output(\"Low level options:\\n\");\n\tif (compat) {\n\t\tprint_output(\"\t-1 .. -9\t\tset lzma/bzip2/gzip compression level (1-9, default 7)\\n\");\n\t\tprint_output(\"\t--fast\t\t\talias for -1\\n\");\n\t\tprint_output(\"\t--best\t\t\talias for -9\\n\");\n\t}\n\tif (!compat)\n\t\tprint_output(\"\t-L, --level level\tset lzma/bzip2/gzip compression level (1-9, default 7)\\n\");\n\tprint_output(\"\t-N, --nice-level value\tSet nice value to value (default %d)\\n\", compat ? 0 : 19);\n\tprint_output(\"\t-p, --threads value\tSet processor count to override number of threads\\n\");\n\tprint_output(\"\t-m, --maxram size\tSet maximum available ram in hundreds of MB\\n\");\n\tprint_output(\"\t\t\t\toverrides detected amount of available ram\\n\");\n\tprint_output(\"\t-T, --threshold\t\tDisable LZ4 compressibility testing\\n\");\n\tprint_output(\"\t-U, --unlimited\t\tUse unlimited window size beyond ramsize (potentially much slower)\\n\");\n\tprint_output(\"\t-w, --window size\tmaximum compression window in hundreds of MB\\n\");\n\tprint_output(\"\t\t\t\tdefault chosen by heuristic dependent on ram and chosen compression\\n\");\n\tprint_output(\"\\nLRZIP=NOCONFIG environment variable setting can be used to bypass lrzip.conf.\\n\");\n\tprint_output(\"TMP environment variable will be used for storage of temporary files when needed.\\n\");\n\tprint_output(\"TMPDIR may also be stored in lrzip.conf file.\\n\");\n\tprint_output(\"\\nIf no filenames or \\\"-\\\" is specified, stdin/out will be used.\\n\");\n\n}\n\nstatic void license(void)\n{\n\tprint_output(\"lrz version %s\\n\", PACKAGE_VERSION);\n\tprint_output(\"Copyright (C) Con Kolivas 2006-2016\\n\");\n\tprint_output(\"Based on rzip \");\n\tprint_output(\"Copyright (C) Andrew Tridgell 1998-2003\\n\\n\");\n\tprint_output(\"This is free software.  You may redistribute copies of it under the terms of\\n\");\n\tprint_output(\"the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\\n\");\n\tprint_output(\"There is NO WARRANTY, to the extent permitted by law.\\n\");\n}\n\nstatic void sighandler(int sig __UNUSED__)\n{\n\tsignal(sig, SIG_IGN);\n\tsignal(SIGTERM, SIG_IGN);\n\tsignal(SIGTTIN, SIG_IGN);\n\tsignal(SIGTTOU, SIG_IGN);\n\tprint_err(\"Interrupted\\n\");\n\tfatal_exit(&local_control);\n}\n\nstatic void show_summary(void)\n{\n\t/* OK, if verbosity set, print summary of options selected */\n\tif (!INFO) {\n\t\tif (!TEST_ONLY)\n\t\t\tprint_verbose(\"The following options are in effect for this %s.\\n\",\n\t\t\t\t      DECOMPRESS ? \"DECOMPRESSION\" : \"COMPRESSION\");\n\t\tprint_verbose(\"Threading is %s. Number of CPUs detected: %d\\n\", control->threads > 1? \"ENABLED\" : \"DISABLED\",\n\t\t\t      control->threads);\n\t\tprint_verbose(\"Detected %lld bytes ram\\n\", control->ramsize);\n\t\tprint_verbose(\"Compression level %d\\n\", control->compression_level);\n\t\tprint_verbose(\"Nice Value: %d\\n\", control->nice_val);\n\t\tprint_verbose(\"Show Progress\\n\");\n\t\tprint_maxverbose(\"Max \");\n\t\tprint_verbose(\"Verbose\\n\");\n\t\tif (FORCE_REPLACE)\n\t\t\tprint_verbose(\"Overwrite Files\\n\");\n\t\tif (!KEEP_FILES)\n\t\t\tprint_verbose(\"Remove input files on completion\\n\");\n\t\tif (control->outdir)\n\t\t\tprint_verbose(\"Output Directory Specified: %s\\n\", control->outdir);\n\t\telse if (control->outname)\n\t\t\tprint_verbose(\"Output Filename Specified: %s\\n\", control->outname);\n\t\tif (TEST_ONLY)\n\t\t\tprint_verbose(\"Test file integrity\\n\");\n\t\tif (control->tmpdir)\n\t\t\tprint_verbose(\"Temporary Directory set as: %s\\n\", control->tmpdir);\n\n\t\t/* show compression options */\n\t\tif (!DECOMPRESS && !TEST_ONLY) {\n\t\t\tprint_verbose(\"Compression mode is: \");\n\t\t\tif (LZMA_COMPRESS)\n\t\t\t\tprint_verbose(\"LZMA. LZ4 Compressibility testing %s\\n\", (LZ4_TEST? \"enabled\" : \"disabled\"));\n\t\t\telse if (LZO_COMPRESS)\n\t\t\t\tprint_verbose(\"LZO\\n\");\n\t\t\telse if (BZIP2_COMPRESS)\n\t\t\t\tprint_verbose(\"BZIP2. LZ4 Compressibility testing %s\\n\", (LZ4_TEST? \"enabled\" : \"disabled\"));\n\t\t\telse if (ZLIB_COMPRESS)\n\t\t\t\tprint_verbose(\"GZIP\\n\");\n\t\t\telse if (ZPAQ_COMPRESS)\n\t\t\t\tprint_verbose(\"ZPAQ. LZ4 Compressibility testing %s\\n\", (LZ4_TEST? \"enabled\" : \"disabled\"));\n\t\t\telse if (NO_COMPRESS)\n\t\t\t\tprint_verbose(\"RZIP pre-processing only\\n\");\n\t\t\tif (control->window)\n\t\t\t\tprint_verbose(\"Compression Window: %lld = %lldMB\\n\", control->window, control->window * 100ull);\n\t\t\t/* show heuristically computed window size */\n\t\t\tif (!control->window && !UNLIMITED) {\n\t\t\t\ti64 temp_chunk, temp_window;\n\n\t\t\t\tif (STDOUT || STDIN)\n\t\t\t\t\ttemp_chunk = control->maxram;\n\t\t\t\telse\n\t\t\t\t\ttemp_chunk = control->ramsize * 2 / 3;\n\t\t\t\ttemp_window = temp_chunk / (100 * 1024 * 1024);\n\t\t\t\tprint_verbose(\"Heuristically Computed Compression Window: %lld = %lldMB\\n\", temp_window, temp_window * 100ull);\n\t\t\t}\n\t\t\tif (UNLIMITED)\n\t\t\t\tprint_verbose(\"Using Unlimited Window size\\n\");\n\t\t}\n\t\tif (!DECOMPRESS && !TEST_ONLY)\n\t\t\tprint_maxverbose(\"Storage time in seconds %lld\\n\", control->secs);\n\t\tif (ENCRYPT)\n\t\t\tprint_maxverbose(\"Encryption hash loops %lld\\n\", control->encloops);\n\t}\n}\n\nstatic struct option long_options[] = {\n\t{\"bzip2\",\tno_argument,\t0,\t'b'}, /* 0 */\n\t{\"check\",\tno_argument,\t0,\t'c'},\n\t{\"check\",\tno_argument,\t0,\t'C'},\n\t{\"decompress\",\tno_argument,\t0,\t'd'},\n\t{\"delete\",\tno_argument,\t0,\t'D'},\n\t{\"encrypt\",\toptional_argument,\t0,\t'e'}, /* 5 */\n\t{\"force\",\tno_argument,\t0,\t'f'},\n\t{\"gzip\",\tno_argument,\t0,\t'g'},\n\t{\"help\",\tno_argument,\t0,\t'h'},\n\t{\"hash\",\tno_argument,\t0,\t'H'},\n\t{\"info\",\tno_argument,\t0,\t'i'}, /* 10 */\n\t{\"keep-broken\",\tno_argument,\t0,\t'k'},\n\t{\"keep-broken\",\tno_argument,\t0,\t'K'},\n\t{\"lzo\",\t\tno_argument,\t0,\t'l'},\n\t{\"lzma\",       \tno_argument,\t0,\t'/'},\n\t{\"level\",\toptional_argument,\t0,\t'L'}, /* 15 */\n\t{\"license\",\tno_argument,\t0,\t'L'},\n\t{\"maxram\",\trequired_argument,\t0,\t'm'},\n\t{\"no-compress\",\tno_argument,\t0,\t'n'},\n\t{\"nice-level\",\trequired_argument,\t0,\t'N'},\n\t{\"outfile\",\trequired_argument,\t0,\t'o'},\n\t{\"outdir\",\trequired_argument,\t0,\t'O'}, /* 20 */\n\t{\"threads\",\trequired_argument,\t0,\t'p'},\n\t{\"progress\",\tno_argument,\t0,\t'P'},\n\t{\"quiet\",\tno_argument,\t0,\t'q'},\n\t{\"recursive\",\tno_argument,\t0,\t'r'},\n\t{\"suffix\",\trequired_argument,\t0,\t'S'},\n\t{\"test\",\tno_argument,\t0,\t't'},  /* 25 */\n\t{\"threshold\",\trequired_argument,\t0,\t'T'},\n\t{\"unlimited\",\tno_argument,\t0,\t'U'},\n\t{\"verbose\",\tno_argument,\t0,\t'v'},\n\t{\"version\",\tno_argument,\t0,\t'V'},\n\t{\"window\",\trequired_argument,\t0,\t'w'},  /* 30 */\n\t{\"zpaq\",\tno_argument,\t0,\t'z'},\n\t{\"fast\",\tno_argument,\t0,\t'1'},\n\t{\"best\",\tno_argument,\t0,\t'9'},\n\t{0,\t0,\t0,\t0},\n};\n\nstatic void set_stdout(struct rzip_control *control)\n{\n\tcontrol->flags |= FLAG_STDOUT;\n\tcontrol->outFILE = stdout;\n\tcontrol->msgout = stderr;\n\tregister_outputfile(control, control->msgout);\n}\n\n/* Recursively enter all directories, adding all regular files to the dirlist array */\nstatic void recurse_dirlist(char *indir, char **dirlist, int *entries)\n{\n\tchar fname[MAX_PATH_LEN];\n\tstruct stat istat;\n\tstruct dirent *dp;\n\tDIR *dirp;\n\n\tdirp = opendir(indir);\n\tif (unlikely(!dirp))\n\t\tfailure(\"Unable to open directory %s\\n\", indir);\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsprintf(fname, \"%s/%s\", indir, dp->d_name);\n\t\tif (unlikely(stat(fname, &istat)))\n\t\t\tfailure(\"Unable to stat file %s\\n\", fname);\n\t\tif (S_ISDIR(istat.st_mode)) {\n\t\t\trecurse_dirlist(fname, dirlist, entries);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_ISREG(istat.st_mode)) {\n\t\t\tprint_err(\"Not regular file %s\\n\", fname);\n\t\t\tcontinue;\n\t\t}\n\t\tprint_maxverbose(\"Added file %s\\n\", fname);\n\t\t*dirlist = realloc(*dirlist, MAX_PATH_LEN * (*entries + 1));\n\t\tstrcpy(*dirlist + MAX_PATH_LEN * (*entries)++, fname);\n\t}\n\tclosedir(dirp);\n}\n\nstatic const char *loptions = \"bcCdDefghHiKlL:nN:o:O:p:PqrS:tTUm:vVw:z?\";\nstatic const char *coptions = \"bcCdefghHikKlLnN:o:O:p:PrS:tTUm:vVw:z?123456789\";\n\nint main(int argc, char *argv[])\n{\n\tbool lrzcat = false, compat = false, recurse = false;\n\tbool options_file = false, conf_file_compression_set = false; /* for environment and tracking of compression setting */\n\tstruct timeval start_time, end_time;\n\tstruct sigaction handler;\n\tdouble seconds,total_time; // for timers\n\tbool nice_set = false;\n\tint c, i;\n\tint hours,minutes;\n\textern int optind;\n\tchar *eptr, *av; /* for environment */\n\tchar *endptr = NULL;\n\n        control = &base_control;\n\n\tinitialise_control(control);\n\n\tav = basename(argv[0]);\n\tif (!strcmp(av, \"lrunzip\"))\n\t\tcontrol->flags |= FLAG_DECOMPRESS;\n\telse if (!strcmp(av, \"lrzcat\")) {\n\t\tcontrol->flags |= FLAG_DECOMPRESS | FLAG_STDOUT;\n\t\tlrzcat = true;\n\t} else if (!strcmp(av, \"lrz\")) {\n\t\t/* Called in gzip compatible command line mode */\n\t\tcontrol->flags &= ~FLAG_SHOW_PROGRESS;\n\t\tcontrol->flags &= ~FLAG_KEEP_FILES;\n\t\tcompat = true;\n\t\tlong_options[1].name = \"stdout\";\n\t\tlong_options[11].name = \"keep\";\n\t}\n\n\t/* generate crc table */\n\tCrcGenerateTable();\n\n\t/* Get Preloaded Defaults from lrzip.conf\n\t * Look in ., $HOME/.lrzip/, /etc/lrzip.\n\t * If LRZIP=NOCONFIG is set, then ignore config\n\t * If lrzip.conf sets a compression mode, options_file will be true.\n\t * This will allow for a test to permit an override of compression mode.\n\t * If there is an override, then all compression settings will be reset\n\t * and command line switches will prevail, including for --lzma.\n\t */\n\teptr = getenv(\"LRZIP\");\n\tif (eptr == NULL)\n\t\toptions_file = read_config(control);\n\telse if (!strstr(eptr,\"NOCONFIG\"))\n\t\toptions_file = read_config(control);\n\tif (options_file && (control->flags & FLAG_NOT_LZMA))\t\t/* if some compression set in lrzip.conf    */\n\t\tconf_file_compression_set = true;\t\t\t/* need this to allow command line override */\n\n\twhile ((c = getopt_long(argc, argv, compat ? coptions : loptions, long_options, &i)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\tcase 'g':\n\t\tcase 'l':\n\t\tcase 'n':\n\t\tcase 'z':\n\t\t\t/* If some compression was chosen in lrzip.conf, allow this one time\n\t\t\t * because conf_file_compression_set will be true\n\t\t\t */\n\t\t\tif ((control->flags & FLAG_NOT_LZMA) && conf_file_compression_set == false)\n\t\t\t\tfailure(\"Can only use one of -l, -b, -g, -z or -n\\n\");\n\t\t\t/* Select Compression Mode */\n\t\t\tcontrol->flags &= ~FLAG_NOT_LZMA; /* must clear all compressions first */\n\t\t\tif (c == 'b')\n\t\t\t\tcontrol->flags |= FLAG_BZIP2_COMPRESS;\n\t\t\telse if (c == 'g')\n\t\t\t\tcontrol->flags |= FLAG_ZLIB_COMPRESS;\n\t\t\telse if (c == 'l')\n\t\t\t\tcontrol->flags |= FLAG_LZO_COMPRESS;\n\t\t\telse if (c == 'n')\n\t\t\t\tcontrol->flags |= FLAG_NO_COMPRESS;\n\t\t\telse if (c == 'z')\n\t\t\t\tcontrol->flags |= FLAG_ZPAQ_COMPRESS;\n\t\t\t/* now FLAG_NOT_LZMA will evaluate as true */\n\t\t\tconf_file_compression_set = false;\n\t\t\tbreak;\n\t\tcase '/':\t\t\t\t\t\t\t/* LZMA Compress selected */\n\t\t\tcontrol->flags &= ~FLAG_NOT_LZMA;\t\t\t/* clear alternate compression flags */\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (compat) {\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\t\tset_stdout(control);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHRU */\n\t\tcase 'C':\n\t\t\tcontrol->flags |= FLAG_CHECK;\n\t\t\tcontrol->flags |= FLAG_HASH;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcontrol->flags |= FLAG_DECOMPRESS;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tcontrol->flags &= ~FLAG_KEEP_FILES;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcontrol->flags |= FLAG_ENCRYPT;\n\t\t\tcontrol->passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tcontrol->flags |= FLAG_FORCE_REPLACE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(compat);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcontrol->flags |= FLAG_HASH;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcontrol->flags |= FLAG_INFO;\n\t\t\tcontrol->flags &= ~FLAG_DECOMPRESS;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (compat) {\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHRU */\n\t\tcase 'K':\n\t\t\tcontrol->flags |= FLAG_KEEP_BROKEN;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (compat) {\n\t\t\t\tlicense();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tcontrol->compression_level = strtol(optarg, &endptr, 10);\n\t\t\tif (control->compression_level < 1 || control->compression_level > 9)\n\t\t\t\tfailure(\"Invalid compression level (must be 1-9)\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after compression level: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcontrol->ramsize = strtol(optarg, &endptr, 10) * 1024 * 1024 * 100;\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after ramsize: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tnice_set = true;\n\t\t\tcontrol->nice_val = strtol(optarg, &endptr, 10);\n\t\t\tif (control->nice_val < PRIO_MIN || control->nice_val > PRIO_MAX)\n\t\t\t\tfailure(\"Invalid nice value (must be %d...%d)\\n\", PRIO_MIN, PRIO_MAX);\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after nice level: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (control->outdir)\n\t\t\t\tfailure(\"Cannot have -o and -O together\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify an output filename when outputting to stdout\\n\");\n\t\t\tcontrol->outname = optarg;\n\t\t\tcontrol->suffix = \"\";\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (control->outname)\t/* can't mix -o and -O */\n\t\t\t\tfailure(\"Cannot have options -o and -O together\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify an output directory when outputting to stdout\\n\");\n\t\t\tcontrol->outdir = malloc(strlen(optarg) + 2);\n\t\t\tif (control->outdir == NULL)\n\t\t\t\tfatal(\"Failed to allocate for outdir\\n\");\n\t\t\tstrcpy(control->outdir,optarg);\n\t\t\tif (strcmp(optarg+strlen(optarg) - 1, \"/\")) \t/* need a trailing slash */\n\t\t\t\tstrcat(control->outdir, \"/\");\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcontrol->threads = strtol(optarg, &endptr, 10);\n\t\t\tif (control->threads < 1)\n\t\t\t\tfailure(\"Must have at least one thread\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after number of threads: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tcontrol->flags &= ~FLAG_SHOW_PROGRESS;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trecurse = true;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (control->outname)\n\t\t\t\tfailure(\"Specified output filename already, can't specify an extension.\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify a filename suffix when outputting to stdout\\n\");\n\t\t\tcontrol->suffix = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (control->outname)\n\t\t\t\tfailure(\"Cannot specify an output file name when just testing.\\n\");\n\t\t\tif (compat)\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\tif (!KEEP_FILES)\n\t\t\t\tfailure(\"Doubt that you want to delete a file when just testing.\\n\");\n\t\t\tcontrol->flags |= FLAG_TEST_ONLY;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tcontrol->flags &= ~FLAG_THRESHOLD;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tcontrol->flags |= FLAG_UNLIMITED;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t/* set verbosity flag */\n\t\t\tif (!(control->flags & FLAG_SHOW_PROGRESS))\n\t\t\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t\t\telse if (!(control->flags & FLAG_VERBOSITY) && !(control->flags & FLAG_VERBOSITY_MAX))\n\t\t\t\tcontrol->flags |= FLAG_VERBOSITY;\n\t\t\telse if ((control->flags & FLAG_VERBOSITY)) {\n\t\t\t\tcontrol->flags &= ~FLAG_VERBOSITY;\n\t\t\t\tcontrol->flags |= FLAG_VERBOSITY_MAX;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tcontrol->msgout = stdout;\n\t\t\tprint_output(\"lrzip version %s\\n\", PACKAGE_VERSION);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcontrol->window = strtol(optarg, &endptr, 10);\n\t\t\tif (control->window < 1)\n\t\t\t\tfailure(\"Window must be positive\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after window size: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tcontrol->compression_level = c - '0';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(compat);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (control->outname) {\n\t\tif (argc > 1)\n\t\t\tfailure(\"Cannot specify output filename with more than 1 file\\n\");\n\t\tif (recurse)\n\t\t\tfailure(\"Cannot specify output filename with recursive\\n\");\n\t}\n\n\tif (VERBOSE && !SHOW_PROGRESS) {\n\t\tprint_err(\"Cannot have -v and -q options. -v wins.\\n\");\n\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t}\n\n\tif (UNLIMITED && control->window) {\n\t\tprint_err(\"If -U used, cannot specify a window size with -w.\\n\");\n\t\tcontrol->window = 0;\n\t}\n\n\tif (argc < 1)\n\t\tcontrol->flags |= FLAG_STDIN;\n\n\tif (UNLIMITED && STDIN) {\n\t\tprint_err(\"Cannot have -U and stdin, unlimited mode disabled.\\n\");\n\t\tcontrol->flags &= ~FLAG_UNLIMITED;\n\t}\n\n\tsetup_overhead(control);\n\n\t/* Set the main nice value to half that of the backend threads since\n\t * the rzip stage is usually the rate limiting step */\n\tcontrol->current_priority = getpriority(PRIO_PROCESS, 0);\n\tif (nice_set) {\n\t\tif (!NO_COMPRESS) {\n\t\t\t/* If niceness can't be set. just reset process priority */\n\t\t\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val/2) == -1)) {\n\t\t\t\tprint_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",\n\t\t\t\t\tcontrol->nice_val, control->current_priority);\n\t\t\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t\t\t}\n\t\t} else {\n\t\t\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val) == -1)) {\n\t\t\t\tprint_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",\n\t\t\t\t\tcontrol->nice_val, control->current_priority);\n\t\t\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* One extra iteration for the case of no parameters means we will default to stdin/out */\n\tfor (i = 0; i <= argc; i++) {\n\t\tchar *dirlist = NULL, *infile = NULL;\n\t\tint direntries = 0, curentry = 0;\n\n\t\tif (i < argc)\n\t\t\tinfile = argv[i];\n\t\telse if (!(i == 0 && STDIN))\n\t\t\tbreak;\n\t\tif (infile) {\n\t\t\tif ((strcmp(infile, \"-\") == 0))\n\t\t\t\tcontrol->flags |= FLAG_STDIN;\n\t\t\telse {\n\t\t\t\tbool isdir = false;\n\t\t\t\tstruct stat istat;\n\n\t\t\t\tif (unlikely(stat(infile, &istat)))\n\t\t\t\t\tfailure(\"Failed to stat %s\\n\", infile);\n\t\t\t\tisdir = S_ISDIR(istat.st_mode);\n\t\t\t\tif (!recurse && (isdir || !S_ISREG(istat.st_mode))) {\n\t\t\t\t\tfailure(\"lrzip only works directly on regular FILES.\\n\"\n\t\t\t\t\t\"Use -r recursive, lrztar or pipe through tar for compressing directories.\\n\");\n\t\t\t\t}\n\t\t\t\tif (recurse && !isdir)\n\t\t\t\t\tfailure(\"%s not a directory, -r recursive needs a directory\\n\", infile);\n\t\t\t}\n\t\t}\n\n\t\tif (recurse) {\n\t\t\tif (unlikely(STDIN || STDOUT))\n\t\t\t\tfailure(\"Cannot use -r recursive with STDIO\\n\");\n\t\t\trecurse_dirlist(infile, &dirlist, &direntries);\n\t\t}\n\n\t\tif (INFO && STDIN)\n\t\t\tfailure(\"Will not get file info from STDIN\\n\");\nrecursion:\n\t\tif (recurse) {\n\t\t\tif (curentry >= direntries) {\n\t\t\t\tinfile = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfile = dirlist + MAX_PATH_LEN * curentry++;\n\t\t}\n\t\tcontrol->infile = infile;\n\n\t\t/* If no output filename is specified, and we're using\n\t\t * stdin, use stdout */\n\t\tif ((control->outname && (strcmp(control->outname, \"-\") == 0)) ||\n\t\t    (!control->outname && STDIN) || lrzcat)\n\t\t\t\tset_stdout(control);\n\n\t\tif (lrzcat) {\n\t\t\tcontrol->msgout = stderr;\n\t\t\tcontrol->outFILE = stdout;\n\t\t\tregister_outputfile(control, control->msgout);\n\t\t}\n\n\t\tif (!STDOUT) {\n\t\t\tcontrol->msgout = stdout;\n\t\t\tregister_outputfile(control, control->msgout);\n\t\t}\n\n\t\tif (STDIN)\n\t\t\tcontrol->inFILE = stdin;\n\n\t\t/* Implement signal handler only once flags are set */\n\t\tsigemptyset(&handler.sa_mask);\n\t\thandler.sa_flags = 0;\n\t\thandler.sa_handler = &sighandler;\n\t\tsigaction(SIGTERM, &handler, 0);\n\t\tsigaction(SIGINT, &handler, 0);\n\n\t\tif (!FORCE_REPLACE) {\n\t\t\tif (STDIN && isatty(fileno((FILE *)stdin))) {\n\t\t\t\tprint_err(\"Will not read stdin from a terminal. Use -f to override.\\n\");\n\t\t\t\tusage(compat);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t\tif (!TEST_ONLY && STDOUT && isatty(fileno((FILE *)stdout)) && !compat) {\n\t\t\t\tprint_err(\"Will not write stdout to a terminal. Use -f to override.\\n\");\n\t\t\t\tusage(compat);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t}\n\n\t\tif (CHECK_FILE) {\n\t\t\tif (!DECOMPRESS) {\n\t\t\t\tprint_err(\"Can only check file written on decompression.\\n\");\n\t\t\t\tcontrol->flags &= ~FLAG_CHECK;\n\t\t\t} else if (STDOUT) {\n\t\t\t\tprint_err(\"Can't check file written when writing to stdout. Checking disabled.\\n\");\n\t\t\t\tcontrol->flags &= ~FLAG_CHECK;\n\t\t\t}\n\t\t}\n\n\t\tsetup_ram(control);\n\t\tshow_summary();\n\n\t\tgettimeofday(&start_time, NULL);\n\n\t\tif (unlikely((STDIN || STDOUT) && ENCRYPT))\n\t\t\tfailure(\"Unable to work from STDIO while reading password\\n\");\n\n\t\tmemcpy(&local_control, &base_control, sizeof(rzip_control));\n\t\tif (DECOMPRESS || TEST_ONLY)\n\t\t\tdecompress_file(&local_control);\n\t\telse if (INFO)\n\t\t\tget_fileinfo(&local_control);\n\t\telse\n\t\t\tcompress_file(&local_control);\n\n\t\t/* compute total time */\n\t\tgettimeofday(&end_time, NULL);\n\t\ttotal_time = (end_time.tv_sec + (double)end_time.tv_usec / 1000000) -\n\t\t\t      (start_time.tv_sec + (double)start_time.tv_usec / 1000000);\n\t\thours = (int)total_time / 3600;\n\t\tminutes = (int)(total_time / 60) % 60;\n\t\tseconds = total_time - hours * 3600 - minutes * 60;\n\t\tif (!INFO)\n\t\t\tprint_progress(\"Total time: %02d:%02d:%05.2f\\n\", hours, minutes, seconds);\n\t\tif (recurse)\n\t\t\tgoto recursion;\n\t}\n\n\treturn 0;\n}\n"], "fixing_code": ["/*\n   Copyright (C) 2006-2016,2018,2021 Con Kolivas\n   Copyright (C) 2011 Peter Hyman\n   Copyright (C) 1998-2003 Andrew Tridgell\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#include <fcntl.h>\n#include <sys/statvfs.h>\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n#include <arpa/inet.h>\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <termios.h>\n#ifdef HAVE_ENDIAN_H\n# include <endian.h>\n#elif HAVE_SYS_ENDIAN_H\n# include <sys/endian.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n# include <arpa/inet.h>\n#endif\n#include <math.h>\n#include <utime.h>\n#include <inttypes.h>\n\n#include \"md5.h\"\n#include \"rzip.h\"\n#include \"runzip.h\"\n#include \"util.h\"\n#include \"stream.h\"\n\n#define MAGIC_LEN (24)\n\nstatic void release_hashes(rzip_control *control);\n\nstatic i64 fdout_seekto(rzip_control *control, i64 pos)\n{\n\tif (TMP_OUTBUF) {\n\t\tpos -= control->out_relofs;\n\t\tcontrol->out_ofs = pos;\n\t\tif (unlikely(pos > control->out_len || pos < 0)) {\n\t\t\tprint_err(\"Trying to seek to %lld outside tmp outbuf in fdout_seekto\\n\", pos);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn lseek(control->fd_out, pos, SEEK_SET);\n}\n\n#ifdef __APPLE__\n# include <sys/sysctl.h>\ni64 get_ram(rzip_control *control)\n{\n\tint mib[2];\n\tsize_t len;\n\ti64 *p, ramsize;\n\n\tmib[0] = CTL_HW;\n\tmib[1] = HW_MEMSIZE;\n\tsysctl(mib, 2, NULL, &len, NULL, 0);\n\tp = malloc(len);\n\tsysctl(mib, 2, p, &len, NULL, 0);\n\tramsize = *p;\n\n\treturn ramsize;\n}\n#else /* __APPLE__ */\ni64 get_ram(rzip_control *control)\n{\n\ti64 ramsize;\n\tFILE *meminfo;\n\tchar aux[256];\n\n\tramsize = (i64)sysconf(_SC_PHYS_PAGES) * PAGE_SIZE;\n\tif (ramsize > 0)\n\t\treturn ramsize;\n\n\t/* Workaround for uclibc which doesn't properly support sysconf */\n\tif(!(meminfo = fopen(\"/proc/meminfo\", \"r\")))\n\t\tfatal_return((\"fopen\\n\"), -1);\n\n\twhile(!feof(meminfo) && !fscanf(meminfo, \"MemTotal: %\"PRId64\" kB\", &ramsize)) {\n\t\tif (unlikely(fgets(aux, sizeof(aux), meminfo) == NULL)) {\n\t\t\tfclose(meminfo);\n\t\t\tfatal_return((\"Failed to fgets in get_ram\\n\"), -1);\n\t\t}\n\t}\n\tif (fclose(meminfo) == -1)\n\t\tfatal_return((\"fclose\"), -1);\n\tramsize *= 1000;\n\n\treturn ramsize;\n}\n#endif\n\ni64 nloops(i64 seconds, uchar *b1, uchar *b2)\n{\n\ti64 nloops;\n\tint nbits;\n\n\tnloops = ARBITRARY_AT_EPOCH * pow(MOORE_TIMES_PER_SECOND, seconds);\n\tif (nloops < ARBITRARY)\n\t\tnloops = ARBITRARY;\n\tfor (nbits = 0; nloops > 255; nbits ++)\n\t\tnloops = nloops >> 1;\n\t*b1 = nbits;\n\t*b2 = nloops;\n\treturn nloops << nbits;\n}\n\n\nbool write_magic(rzip_control *control)\n{\n\tchar magic[MAGIC_LEN] = { \n\t\t'L', 'R', 'Z', 'I', LRZIP_MAJOR_VERSION, LRZIP_MINOR_VERSION \n\t};\n\n\t/* File size is stored as zero for streaming STDOUT blocks when the\n\t * file size is unknown. In encrypted files, the size is left unknown\n\t * and instead the salt is stored here to preserve space. */\n\tif (ENCRYPT)\n\t\tmemcpy(&magic[6], &control->salt, 8);\n\telse if (!STDIN || !STDOUT || control->eof) {\n\t\ti64 esize = htole64(control->st_size);\n\n\t\tmemcpy(&magic[6], &esize, 8);\n\t}\n\n\t/* save LZMA compression flags */\n\tif (LZMA_COMPRESS) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tmagic[i + 16] = (char)control->lzma_properties[i];\n\t}\n\n\t/* This is a flag that the archive contains an md5 sum at the end\n\t * which can be used as an integrity check instead of crc check.\n\t * crc is still stored for compatibility with 0.5 versions.\n\t */\n\tif (!NO_MD5)\n\t\tmagic[21] = 1;\n\tif (ENCRYPT)\n\t\tmagic[22] = 1;\n\n\tif (unlikely(fdout_seekto(control, 0)))\n\t\tfatal_return((\"Failed to seek to BOF to write Magic Header\\n\"), false);\n\n\tif (unlikely(put_fdout(control, magic, MAGIC_LEN) != MAGIC_LEN))\n\t\tfatal_return((\"Failed to write magic header\\n\"), false);\n\tcontrol->magic_written = 1;\n\treturn true;\n}\n\nstatic inline i64 enc_loops(uchar b1, uchar b2)\n{\n\treturn (i64)b2 << (i64)b1;\n}\n\nstatic bool get_magic(rzip_control *control, char *magic)\n{\n\tint encrypted, md5, i;\n\ti64 expected_size;\n\tuint32_t v;\n\n\tif (unlikely(strncmp(magic, \"LRZI\", 4)))\n\t\tfailure_return((\"Not an lrzip file\\n\"), false);\n\n\tmemcpy(&control->major_version, &magic[4], 1);\n\tmemcpy(&control->minor_version, &magic[5], 1);\n\n\tprint_verbose(\"Detected lrzip version %d.%d file.\\n\", control->major_version, control->minor_version);\n\tif (control->major_version > LRZIP_MAJOR_VERSION ||\n\t    (control->major_version == LRZIP_MAJOR_VERSION && control->minor_version > LRZIP_MINOR_VERSION))\n\t\tprint_output(\"Attempting to work with file produced by newer lrzip version %d.%d file.\\n\", control->major_version, control->minor_version);\n\n\t/* Support the convoluted way we described size in versions < 0.40 */\n\tif (control->major_version == 0 && control->minor_version < 4) {\n\t\tmemcpy(&v, &magic[6], 4);\n\t\texpected_size = ntohl(v);\n\t\tmemcpy(&v, &magic[10], 4);\n\t\texpected_size |= ((i64)ntohl(v)) << 32;\n\t} else {\n\t\tmemcpy(&expected_size, &magic[6], 8);\n\t\texpected_size = le64toh(expected_size);\n\t}\n\tcontrol->st_size = expected_size;\n\tif (control->major_version == 0 && control->minor_version < 6)\n\t\tcontrol->eof = 1;\n\n\t/* restore LZMA compression flags only if stored */\n\tif ((int) magic[16]) {\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tcontrol->lzma_properties[i] = magic[i + 16];\n\t\t/* Cludge to allow us to read possibly corrupted archives */\n\t\tif (!control->lzma_properties[0])\n\t\t\tcontrol->lzma_properties[0] = 93;\n\t}\n\n\t/* Whether this archive contains md5 data at the end or not */\n\tmd5 = magic[21];\n\tif (md5 && MD5_RELIABLE) {\n\t\tif (md5 == 1)\n\t\t\tcontrol->flags |= FLAG_MD5;\n\t\telse\n\t\t\tprint_verbose(\"Unknown hash, falling back to CRC\\n\");\n\t}\n\tencrypted = magic[22];\n\tif (encrypted) {\n\t\tif (encrypted == 1)\n\t\t\tcontrol->flags |= FLAG_ENCRYPT;\n\t\telse\n\t\t\tfailure_return((\"Unknown encryption\\n\"), false);\n\t\t/* In encrypted files, the size field is used to store the salt\n\t\t * instead and the size is unknown, just like a STDOUT chunked\n\t\t * file */\n\t\tmemcpy(&control->salt, &magic[6], 8);\n\t\tcontrol->st_size = expected_size = 0;\n\t\tcontrol->encloops = enc_loops(control->salt[0], control->salt[1]);\n\t\tprint_maxverbose(\"Encryption hash loops %lld\\n\", control->encloops);\n\t} else if (ENCRYPT) {\n\t\tprint_output(\"Asked to decrypt a non-encrypted archive. Bypassing decryption.\\n\");\n\t\tcontrol->flags &= ~FLAG_ENCRYPT;\n\t}\n\treturn true;\n}\n\nbool read_magic(rzip_control *control, int fd_in, i64 *expected_size)\n{\n\tchar magic[MAGIC_LEN];\n\n\tmemset(magic, 0, sizeof(magic));\n\t/* Initially read only <v0.6x header */\n\tif (unlikely(read(fd_in, magic, 24) != 24))\n\t\tfatal_return((\"Failed to read magic header\\n\"), false);\n\n\tif (unlikely(!get_magic(control, magic)))\n\t\treturn false;\n\t*expected_size = control->st_size;\n\treturn true;\n}\n\n/* preserve ownership and permissions where possible */\nstatic bool preserve_perms(rzip_control *control, int fd_in, int fd_out)\n{\n\tstruct stat st;\n\n\tif (unlikely(fstat(fd_in, &st)))\n\t\tfatal_return((\"Failed to fstat input file\\n\"), false);\n\tif (unlikely(fchmod(fd_out, (st.st_mode & 0666))))\n\t\tprint_verbose(\"Warning, unable to set permissions on %s\\n\", control->outfile);\n\n\t/* chown fail is not fatal_return(( */\n\tif (unlikely(fchown(fd_out, st.st_uid, st.st_gid)))\n\t\tprint_verbose(\"Warning, unable to set owner on %s\\n\", control->outfile);\n\treturn true;\n}\n\nstatic bool preserve_times(rzip_control *control, int fd_in)\n{\n\tstruct utimbuf times;\n\tstruct stat st;\n\n\tif (unlikely(fstat(fd_in, &st)))\n\t\tfatal_return((\"Failed to fstat input file\\n\"), false);\n\ttimes.actime = 0;\n\ttimes.modtime = st.st_mtime;\n\tif (unlikely(utime(control->outfile, &times)))\n\t\tprint_verbose(\"Warning, unable to set time on %s\\n\", control->outfile);\n\n\treturn true;\n}\n\n/* Open a temporary outputfile to emulate stdout */\nint open_tmpoutfile(rzip_control *control)\n{\n\tint fd_out;\n\n\tif (STDOUT && !TEST_ONLY)\n\t\tprint_verbose(\"Outputting to stdout.\\n\");\n\tif (control->tmpdir) {\n\t\tcontrol->outfile = realloc(NULL, strlen(control->tmpdir) + 16);\n\t\tif (unlikely(!control->outfile))\n\t\t\tfatal_return((\"Failed to allocate outfile name\\n\"), -1);\n\t\tstrcpy(control->outfile, control->tmpdir);\n\t\tstrcat(control->outfile, \"lrzipout.XXXXXX\");\n\t}\n\n\tfd_out = mkstemp(control->outfile);\n\tif (fd_out == -1) {\n\t\tprint_progress(\"WARNING: Failed to create out tmpfile: %s, will fail if cannot perform %scompression entirely in ram\\n\",\n\t\t\t       control->outfile, DECOMPRESS ? \"de\" : \"\");\n\t} else\n\t\tregister_outfile(control, control->outfile, TEST_ONLY || STDOUT || !KEEP_BROKEN);\n\treturn fd_out;\n}\n\nstatic bool fwrite_stdout(rzip_control *control, void *buf, i64 len)\n{\n\tuchar *offset_buf = buf;\n\tssize_t ret;\n\ti64 total;\n\n\ttotal = 0;\n\twhile (len > 0) {\n\t\tssize_t wrote;\n\n\t\tif (len > one_g)\n\t\t\tret = one_g;\n\t\telse\n\t\t\tret = len;\n\t\twrote = fwrite(offset_buf, 1, ret, control->outFILE);\n\t\tif (unlikely(wrote != ret))\n\t\t\tfatal_return((\"Failed to fwrite in fwrite_stdout\\n\"), false);\n\t\tlen -= ret;\n\t\toffset_buf += ret;\n\t\ttotal += ret;\n\t}\n\tfflush(control->outFILE);\n\treturn true;\n}\n\nbool write_fdout(rzip_control *control, void *buf, i64 len)\n{\n\tuchar *offset_buf = buf;\n\tssize_t ret;\n\n\twhile (len > 0) {\n\t\tret = MIN(len, one_g);\n\t\tret = write(control->fd_out, offset_buf, (size_t)ret);\n\t\tif (unlikely(ret <= 0))\n\t\t\tfatal_return((\"Failed to write to fd_out in write_fdout\\n\"), false);\n\t\tlen -= ret;\n\t\toffset_buf += ret;\n\t}\n\treturn true;\n}\n\nbool flush_tmpoutbuf(rzip_control *control)\n{\n\tif (!TEST_ONLY) {\n\t\tprint_maxverbose(\"Dumping buffer to physical file.\\n\");\n\t\tif (STDOUT) {\n\t\t\tif (unlikely(!fwrite_stdout(control, control->tmp_outbuf, control->out_len)))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (unlikely(!write_fdout(control, control->tmp_outbuf, control->out_len)))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tcontrol->out_relofs += control->out_len;\n\tcontrol->out_ofs = control->out_len = 0;\n\treturn true;\n}\n\n/* Dump temporary outputfile to perform stdout */\nbool dump_tmpoutfile(rzip_control *control, int fd_out)\n{\n\tFILE *tmpoutfp;\n\tint tmpchar;\n\n\tif (unlikely(fd_out == -1))\n\t\tfatal_return((\"Failed: No temporary outfile created, unable to do in ram\\n\"), false);\n\t/* flush anything not yet in the temporary file */\n\tfsync(fd_out);\n\ttmpoutfp = fdopen(fd_out, \"r\");\n\tif (unlikely(tmpoutfp == NULL))\n\t\tfatal_return((\"Failed to fdopen out tmpfile\\n\"), false);\n\trewind(tmpoutfp);\n\n\tif (!TEST_ONLY) {\n\t\tprint_verbose(\"Dumping temporary file to control->outFILE.\\n\");\n\t\twhile ((tmpchar = fgetc(tmpoutfp)) != EOF)\n\t\t\tputchar(tmpchar);\n\t\tfflush(control->outFILE);\n\t\trewind(tmpoutfp);\n\t}\n\n\tif (unlikely(ftruncate(fd_out, 0)))\n\t\tfatal_return((\"Failed to ftruncate fd_out in dump_tmpoutfile\\n\"), false);\n\treturn true;\n}\n\n/* Used if we're unable to read STDIN into the temporary buffer, shunts data\n * to temporary file */\nbool write_fdin(rzip_control *control)\n{\n\tuchar *offset_buf = control->tmp_inbuf;\n\ti64 len = control->in_len;\n\tssize_t ret;\n\n\twhile (len > 0) {\n\t\tret = MIN(len, one_g);\n\t\tret = write(control->fd_in, offset_buf, (size_t)ret);\n\t\tif (unlikely(ret <= 0))\n\t\t\tfatal_return((\"Failed to write to fd_in in write_fdin\\n\"), false);\n\t\tlen -= ret;\n\t\toffset_buf += ret;\n\t}\n\treturn true;\n}\n\n/* Open a temporary inputfile to perform stdin decompression */\nint open_tmpinfile(rzip_control *control)\n{\n\tint fd_in = -1;\n\n\t/* Use temporary directory if there is one */\n\tif (control->tmpdir) {\n\t\tcontrol->infile = malloc(strlen(control->tmpdir) + 15);\n\t\tif (unlikely(!control->infile))\n\t\t\tfatal_return((\"Failed to allocate infile name\\n\"), -1);\n\t\tstrcpy(control->infile, control->tmpdir);\n\t\tstrcat(control->infile, \"lrzipin.XXXXXX\");\n\t\tfd_in = mkstemp(control->infile);\n\t}\n\n\t/* Try the current directory */\n\tif (fd_in == -1) {\n\t\tdealloc(control->infile);\n\t\tcontrol->infile = malloc(16);\n\t\tif (unlikely(!control->infile))\n\t\t\tfatal_return((\"Failed to allocate infile name\\n\"), -1);\n\t\tstrcpy(control->infile, \"lrzipin.XXXXXX\");\n\t\tfd_in = mkstemp(control->infile);\n\t}\n\n\t/* Use /tmp if nothing is writeable so far */\n\tif (fd_in == -1) {\n\t\tdealloc(control->infile);\n\t\tcontrol->infile = malloc(20);\n\t\tif (unlikely(!control->infile))\n\t\t\tfatal_return((\"Failed to allocate infile name\\n\"), -1);\n\t\tstrcpy(control->infile, \"/tmp/lrzipin.XXXXXX\");\n\t\tfd_in = mkstemp(control->infile);\n\t}\n\n\tif (fd_in == -1) {\n\t\tprint_progress(\"WARNING: Failed to create in tmpfile: %s, will fail if cannot perform %scompression entirely in ram\\n\",\n\t\t\t       control->infile, DECOMPRESS ? \"de\" : \"\");\n\t} else {\n\t\tregister_infile(control, control->infile, (DECOMPRESS || TEST_ONLY) && STDIN);\n\t\t/* Unlink temporary file immediately to minimise chance of files left\n\t\t* lying around in cases of failure_return((. */\n\t\tif (unlikely(unlink(control->infile))) {\n\t\t\tfatal(\"Failed to unlink tmpfile: %s\\n\", control->infile);\n\t\t\tclose(fd_in);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn fd_in;\n}\n\nstatic bool read_tmpinmagic(rzip_control *control)\n{\n\tchar magic[MAGIC_LEN];\n\tint i, tmpchar;\n\n\tmemset(magic, 0, sizeof(magic));\n\tfor (i = 0; i < 24; i++) {\n\t\ttmpchar = getchar();\n\t\tif (unlikely(tmpchar == EOF))\n\t\t\tfailure_return((\"Reached end of file on STDIN prematurely on v05 magic read\\n\"), false);\n\t\tmagic[i] = (char)tmpchar;\n\t}\n\treturn get_magic(control, magic);\n}\n\n/* Read data from stdin into temporary inputfile */\nbool read_tmpinfile(rzip_control *control, int fd_in)\n{\n\tFILE *tmpinfp;\n\tint tmpchar;\n\n\tif (fd_in == -1)\n\t\treturn false;\n\tif (control->flags & FLAG_SHOW_PROGRESS)\n\t\tfprintf(control->msgout, \"Copying from stdin.\\n\");\n\ttmpinfp = fdopen(fd_in, \"w+\");\n\tif (unlikely(tmpinfp == NULL))\n\t\tfatal_return((\"Failed to fdopen in tmpfile\\n\"), false);\n\n\twhile ((tmpchar = getchar()) != EOF)\n\t\tfputc(tmpchar, tmpinfp);\n\n\tfflush(tmpinfp);\n\trewind(tmpinfp);\n\treturn true;\n}\n\n/* To perform STDOUT, we allocate a proportion of ram that is then used as\n * a pseudo-temporary file */\nstatic bool open_tmpoutbuf(rzip_control *control)\n{\n\ti64 maxlen = control->maxram;\n\tvoid *buf;\n\n\twhile (42) {\n\t\tround_to_page(&maxlen);\n\t\tbuf = malloc(maxlen);\n\t\tif (buf) {\n\t\t\tprint_maxverbose(\"Malloced %\"PRId64\" for tmp_outbuf\\n\", maxlen);\n\t\t\tbreak;\n\t\t}\n\t\tmaxlen = maxlen / 3 * 2;\n\t\tif (maxlen < 100000000)\n\t\t\tfatal_return((\"Unable to even malloc 100MB for tmp_outbuf\\n\"), false);\n\t}\n\tcontrol->flags |= FLAG_TMP_OUTBUF;\n\t/* Allocate slightly more so we can cope when the buffer overflows and\n\t * fall back to a real temporary file */\n\tcontrol->out_maxlen = maxlen - control->page_size;\n\tcontrol->tmp_outbuf = buf;\n\tif (!DECOMPRESS && !TEST_ONLY)\n\t\tcontrol->out_ofs = control->out_len = MAGIC_LEN;\\\n\treturn true;\n}\n\n/* We've decided to use a temporary output file instead of trying to store\n * all the output buffer in ram so we can free up the ram and increase the\n * maximum sizes of ram we can allocate */\nvoid close_tmpoutbuf(rzip_control *control)\n{\n\tcontrol->flags &= ~FLAG_TMP_OUTBUF;\n\tdealloc(control->tmp_outbuf);\n\tif (!BITS32)\n\t\tcontrol->usable_ram = control->maxram += control->ramsize / 18;\n}\n\nstatic bool open_tmpinbuf(rzip_control *control)\n{\n\tcontrol->flags |= FLAG_TMP_INBUF;\n\tcontrol->in_maxlen = control->maxram;\n\tcontrol->tmp_inbuf = malloc(control->maxram + control->page_size);\n\tif (unlikely(!control->tmp_inbuf))\n\t\tfatal_return((\"Failed to malloc tmp_inbuf in open_tmpinbuf\\n\"), false);\n\treturn true;\n}\n\nvoid clear_tmpinbuf(rzip_control *control)\n{\n\tcontrol->in_len = control->in_ofs = 0;\n}\n\nbool clear_tmpinfile(rzip_control *control)\n{\n\tif (unlikely(lseek(control->fd_in, 0, SEEK_SET)))\n\t\tfatal_return((\"Failed to lseek on fd_in in clear_tmpinfile\\n\"), false);\n\tif (unlikely(ftruncate(control->fd_in, 0)))\n\t\tfatal_return((\"Failed to truncate fd_in in clear_tmpinfile\\n\"), false);\n\treturn true;\n}\n\n/* As per temporary output file but for input file */\nvoid close_tmpinbuf(rzip_control *control)\n{\n\tcontrol->flags &= ~FLAG_TMP_INBUF;\n\tdealloc(control->tmp_inbuf);\n\tif (!BITS32)\n\t\tcontrol->usable_ram = control->maxram += control->ramsize / 18;\n}\n\nstatic int get_pass(rzip_control *control, char *s)\n{\n\tint len;\n\n\tmemset(s, 0, PASS_LEN - SALT_LEN);\n\tif (control->passphrase)\n\t\tstrncpy(s, control->passphrase, PASS_LEN - SALT_LEN - 1);\n\telse if (unlikely(fgets(s, PASS_LEN - SALT_LEN, stdin) == NULL))\n\t\tfailure_return((\"Failed to retrieve passphrase\\n\"), -1);\n\tlen = strlen(s);\n\tif (len > 0 && ('\\r' ==  s[len - 1] || '\\n' == s[len - 1]))\n\t\ts[len - 1] = '\\0';\n\tif (len > 1 && ('\\r' ==  s[len - 2] || '\\n' == s[len - 2]))\n\t\ts[len - 2] = '\\0';\n\tlen = strlen(s);\n\tif (unlikely(0 == len))\n\t\tfailure_return((\"Empty passphrase\\n\"), -1);\n\treturn len;\n}\n\nstatic bool get_hash(rzip_control *control, int make_hash)\n{\n\tchar *passphrase, *testphrase;\n\tstruct termios termios_p;\n\tint prompt = control->passphrase == NULL;\n\n\tpassphrase = calloc(PASS_LEN, 1);\n\ttestphrase = calloc(PASS_LEN, 1);\n\tcontrol->salt_pass = calloc(PASS_LEN, 1);\n\tcontrol->hash = calloc(HASH_LEN, 1);\n\tif (unlikely(!passphrase || !testphrase || !control->salt_pass || !control->hash)) {\n\t\tfatal(\"Failed to calloc encrypt buffers in compress_file\\n\");\n\t\tdealloc(testphrase);\n\t\tdealloc(passphrase);\n\t\treturn false;\n\t}\n\tmlock(passphrase, PASS_LEN);\n\tmlock(testphrase, PASS_LEN);\n\tmlock(control->salt_pass, PASS_LEN);\n\tmlock(control->hash, HASH_LEN);\n\n\tif (control->pass_cb) {\n\t\tcontrol->pass_cb(control->pass_data, passphrase, PASS_LEN - SALT_LEN);\n\t\tif (!passphrase[0]) {\n\t\t\tfatal(\"Supplied password was null!\");\n\t\t\tmunlock(passphrase, PASS_LEN);\n\t\t\tmunlock(testphrase, PASS_LEN);\n\t\t\tdealloc(testphrase);\n\t\t\tdealloc(passphrase);\n\t\t\trelease_hashes(control);\n\t\t\treturn false;\n\t\t}\n\t\tcontrol->salt_pass_len = strlen(passphrase) + SALT_LEN;\n\t} else {\n\t\t/* Disable stdin echo to screen */\n\t\ttcgetattr(fileno(stdin), &termios_p);\n\t\ttermios_p.c_lflag &= ~ECHO;\n\t\ttcsetattr(fileno(stdin), 0, &termios_p);\nretry_pass:\n\t\tif (prompt)\n\t\t\tprint_output(\"Enter passphrase: \");\n\t\tcontrol->salt_pass_len = get_pass(control, passphrase) + SALT_LEN;\n\t\tif (prompt)\n\t\t\tprint_output(\"\\n\");\n\t\tif (make_hash) {\n\t\t\tif (prompt)\n\t\t\t\tprint_output(\"Re-enter passphrase: \");\n\t\t\tget_pass(control, testphrase);\n\t\t\tif (prompt)\n\t\t\t\tprint_output(\"\\n\");\n\t\t\tif (strcmp(passphrase, testphrase)) {\n\t\t\t\tprint_output(\"Passwords do not match. Try again.\\n\");\n\t\t\t\tgoto retry_pass;\n\t\t\t}\n\t\t}\n\t\ttermios_p.c_lflag |= ECHO;\n\t\ttcsetattr(fileno(stdin), 0, &termios_p);\n\t\tmemset(testphrase, 0, PASS_LEN);\n\t}\n\tmemcpy(control->salt_pass, control->salt, SALT_LEN);\n\tmemcpy(control->salt_pass + SALT_LEN, passphrase, PASS_LEN - SALT_LEN);\n\tlrz_stretch(control);\n\tmemset(passphrase, 0, PASS_LEN);\n\tmunlock(passphrase, PASS_LEN);\n\tmunlock(testphrase, PASS_LEN);\n\tdealloc(testphrase);\n\tdealloc(passphrase);\n\treturn true;\n}\n\nstatic void release_hashes(rzip_control *control)\n{\n\tmemset(control->salt_pass, 0, PASS_LEN);\n\tmemset(control->hash, 0, SALT_LEN);\n\tmunlock(control->salt_pass, PASS_LEN);\n\tmunlock(control->hash, HASH_LEN);\n\tdealloc(control->salt_pass);\n\tdealloc(control->hash);\n}\n\n/*\n  decompress one file from the command line\n*/\nbool decompress_file(rzip_control *control)\n{\n\tchar *tmp, *tmpoutfile, *infilecopy = NULL;\n\tint fd_in, fd_out = -1, fd_hist = -1;\n\ti64 expected_size = 0, free_space;\n\tstruct statvfs fbuf;\n\n\tif (!STDIN && !IS_FROM_FILE) {\n\t\tstruct stat fdin_stat;\n\n\t\tstat(control->infile, &fdin_stat);\n\t\tif (!S_ISREG(fdin_stat.st_mode) && (tmp = strrchr(control->infile, '.')) &&\n\t\t    strcmp(tmp,control->suffix)) {\n\t\t\t/* make sure infile has an extension. If not, add it\n\t\t\t  * because manipulations may be made to input filename, set local ptr\n\t\t\t*/\n\t\t\tinfilecopy = alloca(strlen(control->infile) + strlen(control->suffix) + 1);\n\t\t\tstrcpy(infilecopy, control->infile);\n\t\t\tstrcat(infilecopy, control->suffix);\n\t\t} else\n\t\t\tinfilecopy = strdupa(control->infile);\n\t\t/* regardless, infilecopy has the input filename */\n\t}\n\n\tif (!STDOUT && !TEST_ONLY) {\n\t\t/* if output name already set, use it */\n\t\tif (control->outname) {\n\t\t\tcontrol->outfile = strdup(control->outname);\n\t\t} else {\n\t\t\t/* default output name from infilecopy\n\t\t\t * test if outdir specified. If so, strip path from filename of\n\t\t\t * infilecopy, then remove suffix.\n\t\t\t*/\n\t\t\tif (control->outdir && (tmp = strrchr(infilecopy, '/')))\n\t\t\t\ttmpoutfile = strdupa(tmp + 1);\n\t\t\telse\n\t\t\t\ttmpoutfile = strdupa(infilecopy);\n\n\t\t\t/* remove suffix to make outfile name */\n\t\t\tif ((tmp = strrchr(tmpoutfile, '.')) && !strcmp(tmp, control->suffix))\n\t\t\t\t*tmp='\\0';\n\n\t\t\tcontrol->outfile = malloc((control->outdir == NULL? 0: strlen(control->outdir)) + strlen(tmpoutfile) + 1);\n\t\t\tif (unlikely(!control->outfile))\n\t\t\t\tfatal_return((\"Failed to allocate outfile name\\n\"), false);\n\n\t\t\tif (control->outdir) {\t/* prepend control->outdir */\n\t\t\t\tstrcpy(control->outfile, control->outdir);\n\t\t\t\tstrcat(control->outfile, tmpoutfile);\n\t\t\t} else\n\t\t\t\tstrcpy(control->outfile, tmpoutfile);\n\t\t}\n\n\t\tif (!STDOUT)\n\t\t\tprint_progress(\"Output filename is: %s\\n\", control->outfile);\n\t}\n\n\tif ( IS_FROM_FILE ) {\n\t\tfd_in = fileno(control->inFILE);\n\t}\n\telse if (STDIN) {\n\t\tfd_in = open_tmpinfile(control);\n\t\tread_tmpinmagic(control);\n\t\tif (ENCRYPT)\n\t\t\tfailure_return((\"Cannot decompress encrypted file from STDIN\\n\"), false);\n\t\texpected_size = control->st_size;\n\t\tif (unlikely(!open_tmpinbuf(control)))\n\t\t\treturn false;\n\t} else {\n\t\tfd_in = open(infilecopy, O_RDONLY);\n\t\tif (unlikely(fd_in == -1)) {\n\t\t\tfatal_return((\"Failed to open %s\\n\", infilecopy), false);\n\t\t}\n\t}\n\tcontrol->fd_in = fd_in;\n\n\tif (!(TEST_ONLY | STDOUT)) {\n\t\tfd_out = open(control->outfile, O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t\tif (FORCE_REPLACE && (-1 == fd_out) && (EEXIST == errno)) {\n\t\t\tif (unlikely(unlink(control->outfile)))\n\t\t\t\tfatal_return((\"Failed to unlink an existing file: %s\\n\", control->outfile), false);\n\t\t\tfd_out = open(control->outfile, O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t\t}\n\t\tif (unlikely(fd_out == -1)) {\n\t\t\t/* We must ensure we don't delete a file that already\n\t\t\t * exists just because we tried to create a new one */\n\t\t\tcontrol->flags |= FLAG_KEEP_BROKEN;\n\t\t\tfatal_return((\"Failed to create %s\\n\", control->outfile), false);\n\t\t}\n\t\tfd_hist = open(control->outfile, O_RDONLY);\n\t\tif (unlikely(fd_hist == -1))\n\t\t\tfatal_return((\"Failed to open history file %s\\n\", control->outfile), false);\n\n\t\t/* Can't copy permissions from STDIN */\n\t\tif (!STDIN)\n\t\t\tif (unlikely(!preserve_perms(control, fd_in, fd_out)))\n\t\t\t\treturn false;\n\t} else {\n\t\tfd_out = open_tmpoutfile(control);\n\t\tif (fd_out == -1) {\n\t\t\tfd_hist = -1;\n\t\t} else {\n\t\t\tfd_hist = open(control->outfile, O_RDONLY);\n\t\t\tif (unlikely(fd_hist == -1))\n\t\t\t\tfatal_return((\"Failed to open history file %s\\n\", control->outfile), false);\n\t\t\t/* Unlink temporary file as soon as possible */\n\t\t\tif (unlikely(unlink(control->outfile)))\n\t\t\t\tfatal_return((\"Failed to unlink tmpfile: %s\\n\", control->outfile), false);\n\t\t}\n\t}\n\n\tif (STDOUT) {\n\t\tif (unlikely(!open_tmpoutbuf(control)))\n\t\t\treturn false;\n\t}\n\n\tif (!STDIN) {\n\t\tif (unlikely(!read_magic(control, fd_in, &expected_size)))\n\t\t\treturn false;\n\t\tif (unlikely(expected_size < 0))\n\t\t\tfatal_return((\"Invalid expected size %lld\\n\", expected_size), false);\n\t}\n\n\tif (!STDOUT && !TEST_ONLY) {\n\t\t/* Check if there's enough free space on the device chosen to fit the\n\t\t* decompressed file. */\n\t\tif (unlikely(fstatvfs(fd_out, &fbuf)))\n\t\t\tfatal_return((\"Failed to fstatvfs in decompress_file\\n\"), false);\n\t\tfree_space = (i64)fbuf.f_bsize * (i64)fbuf.f_bavail;\n\t\tif (free_space < expected_size) {\n\t\t\tif (FORCE_REPLACE)\n\t\t\t\tprint_err(\"Warning, inadequate free space detected, but attempting to decompress due to -f option being used.\\n\");\n\t\t\telse\n\t\t\t\tfailure_return((\"Inadequate free space to decompress file, use -f to override.\\n\"), false);\n\t\t}\n\t}\n\tcontrol->fd_out = fd_out;\n\tcontrol->fd_hist = fd_hist;\n\n\tif (NO_MD5)\n\t\tprint_verbose(\"Not performing MD5 hash check\\n\");\n\tif (HAS_MD5)\n\t\tprint_verbose(\"MD5 \");\n\telse\n\t\tprint_verbose(\"CRC32 \");\n\tprint_verbose(\"being used for integrity testing.\\n\");\n\n\tif (ENCRYPT)\n\t\tif (unlikely(!get_hash(control, 0)))\n\t\t\treturn false;\n\n\tprint_progress(\"Decompressing...\\n\");\n\n\tif (unlikely(runzip_fd(control, fd_in, fd_out, fd_hist, expected_size) < 0))\n\t\treturn false;\n\n\tif (STDOUT && !TMP_OUTBUF) {\n\t\tif (unlikely(!dump_tmpoutfile(control, fd_out)))\n\t\t\treturn false;\n\t}\n\n\t/* if we get here, no fatal_return(( errors during decompression */\n\tprint_progress(\"\\r\");\n\tif (!(STDOUT | TEST_ONLY))\n\t\tprint_progress(\"Output filename is: %s: \", control->outfile);\n\tif (!expected_size)\n\t\texpected_size = control->st_size;\n\tif (!ENCRYPT)\n\t\tprint_progress(\"[OK] - %lld bytes                                \\n\", expected_size);\n\telse\n\t\tprint_progress(\"[OK]                                             \\n\");\n\n\tif (TMP_OUTBUF)\n\t\tclose_tmpoutbuf(control);\n\n\tif (fd_out > 0) {\n\t\tif (unlikely(close(fd_hist) || close(fd_out)))\n\t\t\tfatal_return((\"Failed to close files\\n\"), false);\n\t}\n\n\tif (unlikely(!STDIN && !STDOUT && !TEST_ONLY && !preserve_times(control, fd_in)))\n\t\treturn false;\n\n\tif ( ! IS_FROM_FILE ) {\n\t\tclose(fd_in);\n\t}\n\n\tif (!KEEP_FILES && !STDIN) {\n\t\tif (unlikely(unlink(control->infile)))\n\t\t\tfatal_return((\"Failed to unlink %s\\n\", infilecopy), false);\n\t}\n\n\tif (ENCRYPT)\n\t\trelease_hashes(control);\n\n\tdealloc(control->outfile);\n\treturn true;\n}\n\nbool get_header_info(rzip_control *control, int fd_in, uchar *ctype, i64 *c_len,\n\t\t     i64 *u_len, i64 *last_head, int chunk_bytes)\n{\n\tif (unlikely(read(fd_in, ctype, 1) != 1))\n\t\tfatal_return((\"Failed to read in get_header_info\\n\"), false);\n\n\t*c_len = *u_len = *last_head = 0;\n\tif (control->major_version == 0 && control->minor_version < 4) {\n\t\tu32 c_len32, u_len32, last_head32;\n\n\t\tif (unlikely(read(fd_in, &c_len32, 4) != 4))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tif (unlikely(read(fd_in, &u_len32, 4) != 4))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tif (unlikely(read(fd_in, &last_head32, 4) != 4))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tc_len32 = le32toh(c_len32);\n\t\tu_len32 = le32toh(u_len32);\n\t\tlast_head32 = le32toh(last_head32);\n\t\t*c_len = c_len32;\n\t\t*u_len = u_len32;\n\t\t*last_head = last_head32;\n\t} else {\n\t\tint read_len;\n\n\t\tif (control->major_version == 0 && control->minor_version == 5)\n\t\t\tread_len = 8;\n\t\telse\n\t\t\tread_len = chunk_bytes;\n\t\tif (unlikely(read(fd_in, c_len, read_len) != read_len))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tif (unlikely(read(fd_in, u_len, read_len) != read_len))\n\t\t\tfatal_return((\"Failed to read in get_header_info\"), false);\n\t\tif (unlikely(read(fd_in, last_head, read_len) != read_len))\n\t\t\tfatal_return((\"Failed to read_i64 in get_header_info\"), false);\n\t\t*c_len = le64toh(*c_len);\n\t\t*u_len = le64toh(*u_len);\n\t\t*last_head = le64toh(*last_head);\n\t}\n\treturn true;\n}\n\nstatic double percentage(i64 num, i64 den)\n{\n\tdouble d_num, d_den;\n\n\tif (den < 100) {\n\t\td_num = num * 100;\n\t\td_den = den;\n\t\tif (!d_den)\n\t\t\td_den = 1;\n\t} else {\n\t\td_num = num;\n\t\td_den = den / 100;\n\t}\n\treturn d_num / d_den;\n}\n\nbool get_fileinfo(rzip_control *control)\n{\n\ti64 u_len, c_len, second_last, last_head, utotal = 0, ctotal = 0, ofs = 25, stream_head[2];\n\ti64 expected_size, infile_size, chunk_size = 0, chunk_total = 0;\n\tint header_length, stream = 0, chunk = 0;\n\tchar *tmp, *infilecopy = NULL;\n\tchar chunk_byte = 0;\n\tlong double cratio;\n\tuchar ctype = 0;\n\tuchar save_ctype = 255;\n\tstruct stat st;\n\tint fd_in;\n\n\tif (!STDIN) {\n\t\tstruct stat fdin_stat;\n\n\t\tstat(control->infile, &fdin_stat);\n\t\tif (!S_ISREG(fdin_stat.st_mode) && (tmp = strrchr(control->infile, '.')) &&\n\t\t    strcmp(tmp,control->suffix)) {\n\t\t\tinfilecopy = alloca(strlen(control->infile) + strlen(control->suffix) + 1);\n\t\t\tstrcpy(infilecopy, control->infile);\n\t\t\tstrcat(infilecopy, control->suffix);\n\t\t} else\n\t\t\tinfilecopy = strdupa(control->infile);\n\t}\n\n\tif ( IS_FROM_FILE )\n\t\tfd_in = fileno(control->inFILE);\n\telse if (STDIN)\n\t\tfd_in = 0;\n\telse {\n\t\tfd_in = open(infilecopy, O_RDONLY);\n\t\tif (unlikely(fd_in == -1))\n\t\t\tfatal_return((\"Failed to open %s\\n\", infilecopy), false);\n\t}\n\n\t/* Get file size */\n\tif (unlikely(fstat(fd_in, &st)))\n\t\tfatal_goto((\"bad magic file descriptor!?\\n\"), error);\n\tinfile_size = st.st_size;\n\n\t/* Get decompressed size */\n\tif (unlikely(!read_magic(control, fd_in, &expected_size)))\n\t\tgoto error;\n\n\tif (ENCRYPT) {\n\t\tprint_output(\"Encrypted lrzip archive. No further information available\\n\");\n\t\tif (!STDIN && !IS_FROM_FILE)\n\t\t\tclose(fd_in);\n\t\tgoto out;\n\t}\n\n\tif (control->major_version == 0 && control->minor_version > 4) {\n\t\tif (unlikely(read(fd_in, &chunk_byte, 1) != 1))\n\t\t\tfatal_goto((\"Failed to read chunk_byte in get_fileinfo\\n\"), error);\n\t\tif (unlikely(chunk_byte < 1 || chunk_byte > 8))\n\t\t\tfatal_goto((\"Invalid chunk bytes %d\\n\", chunk_byte), error);\n\t\tif (control->major_version == 0 && control->minor_version > 5) {\n\t\t\tif (unlikely(read(fd_in, &control->eof, 1) != 1))\n\t\t\t\tfatal_goto((\"Failed to read eof in get_fileinfo\\n\"), error);\n\t\t\tif (unlikely(read(fd_in, &chunk_size, chunk_byte) != chunk_byte))\n\t\t\t\tfatal_goto((\"Failed to read chunk_size in get_fileinfo\\n\"), error);\n\t\t\tchunk_size = le64toh(chunk_size);\n\t\t\tif (unlikely(chunk_size < 0))\n\t\t\t\tfatal_goto((\"Invalid chunk size %lld\\n\", chunk_size), error);\n\t\t}\n\t}\n\n\tif (control->major_version == 0 && control->minor_version < 4) {\n\t\tofs = 24;\n\t\theader_length = 13;\n\t} else if (control->major_version == 0 && control->minor_version == 4) {\n\t\tofs = 24;\n\t\theader_length = 25;\n\t} else if (control->major_version == 0 && control->minor_version == 5) {\n\t\tofs = 25;\n\t\theader_length = 25;\n\t} else {\n\t\tofs = 26 + chunk_byte;\n\t\theader_length = 1 + (chunk_byte * 3);\n\t}\n\tif (control->major_version == 0 && control->minor_version < 6 &&\n\t\t!expected_size)\n\t\t\tgoto done;\nnext_chunk:\n\tstream = 0;\n\tstream_head[0] = 0;\n\tstream_head[1] = stream_head[0] + header_length;\n\n\tprint_verbose(\"Rzip chunk %d:\\n\", ++chunk);\n\tif (chunk_byte)\n\t\tprint_verbose(\"Chunk byte width: %d\\n\", chunk_byte);\n\tif (chunk_size) {\n\t\tchunk_total += chunk_size;\n\t\tprint_verbose(\"Chunk size: %lld\\n\", chunk_size);\n\t}\n\tif (unlikely(chunk_byte && (chunk_byte > 8 || chunk_size < 0)))\n\t\tfailure(\"Invalid chunk data\\n\");\n\twhile (stream < NUM_STREAMS) {\n\t\tint block = 1;\n\n\t\tsecond_last = 0;\n\t\tif (unlikely(lseek(fd_in, stream_head[stream] + ofs, SEEK_SET) == -1))\n\t\t\tfatal_goto((\"Failed to seek to header data in get_fileinfo\\n\"), error);\n\t\tif (unlikely(!get_header_info(control, fd_in, &ctype, &c_len, &u_len, &last_head, chunk_byte)))\n\t\t\treturn false;\n\n\t\tprint_verbose(\"Stream: %d\\n\", stream);\n\t\tprint_maxverbose(\"Offset: %lld\\n\", stream_head[stream] + ofs);\n\t\tprint_verbose(\"Block\\tComp\\tPercent\\tSize\\n\");\n\t\tdo {\n\t\t\ti64 head_off;\n\n\t\t\tif (unlikely(last_head && last_head < second_last))\n\t\t\t\tfailure_goto((\"Invalid earlier last_head position, corrupt archive.\\n\"), error);\n\t\t\tsecond_last = last_head;\n\t\t\tif (unlikely(last_head + ofs > infile_size))\n\t\t\t\tfailure_goto((\"Offset greater than archive size, likely corrupted/truncated archive.\\n\"), error);\n\t\t\tif (unlikely((head_off = lseek(fd_in, last_head + ofs, SEEK_SET)) == -1))\n\t\t\t\tfatal_goto((\"Failed to seek to header data in get_fileinfo\\n\"), error);\n\t\t\tif (unlikely(!get_header_info(control, fd_in, &ctype, &c_len, &u_len,\n\t\t\t\t\t&last_head, chunk_byte)))\n\t\t\t\treturn false;\n\t\t\tif (unlikely(last_head < 0 || c_len < 0 || u_len < 0))\n\t\t\t\tfailure_goto((\"Entry negative, likely corrupted archive.\\n\"), error);\n\t\t\tprint_verbose(\"%d\\t\", block);\n\t\t\tif (ctype == CTYPE_NONE)\n\t\t\t\tprint_verbose(\"none\");\n\t\t\telse if (ctype == CTYPE_BZIP2)\n\t\t\t\tprint_verbose(\"bzip2\");\n\t\t\telse if (ctype == CTYPE_LZO)\n\t\t\t\tprint_verbose(\"lzo\");\n\t\t\telse if (ctype == CTYPE_LZMA)\n\t\t\t\tprint_verbose(\"lzma\");\n\t\t\telse if (ctype == CTYPE_GZIP)\n\t\t\t\tprint_verbose(\"gzip\");\n\t\t\telse if (ctype == CTYPE_ZPAQ)\n\t\t\t\tprint_verbose(\"zpaq\");\n\t\t\telse\n\t\t\t\tprint_verbose(\"Dunno wtf\");\n\t\t\tif (save_ctype == 255)\n\t\t\t\tsave_ctype = ctype; /* need this for lzma when some chunks could have no compression\n\t\t\t\t\t\t     * and info will show rzip + none on info display if last chunk\n\t\t\t\t\t\t     * is not compressed. Adjust for all types in case it's used in\n\t\t\t\t\t\t     * the future */\n\t\t\tutotal += u_len;\n\t\t\tctotal += c_len;\n\t\t\tprint_verbose(\"\\t%.1f%%\\t%lld / %lld\", percentage(c_len, u_len), c_len, u_len);\n\t\t\tprint_maxverbose(\"\\tOffset: %lld\\tHead: %lld\", head_off, last_head);\n\t\t\tprint_verbose(\"\\n\");\n\t\t\tblock++;\n\t\t} while (last_head);\n\t\t++stream;\n\t}\n\n\tif (unlikely((ofs = lseek(fd_in, c_len, SEEK_CUR)) == -1))\n\t\tfatal_goto((\"Failed to lseek c_len in get_fileinfo\\n\"), error);\n\n\tif (ofs >= infile_size - (HAS_MD5 ? MD5_DIGEST_SIZE : 0))\n\t\tgoto done;\n\t/* Chunk byte entry */\n\tif (control->major_version == 0 && control->minor_version > 4) {\n\t\tif (unlikely(read(fd_in, &chunk_byte, 1) != 1))\n\t\t\tfatal_goto((\"Failed to read chunk_byte in get_fileinfo\\n\"), error);\n\t\tif (unlikely(chunk_byte < 1 || chunk_byte > 8))\n\t\t\tfatal_goto((\"Invalid chunk bytes %d\\n\", chunk_byte), error);\n\t\tofs++;\n\t\tif (control->major_version == 0 && control->minor_version > 5) {\n\t\t\tif (unlikely(read(fd_in, &control->eof, 1) != 1))\n\t\t\t\tfatal_goto((\"Failed to read eof in get_fileinfo\\n\"), error);\n\t\t\tif (unlikely(read(fd_in, &chunk_size, chunk_byte) != chunk_byte))\n\t\t\t\tfatal_goto((\"Failed to read chunk_size in get_fileinfo\\n\"), error);\n\t\t\tchunk_size = le64toh(chunk_size);\n\t\t\tif (unlikely(chunk_size < 0))\n\t\t\t\tfatal_goto((\"Invalid chunk size %lld\\n\", chunk_size), error);\n\t\t\tofs += 1 + chunk_byte;\n\t\t\theader_length = 1 + (chunk_byte * 3);\n\t\t}\n\t}\n\tgoto next_chunk;\ndone:\n\tif (unlikely(ofs > infile_size))\n\t\tfailure_goto((\"Offset greater than archive size, likely corrupted/truncated archive.\\n\"), error);\n\tprint_verbose(\"Rzip compression: %.1f%% %lld / %lld\\n\",\n\t\t\tpercentage (utotal, expected_size),\n\t\t\tutotal, expected_size);\n\tprint_verbose(\"Back end compression: %.1f%% %lld / %lld\\n\",\n\t\t\tpercentage(ctotal, utotal),\n\t\t\tctotal, utotal);\n\tprint_verbose(\"Overall compression: %.1f%% %lld / %lld\\n\",\n\t\t\tpercentage(ctotal, expected_size),\n\t\t\tctotal, expected_size);\n\n\tcratio = (long double)expected_size / (long double)infile_size;\n\n\tprint_output(\"%s:\\nlrzip version: %d.%d file\\n\", infilecopy, control->major_version, control->minor_version);\n\n\tprint_output(\"Compression: \");\n\tif (save_ctype == CTYPE_NONE)\n\t\tprint_output(\"rzip alone\\n\");\n\telse if (save_ctype == CTYPE_BZIP2)\n\t\tprint_output(\"rzip + bzip2\\n\");\n\telse if (save_ctype == CTYPE_LZO)\n\t\tprint_output(\"rzip + lzo\\n\");\n\telse if (save_ctype == CTYPE_LZMA)\n\t\tprint_output(\"rzip + lzma\\n\");\n\telse if (save_ctype == CTYPE_GZIP)\n\t\tprint_output(\"rzip + gzip\\n\");\n\telse if (save_ctype == CTYPE_ZPAQ)\n\t\tprint_output(\"rzip + zpaq\\n\");\n\telse\n\t\tprint_output(\"Dunno wtf\\n\");\n\tprint_output(\"Decompressed file size: %llu\\n\", expected_size);\n\tprint_output(\"Compressed file size: %llu\\n\", infile_size);\n\tprint_output(\"Compression ratio: %.3Lf\\n\", cratio);\n\n\tif (HAS_MD5) {\n\t\tchar md5_stored[MD5_DIGEST_SIZE];\n\t\tint i;\n\n\t\tprint_output(\"MD5 used for integrity testing\\n\");\n\t\tif (unlikely(lseek(fd_in, -MD5_DIGEST_SIZE, SEEK_END) == -1))\n\t\t\tfatal_goto((\"Failed to seek to md5 data in runzip_fd\\n\"), error);\n\t\tif (unlikely(read(fd_in, md5_stored, MD5_DIGEST_SIZE) != MD5_DIGEST_SIZE))\n\t\t\tfatal_goto((\"Failed to read md5 data in runzip_fd\\n\"), error);\n\t\tprint_output(\"MD5: \");\n\t\tfor (i = 0; i < MD5_DIGEST_SIZE; i++)\n\t\t\tprint_output(\"%02x\", md5_stored[i] & 0xFF);\n\t\tprint_output(\"\\n\");\n\t} else\n\t\tprint_output(\"CRC32 used for integrity testing\\n\");\n\tif ( !IS_FROM_FILE )\n\t\tif (unlikely(close(fd_in)))\n\t\t\tfatal_return((\"Failed to close fd_in in get_fileinfo\\n\"), false);\n\nout:\n\tdealloc(control->outfile);\n\treturn true;\nerror:\n\tif (!STDIN && ! IS_FROM_FILE) close(fd_in);\n\treturn false;\n}\n\n/*\n  compress one file from the command line\n*/\nbool compress_file(rzip_control *control)\n{\n\tconst char *tmp, *tmpinfile; \t/* we're just using this as a proxy for control->infile.\n\t\t\t\t\t * Spares a compiler warning\n\t\t\t\t\t */\n\tint fd_in = -1, fd_out = -1;\n\tchar header[MAGIC_LEN];\n\n\tif (MD5_RELIABLE)\n\t\tcontrol->flags |= FLAG_MD5;\n\tif (ENCRYPT)\n\t\tif (unlikely(!get_hash(control, 1)))\n\t\t\treturn false;\n\tmemset(header, 0, sizeof(header));\n\n\tif ( IS_FROM_FILE )\n\t\tfd_in = fileno(control->inFILE);\n\telse if (!STDIN) {\n\t\t /* is extension at end of infile? */\n\t\tif ((tmp = strrchr(control->infile, '.')) && !strcmp(tmp, control->suffix)) {\n\t\t\tprint_err(\"%s: already has %s suffix. Skipping...\\n\", control->infile, control->suffix);\n\t\t\treturn false;\n\t\t}\n\n        fd_in = open(control->infile, O_RDONLY);\n\t\tif (unlikely(fd_in == -1))\n\t\t\tfatal_return((\"Failed to open %s\\n\", control->infile), false);\n\t} \n\telse\n\t\tfd_in = 0;\n\n\tif (!STDOUT) {\n\t\tif (control->outname) {\n\t\t\t\t/* check if outname has control->suffix */\n\t\t\t\tif (*(control->suffix) == '\\0') /* suffix is empty string */\n\t\t\t\t\tcontrol->outfile = strdup(control->outname);\n\t\t\t\telse if ((tmp=strrchr(control->outname, '.')) && strcmp(tmp, control->suffix)) {\n\t\t\t\t\tcontrol->outfile = malloc(strlen(control->outname) + strlen(control->suffix) + 1);\n\t\t\t\t\tif (unlikely(!control->outfile))\n\t\t\t\t\t\tfatal_goto((\"Failed to allocate outfile name\\n\"), error);\n\t\t\t\t\tstrcpy(control->outfile, control->outname);\n\t\t\t\t\tstrcat(control->outfile, control->suffix);\n\t\t\t\t\tprint_output(\"Suffix added to %s.\\nFull pathname is: %s\\n\", control->outname, control->outfile);\n\t\t\t\t} else\t/* no, already has suffix */\n\t\t\t\t\tcontrol->outfile = strdup(control->outname);\n\t\t} else {\n\t\t\t/* default output name from control->infile\n\t\t\t * test if outdir specified. If so, strip path from filename of\n\t\t\t * control->infile\n\t\t\t*/\n\t\t\tif (control->outdir && (tmp = strrchr(control->infile, '/')))\n\t\t\t\ttmpinfile = tmp + 1;\n\t\t\telse\n\t\t\t\ttmpinfile = control->infile;\n\n\t\t\tcontrol->outfile = malloc((control->outdir == NULL? 0: strlen(control->outdir)) + strlen(tmpinfile) + strlen(control->suffix) + 1);\n\t\t\tif (unlikely(!control->outfile))\n\t\t\t\tfatal_goto((\"Failed to allocate outfile name\\n\"), error);\n\n\t\t\tif (control->outdir) {\t/* prepend control->outdir */\n\t\t\t\tstrcpy(control->outfile, control->outdir);\n\t\t\t\tstrcat(control->outfile, tmpinfile);\n\t\t\t} else\n\t\t\t\tstrcpy(control->outfile, tmpinfile);\n\t\t\tstrcat(control->outfile, control->suffix);\n\t\t\tprint_progress(\"Output filename is: %s\\n\", control->outfile);\n\t\t}\n\n\t\tfd_out = open(control->outfile, O_RDWR | O_CREAT | O_EXCL, 0666);\n\t\tif (FORCE_REPLACE && (-1 == fd_out) && (EEXIST == errno)) {\n\t\t\tif (unlikely(unlink(control->outfile)))\n\t\t\t\tfatal_goto((\"Failed to unlink an existing file: %s\\n\", control->outfile), error);\n\t\t\tfd_out = open(control->outfile, O_RDWR | O_CREAT | O_EXCL, 0666);\n\t\t}\n\t\tif (unlikely(fd_out == -1)) {\n\t\t\t/* We must ensure we don't delete a file that already\n\t\t\t * exists just because we tried to create a new one */\n\t\t\tcontrol->flags |= FLAG_KEEP_BROKEN;\n\t\t\tfatal_goto((\"Failed to create %s\\n\", control->outfile), error);\n\t\t}\n\t\tcontrol->fd_out = fd_out;\n\t\tif (!STDIN) {\n\t\t\tif (unlikely(!preserve_perms(control, fd_in, fd_out)))\n\t\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tif (unlikely(!open_tmpoutbuf(control)))\n\t\t\tgoto error;\n\t}\n\n\t/* Write zeroes to header at beginning of file */\n\tif (unlikely(!STDOUT && write(fd_out, header, sizeof(header)) != sizeof(header)))\n\t\tfatal_goto((\"Cannot write file header\\n\"), error);\n\n\trzip_fd(control, fd_in, fd_out);\n\n\t/* Wwrite magic at end b/c lzma does not tell us properties until it is done */\n\tif (!STDOUT) {\n\t\tif (unlikely(!write_magic(control)))\n\t\t\tgoto error;\n\t}\n\n\tif (ENCRYPT)\n\t\trelease_hashes(control);\n\n\tif (unlikely(!STDIN && !STDOUT && !preserve_times(control, fd_in))) {\n\t\tfatal(\"Failed to preserve times on output file\\n\");\n\t\tgoto error;\n\t}\n\n\tif (unlikely(close(fd_in))) {\n\t\tfatal(\"Failed to close fd_in\\n\");\n\t\tfd_in = -1;\n\t\tgoto error;\n\t}\n\tif (unlikely(!STDOUT && close(fd_out)))\n\t\tfatal_return((\"Failed to close fd_out\\n\"), false);\n\tif (TMP_OUTBUF)\n\t\tclose_tmpoutbuf(control);\n\n\tif (!KEEP_FILES && !STDIN) {\n\t\tif (unlikely(unlink(control->infile)))\n\t\t\tfatal_return((\"Failed to unlink %s\\n\", control->infile), false);\n\t}\n\n\tdealloc(control->outfile);\n\treturn true;\nerror:\n\tif (! IS_FROM_FILE && STDIN && (fd_in > 0))\n\t\tclose(fd_in);\n\tif ((!STDOUT) && (fd_out > 0))\n\t\tclose(fd_out);\n\treturn false;\n}\n\nbool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; /* for environment */\n\tsize_t len;\n\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = strdup(\".lrz\");\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\t/* for testing single CPU */\n\tcontrol->threads = PROCESSORS;\t/* get CPUs for LZMA */\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\n\t/* The first 5 bytes of the salt is the time in seconds.\n\t * The next 2 bytes encode how many times to hash the password.\n\t * The last 9 bytes are random data, making 16 bytes of salt */\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\t/* Workaround for CPUs no longer keeping up with Moore's law!\n\t * This way we keep the magic header format unchanged. */\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\n\t/* Get Temp Dir. Try variations on canonical unix environment variable */\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; /* need a trailing slash */\n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}\n", "/*\n   Copyright (C) 2006-2016,2021 Con Kolivas\n   Copyright (C) 2011 Peter Hyman\n   Copyright (C) 1998-2003 Andrew Tridgell\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n/* lrzip compression - main program */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <signal.h>\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_RESOURCE_H\n# include <sys/resource.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n\n#include <termios.h>\n#ifdef HAVE_ENDIAN_H\n# include <endian.h>\n#elif HAVE_SYS_ENDIAN_H\n# include <sys/endian.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n# include <arpa/inet.h>\n#endif\n\n#include <dirent.h>\n#include <getopt.h>\n#include <libgen.h>\n\n#include \"rzip.h\"\n#include \"lrzip_core.h\"\n#include \"util.h\"\n#include \"stream.h\"\n\n/* needed for CRC routines */\n#include \"lzma/C/7zCrc.h\"\n\n#define MAX_PATH_LEN 4096\n\nstatic rzip_control base_control, local_control, *control;\n\nstatic void usage(bool compat)\n{\n\tprint_output(\"lrz%s version %s\\n\", compat ? \"\" : \"ip\", PACKAGE_VERSION);\n\tprint_output(\"Copyright (C) Con Kolivas 2006-2021\\n\");\n\tprint_output(\"Based on rzip \");\n\tprint_output(\"Copyright (C) Andrew Tridgell 1998-2003\\n\\n\");\n\tprint_output(\"Usage: lrz%s [options] <file...>\\n\", compat ? \"\" : \"ip\");\n\tprint_output(\"General options:\\n\");\n\tif (compat) {\n\t\tprint_output(\"\t-c, --stdout\t\toutput to STDOUT\\n\");\n\t\tprint_output(\"\t-C, --check\t\tcheck integrity of file written on decompression\\n\");\n\t} else\n\t\tprint_output(\"\t-c, -C, --check\t\tcheck integrity of file written on decompression\\n\");\n\tprint_output(\"\t-d, --decompress\tdecompress\\n\");\n\tprint_output(\"\t-e, --encrypt[=password] password protected sha512/aes128 encryption on compression\\n\");\n\tprint_output(\"\t-h, -?, --help\t\tshow help\\n\");\n\tprint_output(\"\t-H, --hash\t\tdisplay md5 hash integrity information\\n\");\n\tprint_output(\"\t-i, --info\t\tshow compressed file information\\n\");\n\tif (compat) {\n\t\tprint_output(\"\t-L, --license\t\tdisplay software version and license\\n\");\n\t\tprint_output(\"\t-P, --progress\t\tshow compression progress\\n\");\n\t} else\n\t\tprint_output(\"\t-q, --quiet\t\tdon't show compression progress\\n\");\n\tprint_output(\"\t-r, --recursive\t\toperate recursively on directories\\n\");\n\tprint_output(\"\t-t, --test\t\ttest compressed file integrity\\n\");\n\tprint_output(\"\t-v[v%s], --verbose\tIncrease verbosity\\n\", compat ? \"v\" : \"\");\n\tprint_output(\"\t-V, --version\t\tshow version\\n\");\n\tprint_output(\"Options affecting output:\\n\");\n\tif (!compat)\n\t\tprint_output(\"\t-D, --delete\t\tdelete existing files\\n\");\n\tprint_output(\"\t-f, --force\t\tforce overwrite of any existing files\\n\");\n\tif (compat)\n\t\tprint_output(\"\t-k, --keep\t\tdon't delete source files on de/compression\\n\");\n\tprint_output(\"\t-K, --keep-broken\tkeep broken or damaged output files\\n\");\n\tprint_output(\"\t-o, --outfile filename\tspecify the output file name and/or path\\n\");\n\tprint_output(\"\t-O, --outdir directory\tspecify the output directory when -o is not used\\n\");\n\tprint_output(\"\t-S, --suffix suffix\tspecify compressed suffix (default '.lrz')\\n\");\n\tprint_output(\"Options affecting compression:\\n\");\n\tprint_output(\"\t--lzma\t\t\tlzma compression (default)\\n\");\n\tprint_output(\"\t-b, --bzip2\t\tbzip2 compression\\n\");\n\tprint_output(\"\t-g, --gzip\t\tgzip compression using zlib\\n\");\n\tprint_output(\"\t-l, --lzo\t\tlzo compression (ultra fast)\\n\");\n\tprint_output(\"\t-n, --no-compress\tno backend compression - prepare for other compressor\\n\");\n\tprint_output(\"\t-z, --zpaq\t\tzpaq compression (best, extreme compression, extremely slow)\\n\");\n\tprint_output(\"Low level options:\\n\");\n\tif (compat) {\n\t\tprint_output(\"\t-1 .. -9\t\tset lzma/bzip2/gzip compression level (1-9, default 7)\\n\");\n\t\tprint_output(\"\t--fast\t\t\talias for -1\\n\");\n\t\tprint_output(\"\t--best\t\t\talias for -9\\n\");\n\t}\n\tif (!compat)\n\t\tprint_output(\"\t-L, --level level\tset lzma/bzip2/gzip compression level (1-9, default 7)\\n\");\n\tprint_output(\"\t-N, --nice-level value\tSet nice value to value (default %d)\\n\", compat ? 0 : 19);\n\tprint_output(\"\t-p, --threads value\tSet processor count to override number of threads\\n\");\n\tprint_output(\"\t-m, --maxram size\tSet maximum available ram in hundreds of MB\\n\");\n\tprint_output(\"\t\t\t\toverrides detected amount of available ram\\n\");\n\tprint_output(\"\t-T, --threshold\t\tDisable LZ4 compressibility testing\\n\");\n\tprint_output(\"\t-U, --unlimited\t\tUse unlimited window size beyond ramsize (potentially much slower)\\n\");\n\tprint_output(\"\t-w, --window size\tmaximum compression window in hundreds of MB\\n\");\n\tprint_output(\"\t\t\t\tdefault chosen by heuristic dependent on ram and chosen compression\\n\");\n\tprint_output(\"\\nLRZIP=NOCONFIG environment variable setting can be used to bypass lrzip.conf.\\n\");\n\tprint_output(\"TMP environment variable will be used for storage of temporary files when needed.\\n\");\n\tprint_output(\"TMPDIR may also be stored in lrzip.conf file.\\n\");\n\tprint_output(\"\\nIf no filenames or \\\"-\\\" is specified, stdin/out will be used.\\n\");\n\n}\n\nstatic void license(void)\n{\n\tprint_output(\"lrz version %s\\n\", PACKAGE_VERSION);\n\tprint_output(\"Copyright (C) Con Kolivas 2006-2016\\n\");\n\tprint_output(\"Based on rzip \");\n\tprint_output(\"Copyright (C) Andrew Tridgell 1998-2003\\n\\n\");\n\tprint_output(\"This is free software.  You may redistribute copies of it under the terms of\\n\");\n\tprint_output(\"the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\\n\");\n\tprint_output(\"There is NO WARRANTY, to the extent permitted by law.\\n\");\n}\n\nstatic void sighandler(int sig __UNUSED__)\n{\n\tsignal(sig, SIG_IGN);\n\tsignal(SIGTERM, SIG_IGN);\n\tsignal(SIGTTIN, SIG_IGN);\n\tsignal(SIGTTOU, SIG_IGN);\n\tprint_err(\"Interrupted\\n\");\n\tfatal_exit(&local_control);\n}\n\nstatic void show_summary(void)\n{\n\t/* OK, if verbosity set, print summary of options selected */\n\tif (!INFO) {\n\t\tif (!TEST_ONLY)\n\t\t\tprint_verbose(\"The following options are in effect for this %s.\\n\",\n\t\t\t\t      DECOMPRESS ? \"DECOMPRESSION\" : \"COMPRESSION\");\n\t\tprint_verbose(\"Threading is %s. Number of CPUs detected: %d\\n\", control->threads > 1? \"ENABLED\" : \"DISABLED\",\n\t\t\t      control->threads);\n\t\tprint_verbose(\"Detected %lld bytes ram\\n\", control->ramsize);\n\t\tprint_verbose(\"Compression level %d\\n\", control->compression_level);\n\t\tprint_verbose(\"Nice Value: %d\\n\", control->nice_val);\n\t\tprint_verbose(\"Show Progress\\n\");\n\t\tprint_maxverbose(\"Max \");\n\t\tprint_verbose(\"Verbose\\n\");\n\t\tif (FORCE_REPLACE)\n\t\t\tprint_verbose(\"Overwrite Files\\n\");\n\t\tif (!KEEP_FILES)\n\t\t\tprint_verbose(\"Remove input files on completion\\n\");\n\t\tif (control->outdir)\n\t\t\tprint_verbose(\"Output Directory Specified: %s\\n\", control->outdir);\n\t\telse if (control->outname)\n\t\t\tprint_verbose(\"Output Filename Specified: %s\\n\", control->outname);\n\t\tif (TEST_ONLY)\n\t\t\tprint_verbose(\"Test file integrity\\n\");\n\t\tif (control->tmpdir)\n\t\t\tprint_verbose(\"Temporary Directory set as: %s\\n\", control->tmpdir);\n\n\t\t/* show compression options */\n\t\tif (!DECOMPRESS && !TEST_ONLY) {\n\t\t\tprint_verbose(\"Compression mode is: \");\n\t\t\tif (LZMA_COMPRESS)\n\t\t\t\tprint_verbose(\"LZMA. LZ4 Compressibility testing %s\\n\", (LZ4_TEST? \"enabled\" : \"disabled\"));\n\t\t\telse if (LZO_COMPRESS)\n\t\t\t\tprint_verbose(\"LZO\\n\");\n\t\t\telse if (BZIP2_COMPRESS)\n\t\t\t\tprint_verbose(\"BZIP2. LZ4 Compressibility testing %s\\n\", (LZ4_TEST? \"enabled\" : \"disabled\"));\n\t\t\telse if (ZLIB_COMPRESS)\n\t\t\t\tprint_verbose(\"GZIP\\n\");\n\t\t\telse if (ZPAQ_COMPRESS)\n\t\t\t\tprint_verbose(\"ZPAQ. LZ4 Compressibility testing %s\\n\", (LZ4_TEST? \"enabled\" : \"disabled\"));\n\t\t\telse if (NO_COMPRESS)\n\t\t\t\tprint_verbose(\"RZIP pre-processing only\\n\");\n\t\t\tif (control->window)\n\t\t\t\tprint_verbose(\"Compression Window: %lld = %lldMB\\n\", control->window, control->window * 100ull);\n\t\t\t/* show heuristically computed window size */\n\t\t\tif (!control->window && !UNLIMITED) {\n\t\t\t\ti64 temp_chunk, temp_window;\n\n\t\t\t\tif (STDOUT || STDIN)\n\t\t\t\t\ttemp_chunk = control->maxram;\n\t\t\t\telse\n\t\t\t\t\ttemp_chunk = control->ramsize * 2 / 3;\n\t\t\t\ttemp_window = temp_chunk / (100 * 1024 * 1024);\n\t\t\t\tprint_verbose(\"Heuristically Computed Compression Window: %lld = %lldMB\\n\", temp_window, temp_window * 100ull);\n\t\t\t}\n\t\t\tif (UNLIMITED)\n\t\t\t\tprint_verbose(\"Using Unlimited Window size\\n\");\n\t\t}\n\t\tif (!DECOMPRESS && !TEST_ONLY)\n\t\t\tprint_maxverbose(\"Storage time in seconds %lld\\n\", control->secs);\n\t\tif (ENCRYPT)\n\t\t\tprint_maxverbose(\"Encryption hash loops %lld\\n\", control->encloops);\n\t}\n}\n\nstatic struct option long_options[] = {\n\t{\"bzip2\",\tno_argument,\t0,\t'b'}, /* 0 */\n\t{\"check\",\tno_argument,\t0,\t'c'},\n\t{\"check\",\tno_argument,\t0,\t'C'},\n\t{\"decompress\",\tno_argument,\t0,\t'd'},\n\t{\"delete\",\tno_argument,\t0,\t'D'},\n\t{\"encrypt\",\toptional_argument,\t0,\t'e'}, /* 5 */\n\t{\"force\",\tno_argument,\t0,\t'f'},\n\t{\"gzip\",\tno_argument,\t0,\t'g'},\n\t{\"help\",\tno_argument,\t0,\t'h'},\n\t{\"hash\",\tno_argument,\t0,\t'H'},\n\t{\"info\",\tno_argument,\t0,\t'i'}, /* 10 */\n\t{\"keep-broken\",\tno_argument,\t0,\t'k'},\n\t{\"keep-broken\",\tno_argument,\t0,\t'K'},\n\t{\"lzo\",\t\tno_argument,\t0,\t'l'},\n\t{\"lzma\",       \tno_argument,\t0,\t'/'},\n\t{\"level\",\toptional_argument,\t0,\t'L'}, /* 15 */\n\t{\"license\",\tno_argument,\t0,\t'L'},\n\t{\"maxram\",\trequired_argument,\t0,\t'm'},\n\t{\"no-compress\",\tno_argument,\t0,\t'n'},\n\t{\"nice-level\",\trequired_argument,\t0,\t'N'},\n\t{\"outfile\",\trequired_argument,\t0,\t'o'},\n\t{\"outdir\",\trequired_argument,\t0,\t'O'}, /* 20 */\n\t{\"threads\",\trequired_argument,\t0,\t'p'},\n\t{\"progress\",\tno_argument,\t0,\t'P'},\n\t{\"quiet\",\tno_argument,\t0,\t'q'},\n\t{\"recursive\",\tno_argument,\t0,\t'r'},\n\t{\"suffix\",\trequired_argument,\t0,\t'S'},\n\t{\"test\",\tno_argument,\t0,\t't'},  /* 25 */\n\t{\"threshold\",\trequired_argument,\t0,\t'T'},\n\t{\"unlimited\",\tno_argument,\t0,\t'U'},\n\t{\"verbose\",\tno_argument,\t0,\t'v'},\n\t{\"version\",\tno_argument,\t0,\t'V'},\n\t{\"window\",\trequired_argument,\t0,\t'w'},  /* 30 */\n\t{\"zpaq\",\tno_argument,\t0,\t'z'},\n\t{\"fast\",\tno_argument,\t0,\t'1'},\n\t{\"best\",\tno_argument,\t0,\t'9'},\n\t{0,\t0,\t0,\t0},\n};\n\nstatic void set_stdout(struct rzip_control *control)\n{\n\tcontrol->flags |= FLAG_STDOUT;\n\tcontrol->outFILE = stdout;\n\tcontrol->msgout = stderr;\n\tregister_outputfile(control, control->msgout);\n}\n\n/* Recursively enter all directories, adding all regular files to the dirlist array */\nstatic void recurse_dirlist(char *indir, char **dirlist, int *entries)\n{\n\tchar fname[MAX_PATH_LEN];\n\tstruct stat istat;\n\tstruct dirent *dp;\n\tDIR *dirp;\n\n\tdirp = opendir(indir);\n\tif (unlikely(!dirp))\n\t\tfailure(\"Unable to open directory %s\\n\", indir);\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tsprintf(fname, \"%s/%s\", indir, dp->d_name);\n\t\tif (unlikely(stat(fname, &istat)))\n\t\t\tfailure(\"Unable to stat file %s\\n\", fname);\n\t\tif (S_ISDIR(istat.st_mode)) {\n\t\t\trecurse_dirlist(fname, dirlist, entries);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_ISREG(istat.st_mode)) {\n\t\t\tprint_err(\"Not regular file %s\\n\", fname);\n\t\t\tcontinue;\n\t\t}\n\t\tprint_maxverbose(\"Added file %s\\n\", fname);\n\t\t*dirlist = realloc(*dirlist, MAX_PATH_LEN * (*entries + 1));\n\t\tstrcpy(*dirlist + MAX_PATH_LEN * (*entries)++, fname);\n\t}\n\tclosedir(dirp);\n}\n\nstatic const char *loptions = \"bcCdDefghHiKlL:nN:o:O:p:PqrS:tTUm:vVw:z?\";\nstatic const char *coptions = \"bcCdefghHikKlLnN:o:O:p:PrS:tTUm:vVw:z?123456789\";\n\nint main(int argc, char *argv[])\n{\n\tbool lrzcat = false, compat = false, recurse = false;\n\tbool options_file = false, conf_file_compression_set = false; /* for environment and tracking of compression setting */\n\tstruct timeval start_time, end_time;\n\tstruct sigaction handler;\n\tdouble seconds,total_time; // for timers\n\tbool nice_set = false;\n\tint c, i;\n\tint hours,minutes;\n\textern int optind;\n\tchar *eptr, *av; /* for environment */\n\tchar *endptr = NULL;\n\n        control = &base_control;\n\n\tinitialise_control(control);\n\n\tav = basename(argv[0]);\n\tif (!strcmp(av, \"lrunzip\"))\n\t\tcontrol->flags |= FLAG_DECOMPRESS;\n\telse if (!strcmp(av, \"lrzcat\")) {\n\t\tcontrol->flags |= FLAG_DECOMPRESS | FLAG_STDOUT;\n\t\tlrzcat = true;\n\t} else if (!strcmp(av, \"lrz\")) {\n\t\t/* Called in gzip compatible command line mode */\n\t\tcontrol->flags &= ~FLAG_SHOW_PROGRESS;\n\t\tcontrol->flags &= ~FLAG_KEEP_FILES;\n\t\tcompat = true;\n\t\tlong_options[1].name = \"stdout\";\n\t\tlong_options[11].name = \"keep\";\n\t}\n\n\t/* generate crc table */\n\tCrcGenerateTable();\n\n\t/* Get Preloaded Defaults from lrzip.conf\n\t * Look in ., $HOME/.lrzip/, /etc/lrzip.\n\t * If LRZIP=NOCONFIG is set, then ignore config\n\t * If lrzip.conf sets a compression mode, options_file will be true.\n\t * This will allow for a test to permit an override of compression mode.\n\t * If there is an override, then all compression settings will be reset\n\t * and command line switches will prevail, including for --lzma.\n\t */\n\teptr = getenv(\"LRZIP\");\n\tif (eptr == NULL)\n\t\toptions_file = read_config(control);\n\telse if (!strstr(eptr,\"NOCONFIG\"))\n\t\toptions_file = read_config(control);\n\tif (options_file && (control->flags & FLAG_NOT_LZMA))\t\t/* if some compression set in lrzip.conf    */\n\t\tconf_file_compression_set = true;\t\t\t/* need this to allow command line override */\n\n\twhile ((c = getopt_long(argc, argv, compat ? coptions : loptions, long_options, &i)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\tcase 'g':\n\t\tcase 'l':\n\t\tcase 'n':\n\t\tcase 'z':\n\t\t\t/* If some compression was chosen in lrzip.conf, allow this one time\n\t\t\t * because conf_file_compression_set will be true\n\t\t\t */\n\t\t\tif ((control->flags & FLAG_NOT_LZMA) && conf_file_compression_set == false)\n\t\t\t\tfailure(\"Can only use one of -l, -b, -g, -z or -n\\n\");\n\t\t\t/* Select Compression Mode */\n\t\t\tcontrol->flags &= ~FLAG_NOT_LZMA; /* must clear all compressions first */\n\t\t\tif (c == 'b')\n\t\t\t\tcontrol->flags |= FLAG_BZIP2_COMPRESS;\n\t\t\telse if (c == 'g')\n\t\t\t\tcontrol->flags |= FLAG_ZLIB_COMPRESS;\n\t\t\telse if (c == 'l')\n\t\t\t\tcontrol->flags |= FLAG_LZO_COMPRESS;\n\t\t\telse if (c == 'n')\n\t\t\t\tcontrol->flags |= FLAG_NO_COMPRESS;\n\t\t\telse if (c == 'z')\n\t\t\t\tcontrol->flags |= FLAG_ZPAQ_COMPRESS;\n\t\t\t/* now FLAG_NOT_LZMA will evaluate as true */\n\t\t\tconf_file_compression_set = false;\n\t\t\tbreak;\n\t\tcase '/':\t\t\t\t\t\t\t/* LZMA Compress selected */\n\t\t\tcontrol->flags &= ~FLAG_NOT_LZMA;\t\t\t/* clear alternate compression flags */\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (compat) {\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\t\tset_stdout(control);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHRU */\n\t\tcase 'C':\n\t\t\tcontrol->flags |= FLAG_CHECK;\n\t\t\tcontrol->flags |= FLAG_HASH;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcontrol->flags |= FLAG_DECOMPRESS;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tcontrol->flags &= ~FLAG_KEEP_FILES;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcontrol->flags |= FLAG_ENCRYPT;\n\t\t\tcontrol->passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tcontrol->flags |= FLAG_FORCE_REPLACE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(compat);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcontrol->flags |= FLAG_HASH;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcontrol->flags |= FLAG_INFO;\n\t\t\tcontrol->flags &= ~FLAG_DECOMPRESS;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (compat) {\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHRU */\n\t\tcase 'K':\n\t\t\tcontrol->flags |= FLAG_KEEP_BROKEN;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (compat) {\n\t\t\t\tlicense();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tcontrol->compression_level = strtol(optarg, &endptr, 10);\n\t\t\tif (control->compression_level < 1 || control->compression_level > 9)\n\t\t\t\tfailure(\"Invalid compression level (must be 1-9)\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after compression level: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcontrol->ramsize = strtol(optarg, &endptr, 10) * 1024 * 1024 * 100;\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after ramsize: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tnice_set = true;\n\t\t\tcontrol->nice_val = strtol(optarg, &endptr, 10);\n\t\t\tif (control->nice_val < PRIO_MIN || control->nice_val > PRIO_MAX)\n\t\t\t\tfailure(\"Invalid nice value (must be %d...%d)\\n\", PRIO_MIN, PRIO_MAX);\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after nice level: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (control->outdir)\n\t\t\t\tfailure(\"Cannot have -o and -O together\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify an output filename when outputting to stdout\\n\");\n\t\t\tcontrol->outname = optarg;\n\t\t\tdealloc(control->suffix);\n\t\t\tcontrol->suffix = strdup(\"\");\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (control->outname)\t/* can't mix -o and -O */\n\t\t\t\tfailure(\"Cannot have options -o and -O together\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify an output directory when outputting to stdout\\n\");\n\t\t\tcontrol->outdir = malloc(strlen(optarg) + 2);\n\t\t\tif (control->outdir == NULL)\n\t\t\t\tfatal(\"Failed to allocate for outdir\\n\");\n\t\t\tstrcpy(control->outdir,optarg);\n\t\t\tif (strcmp(optarg+strlen(optarg) - 1, \"/\")) \t/* need a trailing slash */\n\t\t\t\tstrcat(control->outdir, \"/\");\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcontrol->threads = strtol(optarg, &endptr, 10);\n\t\t\tif (control->threads < 1)\n\t\t\t\tfailure(\"Must have at least one thread\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after number of threads: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tcontrol->flags &= ~FLAG_SHOW_PROGRESS;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trecurse = true;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (control->outname)\n\t\t\t\tfailure(\"Specified output filename already, can't specify an extension.\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify a filename suffix when outputting to stdout\\n\");\n\t\t\tdealloc(control->suffix);\n\t\t\tcontrol->suffix = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (control->outname)\n\t\t\t\tfailure(\"Cannot specify an output file name when just testing.\\n\");\n\t\t\tif (compat)\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\tif (!KEEP_FILES)\n\t\t\t\tfailure(\"Doubt that you want to delete a file when just testing.\\n\");\n\t\t\tcontrol->flags |= FLAG_TEST_ONLY;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tcontrol->flags &= ~FLAG_THRESHOLD;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tcontrol->flags |= FLAG_UNLIMITED;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t/* set verbosity flag */\n\t\t\tif (!(control->flags & FLAG_SHOW_PROGRESS))\n\t\t\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t\t\telse if (!(control->flags & FLAG_VERBOSITY) && !(control->flags & FLAG_VERBOSITY_MAX))\n\t\t\t\tcontrol->flags |= FLAG_VERBOSITY;\n\t\t\telse if ((control->flags & FLAG_VERBOSITY)) {\n\t\t\t\tcontrol->flags &= ~FLAG_VERBOSITY;\n\t\t\t\tcontrol->flags |= FLAG_VERBOSITY_MAX;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tcontrol->msgout = stdout;\n\t\t\tprint_output(\"lrzip version %s\\n\", PACKAGE_VERSION);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcontrol->window = strtol(optarg, &endptr, 10);\n\t\t\tif (control->window < 1)\n\t\t\t\tfailure(\"Window must be positive\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after window size: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tcontrol->compression_level = c - '0';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(compat);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (control->outname) {\n\t\tif (argc > 1)\n\t\t\tfailure(\"Cannot specify output filename with more than 1 file\\n\");\n\t\tif (recurse)\n\t\t\tfailure(\"Cannot specify output filename with recursive\\n\");\n\t}\n\n\tif (VERBOSE && !SHOW_PROGRESS) {\n\t\tprint_err(\"Cannot have -v and -q options. -v wins.\\n\");\n\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t}\n\n\tif (UNLIMITED && control->window) {\n\t\tprint_err(\"If -U used, cannot specify a window size with -w.\\n\");\n\t\tcontrol->window = 0;\n\t}\n\n\tif (argc < 1)\n\t\tcontrol->flags |= FLAG_STDIN;\n\n\tif (UNLIMITED && STDIN) {\n\t\tprint_err(\"Cannot have -U and stdin, unlimited mode disabled.\\n\");\n\t\tcontrol->flags &= ~FLAG_UNLIMITED;\n\t}\n\n\tsetup_overhead(control);\n\n\t/* Set the main nice value to half that of the backend threads since\n\t * the rzip stage is usually the rate limiting step */\n\tcontrol->current_priority = getpriority(PRIO_PROCESS, 0);\n\tif (nice_set) {\n\t\tif (!NO_COMPRESS) {\n\t\t\t/* If niceness can't be set. just reset process priority */\n\t\t\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val/2) == -1)) {\n\t\t\t\tprint_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",\n\t\t\t\t\tcontrol->nice_val, control->current_priority);\n\t\t\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t\t\t}\n\t\t} else {\n\t\t\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val) == -1)) {\n\t\t\t\tprint_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",\n\t\t\t\t\tcontrol->nice_val, control->current_priority);\n\t\t\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* One extra iteration for the case of no parameters means we will default to stdin/out */\n\tfor (i = 0; i <= argc; i++) {\n\t\tchar *dirlist = NULL, *infile = NULL;\n\t\tint direntries = 0, curentry = 0;\n\n\t\tif (i < argc)\n\t\t\tinfile = argv[i];\n\t\telse if (!(i == 0 && STDIN))\n\t\t\tbreak;\n\t\tif (infile) {\n\t\t\tif ((strcmp(infile, \"-\") == 0))\n\t\t\t\tcontrol->flags |= FLAG_STDIN;\n\t\t\telse {\n\t\t\t\tbool isdir = false;\n\t\t\t\tstruct stat istat;\n\n\t\t\t\tif (unlikely(stat(infile, &istat)))\n\t\t\t\t\tfailure(\"Failed to stat %s\\n\", infile);\n\t\t\t\tisdir = S_ISDIR(istat.st_mode);\n\t\t\t\tif (!recurse && (isdir || !S_ISREG(istat.st_mode))) {\n\t\t\t\t\tfailure(\"lrzip only works directly on regular FILES.\\n\"\n\t\t\t\t\t\"Use -r recursive, lrztar or pipe through tar for compressing directories.\\n\");\n\t\t\t\t}\n\t\t\t\tif (recurse && !isdir)\n\t\t\t\t\tfailure(\"%s not a directory, -r recursive needs a directory\\n\", infile);\n\t\t\t}\n\t\t}\n\n\t\tif (recurse) {\n\t\t\tif (unlikely(STDIN || STDOUT))\n\t\t\t\tfailure(\"Cannot use -r recursive with STDIO\\n\");\n\t\t\trecurse_dirlist(infile, &dirlist, &direntries);\n\t\t}\n\n\t\tif (INFO && STDIN)\n\t\t\tfailure(\"Will not get file info from STDIN\\n\");\nrecursion:\n\t\tif (recurse) {\n\t\t\tif (curentry >= direntries) {\n\t\t\t\tinfile = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfile = dirlist + MAX_PATH_LEN * curentry++;\n\t\t}\n\t\tcontrol->infile = infile;\n\n\t\t/* If no output filename is specified, and we're using\n\t\t * stdin, use stdout */\n\t\tif ((control->outname && (strcmp(control->outname, \"-\") == 0)) ||\n\t\t    (!control->outname && STDIN) || lrzcat)\n\t\t\t\tset_stdout(control);\n\n\t\tif (lrzcat) {\n\t\t\tcontrol->msgout = stderr;\n\t\t\tcontrol->outFILE = stdout;\n\t\t\tregister_outputfile(control, control->msgout);\n\t\t}\n\n\t\tif (!STDOUT) {\n\t\t\tcontrol->msgout = stdout;\n\t\t\tregister_outputfile(control, control->msgout);\n\t\t}\n\n\t\tif (STDIN)\n\t\t\tcontrol->inFILE = stdin;\n\n\t\t/* Implement signal handler only once flags are set */\n\t\tsigemptyset(&handler.sa_mask);\n\t\thandler.sa_flags = 0;\n\t\thandler.sa_handler = &sighandler;\n\t\tsigaction(SIGTERM, &handler, 0);\n\t\tsigaction(SIGINT, &handler, 0);\n\n\t\tif (!FORCE_REPLACE) {\n\t\t\tif (STDIN && isatty(fileno((FILE *)stdin))) {\n\t\t\t\tprint_err(\"Will not read stdin from a terminal. Use -f to override.\\n\");\n\t\t\t\tusage(compat);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t\tif (!TEST_ONLY && STDOUT && isatty(fileno((FILE *)stdout)) && !compat) {\n\t\t\t\tprint_err(\"Will not write stdout to a terminal. Use -f to override.\\n\");\n\t\t\t\tusage(compat);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t}\n\n\t\tif (CHECK_FILE) {\n\t\t\tif (!DECOMPRESS) {\n\t\t\t\tprint_err(\"Can only check file written on decompression.\\n\");\n\t\t\t\tcontrol->flags &= ~FLAG_CHECK;\n\t\t\t} else if (STDOUT) {\n\t\t\t\tprint_err(\"Can't check file written when writing to stdout. Checking disabled.\\n\");\n\t\t\t\tcontrol->flags &= ~FLAG_CHECK;\n\t\t\t}\n\t\t}\n\n\t\tsetup_ram(control);\n\t\tshow_summary();\n\n\t\tgettimeofday(&start_time, NULL);\n\n\t\tif (unlikely((STDIN || STDOUT) && ENCRYPT))\n\t\t\tfailure(\"Unable to work from STDIO while reading password\\n\");\n\n\t\tmemcpy(&local_control, &base_control, sizeof(rzip_control));\n\t\tif (DECOMPRESS || TEST_ONLY)\n\t\t\tdecompress_file(&local_control);\n\t\telse if (INFO)\n\t\t\tget_fileinfo(&local_control);\n\t\telse\n\t\t\tcompress_file(&local_control);\n\n\t\t/* compute total time */\n\t\tgettimeofday(&end_time, NULL);\n\t\ttotal_time = (end_time.tv_sec + (double)end_time.tv_usec / 1000000) -\n\t\t\t      (start_time.tv_sec + (double)start_time.tv_usec / 1000000);\n\t\thours = (int)total_time / 3600;\n\t\tminutes = (int)(total_time / 60) % 60;\n\t\tseconds = total_time - hours * 3600 - minutes * 60;\n\t\tif (!INFO)\n\t\t\tprint_progress(\"Total time: %02d:%02d:%05.2f\\n\", hours, minutes, seconds);\n\t\tif (recurse)\n\t\t\tgoto recursion;\n\t}\n\n\treturn 0;\n}\n"], "filenames": ["lrzip.c", "main.c"], "buggy_code_start_loc": [1341, 461], "buggy_code_end_loc": [1342, 497], "fixing_code_start_loc": [1341, 461], "fixing_code_end_loc": [1342, 499], "type": "CWE-787", "message": "Irzip v0.640 was discovered to contain a heap memory corruption via the component lrzip.c:initialise_control.", "other": {"cve": {"id": "CVE-2022-28044", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-15T14:15:07.660", "lastModified": "2022-07-22T09:47:41.723", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Irzip v0.640 was discovered to contain a heap memory corruption via the component lrzip.c:initialise_control."}, {"lang": "es", "value": "Se ha detectado que Irzip versi\u00f3n v0.640, conten\u00eda una corrupci\u00f3n de memoria de la pila por medio del componente lrzip.c:initialise_control"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:irzip_project:irzip:0.640:*:*:*:*:*:*:*", "matchCriteriaId": "F5AAC36E-7E82-4270-8613-147AA67393E8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/ckolivas/lrzip/commit/5faf80cd53ecfd16b636d653483144cd12004f46", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ckolivas/lrzip/issues/216", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00016.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5145", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ckolivas/lrzip/commit/5faf80cd53ecfd16b636d653483144cd12004f46"}}