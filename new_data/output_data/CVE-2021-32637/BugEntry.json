{"buggy_code": ["package handlers\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/valyala/fasthttp\"\n\n\t\"github.com/authelia/authelia/internal/authentication\"\n\t\"github.com/authelia/authelia/internal/authorization\"\n\t\"github.com/authelia/authelia/internal/configuration/schema\"\n\t\"github.com/authelia/authelia/internal/middlewares\"\n\t\"github.com/authelia/authelia/internal/session\"\n\t\"github.com/authelia/authelia/internal/utils\"\n)\n\nfunc isURLUnderProtectedDomain(url *url.URL, domain string) bool {\n\treturn strings.HasSuffix(url.Hostname(), domain)\n}\n\nfunc isSchemeHTTPS(url *url.URL) bool {\n\treturn url.Scheme == \"https\"\n}\n\nfunc isSchemeWSS(url *url.URL) bool {\n\treturn url.Scheme == \"wss\"\n}\n\n// parseBasicAuth parses an HTTP Basic Authentication string.\n// \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\" returns (\"Aladdin\", \"open sesame\", true).\nfunc parseBasicAuth(header, auth string) (username, password string, err error) {\n\tif !strings.HasPrefix(auth, authPrefix) {\n\t\treturn \"\", \"\", fmt.Errorf(\"%s prefix not found in %s header\", strings.Trim(authPrefix, \" \"), header)\n\t}\n\n\tc, err := base64.StdEncoding.DecodeString(auth[len(authPrefix):])\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcs := string(c)\n\ts := strings.IndexByte(cs, ':')\n\n\tif s < 0 {\n\t\treturn \"\", \"\", fmt.Errorf(\"Format of %s header must be user:password\", header)\n\t}\n\n\treturn cs[:s], cs[s+1:], nil\n}\n\n// isTargetURLAuthorized check whether the given user is authorized to access the resource.\nfunc isTargetURLAuthorized(authorizer *authorization.Authorizer, targetURL url.URL,\n\tusername string, userGroups []string, clientIP net.IP, method []byte, authLevel authentication.Level) authorizationMatching {\n\tlevel := authorizer.GetRequiredLevel(\n\t\tauthorization.Subject{\n\t\t\tUsername: username,\n\t\t\tGroups:   userGroups,\n\t\t\tIP:       clientIP,\n\t\t},\n\t\tauthorization.NewObjectRaw(&targetURL, method))\n\n\tswitch {\n\tcase level == authorization.Bypass:\n\t\treturn Authorized\n\tcase level == authorization.Denied && username != \"\":\n\t\t// If the user is not anonymous, it means that we went through\n\t\t// all the rules related to that user and knowing who he is we can\n\t\t// deduce the access is forbidden\n\t\t// For anonymous users though, we cannot be sure that she\n\t\t// could not be granted the rights to access the resource. Consequently\n\t\t// for anonymous users we send Unauthorized instead of Forbidden\n\t\treturn Forbidden\n\tcase level == authorization.OneFactor && authLevel >= authentication.OneFactor,\n\t\tlevel == authorization.TwoFactor && authLevel >= authentication.TwoFactor:\n\t\treturn Authorized\n\t}\n\n\treturn NotAuthorized\n}\n\n// verifyBasicAuth verify that the provided username and password are correct and\n// that the user is authorized to target the resource.\nfunc verifyBasicAuth(header string, auth []byte, targetURL url.URL, ctx *middlewares.AutheliaCtx) (username, name string, groups, emails []string, authLevel authentication.Level, err error) { //nolint:unparam\n\tusername, password, err := parseBasicAuth(header, string(auth))\n\n\tif err != nil {\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to parse content of %s header: %s\", header, err)\n\t}\n\n\tauthenticated, err := ctx.Providers.UserProvider.CheckUserPassword(username, password)\n\n\tif err != nil {\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to check credentials extracted from %s header: %s\", header, err)\n\t}\n\n\t// If the user is not correctly authenticated, send a 401.\n\tif !authenticated {\n\t\t// Request Basic Authentication otherwise\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"User %s is not authenticated\", username)\n\t}\n\n\tdetails, err := ctx.Providers.UserProvider.GetDetails(username)\n\n\tif err != nil {\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to retrieve details of user %s: %s\", username, err)\n\t}\n\n\treturn username, details.DisplayName, details.Groups, details.Emails, authentication.OneFactor, nil\n}\n\n// setForwardedHeaders set the forwarded User, Groups, Name and Email headers.\nfunc setForwardedHeaders(headers *fasthttp.ResponseHeader, username, name string, groups, emails []string) {\n\tif username != \"\" {\n\t\theaders.Set(remoteUserHeader, username)\n\t\theaders.Set(remoteGroupsHeader, strings.Join(groups, \",\"))\n\t\theaders.Set(remoteNameHeader, name)\n\n\t\tif emails != nil {\n\t\t\theaders.Set(remoteEmailHeader, emails[0])\n\t\t} else {\n\t\t\theaders.Set(remoteEmailHeader, \"\")\n\t\t}\n\t}\n}\n\n// hasUserBeenInactiveTooLong checks whether the user has been inactive for too long.\nfunc hasUserBeenInactiveTooLong(ctx *middlewares.AutheliaCtx) (bool, error) { //nolint:unparam\n\tmaxInactivityPeriod := int64(ctx.Providers.SessionProvider.Inactivity.Seconds())\n\tif maxInactivityPeriod == 0 {\n\t\treturn false, nil\n\t}\n\n\tlastActivity := ctx.GetSession().LastActivity\n\tinactivityPeriod := ctx.Clock.Now().Unix() - lastActivity\n\n\tctx.Logger.Tracef(\"Inactivity report: Inactivity=%d, MaxInactivity=%d\",\n\t\tinactivityPeriod, maxInactivityPeriod)\n\n\tif inactivityPeriod > maxInactivityPeriod {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// verifySessionCookie verifies if a user is identified by a cookie.\nfunc verifySessionCookie(ctx *middlewares.AutheliaCtx, targetURL *url.URL, userSession *session.UserSession, refreshProfile bool,\n\trefreshProfileInterval time.Duration) (username, name string, groups, emails []string, authLevel authentication.Level, err error) {\n\t// No username in the session means the user is anonymous.\n\tisUserAnonymous := userSession.Username == \"\"\n\n\tif isUserAnonymous && userSession.AuthenticationLevel != authentication.NotAuthenticated {\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"An anonymous user cannot be authenticated. That might be the sign of a compromise\")\n\t}\n\n\tif !userSession.KeepMeLoggedIn && !isUserAnonymous {\n\t\tinactiveLongEnough, err := hasUserBeenInactiveTooLong(ctx)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to check if user has been inactive for a long time: %s\", err)\n\t\t}\n\n\t\tif inactiveLongEnough {\n\t\t\t// Destroy the session a new one will be regenerated on next request.\n\t\t\terr := ctx.Providers.SessionProvider.DestroySession(ctx.RequestCtx)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to destroy user session after long inactivity: %s\", err)\n\t\t\t}\n\n\t\t\treturn userSession.Username, userSession.DisplayName, userSession.Groups, userSession.Emails, authentication.NotAuthenticated, fmt.Errorf(\"User %s has been inactive for too long\", userSession.Username)\n\t\t}\n\t}\n\n\terr = verifySessionHasUpToDateProfile(ctx, targetURL, userSession, refreshProfile, refreshProfileInterval)\n\tif err != nil {\n\t\tif err == authentication.ErrUserNotFound {\n\t\t\terr = ctx.Providers.SessionProvider.DestroySession(ctx.RequestCtx)\n\t\t\tif err != nil {\n\t\t\t\tctx.Logger.Error(fmt.Errorf(\"Unable to destroy user session after provider refresh didn't find the user: %s\", err))\n\t\t\t}\n\n\t\t\treturn userSession.Username, userSession.DisplayName, userSession.Groups, userSession.Emails, authentication.NotAuthenticated, err\n\t\t}\n\n\t\tctx.Logger.Warnf(\"Error occurred while attempting to update user details from LDAP: %s\", err)\n\t}\n\n\treturn userSession.Username, userSession.DisplayName, userSession.Groups, userSession.Emails, userSession.AuthenticationLevel, nil\n}\n\nfunc handleUnauthorized(ctx *middlewares.AutheliaCtx, targetURL fmt.Stringer, isBasicAuth bool, username string, method []byte) {\n\tfriendlyUsername := \"<anonymous>\"\n\tif username != \"\" {\n\t\tfriendlyUsername = username\n\t}\n\n\tif isBasicAuth {\n\t\tctx.Logger.Infof(\"Access to %s is not authorized to user %s, sending 401 response with basic auth header\", targetURL.String(), friendlyUsername)\n\t\tctx.ReplyUnauthorized()\n\t\tctx.Response.Header.Add(\"WWW-Authenticate\", \"Basic realm=\\\"Authentication required\\\"\")\n\n\t\treturn\n\t}\n\n\t// Kubernetes ingress controller and Traefik use the rd parameter of the verify\n\t// endpoint to provide the URL of the login portal. The target URL of the user\n\t// is computed from X-Forwarded-* headers or X-Original-URL.\n\trd := string(ctx.QueryArgs().Peek(\"rd\"))\n\trm := string(method)\n\n\tfriendlyMethod := \"unknown\"\n\n\tif rm != \"\" {\n\t\tfriendlyMethod = rm\n\t}\n\n\tif rd != \"\" {\n\t\tredirectionURL := \"\"\n\n\t\tif rm != \"\" {\n\t\t\tredirectionURL = fmt.Sprintf(\"%s?rd=%s&rm=%s\", rd, url.QueryEscape(targetURL.String()), rm)\n\t\t} else {\n\t\t\tredirectionURL = fmt.Sprintf(\"%s?rd=%s\", rd, url.QueryEscape(targetURL.String()))\n\t\t}\n\n\t\tctx.Logger.Infof(\"Access to %s (method %s) is not authorized to user %s, redirecting to %s\", targetURL.String(), friendlyMethod, friendlyUsername, redirectionURL)\n\t\tctx.Redirect(redirectionURL, 302)\n\t\tctx.SetBodyString(fmt.Sprintf(\"Found. Redirecting to %s\", redirectionURL))\n\t} else {\n\t\tctx.Logger.Infof(\"Access to %s (method %s) is not authorized to user %s, sending 401 response\", targetURL.String(), friendlyMethod, friendlyUsername)\n\t\tctx.ReplyUnauthorized()\n\t}\n}\n\nfunc updateActivityTimestamp(ctx *middlewares.AutheliaCtx, isBasicAuth bool, username string) error {\n\tif isBasicAuth || username == \"\" {\n\t\treturn nil\n\t}\n\n\tuserSession := ctx.GetSession()\n\t// We don't need to update the activity timestamp when user checked keep me logged in.\n\tif userSession.KeepMeLoggedIn {\n\t\treturn nil\n\t}\n\n\t// Mark current activity.\n\tuserSession.LastActivity = ctx.Clock.Now().Unix()\n\n\treturn ctx.SaveSession(userSession)\n}\n\n// generateVerifySessionHasUpToDateProfileTraceLogs is used to generate trace logs only when trace logging is enabled.\n// The information calculated in this function is completely useless other than trace for now.\nfunc generateVerifySessionHasUpToDateProfileTraceLogs(ctx *middlewares.AutheliaCtx, userSession *session.UserSession,\n\tdetails *authentication.UserDetails) {\n\tgroupsAdded, groupsRemoved := utils.StringSlicesDelta(userSession.Groups, details.Groups)\n\temailsAdded, emailsRemoved := utils.StringSlicesDelta(userSession.Emails, details.Emails)\n\tnameDelta := userSession.DisplayName != details.DisplayName\n\n\t// Check Groups.\n\tvar groupsDelta []string\n\tif len(groupsAdded) != 0 {\n\t\tgroupsDelta = append(groupsDelta, fmt.Sprintf(\"Added: %s.\", strings.Join(groupsAdded, \", \")))\n\t}\n\n\tif len(groupsRemoved) != 0 {\n\t\tgroupsDelta = append(groupsDelta, fmt.Sprintf(\"Removed: %s.\", strings.Join(groupsRemoved, \", \")))\n\t}\n\n\tif len(groupsDelta) != 0 {\n\t\tctx.Logger.Tracef(\"Updated groups detected for %s. %s\", userSession.Username, strings.Join(groupsDelta, \" \"))\n\t} else {\n\t\tctx.Logger.Tracef(\"No updated groups detected for %s\", userSession.Username)\n\t}\n\n\t// Check Emails.\n\tvar emailsDelta []string\n\tif len(emailsAdded) != 0 {\n\t\temailsDelta = append(emailsDelta, fmt.Sprintf(\"Added: %s.\", strings.Join(emailsAdded, \", \")))\n\t}\n\n\tif len(emailsRemoved) != 0 {\n\t\temailsDelta = append(emailsDelta, fmt.Sprintf(\"Removed: %s.\", strings.Join(emailsRemoved, \", \")))\n\t}\n\n\tif len(emailsDelta) != 0 {\n\t\tctx.Logger.Tracef(\"Updated emails detected for %s. %s\", userSession.Username, strings.Join(emailsDelta, \" \"))\n\t} else {\n\t\tctx.Logger.Tracef(\"No updated emails detected for %s\", userSession.Username)\n\t}\n\n\t// Check Name.\n\tif nameDelta {\n\t\tctx.Logger.Tracef(\"Updated display name detected for %s. Added: %s. Removed: %s.\", userSession.Username, details.DisplayName, userSession.DisplayName)\n\t} else {\n\t\tctx.Logger.Tracef(\"No updated display name detected for %s\", userSession.Username)\n\t}\n}\n\nfunc verifySessionHasUpToDateProfile(ctx *middlewares.AutheliaCtx, targetURL *url.URL, userSession *session.UserSession,\n\trefreshProfile bool, refreshProfileInterval time.Duration) error {\n\t// TODO: Add a check for LDAP password changes based on a time format attribute.\n\t// See https://www.authelia.com/docs/security/threat-model.html#potential-future-guarantees\n\tctx.Logger.Tracef(\"Checking if we need check the authentication backend for an updated profile for %s.\", userSession.Username)\n\n\tif !refreshProfile || userSession.Username == \"\" || targetURL == nil {\n\t\treturn nil\n\t}\n\n\tif refreshProfileInterval != schema.RefreshIntervalAlways && userSession.RefreshTTL.After(ctx.Clock.Now()) {\n\t\treturn nil\n\t}\n\n\tctx.Logger.Debugf(\"Checking the authentication backend for an updated profile for user %s\", userSession.Username)\n\tdetails, err := ctx.Providers.UserProvider.GetDetails(userSession.Username)\n\t// Only update the session if we could get the new details.\n\tif err != nil {\n\t\treturn err\n\t}\n\n\temailsDiff := utils.IsStringSlicesDifferent(userSession.Emails, details.Emails)\n\tgroupsDiff := utils.IsStringSlicesDifferent(userSession.Groups, details.Groups)\n\tnameDiff := userSession.DisplayName != details.DisplayName\n\n\tif !groupsDiff && !emailsDiff && !nameDiff {\n\t\tctx.Logger.Tracef(\"Updated profile not detected for %s.\", userSession.Username)\n\t\t// Only update TTL if the user has a interval set.\n\t\t// We get to this check when there were no changes.\n\t\t// Also make sure to update the session even if no difference was found.\n\t\t// This is so that we don't check every subsequent request after this one.\n\t\tif refreshProfileInterval != schema.RefreshIntervalAlways {\n\t\t\t// Update RefreshTTL and save session if refresh is not set to always.\n\t\t\tuserSession.RefreshTTL = ctx.Clock.Now().Add(refreshProfileInterval)\n\t\t\treturn ctx.SaveSession(*userSession)\n\t\t}\n\t} else {\n\t\tctx.Logger.Debugf(\"Updated profile detected for %s.\", userSession.Username)\n\t\tif ctx.Configuration.LogLevel == \"trace\" {\n\t\t\tgenerateVerifySessionHasUpToDateProfileTraceLogs(ctx, userSession, details)\n\t\t}\n\t\tuserSession.Emails = details.Emails\n\t\tuserSession.Groups = details.Groups\n\t\tuserSession.DisplayName = details.DisplayName\n\n\t\t// Only update TTL if the user has a interval set.\n\t\tif refreshProfileInterval != schema.RefreshIntervalAlways {\n\t\t\tuserSession.RefreshTTL = ctx.Clock.Now().Add(refreshProfileInterval)\n\t\t}\n\t\t// Return the result of save session if there were changes.\n\t\treturn ctx.SaveSession(*userSession)\n\t}\n\n\t// Return nil if disabled or if no changes and refresh interval set to always.\n\treturn nil\n}\n\nfunc getProfileRefreshSettings(cfg schema.AuthenticationBackendConfiguration) (refresh bool, refreshInterval time.Duration) {\n\tif cfg.LDAP != nil {\n\t\tif cfg.RefreshInterval == schema.ProfileRefreshDisabled {\n\t\t\trefresh = false\n\t\t\trefreshInterval = 0\n\t\t} else {\n\t\t\trefresh = true\n\n\t\t\tif cfg.RefreshInterval != schema.ProfileRefreshAlways {\n\t\t\t\t// Skip Error Check since validator checks it\n\t\t\t\trefreshInterval, _ = utils.ParseDurationString(cfg.RefreshInterval)\n\t\t\t} else {\n\t\t\t\trefreshInterval = schema.RefreshIntervalAlways\n\t\t\t}\n\t\t}\n\t}\n\n\treturn refresh, refreshInterval\n}\n\nfunc verifyAuth(ctx *middlewares.AutheliaCtx, targetURL *url.URL, refreshProfile bool, refreshProfileInterval time.Duration) (isBasicAuth bool, username, name string, groups, emails []string, authLevel authentication.Level, err error) {\n\tauthHeader := ProxyAuthorizationHeader\n\tif bytes.Equal(ctx.QueryArgs().Peek(\"auth\"), []byte(\"basic\")) {\n\t\tauthHeader = AuthorizationHeader\n\t\tisBasicAuth = true\n\t}\n\n\tauthValue := ctx.Request.Header.Peek(authHeader)\n\tif authValue != nil {\n\t\tisBasicAuth = true\n\t} else if isBasicAuth {\n\t\terr = fmt.Errorf(\"Basic auth requested via query arg, but no value provided via %s header\", authHeader)\n\t\treturn\n\t}\n\n\tif isBasicAuth {\n\t\tusername, name, groups, emails, authLevel, err = verifyBasicAuth(authHeader, authValue, *targetURL, ctx)\n\t\treturn\n\t}\n\n\tuserSession := ctx.GetSession()\n\tusername, name, groups, emails, authLevel, err = verifySessionCookie(ctx, targetURL, &userSession, refreshProfile, refreshProfileInterval)\n\n\tsessionUsername := ctx.Request.Header.Peek(SessionUsernameHeader)\n\tif sessionUsername != nil && !strings.EqualFold(string(sessionUsername), username) {\n\t\tctx.Logger.Warnf(\"Possible cookie hijack or attempt to bypass security detected destroying the session and sending 401 response\")\n\n\t\terr = ctx.Providers.SessionProvider.DestroySession(ctx.RequestCtx)\n\t\tif err != nil {\n\t\t\tctx.Logger.Error(\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\"Unable to destroy user session after handler could not match them to their %s header: %s\",\n\t\t\t\t\tSessionUsernameHeader, err))\n\t\t}\n\n\t\terr = fmt.Errorf(\"Could not match user %s to their %s header with a value of %s when visiting %s\", username, SessionUsernameHeader, sessionUsername, targetURL.String())\n\t}\n\n\treturn\n}\n\n// VerifyGet returns the handler verifying if a request is allowed to go through.\nfunc VerifyGet(cfg schema.AuthenticationBackendConfiguration) middlewares.RequestHandler {\n\trefreshProfile, refreshProfileInterval := getProfileRefreshSettings(cfg)\n\n\treturn func(ctx *middlewares.AutheliaCtx) {\n\t\tctx.Logger.Tracef(\"Headers=%s\", ctx.Request.Header.String())\n\t\ttargetURL, err := ctx.GetOriginalURL()\n\n\t\tif err != nil {\n\t\t\tctx.Error(fmt.Errorf(\"Unable to parse target URL: %s\", err), operationFailedMessage)\n\t\t\treturn\n\t\t}\n\n\t\tif !isSchemeHTTPS(targetURL) && !isSchemeWSS(targetURL) {\n\t\t\tctx.Logger.Error(fmt.Errorf(\"Scheme of target URL %s must be secure since cookies are \"+\n\t\t\t\t\"only transported over a secure connection for security reasons\", targetURL.String()))\n\t\t\tctx.ReplyUnauthorized()\n\n\t\t\treturn\n\t\t}\n\n\t\tif !isURLUnderProtectedDomain(targetURL, ctx.Configuration.Session.Domain) {\n\t\t\tctx.Logger.Error(fmt.Errorf(\"The target URL %s is not under the protected domain %s\",\n\t\t\t\ttargetURL.String(), ctx.Configuration.Session.Domain))\n\t\t\tctx.ReplyUnauthorized()\n\n\t\t\treturn\n\t\t}\n\n\t\tisBasicAuth, username, name, groups, emails, authLevel, err := verifyAuth(ctx, targetURL, refreshProfile, refreshProfileInterval)\n\n\t\tmethod := ctx.XForwardedMethod()\n\n\t\tif err != nil {\n\t\t\tctx.Logger.Error(fmt.Sprintf(\"Error caught when verifying user authorization: %s\", err))\n\n\t\t\tif err := updateActivityTimestamp(ctx, isBasicAuth, username); err != nil {\n\t\t\t\tctx.Error(fmt.Errorf(\"Unable to update last activity: %s\", err), operationFailedMessage)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\thandleUnauthorized(ctx, targetURL, isBasicAuth, username, method)\n\n\t\t\treturn\n\t\t}\n\n\t\tauthorized := isTargetURLAuthorized(ctx.Providers.Authorizer, *targetURL, username,\n\t\t\tgroups, ctx.RemoteIP(), method, authLevel)\n\n\t\tswitch authorized {\n\t\tcase Forbidden:\n\t\t\tctx.Logger.Infof(\"Access to %s is forbidden to user %s\", targetURL.String(), username)\n\t\t\tctx.ReplyForbidden()\n\t\tcase NotAuthorized:\n\t\t\thandleUnauthorized(ctx, targetURL, isBasicAuth, username, method)\n\t\tcase Authorized:\n\t\t\tsetForwardedHeaders(&ctx.Response.Header, username, name, groups, emails)\n\t\t}\n\n\t\tif err := updateActivityTimestamp(ctx, isBasicAuth, username); err != nil {\n\t\t\tctx.Error(fmt.Errorf(\"Unable to update last activity: %s\", err), operationFailedMessage)\n\t\t}\n\t}\n}\n"], "fixing_code": ["package handlers\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/valyala/fasthttp\"\n\n\t\"github.com/authelia/authelia/internal/authentication\"\n\t\"github.com/authelia/authelia/internal/authorization\"\n\t\"github.com/authelia/authelia/internal/configuration/schema\"\n\t\"github.com/authelia/authelia/internal/middlewares\"\n\t\"github.com/authelia/authelia/internal/session\"\n\t\"github.com/authelia/authelia/internal/utils\"\n)\n\nfunc isURLUnderProtectedDomain(url *url.URL, domain string) bool {\n\treturn strings.HasSuffix(url.Hostname(), domain)\n}\n\nfunc isSchemeHTTPS(url *url.URL) bool {\n\treturn url.Scheme == \"https\"\n}\n\nfunc isSchemeWSS(url *url.URL) bool {\n\treturn url.Scheme == \"wss\"\n}\n\n// parseBasicAuth parses an HTTP Basic Authentication string.\n// \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\" returns (\"Aladdin\", \"open sesame\", true).\nfunc parseBasicAuth(header, auth string) (username, password string, err error) {\n\tif !strings.HasPrefix(auth, authPrefix) {\n\t\treturn \"\", \"\", fmt.Errorf(\"%s prefix not found in %s header\", strings.Trim(authPrefix, \" \"), header)\n\t}\n\n\tc, err := base64.StdEncoding.DecodeString(auth[len(authPrefix):])\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcs := string(c)\n\ts := strings.IndexByte(cs, ':')\n\n\tif s < 0 {\n\t\treturn \"\", \"\", fmt.Errorf(\"Format of %s header must be user:password\", header)\n\t}\n\n\treturn cs[:s], cs[s+1:], nil\n}\n\n// isTargetURLAuthorized check whether the given user is authorized to access the resource.\nfunc isTargetURLAuthorized(authorizer *authorization.Authorizer, targetURL url.URL,\n\tusername string, userGroups []string, clientIP net.IP, method []byte, authLevel authentication.Level) authorizationMatching {\n\tlevel := authorizer.GetRequiredLevel(\n\t\tauthorization.Subject{\n\t\t\tUsername: username,\n\t\t\tGroups:   userGroups,\n\t\t\tIP:       clientIP,\n\t\t},\n\t\tauthorization.NewObjectRaw(&targetURL, method))\n\n\tswitch {\n\tcase level == authorization.Bypass:\n\t\treturn Authorized\n\tcase level == authorization.Denied && username != \"\":\n\t\t// If the user is not anonymous, it means that we went through\n\t\t// all the rules related to that user and knowing who he is we can\n\t\t// deduce the access is forbidden\n\t\t// For anonymous users though, we cannot be sure that she\n\t\t// could not be granted the rights to access the resource. Consequently\n\t\t// for anonymous users we send Unauthorized instead of Forbidden\n\t\treturn Forbidden\n\tcase level == authorization.OneFactor && authLevel >= authentication.OneFactor,\n\t\tlevel == authorization.TwoFactor && authLevel >= authentication.TwoFactor:\n\t\treturn Authorized\n\t}\n\n\treturn NotAuthorized\n}\n\n// verifyBasicAuth verify that the provided username and password are correct and\n// that the user is authorized to target the resource.\nfunc verifyBasicAuth(header string, auth []byte, targetURL url.URL, ctx *middlewares.AutheliaCtx) (username, name string, groups, emails []string, authLevel authentication.Level, err error) { //nolint:unparam\n\tusername, password, err := parseBasicAuth(header, string(auth))\n\n\tif err != nil {\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to parse content of %s header: %s\", header, err)\n\t}\n\n\tauthenticated, err := ctx.Providers.UserProvider.CheckUserPassword(username, password)\n\n\tif err != nil {\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to check credentials extracted from %s header: %s\", header, err)\n\t}\n\n\t// If the user is not correctly authenticated, send a 401.\n\tif !authenticated {\n\t\t// Request Basic Authentication otherwise\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"User %s is not authenticated\", username)\n\t}\n\n\tdetails, err := ctx.Providers.UserProvider.GetDetails(username)\n\n\tif err != nil {\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to retrieve details of user %s: %s\", username, err)\n\t}\n\n\treturn username, details.DisplayName, details.Groups, details.Emails, authentication.OneFactor, nil\n}\n\n// setForwardedHeaders set the forwarded User, Groups, Name and Email headers.\nfunc setForwardedHeaders(headers *fasthttp.ResponseHeader, username, name string, groups, emails []string) {\n\tif username != \"\" {\n\t\theaders.Set(remoteUserHeader, username)\n\t\theaders.Set(remoteGroupsHeader, strings.Join(groups, \",\"))\n\t\theaders.Set(remoteNameHeader, name)\n\n\t\tif emails != nil {\n\t\t\theaders.Set(remoteEmailHeader, emails[0])\n\t\t} else {\n\t\t\theaders.Set(remoteEmailHeader, \"\")\n\t\t}\n\t}\n}\n\n// hasUserBeenInactiveTooLong checks whether the user has been inactive for too long.\nfunc hasUserBeenInactiveTooLong(ctx *middlewares.AutheliaCtx) (bool, error) { //nolint:unparam\n\tmaxInactivityPeriod := int64(ctx.Providers.SessionProvider.Inactivity.Seconds())\n\tif maxInactivityPeriod == 0 {\n\t\treturn false, nil\n\t}\n\n\tlastActivity := ctx.GetSession().LastActivity\n\tinactivityPeriod := ctx.Clock.Now().Unix() - lastActivity\n\n\tctx.Logger.Tracef(\"Inactivity report: Inactivity=%d, MaxInactivity=%d\",\n\t\tinactivityPeriod, maxInactivityPeriod)\n\n\tif inactivityPeriod > maxInactivityPeriod {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// verifySessionCookie verifies if a user is identified by a cookie.\nfunc verifySessionCookie(ctx *middlewares.AutheliaCtx, targetURL *url.URL, userSession *session.UserSession, refreshProfile bool,\n\trefreshProfileInterval time.Duration) (username, name string, groups, emails []string, authLevel authentication.Level, err error) {\n\t// No username in the session means the user is anonymous.\n\tisUserAnonymous := userSession.Username == \"\"\n\n\tif isUserAnonymous && userSession.AuthenticationLevel != authentication.NotAuthenticated {\n\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"An anonymous user cannot be authenticated. That might be the sign of a compromise\")\n\t}\n\n\tif !userSession.KeepMeLoggedIn && !isUserAnonymous {\n\t\tinactiveLongEnough, err := hasUserBeenInactiveTooLong(ctx)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to check if user has been inactive for a long time: %s\", err)\n\t\t}\n\n\t\tif inactiveLongEnough {\n\t\t\t// Destroy the session a new one will be regenerated on next request.\n\t\t\terr := ctx.Providers.SessionProvider.DestroySession(ctx.RequestCtx)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", nil, nil, authentication.NotAuthenticated, fmt.Errorf(\"Unable to destroy user session after long inactivity: %s\", err)\n\t\t\t}\n\n\t\t\treturn userSession.Username, userSession.DisplayName, userSession.Groups, userSession.Emails, authentication.NotAuthenticated, fmt.Errorf(\"User %s has been inactive for too long\", userSession.Username)\n\t\t}\n\t}\n\n\terr = verifySessionHasUpToDateProfile(ctx, targetURL, userSession, refreshProfile, refreshProfileInterval)\n\tif err != nil {\n\t\tif err == authentication.ErrUserNotFound {\n\t\t\terr = ctx.Providers.SessionProvider.DestroySession(ctx.RequestCtx)\n\t\t\tif err != nil {\n\t\t\t\tctx.Logger.Error(fmt.Errorf(\"Unable to destroy user session after provider refresh didn't find the user: %s\", err))\n\t\t\t}\n\n\t\t\treturn userSession.Username, userSession.DisplayName, userSession.Groups, userSession.Emails, authentication.NotAuthenticated, err\n\t\t}\n\n\t\tctx.Logger.Warnf(\"Error occurred while attempting to update user details from LDAP: %s\", err)\n\t}\n\n\treturn userSession.Username, userSession.DisplayName, userSession.Groups, userSession.Emails, userSession.AuthenticationLevel, nil\n}\n\nfunc handleUnauthorized(ctx *middlewares.AutheliaCtx, targetURL fmt.Stringer, isBasicAuth bool, username string, method []byte) {\n\tfriendlyUsername := \"<anonymous>\"\n\tif username != \"\" {\n\t\tfriendlyUsername = username\n\t}\n\n\tif isBasicAuth {\n\t\tctx.Logger.Infof(\"Access to %s is not authorized to user %s, sending 401 response with basic auth header\", targetURL.String(), friendlyUsername)\n\t\tctx.ReplyUnauthorized()\n\t\tctx.Response.Header.Add(\"WWW-Authenticate\", \"Basic realm=\\\"Authentication required\\\"\")\n\n\t\treturn\n\t}\n\n\t// Kubernetes ingress controller and Traefik use the rd parameter of the verify\n\t// endpoint to provide the URL of the login portal. The target URL of the user\n\t// is computed from X-Forwarded-* headers or X-Original-URL.\n\trd := string(ctx.QueryArgs().Peek(\"rd\"))\n\trm := string(method)\n\n\tfriendlyMethod := \"unknown\"\n\n\tif rm != \"\" {\n\t\tfriendlyMethod = rm\n\t}\n\n\tif rd != \"\" {\n\t\tredirectionURL := \"\"\n\n\t\tif rm != \"\" {\n\t\t\tredirectionURL = fmt.Sprintf(\"%s?rd=%s&rm=%s\", rd, url.QueryEscape(targetURL.String()), rm)\n\t\t} else {\n\t\t\tredirectionURL = fmt.Sprintf(\"%s?rd=%s\", rd, url.QueryEscape(targetURL.String()))\n\t\t}\n\n\t\tctx.Logger.Infof(\"Access to %s (method %s) is not authorized to user %s, redirecting to %s\", targetURL.String(), friendlyMethod, friendlyUsername, redirectionURL)\n\t\tctx.Redirect(redirectionURL, 302)\n\t\tctx.SetBodyString(fmt.Sprintf(\"Found. Redirecting to %s\", redirectionURL))\n\t} else {\n\t\tctx.Logger.Infof(\"Access to %s (method %s) is not authorized to user %s, sending 401 response\", targetURL.String(), friendlyMethod, friendlyUsername)\n\t\tctx.ReplyUnauthorized()\n\t}\n}\n\nfunc updateActivityTimestamp(ctx *middlewares.AutheliaCtx, isBasicAuth bool, username string) error {\n\tif isBasicAuth || username == \"\" {\n\t\treturn nil\n\t}\n\n\tuserSession := ctx.GetSession()\n\t// We don't need to update the activity timestamp when user checked keep me logged in.\n\tif userSession.KeepMeLoggedIn {\n\t\treturn nil\n\t}\n\n\t// Mark current activity.\n\tuserSession.LastActivity = ctx.Clock.Now().Unix()\n\n\treturn ctx.SaveSession(userSession)\n}\n\n// generateVerifySessionHasUpToDateProfileTraceLogs is used to generate trace logs only when trace logging is enabled.\n// The information calculated in this function is completely useless other than trace for now.\nfunc generateVerifySessionHasUpToDateProfileTraceLogs(ctx *middlewares.AutheliaCtx, userSession *session.UserSession,\n\tdetails *authentication.UserDetails) {\n\tgroupsAdded, groupsRemoved := utils.StringSlicesDelta(userSession.Groups, details.Groups)\n\temailsAdded, emailsRemoved := utils.StringSlicesDelta(userSession.Emails, details.Emails)\n\tnameDelta := userSession.DisplayName != details.DisplayName\n\n\t// Check Groups.\n\tvar groupsDelta []string\n\tif len(groupsAdded) != 0 {\n\t\tgroupsDelta = append(groupsDelta, fmt.Sprintf(\"Added: %s.\", strings.Join(groupsAdded, \", \")))\n\t}\n\n\tif len(groupsRemoved) != 0 {\n\t\tgroupsDelta = append(groupsDelta, fmt.Sprintf(\"Removed: %s.\", strings.Join(groupsRemoved, \", \")))\n\t}\n\n\tif len(groupsDelta) != 0 {\n\t\tctx.Logger.Tracef(\"Updated groups detected for %s. %s\", userSession.Username, strings.Join(groupsDelta, \" \"))\n\t} else {\n\t\tctx.Logger.Tracef(\"No updated groups detected for %s\", userSession.Username)\n\t}\n\n\t// Check Emails.\n\tvar emailsDelta []string\n\tif len(emailsAdded) != 0 {\n\t\temailsDelta = append(emailsDelta, fmt.Sprintf(\"Added: %s.\", strings.Join(emailsAdded, \", \")))\n\t}\n\n\tif len(emailsRemoved) != 0 {\n\t\temailsDelta = append(emailsDelta, fmt.Sprintf(\"Removed: %s.\", strings.Join(emailsRemoved, \", \")))\n\t}\n\n\tif len(emailsDelta) != 0 {\n\t\tctx.Logger.Tracef(\"Updated emails detected for %s. %s\", userSession.Username, strings.Join(emailsDelta, \" \"))\n\t} else {\n\t\tctx.Logger.Tracef(\"No updated emails detected for %s\", userSession.Username)\n\t}\n\n\t// Check Name.\n\tif nameDelta {\n\t\tctx.Logger.Tracef(\"Updated display name detected for %s. Added: %s. Removed: %s.\", userSession.Username, details.DisplayName, userSession.DisplayName)\n\t} else {\n\t\tctx.Logger.Tracef(\"No updated display name detected for %s\", userSession.Username)\n\t}\n}\n\nfunc verifySessionHasUpToDateProfile(ctx *middlewares.AutheliaCtx, targetURL *url.URL, userSession *session.UserSession,\n\trefreshProfile bool, refreshProfileInterval time.Duration) error {\n\t// TODO: Add a check for LDAP password changes based on a time format attribute.\n\t// See https://www.authelia.com/docs/security/threat-model.html#potential-future-guarantees\n\tctx.Logger.Tracef(\"Checking if we need check the authentication backend for an updated profile for %s.\", userSession.Username)\n\n\tif !refreshProfile || userSession.Username == \"\" || targetURL == nil {\n\t\treturn nil\n\t}\n\n\tif refreshProfileInterval != schema.RefreshIntervalAlways && userSession.RefreshTTL.After(ctx.Clock.Now()) {\n\t\treturn nil\n\t}\n\n\tctx.Logger.Debugf(\"Checking the authentication backend for an updated profile for user %s\", userSession.Username)\n\tdetails, err := ctx.Providers.UserProvider.GetDetails(userSession.Username)\n\t// Only update the session if we could get the new details.\n\tif err != nil {\n\t\treturn err\n\t}\n\n\temailsDiff := utils.IsStringSlicesDifferent(userSession.Emails, details.Emails)\n\tgroupsDiff := utils.IsStringSlicesDifferent(userSession.Groups, details.Groups)\n\tnameDiff := userSession.DisplayName != details.DisplayName\n\n\tif !groupsDiff && !emailsDiff && !nameDiff {\n\t\tctx.Logger.Tracef(\"Updated profile not detected for %s.\", userSession.Username)\n\t\t// Only update TTL if the user has a interval set.\n\t\t// We get to this check when there were no changes.\n\t\t// Also make sure to update the session even if no difference was found.\n\t\t// This is so that we don't check every subsequent request after this one.\n\t\tif refreshProfileInterval != schema.RefreshIntervalAlways {\n\t\t\t// Update RefreshTTL and save session if refresh is not set to always.\n\t\t\tuserSession.RefreshTTL = ctx.Clock.Now().Add(refreshProfileInterval)\n\t\t\treturn ctx.SaveSession(*userSession)\n\t\t}\n\t} else {\n\t\tctx.Logger.Debugf(\"Updated profile detected for %s.\", userSession.Username)\n\t\tif ctx.Configuration.LogLevel == \"trace\" {\n\t\t\tgenerateVerifySessionHasUpToDateProfileTraceLogs(ctx, userSession, details)\n\t\t}\n\t\tuserSession.Emails = details.Emails\n\t\tuserSession.Groups = details.Groups\n\t\tuserSession.DisplayName = details.DisplayName\n\n\t\t// Only update TTL if the user has a interval set.\n\t\tif refreshProfileInterval != schema.RefreshIntervalAlways {\n\t\t\tuserSession.RefreshTTL = ctx.Clock.Now().Add(refreshProfileInterval)\n\t\t}\n\t\t// Return the result of save session if there were changes.\n\t\treturn ctx.SaveSession(*userSession)\n\t}\n\n\t// Return nil if disabled or if no changes and refresh interval set to always.\n\treturn nil\n}\n\nfunc getProfileRefreshSettings(cfg schema.AuthenticationBackendConfiguration) (refresh bool, refreshInterval time.Duration) {\n\tif cfg.LDAP != nil {\n\t\tif cfg.RefreshInterval == schema.ProfileRefreshDisabled {\n\t\t\trefresh = false\n\t\t\trefreshInterval = 0\n\t\t} else {\n\t\t\trefresh = true\n\n\t\t\tif cfg.RefreshInterval != schema.ProfileRefreshAlways {\n\t\t\t\t// Skip Error Check since validator checks it\n\t\t\t\trefreshInterval, _ = utils.ParseDurationString(cfg.RefreshInterval)\n\t\t\t} else {\n\t\t\t\trefreshInterval = schema.RefreshIntervalAlways\n\t\t\t}\n\t\t}\n\t}\n\n\treturn refresh, refreshInterval\n}\n\nfunc verifyAuth(ctx *middlewares.AutheliaCtx, targetURL *url.URL, refreshProfile bool, refreshProfileInterval time.Duration) (isBasicAuth bool, username, name string, groups, emails []string, authLevel authentication.Level, err error) {\n\tauthHeader := ProxyAuthorizationHeader\n\tif bytes.Equal(ctx.QueryArgs().Peek(\"auth\"), []byte(\"basic\")) {\n\t\tauthHeader = AuthorizationHeader\n\t\tisBasicAuth = true\n\t}\n\n\tauthValue := ctx.Request.Header.Peek(authHeader)\n\tif authValue != nil {\n\t\tisBasicAuth = true\n\t} else if isBasicAuth {\n\t\terr = fmt.Errorf(\"Basic auth requested via query arg, but no value provided via %s header\", authHeader)\n\t\treturn\n\t}\n\n\tif isBasicAuth {\n\t\tusername, name, groups, emails, authLevel, err = verifyBasicAuth(authHeader, authValue, *targetURL, ctx)\n\t\treturn\n\t}\n\n\tuserSession := ctx.GetSession()\n\tusername, name, groups, emails, authLevel, err = verifySessionCookie(ctx, targetURL, &userSession, refreshProfile, refreshProfileInterval)\n\n\tsessionUsername := ctx.Request.Header.Peek(SessionUsernameHeader)\n\tif sessionUsername != nil && !strings.EqualFold(string(sessionUsername), username) {\n\t\tctx.Logger.Warnf(\"Possible cookie hijack or attempt to bypass security detected destroying the session and sending 401 response\")\n\n\t\terr = ctx.Providers.SessionProvider.DestroySession(ctx.RequestCtx)\n\t\tif err != nil {\n\t\t\tctx.Logger.Error(\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\"Unable to destroy user session after handler could not match them to their %s header: %s\",\n\t\t\t\t\tSessionUsernameHeader, err))\n\t\t}\n\n\t\terr = fmt.Errorf(\"Could not match user %s to their %s header with a value of %s when visiting %s\", username, SessionUsernameHeader, sessionUsername, targetURL.String())\n\t}\n\n\treturn\n}\n\n// VerifyGet returns the handler verifying if a request is allowed to go through.\nfunc VerifyGet(cfg schema.AuthenticationBackendConfiguration) middlewares.RequestHandler {\n\trefreshProfile, refreshProfileInterval := getProfileRefreshSettings(cfg)\n\n\treturn func(ctx *middlewares.AutheliaCtx) {\n\t\tctx.Logger.Tracef(\"Headers=%s\", ctx.Request.Header.String())\n\t\ttargetURL, err := ctx.GetOriginalURL()\n\n\t\tif err != nil {\n\t\t\tctx.Logger.Error(fmt.Errorf(\"Unable to parse target URL: %s\", err))\n\t\t\tctx.ReplyUnauthorized()\n\n\t\t\treturn\n\t\t}\n\n\t\tif !isSchemeHTTPS(targetURL) && !isSchemeWSS(targetURL) {\n\t\t\tctx.Logger.Error(fmt.Errorf(\"Scheme of target URL %s must be secure since cookies are \"+\n\t\t\t\t\"only transported over a secure connection for security reasons\", targetURL.String()))\n\t\t\tctx.ReplyUnauthorized()\n\n\t\t\treturn\n\t\t}\n\n\t\tif !isURLUnderProtectedDomain(targetURL, ctx.Configuration.Session.Domain) {\n\t\t\tctx.Logger.Error(fmt.Errorf(\"The target URL %s is not under the protected domain %s\",\n\t\t\t\ttargetURL.String(), ctx.Configuration.Session.Domain))\n\t\t\tctx.ReplyUnauthorized()\n\n\t\t\treturn\n\t\t}\n\n\t\tisBasicAuth, username, name, groups, emails, authLevel, err := verifyAuth(ctx, targetURL, refreshProfile, refreshProfileInterval)\n\n\t\tmethod := ctx.XForwardedMethod()\n\n\t\tif err != nil {\n\t\t\tctx.Logger.Error(fmt.Sprintf(\"Error caught when verifying user authorization: %s\", err))\n\n\t\t\tif err := updateActivityTimestamp(ctx, isBasicAuth, username); err != nil {\n\t\t\t\tctx.Error(fmt.Errorf(\"Unable to update last activity: %s\", err), operationFailedMessage)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\thandleUnauthorized(ctx, targetURL, isBasicAuth, username, method)\n\n\t\t\treturn\n\t\t}\n\n\t\tauthorized := isTargetURLAuthorized(ctx.Providers.Authorizer, *targetURL, username,\n\t\t\tgroups, ctx.RemoteIP(), method, authLevel)\n\n\t\tswitch authorized {\n\t\tcase Forbidden:\n\t\t\tctx.Logger.Infof(\"Access to %s is forbidden to user %s\", targetURL.String(), username)\n\t\t\tctx.ReplyForbidden()\n\t\tcase NotAuthorized:\n\t\t\thandleUnauthorized(ctx, targetURL, isBasicAuth, username, method)\n\t\tcase Authorized:\n\t\t\tsetForwardedHeaders(&ctx.Response.Header, username, name, groups, emails)\n\t\t}\n\n\t\tif err := updateActivityTimestamp(ctx, isBasicAuth, username); err != nil {\n\t\t\tctx.Error(fmt.Errorf(\"Unable to update last activity: %s\", err), operationFailedMessage)\n\t\t}\n\t}\n}\n"], "filenames": ["internal/handlers/handler_verify.go"], "buggy_code_start_loc": [431], "buggy_code_end_loc": [432], "fixing_code_start_loc": [431], "fixing_code_end_loc": [434], "type": "CWE-287", "message": "Authelia is a a single sign-on multi-factor portal for web apps. This affects uses who are using nginx ngx_http_auth_request_module with Authelia, it allows a malicious individual who crafts a malformed HTTP request to bypass the authentication mechanism. It additionally could theoretically affect other proxy servers, but all of the ones we officially support except nginx do not allow malformed URI paths. The problem is rectified entirely in v4.29.3. As this patch is relatively straightforward we can back port this to any version upon request. Alternatively we are supplying a git patch to 4.25.1 which should be relatively straightforward to apply to any version, the git patches for specific versions can be found in the references. The most relevant workaround is upgrading. You can also add a block which fails requests that contains a malformed URI in the internal location block.", "other": {"cve": {"id": "CVE-2021-32637", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-28T17:15:07.493", "lastModified": "2021-06-09T16:36:44.157", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Authelia is a a single sign-on multi-factor portal for web apps. This affects uses who are using nginx ngx_http_auth_request_module with Authelia, it allows a malicious individual who crafts a malformed HTTP request to bypass the authentication mechanism. It additionally could theoretically affect other proxy servers, but all of the ones we officially support except nginx do not allow malformed URI paths. The problem is rectified entirely in v4.29.3. As this patch is relatively straightforward we can back port this to any version upon request. Alternatively we are supplying a git patch to 4.25.1 which should be relatively straightforward to apply to any version, the git patches for specific versions can be found in the references. The most relevant workaround is upgrading. You can also add a block which fails requests that contains a malformed URI in the internal location block."}, {"lang": "es", "value": "Authelia es un portal multifactor de inicio de sesi\u00f3n \u00fanico para aplicaciones web.&#xa0;Esto afecta a usuarios que usan la funci\u00f3n nginx ngx_http_auth_request_module con Authelia, permite a un individuo  malicioso que dise\u00f1a una petici\u00f3n HTTP malformada omitir el mecanismo de autenticaci\u00f3n.&#xa0;Adem\u00e1s, podr\u00eda afectar te\u00f3ricamente a otros servidores proxy, pero todos los que admitimos oficialmente, excepto nginx, no permiten rutas URI malformadas.&#xa0;El problema es rectificado por completo en la versi\u00f3n v4.29.3.&#xa0;Como este parche es relativamente sencillo, podemos realizar un backport a cualquier versi\u00f3n a pedido.&#xa0;Alternativamente, estamos proporcionando un parche de git para la versi\u00f3n 4.25.1, que deber\u00eda ser relativamente sencillo de aplicar a cualquier versi\u00f3n, los parches de git para versiones espec\u00edficas se pueden encontrar en las referencias.&#xa0;La soluci\u00f3n alternativa m\u00e1s relevante es la actualizaci\u00f3n. Tambi\u00e9n puede a\u00f1adir un bloque que falle las peticiones que contengan un URI malformado en el bloque de localizaci\u00f3n interna"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:authelia:authelia:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.25.1", "matchCriteriaId": "B34C028E-DCF0-40E5-8482-F37539F864B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:authelia:authelia:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.26.0", "versionEndExcluding": "4.29.3", "matchCriteriaId": "E0370876-3F55-4A4F-82F7-D2E5B5C5C78D"}]}]}], "references": [{"url": "https://github.com/authelia/authelia/commit/c62dbd43d6e69ae81530e7c4f8763857f8ff1dda", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/authelia/authelia/security/advisories/GHSA-68wm-pfjf-wqp6", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/authelia/authelia/commit/c62dbd43d6e69ae81530e7c4f8763857f8ff1dda"}}