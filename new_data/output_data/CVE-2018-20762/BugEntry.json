{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / mp4box application\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/tools.h>\n#include <gpac/media_tools.h>\n#include <gpac/constants.h>\n#include <gpac/scene_manager.h>\n#include <gpac/network.h>\n#include <gpac/base_coding.h>\n\n#if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_X3D) && !defined(GPAC_DISABLE_SVG)\n#include <gpac/scenegraph.h>\n#endif\n\n\n#ifndef GPAC_DISABLE_BIFS\n#include <gpac/bifs.h>\n#endif\n#ifndef GPAC_DISABLE_VRML\n#include <gpac/nodes_mpeg4.h>\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#include <gpac/xml.h>\n#include <gpac/internal/isomedia_dev.h>\n\ntypedef struct\n{\n\tconst char *root_file;\n\tconst char *dir;\n\tGF_List *imports;\n} WGTEnum;\n\nGF_Err set_file_udta(GF_ISOFile *dest, u32 tracknum, u32 udta_type, char *src, Bool is_box_array)\n{\n\tchar *data = NULL;\n\tGF_Err res = GF_OK;\n\tu32 size;\n\tbin128 uuid;\n\tmemset(uuid, 0 , 16);\n\n\tif (!udta_type && !is_box_array) return GF_BAD_PARAM;\n\n\tif (!src) {\n\t\treturn gf_isom_remove_user_data(dest, tracknum, udta_type, uuid);\n\t}\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\tif (!strnicmp(src, \"base64\", 6)) {\n\t\tsrc += 7;\n\t\tsize = (u32) strlen(src);\n\t\tdata = gf_malloc(sizeof(char) * size);\n\t\tsize = gf_base64_decode(src, size, data, size);\n\t} else\n#endif\n\t{\n\t\tFILE *t = gf_fopen(src, \"rb\");\n\t\tif (!t) return GF_IO_ERR;\n\t\tfseek(t, 0, SEEK_END);\n\t\tsize = ftell(t);\n\t\tfseek(t, 0, SEEK_SET);\n\t\tdata = gf_malloc(sizeof(char)*size);\n\t\tif (size != fread(data, 1, size, t) ) {\n\t\t\tgf_free(data);\n\t\t\tgf_fclose(t);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tgf_fclose(t);\n\t}\n\n\tif (size && data) {\n\t\tif (is_box_array) {\n\t\t\tres = gf_isom_add_user_data_boxes(dest, tracknum, data, size);\n\t\t} else {\n\t\t\tres = gf_isom_add_user_data(dest, tracknum, udta_type, uuid, data, size);\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn res;\n}\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\nextern u32 swf_flags;\nextern Float swf_flatten_angle;\nextern Bool keep_sys_tracks;\n\nvoid scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist);\n\nvoid convert_file_info(char *inName, u32 trackID)\n{\n\tGF_Err e;\n\tu32 i;\n\tBool found;\n\tGF_MediaImporter import;\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\timport.trackID = trackID;\n\timport.in_name = inName;\n\timport.flags = GF_IMPORT_PROBE_ONLY;\n\te = gf_media_import(&import);\n\tif (e) {\n\t\tfprintf(stderr, \"Error probing file %s: %s\\n\", inName, gf_error_to_string(e));\n\t\treturn;\n\t}\n\tif (trackID) {\n\t\tfprintf(stderr, \"Import probing results for track %s#%d:\\n\", inName, trackID);\n\t} else {\n\t\tfprintf(stderr, \"Import probing results for %s:\\n\", inName);\n\t\tif (!import.nb_tracks) {\n\t\t\tfprintf(stderr, \"File has no selectable tracks\\n\");\n\t\t\treturn;\n\t\t}\n\t\tfprintf(stderr, \"File has %d tracks\\n\", import.nb_tracks);\n\t}\n\tif (import.probe_duration) {\n\t\tfprintf(stderr, \"Duration: %g s\\n\", (Double) (import.probe_duration/1000.0));\n\t}\n\tfound = 0;\n\tfor (i=0; i<import.nb_tracks; i++) {\n\t\tif (trackID && (trackID != import.tk_info[i].track_num)) continue;\n\t\tif (!trackID) fprintf(stderr, \"\\tTrack %d type: \", import.tk_info[i].track_num);\n\t\telse fprintf(stderr, \"Track type: \");\n\n\t\tswitch (import.tk_info[i].type) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tfprintf(stderr, \"Video (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tif (import.tk_info[i].video_info.temporal_enhancement) fprintf(stderr, \" Temporal Enhancement\");\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            fprintf(stderr, \"Auxiliary Video (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            fprintf(stderr, \"Picture Sequence (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n            break;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tfprintf(stderr, \"Audio (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\tfprintf(stderr, \"Text (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tfprintf(stderr, \"Scene (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tfprintf(stderr, \"OD (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_META:\n\t\t\tfprintf(stderr, \"Metadata (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Other (4CC: %s)\", gf_4cc_to_str(import.tk_info[i].type));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (import.tk_info[i].lang) fprintf(stderr, \" - lang %s\", gf_4cc_to_str(import.tk_info[i].lang));\n\n\t\tif (import.tk_info[i].mpeg4_es_id) fprintf(stderr, \" - MPEG-4 ESID %d\", import.tk_info[i].mpeg4_es_id);\n\n\t\tif (import.tk_info[i].prog_num) {\n\t\t\tif (!import.nb_progs) {\n\t\t\t\tfprintf(stderr, \" - Program %d\", import.tk_info[i].prog_num);\n\t\t\t} else {\n\t\t\t\tu32 j;\n\t\t\t\tfor (j=0; j<import.nb_progs; j++) {\n\t\t\t\t\tif (import.tk_info[i].prog_num != import.pg_info[j].number) continue;\n\t\t\t\t\tfprintf(stderr, \" - Program %s\", import.pg_info[j].name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t\tif (!trackID) continue;\n\n\n\t\tif (gf_isom_is_video_subtype(import.tk_info[i].type) && import.tk_info[i].video_info.width && import.tk_info[i].video_info.height\n\t\t   ) {\n\t\t\tfprintf(stderr, \"Source: %s %dx%d\", gf_4cc_to_str(import.tk_info[i].media_type), import.tk_info[i].video_info.width, import.tk_info[i].video_info.height);\n\t\t\tif (import.tk_info[i].video_info.FPS) fprintf(stderr, \" @ %g FPS\", import.tk_info[i].video_info.FPS);\n\t\t\tif (import.tk_info[i].video_info.par) fprintf(stderr, \" PAR: %d:%d\", import.tk_info[i].video_info.par >> 16, import.tk_info[i].video_info.par & 0xFFFF);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\telse if ((import.tk_info[i].type==GF_ISOM_MEDIA_AUDIO) && import.tk_info[i].audio_info.sample_rate) {\n\t\t\tfprintf(stderr, \"Source: %s - SampleRate %d - %d channels\\n\", gf_4cc_to_str(import.tk_info[i].media_type), import.tk_info[i].audio_info.sample_rate, import.tk_info[i].audio_info.nb_channels);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Source: %s\\n\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t}\n\n\n\t\tfprintf(stderr, \"\\nImport Capabilities:\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_USE_DATAREF) fprintf(stderr, \"\\tCan use data referencing\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_NO_FRAME_DROP) fprintf(stderr, \"\\tCan use fixed FPS import\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_FORCE_PACKED) fprintf(stderr, \"\\tCan force packed bitstream import\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_OVERRIDE_FPS) fprintf(stderr, \"\\tCan override source frame rate\\n\");\n\t\tif (import.tk_info[i].flags & (GF_IMPORT_SBR_IMPLICIT|GF_IMPORT_SBR_EXPLICIT)) fprintf(stderr, \"\\tCan use AAC-SBR signaling\\n\");\n\t\tif (import.tk_info[i].flags & (GF_IMPORT_PS_IMPLICIT|GF_IMPORT_PS_EXPLICIT)) fprintf(stderr, \"\\tCan use AAC-PS signaling\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_FORCE_MPEG4) fprintf(stderr, \"\\tCan force MPEG-4 Systems signaling\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_3GPP_AGGREGATION) fprintf(stderr, \"\\tCan use 3GPP frame aggregation\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_NO_DURATION) fprintf(stderr, \"\\tCannot use duration-based import\\n\");\n\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"\\n\");\n\tif (!found && trackID) fprintf(stderr, \"Cannot find track %d in file\\n\", trackID);\n}\n\nstatic void set_chapter_track(GF_ISOFile *file, u32 track, u32 chapter_ref_trak)\n{\n\tu64 ref_duration, chap_duration;\n\tDouble scale;\n\n\tgf_isom_set_track_reference(file, chapter_ref_trak, GF_ISOM_REF_CHAP, gf_isom_get_track_id(file, track) );\n\tgf_isom_set_track_enabled(file, track, 0);\n\n\tref_duration = gf_isom_get_media_duration(file, chapter_ref_trak);\n\tchap_duration = gf_isom_get_media_duration(file, track);\n\tscale = (Double) (s64) gf_isom_get_media_timescale(file, track);\n\tscale /= gf_isom_get_media_timescale(file, chapter_ref_trak);\n\tref_duration = (u64) (ref_duration * scale);\n\n\tif (chap_duration < ref_duration) {\n\t\tchap_duration -= gf_isom_get_sample_duration(file, track, gf_isom_get_sample_count(file, track));\n\t\tchap_duration = ref_duration - chap_duration;\n\t\tgf_isom_set_last_sample_duration(file, track, (u32) chap_duration);\n\t}\n}\n\nGF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, Double force_fps, u32 frames_per_sample)\n{\n\tu32 track_id, i, j, timescale, track, stype, profile, level, new_timescale, rescale, svc_mode, txt_flags, split_tile_mode, temporal_mode;\n\ts32 par_d, par_n, prog_id, delay, force_rate;\n\ts32 tw, th, tx, ty, txtw, txth, txtx, txty;\n\tBool do_audio, do_video, do_auxv,do_pict, do_all, disable, track_layout, text_layout, chap_ref, is_chap, is_chap_file, keep_handler, negative_cts_offset, rap_only, refs_only;\n\tu32 group, handler, rvc_predefined, check_track_for_svc, check_track_for_lhvc, check_track_for_hevc;\n\tconst char *szLan;\n\tGF_Err e;\n\tGF_MediaImporter import;\n\tchar *ext, szName[1000], *handler_name, *rvc_config, *chapter_name;\n\tGF_List *kinds;\n\tGF_TextFlagsMode txt_mode = GF_ISOM_TEXT_FLAGS_OVERWRITE;\n\tu8 max_layer_id_plus_one, max_temporal_id_plus_one;\n\n\trvc_predefined = 0;\n\tchapter_name = NULL;\n\tnew_timescale = 1;\n\trescale = 0;\n\ttext_layout = 0;\n\t/*0: merge all\n\t  1: split base and all SVC in two tracks\n\t  2: split all base and SVC layers in dedicated tracks\n\t */\n\tsvc_mode = 0;\n\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\n\tstrcpy(szName, inName);\n#ifdef WIN32\n\t/*dirty hack for msys&mingw: when we use import options, the ':' separator used prevents msys from translating the path\n\twe do this for regular cases where the path starts with the drive letter. If the path start with anything else (/home , /opt, ...) we're screwed :( */\n\tif ( (szName[0]=='/') && (szName[2]=='/')) {\n\t\tszName[0] = szName[1];\n\t\tszName[1] = ':';\n\t}\n#endif\n\n\tis_chap_file = 0;\n\thandler = 0;\n\tdisable = 0;\n\tchap_ref = 0;\n\tis_chap = 0;\n\tkinds = gf_list_new();\n\ttrack_layout = 0;\n\tszLan = NULL;\n\tdelay = 0;\n\tgroup = 0;\n\tstype = 0;\n\tprofile = level = 0;\n\tnegative_cts_offset = 0;\n\tsplit_tile_mode = 0;\n\ttemporal_mode = 0;\n\trap_only = 0;\n\trefs_only = 0;\n\ttxt_flags = 0;\n\tmax_layer_id_plus_one = max_temporal_id_plus_one = 0;\n\tforce_rate = -1;\n\n\ttw = th = tx = ty = txtw = txth = txtx = txty = 0;\n\tpar_d = par_n = -2;\n\t/*use ':' as separator, but beware DOS paths...*/\n\text = strchr(szName, ':');\n\tif (ext && ext[1]=='\\\\') ext = strchr(szName+2, ':');\n\n\thandler_name = NULL;\n\trvc_config = NULL;\n\twhile (ext) {\n\t\tchar *ext2 = strchr(ext+1, ':');\n\n\t\t// if the colon is part of a file path/url we keep it\n\t\tif (ext2 && !strncmp(ext2, \"://\", 3) ) {\n\t\t\text2[0] = ':';\n\t\t\text2 = strchr(ext2+1, ':');\n\t\t}\n\n\t\t// keep windows drive: path, can be after a file://\n\t\tif (ext2 && ( !strncmp(ext2, \":\\\\\", 2) || !strncmp(ext2, \":/\", 2) ) ) {\n\t\t\text2[0] = ':';\n\t\t\text2 = strchr(ext2+1, ':');\n\t\t}\n\n\t\tif (ext2) ext2[0] = 0;\n\n\t\t/*all extensions for track-based importing*/\n\t\tif (!strnicmp(ext+1, \"dur=\", 4)) import.duration = (u32)( (atof(ext+5) * 1000) + 0.5 );\n\t\telse if (!strnicmp(ext+1, \"lang=\", 5)) {\n\t\t\t/* prevent leak if param is set twice */\n\t\t\tif (szLan)\n\t\t\t\tgf_free((char*) szLan);\n\n\t\t\tszLan = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"delay=\", 6)) delay = atoi(ext+7);\n\t\telse if (!strnicmp(ext+1, \"par=\", 4)) {\n\t\t\tif (!stricmp(ext+5, \"none\")) {\n\t\t\t\tpar_n = par_d = -1;\n\t\t\t} else {\n\t\t\t\tif (ext2) ext2[0] = ':';\n\t\t\t\tif (ext2) ext2 = strchr(ext2+1, ':');\n\t\t\t\tif (ext2) ext2[0] = 0;\n\t\t\t\tsscanf(ext+5, \"%d:%d\", &par_n, &par_d);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"name=\", 5)) {\n\t\t\thandler_name = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"ext=\", 4)) {\n\t\t\t/*extensions begin with '.'*/\n\t\t\tif (*(ext+5) == '.')\n\t\t\t\timport.force_ext = gf_strdup(ext+5);\n\t\t\telse {\n\t\t\t\timport.force_ext = gf_calloc(1+strlen(ext+5)+1, 1);\n\t\t\t\timport.force_ext[0] = '.';\n\t\t\t\tstrcat(import.force_ext+1, ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"hdlr=\", 5)) handler = GF_4CC(ext[6], ext[7], ext[8], ext[9]);\n\t\telse if (!strnicmp(ext+1, \"disable\", 7)) disable = 1;\n\t\telse if (!strnicmp(ext+1, \"group=\", 6)) {\n\t\t\tgroup = atoi(ext+7);\n\t\t\tif (!group) group = gf_isom_get_next_alternate_group_id(dest);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fps=\", 4)) {\n\t\t\tif (!strcmp(ext+5, \"auto\")) force_fps = GF_IMPORT_AUTO_FPS;\n\t\t\telse if (strchr(ext+5, '-')) {\n\t\t\t\tu32 ticks, dts_inc;\n\t\t\t\tsscanf(ext+5, \"%u-%u\", &ticks, &dts_inc);\n\t\t\t\tif (!dts_inc) dts_inc=1;\n\t\t\t\tforce_fps = ticks;\n\t\t\t\tforce_fps /= dts_inc;\n\t\t\t}\n\t\t\telse force_fps = atof(ext+5);\n\t\t}\n\t\telse if (!stricmp(ext+1, \"rap\")) rap_only = 1;\n\t\telse if (!stricmp(ext+1, \"refs\")) refs_only = 1;\n\t\telse if (!stricmp(ext+1, \"trailing\")) import_flags |= GF_IMPORT_KEEP_TRAILING;\n\t\telse if (!strnicmp(ext+1, \"agg=\", 4)) frames_per_sample = atoi(ext+5);\n\t\telse if (!stricmp(ext+1, \"dref\")) import_flags |= GF_IMPORT_USE_DATAREF;\n\t\telse if (!stricmp(ext+1, \"keep_refs\")) import_flags |= GF_IMPORT_KEEP_REFS;\n\t\telse if (!stricmp(ext+1, \"nodrop\")) import_flags |= GF_IMPORT_NO_FRAME_DROP;\n\t\telse if (!stricmp(ext+1, \"packed\")) import_flags |= GF_IMPORT_FORCE_PACKED;\n\t\telse if (!stricmp(ext+1, \"sbr\")) import_flags |= GF_IMPORT_SBR_IMPLICIT;\n\t\telse if (!stricmp(ext+1, \"sbrx\")) import_flags |= GF_IMPORT_SBR_EXPLICIT;\n\t\telse if (!stricmp(ext+1, \"ovsbr\")) import_flags |= GF_IMPORT_OVSBR;\n\t\telse if (!stricmp(ext+1, \"ps\")) import_flags |= GF_IMPORT_PS_IMPLICIT;\n\t\telse if (!stricmp(ext+1, \"psx\")) import_flags |= GF_IMPORT_PS_EXPLICIT;\n\t\telse if (!stricmp(ext+1, \"mpeg4\")) import_flags |= GF_IMPORT_FORCE_MPEG4;\n\t\telse if (!stricmp(ext+1, \"nosei\")) import_flags |= GF_IMPORT_NO_SEI;\n\t\telse if (!stricmp(ext+1, \"svc\") || !stricmp(ext+1, \"lhvc\") ) import_flags |= GF_IMPORT_SVC_EXPLICIT;\n\t\telse if (!stricmp(ext+1, \"nosvc\") || !stricmp(ext+1, \"nolhvc\")) import_flags |= GF_IMPORT_SVC_NONE;\n\n\t\t/*split SVC layers*/\n\t\telse if (!strnicmp(ext+1, \"svcmode=\", 8) || !strnicmp(ext+1, \"lhvcmode=\", 9)) {\n\t\t\tchar *mode = ext+9;\n\t\t\tif (mode[0]=='=') mode = ext+10;\n\n\t\t\tif (!stricmp(mode, \"splitnox\"))\n\t\t\t\tsvc_mode = 3;\n\t\t\telse if (!stricmp(mode, \"splitnoxib\"))\n\t\t\t\tsvc_mode = 4;\n\t\t\telse if (!stricmp(mode, \"splitall\") || !stricmp(mode, \"split\"))\n\t\t\t\tsvc_mode = 2;\n\t\t\telse if (!stricmp(mode, \"splitbase\"))\n\t\t\t\tsvc_mode = 1;\n\t\t\telse if (!stricmp(mode, \"merged\"))\n\t\t\t\tsvc_mode = 0;\n\t\t}\n\t\t/*split SVC layers*/\n\t\telse if (!strnicmp(ext+1, \"temporal=\", 9)) {\n\t\t\tchar *mode = ext+10;\n\t\t\tif (!stricmp(mode, \"split\"))\n\t\t\t\ttemporal_mode = 2;\n\t\t\telse if (!stricmp(mode, \"splitnox\"))\n\t\t\t\ttemporal_mode = 3;\n\t\t\telse if (!stricmp(mode, \"splitbase\"))\n\t\t\t\ttemporal_mode = 1;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Unrecognized temporal mode %s, ignoring\\n\", mode);\n\t\t\t\ttemporal_mode = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"subsamples\")) import_flags |= GF_IMPORT_SET_SUBSAMPLES;\n\t\telse if (!stricmp(ext+1, \"deps\")) import_flags |= GF_IMPORT_SAMPLE_DEPS;\n\t\telse if (!stricmp(ext+1, \"forcesync\")) import_flags |= GF_IMPORT_FORCE_SYNC;\n\t\telse if (!stricmp(ext+1, \"xps_inband\")) import_flags |= GF_IMPORT_FORCE_XPS_INBAND;\n\t\telse if (!strnicmp(ext+1, \"max_lid=\", 8) || !strnicmp(ext+1, \"max_tid=\", 8)) {\n\t\t\ts32 val = atoi(ext+9);\n\t\t\tif (val < 0) {\n\t\t\t\tfprintf(stderr, \"Warning: request max layer/temporal id is negative - ignoring\\n\");\n\t\t\t} else {\n\t\t\t\tif (!strnicmp(ext+1, \"max_lid=\", 8))\n\t\t\t\t\tmax_layer_id_plus_one = 1 + (u8) val;\n\t\t\t\telse\n\t\t\t\t\tmax_temporal_id_plus_one = 1 + (u8) val;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"tiles\")) split_tile_mode = 2;\n\t\telse if (!stricmp(ext+1, \"tiles_rle\")) split_tile_mode = 3;\n\t\telse if (!stricmp(ext+1, \"split_tiles\")) split_tile_mode = 1;\n\n\t\t/*force all composition offsets to be positive*/\n\t\telse if (!strnicmp(ext+1, \"negctts\", 7)) negative_cts_offset = 1;\n\t\telse if (!strnicmp(ext+1, \"stype=\", 6)) {\n\t\t\tstype = GF_4CC(ext[7], ext[8], ext[9], ext[10]);\n\t\t}\n\t\telse if (!stricmp(ext+1, \"chap\")) is_chap = 1;\n\t\telse if (!strnicmp(ext+1, \"chapter=\", 8)) {\n\t\t\tchapter_name = gf_strdup(ext+9);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"chapfile=\", 9)) {\n\t\t\tchapter_name = gf_strdup(ext+10);\n\t\t\tis_chap_file=1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"layout=\", 7)) {\n\t\t\tif ( sscanf(ext+8, \"%dx%dx%dx%d\", &tw, &th, &tx, &ty)==4) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t} else if ( sscanf(ext+8, \"%dx%d\", &tw, &th)==2) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t\ttx = ty = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"rescale=\", 8)) {\n\t\t\trescale = atoi(ext+9);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"timescale=\", 10)) {\n\t\t\tnew_timescale = atoi(ext+11);\n\t\t}\n\t\telse if (!stricmp(ext+1, \"noedit\")) import_flags |= GF_IMPORT_NO_EDIT_LIST;\n\n\n\t\telse if (!strnicmp(ext+1, \"rvc=\", 4)) {\n\t\t\tif (sscanf(ext+5, \"%d\", &rvc_predefined) != 1) {\n\t\t\t\trvc_config = gf_strdup(ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fmt=\", 4)) import.streamFormat = gf_strdup(ext+5);\n\t\telse if (!strnicmp(ext+1, \"profile=\", 8)) profile = atoi(ext+9);\n\t\telse if (!strnicmp(ext+1, \"level=\", 6)) level = atoi(ext+7);\n\t\telse if (!strnicmp(ext+1, \"novpsext\", 8)) import_flags |= GF_IMPORT_NO_VPS_EXTENSIONS;\n\t\telse if (!strnicmp(ext+1, \"keepav1t\", 8)) import_flags |= GF_IMPORT_KEEP_AV1_TEMPORAL_OBU;\n\n\t\telse if (!strnicmp(ext+1, \"font=\", 5)) import.fontName = gf_strdup(ext+6);\n\t\telse if (!strnicmp(ext+1, \"size=\", 5)) import.fontSize = atoi(ext+6);\n\t\telse if (!strnicmp(ext+1, \"text_layout=\", 12)) {\n\t\t\tif ( sscanf(ext+13, \"%dx%dx%dx%d\", &txtw, &txth, &txtx, &txty)==4) {\n\t\t\t\ttext_layout = 1;\n\t\t\t} else if ( sscanf(ext+8, \"%dx%d\", &txtw, &txth)==2) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t\ttxtx = txty = 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\telse if (!stricmp(ext+1, \"swf-global\")) import.swf_flags |= GF_SM_SWF_STATIC_DICT;\n\t\telse if (!stricmp(ext+1, \"swf-no-ctrl\")) import.swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE;\n\t\telse if (!stricmp(ext+1, \"swf-no-text\")) import.swf_flags |= GF_SM_SWF_NO_TEXT;\n\t\telse if (!stricmp(ext+1, \"swf-no-font\")) import.swf_flags |= GF_SM_SWF_NO_FONT;\n\t\telse if (!stricmp(ext+1, \"swf-no-line\")) import.swf_flags |= GF_SM_SWF_NO_LINE;\n\t\telse if (!stricmp(ext+1, \"swf-no-grad\")) import.swf_flags |= GF_SM_SWF_NO_GRADIENT;\n\t\telse if (!stricmp(ext+1, \"swf-quad\")) import.swf_flags |= GF_SM_SWF_QUAD_CURVE;\n\t\telse if (!stricmp(ext+1, \"swf-xlp\")) import.swf_flags |= GF_SM_SWF_SCALABLE_LINE;\n\t\telse if (!stricmp(ext+1, \"swf-ic2d\")) import.swf_flags |= GF_SM_SWF_USE_IC2D;\n\t\telse if (!stricmp(ext+1, \"swf-same-app\")) import.swf_flags |= GF_SM_SWF_REUSE_APPEARANCE;\n\t\telse if (!strnicmp(ext+1, \"swf-flatten=\", 12)) import.swf_flatten_angle = (Float) atof(ext+13);\n#endif\n\n\t\telse if (!strnicmp(ext+1, \"kind=\", 5)) {\n\t\t\tchar *kind_scheme, *kind_value;\n\t\t\tchar *kind_data = ext+6;\n\t\t\tchar *sep = strchr(kind_data, '=');\n\t\t\tif (sep) {\n\t\t\t\t*sep = 0;\n\t\t\t}\n\t\t\tkind_scheme = gf_strdup(kind_data);\n\t\t\tif (sep) {\n\t\t\t\t*sep = '=';\n\t\t\t\tkind_value = gf_strdup(sep+1);\n\t\t\t} else {\n\t\t\t\tkind_value = NULL;\n\t\t\t}\n\t\t\tgf_list_add(kinds, kind_scheme);\n\t\t\tgf_list_add(kinds, kind_value);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"txtflags\", 8)) {\n\t\t\tif (!strnicmp(ext+1, \"txtflags=\", 9)) {\n\t\t\t\tsscanf(ext+10, \"%x\", &txt_flags);\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, \"txtflags+=\", 10)) {\n\t\t\t\tsscanf(ext+11, \"%x\", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_TOGGLE;\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, \"txtflags-=\", 10)) {\n\t\t\t\tsscanf(ext+11, \"%x\", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_UNTOGGLE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"rate=\", 5)) {\n\t\t\tforce_rate = atoi(ext+6);\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"asemode=\", 8)){\n\t\t\tchar *mode = ext+9;\n\t\t\tif (!stricmp(mode, \"v0-bs\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS;\n\t\t\telse if (!stricmp(mode, \"v0-2\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2;\n\t\t\telse if (!stricmp(mode, \"v1\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG;\n\t\t\telse if (!stricmp(mode, \"v1-qt\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"audio_roll=\", 11)) {\n\t\t\timport.audio_roll_change = GF_TRUE;\n\t\t\timport.audio_roll = atoi(ext+12);\n\t\t}\n\n\t\t/*unrecognized, assume name has colon in it*/\n\t\telse {\n\t\t\tfprintf(stderr, \"Unrecognized import option %s, ignoring\\n\", ext+1);\n\t\t\text = ext2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ext2) ext2[0] = ':';\n\n\t\text[0] = 0;\n\n\t\t/* restart from where we stopped\n\t\t * if we didn't stop (ext2 null) then the end has been reached\n\t\t * so we can stop the whole thing */\n\t\text = ext2;\n\t}\n\n\t/*check duration import (old syntax)*/\n\text = strrchr(szName, '%');\n\tif (ext) {\n\t\timport.duration = (u32) (atof(ext+1) * 1000);\n\t\text[0] = 0;\n\t}\n\n\t/*select switches for av containers import*/\n\tdo_audio = do_video = do_auxv = do_pict = 0;\n\ttrack_id = prog_id = 0;\n\tdo_all = 1;\n\text = strrchr(szName, '#');\n\tif (ext) ext[0] = 0;\n\n\tkeep_handler = gf_isom_probe_file(szName);\n\n\timport.in_name = szName;\n\timport.flags = GF_IMPORT_PROBE_ONLY;\n\te = gf_media_import(&import);\n\tif (e) goto exit;\n\n\tif (ext) {\n\t\text++;\n\t\tif (!strnicmp(ext, \"audio\", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, \"video\", 5)) do_video = 1;\n        else if (!strnicmp(ext, \"auxv\", 4)) do_auxv = 1;\n        else if (!strnicmp(ext, \"pict\", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, \"trackID=\", 8)) track_id = atoi(&ext[8]);\n\t\telse if (!strnicmp(ext, \"PID=\", 4)) track_id = atoi(&ext[4]);\n\t\telse if (!strnicmp(ext, \"program=\", 8)) {\n\t\t\tfor (i=0; i<import.nb_progs; i++) {\n\t\t\t\tif (!stricmp(import.pg_info[i].name, ext+8)) {\n\t\t\t\t\tprog_id = import.pg_info[i].number;\n\t\t\t\t\tdo_all = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext, \"prog_id=\", 8)) {\n\t\t\tprog_id = atoi(ext+8);\n\t\t\tdo_all = 0;\n\t\t}\n\t\telse track_id = atoi(ext);\n\t}\n\tif (do_audio || do_video || do_auxv || do_pict || track_id) do_all = 0;\n\n\tif (track_layout || is_chap) {\n\t\tu32 w, h, sw, sh, fw, fh, i;\n\t\tw = h = sw = sh = fw = fh = 0;\n\t\tchap_ref = 0;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n            case GF_ISOM_MEDIA_AUXV:\n            case GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\n\t\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &sw, &sh);\n\t\t\t\tgf_isom_get_track_layout_info(dest, i+1, &fw, &fh, NULL, NULL, NULL);\n\t\t\t\tif (w<sw) w = sw;\n\t\t\t\tif (w<fw) w = fw;\n\t\t\t\tif (h<sh) h = sh;\n\t\t\t\tif (h<fh) h = fh;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (track_layout) {\n\t\t\tif (!tw) tw = w;\n\t\t\tif (!th) th = h;\n\t\t\tif (ty==-1) ty = (h>(u32)th) ? h-th : 0;\n\t\t\timport.text_width = tw;\n\t\t\timport.text_height = th;\n\t\t}\n\t\tif (is_chap && chap_ref) import_flags |= GF_IMPORT_NO_TEXT_FLUSH;\n\t}\n\tif (text_layout && txtw && txth) {\n\t\timport.text_track_width = import.text_width ? import.text_width : txtw;\n\t\timport.text_track_height = import.text_height ? import.text_height : txth;\n\t\timport.text_width = txtw;\n\t\timport.text_height = txth;\n\t\timport.text_x = txtx;\n\t\timport.text_y = txty;\n\t}\n\n\tcheck_track_for_svc = check_track_for_lhvc = check_track_for_hevc = 0;\n\n\timport.dest = dest;\n\timport.video_fps = force_fps;\n\timport.frames_per_sample = frames_per_sample;\n\timport.flags = import_flags;\n\n\tif (!import.nb_tracks) {\n\t\tu32 count, o_count;\n\t\to_count = gf_isom_get_track_count(import.dest);\n\t\te = gf_media_import(&import);\n\t\tif (e) return e;\n\t\tcount = gf_isom_get_track_count(import.dest);\n\t\ttimescale = gf_isom_get_timescale(dest);\n\t\tfor (i=o_count; i<count; i++) {\n\t\t\tif (szLan) gf_isom_set_media_language(import.dest, i+1, (char *) szLan);\n\t\t\tif (delay) {\n\t\t\t\tu64 tk_dur;\n\t\t\t\tgf_isom_remove_edit_segments(import.dest, i+1);\n\t\t\t\ttk_dur = gf_isom_get_track_duration(import.dest, i+1);\n\t\t\t\tif (delay>0) {\n\t\t\t\t\tgf_isom_append_edit_segment(import.dest, i+1, (timescale*delay)/1000, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\tgf_isom_append_edit_segment(import.dest, i+1, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t} else if (delay<0) {\n\t\t\t\t\tu64 to_skip = (timescale*(-delay))/1000;\n\t\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t\t//u64 seg_dur = (-delay)*gf_isom_get_media_timescale(import.dest, i+1) / 1000;\n\t\t\t\t\t\tgf_isom_append_edit_segment(import.dest, i+1, tk_dur-to_skip, to_skip, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Warning: request negative delay longer than track duration - ignoring\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((par_n>=0) && (par_d>=0)) {\n\t\t\t\te = gf_media_change_par(import.dest, i+1, par_n, par_d);\n\t\t\t}\n\n\t\t\tif (rap_only || refs_only) {\n\t\t\t\te = gf_media_remove_non_rap(import.dest, i+1, refs_only);\n\t\t\t}\n\n\t\t\tif (handler_name) gf_isom_set_handler_name(import.dest, i+1, handler_name);\n\t\t\telse if (!keep_handler) {\n\t\t\t\tchar szHName[1024];\n\t\t\t\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\n\t\t\t\tfName = strchr(fName, '.');\n\t\t\t\tif (fName) fName += 1;\n\t\t\t\telse fName = \"?\";\n\n\t\t\t\tsprintf(szHName, \"*%s@GPAC%s\", fName, GPAC_FULL_VERSION);\n\t\t\t\tgf_isom_set_handler_name(import.dest, i+1, szHName);\n\t\t\t}\n\t\t\tif (handler) gf_isom_set_media_type(import.dest, i+1, handler);\n\t\t\tif (disable) gf_isom_set_track_enabled(import.dest, i+1, 0);\n\n\t\t\tif (group) {\n\t\t\t\tgf_isom_set_alternate_group_id(import.dest, i+1, group);\n\t\t\t}\n\t\t\tif (track_layout) {\n\t\t\t\tgf_isom_set_track_layout_info(import.dest, i+1, tw<<16, th<<16, tx<<16, ty<<16, 0);\n\t\t\t}\n\t\t\tif (stype)\n\t\t\t\tgf_isom_set_media_subtype(import.dest, i+1, 1, stype);\n\n\t\t\tif (is_chap && chap_ref) {\n\t\t\t\tset_chapter_track(import.dest, i+1, chap_ref);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\n\t\t\t\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\n\t\t\t\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\n\t\t\t\tgf_isom_add_track_kind(import.dest, i+1, kind_scheme, kind_value);\n\t\t\t}\n\n\t\t\tif (profile || level)\n\t\t\t\tgf_media_change_pl(import.dest, i+1, profile, level);\n\n\t\t\tif (gf_isom_get_media_subtype(import.dest, i+1, 1)== GF_ISOM_BOX_TYPE_MP4S)\n\t\t\t\tkeep_sys_tracks = 1;\n\n\t\t\tgf_isom_set_composition_offset_mode(import.dest, i+1, negative_cts_offset);\n\n\t\t\tif (gf_isom_get_avc_svc_type(import.dest, i+1, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\n\t\t\t\tcheck_track_for_svc = i+1;\n\n\t\t\tswitch (gf_isom_get_hevc_lhvc_type(import.dest, i+1, 1)) {\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\t\tcheck_track_for_lhvc = i+1;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\t\tcheck_track_for_hevc=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (txt_flags) {\n\t\t\t\tgf_isom_text_set_display_flags(import.dest, i+1, 0, txt_flags, txt_mode);\n\t\t\t}\n\n\t\t\tif (force_rate>=0) {\n\t\t\t\tgf_isom_update_bitrate(import.dest, i+1, 1, force_rate, force_rate, 0);\n\t\t\t}\n\n\t\t\tif (split_tile_mode) {\n\t\t\t\tswitch (gf_isom_get_media_subtype(import.dest, i+1, 1)) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsplit_tile_mode = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (do_all)\n\t\t\timport.flags |= GF_IMPORT_KEEP_REFS;\n\n\t\tfor (i=0; i<import.nb_tracks; i++) {\n\t\t\timport.trackID = import.tk_info[i].track_num;\n\t\t\tif (prog_id) {\n\t\t\t\tif (import.tk_info[i].prog_num!=prog_id) continue;\n\t\t\t\te = gf_media_import(&import);\n\t\t\t}\n\t\t\telse if (do_all) e = gf_media_import(&import);\n\t\t\telse if (track_id && (track_id==import.trackID)) {\n\t\t\t\ttrack_id = 0;\n\t\t\t\te = gf_media_import(&import);\n\t\t\t}\n\t\t\telse if (do_audio && (import.tk_info[i].type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\tdo_audio = 0;\n\t\t\t\te = gf_media_import(&import);\n\t\t\t}\n\t\t\telse if (do_video && (import.tk_info[i].type==GF_ISOM_MEDIA_VISUAL)) {\n\t\t\t\tdo_video = 0;\n\t\t\t\te = gf_media_import(&import);\n\t\t\t}\n            else if (do_auxv && (import.tk_info[i].type==GF_ISOM_MEDIA_AUXV)) {\n                do_auxv = 0;\n                e = gf_media_import(&import);\n            }\n            else if (do_pict && (import.tk_info[i].type==GF_ISOM_MEDIA_PICT)) {\n                do_pict = 0;\n                e = gf_media_import(&import);\n            }\n\t\t\telse continue;\n\t\t\tif (e) goto exit;\n\n\t\t\ttimescale = gf_isom_get_timescale(dest);\n\t\t\ttrack = gf_isom_get_track_by_id(import.dest, import.final_trackID);\n\t\t\tif (szLan) gf_isom_set_media_language(import.dest, track, (char *) szLan);\n\t\t\tif (disable) gf_isom_set_track_enabled(import.dest, track, 0);\n\n\t\t\tif (delay) {\n\t\t\t\tu64 tk_dur;\n\t\t\t\tgf_isom_remove_edit_segments(import.dest, track);\n\t\t\t\ttk_dur = gf_isom_get_track_duration(import.dest, track);\n\t\t\t\tif (delay>0) {\n\t\t\t\t\tgf_isom_append_edit_segment(import.dest, track, (timescale*delay)/1000, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\tgf_isom_append_edit_segment(import.dest, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t} else {\n\t\t\t\t\tu64 to_skip = (timescale*(-delay))/1000;\n\t\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t\tu64 media_time = (-delay)*gf_isom_get_media_timescale(import.dest, track) / 1000;\n\t\t\t\t\t\tgf_isom_append_edit_segment(import.dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Warning: request negative delay longer than track duration - ignoring\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gf_isom_is_video_subtype(import.tk_info[i].type) && (par_n>=-1) && (par_d>=-1)) {\n\t\t\t\te = gf_media_change_par(import.dest, track, par_n, par_d);\n\t\t\t}\n\t\t\tif (rap_only || refs_only) {\n\t\t\t\te = gf_media_remove_non_rap(import.dest, track, refs_only);\n\t\t\t}\n\t\t\tif (handler_name) gf_isom_set_handler_name(import.dest, track, handler_name);\n\t\t\telse if (!keep_handler) {\n\t\t\t\tchar szHName[1024];\n\t\t\t\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\n\t\t\t\tfName = strchr(fName, '.');\n\t\t\t\tif (fName) fName += 1;\n\t\t\t\telse fName = \"?\";\n\n\t\t\t\tsprintf(szHName, \"%s@GPAC%s\", fName, GPAC_FULL_VERSION);\n\t\t\t\tgf_isom_set_handler_name(import.dest, track, szHName);\n\t\t\t}\n\t\t\tif (handler) gf_isom_set_media_type(import.dest, track, handler);\n\n\t\t\tif (group) {\n\t\t\t\tgf_isom_set_alternate_group_id(import.dest, track, group);\n\t\t\t}\n\n\t\t\tif (track_layout) {\n\t\t\t\tgf_isom_set_track_layout_info(import.dest, track, tw<<16, th<<16, tx<<16, ty<<16, 0);\n\t\t\t}\n\t\t\tif (stype)\n\t\t\t\tgf_isom_set_media_subtype(import.dest, track, 1, stype);\n\n\t\t\tif (is_chap && chap_ref) {\n\t\t\t\tset_chapter_track(import.dest, track, chap_ref);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\n\t\t\t\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\n\t\t\t\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\n\t\t\t\tgf_isom_add_track_kind(import.dest, i+1, kind_scheme, kind_value);\n\t\t\t}\n\n\t\t\tif (profile || level)\n\t\t\t\tgf_media_change_pl(import.dest, track, profile, level);\n\n\t\t\tif (gf_isom_get_mpeg4_subtype(import.dest, track, 1))\n\t\t\t\tkeep_sys_tracks = 1;\n\n\t\t\tif (new_timescale>1) {\n\t\t\t\tgf_isom_set_media_timescale(import.dest, track, new_timescale, 0);\n\t\t\t}\n\n\t\t\tif (rescale>1) {\n\t\t\t\tswitch (gf_isom_get_media_type(import.dest, track)) {\n\t\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\t\tfprintf(stderr, \"Cannot force media timescale for audio media types - ignoring\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgf_isom_set_media_timescale(import.dest, track, rescale, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rvc_config) {\n\t\t\t\tFILE *f = gf_fopen(rvc_config, \"rb\");\n\t\t\t\tif (f) {\n\t\t\t\t\tchar *data;\n\t\t\t\t\tu32 size;\n\t\t\t\t\tsize_t read;\n\t\t\t\t\tgf_fseek(f, 0, SEEK_END);\n\t\t\t\t\tsize = (u32) gf_ftell(f);\n\t\t\t\t\tgf_fseek(f, 0, SEEK_SET);\n\t\t\t\t\tdata = gf_malloc(sizeof(char)*size);\n\t\t\t\t\tread = fread(data, 1, size, f);\n\t\t\t\t\tgf_fclose(f);\n\t\t\t\t\tif (read != size) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: could not read rvc config from %s\\n\", rvc_config);\n\t\t\t\t\t\te = GF_IO_ERR;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n#ifdef GPAC_DISABLE_ZLIB\n\t\t\t\t\tfprintf(stderr, \"Error: no zlib support - RVC not available\\n\");\n\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\tgoto exit;\n#else\n\t\t\t\t\tgf_gz_compress_payload(&data, size, &size);\n#endif\n\t\t\t\t\tgf_isom_set_rvc_config(import.dest, track, 1, 0, \"application/rvc-config+xml+gz\", data, size);\n\t\t\t\t\tgf_free(data);\n\t\t\t\t}\n\t\t\t} else if (rvc_predefined>0) {\n\t\t\t\tgf_isom_set_rvc_config(import.dest, track, 1, rvc_predefined, NULL, NULL, 0);\n\t\t\t}\n\n\t\t\tgf_isom_set_composition_offset_mode(import.dest, track, negative_cts_offset);\n\n\t\t\tif (gf_isom_get_avc_svc_type(import.dest, track, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\n\t\t\t\tcheck_track_for_svc = track;\n\n\t\t\tswitch (gf_isom_get_hevc_lhvc_type(import.dest, track, 1)) {\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\t\tcheck_track_for_lhvc = i+1;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\t\tcheck_track_for_hevc=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (txt_flags) {\n\t\t\t\tgf_isom_text_set_display_flags(import.dest, track, 0, txt_flags, txt_mode);\n\t\t\t}\n\t\t\tif (force_rate>=0) {\n\t\t\t\tgf_isom_update_bitrate(import.dest, i+1, 1, force_rate, force_rate, 0);\n\t\t\t}\n\n\t\t\tif (split_tile_mode) {\n\t\t\t\tswitch (gf_isom_get_media_subtype(import.dest, track, 1)) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsplit_tile_mode = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (track_id) fprintf(stderr, \"WARNING: Track ID %d not found in file\\n\", track_id);\n\t\telse if (do_video) fprintf(stderr, \"WARNING: Video track not found\\n\");\n        else if (do_auxv) fprintf(stderr, \"WARNING: Auxiliary Video track not found\\n\");\n        else if (do_pict) fprintf(stderr, \"WARNING: Picture sequence track not found\\n\");\n\t\telse if (do_audio) fprintf(stderr, \"WARNING: Audio track not found\\n\");\n\t}\n\n\tif (chapter_name) {\n\t\tif (is_chap_file) {\n\t\t\te = gf_media_import_chapters(import.dest, chapter_name, 0);\n\t\t} else {\n\t\t\te = gf_isom_add_chapter(import.dest, 0, 0, chapter_name);\n\t\t}\n\t}\n\n\t/*force to rewrite all dependencies*/\n\tfor (i = 1; i <= gf_isom_get_track_count(import.dest); i++)\n\t{\n\t\te = gf_isom_rewrite_track_dependencies(import.dest, i);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Warning: track ID %d has references to a track not imported\\n\", gf_isom_get_track_id(import.dest, i) ));\n\t\t\te = GF_OK;\n\t\t}\n\t}\n\n\tif (max_layer_id_plus_one || max_temporal_id_plus_one) {\n\t\tfor (i = 1; i <= gf_isom_get_track_count(import.dest); i++)\n\t\t{\n\t\t\te = gf_media_filter_hevc(import.dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \"Warning: track ID %d: error while filtering LHVC layers\\n\", gf_isom_get_track_id(import.dest, i));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (check_track_for_svc) {\n\t\tif (svc_mode) {\n\t\t\te = gf_media_split_svc(import.dest, check_track_for_svc, (svc_mode==2) ? 1 : 0);\n\t\t\tif (e) goto exit;\n\t\t} else {\n\t\t\te = gf_media_merge_svc(import.dest, check_track_for_svc, 1);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_HEVC\n\tif (check_track_for_lhvc) {\n\t\tif (svc_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = GF_LHVC_EXTRACTORS_ON;\n\t\t\tif (svc_mode==3) xmode = GF_LHVC_EXTRACTORS_OFF;\n\t\t\telse if (svc_mode==4) xmode = GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND;\n\t\t\te = gf_media_split_lhvc(import.dest, check_track_for_lhvc, GF_FALSE, (svc_mode==1) ? 0 : 1, xmode );\n\t\t\tif (e) goto exit;\n\t\t} else {\n\t\t\t//TODO - merge, temporal sublayers\n\t\t}\n\t}\n\tif (check_track_for_hevc) {\n\t\tif (split_tile_mode) {\n\t\t\te = gf_media_split_hevc_tiles(import.dest, split_tile_mode - 1);\n\t\t\tif (e) goto exit;\n\t\t}\n\t\tif (temporal_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = (temporal_mode==3) ? GF_LHVC_EXTRACTORS_OFF : GF_LHVC_EXTRACTORS_ON;\n\t\t\te = gf_media_split_lhvc(import.dest, check_track_for_hevc, GF_TRUE, (temporal_mode==1) ? GF_FALSE : GF_TRUE, xmode );\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\n#endif /*GPAC_DISABLE_HEVC*/\n\nexit:\n\twhile (gf_list_count(kinds)) {\n\t\tchar *kind = (char *)gf_list_get(kinds, 0);\n\t\tgf_list_rem(kinds, 0);\n\t\tif (kind) gf_free(kind);\n\t}\n\tgf_list_del(kinds);\n\tif (handler_name) gf_free(handler_name);\n\tif (chapter_name ) gf_free(chapter_name);\n\tif (import.fontName) gf_free(import.fontName);\n\tif (import.streamFormat) gf_free(import.streamFormat);\n\tif (import.force_ext) gf_free(import.force_ext);\n\tif (rvc_config) gf_free(rvc_config);\n\tif (szLan) gf_free((char *)szLan);\n\treturn e;\n}\n\ntypedef struct\n{\n\tu32 tk;\n\tBool has_non_raps;\n\tu32 last_sample;\n\tu32 sample_count;\n\tu32 time_scale;\n\tu64 firstDTS, lastDTS;\n\tu32 dst_tk;\n\t/*set if media can be duplicated at split boundaries - only used for text tracks and provate tracks, this assumes all\n\tsamples are RAP*/\n\tBool can_duplicate;\n\t/*controls import by time rather than by sample (otherwise we would have to remove much more samples video vs audio for example*/\n\tBool first_sample_done;\n\tBool next_sample_is_rap;\n\tu32 stop_state;\n} TKInfo;\n\nGF_Err split_isomedia_file(GF_ISOFile *mp4, Double split_dur, u64 split_size_kb, char *inName, Double InterleavingTime, Double chunk_start_time, Bool adjust_split_end, char *outName, const char *tmpdir)\n{\n\tu32 i, count, nb_tk, needs_rap_sync, cur_file, conv_type, nb_tk_done, nb_samp, nb_done, di;\n\tDouble max_dur, cur_file_time;\n\tBool do_add, all_duplicatable, size_exceeded, chunk_extraction, rap_split, split_until_end;\n\tGF_ISOFile *dest;\n\tGF_ISOSample *samp;\n\tGF_Err e;\n\tTKInfo *tks, *tki;\n\tchar *ext, szName[1000], szFile[1000];\n\tDouble chunk_start = (Double) chunk_start_time;\n\n\tchunk_extraction = (chunk_start>=0) ? 1 : 0;\n\tsplit_until_end = 0;\n\trap_split = 0;\n\tif (split_size_kb == (u64)-1) rap_split = 1;\n\tif (split_dur == -1) rap_split = 1;\n\telse if (split_dur <= -2) {\n\t\tsplit_size_kb = 0;\n\t\tsplit_until_end = 1;\n\t}\n\n\tif (rap_split) {\n\t\tsplit_size_kb = 0;\n\t\tsplit_dur = (double) GF_MAX_FLOAT;\n\t}\n\n\n\text = strrchr(inName, '/');\n\tif (!ext) ext = strrchr(inName, '\\\\');\n\tstrcpy(szName, ext ? ext+1 : inName);\n\text = strrchr(szName, '.');\n\tif (ext) ext[0] = 0;\n\text = strrchr(inName, '.');\n\n\tdest = NULL;\n\n\tconv_type = 0;\n\tswitch (gf_isom_guess_specification(mp4)) {\n\tcase GF_ISOM_BRAND_ISMA:\n\t\tconv_type = 1;\n\t\tbreak;\n\tcase GF_ISOM_BRAND_3GP4:\n\tcase GF_ISOM_BRAND_3GP5:\n\tcase GF_ISOM_BRAND_3GP6:\n\tcase GF_ISOM_BRAND_3GG6:\n\tcase GF_ISOM_BRAND_3G2A:\n\t\tconv_type = 2;\n\t\tbreak;\n\t}\n\tif (!stricmp(ext, \".3gp\") || !stricmp(ext, \".3g2\")) conv_type = 2;\n\n\tcount = gf_isom_get_track_count(mp4);\n\ttks = (TKInfo *)gf_malloc(sizeof(TKInfo)*count);\n\tmemset(tks, 0, sizeof(TKInfo)*count);\n\n\te = GF_OK;\n\tmax_dur = 0;\n\tnb_tk = 0;\n\tall_duplicatable = 1;\n\tneeds_rap_sync = 0;\n\tnb_samp = 0;\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype;\n\t\tDouble dur;\n\t\ttks[nb_tk].tk = i+1;\n\t\ttks[nb_tk].can_duplicate = 0;\n\n\t\tmtype = gf_isom_get_media_type(mp4, i+1);\n\t\tswitch (mtype) {\n\t\t/*we duplicate text samples at boundaries*/\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\t\ttks[nb_tk].can_duplicate = 1;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\tif (gf_isom_get_sample_count(mp4, i+1)>1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tcase GF_ISOM_MEDIA_FLASH:\n\t\t\tfprintf(stderr, \"WARNING: Track ID %d (type %s) not handled by splitter - skipping\\n\", gf_isom_get_track_id(mp4, i+1), gf_4cc_to_str(mtype));\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/*for all other track types, only split if more than one sample*/\n\t\t\tif (gf_isom_get_sample_count(mp4, i+1)==1) {\n\t\t\t\tfprintf(stderr, \"WARNING: Track ID %d (type %s) not handled by splitter - skipping\\n\", gf_isom_get_track_id(mp4, i+1), gf_4cc_to_str(mtype));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttks[nb_tk].can_duplicate = 1;\n\t\t}\n\n\t\ttks[nb_tk].sample_count = gf_isom_get_sample_count(mp4, i+1);\n\t\tnb_samp += tks[nb_tk].sample_count;\n\t\ttks[nb_tk].last_sample = 0;\n\t\ttks[nb_tk].firstDTS = 0;\n\t\ttks[nb_tk].time_scale = gf_isom_get_media_timescale(mp4, i+1);\n\t\ttks[nb_tk].has_non_raps = gf_isom_has_sync_points(mp4, i+1);\n\t\t/*seen that on some 3gp files from nokia ...*/\n\t\tif (mtype==GF_ISOM_MEDIA_AUDIO) tks[nb_tk].has_non_raps = 0;\n\n\t\tdur = (Double) (s64) gf_isom_get_media_duration(mp4, i+1);\n\t\tdur /= tks[nb_tk].time_scale;\n\t\tif (max_dur<dur) max_dur=dur;\n\n\t\tif (tks[nb_tk].has_non_raps) {\n\t\t\t/*we don't support that*/\n\t\t\tif (needs_rap_sync) {\n\t\t\t\tfprintf(stderr, \"More than one track has non-sync points - cannot split file\\n\");\n\t\t\t\tgf_free(tks);\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\tneeds_rap_sync = nb_tk+1;\n\t\t}\n\t\tif (!tks[nb_tk].can_duplicate) all_duplicatable = 0;\n\t\tnb_tk++;\n\t}\n\tif (!nb_tk) {\n\t\tfprintf(stderr, \"No suitable tracks found for splitting file\\n\");\n\t\tgf_free(tks);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (chunk_start>=max_dur) {\n\t\tfprintf(stderr, \"Input file (%f) shorter than requested split start offset (%f)\\n\", max_dur, chunk_start);\n\t\tgf_free(tks);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (split_until_end) {\n\t\tif (split_dur < -2) {\n\t\t\tsplit_dur = - (split_dur + 2 - chunk_start);\n\t\t\tif (max_dur < split_dur) {\n\t\t\t\tfprintf(stderr, \"Split duration till end %lf longer than track duration %lf\\n\", split_dur, max_dur);\n\t\t\t\tgf_free(tks);\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tsplit_dur = max_dur - split_dur;\n\t\t\t}\n\t\t} else {\n\t\t\tsplit_dur = max_dur;\n\t\t}\n\t} else if (!rap_split && (max_dur<=split_dur)) {\n\t\tfprintf(stderr, \"Input file (%f) shorter than requested split duration (%f)\\n\", max_dur, split_dur);\n\t\tgf_free(tks);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (needs_rap_sync) {\n\t\tBool has_enough_sync = GF_FALSE;\n\t\ttki = &tks[needs_rap_sync-1];\n\n\t\tif (chunk_start == 0.0f)\n\t\t\thas_enough_sync = GF_TRUE;\n\t\telse if (gf_isom_get_sync_point_count(mp4, tki->tk) > 1)\n\t\t\thas_enough_sync = GF_TRUE;\n\t\telse if (gf_isom_get_sample_group_info(mp4, tki->tk, 1, GF_ISOM_SAMPLE_GROUP_RAP, NULL, NULL, NULL))\n\t\t\thas_enough_sync = GF_TRUE;\n\t\telse if (gf_isom_get_sample_group_info(mp4, tki->tk, 1, GF_ISOM_SAMPLE_GROUP_SYNC, NULL, NULL, NULL))\n\t\t\thas_enough_sync = GF_TRUE;\n\n\t\tif (!has_enough_sync) {\n\t\t\tfprintf(stderr, \"Not enough Random Access points in input file - cannot split\\n\");\n\t\t\tgf_free(tks);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\tsplit_size_kb *= 1024;\n\tcur_file_time = 0;\n\n\tif (chunk_start>0) {\n\t\tif (needs_rap_sync) {\n\t\t\tu32 sample_num;\n\t\t\tDouble start;\n\t\t\ttki = &tks[needs_rap_sync-1];\n\n\t\t\tstart = (Double) (s64) gf_isom_get_sample_dts(mp4, tki->tk, tki->sample_count);\n\t\t\tstart /= tki->time_scale;\n\t\t\tif (start<chunk_start) {\n\t\t\t\ttki->stop_state = 2;\n\t\t\t} else  {\n\t\t\t\te = gf_isom_get_sample_for_media_time(mp4, tki->tk, (u64) (chunk_start*tki->time_scale), &di, GF_ISOM_SEARCH_SYNC_BACKWARD, &samp, &sample_num);\n\t\t\t\tif (e!=GF_OK) {\n\t\t\t\t\tfprintf(stderr, \"Cannot locate RAP in track ID %d for chunk extraction from %02.2f sec\\n\", gf_isom_get_track_id(mp4, tki->tk), chunk_start);\n\t\t\t\t\tgf_free(tks);\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t\tstart = (Double) (s64) samp->DTS;\n\t\t\t\tstart /= tki->time_scale;\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\tfprintf(stderr, \"Adjusting chunk start time to previous random access at %02.2f sec\\n\", start);\n\t\t\t\tsplit_dur += (chunk_start - start);\n\t\t\t\tchunk_start = start;\n\t\t\t}\n\t\t}\n\t\t/*sync all tracks*/\n\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\ttki = &tks[i];\n\t\t\twhile (tki->last_sample<tki->sample_count) {\n\t\t\t\tDouble time;\n\t\t\t\tu64 dts;\n\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\ttime = (Double) (s64) dts;\n\t\t\t\ttime /= tki->time_scale;\n\t\t\t\tif (time>=chunk_start) {\n\t\t\t\t\t/*rewind one sample (text tracks & co)*/\n\t\t\t\t\tif (tki->can_duplicate && tki->last_sample) {\n\t\t\t\t\t\ttki->last_sample--;\n\t\t\t\t\t\ttki->firstDTS = (u64) (chunk_start*tki->time_scale);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttki->firstDTS = dts;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttki->last_sample++;\n\t\t\t}\n\t\t}\n\t\tcur_file_time = chunk_start;\n\t} else {\n\t\tchunk_start = 0;\n\t}\n\n\tdest = NULL;\n\tnb_done = 0;\n\tnb_tk_done = 0;\n\tcur_file = 0;\n\twhile (nb_tk_done<nb_tk) {\n\t\tDouble last_rap_sample_time, max_dts, file_split_dur;\n\t\tBool is_last_rap;\n\t\tBool all_av_done = GF_FALSE;\n\n\t\tif (chunk_extraction) {\n\t\t\tsprintf(szFile, \"%s_%d_%d%s\", szName, (u32) chunk_start, (u32) (chunk_start+split_dur), ext);\n\t\t\tif (outName) strcpy(szFile, outName);\n\t\t} else {\n\t\t\tsprintf(szFile, \"%s_%03d%s\", szName, cur_file+1, ext);\n\t\t\tif (outName) {\n\t\t\t\tchar *the_file = gf_url_concatenate(outName, szFile);\n\t\t\t\tif (the_file) {\n\t\t\t\t\tstrcpy(szFile, the_file);\n\t\t\t\t\tgf_free(the_file);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdest = gf_isom_open(szFile, GF_ISOM_WRITE_EDIT, tmpdir);\n\t\t/*clone all tracks*/\n\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\ttki = &tks[i];\n\t\t\t/*track done - we remove the track from destination, an empty video track could cause pbs to some players*/\n\t\t\tif (tki->stop_state==2) continue;\n\n\t\t\te = gf_isom_clone_track(mp4, tki->tk, dest, GF_FALSE, &tki->dst_tk);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \"Error cloning track %d\\n\", tki->tk);\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\t/*use non-packet CTS offsets (faster add/remove)*/\n\t\t\tif (gf_isom_has_time_offset(mp4, tki->tk)) {\n\t\t\t\tgf_isom_set_cts_packing(dest, tki->dst_tk, GF_TRUE);\n\t\t\t}\n\t\t\tgf_isom_remove_edit_segments(dest, tki->dst_tk);\n\t\t}\n\t\tdo_add = 1;\n\t\tis_last_rap = 0;\n\t\tlast_rap_sample_time = 0;\n\t\tfile_split_dur = split_dur;\n\n\t\tsize_exceeded = 0;\n\t\tmax_dts = 0;\n\t\twhile (do_add) {\n\t\t\tBool is_rap;\n\t\t\tDouble time;\n\t\t\tu32 nb_over, nb_av = 0;\n\t\t\t/*perfom basic de-interleaving to make sure we're not importing too much of a given track*/\n\t\t\tu32 nb_add = 0;\n\t\t\t/*add one sample of each track*/\n\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\tDouble t;\n\t\t\t\tu64 dts;\n\t\t\t\ttki = &tks[i];\n\n\t\t\t\tif (!tki->can_duplicate) nb_av++;\n\n\t\t\t\tif (tki->stop_state)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tki->last_sample==tki->sample_count)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*get sample info, see if we need to check it (basic de-interleaver)*/\n\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\n\t\t\t\t/*reinsertion (timed text)*/\n\t\t\t\tif (dts < tki->firstDTS) {\n\t\t\t\t\tsamp = gf_isom_get_sample(mp4, tki->tk, tki->last_sample+1, &di);\n\t\t\t\t\tsamp->DTS = 0;\n\t\t\t\t\te = gf_isom_add_sample(dest, tki->dst_tk, di, samp);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\te = gf_isom_copy_sample_info(dest, tki->dst_tk, mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\ttki->last_sample += 1;\n\t\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t}\n\t\t\t\tdts -= tki->firstDTS;\n\n\n\t\t\t\tt = (Double) (s64) dts;\n\t\t\t\tt /= tki->time_scale;\n\t\t\t\tif (tki->first_sample_done) {\n\t\t\t\t\tif (!all_av_done && (t>max_dts)) continue;\n\t\t\t\t} else {\n\t\t\t\t\t/*here's the trick: only take care of a/v media for splitting, and add other media\n\t\t\t\t\tonly if thir dts is less than the max AV dts found. Otherwise with some text streams we will end up importing\n\t\t\t\t\ttoo much video and corrupting the last sync point indication*/\n\t\t\t\t\tif (!tki->can_duplicate && (t>max_dts)) max_dts = t;\n\t\t\t\t\ttki->first_sample_done = 1;\n\t\t\t\t}\n\t\t\t\tsamp = gf_isom_get_sample(mp4, tki->tk, tki->last_sample+1, &di);\n\t\t\t\tsamp->DTS -= tki->firstDTS;\n\n\t\t\t\tnb_add += 1;\n\n\t\t\t\tis_rap = GF_FALSE;\n\t\t\t\tif (samp->IsRAP) {\n\t\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tBool has_roll;\n\t\t\t\t\tgf_isom_get_sample_rap_roll_info(mp4, tki->tk, tki->last_sample+1, &is_rap, &has_roll, NULL);\n\t\t\t\t}\n\n\n\t\t\t\tif (tki->has_non_raps && is_rap) {\n\t\t\t\t\tGF_ISOSample *next_rap;\n\t\t\t\t\tu32 next_rap_num, sdi;\n\t\t\t\t\tlast_rap_sample_time = (Double) (s64) samp->DTS;\n\t\t\t\t\tlast_rap_sample_time /= tki->time_scale;\n\t\t\t\t\te = gf_isom_get_sample_for_media_time(mp4, tki->tk, samp->DTS+tki->firstDTS+2, &sdi, GF_ISOM_SEARCH_SYNC_FORWARD, &next_rap, &next_rap_num);\n\t\t\t\t\tif (e==GF_EOS)\n\t\t\t\t\t\tis_last_rap = 1;\n\t\t\t\t\tif (next_rap) {\n\t\t\t\t\t\tif (!next_rap->IsRAP)\n\t\t\t\t\t\t\tis_last_rap = 1;\n\t\t\t\t\t\tgf_isom_sample_del(&next_rap);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttki->lastDTS = samp->DTS;\n\t\t\t\te = gf_isom_add_sample(dest, tki->dst_tk, di, samp);\n\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\tif (!e) {\n\t\t\t\t\te = gf_isom_copy_sample_info(dest, tki->dst_tk, mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t}\n\t\t\t\ttki->last_sample += 1;\n\t\t\t\tgf_set_progress(\"Splitting\", nb_done, nb_samp);\n\t\t\t\tnb_done++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error cloning track %d sample %d\\n\", tki->tk, tki->last_sample);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\n\t\t\t\ttki->next_sample_is_rap = 0;\n\t\t\t\tif (rap_split && tki->has_non_raps) {\n\t\t\t\t\tif ( gf_isom_get_sample_sync(mp4, tki->tk, tki->last_sample+1))\n\t\t\t\t\t\ttki->next_sample_is_rap = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*test by size/duration*/\n\t\t\tnb_over = 0;\n\n\t\t\t/*test by file size: same as duration test, only dynamically increment import duration*/\n\t\t\tif (split_size_kb) {\n\t\t\t\tu64 est_size = gf_isom_estimate_size(dest);\n\t\t\t\t/*while below desired size keep importing*/\n\t\t\t\tif (est_size<split_size_kb)\n\t\t\t\t\tfile_split_dur = (Double) GF_MAX_FLOAT;\n\t\t\t\telse {\n\t\t\t\t\tsize_exceeded = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\ttki = &tks[i];\n\t\t\t\tif (tki->stop_state) {\n\t\t\t\t\tnb_over++;\n\t\t\t\t\tif (!tki->can_duplicate && (tki->last_sample==tki->sample_count) )\n\t\t\t\t\t\tnb_av--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttime = (Double) (s64) tki->lastDTS;\n\t\t\t\ttime /= tki->time_scale;\n\t\t\t\tif (size_exceeded\n\t\t\t\t        || (tki->last_sample==tki->sample_count)\n\t\t\t\t        || (!tki->can_duplicate && (time>file_split_dur))\n\t\t\t\t        || (rap_split && tki->has_non_raps && tki->next_sample_is_rap)\n\t\t\t\t   ) {\n\t\t\t\t\tnb_over++;\n\t\t\t\t\ttki->stop_state = 1;\n\t\t\t\t\tif (tki->last_sample<tki->sample_count)\n\t\t\t\t\t\tis_last_rap = 0;\n\t\t\t\t\telse if (tki->first_sample_done)\n\t\t\t\t\t\tis_last_rap = 0;\n\n\t\t\t\t\tif (rap_split && tki->next_sample_is_rap) {\n\t\t\t\t\t\tfile_split_dur = (Double) ( gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1) - tki->firstDTS);\n\t\t\t\t\t\tfile_split_dur /= tki->time_scale;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*special tracks (not audio, not video)*/\n\t\t\t\telse if (tki->can_duplicate) {\n\t\t\t\t\tu64 dts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t\ttime = (Double) (s64) (dts - tki->firstDTS);\n\t\t\t\t\ttime /= tki->time_scale;\n\t\t\t\t\tif (time>file_split_dur) {\n\t\t\t\t\t\tnb_over++;\n\t\t\t\t\t\ttki->stop_state = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!nb_add && (!max_dts || (tki->lastDTS <= 1 + (u64) (tki->time_scale*max_dts) )))\n\t\t\t\t\ttki->first_sample_done = 0;\n\t\t\t}\n\t\t\tif (nb_over==nb_tk) do_add = 0;\n\n\t\t\tif (!nb_av)\n\t\t\t\tall_av_done = GF_TRUE;\n\t\t}\n\n\t\t/*remove samples - first figure out smallest duration*/\n\t\tfile_split_dur = (Double) GF_MAX_FLOAT;\n\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\tDouble time;\n\t\t\ttki = &tks[i];\n\t\t\t/*track done*/\n\t\t\tif ((tki->stop_state==2) || (!is_last_rap && (tki->sample_count == tki->last_sample)) ) {\n\t\t\t\tif (tki->has_non_raps) last_rap_sample_time = 0;\n\t\t\t\ttime = (Double) (s64) ( gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1) - tki->firstDTS);\n\t\t\t\ttime /= tki->time_scale;\n\t\t\t\tif (file_split_dur==(Double)GF_MAX_FLOAT || file_split_dur<time) file_split_dur = time;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//if (tki->lastDTS)\n\t\t\t{\n\t\t\t\t//time = (Double) (s64) tki->lastDTS;\n\t\t\t\ttime = (Double) (s64) ( gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1) - tki->firstDTS);\n\t\t\t\ttime /= tki->time_scale;\n\t\t\t\tif ((!tki->can_duplicate || all_duplicatable) && time<file_split_dur) file_split_dur = time;\n\t\t\t\telse if (rap_split && tki->next_sample_is_rap) file_split_dur = time;\n\t\t\t}\n\t\t}\n\t\tif (file_split_dur == (Double) GF_MAX_FLOAT) {\n\t\t\tfprintf(stderr, \"Cannot split file (duration too small or size too small)\\n\");\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (chunk_extraction) {\n\t\t\tif (adjust_split_end) {\n\t\t\t\tfprintf(stderr, \"Adjusting chunk end time to previous random access at %02.2f sec\\n\", chunk_start + last_rap_sample_time);\n\t\t\t\tfile_split_dur = last_rap_sample_time;\n\t\t\t\tif (outName) strcpy(szFile, outName);\n\t\t\t\telse sprintf(szFile, \"%s_%d_%d%s\", szName, (u32) chunk_start, (u32) (chunk_start+file_split_dur), ext);\n\t\t\t\tgf_isom_set_final_name(dest, szFile);\n\t\t\t}\n\t\t\telse file_split_dur = split_dur;\n\t\t}\n\n\t\t/*don't split if eq to copy...*/\n\t\tif (is_last_rap && !cur_file && !chunk_start) {\n\t\t\tfprintf(stderr, \"Cannot split file (Not enough sync samples, duration too large or size too big)\\n\");\n\t\t\tgoto err_exit;\n\t\t}\n\n\n\t\t/*if not last chunk and longer duration adjust to previous RAP point*/\n\t\tif ( (size_exceeded || !split_size_kb) && (file_split_dur>split_dur) && !chunk_start) {\n\t\t\t/*if larger than last RAP, rewind till it*/\n\t\t\tif (last_rap_sample_time && (last_rap_sample_time<file_split_dur) ) {\n\t\t\t\tfile_split_dur = last_rap_sample_time;\n\t\t\t\tis_last_rap = 0;\n\t\t\t}\n\t\t}\n\n\t\tnb_tk_done = 0;\n\t\tif (!is_last_rap || chunk_extraction) {\n\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\tDouble time = 0;\n\t\t\t\tu32 last_samp;\n\t\t\t\ttki = &tks[i];\n\t\t\t\twhile (1) {\n\t\t\t\t\tlast_samp = gf_isom_get_sample_count(dest, tki->dst_tk);\n\n\t\t\t\t\ttime = (Double) (s64) gf_isom_get_media_duration(dest, tki->dst_tk);\n\t\t\t\t\t//time could get slightly higher than requests dur due to rounding precision. We use 1/4 of the last sample dur as safety marge\n\t\t\t\t\ttime -= (Double) (s64) gf_isom_get_sample_duration(dest, tki->dst_tk, tki->last_sample) / 4;\n\t\t\t\t\ttime /= tki->time_scale;\n\n\t\t\t\t\tif (last_samp<=1) break;\n\n\t\t\t\t\t/*done*/\n\t\t\t\t\tif (tki->last_sample==tki->sample_count) {\n\t\t\t\t\t\tif (!chunk_extraction && !tki->can_duplicate) {\n\t\t\t\t\t\t\ttki->stop_state=2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (time <= file_split_dur) break;\n\n\t\t\t\t\tgf_isom_remove_sample(dest, tki->dst_tk, last_samp);\n\t\t\t\t\ttki->last_sample--;\n\t\t\t\t\tassert(tki->last_sample);\n\t\t\t\t\tnb_done--;\n\t\t\t\t\tgf_set_progress(\"Splitting\", nb_done, nb_samp);\n\t\t\t\t}\n\t\t\t\tif (tki->last_sample<tki->sample_count) {\n\t\t\t\t\tu64 dts;\n\t\t\t\t\ttki->stop_state = 0;\n\t\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t\ttime = (Double) (s64) (dts - tki->firstDTS);\n\t\t\t\t\ttime /= tki->time_scale;\n\t\t\t\t\t/*re-insert prev sample*/\n\t\t\t\t\tif (tki->can_duplicate && (time>file_split_dur) ) {\n\t\t\t\t\t\tBool was_insert = GF_FALSE;\n\t\t\t\t\t\ttki->last_sample--;\n\t\t\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t\t\tif (dts < tki->firstDTS) was_insert = GF_TRUE;\n\t\t\t\t\t\ttki->firstDTS += (u64) (file_split_dur*tki->time_scale);\n\t\t\t\t\t\t//the original, last sample added starts before the first sample in the file: we have re-inserted\n\t\t\t\t\t\t//a single sample, use split duration as target duration\n\t\t\t\t\t\tif (was_insert) {\n\t\t\t\t\t\t\tgf_isom_set_last_sample_duration(dest, tki->dst_tk, (u32) (file_split_dur*tki->time_scale));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_isom_set_last_sample_duration(dest, tki->dst_tk, (u32) (tki->firstDTS - dts) );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttki->firstDTS = dts;\n\t\t\t\t\t}\n\t\t\t\t\ttki->first_sample_done = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnb_tk_done++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif (chunk_extraction) {\n\t\t\tfprintf(stderr, \"Extracting chunk %s - duration %02.2fs (%02.2fs->%02.2fs)\\n\", szFile, file_split_dur, chunk_start, (chunk_start+split_dur));\n\t\t} else {\n\t\t\tfprintf(stderr, \"Storing split-file %s - duration %02.2f seconds\\n\", szFile, file_split_dur);\n\t\t}\n\n\t\t/*repack CTSs*/\n\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\tu32 j;\n\t\t\tu64 new_track_dur;\n\t\t\ttki = &tks[i];\n\t\t\tif (tki->stop_state == 2) continue;\n\t\t\tif (!gf_isom_get_sample_count(dest, tki->dst_tk)) {\n\t\t\t\tgf_isom_remove_track(dest, tki->dst_tk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (gf_isom_has_time_offset(mp4, tki->tk)) {\n\t\t\t\tgf_isom_set_cts_packing(dest, tki->dst_tk, GF_FALSE);\n\t\t\t}\n\t\t\tif (is_last_rap && tki->can_duplicate) {\n\t\t\t\tgf_isom_set_last_sample_duration(dest, tki->dst_tk, gf_isom_get_sample_duration(mp4, tki->tk, tki->sample_count));\n\t\t\t}\n\n\t\t\t/*rewrite edit list*/\n\t\t\tnew_track_dur = gf_isom_get_track_duration(dest, tki->dst_tk);\n\t\t\tcount = gf_isom_get_edit_segment_count(mp4, tki->tk);\n\t\t\tif (count>2) {\n\t\t\t\tfprintf(stderr, \"Warning: %d edit segments - not supported while splitting (max 2) - ignoring extra\\n\", count);\n\t\t\t\tcount=2;\n\t\t\t}\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tu64 editTime, segDur, MediaTime;\n\t\t\t\tu8 mode;\n\n\t\t\t\tgf_isom_get_edit_segment(mp4, tki->tk, j+1, &editTime, &segDur, &MediaTime, &mode);\n\t\t\t\tif (!j && (mode!=GF_ISOM_EDIT_EMPTY) ) {\n\t\t\t\t\tfprintf(stderr, \"Warning: Edit list doesn't look like a track delay scheme - ignoring\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mode==GF_ISOM_EDIT_NORMAL) {\n\t\t\t\t\tsegDur = new_track_dur;\n\t\t\t\t}\n\t\t\t\tgf_isom_set_edit_segment(dest, tki->dst_tk, editTime, segDur, MediaTime, mode);\n\t\t\t}\n\t\t}\n\t\t/*check chapters*/\n\t\tdo_add = 1;\n\t\tfor (i=0; i<gf_isom_get_chapter_count(mp4, 0); i++) {\n\t\t\tchar *name;\n\t\t\tu64 chap_time;\n\t\t\tgf_isom_get_chapter(mp4, 0, i+1, &chap_time, (const char **) &name);\n\t\t\tmax_dts = (Double) (s64) chap_time;\n\t\t\tmax_dts /= 1000;\n\t\t\tif (max_dts<cur_file_time) continue;\n\t\t\tif (max_dts>cur_file_time+file_split_dur) break;\n\t\t\tmax_dts-=cur_file_time;\n\t\t\tchap_time = (u64) (max_dts*1000);\n\t\t\tgf_isom_add_chapter(dest, 0, chap_time, name);\n\t\t\t/*add prev*/\n\t\t\tif (do_add && i) {\n\t\t\t\tgf_isom_get_chapter(mp4, 0, i, &chap_time, (const char **) &name);\n\t\t\t\tgf_isom_add_chapter(dest, 0, 0, name);\n\t\t\t\tdo_add = 0;\n\t\t\t}\n\t\t}\n\t\tcur_file_time += file_split_dur;\n\n\t\tif (conv_type==1) gf_media_make_isma(dest, 1, 0, 0);\n\t\telse if (conv_type==2) gf_media_make_3gpp(dest);\n\t\tif (InterleavingTime) {\n\t\t\tgf_isom_make_interleave(dest, InterleavingTime);\n\t\t} else {\n\t\t\tgf_isom_set_storage_mode(dest, GF_ISOM_STORE_STREAMABLE);\n\t\t}\n\n\t\tgf_isom_clone_pl_indications(mp4, dest);\n\t\te = gf_isom_close(dest);\n\t\tdest = NULL;\n\t\tif (e) fprintf(stderr, \"Error storing file %s\\n\", gf_error_to_string(e));\n\t\tif (is_last_rap || chunk_extraction) break;\n\t\tcur_file++;\n\t}\n\tgf_set_progress(\"Splitting\", nb_samp, nb_samp);\nerr_exit:\n\tif (dest) gf_isom_delete(dest);\n\tgf_free(tks);\n\treturn e;\n}\n\nGF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command);\n\nstatic Bool merge_parameter_set(GF_List *src, GF_List *dst, const char *name)\n{\n\tu32 j, k;\n\tfor (j=0; j<gf_list_count(src); j++) {\n\t\tBool found = 0;\n\t\tGF_AVCConfigSlot *slc = gf_list_get(src, j);\n\t\tfor (k=0; k<gf_list_count(dst); k++) {\n\t\t\tGF_AVCConfigSlot *slc_dst = gf_list_get(dst, k);\n\t\t\tif ( (slc->size==slc_dst->size) && !memcmp(slc->data, slc_dst->data, slc->size) ) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nstatic u32 merge_avc_config(GF_ISOFile *dest, u32 tk_id, GF_ISOFile *orig, u32 src_track, Bool force_cat)\n{\n\tGF_AVCConfig *avc_src, *avc_dst;\n\tu32 dst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\n\tavc_src = gf_isom_avc_config_get(orig, src_track, 1);\n\tavc_dst = gf_isom_avc_config_get(dest, dst_tk, 1);\n\n\tif (avc_src->AVCLevelIndication!=avc_dst->AVCLevelIndication) {\n\t\tdst_tk = 0;\n\t} else if (avc_src->AVCProfileIndication!=avc_dst->AVCProfileIndication) {\n\t\tdst_tk = 0;\n\t}\n\telse {\n\t\t/*rewrite all samples if using different NALU size*/\n\t\tif (avc_src->nal_unit_size > avc_dst->nal_unit_size) {\n\t\t\tgf_media_avc_rewrite_samples(dest, dst_tk, 8*avc_dst->nal_unit_size, 8*avc_src->nal_unit_size);\n\t\t\tavc_dst->nal_unit_size = avc_src->nal_unit_size;\n\t\t} else if (avc_src->nal_unit_size < avc_dst->nal_unit_size) {\n\t\t\tgf_media_avc_rewrite_samples(orig, src_track, 8*avc_src->nal_unit_size, 8*avc_dst->nal_unit_size);\n\t\t}\n\n\t\t/*merge PS*/\n\t\tif (!merge_parameter_set(avc_src->sequenceParameterSets, avc_dst->sequenceParameterSets, \"SPS\"))\n\t\t\tdst_tk = 0;\n\t\tif (!merge_parameter_set(avc_src->pictureParameterSets, avc_dst->pictureParameterSets, \"PPS\"))\n\t\t\tdst_tk = 0;\n\n\t\tgf_isom_avc_config_update(dest, dst_tk, 1, avc_dst);\n\t}\n\n\tgf_odf_avc_cfg_del(avc_src);\n\tgf_odf_avc_cfg_del(avc_dst);\n\n\tif (!dst_tk) {\n\t\tdst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\t\tgf_isom_set_nalu_extract_mode(orig, src_track, GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG);\n\t\tif (!force_cat) {\n\t\t\tgf_isom_avc_set_inband_config(dest, dst_tk, 1);\n\t\t} else {\n\t\t\tfprintf(stderr, \"WARNING: Concatenating track ID %d even though sample descriptions do not match\\n\", tk_id);\n\t\t}\n\t}\n\treturn dst_tk;\n}\n\n#ifndef GPAC_DISABLE_HEVC\nstatic u32 merge_hevc_config(GF_ISOFile *dest, u32 tk_id, GF_ISOFile *orig, u32 src_track, Bool force_cat)\n{\n\tu32 i;\n\tGF_HEVCConfig *hevc_src, *hevc_dst;\n\tu32 dst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\n\thevc_src = gf_isom_hevc_config_get(orig, src_track, 1);\n\thevc_dst = gf_isom_hevc_config_get(dest, dst_tk, 1);\n\n\tif (hevc_src->profile_idc != hevc_dst->profile_idc) dst_tk = 0;\n\telse if (hevc_src->level_idc != hevc_dst->level_idc) dst_tk = 0;\n\telse if (hevc_src->general_profile_compatibility_flags != hevc_dst->general_profile_compatibility_flags ) dst_tk = 0;\n\telse {\n\t\t/*rewrite all samples if using different NALU size*/\n\t\tif (hevc_src->nal_unit_size > hevc_dst->nal_unit_size) {\n\t\t\tgf_media_avc_rewrite_samples(dest, dst_tk, 8*hevc_dst->nal_unit_size, 8*hevc_src->nal_unit_size);\n\t\t\thevc_dst->nal_unit_size = hevc_src->nal_unit_size;\n\t\t} else if (hevc_src->nal_unit_size < hevc_dst->nal_unit_size) {\n\t\t\tgf_media_avc_rewrite_samples(orig, src_track, 8*hevc_src->nal_unit_size, 8*hevc_dst->nal_unit_size);\n\t\t}\n\n\t\t/*merge PS*/\n\t\tfor (i=0; i<gf_list_count(hevc_src->param_array); i++) {\n\t\t\tu32 k;\n\t\t\tGF_HEVCParamArray *src_ar = gf_list_get(hevc_src->param_array, i);\n\t\t\tfor (k=0; k<gf_list_count(hevc_dst->param_array); k++) {\n\t\t\t\tGF_HEVCParamArray *dst_ar = gf_list_get(hevc_dst->param_array, k);\n\t\t\t\tif (dst_ar->type==src_ar->type) {\n\t\t\t\t\tif (!merge_parameter_set(src_ar->nalus, dst_ar->nalus, \"SPS\"))\n\t\t\t\t\t\tdst_tk = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgf_isom_hevc_config_update(dest, dst_tk, 1, hevc_dst);\n\t}\n\n\tgf_odf_hevc_cfg_del(hevc_src);\n\tgf_odf_hevc_cfg_del(hevc_dst);\n\n\tif (!dst_tk) {\n\t\tdst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\t\tgf_isom_set_nalu_extract_mode(orig, src_track, GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG);\n\t\tif (!force_cat) {\n\t\t\tgf_isom_hevc_set_inband_config(dest, dst_tk, 1);\n\t\t} else {\n\t\t\tfprintf(stderr, \"WARNING: Concatenating track ID %d even though sample descriptions do not match\\n\", tk_id);\n\t\t}\n\t}\n\treturn dst_tk;\n}\n#endif /*GPAC_DISABLE_HEVC */\n\nGF_Err cat_isomedia_file(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)\n{\n\tu32 i, j, count, nb_tracks, nb_samp, nb_done;\n\tGF_ISOFile *orig;\n\tGF_Err e;\n\tchar *opts, *multi_cat;\n\tDouble ts_scale;\n\tDouble dest_orig_dur;\n\tu32 dst_tk, tk_id, mtype;\n\tu64 insert_dts;\n\tBool is_isom;\n\tGF_ISOSample *samp;\n\tDouble aligned_to_DTS = 0;\n\n\tif (strchr(fileName, '*')) return cat_multiple_files(dest, fileName, import_flags, force_fps, frames_per_sample, tmp_dir, force_cat, align_timelines, allow_add_in_command);\n\n\tmulti_cat = allow_add_in_command ? strchr(fileName, '+') : NULL;\n\tif (multi_cat) {\n\t\tmulti_cat[0] = 0;\n\t\tmulti_cat = &multi_cat[1];\n\t}\n\topts = strchr(fileName, ':');\n\tif (opts && (opts[1]=='\\\\'))\n\t\topts = strchr(fileName, ':');\n\n\te = GF_OK;\n\n\t/*if options are specified, reimport the file*/\n\tis_isom = opts ? 0 : gf_isom_probe_file(fileName);\n\n\tif (!is_isom || opts) {\n\t\torig = gf_isom_open(\"temp\", GF_ISOM_WRITE_EDIT, tmp_dir);\n\t\te = import_file(orig, fileName, import_flags, force_fps, frames_per_sample);\n\t\tif (e) return e;\n\t} else {\n\t\t/*we open the original file in edit mode since we may have to rewrite AVC samples*/\n\t\torig = gf_isom_open(fileName, GF_ISOM_OPEN_EDIT, tmp_dir);\n\t}\n\n\twhile (multi_cat) {\n\t\tchar *sep = strchr(multi_cat, '+');\n\t\tif (sep) sep[0] = 0;\n\n\t\te = import_file(orig, multi_cat, import_flags, force_fps, frames_per_sample);\n\t\tif (e) {\n\t\t\tgf_isom_delete(orig);\n\t\t\treturn e;\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0]=':';\n\t\tmulti_cat = sep+1;\n\t}\n\n\tnb_samp = 0;\n\tnb_tracks = gf_isom_get_track_count(orig);\n\tfor (i=0; i<nb_tracks; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(orig, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_FLASH:\n\t\t\tfprintf(stderr, \"WARNING: Track ID %d (type %s) not handled by concatenation - removing from destination\\n\", gf_isom_get_track_id(orig, i+1), gf_4cc_to_str(mtype));\n\t\t\tcontinue;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tdefault:\n\t\t\t/*only cat self-contained files*/\n\t\t\tif (gf_isom_is_self_contained(orig, i+1, 1)) {\n\t\t\t\tnb_samp+= gf_isom_get_sample_count(orig, i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!nb_samp) {\n\t\tfprintf(stderr, \"No suitable media tracks to cat in %s - skipping\\n\", fileName);\n\t\tgoto err_exit;\n\t}\n\n\tdest_orig_dur = (Double) (s64) gf_isom_get_duration(dest);\n\tif (!gf_isom_get_timescale(dest)) {\n\t\tgf_isom_set_timescale(dest, gf_isom_get_timescale(orig));\n\t}\n\tdest_orig_dur /= gf_isom_get_timescale(dest);\n\n\taligned_to_DTS = 0;\n\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\tDouble track_dur = (Double) gf_isom_get_media_duration(dest, i+1);\n\t\ttrack_dur /= gf_isom_get_media_timescale(dest, i+1);\n\t\tif (aligned_to_DTS < track_dur) {\n\t\t\taligned_to_DTS = track_dur;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"Appending file %s\\n\", fileName);\n\tnb_done = 0;\n\tfor (i=0; i<nb_tracks; i++) {\n\t\tu64 last_DTS, dest_track_dur_before_cat;\n\t\tu32 nb_edits = 0;\n\t\tBool skip_lang_test = 1;\n\t\tBool use_ts_dur = 1;\n\t\tBool merge_edits = 0;\n\t\tBool new_track = 0;\n\t\tmtype = gf_isom_get_media_type(orig, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_FLASH:\n\t\t\tcontinue;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tuse_ts_dur = 0;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tdefault:\n\t\t\tif (!gf_isom_is_self_contained(orig, i+1, 1)) continue;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst_tk = 0;\n\t\t/*if we had a temporary import of the file, check if the original track ID matches the dst one. If so, skip all language detection code*/\n\t\ttk_id = gf_isom_get_track_original_id(orig, i+1);\n\t\tif (!tk_id) {\n\t\t\ttk_id = gf_isom_get_track_id(orig, i+1);\n\t\t\tskip_lang_test = 0;\n\t\t}\n\t\tdst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\n\n\t\tif (dst_tk) {\n\t\t\tif (mtype != gf_isom_get_media_type(dest, dst_tk))\n\t\t\t\tdst_tk = 0;\n\t\t\telse if (gf_isom_get_media_subtype(dest, dst_tk, 1) != gf_isom_get_media_subtype(orig, i+1, 1))\n\t\t\t\tdst_tk = 0;\n\t\t}\n\n\t\tif (!dst_tk) {\n\t\t\tfor (j=0; j<gf_isom_get_track_count(dest); j++) {\n\t\t\t\tif (mtype != gf_isom_get_media_type(dest, j+1)) continue;\n\t\t\t\tif (gf_isom_is_same_sample_description(orig, i+1, 0, dest, j+1, 0)) {\n\t\t\t\t\tif (gf_isom_is_video_subtype(mtype) ) {\n\t\t\t\t\t\tu32 w, h, ow, oh;\n\t\t\t\t\t\tgf_isom_get_visual_info(orig, i+1, 1, &ow, &oh);\n\t\t\t\t\t\tgf_isom_get_visual_info(dest, j+1, 1, &w, &h);\n\t\t\t\t\t\tif ((ow==w) && (oh==h)) {\n\t\t\t\t\t\t\tdst_tk = j+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*check language code*/\n\t\t\t\t\telse if (!skip_lang_test && (mtype==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\t\t\tu32 lang_src, lang_dst;\n\t\t\t\t\t\tchar *lang = NULL;\n\t\t\t\t\t\tgf_isom_get_media_language(orig, i+1, &lang);\n\t\t\t\t\t\tif (lang) {\n\t\t\t\t\t\t\tlang_src = GF_4CC(lang[0], lang[1], lang[2], lang[3]);\n\t\t\t\t\t\t\tgf_free(lang);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlang_src = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_get_media_language(dest, j+1, &lang);\n\t\t\t\t\t\tif (lang) {\n\t\t\t\t\t\t\tlang_dst = GF_4CC(lang[0], lang[1], lang[2], lang[3]);\n\t\t\t\t\t\t\tgf_free(lang);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlang_dst = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lang_dst==lang_src) {\n\t\t\t\t\t\t\tdst_tk = j+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdst_tk = j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dst_tk) {\n\t\t\tu32 found_dst_tk = dst_tk;\n\t\t\tu32 stype = gf_isom_get_media_subtype(dest, dst_tk, 1);\n\t\t\t/*we MUST have the same codec*/\n\t\t\tif (gf_isom_get_media_subtype(orig, i+1, 1) != stype) dst_tk = 0;\n\t\t\t/*we only support cat with the same number of sample descriptions*/\n\t\t\tif (gf_isom_get_sample_description_count(orig, i+1) != gf_isom_get_sample_description_count(dest, dst_tk)) dst_tk = 0;\n\t\t\t/*if not forcing cat, check the media codec config is the same*/\n\t\t\tif (!gf_isom_is_same_sample_description(orig, i+1, 0, dest, dst_tk, 0)) {\n\t\t\t\tdst_tk = 0;\n\t\t\t}\n\t\t\t/*we force the same visual resolution*/\n\t\t\telse if (gf_isom_is_video_subtype(mtype) ) {\n\t\t\t\tu32 w, h, ow, oh;\n\t\t\t\tgf_isom_get_visual_info(orig, i+1, 1, &ow, &oh);\n\t\t\t\tgf_isom_get_visual_info(dest, dst_tk, 1, &w, &h);\n\t\t\t\tif ((ow!=w) || (oh!=h)) {\n\t\t\t\t\tdst_tk = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dst_tk) {\n\t\t\t\t/*merge AVC config if possible*/\n\t\t\t\tif ((stype == GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\t        || (stype == GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\t        || (stype == GF_ISOM_SUBTYPE_AVC3_H264)\n\t\t\t\t        || (stype == GF_ISOM_SUBTYPE_AVC4_H264) ) {\n\t\t\t\t\tdst_tk = merge_avc_config(dest, tk_id, orig, i+1, force_cat);\n\t\t\t\t}\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t/*merge HEVC config if possible*/\n\t\t\t\telse if ((stype == GF_ISOM_SUBTYPE_HVC1)\n\t\t\t\t         || (stype == GF_ISOM_SUBTYPE_HEV1)\n\t\t\t\t         || (stype == GF_ISOM_SUBTYPE_HVC2)\n\t\t\t\t         || (stype == GF_ISOM_SUBTYPE_HEV2)) {\n\t\t\t\t\tdst_tk = merge_hevc_config(dest, tk_id, orig, i+1, force_cat);\n\t\t\t\t}\n#endif /*GPAC_DISABLE_HEVC*/\n\t\t\t\telse if (force_cat) {\n\t\t\t\t\tdst_tk = found_dst_tk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*looks like a new track*/\n\t\tif (!dst_tk) {\n\t\t\tfprintf(stderr, \"No suitable destination track found - creating new one (type %s)\\n\", gf_4cc_to_str(mtype));\n\t\t\te = gf_isom_clone_track(orig, i+1, dest, GF_FALSE, &dst_tk);\n\t\t\tif (e) goto err_exit;\n\t\t\tgf_isom_clone_pl_indications(orig, dest);\n\t\t\tnew_track = 1;\n\n\t\t\tif (align_timelines) {\n\t\t\t\tu32 max_timescale = 0;\n//\t\t\t\tu32 dst_timescale = 0;\n\t\t\t\tu32 idx;\n\t\t\t\tfor (idx=0; idx<nb_tracks; idx++) {\n\t\t\t\t\tif (max_timescale < gf_isom_get_media_timescale(orig, idx+1))\n\t\t\t\t\t\tmax_timescale = gf_isom_get_media_timescale(orig, idx+1);\n\t\t\t\t}\n#if 0\n\t\t\t\tif (dst_timescale < max_timescale) {\n\t\t\t\t\tdst_timescale = gf_isom_get_media_timescale(dest, dst_tk);\n\t\t\t\t\tidx = max_timescale / dst_timescale;\n\t\t\t\t\tif (dst_timescale * idx < max_timescale) idx ++;\n\t\t\t\t\tdst_timescale *= idx;\n\n\t\t\t\t\tgf_isom_set_media_timescale(dest, dst_tk, max_timescale, 0);\n\t\t\t\t}\n#else\n\t\t\t\tgf_isom_set_media_timescale(dest, dst_tk, max_timescale, 0);\n#endif\n\t\t\t}\n\n\t\t\t/*remove cloned edit list, as it will be rewritten after import*/\n\t\t\tgf_isom_remove_edit_segments(dest, dst_tk);\n\t\t} else {\n\t\t\tnb_edits = gf_isom_get_edit_segment_count(orig, i+1);\n\t\t}\n\n\t\tdest_track_dur_before_cat = gf_isom_get_media_duration(dest, dst_tk);\n\t\tcount = gf_isom_get_sample_count(dest, dst_tk);\n\n\t\tif (align_timelines) {\n\t\t\tinsert_dts = (u64) (aligned_to_DTS * gf_isom_get_media_timescale(dest, dst_tk));\n\t\t} else if (use_ts_dur && (count>1)) {\n\t\t\tinsert_dts = 2*gf_isom_get_sample_dts(dest, dst_tk, count) - gf_isom_get_sample_dts(dest, dst_tk, count-1);\n\t\t} else {\n\t\t\tinsert_dts = dest_track_dur_before_cat;\n\t\t\tif (!count) insert_dts = 0;\n\t\t}\n\n\t\tts_scale = gf_isom_get_media_timescale(dest, dst_tk);\n\t\tts_scale /= gf_isom_get_media_timescale(orig, i+1);\n\n\t\t/*if not a new track, see if we can merge the edit list - this is a crude test that only checks\n\t\twe have the same edit types*/\n\t\tif (nb_edits && (nb_edits == gf_isom_get_edit_segment_count(dest, dst_tk)) ) {\n\t\t\tu64 editTime, segmentDuration, mediaTime, dst_editTime, dst_segmentDuration, dst_mediaTime;\n\t\t\tu8 dst_editMode, editMode;\n\t\t\tu32 j;\n\t\t\tmerge_edits = 1;\n\t\t\tfor (j=0; j<nb_edits; j++) {\n\t\t\t\tgf_isom_get_edit_segment(orig, i+1, j+1, &editTime, &segmentDuration, &mediaTime, &editMode);\n\t\t\t\tgf_isom_get_edit_segment(dest, dst_tk, j+1, &dst_editTime, &dst_segmentDuration, &dst_mediaTime, &dst_editMode);\n\n\t\t\t\tif (dst_editMode!=editMode) {\n\t\t\t\t\tmerge_edits=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlast_DTS = 0;\n\t\tcount = gf_isom_get_sample_count(orig, i+1);\n\t\tfor (j=0; j<count; j++) {\n\t\t\tu32 di;\n\t\t\tsamp = gf_isom_get_sample(orig, i+1, j+1, &di);\n\t\t\tlast_DTS = samp->DTS;\n\t\t\tsamp->DTS =  (u64) (ts_scale * samp->DTS + (new_track ? 0 : insert_dts));\n\t\t\tsamp->CTS_Offset =  (u32) (samp->CTS_Offset * ts_scale);\n\n\t\t\tif (gf_isom_is_self_contained(orig, i+1, di)) {\n\t\t\t\te = gf_isom_add_sample(dest, dst_tk, di, samp);\n\t\t\t} else {\n\t\t\t\tu64 offset;\n\t\t\t\tGF_ISOSample *s = gf_isom_get_sample_info(orig, i+1, j+1, &di, &offset);\n\t\t\t\te = gf_isom_add_sample_reference(dest, dst_tk, di, samp, offset);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (e) goto err_exit;\n\n\t\t\te = gf_isom_copy_sample_info(dest, dst_tk, orig, i+1, j+1);\n\t\t\tif (e) goto err_exit;\n\n\t\t\tgf_set_progress(\"Appending\", nb_done, nb_samp);\n\t\t\tnb_done++;\n\t\t}\n\t\t/*scene description and text: compute last sample duration based on original media duration*/\n\t\tif (!use_ts_dur) {\n\t\t\tinsert_dts = gf_isom_get_media_duration(orig, i+1) - last_DTS;\n\t\t\tgf_isom_set_last_sample_duration(dest, dst_tk, (u32) insert_dts);\n\t\t}\n\n\t\tif (new_track && insert_dts) {\n\t\t\tu64 media_dur = gf_isom_get_media_duration(orig, i+1);\n\t\t\t/*convert from media time to track time*/\n\t\t\tDouble rescale = (Float) gf_isom_get_timescale(dest);\n\t\t\trescale /= (Float) gf_isom_get_media_timescale(dest, dst_tk);\n\t\t\t/*convert from orig to dst time scale*/\n\t\t\trescale *= ts_scale;\n\n\t\t\tgf_isom_set_edit_segment(dest, dst_tk, 0, (u64) (s64) (insert_dts*rescale), 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit_segment(dest, dst_tk, (u64) (s64) (insert_dts*rescale), (u64) (s64) (media_dur*rescale), 0, GF_ISOM_EDIT_NORMAL);\n\t\t} else if (merge_edits) {\n\t\t\t/*convert from media time to track time*/\n\t\t\tDouble rescale = (Float) gf_isom_get_timescale(dest);\n\t\t\trescale /= (Float) gf_isom_get_media_timescale(dest, dst_tk);\n\t\t\t/*convert from orig to dst time scale*/\n\t\t\trescale *= ts_scale;\n\n\t\t\t/*get the first edit normal mode and add the new track dur*/\n\t\t\tfor (j=nb_edits; j>0; j--) {\n\t\t\t\tu64 editTime, segmentDuration, mediaTime;\n\t\t\t\tu8 editMode;\n\t\t\t\tgf_isom_get_edit_segment(dest, dst_tk, j, &editTime, &segmentDuration, &mediaTime, &editMode);\n\n\t\t\t\tif (editMode==GF_ISOM_EDIT_NORMAL) {\n\t\t\t\t\tDouble prev_dur = (Double) (s64) dest_track_dur_before_cat;\n\t\t\t\t\tDouble dur = (Double) (s64) gf_isom_get_media_duration(orig, i+1);\n\n\t\t\t\t\tdur *= rescale;\n\t\t\t\t\tprev_dur *= rescale;\n\n\t\t\t\t\t/*safety test: some files have broken edit lists. If no more than 2 entries, check that the segment duration\n\t\t\t\t\tis less or equal to the movie duration*/\n\t\t\t\t\tif (prev_dur < segmentDuration) {\n\t\t\t\t\t\tfprintf(stderr, \"Warning: suspicious edit list entry found: duration %g sec but longest track duration before cat is %g - fixing it\\n\", (Double) (s64) segmentDuration/1000.0, prev_dur/1000);\n\t\t\t\t\t\tsegmentDuration = (u64) (s64) ( (Double) (s64) (dest_track_dur_before_cat - mediaTime) * rescale );\n\t\t\t\t\t}\n\n\t\t\t\t\tsegmentDuration += (u64) (s64) dur;\n\t\t\t\t\tgf_isom_modify_edit_segment(dest, dst_tk, j, segmentDuration, mediaTime, editMode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tu64 editTime, segmentDuration, mediaTime, edit_offset;\n\t\t\tDouble t;\n\t\t\tu8 editMode;\n\t\t\tu32 j, count;\n\n\t\t\tcount = gf_isom_get_edit_segment_count(dest, dst_tk);\n\t\t\tif (count) {\n\t\t\t\te = gf_isom_get_edit_segment(dest, dst_tk, count, &editTime, &segmentDuration, &mediaTime, &editMode);\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error: edit segment error on destination track %u could not be retrieved.\\n\", dst_tk);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else if (gf_isom_get_edit_segment_count(orig, i+1)) {\n\t\t\t\t/*fake empty edit segment*/\n\t\t\t\t/*convert from media time to track time*/\n\t\t\t\tDouble rescale = (Float) gf_isom_get_timescale(dest);\n\t\t\t\trescale /= (Float) gf_isom_get_media_timescale(dest, dst_tk);\n\t\t\t\tsegmentDuration = (u64) (dest_track_dur_before_cat * rescale);\n\t\t\t\teditTime = 0;\n\t\t\t\tmediaTime = 0;\n\t\t\t\tgf_isom_set_edit_segment(dest, dst_tk, editTime, segmentDuration, mediaTime, GF_ISOM_EDIT_NORMAL);\n\t\t\t} else {\n\t\t\t\teditTime = 0;\n\t\t\t\tsegmentDuration = 0;\n\t\t\t}\n\n\t\t\t/*convert to dst time scale*/\n\t\t\tts_scale = (Float) gf_isom_get_timescale(dest);\n\t\t\tts_scale /= (Float) gf_isom_get_timescale(orig);\n\n\t\t\tedit_offset = editTime + segmentDuration;\n\t\t\tcount = gf_isom_get_edit_segment_count(orig, i+1);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tgf_isom_get_edit_segment(orig, i+1, j+1, &editTime, &segmentDuration, &mediaTime, &editMode);\n\t\t\t\tt = (Double) (s64) editTime;\n\t\t\t\tt *= ts_scale;\n\t\t\t\tt += (s64) edit_offset;\n\t\t\t\teditTime = (s64) t;\n\t\t\t\tt = (Double) (s64) segmentDuration;\n\t\t\t\tt *= ts_scale;\n\t\t\t\tsegmentDuration = (s64) t;\n\t\t\t\tt = (Double) (s64) mediaTime;\n\t\t\t\tt *= ts_scale;\n\t\t\t\tt+= (s64) dest_track_dur_before_cat;\n\t\t\t\tmediaTime = (s64) t;\n\t\t\t\tif ((editMode == GF_ISOM_EDIT_EMPTY) && (mediaTime > 0)) {\n\t\t\t\t\teditMode = GF_ISOM_EDIT_NORMAL;\n\t\t\t\t}\n\t\t\t\tgf_isom_set_edit_segment(dest, dst_tk, editTime, segmentDuration, mediaTime, editMode);\n\t\t\t}\n\t\t}\n\n\t}\n\tgf_set_progress(\"Appending\", nb_samp, nb_samp);\n\n\t/*check chapters*/\n\tfor (i=0; i<gf_isom_get_chapter_count(orig, 0); i++) {\n\t\tchar *name;\n\t\tDouble c_time;\n\t\tu64 chap_time;\n\t\tgf_isom_get_chapter(orig, 0, i+1, &chap_time, (const char **) &name);\n\t\tc_time = (Double) (s64) chap_time;\n\t\tc_time /= 1000;\n\t\tc_time += dest_orig_dur;\n\n\t\t/*check last file chapter*/\n\t\tif (!i && gf_isom_get_chapter_count(dest, 0)) {\n\t\t\tconst char *last_name;\n\t\t\tu64 last_chap_time;\n\t\t\tgf_isom_get_chapter(dest, 0, gf_isom_get_chapter_count(dest, 0), &last_chap_time, &last_name);\n\t\t\t/*last and first chapters are the same, don't duplicate*/\n\t\t\tif (last_name && name && !stricmp(last_name, name)) continue;\n\t\t}\n\n\t\tchap_time = (u64) (c_time*1000);\n\t\tgf_isom_add_chapter(dest, 0, chap_time, name);\n\t}\n\n\nerr_exit:\n\tgf_isom_delete(orig);\n\treturn e;\n}\n\ntypedef struct\n{\n\tchar szPath[GF_MAX_PATH];\n\tchar szRad1[1024], szRad2[1024], szOpt[200];\n\tGF_ISOFile *dest;\n\tu32 import_flags;\n\tDouble force_fps;\n\tu32 frames_per_sample;\n\tchar *tmp_dir;\n\tBool force_cat, align_timelines, allow_add_in_command;\n} CATEnum;\n\nBool cat_enumerate(void *cbk, char *szName, char *szPath, GF_FileEnumInfo *file_info)\n{\n\tGF_Err e;\n\tu32 len_rad1;\n\tchar szFileName[GF_MAX_PATH];\n\tCATEnum *cat_enum = (CATEnum *)cbk;\n\tlen_rad1 = (u32) strlen(cat_enum->szRad1);\n\tif (strnicmp(szName, cat_enum->szRad1, len_rad1)) return 0;\n\tif (strlen(cat_enum->szRad2) && !strstr(szName + len_rad1, cat_enum->szRad2) ) return 0;\n\n\tstrcpy(szFileName, szName);\n\tstrcat(szFileName, cat_enum->szOpt);\n\n\te = cat_isomedia_file(cat_enum->dest, szFileName, cat_enum->import_flags, cat_enum->force_fps, cat_enum->frames_per_sample, cat_enum->tmp_dir, cat_enum->force_cat, cat_enum->align_timelines, cat_enum->allow_add_in_command);\n\tif (e) return 1;\n\treturn 0;\n}\n\nGF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)\n{\n\tCATEnum cat_enum;\n\tchar *sep;\n\n\tcat_enum.dest = dest;\n\tcat_enum.import_flags = import_flags;\n\tcat_enum.force_fps = force_fps;\n\tcat_enum.frames_per_sample = frames_per_sample;\n\tcat_enum.tmp_dir = tmp_dir;\n\tcat_enum.force_cat = force_cat;\n\tcat_enum.align_timelines = align_timelines;\n\tcat_enum.allow_add_in_command = allow_add_in_command;\n\n\tstrcpy(cat_enum.szPath, fileName);\n\tsep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);\n\tif (!sep) sep = strrchr(cat_enum.szPath, '/');\n\tif (!sep) {\n\t\tstrcpy(cat_enum.szPath, \".\");\n\t\tstrcpy(cat_enum.szRad1, fileName);\n\t} else {\n\t\tstrcpy(cat_enum.szRad1, sep+1);\n\t\tsep[0] = 0;\n\t}\n\tsep = strchr(cat_enum.szRad1, '*');\n\tstrcpy(cat_enum.szRad2, sep+1);\n\tsep[0] = 0;\n\tsep = strchr(cat_enum.szRad2, '%');\n\tif (!sep) sep = strchr(cat_enum.szRad2, '#');\n\tif (!sep) sep = strchr(cat_enum.szRad2, ':');\n\tstrcpy(cat_enum.szOpt, \"\");\n\tif (sep) {\n\t\tstrcpy(cat_enum.szOpt, sep);\n\t\tsep[0] = 0;\n\t}\n\treturn gf_enum_directory(cat_enum.szPath, 0, cat_enumerate, &cat_enum, NULL);\n}\n\n\n#ifndef GPAC_DISABLE_SCENE_ENCODER\n/*\n\t\tMPEG-4 encoding\n*/\n\nGF_Err EncodeFile(char *in, GF_ISOFile *mp4, GF_SMEncodeOptions *opts, FILE *logs)\n{\n#ifdef GPAC_DISABLE_SMGR\n\treturn GF_NOT_SUPPORTED;\n#else\n\tGF_Err e;\n\tGF_SceneLoader load;\n\tGF_SceneManager *ctx;\n\tGF_SceneGraph *sg;\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tGF_StatManager *statsman = NULL;\n#endif\n\n\tsg = gf_sg_new();\n\tctx = gf_sm_new(sg);\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = in;\n\tload.ctx = ctx;\n\tload.swf_import_flags = swf_flags;\n\tload.swf_flatten_limit = swf_flatten_angle;\n\t/*since we're encoding we must get MPEG4 nodes only*/\n\tload.flags = GF_SM_LOAD_MPEG4_STRICT;\n\te = gf_sm_load_init(&load);\n\tif (e<0) {\n\t\tgf_sm_load_done(&load);\n\t\tfprintf(stderr, \"Cannot load context %s - %s\\n\", in, gf_error_to_string(e));\n\t\tgoto err_exit;\n\t}\n\te = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tif (opts->auto_quant) {\n\t\tfprintf(stderr, \"Analysing Scene for Automatic Quantization\\n\");\n\t\tstatsman = gf_sm_stats_new();\n\t\te = gf_sm_stats_for_scene(statsman, ctx);\n\t\tif (!e) {\n\t\t\tGF_SceneStatistics *stats = gf_sm_stats_get(statsman);\n\t\t\t/*LASeR*/\n\t\t\tif (opts->auto_quant==1) {\n\t\t\t\tif (opts->resolution > (s32)stats->frac_res_2d) {\n\t\t\t\t\tfprintf(stderr, \" Given resolution %d is (unnecessarily) too high, using %d instead.\\n\", opts->resolution, stats->frac_res_2d);\n\t\t\t\t\topts->resolution = stats->frac_res_2d;\n\t\t\t\t} else if (stats->int_res_2d + opts->resolution <= 0) {\n\t\t\t\t\tfprintf(stderr, \" Given resolution %d is too low, using %d instead.\\n\", opts->resolution, stats->int_res_2d - 1);\n\t\t\t\t\topts->resolution = 1 - stats->int_res_2d;\n\t\t\t\t}\n\t\t\t\topts->coord_bits = stats->int_res_2d + opts->resolution;\n\t\t\t\tfprintf(stderr, \" Coordinates & Lengths encoded using \");\n\t\t\t\tif (opts->resolution < 0) fprintf(stderr, \"only the %d most significant bits (of %d).\\n\", opts->coord_bits, stats->int_res_2d);\n\t\t\t\telse fprintf(stderr, \"a %d.%d representation\\n\", stats->int_res_2d, opts->resolution);\n\n\t\t\t\tfprintf(stderr, \" Matrix Scale & Skew Coefficients \");\n\t\t\t\tif (opts->coord_bits - 8 < stats->scale_int_res_2d) {\n\t\t\t\t\topts->scale_bits = stats->scale_int_res_2d - opts->coord_bits + 8;\n\t\t\t\t\tfprintf(stderr, \"encoded using a %d.8 representation\\n\", stats->scale_int_res_2d);\n\t\t\t\t} else  {\n\t\t\t\t\topts->scale_bits = 0;\n\t\t\t\t\tfprintf(stderr, \"encoded using a %d.8 representation\\n\", opts->coord_bits - 8);\n\t\t\t\t}\n\t\t\t}\n#ifndef GPAC_DISABLE_VRML\n\t\t\t/*BIFS*/\n\t\t\telse if (stats->base_layer) {\n\t\t\t\tGF_AUContext *au;\n\t\t\t\tGF_CommandField *inf;\n\t\t\t\tM_QuantizationParameter *qp;\n\t\t\t\tGF_Command *com = gf_sg_command_new(ctx->scene_graph, GF_SG_GLOBAL_QUANTIZER);\n\t\t\t\tqp = (M_QuantizationParameter *) gf_node_new(ctx->scene_graph, TAG_MPEG4_QuantizationParameter);\n\n\t\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\t\tinf->new_node = (GF_Node *)qp;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\t\tgf_node_register(inf->new_node, NULL);\n\t\t\t\tau = gf_list_get(stats->base_layer->AUs, 0);\n\t\t\t\tgf_list_insert(au->commands, com, 0);\n\t\t\t\tqp->useEfficientCoding = 1;\n\t\t\t\tqp->textureCoordinateQuant = 0;\n\t\t\t\tif ((stats->count_2f+stats->count_2d) && opts->resolution) {\n\t\t\t\t\tqp->position2DMin = stats->min_2d;\n\t\t\t\t\tqp->position2DMax = stats->max_2d;\n\t\t\t\t\tqp->position2DNbBits = opts->resolution;\n\t\t\t\t\tqp->position2DQuant = 1;\n\t\t\t\t}\n\t\t\t\tif ((stats->count_3f+stats->count_3d) &&  opts->resolution) {\n\t\t\t\t\tqp->position3DMin = stats->min_3d;\n\t\t\t\t\tqp->position3DMax = stats->max_3d;\n\t\t\t\t\tqp->position3DQuant = opts->resolution;\n\t\t\t\t\tqp->position3DQuant = 1;\n\t\t\t\t\tqp->textureCoordinateQuant = 1;\n\t\t\t\t}\n\t\t\t\t//float quantif is disabled since 2008, check if we want to re-enable it\n#if 0\n\t\t\t\tif (stats->count_float && opts->resolution) {\n\t\t\t\t\tqp->scaleMin = stats->min_fixed;\n\t\t\t\t\tqp->scaleMax = stats->max_fixed;\n\t\t\t\t\tqp->scaleNbBits = 2*opts->resolution;\n\t\t\t\t\tqp->scaleQuant = 1;\n\t\t\t\t}\n#endif\n\t\t\t}\n#endif\n\t\t}\n\t}\n#endif /*GPAC_DISABLE_SCENE_STATS*/\n\n\tif (e<0) {\n\t\tfprintf(stderr, \"Error loading file %s\\n\", gf_error_to_string(e));\n\t\tgoto err_exit;\n\t} else {\n\t\tgf_log_cbk prev_logs = NULL;\n\t\tif (logs) {\n\t\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_DEBUG);\n\t\t\tprev_logs = gf_log_set_callback(logs, scene_coding_log);\n\t\t}\n\t\topts->src_url = in;\n\t\te = gf_sm_encode_to_file(ctx, mp4, opts);\n\t\tif (logs) {\n\t\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_ERROR);\n\t\t\tgf_log_set_callback(NULL, prev_logs);\n\t\t}\n\t}\n\n\tgf_isom_set_brand_info(mp4, GF_ISOM_BRAND_MP42, 1);\n\tgf_isom_modify_alternate_brand(mp4, GF_ISOM_BRAND_ISOM, 1);\n\nerr_exit:\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tif (statsman) gf_sm_stats_del(statsman);\n#endif\n\tgf_sm_del(ctx);\n\tgf_sg_del(sg);\n\treturn e;\n\n#endif /*GPAC_DISABLE_SMGR*/\n}\n#endif /*GPAC_DISABLE_SCENE_ENCODER*/\n\n\n#ifndef GPAC_DISABLE_BIFS_ENC\n/*\n\t\tMPEG-4 chunk encoding\n*/\n\nstatic u32 GetNbBits(u32 MaxVal)\n{\n\tu32 k=0;\n\twhile ((s32) MaxVal > ((1<<k)-1) ) k+=1;\n\treturn k;\n}\n\n#ifndef GPAC_DISABLE_SMGR\nGF_Err EncodeBIFSChunk(GF_SceneManager *ctx, char *bifsOutputFile, GF_Err (*AUCallback)(GF_ISOSample *))\n{\n\tGF_Err\t\t\te;\n\tchar *data;\n\tu32 data_len;\n\tGF_BifsEncoder *bifsenc;\n\tGF_InitialObjectDescriptor *iod;\n\tu32 i, j, count;\n\tGF_StreamContext *sc;\n\tGF_ESD *esd;\n\tBool encode_names, delete_bcfg;\n\tGF_BIFSConfig *bcfg;\n\tGF_AUContext\t\t*au;\n\tchar szRad[GF_MAX_PATH], *ext;\n\tchar szName[1024];\n\tFILE *f;\n\n\tstrcpy(szRad, bifsOutputFile);\n\text = strrchr(szRad, '.');\n\tif (ext) ext[0] = 0;\n\n\n\t/* step3: encoding all AUs in ctx->streams starting at AU index 1 (0 is SceneReplace from previous context) */\n\tbifsenc = gf_bifs_encoder_new(ctx->scene_graph);\n\te = GF_OK;\n\n\tiod = (GF_InitialObjectDescriptor *) ctx->root_od;\n\t/*if no iod check we only have one bifs*/\n\tif (!iod) {\n\t\tcount = 0;\n\t\tfor (i=0; i<gf_list_count(ctx->streams); i++) {\n\t\t\tsc = gf_list_get(ctx->streams, i);\n\t\t\tif (sc->streamType == GF_STREAM_OD) count++;\n\t\t}\n\t\tif (!iod && count>1) return GF_NOT_SUPPORTED;\n\t}\n\n\tcount = gf_list_count(ctx->streams);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nbb;\n\t\tGF_StreamContext *sc = gf_list_get(ctx->streams, i);\n\t\tesd = NULL;\n\t\tif (sc->streamType != GF_STREAM_SCENE) continue;\n\n\t\tesd = NULL;\n\t\tif (iod) {\n\t\t\tfor (j=0; j<gf_list_count(iod->ESDescriptors); j++) {\n\t\t\t\tesd = gf_list_get(iod->ESDescriptors, j);\n\t\t\t\tif (esd->decoderConfig && esd->decoderConfig->streamType == GF_STREAM_SCENE) {\n\t\t\t\t\tif (!sc->ESID) sc->ESID = esd->ESID;\n\t\t\t\t\tif (sc->ESID == esd->ESID) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*special BIFS direct import from NHNT*/\n\t\t\t\telse if (gf_list_count(iod->ESDescriptors)==1) {\n\t\t\t\t\tsc->ESID = esd->ESID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tesd = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (!esd) {\n\t\t\tesd = gf_odf_desc_esd_new(2);\n\t\t\tif (!esd) return GF_OUT_OF_MEM;\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd->decoderConfig->decoderSpecificInfo);\n\t\t\tesd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t\tesd->ESID = sc->ESID;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t}\n\t\tif (!esd->decoderConfig) return GF_OUT_OF_MEM;\n\n\t\t/*should NOT happen (means inputctx is not properly setup)*/\n\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n\t\t\tbcfg = (GF_BIFSConfig*)gf_odf_desc_new(GF_ODF_BIFS_CFG_TAG);\n\t\t\tdelete_bcfg = 1;\n\t\t}\n\t\t/*regular retrieve from ctx*/\n\t\telse if (esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_BIFS_CFG_TAG) {\n\t\t\tbcfg = (GF_BIFSConfig *)esd->decoderConfig->decoderSpecificInfo;\n\t\t\tdelete_bcfg = 0;\n\t\t}\n\t\t/*should not happen either (unless loading from MP4 in which case BIFSc is not decoded)*/\n\t\telse {\n\t\t\tbcfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n\t\t\tdelete_bcfg = 1;\n\t\t}\n\t\t/*NO CHANGE TO BIFSC otherwise the generated update will not match the input context*/\n\t\tnbb = GetNbBits(ctx->max_node_id);\n\t\tif (!bcfg->nodeIDbits) bcfg->nodeIDbits=nbb;\n\t\tif (bcfg->nodeIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.NodeIDBits TOO SMALL\\n\");\n\n\t\tnbb = GetNbBits(ctx->max_route_id);\n\t\tif (!bcfg->routeIDbits) bcfg->routeIDbits = nbb;\n\t\tif (bcfg->routeIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.RouteIDBits TOO SMALL\\n\");\n\n\t\tnbb = GetNbBits(ctx->max_proto_id);\n\t\tif (!bcfg->protoIDbits) bcfg->protoIDbits=nbb;\n\t\tif (bcfg->protoIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.ProtoIDBits TOO SMALL\\n\");\n\n\t\t/*this is the real pb, not stored in cfg or file level, set at EACH replaceScene*/\n\t\tencode_names = 0;\n\n\t\t/* The BIFS Config that is passed here should be the BIFSConfig from the IOD */\n\t\tgf_bifs_encoder_new_stream(bifsenc, sc->ESID, bcfg, encode_names, 0);\n\t\tif (delete_bcfg) gf_odf_desc_del((GF_Descriptor *)bcfg);\n\n\t\t/*setup MP4 track*/\n\t\tif (!esd->slConfig) esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\tif (sc->timeScale) esd->slConfig->timestampResolution = sc->timeScale;\n\t\tif (!esd->slConfig->timestampResolution) esd->slConfig->timestampResolution = 1000;\n\t\tesd->ESID = sc->ESID;\n\t\tgf_bifs_encoder_get_config(bifsenc, sc->ESID, &data, &data_len);\n\n\t\tif (esd->decoderConfig->decoderSpecificInfo) gf_odf_desc_del((GF_Descriptor *) esd->decoderConfig->decoderSpecificInfo);\n\t\tesd->decoderConfig->decoderSpecificInfo = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\t\tesd->decoderConfig->decoderSpecificInfo->data = data;\n\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = data_len;\n\t\tesd->decoderConfig->objectTypeIndication = gf_bifs_encoder_get_version(bifsenc, sc->ESID);\n\n\t\tfor (j=1; j<gf_list_count(sc->AUs); j++) {\n\t\t\tchar *data;\n\t\t\tu32 data_len;\n\t\t\tau = gf_list_get(sc->AUs, j);\n\t\t\te = gf_bifs_encode_au(bifsenc, sc->ESID, au->commands, &data, &data_len);\n\t\t\tif (data) {\n\t\t\t\tsprintf(szName, \"%s%02d.bifs\", szRad, j);\n\t\t\t\tf = gf_fopen(szName, \"wb\");\n\t\t\t\tgf_fwrite(data, data_len, 1, f);\n\t\t\t\tgf_fclose(f);\n\t\t\t\tgf_free(data);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bifs_encoder_del(bifsenc);\n\treturn e;\n}\n#endif /*GPAC_DISABLE_SMGR*/\n\n\n#endif /*GPAC_DISABLE_BIFS_ENC*/\n\n/**\n * \\param chunkFile BT chunk to be encoded\n * \\param bifs output file name for the BIFS data\n * \\param inputContext initial BT upon which the chunk is based (shall not be NULL)\n * \\param outputContext: file name to dump the context after applying the new chunk to the input context\n                   can be NULL, without .bt\n * \\param tmpdir can be NULL\n */\nGF_Err EncodeFileChunk(char *chunkFile, char *bifs, char *inputContext, char *outputContext, const char *tmpdir)\n{\n#if defined(GPAC_DISABLE_SMGR) || defined(GPAC_DISABLE_BIFS_ENC) || defined(GPAC_DISABLE_SCENE_ENCODER) || defined (GPAC_DISABLE_SCENE_DUMP)\n\tfprintf(stderr, \"BIFS encoding is not supported in this build of GPAC\\n\");\n\treturn GF_NOT_SUPPORTED;\n#else\n\tGF_Err e;\n\tGF_SceneGraph *sg;\n\tGF_SceneManager\t*ctx;\n\tGF_SceneLoader load;\n\n\t/*Step 1: create context and load input*/\n\tsg = gf_sg_new();\n\tctx = gf_sm_new(sg);\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = inputContext;\n\tload.ctx = ctx;\n\t/*since we're encoding we must get MPEG4 nodes only*/\n\tload.flags = GF_SM_LOAD_MPEG4_STRICT;\n\te = gf_sm_load_init(&load);\n\tif (!e) e = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\tif (e) {\n\t\tfprintf(stderr, \"Cannot load context %s - %s\\n\", inputContext, gf_error_to_string(e));\n\t\tgoto exit;\n\t}\n\n\t/* Step 2: make sure we have only ONE RAP for each stream*/\n\te = gf_sm_aggregate(ctx, 0);\n\tif (e) goto exit;\n\n\t/*Step 3: loading the chunk into the context*/\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = chunkFile;\n\tload.ctx = ctx;\n\tload.flags = GF_SM_LOAD_MPEG4_STRICT | GF_SM_LOAD_CONTEXT_READY;\n\te = gf_sm_load_init(&load);\n\tif (!e) e = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\tif (e) {\n\t\tfprintf(stderr, \"Cannot load chunk context %s - %s\\n\", chunkFile, gf_error_to_string(e));\n\t\tgoto exit;\n\t}\n\tfprintf(stderr, \"Context and chunks loaded\\n\");\n\n\t/* Assumes that the first AU contains only one command a SceneReplace and\n\t   that is not part of the current chunk */\n\t/* Last argument is a callback to pass the encoded AUs: not needed here\n\t   Saving is not handled correctly */\n\te = EncodeBIFSChunk(ctx, bifs, NULL);\n\tif (e) goto exit;\n\n\n\tif (outputContext) {\n\t\tu32 d_mode, do_enc;\n\t\tchar szF[GF_MAX_PATH], *ext;\n\n\t\t/*make random access for storage*/\n\t\te = gf_sm_aggregate(ctx, 0);\n\t\tif (e) goto exit;\n\n\t\t/*check if we dump to BT, XMT or encode to MP4*/\n\t\tstrcpy(szF, outputContext);\n\t\text = strrchr(szF, '.');\n\t\td_mode = GF_SM_DUMP_BT;\n\t\tdo_enc = 0;\n\t\tif (ext) {\n\t\t\tif (!stricmp(ext, \".xmt\") || !stricmp(ext, \".xmta\")) d_mode = GF_SM_DUMP_XMTA;\n\t\t\telse if (!stricmp(ext, \".mp4\")) do_enc = 1;\n\t\t\text[0] = 0;\n\t\t}\n\n\t\tif (do_enc) {\n\t\t\tGF_ISOFile *mp4;\n\t\t\tstrcat(szF, \".mp4\");\n\t\t\tmp4 = gf_isom_open(szF, GF_ISOM_WRITE_EDIT, tmpdir);\n\t\t\te = gf_sm_encode_to_file(ctx, mp4, NULL);\n\t\t\tif (e) gf_isom_delete(mp4);\n\t\t\telse gf_isom_close(mp4);\n\t\t}\n\t\telse e = gf_sm_dump(ctx, szF, GF_FALSE, d_mode);\n\t}\n\nexit:\n\tif (ctx) {\n\t\tsg = ctx->scene_graph;\n\t\tgf_sm_del(ctx);\n\t\tgf_sg_del(sg);\n\t}\n\n\treturn e;\n\n#endif /*defined(GPAC_DISABLE_BIFS_ENC) || defined(GPAC_DISABLE_SCENE_ENCODER) || defined (GPAC_DISABLE_SCENE_DUMP)*/\n\n}\n\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\nvoid sax_node_start(void *sax_cbck, const char *node_name, const char *name_space, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tchar szCheck[100];\n\tGF_List *imports = sax_cbck;\n\tGF_XMLAttribute *att;\n\tu32 i=0;\n\n\t/*do not process hyperlinks*/\n\tif (!strcmp(node_name, \"a\") || !strcmp(node_name, \"Anchor\")) return;\n\n\tfor (i=0; i<nb_attributes; i++) {\n\t\tatt = (GF_XMLAttribute *) &attributes[i];\n\t\tif (stricmp(att->name, \"xlink:href\") && stricmp(att->name, \"url\")) continue;\n\t\tif (att->value[0]=='#') continue;\n\t\tif (!strnicmp(att->value, \"od:\", 3)) continue;\n\t\tsprintf(szCheck, \"%d\", atoi(att->value));\n\t\tif (!strcmp(szCheck, att->value)) continue;\n\t\tgf_list_add(imports, gf_strdup(att->value) );\n\t}\n}\n\nstatic Bool wgt_enum_files(void *cbck, char *file_name, char *file_path, GF_FileEnumInfo *file_info)\n{\n\tWGTEnum *wgt = (WGTEnum *)cbck;\n\n\tif (!strcmp(wgt->root_file, file_path)) return 0;\n\t/*remove CVS stuff*/\n\tif (strstr(file_path, \".#\")) return 0;\n\tgf_list_add(wgt->imports, gf_strdup(file_path) );\n\treturn 0;\n}\nstatic Bool wgt_enum_dir(void *cbck, char *file_name, char *file_path, GF_FileEnumInfo *file_info)\n{\n\tif (!stricmp(file_name, \"cvs\") || !stricmp(file_name, \".svn\") || !stricmp(file_name, \".git\")) return 0;\n\tgf_enum_directory(file_path, 0, wgt_enum_files, cbck, NULL);\n\treturn gf_enum_directory(file_path, 1, wgt_enum_dir, cbck, NULL);\n}\n\nGF_ISOFile *package_file(char *file_name, char *fcc, const char *tmpdir, Bool make_wgt)\n{\n\tGF_ISOFile *file = NULL;\n\tGF_Err e;\n\tGF_SAXParser *sax;\n\tGF_List *imports;\n\tBool ascii;\n\tchar root_dir[GF_MAX_PATH];\n\tchar *isom_src = NULL;\n\tu32 i, count, mtype, skip_chars;\n\tchar *type;\n\n\ttype = gf_xml_get_root_type(file_name, &e);\n\tif (!type) {\n\t\tfprintf(stderr, \"Cannot process XML file %s: %s\\n\", file_name, gf_error_to_string(e) );\n\t\treturn NULL;\n\t}\n\tif (make_wgt) {\n\t\tif (strcmp(type, \"widget\")) {\n\t\t\tfprintf(stderr, \"XML Root type %s differs from \\\"widget\\\" \\n\", type);\n\t\t\tgf_free(type);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_free(type);\n\t\ttype = gf_strdup(\"application/mw-manifest+xml\");\n\t\tfcc = \"mwgt\";\n\t}\n\timports = gf_list_new();\n\n\n\troot_dir[0] = 0;\n\tif (make_wgt) {\n\t\tWGTEnum wgt;\n\t\tchar *sep = strrchr(file_name, '\\\\');\n\t\tif (!sep) sep = strrchr(file_name, '/');\n\t\tif (sep) {\n\t\t\tchar c = sep[1];\n\t\t\tsep[1]=0;\n\t\t\tstrcpy(root_dir, file_name);\n\t\t\tsep[1] = c;\n\t\t} else {\n\t\t\tstrcpy(root_dir, \"./\");\n\t\t}\n\t\twgt.dir = root_dir;\n\t\twgt.root_file = file_name;\n\t\twgt.imports = imports;\n\t\tgf_enum_directory(wgt.dir, 0, wgt_enum_files, &wgt, NULL);\n\t\tgf_enum_directory(wgt.dir, 1, wgt_enum_dir, &wgt, NULL);\n\t\tascii = 1;\n\t} else {\n\t\tsax = gf_xml_sax_new(sax_node_start, NULL, NULL, imports);\n\t\te = gf_xml_sax_parse_file(sax, file_name, NULL);\n\t\tascii = !gf_xml_sax_binary_file(sax);\n\t\tgf_xml_sax_del(sax);\n\t\tif (e<0) goto exit;\n\t\te = GF_OK;\n\t}\n\n\tif (fcc) {\n\t\tmtype = GF_4CC(fcc[0],fcc[1],fcc[2],fcc[3]);\n\t} else {\n\t\tmtype = 0;\n\t\tif (!stricmp(type, \"svg\")) mtype = ascii ? GF_META_TYPE_SVG : GF_META_TYPE_SVGZ;\n\t\telse if (!stricmp(type, \"smil\")) mtype = ascii ? GF_META_TYPE_SMIL : GF_META_TYPE_SMLZ;\n\t\telse if (!stricmp(type, \"x3d\")) mtype = ascii ? GF_META_TYPE_X3D  : GF_META_TYPE_X3DZ  ;\n\t\telse if (!stricmp(type, \"xmt-a\")) mtype = ascii ? GF_META_TYPE_XMTA : GF_META_TYPE_XMTZ;\n\t}\n\tif (!mtype) {\n\t\tfprintf(stderr, \"Missing 4CC code for meta name - please use ABCD:fileName\\n\");\n\t\te = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\n\tif (!make_wgt) {\n\t\tcount = gf_list_count(imports);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tchar *item = gf_list_get(imports, i);\n\n\t\t\tFILE *test = gf_fopen(item, \"rb\");\n\t\t\tif (!test) {\n\t\t\t\tgf_list_rem(imports, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tgf_free(item);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgf_fclose(test);\n\t\t\tif (gf_isom_probe_file(item)) {\n\t\t\t\tif (isom_src) {\n\t\t\t\t\tfprintf(stderr, \"Cannot package several IsoMedia files together\\n\");\n\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgf_list_rem(imports, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tisom_src = item;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (isom_src) {\n\t\tfile = gf_isom_open(isom_src, GF_ISOM_OPEN_EDIT, tmpdir);\n\t} else {\n\t\tfile = gf_isom_open(\"package\", GF_ISOM_WRITE_EDIT, tmpdir);\n\t}\n\n\te = gf_isom_set_meta_type(file, 1, 0, mtype);\n\tif (e) goto exit;\n\t/*add self ref*/\n\tif (isom_src) {\n\t\te = gf_isom_add_meta_item(file, 1, 0, 1, NULL, isom_src, 0, 0, NULL, NULL, NULL,  NULL, NULL);\n\t\tif (e) goto exit;\n\t}\n\te = gf_isom_set_meta_xml(file, 1, 0, file_name, !ascii);\n\tif (e) goto exit;\n\n\tskip_chars = (u32) strlen(root_dir);\n\tcount = gf_list_count(imports);\n\tfor (i=0; i<count; i++) {\n\t\tchar *ext, *mime, *encoding, *name = NULL;\n\t\tchar *item = gf_list_get(imports, i);\n\n\t\tname = gf_strdup(item + skip_chars);\n\n\t\tif (make_wgt) {\n\t\t\tchar *sep;\n\t\t\twhile (1) {\n\t\t\t\tsep = strchr(name, '\\\\');\n\t\t\t\tif (!sep) break;\n\t\t\t\tsep[0] = '/';\n\t\t\t}\n\t\t}\n\n\n\t\tmime = encoding = NULL;\n\t\text = strrchr(item, '.');\n\t\tif (!stricmp(ext, \".gz\")) ext = strrchr(ext-1, '.');\n\n\t\tif (!stricmp(ext, \".jpg\") || !stricmp(ext, \".jpeg\")) mime = \"image/jpeg\";\n\t\telse if (!stricmp(ext, \".png\")) mime = \"image/png\";\n\t\telse if (!stricmp(ext, \".svg\")) mime = \"image/svg+xml\";\n\t\telse if (!stricmp(ext, \".x3d\")) mime = \"model/x3d+xml\";\n\t\telse if (!stricmp(ext, \".xmt\")) mime = \"application/x-xmt\";\n\t\telse if (!stricmp(ext, \".js\")) {\n\t\t\tmime = \"application/javascript\";\n\t\t}\n\t\telse if (!stricmp(ext, \".svgz\") || !stricmp(ext, \".svg.gz\")) {\n\t\t\tmime = \"image/svg+xml\";\n\t\t\tencoding = \"binary-gzip\";\n\t\t}\n\t\telse if (!stricmp(ext, \".x3dz\") || !stricmp(ext, \".x3d.gz\")) {\n\t\t\tmime = \"model/x3d+xml\";\n\t\t\tencoding = \"binary-gzip\";\n\t\t}\n\t\telse if (!stricmp(ext, \".xmtz\") || !stricmp(ext, \".xmt.gz\")) {\n\t\t\tmime = \"application/x-xmt\";\n\t\t\tencoding = \"binary-gzip\";\n\t\t}\n\n\t\te = gf_isom_add_meta_item(file, 1, 0, 0, item, name, 0, GF_META_ITEM_TYPE_MIME, mime, encoding, NULL,  NULL, NULL);\n\t\tgf_free(name);\n\t\tif (e) goto exit;\n\t}\n\nexit:\n\twhile (gf_list_count(imports)) {\n\t\tchar *item = gf_list_last(imports);\n\t\tgf_list_rem_last(imports);\n\t\tgf_free(item);\n\t}\n\tgf_list_del(imports);\n\tif (isom_src) gf_free(isom_src);\n\tif (type) gf_free(type);\n\tif (e) {\n\t\tif (file) gf_isom_delete(file);\n\t\treturn NULL;\n\t}\n\treturn file;\n}\n#else\nGF_ISOFile *package_file(char *file_name, char *fcc, const char *tmpdir, Bool make_wgt)\n{\n\tfprintf(stderr, \"XML Not supported in this build of GPAC - cannot package file\\n\");\n\treturn NULL;\n}\n#endif //#ifndef GPAC_DISABLE_CORE_TOOLS\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / command-line client\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n/*includes both terminal and od browser*/\n#include <gpac/terminal.h>\n#include <gpac/term_info.h>\n#include <gpac/constants.h>\n#include <gpac/events.h>\n#include <gpac/media_tools.h>\n#include <gpac/options.h>\n#include <gpac/modules/service.h>\n#include <gpac/avparse.h>\n#include <gpac/network.h>\n#include <gpac/utf.h>\n#include <time.h>\n\n/*ISO 639 languages*/\n#include <gpac/iso639.h>\n\n//FIXME we need a plugin for playlists\n#include <gpac/internal/terminal_dev.h>\n\n\n#ifndef WIN32\n#include <dlfcn.h>\n#include <pwd.h>\n#include <unistd.h>\n#if defined(__DARWIN__) || defined(__APPLE__)\n#include <sys/types.h>\n#include <sys/stat.h>\n\nvoid carbon_init();\nvoid carbon_uninit();\n\n#endif\n\n#else\n#include <windows.h> /*for GetModuleFileName*/\n#endif\t//WIN32\n\n/*local prototypes*/\nvoid PrintWorldInfo(GF_Terminal *term);\nvoid ViewOD(GF_Terminal *term, u32 OD_ID, u32 number, const char *URL);\nvoid PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name);\n\nvoid ViewODs(GF_Terminal *term, Bool show_timing);\nvoid PrintGPACConfig();\n\nstatic u32 gui_mode = 0;\n\nstatic Bool restart = GF_FALSE;\nstatic Bool reload = GF_FALSE;\n\nBool no_prog = 0;\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n//we keep no decoder thread because of JS_GC deadlocks between threads ...\nstatic u32 threading_flags = GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_DECODER_THREAD;\n#define VK_MOD  GF_KEY_MOD_ALT\n#else\nstatic u32 threading_flags = 0;\n#define VK_MOD  GF_KEY_MOD_CTRL\n#endif\nstatic Bool no_audio = GF_FALSE;\nstatic Bool term_step = GF_FALSE;\nstatic Bool no_regulation = GF_FALSE;\nstatic u32 bench_mode = 0;\nstatic u32 bench_mode_start = 0;\nstatic u32 bench_buffer = 0;\nstatic Bool eos_seen = GF_FALSE;\nstatic Bool addon_visible = GF_TRUE;\nBool is_connected = GF_FALSE;\nBool startup_file = GF_FALSE;\nGF_User user;\nGF_Terminal *term;\nu64 Duration;\nGF_Err last_error = GF_OK;\nstatic Bool enable_add_ons = GF_TRUE;\nstatic Fixed playback_speed = FIX_ONE;\n\nstatic s32 request_next_playlist_item = GF_FALSE;\nFILE *playlist = NULL;\nstatic Bool readonly_playlist = GF_FALSE;\n\nstatic GF_Config *cfg_file;\nstatic u32 display_rti = 0;\nstatic Bool Run;\nstatic Bool CanSeek = GF_FALSE;\nstatic char the_url[GF_MAX_PATH];\nstatic char pl_path[GF_MAX_PATH];\nstatic Bool no_mime_check = GF_TRUE;\nstatic Bool be_quiet = GF_FALSE;\nstatic u64 log_time_start = 0;\nstatic Bool log_utc_time = GF_FALSE;\nstatic Bool loop_at_end = GF_FALSE;\nstatic u32 forced_width=0;\nstatic u32 forced_height=0;\n\n/*windowless options*/\nu32 align_mode = 0;\nu32 init_w = 0;\nu32 init_h = 0;\nu32 last_x, last_y;\nBool right_down = GF_FALSE;\n\nvoid dump_frame(GF_Terminal *term, char *rad_path, u32 dump_type, u32 frameNum);\n\nenum\n{\n\tDUMP_NONE = 0,\n\tDUMP_AVI = 1,\n\tDUMP_BMP = 2,\n\tDUMP_PNG = 3,\n\tDUMP_RAW = 4,\n\tDUMP_SHA1 = 5,\n\n\t//DuMP flags\n\tDUMP_DEPTH_ONLY = 1<<16,\n\tDUMP_RGB_DEPTH = 1<<17,\n\tDUMP_RGB_DEPTH_SHAPE = 1<<18\n};\n\nBool dump_file(char *the_url, char *out_url, u32 dump_mode, Double fps, u32 width, u32 height, Float scale, u32 *times, u32 nb_times);\n\n\nstatic Bool shell_visible = GF_TRUE;\nvoid hide_shell(u32 cmd_type)\n{\n#if defined(WIN32) && !defined(_WIN32_WCE)\n\ttypedef HWND (WINAPI *GetConsoleWindowT)(void);\n\tHMODULE hk32 = GetModuleHandle(\"kernel32.dll\");\n\tGetConsoleWindowT GetConsoleWindow = (GetConsoleWindowT ) GetProcAddress(hk32,\"GetConsoleWindow\");\n\tif (cmd_type==0) {\n\t\tShowWindow( GetConsoleWindow(), SW_SHOW);\n\t\tshell_visible = GF_TRUE;\n\t}\n\telse if (cmd_type==1) {\n\t\tShowWindow( GetConsoleWindow(), SW_HIDE);\n\t\tshell_visible = GF_FALSE;\n\t}\n\telse if (cmd_type==2) PostMessage(GetConsoleWindow(), WM_CLOSE, 0, 0);\n\n#endif\n}\n\n\nvoid send_open_url(const char *url)\n{\n\tGF_Event evt;\n\tmemset(&evt, 0, sizeof(GF_Event));\n\tevt.type = GF_EVENT_NAVIGATE;\n\tevt.navigate.to_url = url;\n\tgf_term_send_event(term, &evt);\n}\n\nvoid PrintUsage()\n{\n\tfprintf(stderr, \"Usage MP4Client [options] [filename]\\n\"\n\t        \"\\t-c fileName:    user-defined configuration file. Also works with -cfg\\n\"\n#ifdef GPAC_MEMORY_TRACKING\n            \"\\t-mem-track:  enables memory tracker\\n\"\n            \"\\t-mem-track-stack:  enables memory tracker with stack dumping\\n\"\n#endif\n\t        \"\\t-rti fileName:  logs run-time info (FPS, CPU, Mem usage) to file\\n\"\n\t        \"\\t-rtix fileName: same as -rti but driven by GPAC logs\\n\"\n\t        \"\\t-quiet:         removes script message, buffering and downloading status\\n\"\n\t        \"\\t-strict-error:  exit when the player reports its first error\\n\"\n\t        \"\\t-opt option:    Overrides an option in the configuration file. String format is section:key=value. \\n\"\n\t        \"\\t                  \\\"section:key=null\\\" removes the key\\n\"\n\t        \"\\t                  \\\"section:*=null\\\" removes the section\\n\"\n\t        \"\\t-conf option:   Same as -opt but does not start player.\\n\"\n\t        \"\\t-log-file file: sets output log file. Also works with -lf\\n\"\n\t        \"\\t-logs log_args: sets log tools and levels, formatted as a ':'-separated list of toolX[:toolZ]@levelX\\n\"\n\t        \"\\t                 levelX can be one of:\\n\"\n\t        \"\\t        \\\"quiet\\\"      : skip logs\\n\"\n\t        \"\\t        \\\"error\\\"      : logs only error messages\\n\"\n\t        \"\\t        \\\"warning\\\"    : logs error+warning messages\\n\"\n\t        \"\\t        \\\"info\\\"       : logs error+warning+info messages\\n\"\n\t        \"\\t        \\\"debug\\\"      : logs all messages\\n\"\n\t        \"\\t                 toolX can be one of:\\n\"\n\t        \"\\t        \\\"core\\\"       : libgpac core\\n\"\n\t        \"\\t        \\\"coding\\\"     : bitstream formats (audio, video, scene)\\n\"\n\t        \"\\t        \\\"container\\\"  : container formats (ISO File, MPEG-2 TS, AVI, ...)\\n\"\n\t        \"\\t        \\\"network\\\"    : network data exept RTP trafic\\n\"\n\t        \"\\t        \\\"rtp\\\"        : rtp trafic\\n\"\n\t        \"\\t        \\\"author\\\"     : authoring tools (hint, import, export)\\n\"\n\t        \"\\t        \\\"sync\\\"       : terminal sync layer\\n\"\n\t        \"\\t        \\\"codec\\\"      : terminal codec messages\\n\"\n\t        \"\\t        \\\"parser\\\"     : scene parsers (svg, xmt, bt) and other\\n\"\n\t        \"\\t        \\\"media\\\"      : terminal media object management\\n\"\n\t        \"\\t        \\\"scene\\\"      : scene graph and scene manager\\n\"\n\t        \"\\t        \\\"script\\\"     : scripting engine messages\\n\"\n\t        \"\\t        \\\"interact\\\"   : interaction engine (events, scripts, etc)\\n\"\n\t        \"\\t        \\\"smil\\\"       : SMIL timing engine\\n\"\n\t        \"\\t        \\\"compose\\\"    : composition engine (2D, 3D, etc)\\n\"\n\t        \"\\t        \\\"mmio\\\"       : Audio/Video HW I/O management\\n\"\n\t        \"\\t        \\\"rti\\\"        : various run-time stats\\n\"\n\t        \"\\t        \\\"cache\\\"      : HTTP cache subsystem\\n\"\n\t        \"\\t        \\\"audio\\\"      : Audio renderer and mixers\\n\"\n#ifdef GPAC_MEMORY_TRACKING\n\t        \"\\t        \\\"mem\\\"        : GPAC memory tracker\\n\"\n#endif\n#ifndef GPAC_DISABLE_DASH_CLIENT\n\t        \"\\t        \\\"dash\\\"       : HTTP streaming logs\\n\"\n#endif\n\t        \"\\t        \\\"module\\\"     : GPAC modules debugging\\n\"\n\t        \"\\t        \\\"mutex\\\"      : mutex\\n\"\n\t        \"\\t        \\\"all\\\"        : all tools logged - other tools can be specified afterwards.\\n\"\n\t        \"\\tThe special value \\\"ncl\\\" disables color logs.\\n\"\n\t        \"\\n\"\n\t        \"\\t-log-clock or -lc      : logs time in micro sec since start time of GPAC before each log line.\\n\"\n\t        \"\\t-log-utc or -lu        : logs UTC time in ms before each log line.\\n\"\n\t        \"\\t-ifce IPIFCE           : Sets default Multicast interface\\n\"\n\t        \"\\t-size WxH:      specifies visual size (default: scene size)\\n\"\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t        \"\\t-thread:        enables thread usage for terminal and compositor \\n\"\n#else\n\t        \"\\t-no-thread:     disables thread usage (except for audio)\\n\"\n#endif\n\t        \"\\t-no-cthread:    disables compositor thread (iOS and Android mode)\\n\"\n\t        \"\\t-no-audio:      disables audio \\n\"\n\t        \"\\t-no-wnd:        uses windowless mode (Win32 only)\\n\"\n\t        \"\\t-no-back:       uses transparent background for output window when no background is specified (Win32 only)\\n\"\n\t        \"\\t-align vh:      specifies v and h alignment for windowless mode\\n\"\n\t        \"\\t                 possible v values: t(op), m(iddle), b(ottom)\\n\"\n\t        \"\\t                 possible h values: l(eft), m(iddle), r(ight)\\n\"\n\t        \"\\t                 default alignment is top-left\\n\"\n\t        \"\\t                 default alignment is top-left\\n\"\n\t        \"\\t-pause:         pauses at first frame\\n\"\n\t        \"\\t-play-from T:   starts from T seconds in media\\n\"\n\t        \"\\t-speed S:       starts with speed S\\n\"\n\t        \"\\t-loop:          loops presentation\\n\"\n\t        \"\\t-no-regulation: disables framerate regulation\\n\"\n\t        \"\\t-bench:         disable a/v output and bench source decoding (as fast as possible)\\n\"\n\t        \"\\t-vbench:        disable audio output, video sync bench source decoding/display (as fast as possible)\\n\"\n\t        \"\\t-sbench:        disable all decoders and bench systems layer (as fast as possible)\\n\"\n\t        \"\\t-fs:            starts in fullscreen mode\\n\"\n\t        \"\\t-views v1:.:vN: creates an auto-stereo scene of N views. vN can be any type of URL supported by GPAC.\\n\"\n\t        \"\\t                 in this mode, URL argument of GPAC is ignored, GUI as well.\\n\"\n\t        \"\\t                 this is equivalent as using views://v1:.:N as an URL.\\n\"\n\t        \"\\t-mosaic v1:.:vN: creates a mosaic of N views. vN can be any type of URL supported by GPAC.\\n\"\n\t        \"\\t                 in this mode, URL argument of GPAC is ignored.\\n\"\n\t        \"\\t                 this is equivalent as using mosaic://v1:.:N as an URL.\\n\"\n\t        \"\\n\"\n\t        \"\\t-exit:          automatically exits when presentation is over\\n\"\n\t        \"\\t-run-for TIME:  runs for TIME seconds and exits\\n\"\n\t        \"\\t-service ID:    auto-tune to given service ID in a multiplex\\n\"\n\t        \"\\t-noprog:        disable progress report\\n\"\n\t        \"\\t-no-save:       disable saving config file on exit\\n\"\n\t        \"\\t-no-addon:      disable automatic loading of media addons declared in source URL\\n\"\n\t        \"\\t-gui:           starts in GUI mode. The GUI is indicated in GPAC config, section General, by the key [StartupFile]\\n\"\n\t        \"\\t-ntp-shift T:   shifts NTP clock of T (signed int) milliseconds\\n\"\n\t        \"\\n\"\n\t        \"Dumper Options (times is a formated as start-end, with start being sec, h:m:s:f/fps or h:m:s:ms):\\n\"\n\t        \"\\t-bmp [times]:   dumps given frames to bmp\\n\"\n\t        \"\\t-png [times]:   dumps given frames to png\\n\"\n\t        \"\\t-raw [times]:   dumps given frames to raw\\n\"\n\t        \"\\t-avi [times]:   dumps given file to raw avi\\n\"\n\t        \"\\t-sha [times]:   dumps given file to raw SHA-1 (1 hash per frame)\\n\"\n\t        \"\\r-out filename:  name of the output file\\n\"\n\t        \"\\t-rgbds:         dumps the RGBDS pixel format texture\\n\"\n\t        \"\\t                 with -avi [times]: dumps an rgbds-format .avi\\n\"\n\t        \"\\t-rgbd:          dumps the RGBD pixel format texture\\n\"\n\t        \"\\t                 with -avi [times]: dumps an rgbd-format .avi\\n\"\n\t        \"\\t-depth:         dumps depthmap (z-buffer) frames\\n\"\n\t        \"\\t                 with -avi [times]: dumps depthmap in grayscale .avi\\n\"\n\t        \"\\t                 with -bmp: dumps depthmap in grayscale .bmp\\n\"\n\t        \"\\t                 with -png: dumps depthmap in grayscale .png\\n\"\n\t        \"\\t-fps FPS:       specifies frame rate for AVI dumping (default: %f)\\n\"\n\t        \"\\t-scale s:       scales the visual size (default: 1)\\n\"\n\t        \"\\t-fill:          uses fill aspect ratio for dumping (default: none)\\n\"\n\t        \"\\t-show:          shows window while dumping (default: no)\\n\"\n\t        \"\\n\"\n\t        \"\\t-uncache:       Revert all cached items to their original name and location. Does not start player.\\n\"\n\t        \"\\n\"\n\t        \"\\t-help:          shows this screen\\n\"\n\t        \"\\n\"\n\t        \"MP4Client - GPAC command line player and dumper - version \"GPAC_FULL_VERSION\"\\n\"\n\t        \"(c) Telecom ParisTech 2000-2018 - Licence LGPL v2\\n\"\n\t        \"GPAC Configuration: \" GPAC_CONFIGURATION \"\\n\"\n\t        \"Features: %s\\n\",\n\t        GF_IMPORT_DEFAULT_FPS,\n\t        gpac_features()\n\t       );\n}\n\nvoid PrintHelp()\n{\n\tfprintf(stderr, \"MP4Client command keys:\\n\"\n\t        \"\\tq: quit\\n\"\n\t        \"\\tX: kill\\n\"\n\t        \"\\to: connect to the specified URL\\n\"\n\t        \"\\tO: connect to the specified playlist\\n\"\n\t        \"\\tN: switch to the next URL in the playlist. Also works with \\\\n\\n\"\n\t        \"\\tP: jumps to a given number ahead in the playlist\\n\"\n\t        \"\\tr: reload current presentation\\n\"\n\t        \"\\tD: disconnects the current presentation\\n\"\n\t        \"\\tG: selects object or service ID\\n\"\n\t        \"\\n\"\n\t        \"\\tp: play/pause the presentation\\n\"\n\t        \"\\ts: step one frame ahead\\n\"\n\t        \"\\tz: seek into presentation by percentage\\n\"\n\t        \"\\tT: seek into presentation by time\\n\"\n\t        \"\\tt: print current timing\\n\"\n\t        \"\\n\"\n\t        \"\\tu: sends a command (BIFS or LASeR) to the main scene\\n\"\n\t        \"\\te: evaluates JavaScript code\\n\"\n\t        \"\\tZ: dumps output video to PNG\\n\"\n\t        \"\\n\"\n\t        \"\\tw: view world info\\n\"\n\t        \"\\tv: view Object Descriptor list\\n\"\n\t        \"\\ti: view Object Descriptor info (by ID)\\n\"\n\t        \"\\tj: view Object Descriptor info (by number)\\n\"\n\t        \"\\tb: view media objects timing and buffering info\\n\"\n\t        \"\\tm: view media objects buffering and memory info\\n\"\n\t        \"\\td: dumps scene graph\\n\"\n\t        \"\\n\"\n\t        \"\\tk: turns stress mode on/off\\n\"\n\t        \"\\tn: changes navigation mode\\n\"\n\t        \"\\tx: reset to last active viewpoint\\n\"\n\t        \"\\n\"\n\t        \"\\t3: switch OpenGL on or off for 2D scenes\\n\"\n\t        \"\\n\"\n\t        \"\\t4: forces 4/3 Aspect Ratio\\n\"\n\t        \"\\t5: forces 16/9 Aspect Ratio\\n\"\n\t        \"\\t6: forces no Aspect Ratio (always fill screen)\\n\"\n\t        \"\\t7: forces original Aspect Ratio (default)\\n\"\n\t        \"\\n\"\n\t        \"\\tL: changes to new log level. CF MP4Client usage for possible values\\n\"\n\t        \"\\tT: select new tools to log. CF MP4Client usage for possible values\\n\"\n\t        \"\\n\"\n\t        \"\\tl: list available modules\\n\"\n\t        \"\\tc: prints some GPAC configuration info\\n\"\n\t        \"\\tE: forces reload of GPAC configuration\\n\"\n\t        \"\\n\"\n\t        \"\\tR: toggles run-time info display in window title bar on/off\\n\"\n\t        \"\\tF: toggle displaying of FPS in stderr on/off\\n\"\n\t        \"\\tg: print GPAC allocated memory\\n\"\n\t        \"\\th: print this message\\n\"\n\t        \"\\n\"\n\t        \"\\tEXPERIMENTAL/UNSTABLE OPTIONS\\n\"\n\t        \"\\tC: Enable Streaming Cache\\n\"\n\t        \"\\tS: Stops Streaming Cache and save to file\\n\"\n\t        \"\\tA: Aborts Streaming Cache\\n\"\n\t        \"\\tM: specifies video cache memory for 2D objects\\n\"\n\t        \"\\n\"\n\t        \"MP4Client - GPAC command line player - version %s\\n\"\n\t        \"GPAC Written by Jean Le Feuvre (c) 2001-2005 - ENST (c) 2005-200X\\n\",\n\n\t        GPAC_FULL_VERSION\n\t       );\n}\n\n\nstatic void PrintTime(u64 time)\n{\n\tu32 ms, h, m, s;\n\th = (u32) (time / 1000 / 3600);\n\tm = (u32) (time / 1000 / 60 - h*60);\n\ts = (u32) (time / 1000 - h*3600 - m*60);\n\tms = (u32) (time - (h*3600 + m*60 + s) * 1000);\n\tfprintf(stderr, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n}\n\nvoid PrintAVInfo(Bool final);\n\n\nstatic u32 rti_update_time_ms = 200;\nstatic FILE *rti_logs = NULL;\n\nstatic void UpdateRTInfo(const char *legend)\n{\n\tGF_SystemRTInfo rti;\n\n\t/*refresh every second*/\n\tif (!display_rti && !rti_logs) return;\n\tif (!gf_sys_get_rti(rti_update_time_ms, &rti, 0) && !legend)\n\t\treturn;\n\n\tif (display_rti) {\n\t\tchar szMsg[1024];\n\n\t\tif (rti.total_cpu_usage && (bench_mode<2) ) {\n\t\t\tsprintf(szMsg, \"FPS %02.02f CPU %2d (%02d) Mem %d kB\",\n\t\t\t        gf_term_get_framerate(term, 0), rti.total_cpu_usage, rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024));\n\t\t} else {\n\t\t\tsprintf(szMsg, \"FPS %02.02f CPU %02d Mem %d kB\",\n\t\t\t        gf_term_get_framerate(term, 0), rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024) );\n\t\t}\n\n\t\tif (display_rti==2) {\n\t\t\tif (bench_mode>=2) {\n\t\t\t\tPrintAVInfo(GF_FALSE);\n\t\t\t}\n\t\t\tfprintf(stderr, \"%s\\r\", szMsg);\n\t\t} else {\n\t\t\tGF_Event evt;\n\t\t\tevt.type = GF_EVENT_SET_CAPTION;\n\t\t\tevt.caption.caption = szMsg;\n\t\t\tgf_term_user_event(term, &evt);\n\t\t}\n\t}\n\tif (rti_logs) {\n\t\tfprintf(rti_logs, \"% 8d\\t% 8d\\t% 8d\\t% 4d\\t% 8d\\t%s\",\n\t\t        gf_sys_clock(),\n\t\t        gf_term_get_time_in_ms(term),\n\t\t        rti.total_cpu_usage,\n\t\t        (u32) gf_term_get_framerate(term, 0),\n\t\t        (u32) (rti.gpac_memory / 1024),\n\t\t        legend ? legend : \"\"\n\t\t       );\n\t\tif (!legend) fprintf(rti_logs, \"\\n\");\n\t}\n}\n\nstatic void ResetCaption()\n{\n\tGF_Event event;\n\tif (display_rti) return;\n\tevent.type = GF_EVENT_SET_CAPTION;\n\tif (is_connected) {\n\t\tchar szName[1024];\n\t\tNetInfoCommand com;\n\n\t\tevent.caption.caption = NULL;\n\t\t/*get any service info*/\n\t\tif (!startup_file && gf_term_get_service_info(term, gf_term_get_root_object(term), &com) == GF_OK) {\n\t\t\tstrcpy(szName, \"\");\n\t\t\tif (com.track_info) {\n\t\t\t\tchar szBuf[10];\n\t\t\t\tsprintf(szBuf, \"%02d \", (u32) (com.track_info>>16) );\n\t\t\t\tstrcat(szName, szBuf);\n\t\t\t}\n\t\t\tif (com.artist) {\n\t\t\t\tstrcat(szName, com.artist);\n\t\t\t\tstrcat(szName, \" \");\n\t\t\t}\n\t\t\tif (com.name) {\n\t\t\t\tstrcat(szName, com.name);\n\t\t\t\tstrcat(szName, \" \");\n\t\t\t}\n\t\t\tif (com.album) {\n\t\t\t\tstrcat(szName, \"(\");\n\t\t\t\tstrcat(szName, com.album);\n\t\t\t\tstrcat(szName, \")\");\n\t\t\t}\n\t\t\tif (com.provider) {\n\t\t\t\tstrcat(szName, \"(\");\n\t\t\t\tstrcat(szName, com.provider);\n\t\t\t\tstrcat(szName, \")\");\n\t\t\t}\n\n\t\t\tif (strlen(szName)) event.caption.caption = szName;\n\t\t}\n\t\tif (!event.caption.caption) {\n\t\t\tchar *str = strrchr(the_url, '\\\\');\n\t\t\tif (!str) str = strrchr(the_url, '/');\n\t\t\tevent.caption.caption = str ? str+1 : the_url;\n\t\t}\n\t} else {\n\t\tevent.caption.caption = \"GPAC MP4Client \" GPAC_FULL_VERSION;\n\t}\n\tgf_term_user_event(term, &event);\n}\n\n#ifdef WIN32\nu32 get_sys_col(int idx)\n{\n\tu32 res;\n\tDWORD val = GetSysColor(idx);\n\tres = (val)&0xFF;\n\tres<<=8;\n\tres |= (val>>8)&0xFF;\n\tres<<=8;\n\tres |= (val>>16)&0xFF;\n\treturn res;\n}\n#endif\n\nvoid switch_bench(u32 is_on)\n{\n\tbench_mode = is_on;\n\tdisplay_rti = is_on ? 2 : 0;\n\tResetCaption();\n\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, is_on);\n}\n\n#ifndef WIN32\n#include <termios.h>\nint getch() {\n\tstruct termios old;\n\tstruct termios new;\n\tint rc;\n\tif (tcgetattr(0, &old) == -1) {\n\t\treturn -1;\n\t}\n\tnew = old;\n\tnew.c_lflag &= ~(ICANON | ECHO);\n\tnew.c_cc[VMIN] = 1;\n\tnew.c_cc[VTIME] = 0;\n\tif (tcsetattr(0, TCSANOW, &new) == -1) {\n\t\treturn -1;\n\t}\n\trc = getchar();\n\t(void) tcsetattr(0, TCSANOW, &old);\n\treturn rc;\n}\n#else\nint getch() {\n\treturn getchar();\n}\n#endif\n\n/**\n * Reads a line of input from stdin\n * @param line the buffer to fill\n * @param maxSize the maximum size of the line to read\n * @param showContent boolean indicating if the line read should be printed on stderr or not\n */\nstatic const char * read_line_input(char * line, int maxSize, Bool showContent) {\n\tchar read;\n\tint i = 0;\n\tif (fflush( stderr ))\n\t\tperror(\"Failed to flush buffer %s\");\n\tdo {\n\t\tline[i] = '\\0';\n\t\tif (i >= maxSize - 1)\n\t\t\treturn line;\n\t\tread = getch();\n\t\tif (read == 8 || read == 127) {\n\t\t\tif (i > 0) {\n\t\t\t\tfprintf(stderr, \"\\b \\b\");\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else if (read > 32) {\n\t\t\tfputc(showContent ? read : '*', stderr);\n\t\t\tline[i++] = read;\n\t\t}\n\t\tfflush(stderr);\n\t} while (read != '\\n');\n\tif (!read)\n\t\treturn 0;\n\treturn line;\n}\n\nstatic void do_set_speed(Fixed desired_speed)\n{\n\tif (gf_term_set_speed(term, desired_speed) == GF_OK) {\n\t\tplayback_speed = desired_speed;\n\t\tfprintf(stderr, \"Playing at %g speed\\n\", FIX2FLT(playback_speed));\n\t} else {\n\t\tfprintf(stderr, \"Adjusting speed to %g not supported for this content\\n\", FIX2FLT(desired_speed));\n\t}\n}\n\nBool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n\t\tbreak;\n\tcase GF_EVENT_NAVIGATE:\n\t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrcpy(the_url, evt->navigate.to_url);\n\t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n\t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}\n\n\nvoid list_modules(GF_ModuleManager *modules)\n{\n\tu32 i;\n\tfprintf(stderr, \"\\rAvailable modules:\\n\");\n\tfor (i=0; i<gf_modules_get_count(modules); i++) {\n\t\tchar *str = (char *) gf_modules_get_file_name(modules, i);\n\t\tif (str) fprintf(stderr, \"\\t%s\\n\", str);\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\nvoid set_navigation()\n{\n\tGF_Err e;\n\tchar nav;\n\tu32 type = gf_term_get_option(term, GF_OPT_NAVIGATION_TYPE);\n\te = GF_OK;\n\tfflush(stdin);\n\n\tif (!type) {\n\t\tfprintf(stderr, \"Content/compositor doesn't allow user-selectable navigation\\n\");\n\t} else if (type==1) {\n\t\tfprintf(stderr, \"Select Navigation (\\'N\\'one, \\'E\\'xamine, \\'S\\'lide): \");\n\t\tnav = getch();\n\t\tif (nav=='N') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);\n\t\telse if (nav=='E') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);\n\t\telse if (nav=='S') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);\n\t\telse fprintf(stderr, \"Unknown selector \\'%c\\' - only \\'N\\',\\'E\\',\\'S\\' allowed\\n\", nav);\n\t} else if (type==2) {\n\t\tfprintf(stderr, \"Select Navigation (\\'N\\'one, \\'W\\'alk, \\'F\\'ly, \\'E\\'xamine, \\'P\\'an, \\'S\\'lide, \\'G\\'ame, \\'V\\'R, \\'O\\'rbit): \");\n\t\tnav = getch();\n\t\tif (nav=='N') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);\n\t\telse if (nav=='W') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_WALK);\n\t\telse if (nav=='F') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_FLY);\n\t\telse if (nav=='E') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);\n\t\telse if (nav=='P') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_PAN);\n\t\telse if (nav=='S') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);\n\t\telse if (nav=='G') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_GAME);\n\t\telse if (nav=='O') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_ORBIT);\n\t\telse if (nav=='V') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_VR);\n\t\telse fprintf(stderr, \"Unknown selector %c - only \\'N\\',\\'W\\',\\'F\\',\\'E\\',\\'P\\',\\'S\\',\\'G\\', \\'V\\', \\'O\\' allowed\\n\", nav);\n\t}\n\tif (e) fprintf(stderr, \"Error setting mode: %s\\n\", gf_error_to_string(e));\n}\n\n\nstatic Bool get_time_list(char *arg, u32 *times, u32 *nb_times)\n{\n\tchar *str;\n\tFloat var;\n\tDouble sec;\n\tu32 h, m, s, ms, f, fps;\n\tif (!arg || (arg[0]=='-') || !isdigit(arg[0])) return 0;\n\n\t/*SMPTE time code*/\n\tif (strchr(arg, ':') && strchr(arg, ';') && strchr(arg, '/')) {\n\t\tif (sscanf(arg, \"%02ud:%02ud:%02ud;%02ud/%02ud\", &h, &m, &s, &f, &fps)==5) {\n\t\t\tsec = 0;\n\t\t\tif (fps) sec = ((Double)f) / fps;\n\t\t\tsec += 3600*h + 60*m + s;\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\twhile (arg) {\n\t\tstr = strchr(arg, '-');\n\t\tif (str) str[0] = 0;\n\t\t/*HH:MM:SS:MS time code*/\n\t\tif (strchr(arg, ':') && (sscanf(arg, \"%u:%u:%u:%u\", &h, &m, &s, &ms)==4)) {\n\t\t\tsec = ms;\n\t\t\tsec /= 1000;\n\t\t\tsec += 3600*h + 60*m + s;\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t} else if (sscanf(arg, \"%f\", &var)==1) {\n\t\t\tsec = atof(arg);\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t}\n\t\tif (!str) break;\n\t\tstr[0] = '-';\n\t\targ = str+1;\n\t}\n\treturn 1;\n}\n\nstatic u64 last_log_time=0;\nstatic void on_gpac_log(void *cbk, GF_LOG_Level ll, GF_LOG_Tool lm, const char *fmt, va_list list)\n{\n\tFILE *logs = cbk ? cbk : stderr;\n\n\tif (rti_logs && (lm & GF_LOG_RTI)) {\n\t\tchar szMsg[2048];\n\t\tvsprintf(szMsg, fmt, list);\n\t\tUpdateRTInfo(szMsg + 6 /*\"[RTI] \"*/);\n\t} else {\n\t\tif (log_time_start) {\n\t\t\tu64 now = gf_sys_clock_high_res();\n\t\t\tfprintf(logs, \"At \"LLD\" (diff %d) - \", now - log_time_start, (u32) (now - last_log_time) );\n\t\t\tlast_log_time = now;\n\t\t}\n\t\tif (log_utc_time) {\n\t\t\tu64 utc_clock = gf_net_get_utc() ;\n\t\t\ttime_t secs = utc_clock/1000;\n\t\t\tstruct tm t;\n\t\t\tt = *gmtime(&secs);\n\t\t\tfprintf(logs, \"UTC %d-%02d-%02dT%02d:%02d:%02dZ (TS \"LLU\") - \", 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, utc_clock);\n\t\t}\n\t\tvfprintf(logs, fmt, list);\n\t\tfflush(logs);\n\t}\n}\n\nstatic void init_rti_logs(char *rti_file, char *url, Bool use_rtix)\n{\n\tif (rti_logs) gf_fclose(rti_logs);\n\trti_logs = gf_fopen(rti_file, \"wt\");\n\tif (rti_logs) {\n\t\tfprintf(rti_logs, \"!! GPAC RunTime Info \");\n\t\tif (url) fprintf(rti_logs, \"for file %s\", url);\n\t\tfprintf(rti_logs, \" !!\\n\");\n\t\tfprintf(rti_logs, \"SysTime(ms)\\tSceneTime(ms)\\tCPU\\tFPS\\tMemory(kB)\\tObservation\\n\");\n\n\t\t/*turn on RTI loging*/\n\t\tif (use_rtix) {\n\t\t\tgf_log_set_callback(NULL, on_gpac_log);\n\t\t\tgf_log_set_tool_level(GF_LOG_RTI, GF_LOG_DEBUG);\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_RTI, (\"[RTI] System state when enabling log\\n\"));\n\t\t} else if (log_time_start) {\n\t\t\tlog_time_start = gf_sys_clock_high_res();\n\t\t}\n\t}\n}\n\nvoid set_cfg_option(char *opt_string)\n{\n\tchar *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];\n\tsep = strchr(opt_string, ':');\n\tif (!sep) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep - opt_string;\n\t\tstrncpy(szSec, opt_string, sepIdx);\n\t\tszSec[sepIdx] = 0;\n\t}\n\tsep ++;\n\tsep2 = strchr(sep, '=');\n\tif (!sep2) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep2 - sep;\n\t\tstrncpy(szKey, sep, sepIdx);\n\t\tszKey[sepIdx] = 0;\n\t\tstrcpy(szVal, sep2+1);\n\t}\n\n\tif (!stricmp(szKey, \"*\")) {\n\t\tif (stricmp(szVal, \"null\")) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:*=null\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tgf_cfg_del_section(cfg_file, szSec);\n\t\treturn;\n\t}\n\n\tif (!stricmp(szVal, \"null\")) {\n\t\tszVal[0]=0;\n\t}\n\tgf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);\n}\n\nBool revert_cache_file(void *cbck, char *item_name, char *item_path, GF_FileEnumInfo *file_info)\n{\n\tconst char *url;\n\tchar *sep;\n\tGF_Config *cached;\n\tif (strncmp(item_name, \"gpac_cache_\", 11)) return GF_FALSE;\n\tcached = gf_cfg_new(NULL, item_path);\n\turl = gf_cfg_get_key(cached, \"cache\", \"url\");\n\tif (url) url = strstr(url, \"://\");\n\tif (url) {\n\t\tu32 i, len, dir_len=0, k=0;\n\t\tchar *dst_name;\n\t\tsep = strstr(item_path, \"gpac_cache_\");\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tdir_len = (u32) strlen(item_path);\n\t\t\tsep[0] = 'g';\n\t\t}\n\t\turl+=3;\n\t\tlen = (u32) strlen(url);\n\t\tdst_name = gf_malloc(len+dir_len+1);\n\t\tmemset(dst_name, 0, len+dir_len+1);\n\n\t\tstrncpy(dst_name, item_path, dir_len);\n\t\tk=dir_len;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tdst_name[k] = url[i];\n\t\t\tif (dst_name[k]==':') dst_name[k]='_';\n\t\t\telse if (dst_name[k]=='/') {\n\t\t\t\tif (!gf_dir_exists(dst_name))\n\t\t\t\t\tgf_mkdir(dst_name);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tsep = strrchr(item_path, '.');\n\t\tif (sep) {\n\t\t\tsep[0]=0;\n\t\t\tif (gf_file_exists(item_path)) {\n\t\t\t\tgf_move_file(item_path, dst_name);\n\t\t\t}\n\t\t\tsep[0]='.';\n\t\t}\n\t\tgf_free(dst_name);\n\t}\n\tgf_cfg_del(cached);\n\tgf_delete_file(item_path);\n\treturn GF_FALSE;\n}\nvoid do_flatten_cache(const char *cache_dir)\n{\n\tgf_enum_directory(cache_dir, GF_FALSE, revert_cache_file, NULL, \"*.txt\");\n}\n\n\n#ifdef WIN32\n#include <wincon.h>\n#endif\n\nstatic void progress_quiet(const void *cbck, const char *title, u64 done, u64 total) { }\n\nint mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don't want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tstrcpy(the_url, url_arg);\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) strcpy(the_url, gf_dm_sess_get_cache_name(sess));\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrcpy(the_url, \"MP4Client \"GPAC_FULL_VERSION);\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}\n\n#if defined(WIN32) && !defined(NO_WMAIN)\nint wmain(int argc, wchar_t** wargv)\n{\n\tint i;\n\tint res;\n\tsize_t len;\n\tsize_t res_len;\n\tchar **argv;\n\targv = (char **)malloc(argc*sizeof(wchar_t *));\n\tfor (i = 0; i < argc; i++) {\n\t\twchar_t *src_str = wargv[i];\n\t\tlen = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(wargv[i]);\n\t\targv[i] = (char *)malloc(len + 1);\n\t\tres_len = gf_utf8_wcstombs(argv[i], len, &src_str);\n\t\targv[i][res_len] = 0;\n\t\tif (res_len > len) {\n\t\t\tfprintf(stderr, \"Length allocated for conversion of wide char to UTF-8 not sufficient\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tres = mp4client_main(argc, argv);\n\tfor (i = 0; i < argc; i++) {\n\t\tfree(argv[i]);\n\t}\n\tfree(argv);\n\treturn res;\n}\n#else\nint main(int argc, char** argv)\n{\n\treturn mp4client_main(argc, argv);\n}\n#endif //win32\nstatic GF_ObjectManager *video_odm = NULL;\nstatic GF_ObjectManager *audio_odm = NULL;\nstatic GF_ObjectManager *scene_odm = NULL;\nstatic u32 last_odm_count = 0;\nvoid PrintAVInfo(Bool final)\n{\n\tGF_MediaInfo a_odi, v_odi, s_odi;\n\tDouble avg_dec_time=0;\n\tu32 tot_time=0;\n\tBool print_codecs = final;\n\n\tif (scene_odm) {\n\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\tu32 count = gf_term_get_object_count(term, root_odm);\n\t\tif (last_odm_count != count) {\n\t\t\tlast_odm_count = count;\n\t\t\tscene_odm = NULL;\n\t\t}\n\t}\n\tif (!video_odm && !audio_odm && !scene_odm) {\n\t\tu32 count, i;\n\t\tGF_ObjectManager *root_odm = root_odm = gf_term_get_root_object(term);\n\t\tif (!root_odm) return;\n\n\t\tif (gf_term_get_object_info(term, root_odm, &v_odi)==GF_OK) {\n\t\t\tif (!scene_odm  && (v_odi.generated_scene== 0)) {\n\t\t\t\tscene_odm = root_odm;\n\t\t\t}\n\t\t}\n\n\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ObjectManager *odm = gf_term_get_object(term, root_odm, i);\n\t\t\tif (!odm) break;\n\t\t\tif (gf_term_get_object_info(term, odm, &v_odi) == GF_OK) {\n\t\t\t\tif (!video_odm && (v_odi.od_type == GF_STREAM_VISUAL) && (v_odi.raw_media || (v_odi.cb_max_count>1) || v_odi.direct_video_memory || (bench_mode == 3) )) {\n\t\t\t\t\tvideo_odm = odm;\n\t\t\t\t}\n\t\t\t\telse if (!audio_odm && (v_odi.od_type == GF_STREAM_AUDIO)) {\n\t\t\t\t\taudio_odm = odm;\n\t\t\t\t}\n\t\t\t\telse if (!scene_odm && (v_odi.od_type == GF_STREAM_SCENE)) {\n\t\t\t\t\tscene_odm = odm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0 && bench_buffer) {\n\t\tfprintf(stderr, \"Buffering %d %% \", bench_buffer-1);\n\t\treturn;\n\t}\n\n\tif (video_odm) {\n\t\tif (gf_term_get_object_info(term, video_odm, &v_odi)!= GF_OK) {\n\t\t\tvideo_odm = NULL;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmemset(&v_odi, 0, sizeof(v_odi));\n\t}\n\tif (print_codecs && audio_odm) {\n\t\tgf_term_get_object_info(term, audio_odm, &a_odi);\n\t} else {\n\t\tmemset(&a_odi, 0, sizeof(a_odi));\n\t}\n\tif ((print_codecs || !video_odm) && scene_odm) {\n\t\tgf_term_get_object_info(term, scene_odm, &s_odi);\n\t} else {\n\t\tmemset(&s_odi, 0, sizeof(s_odi));\n\t}\n\n\tif (final) {\n\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\tfprintf(stderr, \"                                                                                     \\r\");\n\t\tfprintf(stderr, \"************** Bench Mode Done in %d ms ********************\\n\", tot_time);\n\t\tif (bench_mode==3) fprintf(stderr, \"** Systems layer only (no decoding) **\\n\");\n\n\t\tif (!video_odm) {\n\t\t\tu32 nb_frames_drawn;\n\t\t\tDouble FPS = gf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\tfprintf(stderr, \"Drawn %d frames FPS %.2f (simulation FPS %.2f) - duration %d ms\\n\", nb_frames_drawn, ((Float)nb_frames_drawn*1000)/tot_time,(Float) FPS, gf_term_get_time_in_ms(term)  );\n\t\t}\n\t}\n\tif (print_codecs) {\n\t\tif (video_odm) {\n\t\t\tfprintf(stderr, \"%s %dx%d sar=%d:%d duration %.2fs\\n\", v_odi.codec_name, v_odi.width, v_odi.height, v_odi.par ? (v_odi.par>>16)&0xFF : 1, v_odi.par ? (v_odi.par)&0xFF : 1, v_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tu32 dec_run_time = v_odi.last_frame_time - v_odi.first_frame_time;\n\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\tif (v_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*v_odi.current_time / v_odi.duration ) );\n\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (max %d us/f) rate avg %d max %d\", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / dec_run_time, v_odi.max_dec_time, (u32) v_odi.avg_bitrate/1000, (u32) v_odi.max_bitrate/1000);\n\t\t\t\tif (v_odi.nb_dropped) {\n\t\t\t\t\tfprintf(stderr, \" (Error during bench: %d frames drop)\", v_odi.nb_dropped);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (audio_odm) {\n\t\t\tfprintf(stderr, \"%s SR %d num channels %d bpp %d duration %.2fs\\n\", a_odi.codec_name, a_odi.sample_rate, a_odi.num_channels, a_odi.bits_per_sample, a_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tu32 dec_run_time = a_odi.last_frame_time - a_odi.first_frame_time;\n\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\tif (a_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*a_odi.current_time / a_odi.duration ) );\n\t\t\t\tfprintf(stderr, \"%d frames (ms/f %.2f avg %.2f max) rate avg %d max %d\", a_odi.nb_dec_frames, ((Float)dec_run_time)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0, (u32) a_odi.avg_bitrate/1000, (u32) a_odi.max_bitrate/1000);\n\t\t\t\tif (a_odi.nb_dropped) {\n\t\t\t\t\tfprintf(stderr, \" (Error during bench: %d frames drop)\", a_odi.nb_dropped);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (scene_odm) {\n\t\t\tu32 w, h;\n\t\t\tgf_term_get_visual_output_size(term, &w, &h);\n\t\t\tfprintf(stderr, \"%s scene size %dx%d rastered to %dx%d duration %.2fs\\n\", s_odi.codec_name ? s_odi.codec_name : \"\", s_odi.width, s_odi.height, w, h, s_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tif (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {\n\t\t\t\t\tu32 dec_run_time = s_odi.last_frame_time - s_odi.first_frame_time;\n\t\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (max %d us/f) rate avg %d max %d\", s_odi.nb_dec_frames, ((Float)s_odi.nb_dec_frames*1000) / dec_run_time, s_odi.max_dec_time, (u32) s_odi.avg_bitrate/1000, (u32) s_odi.max_bitrate/1000);\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tu32 nb_frames_drawn;\n\t\t\t\t\tDouble FPS;\n\t\t\t\t\tgf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\t\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\t\t\t\tFPS = gf_term_get_framerate(term, 0);\n\t\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (abs %.2f)\\n\", nb_frames_drawn, (1000.0*nb_frames_drawn / tot_time), FPS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (final) {\n\t\t\tfprintf(stderr, \"**********************************************************\\n\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (video_odm) {\n\t\ttot_time = v_odi.last_frame_time - v_odi.first_frame_time;\n\t\tif (!tot_time) tot_time=1;\n\t\tif (v_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*v_odi.current_time / v_odi.duration ) );\n\t\tfprintf(stderr, \"%d f FPS %.2f (%.2f ms max) rate %d \", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / tot_time, v_odi.max_dec_time/1000.0, (u32) v_odi.instant_bitrate/1000);\n\t}\n\telse if (scene_odm) {\n\n\t\tif (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {\n\t\t\tavg_dec_time = (Float) 1000000 * s_odi.nb_dec_frames;\n\t\t\tavg_dec_time /= s_odi.total_dec_time;\n\t\t\tif (s_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*s_odi.current_time / s_odi.duration ) );\n\t\t\tfprintf(stderr, \"%d f %.2f (%d us max) - rate %d \", s_odi.nb_dec_frames, avg_dec_time, s_odi.max_dec_time, (u32) s_odi.instant_bitrate/1000);\n\t\t} else {\n\t\t\tu32 nb_frames_drawn;\n\t\t\tDouble FPS;\n\t\t\tgf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\t\tFPS = gf_term_get_framerate(term, 1);\n\t\t\tfprintf(stderr, \"%d f FPS %.2f (abs %.2f) \", nb_frames_drawn, (1000.0*nb_frames_drawn / tot_time), FPS);\n\t\t}\n\t}\n\telse if (audio_odm) {\n\t\tif (!print_codecs) {\n\t\t\tgf_term_get_object_info(term, audio_odm, &a_odi);\n\t\t}\n\t\ttot_time = a_odi.last_frame_time - a_odi.first_frame_time;\n\t\tif (!tot_time) tot_time=1;\n\t\tif (a_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*a_odi.current_time / a_odi.duration ) );\n\t\tfprintf(stderr, \"%d frames (ms/f %.2f avg %.2f max)\", a_odi.nb_dec_frames, ((Float)tot_time)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0);\n\t}\n}\n\nvoid PrintWorldInfo(GF_Terminal *term)\n{\n\tu32 i;\n\tconst char *title;\n\tGF_List *descs;\n\tdescs = gf_list_new();\n\ttitle = gf_term_get_world_info(term, NULL, descs);\n\tif (!title && !gf_list_count(descs)) {\n\t\tfprintf(stderr, \"No World Info available\\n\");\n\t} else {\n\t\tfprintf(stderr, \"\\t%s\\n\", title ? title : \"No title available\");\n\t\tfor (i=0; i<gf_list_count(descs); i++) {\n\t\t\tchar *str = gf_list_get(descs, i);\n\t\t\tfprintf(stderr, \"%s\\n\", str);\n\t\t}\n\t}\n\tgf_list_del(descs);\n}\n\nvoid PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name)\n{\n\tGF_MediaInfo odi;\n\tu32 i, count;\n\tchar szIndent[50];\n\tGF_ObjectManager *odm;\n\n\tif (!root_odm) {\n\t\tfprintf(stderr, \"Currently loaded objects:\\n\");\n\t\troot_odm = gf_term_get_root_object(term);\n\t}\n\tif (!root_odm) return;\n\n\tcount = gf_term_get_current_service_id(term);\n\tif (count)\n\t\tfprintf(stderr, \"Current service ID %d\\n\", count);\n\n\tif (gf_term_get_object_info(term, root_odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tfor (i=0; i<indent; i++) szIndent[i]=' ';\n\tszIndent[indent]=0;\n\n\tfprintf(stderr, \"%s\", szIndent);\n\tfprintf(stderr, \"#%d %s - \", num, root_name);\n\tif (odi.od->ServiceID) fprintf(stderr, \"Service ID %d \", odi.od->ServiceID);\n\tif (odi.media_url) {\n\t\tfprintf(stderr, \"%s\\n\", odi.media_url);\n\t} else {\n\t\tfprintf(stderr, \"OD ID %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tszIndent[indent]=' ';\n\tszIndent[indent+1]=0;\n\tindent++;\n\n\tcount = gf_term_get_object_count(term, root_odm);\n\tfor (i=0; i<count; i++) {\n\t\todm = gf_term_get_object(term, root_odm, i);\n\t\tif (!odm) break;\n\t\tnum++;\n\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\tswitch (gf_term_object_subscene_type(term, odm)) {\n\t\t\tcase 1:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Root\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Inline Scene\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tPrintODList(term, odm, num, indent, \"EXTERNPROTO Library\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"%s\", szIndent);\n\t\t\t\tfprintf(stderr, \"#%d - \", num);\n\t\t\t\tif (odi.media_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.media_url);\n\t\t\t\t} else if (odi.od) {\n\t\t\t\t \tif (odi.od->URLString) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", odi.od->URLString);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"ID %d\", odi.od->objectDescriptorID);\n\t\t\t\t\t}\n\t\t\t\t} else if (odi.service_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.service_url);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \" - %s\", (odi.od_type==GF_STREAM_VISUAL) ? \"Video\" : (odi.od_type==GF_STREAM_AUDIO) ? \"Audio\" : \"Systems\");\n\t\t\t\tif (odi.od && odi.od->ServiceID) fprintf(stderr, \" - Service ID %d\", odi.od->ServiceID);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ViewOD(GF_Terminal *term, u32 OD_ID, u32 number, const char *szURL)\n{\n\tGF_MediaInfo odi;\n\tu32 i, j, count, d_enum,id;\n\tGF_Err e;\n\tNetStatCommand com;\n\tGF_ObjectManager *odm, *root_odm = gf_term_get_root_object(term);\n\tif (!root_odm) return;\n\n\todm = NULL;\n\tif (!szURL && ((!OD_ID && (number == (u32)-1)) || ((OD_ID == (u32)(-1)) && !number))) {\n\t\todm = root_odm;\n\t\tif ((gf_term_get_object_info(term, odm, &odi) != GF_OK)) odm=NULL;\n\t} else {\n\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\tfor (i=0; i<count; i++) {\n\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\tif (!odm) break;\n\t\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\t\tif (szURL && strstr(odi.service_url, szURL)) break;\n\t\t\t\tif ((number == (u32)(-1)) && odi.od && (odi.od->objectDescriptorID == OD_ID)) break;\n\t\t\t\telse if (i == (u32)(number-1)) break;\n\t\t\t}\n\t\t\todm = NULL;\n\t\t}\n\t}\n\tif (!odm) {\n\t\tif (szURL) fprintf(stderr, \"cannot find OD for URL %s\\n\", szURL);\n\t\tif (number == (u32)-1) fprintf(stderr, \"cannot find OD with ID %d\\n\", OD_ID);\n\t\telse fprintf(stderr, \"cannot find OD with number %d\\n\", number);\n\t\treturn;\n\t}\n\tif (!odi.od) {\n\t\tif (number == (u32)-1) fprintf(stderr, \"Object %d not attached yet\\n\", OD_ID);\n\t\telse fprintf(stderr, \"Object #%d not attached yet\\n\", number);\n\t\treturn;\n\t}\n\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tif (odi.od->tag==GF_ODF_IOD_TAG) {\n\t\tfprintf(stderr, \"InitialObjectDescriptor %d\\n\", odi.od->objectDescriptorID);\n\t\tfprintf(stderr, \"Profiles and Levels: Scene %x - Graphics %x - Visual %x - Audio %x - OD %x\\n\",\n\t\t        odi.scene_pl, odi.graphics_pl, odi.visual_pl, odi.audio_pl, odi.OD_pl);\n\t\tfprintf(stderr, \"Inline Profile Flag %d\\n\", odi.inline_pl);\n\t} else {\n\t\tfprintf(stderr, \"ObjectDescriptor %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tfprintf(stderr, \"Object Duration: \");\n\tif (odi.duration) {\n\t\tPrintTime((u32) (odi.duration*1000));\n\t} else {\n\t\tfprintf(stderr, \"unknown\");\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"Service Handler: %s\\n\", odi.service_handler);\n\tfprintf(stderr, \"Service URL: %s\\n\", odi.service_url);\n\n\tif (odi.codec_name) {\n\t\tFloat avg_dec_time;\n\t\tswitch (odi.od_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tfprintf(stderr, \"Video Object: Width %d - Height %d\\r\\n\", odi.width, odi.height);\n\t\t\tfprintf(stderr, \"Media Codec: %s\\n\", odi.codec_name);\n\t\t\tif (odi.par) fprintf(stderr, \"Pixel Aspect Ratio: %d:%d\\n\", (odi.par>>16)&0xFF, (odi.par)&0xFF);\n\t\t\tbreak;\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tfprintf(stderr, \"Audio Object: Sample Rate %d - %d channels\\r\\n\", odi.sample_rate, odi.num_channels);\n\t\t\tfprintf(stderr, \"Media Codec: %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\tcase GF_STREAM_PRIVATE_SCENE:\n\t\t\tif (odi.width && odi.height) {\n\t\t\t\tfprintf(stderr, \"Scene Description - Width %d - Height %d\\n\", odi.width, odi.height);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Scene Description - no size specified\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"Scene Codec: %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\tcase GF_STREAM_TEXT:\n\t\t\tif (odi.width && odi.height) {\n\t\t\t\tfprintf(stderr, \"Text Object: Width %d - Height %d\\n\", odi.width, odi.height);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Text Object: No size specified\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"Text Codec %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\t}\n\n\t\tavg_dec_time = 0;\n\t\tif (odi.nb_dec_frames) {\n\t\t\tavg_dec_time = (Float) odi.total_dec_time;\n\t\t\tavg_dec_time /= odi.nb_dec_frames;\n\t\t}\n\t\tfprintf(stderr, \"\\tBitrate over last second: %d kbps\\n\\tMax bitrate over one second: %d kbps\\n\\tAverage Decoding Time %.2f us %d max)\\n\\tTotal decoded frames %d\\n\",\n\t\t        (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, avg_dec_time, odi.max_dec_time, odi.nb_dec_frames);\n\t}\n\tif (odi.protection) fprintf(stderr, \"Encrypted Media%s\\n\", (odi.protection==2) ? \" NOT UNLOCKED\" : \"\");\n\n\tcount = gf_list_count(odi.od->ESDescriptors);\n\tfprintf(stderr, \"%d streams in OD\\n\", count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ESD *esd = (GF_ESD *) gf_list_get(odi.od->ESDescriptors, i);\n\n\t\tfprintf(stderr, \"\\nStream ID %d - Clock ID %d\\n\", esd->ESID, esd->OCRESID);\n\t\tif (esd->dependsOnESID) fprintf(stderr, \"\\tDepends on Stream ID %d for decoding\\n\", esd->dependsOnESID);\n\n\t\tswitch (esd->decoderConfig->streamType) {\n\t\tcase GF_STREAM_OD:\n\t\t\tfprintf(stderr, \"\\tOD Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_OCR:\n\t\t\tfprintf(stderr, \"\\tOCR Stream\\n\");\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\t\tfprintf(stderr, \"\\tScene Description Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tfprintf(stderr, \"\\tVisual Stream - media type: %s\", gf_esd_get_textual_description(esd));\n\t\t\tbreak;\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tfprintf(stderr, \"\\tAudio Stream - media type: %s\", gf_esd_get_textual_description(esd));\n\t\t\tbreak;\n\t\tcase GF_STREAM_MPEG7:\n\t\t\tfprintf(stderr, \"\\tMPEG-7 Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_IPMP:\n\t\t\tfprintf(stderr, \"\\tIPMP Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_OCI:\n\t\t\tfprintf(stderr, \"\\tOCI Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_MPEGJ:\n\t\t\tfprintf(stderr, \"\\tMPEGJ Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_INTERACT:\n\t\t\tfprintf(stderr, \"\\tUser Interaction Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_TEXT:\n\t\t\tfprintf(stderr, \"\\tStreaming Text Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"\\tUnknown Stream\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfprintf(stderr, \"\\tBuffer Size %d\\n\\tAverage Bitrate %d bps\\n\\tMaximum Bitrate %d bps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate, esd->decoderConfig->maxBitrate);\n\t\tif (esd->slConfig->predefined==SLPredef_SkipSL) {\n\t\t\tfprintf(stderr, \"\\tNot using MPEG-4 Synchronization Layer\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tStream Clock Resolution %d\\n\", esd->slConfig->timestampResolution);\n\t\t}\n\t\tif (esd->URLString) fprintf(stderr, \"\\tStream Location: %s\\n\", esd->URLString);\n\n\t\t/*check language*/\n\t\tif (esd->langDesc) {\n\t\t\ts32 lang_idx;\n\t\t\tchar lan[4];\n\t\t\tlan[0] = esd->langDesc->langCode>>16;\n\t\t\tlan[1] = (esd->langDesc->langCode>>8)&0xFF;\n\t\t\tlan[2] = (esd->langDesc->langCode)&0xFF;\n\t\t\tlan[3] = 0;\n\n\t\t\tlang_idx = gf_lang_find(lan);\n\t\t\tif (lang_idx>=0) {\n\t\t\t\tfprintf(stderr, \"\\tStream Language: %s\\n\", gf_lang_get_name(lang_idx));\n\t\t\t}\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n\t/*check OCI (not everything interests us) - FIXME: support for unicode*/\n\tcount = gf_list_count(odi.od->OCIDescriptors);\n\tif (count) {\n\t\tfprintf(stderr, \"%d Object Content Information descriptors in OD\\n\", count);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *) gf_list_get(odi.od->OCIDescriptors, i);\n\t\t\tswitch (desc->tag) {\n\t\t\tcase GF_ODF_SEGMENT_TAG:\n\t\t\t{\n\t\t\t\tGF_Segment *sd = (GF_Segment *) desc;\n\t\t\t\tfprintf(stderr, \"Segment Descriptor: Name: %s - start time %g sec - duration %g sec\\n\", sd->SegmentName, sd->startTime, sd->Duration);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ODF_CC_NAME_TAG:\n\t\t\t{\n\t\t\t\tGF_CC_Name *ccn = (GF_CC_Name *)desc;\n\t\t\t\tfprintf(stderr, \"Content Creators:\\n\");\n\t\t\t\tfor (j=0; j<gf_list_count(ccn->ContentCreators); j++) {\n\t\t\t\t\tGF_ContentCreatorInfo *ci = (GF_ContentCreatorInfo *) gf_list_get(ccn->ContentCreators, j);\n\t\t\t\t\tif (!ci->isUTF8) continue;\n\t\t\t\t\tfprintf(stderr, \"\\t%s\\n\", ci->contentCreatorName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase GF_ODF_SHORT_TEXT_TAG:\n\t\t\t{\n\t\t\t\tGF_ShortTextual *std = (GF_ShortTextual *)desc;\n\t\t\t\tfprintf(stderr, \"Description:\\n\\tEvent: %s\\n\\t%s\\n\", std->eventName, std->eventText);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tswitch (odi.status) {\n\tcase 0:\n\t\tfprintf(stderr, \"Stopped - \");\n\t\tbreak;\n\tcase 1:\n\t\tfprintf(stderr, \"Playing - \");\n\t\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"Paused - \");\n\t\tbreak;\n\tcase 3:\n\t\tfprintf(stderr, \"Not setup yet\\n\");\n\t\treturn;\n\tdefault:\n\t\tfprintf(stderr, \"Setup Failed\\n\");\n\t\treturn;\n\t}\n\tif (odi.buffer>=0) fprintf(stderr, \"Buffer: %d ms - \", odi.buffer);\n\telse fprintf(stderr, \"Not buffering - \");\n\tfprintf(stderr, \"Clock drift: %d ms\\n\", odi.clock_drift);\n\tif (odi.db_unit_count) fprintf(stderr, \"%d AU in DB\\n\", odi.db_unit_count);\n\tif (odi.cb_max_count) fprintf(stderr, \"Composition Buffer: %d CU (%d max)\\n\", odi.cb_unit_count, odi.cb_max_count);\n\tfprintf(stderr, \"\\n\");\n\n\tif (odi.owns_service) {\n\t\tconst char *url;\n\t\tu32 done, total, bps;\n\t\td_enum = 0;\n\t\twhile (gf_term_get_download_info(term, odm, &d_enum, &url, NULL, &done, &total, &bps)) {\n\t\t\tif (d_enum==1) fprintf(stderr, \"Current Downloads in service:\\n\");\n\t\t\tif (done && total) {\n\t\t\t\tfprintf(stderr, \"%s: %d / %d bytes (%.2f %%) - %.2f kBps\\n\", url, done, total, (100.0f*done)/total, ((Float)bps)/1024.0f);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: %.2f kbps\\n\", url, ((Float)8*bps)/1024.0f);\n\t\t\t}\n\t\t}\n\t\tif (!d_enum) fprintf(stderr, \"No Downloads in service\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\td_enum = 0;\n\twhile (gf_term_get_channel_net_info(term, odm, &d_enum, &id, &com, &e)) {\n\t\tif (e) continue;\n\t\tif (!com.bw_down && !com.bw_up) continue;\n\n\t\tfprintf(stderr, \"Stream ID %d statistics:\\n\", id);\n\t\tif (com.multiplex_port) {\n\t\t\tfprintf(stderr, \"\\tMultiplex Port %d - multiplex ID %d\\n\", com.multiplex_port, com.port);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tPort %d\\n\", com.port);\n\t\t}\n\t\tfprintf(stderr, \"\\tPacket Loss Percentage: %.4f\\n\", com.pck_loss_percentage);\n\t\tfprintf(stderr, \"\\tDown Bandwidth: %d bps\\n\", com.bw_down);\n\t\tif (com.bw_up) fprintf(stderr, \"\\tUp Bandwidth: %d bps\\n\", com.bw_up);\n\t\tif (com.ctrl_port) {\n\t\t\tif (com.multiplex_port) {\n\t\t\t\tfprintf(stderr, \"\\tControl Multiplex Port: %d - Control Multiplex ID %d\\n\", com.multiplex_port, com.ctrl_port);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tControl Port: %d\\n\", com.ctrl_port);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tDown Bandwidth: %d bps\\n\", com.ctrl_bw_down);\n\t\t\tfprintf(stderr, \"\\tUp Bandwidth: %d bps\\n\", com.ctrl_bw_up);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid PrintODTiming(GF_Terminal *term, GF_ObjectManager *odm, u32 indent)\n{\n\tGF_MediaInfo odi;\n\tu32 ind = indent;\n\tu32 i, count;\n\tif (!odm) return;\n\n\tif (gf_term_get_object_info(term, odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\twhile (ind) {\n\t\tfprintf(stderr, \" \");\n\t\tind--;\n\t}\n\n\tif (! odi.generated_scene) {\n\n\t\tfprintf(stderr, \"- OD %d: \", odi.od->objectDescriptorID);\n\t\tswitch (odi.status) {\n\t\tcase 1:\n\t\t\tfprintf(stderr, \"Playing - \");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(stderr, \"Paused - \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Stopped - \");\n\t\t\tbreak;\n\t\t}\n\t\tif (odi.buffer>=0) fprintf(stderr, \"Buffer: %d ms - \", odi.buffer);\n\t\telse fprintf(stderr, \"Not buffering - \");\n\t\tfprintf(stderr, \"Clock drift: %d ms\", odi.clock_drift);\n\t\tfprintf(stderr, \" - time: \");\n\t\tPrintTime((u32) (odi.current_time*1000));\n\t\tfprintf(stderr, \"\\n\");\n\n\t} else {\n\t\tfprintf(stderr, \"+ Service %s:\\n\", odi.service_url);\n\t}\n\n\tcount = gf_term_get_object_count(term, odm);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ObjectManager *an_odm = gf_term_get_object(term, odm, i);\n\t\tPrintODTiming(term, an_odm, indent+1);\n\t}\n\treturn;\n\n}\n\nvoid PrintODBuffer(GF_Terminal *term, GF_ObjectManager *odm, u32 indent)\n{\n\tFloat avg_dec_time;\n\tGF_MediaInfo odi;\n\tu32 ind, i, count;\n\tif (!odm) return;\n\n\tif (gf_term_get_object_info(term, odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tind = indent;\n\twhile (ind) {\n\t\tfprintf(stderr, \" \");\n\t\tind--;\n\t}\n\n\tif (odi.generated_scene) {\n\t\tfprintf(stderr, \"+ Service %s:\\n\", odi.service_url);\n\t} else {\n\t\tfprintf(stderr, \"- OD %d: \", odi.od->objectDescriptorID);\n\t\tswitch (odi.status) {\n\t\tcase 1:\n\t\t\tfprintf(stderr, \"Playing\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(stderr, \"Paused\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Stopped\");\n\t\t\tbreak;\n\t\t}\n\t\tif (odi.buffer>=0) fprintf(stderr, \" - Buffer: %d ms\", odi.buffer);\n\t\tif (odi.db_unit_count) fprintf(stderr, \" - DB: %d AU\", odi.db_unit_count);\n\t\tif (odi.cb_max_count) fprintf(stderr, \" - CB: %d/%d CUs\", odi.cb_unit_count, odi.cb_max_count);\n\n\t\tfprintf(stderr, \"\\n\");\n\t\tind = indent;\n\t\twhile (ind) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tind--;\n\t\t}\n\n\t\tfprintf(stderr, \" %d decoded frames - %d dropped frames\\n\", odi.nb_dec_frames, odi.nb_dropped);\n\n\t\tind = indent;\n\t\twhile (ind) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tind--;\n\t\t}\n\n\t\tavg_dec_time = 0;\n\t\tif (odi.nb_dec_frames) {\n\t\t\tavg_dec_time = (Float) odi.total_dec_time;\n\t\t\tavg_dec_time /= odi.nb_dec_frames;\n\t\t}\n\t\tfprintf(stderr, \" Avg Bitrate %d kbps (%d max) - Avg Decoding Time %.2f us (%d max)\\n\",\n\t\t        (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, avg_dec_time, odi.max_dec_time);\n\t}\n\n\tcount = gf_term_get_object_count(term, odm);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ObjectManager *an_odm = gf_term_get_object(term, odm, i);\n\t\tPrintODBuffer(term, an_odm, indent+1);\n\t}\n\n}\n\nvoid ViewODs(GF_Terminal *term, Bool show_timing)\n{\n\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\tif (!root_odm) return;\n\n\tif (show_timing) {\n\t\tPrintODTiming(term, root_odm, 0);\n\t} else {\n\t\tPrintODBuffer(term, root_odm, 0);\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\n\nvoid PrintGPACConfig()\n{\n\tu32 i, j, cfg_count, key_count;\n\tchar szName[200];\n\tchar *secName = NULL;\n\n\tfprintf(stderr, \"Enter section name (\\\"*\\\" for complete dump):\\n\");\n\tif (1 > scanf(\"%s\", szName)) {\n\t\tfprintf(stderr, \"No section name, aborting.\\n\");\n\t\treturn;\n\t}\n\tif (strcmp(szName, \"*\")) secName = szName;\n\n\tfprintf(stderr, \"\\n\\n*** GPAC Configuration ***\\n\\n\");\n\n\tcfg_count = gf_cfg_get_section_count(cfg_file);\n\tfor (i=0; i<cfg_count; i++) {\n\t\tconst char *sec = gf_cfg_get_section_name(cfg_file, i);\n\t\tif (secName) {\n\t\t\tif (stricmp(sec, secName)) continue;\n\t\t} else {\n\t\t\tif (!stricmp(sec, \"General\")) continue;\n\t\t\tif (!stricmp(sec, \"MimeTypes\")) continue;\n\t\t\tif (!stricmp(sec, \"RecentFiles\")) continue;\n\t\t}\n\t\tfprintf(stderr, \"[%s]\\n\", sec);\n\t\tkey_count = gf_cfg_get_key_count(cfg_file, sec);\n\t\tfor (j=0; j<key_count; j++) {\n\t\t\tconst char *key = gf_cfg_get_key_name(cfg_file, sec, j);\n\t\t\tconst char *val = gf_cfg_get_key(cfg_file, sec, key);\n\t\t\tfprintf(stderr, \"%s=%s\\n\", key, val);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / FFMPEG module\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"ffmpeg_in.h\"\n\n#ifndef DISABLE_FFMPEG_DEMUX\n\n/*default buffer is 200 ms per channel*/\n#define FFD_DATA_BUFFER\t\t800\n\n//#define FFMPEG_DEMUX_ENABLE_MPEG2TS\n\n//#if defined(__DARWIN__) || defined(__APPLE__)\n#if !defined(WIN32) && !defined(_WIN32_WCE) && !defined(__SYMBIAN32__)\n#include <errno.h>\n#endif\n\n/**\n * New versions of ffmpeg do not declare AVERROR_NOMEM, AVERROR_IO, AVERROR_NOFMT\n */\n\n#ifndef AVERROR_NOMEM\n#define AVERROR_NOMEM AVERROR(ENOMEM)\n#endif /* AVERROR_NOMEM */\n\n#ifndef AVERROR_IO\n#define AVERROR_IO AVERROR(EIO)\n#endif /* AVERROR_IO */\n\n#ifndef AVERROR_NOFMT\n#define AVERROR_NOFMT AVERROR(EINVAL)\n#endif /* AVERROR_NOFMT */\n\n\n#if ((LIBAVFORMAT_VERSION_MAJOR == 54) && (LIBAVFORMAT_VERSION_MINOR >= 20)) || (LIBAVFORMAT_VERSION_MAJOR > 54)\n\n#define av_find_stream_info(__c)\tavformat_find_stream_info(__c, NULL)\n#define USE_AVFORMAT_OPEN_INPUT\t1\n#endif\n\n\n#if defined(GPAC_ANDROID) && (LIBAVFORMAT_VERSION_MAJOR <= 52)\n\n#ifndef FF_API_CLOSE_INPUT_FILE\n#define FF_API_CLOSE_INPUT_FILE\t1\n#endif\n\n#endif\n\n\n\nstatic u32 FFDemux_Run(void *par)\n{\n\tAVPacket pkt;\n\ts64 seek_to;\n\tGF_NetworkCommand com;\n\tGF_NetworkCommand map;\n\tGF_SLHeader slh;\n\tFFDemux *ffd = (FFDemux *) par;\n\n\tmemset(&map, 0, sizeof(GF_NetworkCommand));\n\tmap.command_type = GF_NET_CHAN_MAP_TIME;\n\n\tmemset(&com, 0, sizeof(GF_NetworkCommand));\n\tcom.command_type = GF_NET_BUFFER_QUERY;\n\n\tmemset(&slh, 0, sizeof(GF_SLHeader));\n\n\tslh.compositionTimeStampFlag = slh.decodingTimeStampFlag = 1;\n\n\twhile (ffd->is_running) {\n\t\t//nothing connected, wait\n\t\tif (!ffd->video_ch && !ffd->audio_ch) {\n\t\t\tgf_sleep(100);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((ffd->seek_time>=0) && ffd->seekable) {\n\t\t\tseek_to = (s64) (AV_TIME_BASE*ffd->seek_time);\n\t\t\tav_seek_frame(ffd->ctx, -1, seek_to, AVSEEK_FLAG_BACKWARD);\n\t\t\tffd->seek_time = -1;\n\t\t}\n\t\tpkt.stream_index = -1;\n\t\t/*EOF*/\n\t\tif (av_read_frame(ffd->ctx, &pkt) <0) break;\n\t\tif (pkt.pts == AV_NOPTS_VALUE) pkt.pts = pkt.dts;\n\t\tif (!pkt.dts) pkt.dts = pkt.pts;\n\n\t\tslh.compositionTimeStamp = pkt.pts;\n\t\tslh.decodingTimeStamp = pkt.dts;\n\n\t\tgf_mx_p(ffd->mx);\n\t\t/*blindly send audio as soon as video is init*/\n\t\tif (ffd->audio_ch && (pkt.stream_index == ffd->audio_st) ) {\n\t\t\tslh.compositionTimeStamp *= ffd->audio_tscale.num;\n\t\t\tslh.decodingTimeStamp *= ffd->audio_tscale.num;\n\n\t\t\tgf_service_send_packet(ffd->service, ffd->audio_ch, (char *) pkt.data, pkt.size, &slh, GF_OK);\n\t\t}\n\t\telse if (ffd->video_ch && (pkt.stream_index == ffd->video_st)) {\n\t\t\tslh.compositionTimeStamp *= ffd->video_tscale.num;\n\t\t\tslh.decodingTimeStamp *= ffd->video_tscale.num;\n\t\t\tslh.randomAccessPointFlag = pkt.flags&AV_PKT_FLAG_KEY ? 1 : 0;\n\t\t\tgf_service_send_packet(ffd->service, ffd->video_ch, (char *) pkt.data, pkt.size, &slh, GF_OK);\n\t\t}\n\t\tgf_mx_v(ffd->mx);\n\t\tav_free_packet(&pkt);\n\n\t\t/*sleep untill the buffer occupancy is too low - note that this work because all streams in this\n\t\tdemuxer are synchronized*/\n\t\twhile (ffd->audio_run || ffd->video_run) {\n\t\t\tgf_service_command(ffd->service, &com, GF_OK);\n\t\t\tif (com.buffer.occupancy < com.buffer.max)\n\t\t\t\tbreak;\n\n\t\t\tgf_sleep(1);\n\t\t}\n\n\t\tif (!ffd->audio_run && !ffd->video_run) break;\n\t}\n\t/*signal EOS*/\n\tif (ffd->audio_ch) gf_service_send_packet(ffd->service, ffd->audio_ch, NULL, 0, NULL, GF_EOS);\n\tif (ffd->video_ch) gf_service_send_packet(ffd->service, ffd->video_ch, NULL, 0, NULL, GF_EOS);\n\tffd->is_running = 2;\n\n\treturn 0;\n}\n\nstatic const char * FFD_MIME_TYPES[] = {\n\t\"video/x-mpeg\", \"mpg mpeg mp2 mpa mpe mpv2\", \"MPEG 1/2 Movies\",\n\t\"video/x-mpeg-systems\", \"mpg mpeg mp2 mpa mpe mpv2\", \"MPEG 1/2 Movies\",\n\t\"audio/basic\", \"snd au\", \"Basic Audio\",\n\t\"audio/x-wav\", \"wav\", \"WAV Audio\",\n\t\"audio/vnd.wave\", \"wav\", \"WAV Audio\",\n\t\"video/x-ms-asf\", \"asf wma wmv asx asr\", \"WindowsMedia Movies\",\n\t\"video/x-ms-wmv\", \"asf wma wmv asx asr\", \"WindowsMedia Movies\",\n\t\"video/x-msvideo\", \"avi\", \"AVI Movies\",\n\t\"video/x-ms-video\", \"avi\", \"AVI Movies\",\n\t\"video/avi\", \"avi\", \"AVI Movies\",\n\t\"video/vnd.avi\", \"avi\", \"AVI Movies\",\n\t\"video/H263\", \"h263 263\", \"H263 Video\",\n\t\"video/H264\", \"h264 264\", \"H264 Video\",\n\t\"video/MPEG4\", \"cmp\", \"MPEG-4 Video\",\n\t/* We let ffmpeg handle mov because some QT files with uncompressed or adpcm audio use 1 audio sample\n\t   per MP4 sample which is a killer for our MP4 lib, whereas ffmpeg handles these as complete audio chunks\n\t   moreover ffmpeg handles cmov, we don't */\n\t\"video/quicktime\", \"mov qt\", \"QuickTime Movies\",\n\t/* Supported by latest versions of FFMPEG */\n\t\"video/webm\", \"webm\", \"Google WebM Movies\",\n\t\"audio/webm\", \"webm\", \"Google WebM Music\",\n#ifdef FFMPEG_DEMUX_ENABLE_MPEG2TS\n\t\"video/mp2t\", \"ts\", \"MPEG 2 TS\",\n#endif\n\tNULL\n};\n\nstatic u32 FFD_RegisterMimeTypes(const GF_InputService *plug) {\n\tu32 i;\n\tfor (i = 0 ; FFD_MIME_TYPES[i]; i+=3)\n\t\tgf_service_register_mime(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2]);\n\treturn i/3;\n}\n\nstatic int open_file(AVFormatContext **\tic_ptr, const char * \tfilename, AVInputFormat * \tfmt, void *ops) {\n#ifdef USE_PRE_0_7\n\treturn av_open_input_file(ic_ptr, filename, fmt, 0, NULL);\n#else\n\treturn avformat_open_input(ic_ptr, filename, fmt, (AVDictionary**)ops);\n#endif\n}\n\nvoid ffd_parse_options(FFDemux *ffd, const char *url)\n{\n#ifdef USE_AVFORMAT_OPEN_INPUT\n\tint res;\n\tchar *frag = (char*) strchr(url, '#');\n\tif (frag) frag = frag+1;\n\n\tif (ffd->options) return;\n\n\twhile (frag) {\n\t\tchar *mid, *sep = strchr(frag, ':');\n\t\tif (sep) sep[0] = 0;\n\t\tmid = strchr(frag, '=');\n\t\tif (mid) {\n\t\t\tmid[0] = 0;\n\t\t\tres = av_dict_set(&ffd->options, frag, mid+1, 0);\n\t\t\tif (res<0) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] Failed to set option %s:%s\\n\", frag, mid+1) );\n\t\t\t}\n\t\t\tmid[0] = '=';\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0] = ':';\n\t\tfrag = sep+1;\n\t}\n#endif\n}\n\n\nstatic Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)\n{\n\tBool has_audio, has_video;\n\ts32 i;\n\tAVFormatContext *ctx;\n\tAVOutputFormat *fmt_out;\n\tBool ret = GF_FALSE;\n\tchar *ext, szName[1000], szExt[20];\n\tconst char *szExtList;\n\tFFDemux *ffd;\n\tif (!plug || !url)\n\t\treturn GF_FALSE;\n\t/*disable RTP/RTSP from ffmpeg*/\n\tif (!strnicmp(url, \"rtsp://\", 7)) return GF_FALSE;\n\tif (!strnicmp(url, \"rtspu://\", 8)) return GF_FALSE;\n\tif (!strnicmp(url, \"rtp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"plato://\", 8)) return GF_FALSE;\n\tif (!strnicmp(url, \"udp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"tcp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"data:\", 5)) return GF_FALSE;\n\n\tffd = (FFDemux*)plug->priv;\n\n\tstrcpy(szName, url);\n\text = strrchr(szName, '#');\n\tif (ext) ext[0] = 0;\n\text = strrchr(szName, '?');\n\tif (ext) ext[0] = 0;\n\n\text = strrchr(szName, '.');\n\tif (ext && strlen(ext) > 19) ext = NULL;\n\n\tif (ext && strlen(ext) > 1) {\n\t\tstrcpy(szExt, &ext[1]);\n\t\tstrlwr(szExt);\n#ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS\n\t\tif (strstr(\"ts m2t mts dmb trp\", szExt) ) return GF_FALSE;\n#endif\n\n\t\t/*note we forbid ffmpeg to handle files we support*/\n\t\tif (!strcmp(szExt, \"mp4\") || !strcmp(szExt, \"mpg4\") || !strcmp(szExt, \"m4a\") || !strcmp(szExt, \"m21\")\n\t\t        || !strcmp(szExt, \"m4v\") || !strcmp(szExt, \"m4a\")\n\t\t        || !strcmp(szExt, \"m4s\") || !strcmp(szExt, \"3gs\")\n\t\t        || !strcmp(szExt, \"3gp\") || !strcmp(szExt, \"3gpp\") || !strcmp(szExt, \"3gp2\") || !strcmp(szExt, \"3g2\")\n\t\t        || !strcmp(szExt, \"mp3\")\n\t\t        || !strcmp(szExt, \"ac3\")\n\t\t        || !strcmp(szExt, \"amr\")\n\t\t        || !strcmp(szExt, \"bt\") || !strcmp(szExt, \"wrl\") || !strcmp(szExt, \"x3dv\")\n\t\t        || !strcmp(szExt, \"xmt\") || !strcmp(szExt, \"xmta\") || !strcmp(szExt, \"x3d\")\n\n\t\t        || !strcmp(szExt, \"jpg\") || !strcmp(szExt, \"jpeg\") || !strcmp(szExt, \"png\")\n\t\t   ) return GF_FALSE;\n\n\t\t/*check any default stuff that should work with ffmpeg*/\n\t\t{\n\t\t\tu32 i;\n\t\t\tfor (i = 0 ; FFD_MIME_TYPES[i]; i+=3) {\n\t\t\t\tif (gf_service_check_mime_register(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2], ext))\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tffd_parse_options(ffd, url);\n\n\tctx = NULL;\n\tif (open_file(&ctx, szName, NULL, ffd->options ? &ffd->options : NULL)<0) {\n\t\tAVInputFormat *av_in = NULL;\n\t\t/*some extensions not supported by ffmpeg*/\n\t\tif (ext && !strcmp(szExt, \"cmp\")) av_in = av_find_input_format(\"m4v\");\n\n\t\tif (open_file(&ctx, szName, av_in, ffd->options ? &ffd->options : NULL)<0) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\tif (!ctx) goto exit;\n\tif (av_find_stream_info(ctx) <0) goto exit;\n\n\t/*figure out if we can use codecs or not*/\n\thas_video = has_audio = GF_FALSE;\n\tfor(i = 0; i < (s32)ctx->nb_streams; i++) {\n\t\tAVCodecContext *enc = ctx->streams[i]->codec;\n\t\tswitch(enc->codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tif (!has_audio) has_audio = GF_TRUE;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tif (!has_video) has_video= GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!has_audio && !has_video) goto exit;\n\tret = GF_TRUE;\n#if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52)\n\tfmt_out = guess_stream_format(NULL, url, NULL);\n#else\n\tfmt_out = av_guess_format(NULL, url, NULL);\n#endif\n\tif (fmt_out) gf_service_register_mime(plug, fmt_out->mime_type, fmt_out->extensions, fmt_out->name);\n\telse {\n\t\text = strrchr(szName, '.');\n\t\tif (ext) {\n\t\t\tstrcpy(szExt, &ext[1]);\n\t\t\tstrlwr(szExt);\n\n\t\t\tszExtList = gf_modules_get_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\");\n\t\t\tif (!szExtList) {\n\t\t\t\tgf_service_register_mime(plug, \"application/x-ffmpeg\", szExt, \"Other Movies (FFMPEG)\");\n\t\t\t} else if (!strstr(szExtList, szExt)) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *buf;\n\t\t\t\tlen = (u32) (strlen(szExtList) + strlen(szExt) + 10);\n\t\t\t\tbuf = (char*)gf_malloc(sizeof(char)*len);\n\t\t\t\tsprintf(buf, \"\\\"%s \", szExt);\n\t\t\t\tstrcat(buf, &szExtList[1]);\n\t\t\t\tgf_modules_set_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\", buf);\n\t\t\t\tgf_free(buf);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n#if FF_API_CLOSE_INPUT_FILE\n\tif (ctx) av_close_input_file(ctx);\n#else\n\tif (ctx) avformat_close_input(&ctx);\n#endif\n\treturn ret;\n}\n\nstatic GF_ESD *FFD_GetESDescriptor(FFDemux *ffd, Bool for_audio)\n{\n\tGF_BitStream *bs;\n\tBool dont_use_sl;\n\tGF_ESD *esd = (GF_ESD *) gf_odf_desc_esd_new(0);\n\tesd->ESID = 1 + (for_audio ? ffd->audio_st : ffd->video_st);\n\tesd->decoderConfig->streamType = for_audio ? GF_STREAM_AUDIO : GF_STREAM_VISUAL;\n\tesd->decoderConfig->avgBitrate = esd->decoderConfig->maxBitrate = 0;\n\n\t/*remap std object types - depending on input formats, FFMPEG may not have separate DSI from initial frame.\n\tIn this case we have no choice but using FFMPEG decoders*/\n\tif (for_audio) {\n\t\tAVCodecContext *dec = ffd->ctx->streams[ffd->audio_st]->codec;\n\t\tesd->slConfig->timestampResolution = ffd->audio_tscale.den;\n\t\tswitch (dec->codec_id) {\n\t\tcase CODEC_ID_MP2:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_MPEG1;\n\t\t\tbreak;\n\t\tcase CODEC_ID_MP3:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_MPEG2_PART3;\n\t\t\tbreak;\n\t\tcase CODEC_ID_AAC:\n\t\t\tif (!dec->extradata_size) goto opaque_audio;\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = dec->extradata_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = (char*)gf_malloc(sizeof(char)*dec->extradata_size);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data,\n\t\t\t       dec->extradata,\n\t\t\t       sizeof(char)*dec->extradata_size);\n\t\t\tbreak;\n\t\tdefault:\nopaque_audio:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_FFMPEG;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, dec->codec_id);\n\t\t\tgf_bs_write_u32(bs, dec->sample_rate);\n\t\t\tgf_bs_write_u16(bs, dec->channels);\n\t\t\tgf_bs_write_u16(bs, dec->frame_size);\n\t\t\tgf_bs_write_u8(bs, 16);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t/*ffmpeg specific*/\n\t\t\tgf_bs_write_u16(bs, dec->block_align);\n\t\t\tgf_bs_write_u32(bs, dec->bit_rate);\n\t\t\tgf_bs_write_u32(bs, dec->codec_tag);\n\t\t\tif (dec->extradata_size) {\n\t\t\t\tgf_bs_write_data(bs, (char *) dec->extradata, dec->extradata_size);\n\t\t\t}\n\t\t\tgf_bs_get_content(bs, (char **) &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\t}\n\t\tdont_use_sl = ffd->unreliable_audio_timing;\n\t} else {\n\t\tAVCodecContext *dec = ffd->ctx->streams[ffd->video_st]->codec;\n\t\tesd->slConfig->timestampResolution = ffd->video_tscale.den;\n\t\tswitch (dec->codec_id) {\n\t\tcase CODEC_ID_MPEG4:\n\t\t\t/*there is a bug in fragmentation of raw H264 in ffmpeg, the NALU startcode (0x00000001) is split across\n\t\t\ttwo frames - we therefore force internal ffmpeg codec ID to avoid NALU size recompute\n\t\t\tat the decoder level*/\n//\t\tcase CODEC_ID_H264:\n\t\t\t/*if dsi not detected force use ffmpeg*/\n\t\t\tif (!dec->extradata_size) goto opaque_video;\n\t\t\t/*otherwise use any MPEG-4 Visual*/\n\t\t\tesd->decoderConfig->objectTypeIndication = (dec->codec_id==CODEC_ID_H264) ? GPAC_OTI_VIDEO_AVC : GPAC_OTI_VIDEO_MPEG4_PART2;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = dec->extradata_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = (char*)gf_malloc(sizeof(char)*dec->extradata_size);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data,\n\t\t\t       dec->extradata,\n\t\t\t       sizeof(char)*dec->extradata_size);\n\t\t\tbreak;\n\t\tcase CODEC_ID_MPEG1VIDEO:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MPEG1;\n\t\t\tbreak;\n\t\tcase CODEC_ID_MPEG2VIDEO:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MPEG2_MAIN;\n\t\t\tbreak;\n\n\t\tcase CODEC_ID_H263:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_GENERIC;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, GF_4CC('s', '2', '6', '3') );\n\t\t\tgf_bs_write_u16(bs, dec->width);\n\t\t\tgf_bs_write_u16(bs, dec->height);\n\t\t\tgf_bs_get_content(bs, (char **) &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\tdefault:\nopaque_video:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_FFMPEG;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, dec->codec_id);\n\t\t\tgf_bs_write_u16(bs, dec->width);\n\t\t\tgf_bs_write_u16(bs, dec->height);\n\t\t\t/*ffmpeg specific*/\n\t\t\tgf_bs_write_u32(bs, dec->bit_rate);\n\t\t\tgf_bs_write_u32(bs, dec->codec_tag);\n\t\t\tgf_bs_write_u32(bs, dec->pix_fmt);\n\n\t\t\tif (dec->extradata_size) {\n\t\t\t\tgf_bs_write_data(bs, (char *) dec->extradata, dec->extradata_size);\n\t\t\t}\n\t\t\tgf_bs_get_content(bs, (char **) &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\t}\n\t\tdont_use_sl = GF_FALSE;\n\t}\n\n\tif (dont_use_sl) {\n\t\tesd->slConfig->predefined = SLPredef_SkipSL;\n\t} else {\n\t\t/*only send full AUs*/\n\t\tesd->slConfig->useAccessUnitStartFlag = esd->slConfig->useAccessUnitEndFlag = 0;\n\t\tif (for_audio) {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\t} else {\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 1;\n\t\t}\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t}\n\n\treturn esd;\n}\n\n\nstatic void FFD_SetupObjects(FFDemux *ffd)\n{\n\tGF_ESD *esd;\n\tGF_ObjectDescriptor *od;\n\tu32 audio_esid = 0;\n\n\tif ((ffd->audio_st>=0) && (ffd->service_type != 1)) {\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tesd = FFD_GetESDescriptor(ffd, GF_TRUE);\n\t\tod->objectDescriptorID = esd->ESID;\n\t\taudio_esid = esd->ESID;\n\t\tgf_list_add(od->ESDescriptors, esd);\n\t\tgf_service_declare_media(ffd->service, (GF_Descriptor*)od, (ffd->video_st>=0) ? GF_TRUE : GF_FALSE);\n\t}\n\tif ((ffd->video_st>=0) && (ffd->service_type != 2)) {\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tesd = FFD_GetESDescriptor(ffd, GF_FALSE);\n\t\tod->objectDescriptorID = esd->ESID;\n\t\tesd->OCRESID = audio_esid;\n\t\tgf_list_add(od->ESDescriptors, esd);\n\t\tgf_service_declare_media(ffd->service, (GF_Descriptor*)od, GF_FALSE);\n\t}\n}\n\n#ifdef USE_PRE_0_7\nstatic int ff_url_read(void *h, unsigned char *buf, int size)\n{\n\tu32 retry = 10;\n\tu32 read;\n\tint full_size;\n\tFFDemux *ffd = (FFDemux *)h;\n\n\tfull_size = 0;\n\tif (ffd->buffer_used) {\n\t\tif (ffd->buffer_used >= (u32) size) {\n\t\t\tffd->buffer_used-=size;\n\t\t\tmemcpy(ffd->buffer, ffd->buffer+size, sizeof(char)*ffd->buffer_used);\n#ifdef FFMPEG_DUMP_REMOTE\n\t\t\tif (ffd->outdbg) gf_fwrite(buf, size, 1, ffd->outdbg);\n#endif\n\t\t\treturn size;\n\t\t}\n\t\tfull_size += ffd->buffer_used;\n\t\tbuf += ffd->buffer_used;\n\t\tsize -= ffd->buffer_used;\n\t\tffd->buffer_used = 0;\n\t}\n\n\twhile (size) {\n\t\tGF_Err e = gf_dm_sess_fetch_data(ffd->dnload, buf, size, &read);\n\t\tif (e==GF_EOS) break;\n\t\t/*we're sync!!*/\n\t\tif (e==GF_IP_NETWORK_EMPTY) {\n\t\t\tif (!retry) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] timeout fetching bytes from network\\n\") );\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tretry --;\n\t\t\tgf_sleep(100);\n\t\t\tcontinue;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] error fetching bytes from network: %s\\n\", gf_error_to_string(e) ) );\n\t\t\treturn -1;\n\t\t}\n\t\tfull_size += read;\n\t\tif (read==size) break;\n\t\tsize -= read;\n\t\tbuf += read;\n\t}\n#ifdef FFMPEG_DUMP_REMOTE\n\tif (ffd->outdbg) gf_fwrite(ffd->buffer, full_size, 1, ffd->outdbg);\n#endif\n\treturn full_size ? (int) full_size : -1;\n}\n#endif /*USE_PRE_0_7*/\n\n\nstatic GF_Err FFD_ConnectService(GF_InputService *plug, GF_ClientService *serv, const char *url)\n{\n\tGF_Err e;\n\ts64 last_aud_pts;\n\tu32 i;\n\ts32 res;\n\tBool is_local;\n\tconst char *sOpt;\n\tchar *ext, szName[1024];\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\tAVInputFormat *av_in = NULL;\n\tchar szExt[20];\n\n\tif (ffd->ctx) return GF_SERVICE_ERROR;\n\n\tassert( url && strlen(url) < 1024);\n\tstrcpy(szName, url);\n\text = strrchr(szName, '#');\n\tffd->service_type = 0;\n\tffd->service = serv;\n\n\tif (ext) {\n\t\tif (!stricmp(&ext[1], \"video\")) ffd->service_type = 1;\n\t\telse if (!stricmp(&ext[1], \"audio\")) ffd->service_type = 2;\n\t\text[0] = 0;\n\t}\n\n\tffd_parse_options(ffd, url);\n\n\t/*some extensions not supported by ffmpeg, overload input format*/\n\text = strrchr(szName, '.');\n\tstrcpy(szExt, ext ? ext+1 : \"\");\n\tstrlwr(szExt);\n\tif (!strcmp(szExt, \"cmp\")) av_in = av_find_input_format(\"m4v\");\n\n\tis_local = (strnicmp(url, \"file://\", 7) && strstr(url, \"://\")) ? GF_FALSE : GF_TRUE;\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[FFMPEG] opening file %s - local %d - av_in %08x\\n\", url, is_local, av_in));\n\n\tif (!is_local) {\n\t\tAVProbeData   pd;\n\n\t\t/*setup wraper for FFMPEG I/O*/\n\t\tffd->buffer_size = 8192;\n\t\tsOpt = gf_modules_get_option((GF_BaseInterface *)plug, \"FFMPEG\", \"IOBufferSize\");\n\t\tif (sOpt) ffd->buffer_size = atoi(sOpt);\n\t\tffd->buffer = (char*)gf_malloc(sizeof(char)*ffd->buffer_size);\n#ifdef FFMPEG_DUMP_REMOTE\n\t\tffd->outdbg = gf_fopen(\"ffdeb.raw\", \"wb\");\n#endif\n#ifdef USE_PRE_0_7\n\t\tinit_put_byte(&ffd->io, ffd->buffer, ffd->buffer_size, 0, ffd, ff_url_read, NULL, NULL);\n\t\tffd->io.is_streamed = 1;\n#else\n\t\tffd->io.seekable = 1;\n#endif\n\n\t\tffd->dnload = gf_service_download_new(ffd->service, url, GF_NETIO_SESSION_NOT_THREADED  | GF_NETIO_SESSION_NOT_CACHED, NULL, ffd);\n\t\tif (!ffd->dnload) return GF_URL_ERROR;\n\t\twhile (1) {\n\t\t\tu32 read;\n\t\t\te = gf_dm_sess_fetch_data(ffd->dnload, ffd->buffer + ffd->buffer_used, ffd->buffer_size - ffd->buffer_used, &read);\n\t\t\tif (e==GF_EOS) break;\n\t\t\t/*we're sync!!*/\n\t\t\tif (e==GF_IP_NETWORK_EMPTY) continue;\n\t\t\tif (e) goto err_exit;\n\t\t\tffd->buffer_used += read;\n\t\t\tif (ffd->buffer_used == ffd->buffer_size) break;\n\t\t}\n\t\tif (e==GF_EOS) {\n\t\t\tconst char *cache_file = gf_dm_sess_get_cache_name(ffd->dnload);\n\t\t\tres = open_file(&ffd->ctx, cache_file, av_in, ffd->options ? &ffd->options : NULL);\n\t\t} else {\n\t\t\tpd.filename = szName;\n\t\t\tpd.buf_size = ffd->buffer_used;\n\t\t\tpd.buf = (u8 *) ffd->buffer;\n\t\t\tav_in = av_probe_input_format(&pd, 1);\n\t\t\tif (!av_in) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG] error probing file %s - probe start with %c %c %c %c\\n\", url, ffd->buffer[0], ffd->buffer[1], ffd->buffer[2], ffd->buffer[3]));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\t/*setup downloader*/\n\t\t\tav_in->flags |= AVFMT_NOFILE;\n#ifdef USE_AVFORMAT_OPEN_INPUT /*commit ffmpeg 603b8bc2a109978c8499b06d2556f1433306eca7*/\n\t\t\tres = avformat_open_input(&ffd->ctx, szName, av_in, NULL);\n#else\n\t\t\tres = av_open_input_stream(&ffd->ctx, &ffd->io, szName, av_in, NULL);\n#endif\n\t\t}\n\t} else {\n\t\tres = open_file(&ffd->ctx, szName, av_in, ffd->options ? &ffd->options : NULL);\n\t}\n\n\tswitch (res) {\n#ifndef _WIN32_WCE\n\tcase 0:\n\t\te = GF_OK;\n\t\tbreak;\n\tcase AVERROR_IO:\n\t\te = GF_URL_ERROR;\n\t\tgoto err_exit;\n\tcase AVERROR_INVALIDDATA:\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto err_exit;\n\tcase AVERROR_NOMEM:\n\t\te = GF_OUT_OF_MEM;\n\t\tgoto err_exit;\n\tcase AVERROR_NOFMT:\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto err_exit;\n#endif\n\tdefault:\n\t\te = GF_SERVICE_ERROR;\n\t\tgoto err_exit;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[FFMPEG] looking for streams in %s - %d streams - type %s\\n\", ffd->ctx->filename, ffd->ctx->nb_streams, ffd->ctx->iformat->name));\n\n#ifdef USE_AVFORMAT_OPEN_INPUT\n\tres = avformat_find_stream_info(ffd->ctx, ffd->options ? &ffd->options : NULL);\n#else\n\tres = av_find_stream_info(ffd->ctx);\n#endif\n\n\tif (res <0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG] cannot locate streams - error %d\\n\", res));\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto err_exit;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[FFMPEG] file %s opened - %d streams\\n\", url, ffd->ctx->nb_streams));\n\n\t/*figure out if we can use codecs or not*/\n\tffd->audio_st = ffd->video_st = -1;\n\tfor (i = 0; i < ffd->ctx->nb_streams; i++) {\n\t\tAVCodecContext *enc = ffd->ctx->streams[i]->codec;\n\t\tswitch(enc->codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tif ((ffd->audio_st<0) && (ffd->service_type!=1)) {\n\t\t\t\tffd->audio_st = i;\n\t\t\t\tffd->audio_tscale = ffd->ctx->streams[i]->time_base;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tif ((ffd->video_st<0) && (ffd->service_type!=2)) {\n\t\t\t\tffd->video_st = i;\n\t\t\t\tffd->video_tscale = ffd->ctx->streams[i]->time_base;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((ffd->service_type==1) && (ffd->video_st<0)) goto err_exit;\n\tif ((ffd->service_type==2) && (ffd->audio_st<0)) goto err_exit;\n\tif ((ffd->video_st<0) && (ffd->audio_st<0)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG] No supported streams in file\\n\"));\n\t\tgoto err_exit;\n\t}\n\n\n\tsOpt = gf_modules_get_option((GF_BaseInterface *)plug, \"FFMPEG\", \"DataBufferMS\");\n\tffd->data_buffer_ms = 0;\n\tif (sOpt) ffd->data_buffer_ms = atoi(sOpt);\n\tif (!ffd->data_buffer_ms) ffd->data_buffer_ms = FFD_DATA_BUFFER;\n\n\t/*build seek*/\n\tif (is_local) {\n\t\t/*check we do have increasing pts. If not we can't rely on pts, we must skip SL\n\t\twe assume video pts is always present*/\n\t\tif (ffd->audio_st>=0) {\n\t\t\tlast_aud_pts = 0;\n\t\t\tfor (i=0; i<20; i++) {\n\t\t\t\tAVPacket pkt;\n\t\t\t\tpkt.stream_index = -1;\n\t\t\t\tif (av_read_frame(ffd->ctx, &pkt) <0) break;\n\t\t\t\tif (pkt.pts == AV_NOPTS_VALUE) pkt.pts = pkt.dts;\n\t\t\t\tif (pkt.stream_index==ffd->audio_st) last_aud_pts = pkt.pts;\n\t\t\t}\n\t\t\tif (last_aud_pts*ffd->audio_tscale.den<10*ffd->audio_tscale.num) ffd->unreliable_audio_timing = GF_TRUE;\n\t\t}\n\n\t\tffd->seekable = (av_seek_frame(ffd->ctx, -1, 0, AVSEEK_FLAG_BACKWARD)<0) ? GF_FALSE : GF_TRUE;\n\t\tif (!ffd->seekable) {\n#if FF_API_CLOSE_INPUT_FILE\n\t\t\tav_close_input_file(ffd->ctx);\n#else\n\t\t\tavformat_close_input(&ffd->ctx);\n#endif\n\t\t\tffd->ctx = NULL;\n\t\t\topen_file(&ffd->ctx, szName, av_in, ffd->options ? &ffd->options : NULL);\n\t\t\tav_find_stream_info(ffd->ctx);\n\t\t}\n\t}\n\n\t/*let's go*/\n\tgf_service_connect_ack(serv, NULL, GF_OK);\n\t/*if (!ffd->service_type)*/ FFD_SetupObjects(ffd);\n\tffd->service_type = 0;\n\treturn GF_OK;\n\nerr_exit:\n\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG] Error opening file %s: %s\\n\", url, gf_error_to_string(e)));\n#if FF_API_CLOSE_INPUT_FILE\n\tif (ffd->ctx) av_close_input_file(ffd->ctx);\n#else\n\tif (ffd->ctx) avformat_close_input(&ffd->ctx);\n#endif\n\tffd->ctx = NULL;\n\tgf_service_connect_ack(serv, NULL, e);\n\treturn e;\n}\n\n\nstatic GF_Descriptor *FFD_GetServiceDesc(GF_InputService *plug, u32 expect_type, const char *sub_url)\n{\n\tGF_ObjectDescriptor *od;\n\tGF_ESD *esd;\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\tif (!ffd->ctx) return NULL;\n\n\tif (expect_type==GF_MEDIA_OBJECT_UNDEF) {\n\t\tif (ffd->video_st>=0) expect_type=GF_MEDIA_OBJECT_VIDEO;\n\t\telse if (ffd->audio_st>=0) expect_type=GF_MEDIA_OBJECT_AUDIO;\n\t}\n\n\n\t/*since we don't handle multitrack in ffmpeg, we don't need to check sub_url, only use expected type*/\n\tif (expect_type==GF_MEDIA_OBJECT_AUDIO) {\n\t\tif (ffd->audio_st<0) return NULL;\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tod->objectDescriptorID = 1;\n\t\tesd = FFD_GetESDescriptor(ffd, GF_TRUE);\n\t\t/*if session join, setup sync*/\n\t\tif (ffd->video_ch) esd->OCRESID = ffd->video_st+1;\n\t\tgf_list_add(od->ESDescriptors, esd);\n\t\tffd->service_type = 2;\n\t\treturn (GF_Descriptor *) od;\n\t}\n\tif (expect_type==GF_MEDIA_OBJECT_VIDEO) {\n\t\tif (ffd->video_st<0) return NULL;\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tod->objectDescriptorID = 1;\n\t\tesd = FFD_GetESDescriptor(ffd, GF_FALSE);\n\t\t/*if session join, setup sync*/\n\t\tif (ffd->audio_ch) esd->OCRESID = ffd->audio_st+1;\n\t\tgf_list_add(od->ESDescriptors, esd);\n\t\tffd->service_type = 1;\n\t\treturn (GF_Descriptor *) od;\n\t}\n\treturn NULL;\n}\n\n\nstatic GF_Err FFD_CloseService(GF_InputService *plug)\n{\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\tffd->is_running = 0;\n\n#if FF_API_CLOSE_INPUT_FILE\n\tif (ffd->ctx) av_close_input_file(ffd->ctx);\n#else\n\tif (ffd->ctx) avformat_close_input(&ffd->ctx);\n#endif\n\n\tffd->ctx = NULL;\n\tffd->audio_ch = ffd->video_ch = NULL;\n\tffd->audio_run = ffd->video_run = GF_FALSE;\n\n\tif (ffd->dnload) {\n\t\tif (ffd->is_running) {\n\t\t\twhile (!ffd->is_running) gf_sleep(1);\n\t\t\tffd->is_running = 0;\n\t\t}\n\t\tgf_service_download_del(ffd->dnload);\n\t\tffd->dnload = NULL;\n\t}\n\tif (ffd->buffer) gf_free(ffd->buffer);\n\tffd->buffer = NULL;\n\n\tgf_service_disconnect_ack(ffd->service, NULL, GF_OK);\n#ifdef FFMPEG_DUMP_REMOTE\n\tif (ffd->outdbg) gf_fclose(ffd->outdbg);\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err FFD_ConnectChannel(GF_InputService *plug, LPNETCHANNEL channel, const char *url, Bool upstream)\n{\n\tGF_Err e;\n\tu32 ESID;\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\te = GF_STREAM_NOT_FOUND;\n\tif (upstream) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (!strstr(url, \"ES_ID=\")) {\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto exit;\n\t}\n\tsscanf(url, \"ES_ID=%u\", &ESID);\n\n\tif ((s32) ESID == 1 + ffd->audio_st) {\n\t\tif (ffd->audio_ch) {\n\t\t\te = GF_SERVICE_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t\tffd->audio_ch = channel;\n\t\te = GF_OK;\n\t}\n\telse if ((s32) ESID == 1 + ffd->video_st) {\n\t\tif (ffd->video_ch) {\n\t\t\te = GF_SERVICE_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t\tffd->video_ch = channel;\n\t\te = GF_OK;\n\t}\n\nexit:\n\tgf_service_connect_ack(ffd->service, channel, e);\n\treturn GF_OK;\n}\n\nstatic GF_Err FFD_DisconnectChannel(GF_InputService *plug, LPNETCHANNEL channel)\n{\n\tGF_Err e;\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\te = GF_STREAM_NOT_FOUND;\n\tif (ffd->audio_ch == channel) {\n\t\te = GF_OK;\n\t\tffd->audio_ch = NULL;\n\t\tffd->audio_run = GF_FALSE;\n\t}\n\telse if (ffd->video_ch == channel) {\n\t\te = GF_OK;\n\t\tffd->video_ch = NULL;\n\t\tffd->video_run = GF_FALSE;\n\t}\n\tgf_service_disconnect_ack(ffd->service, channel, e);\n\treturn GF_OK;\n}\n\nstatic GF_Err FFD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)\n{\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\n\tif (com->command_type==GF_NET_SERVICE_HAS_AUDIO) {\n\t\tif (ffd->audio_st>=0) return GF_OK;\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (!com->base.on_channel) return GF_NOT_SUPPORTED;\n\n\tswitch (com->command_type) {\n\t/*only BIFS/OD work in pull mode (cf ffmpeg_in.h)*/\n\tcase GF_NET_CHAN_SET_PULL:\n\t\treturn GF_NOT_SUPPORTED;\n\tcase GF_NET_CHAN_INTERACTIVE:\n\t\treturn ffd->seekable ? GF_OK : GF_NOT_SUPPORTED;\n\tcase GF_NET_CHAN_BUFFER:\n\t\treturn GF_OK;\n\tcase GF_NET_CHAN_DURATION:\n\t\tif (ffd->ctx->duration == AV_NOPTS_VALUE)\n\t\t\tcom->duration.duration = -1;\n\t\telse\n\t\t\tcom->duration.duration = (Double) ffd->ctx->duration / AV_TIME_BASE;\n\t\treturn GF_OK;\n\t/*fetch start time*/\n\tcase GF_NET_CHAN_PLAY:\n\t\tif (com->play.speed<0) return GF_NOT_SUPPORTED;\n\n\t\tgf_mx_p(ffd->mx);\n\t\tffd->seek_time = (com->play.start_range>=0) ? com->play.start_range : 0;\n\n\t\tif (ffd->audio_ch==com->base.on_channel) ffd->audio_run = GF_TRUE;\n\t\telse if (ffd->video_ch==com->base.on_channel) ffd->video_run = GF_TRUE;\n\n\t\t/*play on media stream, start thread*/\n\t\tif ((ffd->audio_ch==com->base.on_channel) || (ffd->video_ch==com->base.on_channel)) {\n\t\t\tif (ffd->is_running!=1) {\n\t\t\t\tffd->is_running = 1;\n\t\t\t\tgf_th_run(ffd->thread, FFDemux_Run, ffd);\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(ffd->mx);\n\t\treturn GF_OK;\n\tcase GF_NET_CHAN_STOP:\n\t\tif (ffd->audio_ch==com->base.on_channel) ffd->audio_run = GF_FALSE;\n\t\telse if (ffd->video_ch==com->base.on_channel) ffd->video_run = GF_FALSE;\n\t\treturn GF_OK;\n\t/*note we don't handle PAUSE/RESUME/SET_SPEED, this is automatically handled by the demuxing thread\n\tthrough buffer occupancy queries*/\n\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\treturn GF_OK;\n}\n\n\nstatic Bool FFD_CanHandleURLInService(GF_InputService *plug, const char *url)\n{\n\tchar szURL[2048], *sep;\n\tFFDemux *ffd;\n\tconst char *this_url;\n\tif (!plug || !url)\n\t\treturn GF_FALSE;\n\tffd = (FFDemux *)plug->priv;\n\tthis_url = gf_service_get_url(ffd->service);\n\tif (!this_url)\n\t\treturn GF_FALSE;\n\n\tstrcpy(szURL, this_url);\n\tsep = strrchr(szURL, '#');\n\tif (sep) sep[0] = 0;\n\n\tif ((url[0] != '#') && strnicmp(szURL, url, sizeof(char)*strlen(szURL))) return GF_FALSE;\n\tsep = strrchr(url, '#');\n\tif (sep && !stricmp(sep, \"#video\") && (ffd->video_st>=0)) return GF_TRUE;\n\tif (sep && !stricmp(sep, \"#audio\") && (ffd->audio_st>=0)) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nvoid *New_FFMPEG_Demux()\n{\n\tGF_InputService *ffd;\n\tFFDemux *priv;\n\tGF_SAFEALLOC(ffd, GF_InputService);\n\tif (!ffd) return NULL;\n\tGF_SAFEALLOC(priv, FFDemux);\n\tif (!priv) {\n\t\tgf_free(ffd);\n\t\treturn NULL;\n\t}\n\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] Registering all ffmpeg plugins...\\n\") );\n\t/* register all codecs, demux and protocols */\n\tav_register_all();\n\tavformat_network_init();\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] Registering all ffmpeg plugins DONE.\\n\") );\n\n\tffd->RegisterMimeTypes = FFD_RegisterMimeTypes;\n\tffd->CanHandleURL = FFD_CanHandleURL;\n\tffd->CloseService = FFD_CloseService;\n\tffd->ConnectChannel = FFD_ConnectChannel;\n\tffd->ConnectService = FFD_ConnectService;\n\tffd->DisconnectChannel = FFD_DisconnectChannel;\n\tffd->GetServiceDescriptor = FFD_GetServiceDesc;\n\tffd->ServiceCommand = FFD_ServiceCommand;\n\n\tffd->CanHandleURLInService = FFD_CanHandleURLInService;\n\n\tpriv->thread = gf_th_new(\"FFMPEG Demux\");\n\tpriv->mx = gf_mx_new(\"FFMPEG Demux\");\n\tif (!priv->thread || !priv->mx) {\n\t\tif (priv->thread) gf_th_del(priv->thread);\n\t\tif (priv->mx) gf_mx_del(priv->mx);\n\t\tgf_free(priv);\n\t\treturn NULL;\n\t}\n\n\tGF_REGISTER_MODULE_INTERFACE(ffd, GF_NET_CLIENT_INTERFACE, \"FFMPEG Demuxer\", \"gpac distribution\");\n\tffd->priv = priv;\n\treturn ffd;\n}\n\nvoid Delete_FFMPEG_Demux(void *ifce)\n{\n\tFFDemux *ffd;\n\tGF_InputService *ptr = (GF_InputService *)ifce;\n\tif (!ptr)\n\t\treturn;\n\tffd = (FFDemux*)ptr->priv;\n\tif (ffd) {\n\t\tif (ffd->thread)\n\t\t\tgf_th_del(ffd->thread);\n\t\tffd->thread = NULL;\n\t\tif (ffd->mx)\n\t\t\tgf_mx_del(ffd->mx);\n\n#ifndef USE_PRE_0_7\n\t\tif (ffd->options) av_dict_free(&ffd->options);\n#endif\n\t\tffd->mx = NULL;\n\t\tgf_free(ffd);\n\t\tptr->priv = NULL;\n\t}\n\tgf_free(ptr);\n}\n\n\n#endif\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/scene_manager.h>\n#include <gpac/constants.h>\n#include <gpac/media_tools.h>\n#include <gpac/bifs.h>\n#include <gpac/xml.h>\n#include <gpac/internal/scenegraph_dev.h>\n#include <gpac/network.h>\n\n\nGF_EXPORT\nGF_SceneManager *gf_sm_new(GF_SceneGraph *graph)\n{\n\tGF_SceneManager *tmp;\n\n\tif (!graph) return NULL;\n\tGF_SAFEALLOC(tmp, GF_SceneManager);\n\tif (!tmp) return NULL;\n\ttmp->streams = gf_list_new();\n\ttmp->scene_graph = graph;\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_StreamContext *gf_sm_stream_new(GF_SceneManager *ctx, u16 ES_ID, u8 streamType, u8 objectType)\n{\n\tu32 i;\n\tGF_StreamContext *tmp;\n\n\ti=0;\n\twhile ((tmp = (GF_StreamContext*)gf_list_enum(ctx->streams, &i))) {\n\t\t/*we MUST use the same ST*/\n\t\tif (tmp->streamType!=streamType) continue;\n\t\t/*if no ESID/OTI specified this is a base layer (default stream created by parsers)\n\t\tif ESID/OTI specified this is a stream already setup\n\t\t*/\n\t\tif ( tmp->ESID==ES_ID ) {\n\t\t\t//tmp->objectType = objectType;\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\tGF_SAFEALLOC(tmp, GF_StreamContext);\n\tif (!tmp) return NULL;\n\ttmp->AUs = gf_list_new();\n\ttmp->ESID = ES_ID;\n\ttmp->streamType = streamType;\n\ttmp->objectType = objectType ? objectType : 1;\n\ttmp->timeScale = 1000;\n\tgf_list_add(ctx->streams, tmp);\n\treturn tmp;\n}\n\nGF_StreamContext *gf_sm_stream_find(GF_SceneManager *ctx, u16 ES_ID)\n{\n\tu32 i, count;\n\tif (!ES_ID) return NULL;\n\tcount = gf_list_count(ctx->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_StreamContext *tmp = (GF_StreamContext *)gf_list_get(ctx->streams, i);\n\t\tif (tmp->ESID==ES_ID) return tmp;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_MuxInfo *gf_sm_get_mux_info(GF_ESD *src)\n{\n\tu32 i;\n\tGF_MuxInfo *mux;\n\ti=0;\n\twhile ((mux = (GF_MuxInfo *)gf_list_enum(src->extensionDescriptors, &i))) {\n\t\tif (mux->tag == GF_ODF_MUXINFO_TAG) return mux;\n\t}\n\treturn NULL;\n}\n\n\nstatic void gf_sm_au_del(GF_StreamContext *sc, GF_AUContext *au)\n{\n\twhile (gf_list_count(au->commands)) {\n\t\tvoid *comptr = gf_list_last(au->commands);\n\t\tgf_list_rem_last(au->commands);\n\t\tswitch (sc->streamType) {\n\t\tcase GF_STREAM_OD:\n\t\t\tgf_odf_com_del((GF_ODCom**) & comptr);\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\t\tgf_sg_command_del((GF_Command *)comptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_list_del(au->commands);\n\tgf_free(au);\n}\n\nstatic void gf_sm_reset_stream(GF_StreamContext *sc)\n{\n\twhile (gf_list_count(sc->AUs)) {\n\t\tGF_AUContext *au = (GF_AUContext *)gf_list_last(sc->AUs);\n\t\tgf_list_rem_last(sc->AUs);\n\t\tgf_sm_au_del(sc, au);\n\n\t}\n}\n\nstatic void gf_sm_delete_stream(GF_StreamContext *sc)\n{\n\tgf_sm_reset_stream(sc);\n\tgf_list_del(sc->AUs);\n\tif (sc->name) gf_free(sc->name);\n\tif (sc->dec_cfg) gf_free(sc->dec_cfg);\n\tgf_free(sc);\n}\n\nGF_EXPORT\nvoid gf_sm_stream_del(GF_SceneManager *ctx, GF_StreamContext *sc)\n{\n\tif (gf_list_del_item(ctx->streams, sc)>=0) {\n\t\tgf_sm_delete_stream(sc);\n\t}\n}\n\nGF_EXPORT\nvoid gf_sm_del(GF_SceneManager *ctx)\n{\n\tu32 count;\n\twhile ( (count = gf_list_count(ctx->streams)) ) {\n\t\tGF_StreamContext *sc = (GF_StreamContext *)gf_list_get(ctx->streams, count-1);\n\t\tgf_list_rem(ctx->streams, count-1);\n\t\tgf_sm_delete_stream(sc);\n\t}\n\tgf_list_del(ctx->streams);\n\tif (ctx->root_od) gf_odf_desc_del((GF_Descriptor *) ctx->root_od);\n\tgf_free(ctx);\n}\n\nGF_EXPORT\nvoid gf_sm_reset(GF_SceneManager *ctx)\n{\n\tGF_StreamContext *sc;\n\tu32 i=0;\n\twhile ( (sc = gf_list_enum(ctx->streams, &i)) ) {\n\t\tgf_sm_reset_stream(sc);\n\t}\n\tif (ctx->root_od) gf_odf_desc_del((GF_Descriptor *) ctx->root_od);\n\tctx->root_od = NULL;\n}\n\nGF_EXPORT\nGF_AUContext *gf_sm_stream_au_new(GF_StreamContext *stream, u64 timing, Double time_sec, Bool isRap)\n{\n\tu32 i;\n\tGF_AUContext *tmp;\n\tu64 tmp_timing;\n\n\ttmp_timing = timing ? timing : (u64) (time_sec*1000);\n\tif (stream->imp_exp_time >= tmp_timing) {\n\t\t/*look for existing AU*/\n\t\ti=0;\n\t\twhile ((tmp = (GF_AUContext *)gf_list_enum(stream->AUs, &i))) {\n\t\t\tif (timing && (tmp->timing==timing)) return tmp;\n\t\t\telse if (time_sec && (tmp->timing_sec == time_sec)) return tmp;\n\t\t\telse if (!time_sec && !timing && !tmp->timing && !tmp->timing_sec) return tmp;\n\t\t\t/*insert AU*/\n\t\t\telse if ((time_sec && time_sec<tmp->timing_sec) || (timing && timing<tmp->timing)) {\n\t\t\t\tGF_SAFEALLOC(tmp, GF_AUContext);\n\t\t\t\tif (!tmp) return NULL;\n\t\t\t\ttmp->commands = gf_list_new();\n\t\t\t\tif (isRap) tmp->flags = GF_SM_AU_RAP;\n\t\t\t\ttmp->timing = timing;\n\t\t\t\ttmp->timing_sec = time_sec;\n\t\t\t\ttmp->owner = stream;\n\t\t\t\tgf_list_insert(stream->AUs, tmp, i-1);\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t}\n\tGF_SAFEALLOC(tmp, GF_AUContext);\n\tif (!tmp) return NULL;\n\ttmp->commands = gf_list_new();\n\tif (isRap) tmp->flags = GF_SM_AU_RAP;\n\ttmp->timing = timing;\n\ttmp->timing_sec = time_sec;\n\ttmp->owner = stream;\n\tif (stream->disable_aggregation) tmp->flags |= GF_SM_AU_NOT_AGGREGATED;\n\tgf_list_add(stream->AUs, tmp);\n\tstream->imp_exp_time = tmp_timing;\n\treturn tmp;\n}\n\nstatic Bool node_in_commands_subtree(GF_Node *node, GF_List *commands)\n{\n#ifndef GPAC_DISABLE_VRML\n\tu32 i, j, count, nb_fields;\n\n\tcount = gf_list_count(commands);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Command *com = gf_list_get(commands, i);\n\t\tif (com->tag>=GF_SG_LAST_BIFS_COMMAND) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] Command check for LASeR/DIMS not supported\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tif (com->tag==GF_SG_SCENE_REPLACE) {\n\t\t\tif (gf_node_parent_of(com->node, node)) return 1;\n\t\t\tcontinue;\n\t\t}\n\t\tnb_fields = gf_list_count(com->command_fields);\n\t\tfor (j=0; j<nb_fields; j++) {\n\t\t\tGF_CommandField *field = gf_list_get(com->command_fields, j);\n\t\t\tswitch (field->fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tif (field->new_node) {\n\t\t\t\t\tif (gf_node_parent_of(field->new_node, node)) return 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t\tif (field->field_ptr) {\n\t\t\t\t\tGF_ChildNodeItem *child;\n\t\t\t\t\tchild = field->node_list;\n\t\t\t\t\twhile (child) {\n\t\t\t\t\t\tif (gf_node_parent_of(child->node, node)) return 1;\n\t\t\t\t\t\tchild = child->next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic u32 store_or_aggregate(GF_StreamContext *sc, GF_Command *com, GF_List *commands, Bool *has_modif)\n{\n#ifndef GPAC_DISABLE_VRML\n\tu32 i, count, j, nb_fields;\n\tGF_CommandField *field, *check_field;\n\n\t/*if our command deals with a node inserted in the commands list, apply command list*/\n\tif (node_in_commands_subtree(com->node, commands)) return 0;\n\n\t/*otherwise, check if we can substitute a previous command with this one*/\n\tcount = gf_list_count(commands);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Command *check = gf_list_get(commands, i);\n\n\t\tif (sc->streamType == GF_STREAM_SCENE) {\n\t\t\tBool check_index=0;\n\t\t\tBool original_is_index = 0;\n\t\t\tBool apply;\n\t\t\tswitch (com->tag) {\n\t\t\tcase GF_SG_INDEXED_REPLACE:\n\t\t\t\tcheck_index=1;\n\t\t\tcase GF_SG_MULTIPLE_INDEXED_REPLACE:\n\t\t\tcase GF_SG_FIELD_REPLACE:\n\t\t\tcase GF_SG_MULTIPLE_REPLACE:\n\t\t\t\tif (check->node != com->node) break;\n\t\t\t\t/*we may aggregate an indexed insertion and a replace one*/\n\t\t\t\tif (check_index) {\n\t\t\t\t\tif (check->tag == GF_SG_INDEXED_REPLACE) {}\n\t\t\t\t\telse if (check->tag == GF_SG_INDEXED_INSERT) {\n\t\t\t\t\t\toriginal_is_index = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (check->tag != com->tag) break;\n\t\t\t\t}\n\t\t\t\tnb_fields = gf_list_count(com->command_fields);\n\t\t\t\tif (gf_list_count(check->command_fields) != nb_fields) break;\n\t\t\t\tapply=1;\n\t\t\t\tfor (j=0; j<nb_fields; j++) {\n\t\t\t\t\tfield = gf_list_get(com->command_fields, j);\n\t\t\t\t\tcheck_field = gf_list_get(check->command_fields, j);\n\t\t\t\t\tif ((field->pos != check_field->pos) || (field->fieldIndex != check_field->fieldIndex)) {\n\t\t\t\t\t\tapply=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*same target node+fields, destroy first command and store new one*/\n\t\t\t\tif (apply) {\n\t\t\t\t\t/*if indexed, change command tag*/\n\t\t\t\t\tif (original_is_index) com->tag = GF_SG_INDEXED_INSERT;\n\n\t\t\t\t\tgf_sg_command_del((GF_Command *)check);\n\t\t\t\t\tgf_list_rem(commands, i);\n\t\t\t\t\tif (has_modif) *has_modif = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GF_SG_NODE_REPLACE:\n\t\t\t\tif (check->tag != GF_SG_NODE_REPLACE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*TODO - THIS IS NOT SUPPORTED IN GPAC SINCE WE NEVER ALLOW FOR DUPLICATE NODE IDs IN THE SCENE !!!*/\n\t\t\t\tif (gf_node_get_id(check->node) != gf_node_get_id(com->node) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*same node ID, destroy first command and store new one*/\n\t\t\t\tgf_sg_command_del((GF_Command *)check);\n\t\t\t\tgf_list_rem(commands, i);\n\t\t\t\tif (has_modif) *has_modif = 1;\n\t\t\t\treturn 1;\n\n\t\t\tcase GF_SG_INDEXED_DELETE:\n\t\t\t\t/*look for an indexed insert before the indexed delete with same target pos and node. If found, discard both commands!*/\n\t\t\t\tif (check->tag != GF_SG_INDEXED_INSERT) break;\n\t\t\t\tif (com->node != check->node) break;\n\t\t\t\tfield = gf_list_get(com->command_fields, 0);\n\t\t\t\tcheck_field = gf_list_get(check->command_fields, 0);\n\t\t\t\tif (!field || !check_field) break;\n\t\t\t\tif (field->pos != check_field->pos) break;\n\t\t\t\tif (field->fieldIndex != check_field->fieldIndex) break;\n\n\t\t\t\tgf_sg_command_del((GF_Command *)check);\n\t\t\t\tgf_list_rem(commands, i);\n\t\t\t\tif (has_modif) *has_modif = 1;\n\t\t\t\treturn 2;\n\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] Stream Aggregation not implemented for command - aggregating on main scene\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*the command modifies another stream than associated current carousel stream, we have to store it.*/\n\tif (has_modif) *has_modif=1;\n#endif\n\treturn 1;\n}\n\nstatic GF_StreamContext *gf_sm_get_stream(GF_SceneManager *ctx, u16 ESID)\n{\n\tu32 i, count;\n\tcount = gf_list_count(ctx->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_StreamContext *sc = gf_list_get(ctx->streams, i);\n\t\tif (sc->ESID==ESID) return sc;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Err gf_sm_aggregate(GF_SceneManager *ctx, u16 ESID)\n{\n\tGF_Err e;\n\tu32 i, stream_count;\n#ifndef GPAC_DISABLE_VRML\n\tu32 j;\n\tGF_AUContext *au;\n\tGF_Command *com;\n#endif\n\n\te = GF_OK;\n\n#if DEBUG_RAP\n\tcom_count = 0;\n\tstream_count = gf_list_count(ctx->streams);\n\tfor (i=0; i<stream_count; i++) {\n\t\tGF_StreamContext *sc = (GF_StreamContext *)gf_list_get(ctx->streams, i);\n\t\tif (sc->streamType == GF_STREAM_SCENE) {\n\t\t\tau_count = gf_list_count(sc->AUs);\n\t\t\tfor (j=0; j<au_count; j++) {\n\t\t\t\tau = (GF_AUContext *)gf_list_get(sc->AUs, j);\n\t\t\t\tcom_count += gf_list_count(au->commands);\n\t\t\t}\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_INFO, GF_LOG_SCENE, (\"[SceneManager] Making RAP with %d commands\\n\", com_count));\n#endif\n\n\tstream_count = gf_list_count(ctx->streams);\n\tfor (i=0; i<stream_count; i++) {\n\t\tGF_AUContext *carousel_au;\n\t\tGF_List *carousel_commands;\n\t\tGF_StreamContext *aggregate_on_stream;\n\t\tGF_StreamContext *sc = (GF_StreamContext *)gf_list_get(ctx->streams, i);\n\t\tif (ESID && (sc->ESID!=ESID)) continue;\n\n\t\t/*locate the AU in which our commands will be aggregated*/\n\t\tcarousel_au = NULL;\n\t\tcarousel_commands = NULL;\n\t\taggregate_on_stream = sc->aggregate_on_esid ? gf_sm_get_stream(ctx, sc->aggregate_on_esid) : NULL;\n\t\tif (aggregate_on_stream==sc) {\n\t\t\tcarousel_commands = gf_list_new();\n\t\t} else if (aggregate_on_stream) {\n\t\t\tif (!gf_list_count(aggregate_on_stream->AUs)) {\n\t\t\t\tcarousel_au = gf_sm_stream_au_new(aggregate_on_stream, 0, 0, 1);\n\t\t\t} else {\n\t\t\t\t/* assert we already performed aggregation */\n\t\t\t\tassert(gf_list_count(aggregate_on_stream->AUs)==1);\n\t\t\t\tcarousel_au = gf_list_get(aggregate_on_stream->AUs, 0);\n\t\t\t}\n\t\t\tcarousel_commands = carousel_au->commands;\n\t\t}\n\t\t/*TODO - do this as well for ODs*/\n#ifndef GPAC_DISABLE_VRML\n\t\tif (sc->streamType == GF_STREAM_SCENE) {\n\t\t\tBool has_modif = 0;\n\t\t\t/*we check for each stream if it is a base stream (SceneReplace ...) - several streams may carry RAPs if inline nodes are used*/\n\t\t\tBool base_stream_found = 0;\n\n\t\t\t/*in DIMS we use an empty initial AU with no commands to signal the RAP*/\n\t\t\tif (sc->objectType == GPAC_OTI_SCENE_DIMS) base_stream_found = 1;\n\n\t\t\t/*apply all commands - this will also apply the SceneReplace*/\n\t\t\twhile (gf_list_count(sc->AUs)) {\n\t\t\t\tu32 count;\n\t\t\t\tau = (GF_AUContext *) gf_list_get(sc->AUs, 0);\n\t\t\t\tgf_list_rem(sc->AUs, 0);\n\n\t\t\t\t/*AU not aggregated*/\n\t\t\t\tif (au->flags & GF_SM_AU_NOT_AGGREGATED) {\n\t\t\t\t\tgf_sm_au_del(sc, au);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcount = gf_list_count(au->commands);\n\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\tu32 store=0;\n\t\t\t\t\tcom = gf_list_get(au->commands, j);\n\t\t\t\t\tif (!base_stream_found) {\n\t\t\t\t\t\tswitch (com->tag) {\n\t\t\t\t\t\tcase GF_SG_SCENE_REPLACE:\n\t\t\t\t\t\tcase GF_SG_LSR_NEW_SCENE:\n\t\t\t\t\t\tcase GF_SG_LSR_REFRESH_SCENE:\n\t\t\t\t\t\t\tbase_stream_found = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*aggregate the command*/\n\n\t\t\t\t\t/*if stream doesn't carry a carousel or carries the base carousel (scene replace), always apply the command*/\n\t\t\t\t\tif (base_stream_found || !sc->aggregate_on_esid) {\n\t\t\t\t\t\tstore = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/*otherwise, check wether the command should be kept in this stream as is, or can be aggregated on this stream*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tswitch (com->tag) {\n\t\t\t\t\t\t/*the following commands do not impact a sub-tree (eg do not deal with nodes), we cannot\n\t\t\t\t\t\taggregate them... */\n\t\t\t\t\t\tcase GF_SG_ROUTE_REPLACE:\n\t\t\t\t\t\tcase GF_SG_ROUTE_DELETE:\n\t\t\t\t\t\tcase GF_SG_ROUTE_INSERT:\n\t\t\t\t\t\tcase GF_SG_PROTO_INSERT:\n\t\t\t\t\t\tcase GF_SG_PROTO_DELETE:\n\t\t\t\t\t\tcase GF_SG_PROTO_DELETE_ALL:\n\t\t\t\t\t\tcase GF_SG_GLOBAL_QUANTIZER:\n\t\t\t\t\t\tcase GF_SG_LSR_RESTORE:\n\t\t\t\t\t\tcase GF_SG_LSR_SAVE:\n\t\t\t\t\t\tcase GF_SG_LSR_SEND_EVENT:\n\t\t\t\t\t\tcase GF_SG_LSR_CLEAN:\n\t\t\t\t\t\t\t/*todo check in which category to put these commands*/\n//\t\t\t\t\t\tcase GF_SG_LSR_ACTIVATE:\n//\t\t\t\t\t\tcase GF_SG_LSR_DEACTIVATE:\n\t\t\t\t\t\t\tstore = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/*other commands:\n\t\t\t\t\t\t\t!!! we need to know if the target node of the command has been inserted in this stream !!!\n\n\t\t\t\t\t\tThis is a tedious task, for now we will consider the following cases:\n\t\t\t\t\t\t\t- locate a similar command in the stored list: remove the similar one and aggregate on stream\n\t\t\t\t\t\t\t- by default all AUs are stored if the stream is in aggregate mode - we should fix that by checking insertion points:\n\t\t\t\t\t\t\t if a command apllies on a node that has been inserted in this stream, we can aggregate, otherwise store\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/*check if we can directly store the command*/\n\t\t\t\t\t\t\tassert(carousel_commands);\n\t\t\t\t\t\t\tstore = store_or_aggregate(sc, com, carousel_commands, &has_modif);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (store) {\n\t\t\t\t\t/*command has been merged with a previous command in carousel and needs to be destroyed*/\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tgf_list_rem(au->commands, j);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tgf_sg_command_del((GF_Command *)com);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/*command shall be moved to carousel without being applied*/\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tgf_list_insert(carousel_commands, com, 0);\n\t\t\t\t\t\tgf_list_rem(au->commands, j);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/*command can be applied*/\n\t\t\t\t\tdefault:\n\t\t\t\t\t\te = gf_sg_command_apply(ctx->scene_graph, com, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_sm_au_del(sc, au);\n\t\t\t}\n\n\t\t\t/*and recreate scene replace*/\n\t\t\tif (base_stream_found) {\n\t\t\t\tau = gf_sm_stream_au_new(sc, 0, 0, 1);\n\n\t\t\t\tswitch (sc->objectType) {\n\t\t\t\tcase GPAC_OTI_SCENE_BIFS:\n\t\t\t\tcase GPAC_OTI_SCENE_BIFS_V2:\n\t\t\t\t\tcom = gf_sg_command_new(ctx->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GPAC_OTI_SCENE_LASER:\n\t\t\t\t\tcom = gf_sg_command_new(ctx->scene_graph, GF_SG_LSR_NEW_SCENE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GPAC_OTI_SCENE_DIMS:\n\t\t\t\t/* We do not create a new command, empty AU is enough in DIMS*/\n\t\t\t\tdefault:\n\t\t\t\t\tcom = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (com) {\n\t\t\t\t\tcom->node = ctx->scene_graph->RootNode;\n\t\t\t\t\tctx->scene_graph->RootNode = NULL;\n\t\t\t\t\tgf_list_del(com->new_proto_list);\n\t\t\t\t\tcom->new_proto_list = ctx->scene_graph->protos;\n\t\t\t\t\tctx->scene_graph->protos = NULL;\n\t\t\t\t\t/*indicate the command is the aggregated scene graph, so that PROTOs and ROUTEs\n\t\t\t\t\tare taken from the scenegraph when encoding*/\n\t\t\t\t\tcom->aggregated = 1;\n\t\t\t\t\tgf_list_add(au->commands, com);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*update carousel flags of the AU*/\n\t\t\telse if (carousel_commands) {\n\t\t\t\t/*if current stream caries its own carousel*/\n\t\t\t\tif (!carousel_au) {\n\t\t\t\t\tcarousel_au = gf_sm_stream_au_new(sc, 0, 0, 1);\n\t\t\t\t\tgf_list_del(carousel_au->commands);\n\t\t\t\t\tcarousel_au->commands = carousel_commands;\n\t\t\t\t}\n\t\t\t\tcarousel_au->flags |= GF_SM_AU_RAP | GF_SM_AU_CAROUSEL;\n\t\t\t\tif (has_modif) carousel_au->flags |= GF_SM_AU_MODIFIED;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_LOADER_BT\nGF_Err gf_sm_load_init_bt(GF_SceneLoader *load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_XMT\nGF_Err gf_sm_load_init_xmt(GF_SceneLoader *load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_ISOM\nGF_Err gf_sm_load_init_isom(GF_SceneLoader *load);\n#endif\n\n#ifndef GPAC_DISABLE_SVG\n\nGF_Err gf_sm_load_init_svg(GF_SceneLoader *load);\n\nGF_Err gf_sm_load_init_xbl(GF_SceneLoader *load);\nGF_Err gf_sm_load_run_xbl(GF_SceneLoader *load);\nvoid gf_sm_load_done_xbl(GF_SceneLoader *load);\n#endif\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\nGF_Err gf_sm_load_init_swf(GF_SceneLoader *load);\n#endif\n\n\n#ifndef GPAC_DISABLE_QTVR\n\nGF_Err gf_sm_load_init_qt(GF_SceneLoader *load);\n#endif\n\n\n\nGF_EXPORT\nGF_Err gf_sm_load_string(GF_SceneLoader *load, const char *str, Bool do_clean)\n{\n\tGF_Err e;\n\tif (!load->type) e = GF_BAD_PARAM;\n\telse if (load->parse_string) e = load->parse_string(load, str);\n\telse e = GF_NOT_SUPPORTED;\n\n\treturn e;\n}\n\n\n/*initializes the context loader*/\nGF_EXPORT\nGF_Err gf_sm_load_init(GF_SceneLoader *load)\n{\n\tGF_Err e = GF_NOT_SUPPORTED;\n\tchar *ext, szExt[50];\n\t/*we need at least a scene graph*/\n\tif (!load || (!load->ctx && !load->scene_graph)\n#ifndef GPAC_DISABLE_ISOM\n\t        || (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )\n#endif\n\t   ) return GF_BAD_PARAM;\n\n\tif (!load->type) {\n#ifndef GPAC_DISABLE_ISOM\n\t\tif (load->isom) {\n\t\t\tload->type = GF_SM_LOAD_MP4;\n\t\t} else\n#endif\n\t\t{\n\t\t\text = (char *)strrchr(load->fileName, '.');\n\t\t\tif (!ext) return GF_NOT_SUPPORTED;\n\t\t\tif (!stricmp(ext, \".gz\")) {\n\t\t\t\tchar *anext;\n\t\t\t\text[0] = 0;\n\t\t\t\tanext = (char *)strrchr(load->fileName, '.');\n\t\t\t\text[0] = '.';\n\t\t\t\text = anext;\n\t\t\t}\n\t\t\tstrcpy(szExt, &ext[1]);\n\t\t\tstrlwr(szExt);\n\t\t\tif (strstr(szExt, \"bt\")) load->type = GF_SM_LOAD_BT;\n\t\t\telse if (strstr(szExt, \"wrl\")) load->type = GF_SM_LOAD_VRML;\n\t\t\telse if (strstr(szExt, \"x3dv\")) load->type = GF_SM_LOAD_X3DV;\n#ifndef GPAC_DISABLE_LOADER_XMT\n\t\t\telse if (strstr(szExt, \"xmt\") || strstr(szExt, \"xmta\")) load->type = GF_SM_LOAD_XMTA;\n\t\t\telse if (strstr(szExt, \"x3d\")) load->type = GF_SM_LOAD_X3D;\n#endif\n\t\t\telse if (strstr(szExt, \"swf\")) load->type = GF_SM_LOAD_SWF;\n\t\t\telse if (strstr(szExt, \"mov\")) load->type = GF_SM_LOAD_QT;\n\t\t\telse if (strstr(szExt, \"svg\")) load->type = GF_SM_LOAD_SVG;\n\t\t\telse if (strstr(szExt, \"xsr\")) load->type = GF_SM_LOAD_XSR;\n\t\t\telse if (strstr(szExt, \"xbl\")) load->type = GF_SM_LOAD_XBL;\n\t\t\telse if (strstr(szExt, \"xml\")) {\n\t\t\t\tchar *rtype = gf_xml_get_root_type(load->fileName, &e);\n\t\t\t\tif (rtype) {\n\t\t\t\t\tif (!strcmp(rtype, \"SAFSession\")) load->type = GF_SM_LOAD_XSR;\n\t\t\t\t\telse if (!strcmp(rtype, \"XMT-A\")) load->type = GF_SM_LOAD_XMTA;\n\t\t\t\t\telse if (!strcmp(rtype, \"X3D\")) load->type = GF_SM_LOAD_X3D;\n\t\t\t\t\telse if (!strcmp(rtype, \"bindings\")) load->type = GF_SM_LOAD_XBL;\n\n\t\t\t\t\tgf_free(rtype);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!load->type) return e;\n\n\tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;\n\n\tswitch (load->type) {\n#ifndef GPAC_DISABLE_LOADER_BT\n\tcase GF_SM_LOAD_BT:\n\tcase GF_SM_LOAD_VRML:\n\tcase GF_SM_LOAD_X3DV:\n\t\treturn gf_sm_load_init_bt(load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_XMT\n\tcase GF_SM_LOAD_XMTA:\n\tcase GF_SM_LOAD_X3D:\n\t\treturn gf_sm_load_init_xmt(load);\n#endif\n\n#ifndef GPAC_DISABLE_SVG\n\tcase GF_SM_LOAD_SVG:\n\tcase GF_SM_LOAD_XSR:\n\tcase GF_SM_LOAD_DIMS:\n\t\treturn gf_sm_load_init_svg(load);\n\n\tcase GF_SM_LOAD_XBL:\n\t\te = gf_sm_load_init_xbl(load);\n\n\t\tload->process = gf_sm_load_run_xbl;\n\t\tload->done = gf_sm_load_done_xbl;\n\t\treturn e;\n#endif\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tcase GF_SM_LOAD_SWF:\n\t\treturn gf_sm_load_init_swf(load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_ISOM\n\tcase GF_SM_LOAD_MP4:\n\t\treturn gf_sm_load_init_isom(load);\n#endif\n\n#ifndef GPAC_DISABLE_QTVR\n\tcase GF_SM_LOAD_QT:\n\t\treturn gf_sm_load_init_qt(load);\n#endif\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\treturn GF_NOT_SUPPORTED;\n}\n\nGF_EXPORT\nvoid gf_sm_load_done(GF_SceneLoader *load)\n{\n\tif (load->done) load->done(load);\n}\n\nGF_EXPORT\nGF_Err gf_sm_load_run(GF_SceneLoader *load)\n{\n\tif (load->process) return load->process(load);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_sm_load_suspend(GF_SceneLoader *load, Bool suspend)\n{\n\tif (load->suspend) return load->suspend(load, suspend);\n\treturn GF_OK;\n}\n\n#if !defined(GPAC_DISABLE_LOADER_BT) || !defined(GPAC_DISABLE_LOADER_XMT)\n#include <gpac/base_coding.h>\nvoid gf_sm_update_bitwrapper_buffer(GF_Node *node, const char *fileName)\n{\n\tu32 data_size = 0;\n\tchar *data = NULL;\n\tchar *buffer;\n\tM_BitWrapper *bw = (M_BitWrapper *)node;\n\n\tif (!bw->buffer.buffer) return;\n\tbuffer = bw->buffer.buffer;\n\tif (!strnicmp(buffer, \"file://\", 7)) {\n\t\tchar *url = gf_url_concatenate(fileName, buffer+7);\n\t\tif (url) {\n\t\t\tFILE *f = gf_fopen(url, \"rb\");\n\t\t\tif (f) {\n\t\t\t\tfseek(f, 0, SEEK_END);\n\t\t\t\tdata_size = (u32) ftell(f);\n\t\t\t\tfseek(f, 0, SEEK_SET);\n\t\t\t\tdata = gf_malloc(sizeof(char)*data_size);\n\t\t\t\tif (data) {\n\t\t\t\t\tif (fread(data, 1, data_size, f) != data_size) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] error reading bitwrapper file %s\\n\", url));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fclose(f);\n\t\t\t}\n\t\t\tgf_free(url);\n\t\t}\n\t} else {\n\t\tBool base_64 = 0;\n\t\tif (!strnicmp(buffer, \"data:application/octet-string\", 29)) {\n\t\t\tchar *sep = strchr(bw->buffer.buffer, ',');\n\t\t\tbase_64 = strstr(bw->buffer.buffer, \";base64\") ? 1 : 0;\n\t\t\tif (sep) buffer = sep+1;\n\t\t}\n\n\t\tif (base_64) {\n\t\t\tdata_size = 2 * (u32) strlen(buffer);\n\t\t\tdata = (char*)gf_malloc(sizeof(char)*data_size);\n\t\t\tif (data)\n\t\t\t\tdata_size = gf_base64_decode(buffer, (u32) strlen(buffer), data, data_size);\n\t\t} else {\n\t\t\tu32 i, c;\n\t\t\tchar s[3];\n\t\t\tdata_size = (u32) strlen(buffer) / 3;\n\t\t\tdata = (char*)gf_malloc(sizeof(char) * data_size);\n\t\t\tif (data) {\n\t\t\t\ts[2] = 0;\n\t\t\t\tfor (i=0; i<data_size; i++) {\n\t\t\t\t\ts[0] = buffer[3*i+1];\n\t\t\t\t\ts[1] = buffer[3*i+2];\n\t\t\t\t\tsscanf(s, \"%02X\", &c);\n\t\t\t\t\tdata[i] = (unsigned char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgf_free(bw->buffer.buffer);\n\tbw->buffer.buffer = NULL;\n\tbw->buffer_len = 0;\n\tif (data) {\n\t\tbw->buffer.buffer = data;\n\t\tbw->buffer_len = data_size;\n\t}\n\n}\n#endif //!defined(GPAC_DISABLE_LOADER_BT) || !defined(GPAC_DISABLE_LOADER_XMT)\n\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / mp4box application\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/tools.h>\n#include <gpac/media_tools.h>\n#include <gpac/constants.h>\n#include <gpac/scene_manager.h>\n#include <gpac/network.h>\n#include <gpac/base_coding.h>\n\n#if !defined(GPAC_DISABLE_VRML) && !defined(GPAC_DISABLE_X3D) && !defined(GPAC_DISABLE_SVG)\n#include <gpac/scenegraph.h>\n#endif\n\n\n#ifndef GPAC_DISABLE_BIFS\n#include <gpac/bifs.h>\n#endif\n#ifndef GPAC_DISABLE_VRML\n#include <gpac/nodes_mpeg4.h>\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#include <gpac/xml.h>\n#include <gpac/internal/isomedia_dev.h>\n\ntypedef struct\n{\n\tconst char *root_file;\n\tconst char *dir;\n\tGF_List *imports;\n} WGTEnum;\n\nGF_Err set_file_udta(GF_ISOFile *dest, u32 tracknum, u32 udta_type, char *src, Bool is_box_array)\n{\n\tchar *data = NULL;\n\tGF_Err res = GF_OK;\n\tu32 size;\n\tbin128 uuid;\n\tmemset(uuid, 0 , 16);\n\n\tif (!udta_type && !is_box_array) return GF_BAD_PARAM;\n\n\tif (!src) {\n\t\treturn gf_isom_remove_user_data(dest, tracknum, udta_type, uuid);\n\t}\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\tif (!strnicmp(src, \"base64\", 6)) {\n\t\tsrc += 7;\n\t\tsize = (u32) strlen(src);\n\t\tdata = gf_malloc(sizeof(char) * size);\n\t\tsize = gf_base64_decode(src, size, data, size);\n\t} else\n#endif\n\t{\n\t\tFILE *t = gf_fopen(src, \"rb\");\n\t\tif (!t) return GF_IO_ERR;\n\t\tfseek(t, 0, SEEK_END);\n\t\tsize = ftell(t);\n\t\tfseek(t, 0, SEEK_SET);\n\t\tdata = gf_malloc(sizeof(char)*size);\n\t\tif (size != fread(data, 1, size, t) ) {\n\t\t\tgf_free(data);\n\t\t\tgf_fclose(t);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tgf_fclose(t);\n\t}\n\n\tif (size && data) {\n\t\tif (is_box_array) {\n\t\t\tres = gf_isom_add_user_data_boxes(dest, tracknum, data, size);\n\t\t} else {\n\t\t\tres = gf_isom_add_user_data(dest, tracknum, udta_type, uuid, data, size);\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn res;\n}\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\nextern u32 swf_flags;\nextern Float swf_flatten_angle;\nextern Bool keep_sys_tracks;\n\nvoid scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist);\n\nvoid convert_file_info(char *inName, u32 trackID)\n{\n\tGF_Err e;\n\tu32 i;\n\tBool found;\n\tGF_MediaImporter import;\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\timport.trackID = trackID;\n\timport.in_name = inName;\n\timport.flags = GF_IMPORT_PROBE_ONLY;\n\te = gf_media_import(&import);\n\tif (e) {\n\t\tfprintf(stderr, \"Error probing file %s: %s\\n\", inName, gf_error_to_string(e));\n\t\treturn;\n\t}\n\tif (trackID) {\n\t\tfprintf(stderr, \"Import probing results for track %s#%d:\\n\", inName, trackID);\n\t} else {\n\t\tfprintf(stderr, \"Import probing results for %s:\\n\", inName);\n\t\tif (!import.nb_tracks) {\n\t\t\tfprintf(stderr, \"File has no selectable tracks\\n\");\n\t\t\treturn;\n\t\t}\n\t\tfprintf(stderr, \"File has %d tracks\\n\", import.nb_tracks);\n\t}\n\tif (import.probe_duration) {\n\t\tfprintf(stderr, \"Duration: %g s\\n\", (Double) (import.probe_duration/1000.0));\n\t}\n\tfound = 0;\n\tfor (i=0; i<import.nb_tracks; i++) {\n\t\tif (trackID && (trackID != import.tk_info[i].track_num)) continue;\n\t\tif (!trackID) fprintf(stderr, \"\\tTrack %d type: \", import.tk_info[i].track_num);\n\t\telse fprintf(stderr, \"Track type: \");\n\n\t\tswitch (import.tk_info[i].type) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tfprintf(stderr, \"Video (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tif (import.tk_info[i].video_info.temporal_enhancement) fprintf(stderr, \" Temporal Enhancement\");\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            fprintf(stderr, \"Auxiliary Video (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            fprintf(stderr, \"Picture Sequence (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n            break;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tfprintf(stderr, \"Audio (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\tfprintf(stderr, \"Text (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tfprintf(stderr, \"Scene (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tfprintf(stderr, \"OD (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_META:\n\t\t\tfprintf(stderr, \"Metadata (%s)\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Other (4CC: %s)\", gf_4cc_to_str(import.tk_info[i].type));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (import.tk_info[i].lang) fprintf(stderr, \" - lang %s\", gf_4cc_to_str(import.tk_info[i].lang));\n\n\t\tif (import.tk_info[i].mpeg4_es_id) fprintf(stderr, \" - MPEG-4 ESID %d\", import.tk_info[i].mpeg4_es_id);\n\n\t\tif (import.tk_info[i].prog_num) {\n\t\t\tif (!import.nb_progs) {\n\t\t\t\tfprintf(stderr, \" - Program %d\", import.tk_info[i].prog_num);\n\t\t\t} else {\n\t\t\t\tu32 j;\n\t\t\t\tfor (j=0; j<import.nb_progs; j++) {\n\t\t\t\t\tif (import.tk_info[i].prog_num != import.pg_info[j].number) continue;\n\t\t\t\t\tfprintf(stderr, \" - Program %s\", import.pg_info[j].name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t\tif (!trackID) continue;\n\n\n\t\tif (gf_isom_is_video_subtype(import.tk_info[i].type) && import.tk_info[i].video_info.width && import.tk_info[i].video_info.height\n\t\t   ) {\n\t\t\tfprintf(stderr, \"Source: %s %dx%d\", gf_4cc_to_str(import.tk_info[i].media_type), import.tk_info[i].video_info.width, import.tk_info[i].video_info.height);\n\t\t\tif (import.tk_info[i].video_info.FPS) fprintf(stderr, \" @ %g FPS\", import.tk_info[i].video_info.FPS);\n\t\t\tif (import.tk_info[i].video_info.par) fprintf(stderr, \" PAR: %d:%d\", import.tk_info[i].video_info.par >> 16, import.tk_info[i].video_info.par & 0xFFFF);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\telse if ((import.tk_info[i].type==GF_ISOM_MEDIA_AUDIO) && import.tk_info[i].audio_info.sample_rate) {\n\t\t\tfprintf(stderr, \"Source: %s - SampleRate %d - %d channels\\n\", gf_4cc_to_str(import.tk_info[i].media_type), import.tk_info[i].audio_info.sample_rate, import.tk_info[i].audio_info.nb_channels);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Source: %s\\n\", gf_4cc_to_str(import.tk_info[i].media_type));\n\t\t}\n\n\n\t\tfprintf(stderr, \"\\nImport Capabilities:\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_USE_DATAREF) fprintf(stderr, \"\\tCan use data referencing\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_NO_FRAME_DROP) fprintf(stderr, \"\\tCan use fixed FPS import\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_FORCE_PACKED) fprintf(stderr, \"\\tCan force packed bitstream import\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_OVERRIDE_FPS) fprintf(stderr, \"\\tCan override source frame rate\\n\");\n\t\tif (import.tk_info[i].flags & (GF_IMPORT_SBR_IMPLICIT|GF_IMPORT_SBR_EXPLICIT)) fprintf(stderr, \"\\tCan use AAC-SBR signaling\\n\");\n\t\tif (import.tk_info[i].flags & (GF_IMPORT_PS_IMPLICIT|GF_IMPORT_PS_EXPLICIT)) fprintf(stderr, \"\\tCan use AAC-PS signaling\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_FORCE_MPEG4) fprintf(stderr, \"\\tCan force MPEG-4 Systems signaling\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_3GPP_AGGREGATION) fprintf(stderr, \"\\tCan use 3GPP frame aggregation\\n\");\n\t\tif (import.tk_info[i].flags & GF_IMPORT_NO_DURATION) fprintf(stderr, \"\\tCannot use duration-based import\\n\");\n\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"\\n\");\n\tif (!found && trackID) fprintf(stderr, \"Cannot find track %d in file\\n\", trackID);\n}\n\nstatic void set_chapter_track(GF_ISOFile *file, u32 track, u32 chapter_ref_trak)\n{\n\tu64 ref_duration, chap_duration;\n\tDouble scale;\n\n\tgf_isom_set_track_reference(file, chapter_ref_trak, GF_ISOM_REF_CHAP, gf_isom_get_track_id(file, track) );\n\tgf_isom_set_track_enabled(file, track, 0);\n\n\tref_duration = gf_isom_get_media_duration(file, chapter_ref_trak);\n\tchap_duration = gf_isom_get_media_duration(file, track);\n\tscale = (Double) (s64) gf_isom_get_media_timescale(file, track);\n\tscale /= gf_isom_get_media_timescale(file, chapter_ref_trak);\n\tref_duration = (u64) (ref_duration * scale);\n\n\tif (chap_duration < ref_duration) {\n\t\tchap_duration -= gf_isom_get_sample_duration(file, track, gf_isom_get_sample_count(file, track));\n\t\tchap_duration = ref_duration - chap_duration;\n\t\tgf_isom_set_last_sample_duration(file, track, (u32) chap_duration);\n\t}\n}\n\nGF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, Double force_fps, u32 frames_per_sample)\n{\n\tu32 track_id, i, j, timescale, track, stype, profile, level, new_timescale, rescale, svc_mode, txt_flags, split_tile_mode, temporal_mode;\n\ts32 par_d, par_n, prog_id, delay, force_rate;\n\ts32 tw, th, tx, ty, txtw, txth, txtx, txty;\n\tBool do_audio, do_video, do_auxv,do_pict, do_all, disable, track_layout, text_layout, chap_ref, is_chap, is_chap_file, keep_handler, negative_cts_offset, rap_only, refs_only;\n\tu32 group, handler, rvc_predefined, check_track_for_svc, check_track_for_lhvc, check_track_for_hevc;\n\tconst char *szLan;\n\tGF_Err e;\n\tGF_MediaImporter import;\n\tchar *ext, szName[1000], *handler_name, *rvc_config, *chapter_name;\n\tGF_List *kinds;\n\tGF_TextFlagsMode txt_mode = GF_ISOM_TEXT_FLAGS_OVERWRITE;\n\tu8 max_layer_id_plus_one, max_temporal_id_plus_one;\n\n\trvc_predefined = 0;\n\tchapter_name = NULL;\n\tnew_timescale = 1;\n\trescale = 0;\n\ttext_layout = 0;\n\t/*0: merge all\n\t  1: split base and all SVC in two tracks\n\t  2: split all base and SVC layers in dedicated tracks\n\t */\n\tsvc_mode = 0;\n\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\n\tstrcpy(szName, inName);\n#ifdef WIN32\n\t/*dirty hack for msys&mingw: when we use import options, the ':' separator used prevents msys from translating the path\n\twe do this for regular cases where the path starts with the drive letter. If the path start with anything else (/home , /opt, ...) we're screwed :( */\n\tif ( (szName[0]=='/') && (szName[2]=='/')) {\n\t\tszName[0] = szName[1];\n\t\tszName[1] = ':';\n\t}\n#endif\n\n\tis_chap_file = 0;\n\thandler = 0;\n\tdisable = 0;\n\tchap_ref = 0;\n\tis_chap = 0;\n\tkinds = gf_list_new();\n\ttrack_layout = 0;\n\tszLan = NULL;\n\tdelay = 0;\n\tgroup = 0;\n\tstype = 0;\n\tprofile = level = 0;\n\tnegative_cts_offset = 0;\n\tsplit_tile_mode = 0;\n\ttemporal_mode = 0;\n\trap_only = 0;\n\trefs_only = 0;\n\ttxt_flags = 0;\n\tmax_layer_id_plus_one = max_temporal_id_plus_one = 0;\n\tforce_rate = -1;\n\n\ttw = th = tx = ty = txtw = txth = txtx = txty = 0;\n\tpar_d = par_n = -2;\n\t/*use ':' as separator, but beware DOS paths...*/\n\text = strchr(szName, ':');\n\tif (ext && ext[1]=='\\\\') ext = strchr(szName+2, ':');\n\n\thandler_name = NULL;\n\trvc_config = NULL;\n\twhile (ext) {\n\t\tchar *ext2 = strchr(ext+1, ':');\n\n\t\t// if the colon is part of a file path/url we keep it\n\t\tif (ext2 && !strncmp(ext2, \"://\", 3) ) {\n\t\t\text2[0] = ':';\n\t\t\text2 = strchr(ext2+1, ':');\n\t\t}\n\n\t\t// keep windows drive: path, can be after a file://\n\t\tif (ext2 && ( !strncmp(ext2, \":\\\\\", 2) || !strncmp(ext2, \":/\", 2) ) ) {\n\t\t\text2[0] = ':';\n\t\t\text2 = strchr(ext2+1, ':');\n\t\t}\n\n\t\tif (ext2) ext2[0] = 0;\n\n\t\t/*all extensions for track-based importing*/\n\t\tif (!strnicmp(ext+1, \"dur=\", 4)) import.duration = (u32)( (atof(ext+5) * 1000) + 0.5 );\n\t\telse if (!strnicmp(ext+1, \"lang=\", 5)) {\n\t\t\t/* prevent leak if param is set twice */\n\t\t\tif (szLan)\n\t\t\t\tgf_free((char*) szLan);\n\n\t\t\tszLan = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"delay=\", 6)) delay = atoi(ext+7);\n\t\telse if (!strnicmp(ext+1, \"par=\", 4)) {\n\t\t\tif (!stricmp(ext+5, \"none\")) {\n\t\t\t\tpar_n = par_d = -1;\n\t\t\t} else {\n\t\t\t\tif (ext2) ext2[0] = ':';\n\t\t\t\tif (ext2) ext2 = strchr(ext2+1, ':');\n\t\t\t\tif (ext2) ext2[0] = 0;\n\t\t\t\tsscanf(ext+5, \"%d:%d\", &par_n, &par_d);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"name=\", 5)) {\n\t\t\thandler_name = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"ext=\", 4)) {\n\t\t\t/*extensions begin with '.'*/\n\t\t\tif (*(ext+5) == '.')\n\t\t\t\timport.force_ext = gf_strdup(ext+5);\n\t\t\telse {\n\t\t\t\timport.force_ext = gf_calloc(1+strlen(ext+5)+1, 1);\n\t\t\t\timport.force_ext[0] = '.';\n\t\t\t\tstrcat(import.force_ext+1, ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"hdlr=\", 5)) handler = GF_4CC(ext[6], ext[7], ext[8], ext[9]);\n\t\telse if (!strnicmp(ext+1, \"disable\", 7)) disable = 1;\n\t\telse if (!strnicmp(ext+1, \"group=\", 6)) {\n\t\t\tgroup = atoi(ext+7);\n\t\t\tif (!group) group = gf_isom_get_next_alternate_group_id(dest);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fps=\", 4)) {\n\t\t\tif (!strcmp(ext+5, \"auto\")) force_fps = GF_IMPORT_AUTO_FPS;\n\t\t\telse if (strchr(ext+5, '-')) {\n\t\t\t\tu32 ticks, dts_inc;\n\t\t\t\tsscanf(ext+5, \"%u-%u\", &ticks, &dts_inc);\n\t\t\t\tif (!dts_inc) dts_inc=1;\n\t\t\t\tforce_fps = ticks;\n\t\t\t\tforce_fps /= dts_inc;\n\t\t\t}\n\t\t\telse force_fps = atof(ext+5);\n\t\t}\n\t\telse if (!stricmp(ext+1, \"rap\")) rap_only = 1;\n\t\telse if (!stricmp(ext+1, \"refs\")) refs_only = 1;\n\t\telse if (!stricmp(ext+1, \"trailing\")) import_flags |= GF_IMPORT_KEEP_TRAILING;\n\t\telse if (!strnicmp(ext+1, \"agg=\", 4)) frames_per_sample = atoi(ext+5);\n\t\telse if (!stricmp(ext+1, \"dref\")) import_flags |= GF_IMPORT_USE_DATAREF;\n\t\telse if (!stricmp(ext+1, \"keep_refs\")) import_flags |= GF_IMPORT_KEEP_REFS;\n\t\telse if (!stricmp(ext+1, \"nodrop\")) import_flags |= GF_IMPORT_NO_FRAME_DROP;\n\t\telse if (!stricmp(ext+1, \"packed\")) import_flags |= GF_IMPORT_FORCE_PACKED;\n\t\telse if (!stricmp(ext+1, \"sbr\")) import_flags |= GF_IMPORT_SBR_IMPLICIT;\n\t\telse if (!stricmp(ext+1, \"sbrx\")) import_flags |= GF_IMPORT_SBR_EXPLICIT;\n\t\telse if (!stricmp(ext+1, \"ovsbr\")) import_flags |= GF_IMPORT_OVSBR;\n\t\telse if (!stricmp(ext+1, \"ps\")) import_flags |= GF_IMPORT_PS_IMPLICIT;\n\t\telse if (!stricmp(ext+1, \"psx\")) import_flags |= GF_IMPORT_PS_EXPLICIT;\n\t\telse if (!stricmp(ext+1, \"mpeg4\")) import_flags |= GF_IMPORT_FORCE_MPEG4;\n\t\telse if (!stricmp(ext+1, \"nosei\")) import_flags |= GF_IMPORT_NO_SEI;\n\t\telse if (!stricmp(ext+1, \"svc\") || !stricmp(ext+1, \"lhvc\") ) import_flags |= GF_IMPORT_SVC_EXPLICIT;\n\t\telse if (!stricmp(ext+1, \"nosvc\") || !stricmp(ext+1, \"nolhvc\")) import_flags |= GF_IMPORT_SVC_NONE;\n\n\t\t/*split SVC layers*/\n\t\telse if (!strnicmp(ext+1, \"svcmode=\", 8) || !strnicmp(ext+1, \"lhvcmode=\", 9)) {\n\t\t\tchar *mode = ext+9;\n\t\t\tif (mode[0]=='=') mode = ext+10;\n\n\t\t\tif (!stricmp(mode, \"splitnox\"))\n\t\t\t\tsvc_mode = 3;\n\t\t\telse if (!stricmp(mode, \"splitnoxib\"))\n\t\t\t\tsvc_mode = 4;\n\t\t\telse if (!stricmp(mode, \"splitall\") || !stricmp(mode, \"split\"))\n\t\t\t\tsvc_mode = 2;\n\t\t\telse if (!stricmp(mode, \"splitbase\"))\n\t\t\t\tsvc_mode = 1;\n\t\t\telse if (!stricmp(mode, \"merged\"))\n\t\t\t\tsvc_mode = 0;\n\t\t}\n\t\t/*split SVC layers*/\n\t\telse if (!strnicmp(ext+1, \"temporal=\", 9)) {\n\t\t\tchar *mode = ext+10;\n\t\t\tif (!stricmp(mode, \"split\"))\n\t\t\t\ttemporal_mode = 2;\n\t\t\telse if (!stricmp(mode, \"splitnox\"))\n\t\t\t\ttemporal_mode = 3;\n\t\t\telse if (!stricmp(mode, \"splitbase\"))\n\t\t\t\ttemporal_mode = 1;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Unrecognized temporal mode %s, ignoring\\n\", mode);\n\t\t\t\ttemporal_mode = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"subsamples\")) import_flags |= GF_IMPORT_SET_SUBSAMPLES;\n\t\telse if (!stricmp(ext+1, \"deps\")) import_flags |= GF_IMPORT_SAMPLE_DEPS;\n\t\telse if (!stricmp(ext+1, \"forcesync\")) import_flags |= GF_IMPORT_FORCE_SYNC;\n\t\telse if (!stricmp(ext+1, \"xps_inband\")) import_flags |= GF_IMPORT_FORCE_XPS_INBAND;\n\t\telse if (!strnicmp(ext+1, \"max_lid=\", 8) || !strnicmp(ext+1, \"max_tid=\", 8)) {\n\t\t\ts32 val = atoi(ext+9);\n\t\t\tif (val < 0) {\n\t\t\t\tfprintf(stderr, \"Warning: request max layer/temporal id is negative - ignoring\\n\");\n\t\t\t} else {\n\t\t\t\tif (!strnicmp(ext+1, \"max_lid=\", 8))\n\t\t\t\t\tmax_layer_id_plus_one = 1 + (u8) val;\n\t\t\t\telse\n\t\t\t\t\tmax_temporal_id_plus_one = 1 + (u8) val;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"tiles\")) split_tile_mode = 2;\n\t\telse if (!stricmp(ext+1, \"tiles_rle\")) split_tile_mode = 3;\n\t\telse if (!stricmp(ext+1, \"split_tiles\")) split_tile_mode = 1;\n\n\t\t/*force all composition offsets to be positive*/\n\t\telse if (!strnicmp(ext+1, \"negctts\", 7)) negative_cts_offset = 1;\n\t\telse if (!strnicmp(ext+1, \"stype=\", 6)) {\n\t\t\tstype = GF_4CC(ext[7], ext[8], ext[9], ext[10]);\n\t\t}\n\t\telse if (!stricmp(ext+1, \"chap\")) is_chap = 1;\n\t\telse if (!strnicmp(ext+1, \"chapter=\", 8)) {\n\t\t\tchapter_name = gf_strdup(ext+9);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"chapfile=\", 9)) {\n\t\t\tchapter_name = gf_strdup(ext+10);\n\t\t\tis_chap_file=1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"layout=\", 7)) {\n\t\t\tif ( sscanf(ext+8, \"%dx%dx%dx%d\", &tw, &th, &tx, &ty)==4) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t} else if ( sscanf(ext+8, \"%dx%d\", &tw, &th)==2) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t\ttx = ty = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"rescale=\", 8)) {\n\t\t\trescale = atoi(ext+9);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"timescale=\", 10)) {\n\t\t\tnew_timescale = atoi(ext+11);\n\t\t}\n\t\telse if (!stricmp(ext+1, \"noedit\")) import_flags |= GF_IMPORT_NO_EDIT_LIST;\n\n\n\t\telse if (!strnicmp(ext+1, \"rvc=\", 4)) {\n\t\t\tif (sscanf(ext+5, \"%d\", &rvc_predefined) != 1) {\n\t\t\t\trvc_config = gf_strdup(ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fmt=\", 4)) import.streamFormat = gf_strdup(ext+5);\n\t\telse if (!strnicmp(ext+1, \"profile=\", 8)) profile = atoi(ext+9);\n\t\telse if (!strnicmp(ext+1, \"level=\", 6)) level = atoi(ext+7);\n\t\telse if (!strnicmp(ext+1, \"novpsext\", 8)) import_flags |= GF_IMPORT_NO_VPS_EXTENSIONS;\n\t\telse if (!strnicmp(ext+1, \"keepav1t\", 8)) import_flags |= GF_IMPORT_KEEP_AV1_TEMPORAL_OBU;\n\n\t\telse if (!strnicmp(ext+1, \"font=\", 5)) import.fontName = gf_strdup(ext+6);\n\t\telse if (!strnicmp(ext+1, \"size=\", 5)) import.fontSize = atoi(ext+6);\n\t\telse if (!strnicmp(ext+1, \"text_layout=\", 12)) {\n\t\t\tif ( sscanf(ext+13, \"%dx%dx%dx%d\", &txtw, &txth, &txtx, &txty)==4) {\n\t\t\t\ttext_layout = 1;\n\t\t\t} else if ( sscanf(ext+8, \"%dx%d\", &txtw, &txth)==2) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t\ttxtx = txty = 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\telse if (!stricmp(ext+1, \"swf-global\")) import.swf_flags |= GF_SM_SWF_STATIC_DICT;\n\t\telse if (!stricmp(ext+1, \"swf-no-ctrl\")) import.swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE;\n\t\telse if (!stricmp(ext+1, \"swf-no-text\")) import.swf_flags |= GF_SM_SWF_NO_TEXT;\n\t\telse if (!stricmp(ext+1, \"swf-no-font\")) import.swf_flags |= GF_SM_SWF_NO_FONT;\n\t\telse if (!stricmp(ext+1, \"swf-no-line\")) import.swf_flags |= GF_SM_SWF_NO_LINE;\n\t\telse if (!stricmp(ext+1, \"swf-no-grad\")) import.swf_flags |= GF_SM_SWF_NO_GRADIENT;\n\t\telse if (!stricmp(ext+1, \"swf-quad\")) import.swf_flags |= GF_SM_SWF_QUAD_CURVE;\n\t\telse if (!stricmp(ext+1, \"swf-xlp\")) import.swf_flags |= GF_SM_SWF_SCALABLE_LINE;\n\t\telse if (!stricmp(ext+1, \"swf-ic2d\")) import.swf_flags |= GF_SM_SWF_USE_IC2D;\n\t\telse if (!stricmp(ext+1, \"swf-same-app\")) import.swf_flags |= GF_SM_SWF_REUSE_APPEARANCE;\n\t\telse if (!strnicmp(ext+1, \"swf-flatten=\", 12)) import.swf_flatten_angle = (Float) atof(ext+13);\n#endif\n\n\t\telse if (!strnicmp(ext+1, \"kind=\", 5)) {\n\t\t\tchar *kind_scheme, *kind_value;\n\t\t\tchar *kind_data = ext+6;\n\t\t\tchar *sep = strchr(kind_data, '=');\n\t\t\tif (sep) {\n\t\t\t\t*sep = 0;\n\t\t\t}\n\t\t\tkind_scheme = gf_strdup(kind_data);\n\t\t\tif (sep) {\n\t\t\t\t*sep = '=';\n\t\t\t\tkind_value = gf_strdup(sep+1);\n\t\t\t} else {\n\t\t\t\tkind_value = NULL;\n\t\t\t}\n\t\t\tgf_list_add(kinds, kind_scheme);\n\t\t\tgf_list_add(kinds, kind_value);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"txtflags\", 8)) {\n\t\t\tif (!strnicmp(ext+1, \"txtflags=\", 9)) {\n\t\t\t\tsscanf(ext+10, \"%x\", &txt_flags);\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, \"txtflags+=\", 10)) {\n\t\t\t\tsscanf(ext+11, \"%x\", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_TOGGLE;\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, \"txtflags-=\", 10)) {\n\t\t\t\tsscanf(ext+11, \"%x\", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_UNTOGGLE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"rate=\", 5)) {\n\t\t\tforce_rate = atoi(ext+6);\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"asemode=\", 8)){\n\t\t\tchar *mode = ext+9;\n\t\t\tif (!stricmp(mode, \"v0-bs\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS;\n\t\t\telse if (!stricmp(mode, \"v0-2\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2;\n\t\t\telse if (!stricmp(mode, \"v1\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG;\n\t\t\telse if (!stricmp(mode, \"v1-qt\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"audio_roll=\", 11)) {\n\t\t\timport.audio_roll_change = GF_TRUE;\n\t\t\timport.audio_roll = atoi(ext+12);\n\t\t}\n\n\t\t/*unrecognized, assume name has colon in it*/\n\t\telse {\n\t\t\tfprintf(stderr, \"Unrecognized import option %s, ignoring\\n\", ext+1);\n\t\t\text = ext2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ext2) ext2[0] = ':';\n\n\t\text[0] = 0;\n\n\t\t/* restart from where we stopped\n\t\t * if we didn't stop (ext2 null) then the end has been reached\n\t\t * so we can stop the whole thing */\n\t\text = ext2;\n\t}\n\n\t/*check duration import (old syntax)*/\n\text = strrchr(szName, '%');\n\tif (ext) {\n\t\timport.duration = (u32) (atof(ext+1) * 1000);\n\t\text[0] = 0;\n\t}\n\n\t/*select switches for av containers import*/\n\tdo_audio = do_video = do_auxv = do_pict = 0;\n\ttrack_id = prog_id = 0;\n\tdo_all = 1;\n\text = strrchr(szName, '#');\n\tif (ext) ext[0] = 0;\n\n\tkeep_handler = gf_isom_probe_file(szName);\n\n\timport.in_name = szName;\n\timport.flags = GF_IMPORT_PROBE_ONLY;\n\te = gf_media_import(&import);\n\tif (e) goto exit;\n\n\tif (ext) {\n\t\text++;\n\t\tif (!strnicmp(ext, \"audio\", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, \"video\", 5)) do_video = 1;\n        else if (!strnicmp(ext, \"auxv\", 4)) do_auxv = 1;\n        else if (!strnicmp(ext, \"pict\", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, \"trackID=\", 8)) track_id = atoi(&ext[8]);\n\t\telse if (!strnicmp(ext, \"PID=\", 4)) track_id = atoi(&ext[4]);\n\t\telse if (!strnicmp(ext, \"program=\", 8)) {\n\t\t\tfor (i=0; i<import.nb_progs; i++) {\n\t\t\t\tif (!stricmp(import.pg_info[i].name, ext+8)) {\n\t\t\t\t\tprog_id = import.pg_info[i].number;\n\t\t\t\t\tdo_all = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext, \"prog_id=\", 8)) {\n\t\t\tprog_id = atoi(ext+8);\n\t\t\tdo_all = 0;\n\t\t}\n\t\telse track_id = atoi(ext);\n\t}\n\tif (do_audio || do_video || do_auxv || do_pict || track_id) do_all = 0;\n\n\tif (track_layout || is_chap) {\n\t\tu32 w, h, sw, sh, fw, fh, i;\n\t\tw = h = sw = sh = fw = fh = 0;\n\t\tchap_ref = 0;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n            case GF_ISOM_MEDIA_AUXV:\n            case GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\n\t\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &sw, &sh);\n\t\t\t\tgf_isom_get_track_layout_info(dest, i+1, &fw, &fh, NULL, NULL, NULL);\n\t\t\t\tif (w<sw) w = sw;\n\t\t\t\tif (w<fw) w = fw;\n\t\t\t\tif (h<sh) h = sh;\n\t\t\t\tif (h<fh) h = fh;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (track_layout) {\n\t\t\tif (!tw) tw = w;\n\t\t\tif (!th) th = h;\n\t\t\tif (ty==-1) ty = (h>(u32)th) ? h-th : 0;\n\t\t\timport.text_width = tw;\n\t\t\timport.text_height = th;\n\t\t}\n\t\tif (is_chap && chap_ref) import_flags |= GF_IMPORT_NO_TEXT_FLUSH;\n\t}\n\tif (text_layout && txtw && txth) {\n\t\timport.text_track_width = import.text_width ? import.text_width : txtw;\n\t\timport.text_track_height = import.text_height ? import.text_height : txth;\n\t\timport.text_width = txtw;\n\t\timport.text_height = txth;\n\t\timport.text_x = txtx;\n\t\timport.text_y = txty;\n\t}\n\n\tcheck_track_for_svc = check_track_for_lhvc = check_track_for_hevc = 0;\n\n\timport.dest = dest;\n\timport.video_fps = force_fps;\n\timport.frames_per_sample = frames_per_sample;\n\timport.flags = import_flags;\n\n\tif (!import.nb_tracks) {\n\t\tu32 count, o_count;\n\t\to_count = gf_isom_get_track_count(import.dest);\n\t\te = gf_media_import(&import);\n\t\tif (e) return e;\n\t\tcount = gf_isom_get_track_count(import.dest);\n\t\ttimescale = gf_isom_get_timescale(dest);\n\t\tfor (i=o_count; i<count; i++) {\n\t\t\tif (szLan) gf_isom_set_media_language(import.dest, i+1, (char *) szLan);\n\t\t\tif (delay) {\n\t\t\t\tu64 tk_dur;\n\t\t\t\tgf_isom_remove_edit_segments(import.dest, i+1);\n\t\t\t\ttk_dur = gf_isom_get_track_duration(import.dest, i+1);\n\t\t\t\tif (delay>0) {\n\t\t\t\t\tgf_isom_append_edit_segment(import.dest, i+1, (timescale*delay)/1000, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\tgf_isom_append_edit_segment(import.dest, i+1, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t} else if (delay<0) {\n\t\t\t\t\tu64 to_skip = (timescale*(-delay))/1000;\n\t\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t\t//u64 seg_dur = (-delay)*gf_isom_get_media_timescale(import.dest, i+1) / 1000;\n\t\t\t\t\t\tgf_isom_append_edit_segment(import.dest, i+1, tk_dur-to_skip, to_skip, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Warning: request negative delay longer than track duration - ignoring\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((par_n>=0) && (par_d>=0)) {\n\t\t\t\te = gf_media_change_par(import.dest, i+1, par_n, par_d);\n\t\t\t}\n\n\t\t\tif (rap_only || refs_only) {\n\t\t\t\te = gf_media_remove_non_rap(import.dest, i+1, refs_only);\n\t\t\t}\n\n\t\t\tif (handler_name) gf_isom_set_handler_name(import.dest, i+1, handler_name);\n\t\t\telse if (!keep_handler) {\n\t\t\t\tchar szHName[1024];\n\t\t\t\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\n\t\t\t\tfName = strchr(fName, '.');\n\t\t\t\tif (fName) fName += 1;\n\t\t\t\telse fName = \"?\";\n\n\t\t\t\tsprintf(szHName, \"*%s@GPAC%s\", fName, GPAC_FULL_VERSION);\n\t\t\t\tgf_isom_set_handler_name(import.dest, i+1, szHName);\n\t\t\t}\n\t\t\tif (handler) gf_isom_set_media_type(import.dest, i+1, handler);\n\t\t\tif (disable) gf_isom_set_track_enabled(import.dest, i+1, 0);\n\n\t\t\tif (group) {\n\t\t\t\tgf_isom_set_alternate_group_id(import.dest, i+1, group);\n\t\t\t}\n\t\t\tif (track_layout) {\n\t\t\t\tgf_isom_set_track_layout_info(import.dest, i+1, tw<<16, th<<16, tx<<16, ty<<16, 0);\n\t\t\t}\n\t\t\tif (stype)\n\t\t\t\tgf_isom_set_media_subtype(import.dest, i+1, 1, stype);\n\n\t\t\tif (is_chap && chap_ref) {\n\t\t\t\tset_chapter_track(import.dest, i+1, chap_ref);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\n\t\t\t\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\n\t\t\t\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\n\t\t\t\tgf_isom_add_track_kind(import.dest, i+1, kind_scheme, kind_value);\n\t\t\t}\n\n\t\t\tif (profile || level)\n\t\t\t\tgf_media_change_pl(import.dest, i+1, profile, level);\n\n\t\t\tif (gf_isom_get_media_subtype(import.dest, i+1, 1)== GF_ISOM_BOX_TYPE_MP4S)\n\t\t\t\tkeep_sys_tracks = 1;\n\n\t\t\tgf_isom_set_composition_offset_mode(import.dest, i+1, negative_cts_offset);\n\n\t\t\tif (gf_isom_get_avc_svc_type(import.dest, i+1, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\n\t\t\t\tcheck_track_for_svc = i+1;\n\n\t\t\tswitch (gf_isom_get_hevc_lhvc_type(import.dest, i+1, 1)) {\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\t\tcheck_track_for_lhvc = i+1;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\t\tcheck_track_for_hevc=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (txt_flags) {\n\t\t\t\tgf_isom_text_set_display_flags(import.dest, i+1, 0, txt_flags, txt_mode);\n\t\t\t}\n\n\t\t\tif (force_rate>=0) {\n\t\t\t\tgf_isom_update_bitrate(import.dest, i+1, 1, force_rate, force_rate, 0);\n\t\t\t}\n\n\t\t\tif (split_tile_mode) {\n\t\t\t\tswitch (gf_isom_get_media_subtype(import.dest, i+1, 1)) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsplit_tile_mode = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (do_all)\n\t\t\timport.flags |= GF_IMPORT_KEEP_REFS;\n\n\t\tfor (i=0; i<import.nb_tracks; i++) {\n\t\t\timport.trackID = import.tk_info[i].track_num;\n\t\t\tif (prog_id) {\n\t\t\t\tif (import.tk_info[i].prog_num!=prog_id) continue;\n\t\t\t\te = gf_media_import(&import);\n\t\t\t}\n\t\t\telse if (do_all) e = gf_media_import(&import);\n\t\t\telse if (track_id && (track_id==import.trackID)) {\n\t\t\t\ttrack_id = 0;\n\t\t\t\te = gf_media_import(&import);\n\t\t\t}\n\t\t\telse if (do_audio && (import.tk_info[i].type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\tdo_audio = 0;\n\t\t\t\te = gf_media_import(&import);\n\t\t\t}\n\t\t\telse if (do_video && (import.tk_info[i].type==GF_ISOM_MEDIA_VISUAL)) {\n\t\t\t\tdo_video = 0;\n\t\t\t\te = gf_media_import(&import);\n\t\t\t}\n            else if (do_auxv && (import.tk_info[i].type==GF_ISOM_MEDIA_AUXV)) {\n                do_auxv = 0;\n                e = gf_media_import(&import);\n            }\n            else if (do_pict && (import.tk_info[i].type==GF_ISOM_MEDIA_PICT)) {\n                do_pict = 0;\n                e = gf_media_import(&import);\n            }\n\t\t\telse continue;\n\t\t\tif (e) goto exit;\n\n\t\t\ttimescale = gf_isom_get_timescale(dest);\n\t\t\ttrack = gf_isom_get_track_by_id(import.dest, import.final_trackID);\n\t\t\tif (szLan) gf_isom_set_media_language(import.dest, track, (char *) szLan);\n\t\t\tif (disable) gf_isom_set_track_enabled(import.dest, track, 0);\n\n\t\t\tif (delay) {\n\t\t\t\tu64 tk_dur;\n\t\t\t\tgf_isom_remove_edit_segments(import.dest, track);\n\t\t\t\ttk_dur = gf_isom_get_track_duration(import.dest, track);\n\t\t\t\tif (delay>0) {\n\t\t\t\t\tgf_isom_append_edit_segment(import.dest, track, (timescale*delay)/1000, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\tgf_isom_append_edit_segment(import.dest, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t} else {\n\t\t\t\t\tu64 to_skip = (timescale*(-delay))/1000;\n\t\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t\tu64 media_time = (-delay)*gf_isom_get_media_timescale(import.dest, track) / 1000;\n\t\t\t\t\t\tgf_isom_append_edit_segment(import.dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Warning: request negative delay longer than track duration - ignoring\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gf_isom_is_video_subtype(import.tk_info[i].type) && (par_n>=-1) && (par_d>=-1)) {\n\t\t\t\te = gf_media_change_par(import.dest, track, par_n, par_d);\n\t\t\t}\n\t\t\tif (rap_only || refs_only) {\n\t\t\t\te = gf_media_remove_non_rap(import.dest, track, refs_only);\n\t\t\t}\n\t\t\tif (handler_name) gf_isom_set_handler_name(import.dest, track, handler_name);\n\t\t\telse if (!keep_handler) {\n\t\t\t\tchar szHName[1024];\n\t\t\t\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\n\t\t\t\tfName = strchr(fName, '.');\n\t\t\t\tif (fName) fName += 1;\n\t\t\t\telse fName = \"?\";\n\n\t\t\t\tsprintf(szHName, \"%s@GPAC%s\", fName, GPAC_FULL_VERSION);\n\t\t\t\tgf_isom_set_handler_name(import.dest, track, szHName);\n\t\t\t}\n\t\t\tif (handler) gf_isom_set_media_type(import.dest, track, handler);\n\n\t\t\tif (group) {\n\t\t\t\tgf_isom_set_alternate_group_id(import.dest, track, group);\n\t\t\t}\n\n\t\t\tif (track_layout) {\n\t\t\t\tgf_isom_set_track_layout_info(import.dest, track, tw<<16, th<<16, tx<<16, ty<<16, 0);\n\t\t\t}\n\t\t\tif (stype)\n\t\t\t\tgf_isom_set_media_subtype(import.dest, track, 1, stype);\n\n\t\t\tif (is_chap && chap_ref) {\n\t\t\t\tset_chapter_track(import.dest, track, chap_ref);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\n\t\t\t\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\n\t\t\t\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\n\t\t\t\tgf_isom_add_track_kind(import.dest, i+1, kind_scheme, kind_value);\n\t\t\t}\n\n\t\t\tif (profile || level)\n\t\t\t\tgf_media_change_pl(import.dest, track, profile, level);\n\n\t\t\tif (gf_isom_get_mpeg4_subtype(import.dest, track, 1))\n\t\t\t\tkeep_sys_tracks = 1;\n\n\t\t\tif (new_timescale>1) {\n\t\t\t\tgf_isom_set_media_timescale(import.dest, track, new_timescale, 0);\n\t\t\t}\n\n\t\t\tif (rescale>1) {\n\t\t\t\tswitch (gf_isom_get_media_type(import.dest, track)) {\n\t\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\t\tfprintf(stderr, \"Cannot force media timescale for audio media types - ignoring\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgf_isom_set_media_timescale(import.dest, track, rescale, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rvc_config) {\n\t\t\t\tFILE *f = gf_fopen(rvc_config, \"rb\");\n\t\t\t\tif (f) {\n\t\t\t\t\tchar *data;\n\t\t\t\t\tu32 size;\n\t\t\t\t\tsize_t read;\n\t\t\t\t\tgf_fseek(f, 0, SEEK_END);\n\t\t\t\t\tsize = (u32) gf_ftell(f);\n\t\t\t\t\tgf_fseek(f, 0, SEEK_SET);\n\t\t\t\t\tdata = gf_malloc(sizeof(char)*size);\n\t\t\t\t\tread = fread(data, 1, size, f);\n\t\t\t\t\tgf_fclose(f);\n\t\t\t\t\tif (read != size) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: could not read rvc config from %s\\n\", rvc_config);\n\t\t\t\t\t\te = GF_IO_ERR;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n#ifdef GPAC_DISABLE_ZLIB\n\t\t\t\t\tfprintf(stderr, \"Error: no zlib support - RVC not available\\n\");\n\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\tgoto exit;\n#else\n\t\t\t\t\tgf_gz_compress_payload(&data, size, &size);\n#endif\n\t\t\t\t\tgf_isom_set_rvc_config(import.dest, track, 1, 0, \"application/rvc-config+xml+gz\", data, size);\n\t\t\t\t\tgf_free(data);\n\t\t\t\t}\n\t\t\t} else if (rvc_predefined>0) {\n\t\t\t\tgf_isom_set_rvc_config(import.dest, track, 1, rvc_predefined, NULL, NULL, 0);\n\t\t\t}\n\n\t\t\tgf_isom_set_composition_offset_mode(import.dest, track, negative_cts_offset);\n\n\t\t\tif (gf_isom_get_avc_svc_type(import.dest, track, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\n\t\t\t\tcheck_track_for_svc = track;\n\n\t\t\tswitch (gf_isom_get_hevc_lhvc_type(import.dest, track, 1)) {\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\t\tcheck_track_for_lhvc = i+1;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\t\tcheck_track_for_hevc=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (txt_flags) {\n\t\t\t\tgf_isom_text_set_display_flags(import.dest, track, 0, txt_flags, txt_mode);\n\t\t\t}\n\t\t\tif (force_rate>=0) {\n\t\t\t\tgf_isom_update_bitrate(import.dest, i+1, 1, force_rate, force_rate, 0);\n\t\t\t}\n\n\t\t\tif (split_tile_mode) {\n\t\t\t\tswitch (gf_isom_get_media_subtype(import.dest, track, 1)) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsplit_tile_mode = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (track_id) fprintf(stderr, \"WARNING: Track ID %d not found in file\\n\", track_id);\n\t\telse if (do_video) fprintf(stderr, \"WARNING: Video track not found\\n\");\n        else if (do_auxv) fprintf(stderr, \"WARNING: Auxiliary Video track not found\\n\");\n        else if (do_pict) fprintf(stderr, \"WARNING: Picture sequence track not found\\n\");\n\t\telse if (do_audio) fprintf(stderr, \"WARNING: Audio track not found\\n\");\n\t}\n\n\tif (chapter_name) {\n\t\tif (is_chap_file) {\n\t\t\te = gf_media_import_chapters(import.dest, chapter_name, 0);\n\t\t} else {\n\t\t\te = gf_isom_add_chapter(import.dest, 0, 0, chapter_name);\n\t\t}\n\t}\n\n\t/*force to rewrite all dependencies*/\n\tfor (i = 1; i <= gf_isom_get_track_count(import.dest); i++)\n\t{\n\t\te = gf_isom_rewrite_track_dependencies(import.dest, i);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Warning: track ID %d has references to a track not imported\\n\", gf_isom_get_track_id(import.dest, i) ));\n\t\t\te = GF_OK;\n\t\t}\n\t}\n\n\tif (max_layer_id_plus_one || max_temporal_id_plus_one) {\n\t\tfor (i = 1; i <= gf_isom_get_track_count(import.dest); i++)\n\t\t{\n\t\t\te = gf_media_filter_hevc(import.dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \"Warning: track ID %d: error while filtering LHVC layers\\n\", gf_isom_get_track_id(import.dest, i));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (check_track_for_svc) {\n\t\tif (svc_mode) {\n\t\t\te = gf_media_split_svc(import.dest, check_track_for_svc, (svc_mode==2) ? 1 : 0);\n\t\t\tif (e) goto exit;\n\t\t} else {\n\t\t\te = gf_media_merge_svc(import.dest, check_track_for_svc, 1);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_HEVC\n\tif (check_track_for_lhvc) {\n\t\tif (svc_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = GF_LHVC_EXTRACTORS_ON;\n\t\t\tif (svc_mode==3) xmode = GF_LHVC_EXTRACTORS_OFF;\n\t\t\telse if (svc_mode==4) xmode = GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND;\n\t\t\te = gf_media_split_lhvc(import.dest, check_track_for_lhvc, GF_FALSE, (svc_mode==1) ? 0 : 1, xmode );\n\t\t\tif (e) goto exit;\n\t\t} else {\n\t\t\t//TODO - merge, temporal sublayers\n\t\t}\n\t}\n\tif (check_track_for_hevc) {\n\t\tif (split_tile_mode) {\n\t\t\te = gf_media_split_hevc_tiles(import.dest, split_tile_mode - 1);\n\t\t\tif (e) goto exit;\n\t\t}\n\t\tif (temporal_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = (temporal_mode==3) ? GF_LHVC_EXTRACTORS_OFF : GF_LHVC_EXTRACTORS_ON;\n\t\t\te = gf_media_split_lhvc(import.dest, check_track_for_hevc, GF_TRUE, (temporal_mode==1) ? GF_FALSE : GF_TRUE, xmode );\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\n#endif /*GPAC_DISABLE_HEVC*/\n\nexit:\n\twhile (gf_list_count(kinds)) {\n\t\tchar *kind = (char *)gf_list_get(kinds, 0);\n\t\tgf_list_rem(kinds, 0);\n\t\tif (kind) gf_free(kind);\n\t}\n\tgf_list_del(kinds);\n\tif (handler_name) gf_free(handler_name);\n\tif (chapter_name ) gf_free(chapter_name);\n\tif (import.fontName) gf_free(import.fontName);\n\tif (import.streamFormat) gf_free(import.streamFormat);\n\tif (import.force_ext) gf_free(import.force_ext);\n\tif (rvc_config) gf_free(rvc_config);\n\tif (szLan) gf_free((char *)szLan);\n\treturn e;\n}\n\ntypedef struct\n{\n\tu32 tk;\n\tBool has_non_raps;\n\tu32 last_sample;\n\tu32 sample_count;\n\tu32 time_scale;\n\tu64 firstDTS, lastDTS;\n\tu32 dst_tk;\n\t/*set if media can be duplicated at split boundaries - only used for text tracks and provate tracks, this assumes all\n\tsamples are RAP*/\n\tBool can_duplicate;\n\t/*controls import by time rather than by sample (otherwise we would have to remove much more samples video vs audio for example*/\n\tBool first_sample_done;\n\tBool next_sample_is_rap;\n\tu32 stop_state;\n} TKInfo;\n\nGF_Err split_isomedia_file(GF_ISOFile *mp4, Double split_dur, u64 split_size_kb, char *inName, Double InterleavingTime, Double chunk_start_time, Bool adjust_split_end, char *outName, const char *tmpdir)\n{\n\tu32 i, count, nb_tk, needs_rap_sync, cur_file, conv_type, nb_tk_done, nb_samp, nb_done, di;\n\tDouble max_dur, cur_file_time;\n\tBool do_add, all_duplicatable, size_exceeded, chunk_extraction, rap_split, split_until_end;\n\tGF_ISOFile *dest;\n\tGF_ISOSample *samp;\n\tGF_Err e;\n\tTKInfo *tks, *tki;\n\tchar *ext, szName[1000], szFile[1000];\n\tDouble chunk_start = (Double) chunk_start_time;\n\n\tchunk_extraction = (chunk_start>=0) ? 1 : 0;\n\tsplit_until_end = 0;\n\trap_split = 0;\n\tif (split_size_kb == (u64)-1) rap_split = 1;\n\tif (split_dur == -1) rap_split = 1;\n\telse if (split_dur <= -2) {\n\t\tsplit_size_kb = 0;\n\t\tsplit_until_end = 1;\n\t}\n\n\tif (rap_split) {\n\t\tsplit_size_kb = 0;\n\t\tsplit_dur = (double) GF_MAX_FLOAT;\n\t}\n\n\n\text = strrchr(inName, '/');\n\tif (!ext) ext = strrchr(inName, '\\\\');\n\tstrcpy(szName, ext ? ext+1 : inName);\n\text = strrchr(szName, '.');\n\tif (ext) ext[0] = 0;\n\text = strrchr(inName, '.');\n\n\tdest = NULL;\n\n\tconv_type = 0;\n\tswitch (gf_isom_guess_specification(mp4)) {\n\tcase GF_ISOM_BRAND_ISMA:\n\t\tconv_type = 1;\n\t\tbreak;\n\tcase GF_ISOM_BRAND_3GP4:\n\tcase GF_ISOM_BRAND_3GP5:\n\tcase GF_ISOM_BRAND_3GP6:\n\tcase GF_ISOM_BRAND_3GG6:\n\tcase GF_ISOM_BRAND_3G2A:\n\t\tconv_type = 2;\n\t\tbreak;\n\t}\n\tif (!stricmp(ext, \".3gp\") || !stricmp(ext, \".3g2\")) conv_type = 2;\n\n\tcount = gf_isom_get_track_count(mp4);\n\ttks = (TKInfo *)gf_malloc(sizeof(TKInfo)*count);\n\tmemset(tks, 0, sizeof(TKInfo)*count);\n\n\te = GF_OK;\n\tmax_dur = 0;\n\tnb_tk = 0;\n\tall_duplicatable = 1;\n\tneeds_rap_sync = 0;\n\tnb_samp = 0;\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype;\n\t\tDouble dur;\n\t\ttks[nb_tk].tk = i+1;\n\t\ttks[nb_tk].can_duplicate = 0;\n\n\t\tmtype = gf_isom_get_media_type(mp4, i+1);\n\t\tswitch (mtype) {\n\t\t/*we duplicate text samples at boundaries*/\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\t\ttks[nb_tk].can_duplicate = 1;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\tif (gf_isom_get_sample_count(mp4, i+1)>1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tcase GF_ISOM_MEDIA_FLASH:\n\t\t\tfprintf(stderr, \"WARNING: Track ID %d (type %s) not handled by splitter - skipping\\n\", gf_isom_get_track_id(mp4, i+1), gf_4cc_to_str(mtype));\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/*for all other track types, only split if more than one sample*/\n\t\t\tif (gf_isom_get_sample_count(mp4, i+1)==1) {\n\t\t\t\tfprintf(stderr, \"WARNING: Track ID %d (type %s) not handled by splitter - skipping\\n\", gf_isom_get_track_id(mp4, i+1), gf_4cc_to_str(mtype));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttks[nb_tk].can_duplicate = 1;\n\t\t}\n\n\t\ttks[nb_tk].sample_count = gf_isom_get_sample_count(mp4, i+1);\n\t\tnb_samp += tks[nb_tk].sample_count;\n\t\ttks[nb_tk].last_sample = 0;\n\t\ttks[nb_tk].firstDTS = 0;\n\t\ttks[nb_tk].time_scale = gf_isom_get_media_timescale(mp4, i+1);\n\t\ttks[nb_tk].has_non_raps = gf_isom_has_sync_points(mp4, i+1);\n\t\t/*seen that on some 3gp files from nokia ...*/\n\t\tif (mtype==GF_ISOM_MEDIA_AUDIO) tks[nb_tk].has_non_raps = 0;\n\n\t\tdur = (Double) (s64) gf_isom_get_media_duration(mp4, i+1);\n\t\tdur /= tks[nb_tk].time_scale;\n\t\tif (max_dur<dur) max_dur=dur;\n\n\t\tif (tks[nb_tk].has_non_raps) {\n\t\t\t/*we don't support that*/\n\t\t\tif (needs_rap_sync) {\n\t\t\t\tfprintf(stderr, \"More than one track has non-sync points - cannot split file\\n\");\n\t\t\t\tgf_free(tks);\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\tneeds_rap_sync = nb_tk+1;\n\t\t}\n\t\tif (!tks[nb_tk].can_duplicate) all_duplicatable = 0;\n\t\tnb_tk++;\n\t}\n\tif (!nb_tk) {\n\t\tfprintf(stderr, \"No suitable tracks found for splitting file\\n\");\n\t\tgf_free(tks);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (chunk_start>=max_dur) {\n\t\tfprintf(stderr, \"Input file (%f) shorter than requested split start offset (%f)\\n\", max_dur, chunk_start);\n\t\tgf_free(tks);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (split_until_end) {\n\t\tif (split_dur < -2) {\n\t\t\tsplit_dur = - (split_dur + 2 - chunk_start);\n\t\t\tif (max_dur < split_dur) {\n\t\t\t\tfprintf(stderr, \"Split duration till end %lf longer than track duration %lf\\n\", split_dur, max_dur);\n\t\t\t\tgf_free(tks);\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tsplit_dur = max_dur - split_dur;\n\t\t\t}\n\t\t} else {\n\t\t\tsplit_dur = max_dur;\n\t\t}\n\t} else if (!rap_split && (max_dur<=split_dur)) {\n\t\tfprintf(stderr, \"Input file (%f) shorter than requested split duration (%f)\\n\", max_dur, split_dur);\n\t\tgf_free(tks);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (needs_rap_sync) {\n\t\tBool has_enough_sync = GF_FALSE;\n\t\ttki = &tks[needs_rap_sync-1];\n\n\t\tif (chunk_start == 0.0f)\n\t\t\thas_enough_sync = GF_TRUE;\n\t\telse if (gf_isom_get_sync_point_count(mp4, tki->tk) > 1)\n\t\t\thas_enough_sync = GF_TRUE;\n\t\telse if (gf_isom_get_sample_group_info(mp4, tki->tk, 1, GF_ISOM_SAMPLE_GROUP_RAP, NULL, NULL, NULL))\n\t\t\thas_enough_sync = GF_TRUE;\n\t\telse if (gf_isom_get_sample_group_info(mp4, tki->tk, 1, GF_ISOM_SAMPLE_GROUP_SYNC, NULL, NULL, NULL))\n\t\t\thas_enough_sync = GF_TRUE;\n\n\t\tif (!has_enough_sync) {\n\t\t\tfprintf(stderr, \"Not enough Random Access points in input file - cannot split\\n\");\n\t\t\tgf_free(tks);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\tsplit_size_kb *= 1024;\n\tcur_file_time = 0;\n\n\tif (chunk_start>0) {\n\t\tif (needs_rap_sync) {\n\t\t\tu32 sample_num;\n\t\t\tDouble start;\n\t\t\ttki = &tks[needs_rap_sync-1];\n\n\t\t\tstart = (Double) (s64) gf_isom_get_sample_dts(mp4, tki->tk, tki->sample_count);\n\t\t\tstart /= tki->time_scale;\n\t\t\tif (start<chunk_start) {\n\t\t\t\ttki->stop_state = 2;\n\t\t\t} else  {\n\t\t\t\te = gf_isom_get_sample_for_media_time(mp4, tki->tk, (u64) (chunk_start*tki->time_scale), &di, GF_ISOM_SEARCH_SYNC_BACKWARD, &samp, &sample_num);\n\t\t\t\tif (e!=GF_OK) {\n\t\t\t\t\tfprintf(stderr, \"Cannot locate RAP in track ID %d for chunk extraction from %02.2f sec\\n\", gf_isom_get_track_id(mp4, tki->tk), chunk_start);\n\t\t\t\t\tgf_free(tks);\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t\tstart = (Double) (s64) samp->DTS;\n\t\t\t\tstart /= tki->time_scale;\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\tfprintf(stderr, \"Adjusting chunk start time to previous random access at %02.2f sec\\n\", start);\n\t\t\t\tsplit_dur += (chunk_start - start);\n\t\t\t\tchunk_start = start;\n\t\t\t}\n\t\t}\n\t\t/*sync all tracks*/\n\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\ttki = &tks[i];\n\t\t\twhile (tki->last_sample<tki->sample_count) {\n\t\t\t\tDouble time;\n\t\t\t\tu64 dts;\n\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\ttime = (Double) (s64) dts;\n\t\t\t\ttime /= tki->time_scale;\n\t\t\t\tif (time>=chunk_start) {\n\t\t\t\t\t/*rewind one sample (text tracks & co)*/\n\t\t\t\t\tif (tki->can_duplicate && tki->last_sample) {\n\t\t\t\t\t\ttki->last_sample--;\n\t\t\t\t\t\ttki->firstDTS = (u64) (chunk_start*tki->time_scale);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttki->firstDTS = dts;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttki->last_sample++;\n\t\t\t}\n\t\t}\n\t\tcur_file_time = chunk_start;\n\t} else {\n\t\tchunk_start = 0;\n\t}\n\n\tdest = NULL;\n\tnb_done = 0;\n\tnb_tk_done = 0;\n\tcur_file = 0;\n\twhile (nb_tk_done<nb_tk) {\n\t\tDouble last_rap_sample_time, max_dts, file_split_dur;\n\t\tBool is_last_rap;\n\t\tBool all_av_done = GF_FALSE;\n\n\t\tif (chunk_extraction) {\n\t\t\tsprintf(szFile, \"%s_%d_%d%s\", szName, (u32) chunk_start, (u32) (chunk_start+split_dur), ext);\n\t\t\tif (outName) strcpy(szFile, outName);\n\t\t} else {\n\t\t\tsprintf(szFile, \"%s_%03d%s\", szName, cur_file+1, ext);\n\t\t\tif (outName) {\n\t\t\t\tchar *the_file = gf_url_concatenate(outName, szFile);\n\t\t\t\tif (the_file) {\n\t\t\t\t\tstrcpy(szFile, the_file);\n\t\t\t\t\tgf_free(the_file);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdest = gf_isom_open(szFile, GF_ISOM_WRITE_EDIT, tmpdir);\n\t\t/*clone all tracks*/\n\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\ttki = &tks[i];\n\t\t\t/*track done - we remove the track from destination, an empty video track could cause pbs to some players*/\n\t\t\tif (tki->stop_state==2) continue;\n\n\t\t\te = gf_isom_clone_track(mp4, tki->tk, dest, GF_FALSE, &tki->dst_tk);\n\t\t\tif (e) {\n\t\t\t\tfprintf(stderr, \"Error cloning track %d\\n\", tki->tk);\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\t/*use non-packet CTS offsets (faster add/remove)*/\n\t\t\tif (gf_isom_has_time_offset(mp4, tki->tk)) {\n\t\t\t\tgf_isom_set_cts_packing(dest, tki->dst_tk, GF_TRUE);\n\t\t\t}\n\t\t\tgf_isom_remove_edit_segments(dest, tki->dst_tk);\n\t\t}\n\t\tdo_add = 1;\n\t\tis_last_rap = 0;\n\t\tlast_rap_sample_time = 0;\n\t\tfile_split_dur = split_dur;\n\n\t\tsize_exceeded = 0;\n\t\tmax_dts = 0;\n\t\twhile (do_add) {\n\t\t\tBool is_rap;\n\t\t\tDouble time;\n\t\t\tu32 nb_over, nb_av = 0;\n\t\t\t/*perfom basic de-interleaving to make sure we're not importing too much of a given track*/\n\t\t\tu32 nb_add = 0;\n\t\t\t/*add one sample of each track*/\n\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\tDouble t;\n\t\t\t\tu64 dts;\n\t\t\t\ttki = &tks[i];\n\n\t\t\t\tif (!tki->can_duplicate) nb_av++;\n\n\t\t\t\tif (tki->stop_state)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tki->last_sample==tki->sample_count)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*get sample info, see if we need to check it (basic de-interleaver)*/\n\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\n\t\t\t\t/*reinsertion (timed text)*/\n\t\t\t\tif (dts < tki->firstDTS) {\n\t\t\t\t\tsamp = gf_isom_get_sample(mp4, tki->tk, tki->last_sample+1, &di);\n\t\t\t\t\tsamp->DTS = 0;\n\t\t\t\t\te = gf_isom_add_sample(dest, tki->dst_tk, di, samp);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\te = gf_isom_copy_sample_info(dest, tki->dst_tk, mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\ttki->last_sample += 1;\n\t\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t}\n\t\t\t\tdts -= tki->firstDTS;\n\n\n\t\t\t\tt = (Double) (s64) dts;\n\t\t\t\tt /= tki->time_scale;\n\t\t\t\tif (tki->first_sample_done) {\n\t\t\t\t\tif (!all_av_done && (t>max_dts)) continue;\n\t\t\t\t} else {\n\t\t\t\t\t/*here's the trick: only take care of a/v media for splitting, and add other media\n\t\t\t\t\tonly if thir dts is less than the max AV dts found. Otherwise with some text streams we will end up importing\n\t\t\t\t\ttoo much video and corrupting the last sync point indication*/\n\t\t\t\t\tif (!tki->can_duplicate && (t>max_dts)) max_dts = t;\n\t\t\t\t\ttki->first_sample_done = 1;\n\t\t\t\t}\n\t\t\t\tsamp = gf_isom_get_sample(mp4, tki->tk, tki->last_sample+1, &di);\n\t\t\t\tsamp->DTS -= tki->firstDTS;\n\n\t\t\t\tnb_add += 1;\n\n\t\t\t\tis_rap = GF_FALSE;\n\t\t\t\tif (samp->IsRAP) {\n\t\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tBool has_roll;\n\t\t\t\t\tgf_isom_get_sample_rap_roll_info(mp4, tki->tk, tki->last_sample+1, &is_rap, &has_roll, NULL);\n\t\t\t\t}\n\n\n\t\t\t\tif (tki->has_non_raps && is_rap) {\n\t\t\t\t\tGF_ISOSample *next_rap;\n\t\t\t\t\tu32 next_rap_num, sdi;\n\t\t\t\t\tlast_rap_sample_time = (Double) (s64) samp->DTS;\n\t\t\t\t\tlast_rap_sample_time /= tki->time_scale;\n\t\t\t\t\te = gf_isom_get_sample_for_media_time(mp4, tki->tk, samp->DTS+tki->firstDTS+2, &sdi, GF_ISOM_SEARCH_SYNC_FORWARD, &next_rap, &next_rap_num);\n\t\t\t\t\tif (e==GF_EOS)\n\t\t\t\t\t\tis_last_rap = 1;\n\t\t\t\t\tif (next_rap) {\n\t\t\t\t\t\tif (!next_rap->IsRAP)\n\t\t\t\t\t\t\tis_last_rap = 1;\n\t\t\t\t\t\tgf_isom_sample_del(&next_rap);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttki->lastDTS = samp->DTS;\n\t\t\t\te = gf_isom_add_sample(dest, tki->dst_tk, di, samp);\n\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\tif (!e) {\n\t\t\t\t\te = gf_isom_copy_sample_info(dest, tki->dst_tk, mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t}\n\t\t\t\ttki->last_sample += 1;\n\t\t\t\tgf_set_progress(\"Splitting\", nb_done, nb_samp);\n\t\t\t\tnb_done++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error cloning track %d sample %d\\n\", tki->tk, tki->last_sample);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\n\t\t\t\ttki->next_sample_is_rap = 0;\n\t\t\t\tif (rap_split && tki->has_non_raps) {\n\t\t\t\t\tif ( gf_isom_get_sample_sync(mp4, tki->tk, tki->last_sample+1))\n\t\t\t\t\t\ttki->next_sample_is_rap = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*test by size/duration*/\n\t\t\tnb_over = 0;\n\n\t\t\t/*test by file size: same as duration test, only dynamically increment import duration*/\n\t\t\tif (split_size_kb) {\n\t\t\t\tu64 est_size = gf_isom_estimate_size(dest);\n\t\t\t\t/*while below desired size keep importing*/\n\t\t\t\tif (est_size<split_size_kb)\n\t\t\t\t\tfile_split_dur = (Double) GF_MAX_FLOAT;\n\t\t\t\telse {\n\t\t\t\t\tsize_exceeded = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\ttki = &tks[i];\n\t\t\t\tif (tki->stop_state) {\n\t\t\t\t\tnb_over++;\n\t\t\t\t\tif (!tki->can_duplicate && (tki->last_sample==tki->sample_count) )\n\t\t\t\t\t\tnb_av--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttime = (Double) (s64) tki->lastDTS;\n\t\t\t\ttime /= tki->time_scale;\n\t\t\t\tif (size_exceeded\n\t\t\t\t        || (tki->last_sample==tki->sample_count)\n\t\t\t\t        || (!tki->can_duplicate && (time>file_split_dur))\n\t\t\t\t        || (rap_split && tki->has_non_raps && tki->next_sample_is_rap)\n\t\t\t\t   ) {\n\t\t\t\t\tnb_over++;\n\t\t\t\t\ttki->stop_state = 1;\n\t\t\t\t\tif (tki->last_sample<tki->sample_count)\n\t\t\t\t\t\tis_last_rap = 0;\n\t\t\t\t\telse if (tki->first_sample_done)\n\t\t\t\t\t\tis_last_rap = 0;\n\n\t\t\t\t\tif (rap_split && tki->next_sample_is_rap) {\n\t\t\t\t\t\tfile_split_dur = (Double) ( gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1) - tki->firstDTS);\n\t\t\t\t\t\tfile_split_dur /= tki->time_scale;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*special tracks (not audio, not video)*/\n\t\t\t\telse if (tki->can_duplicate) {\n\t\t\t\t\tu64 dts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t\ttime = (Double) (s64) (dts - tki->firstDTS);\n\t\t\t\t\ttime /= tki->time_scale;\n\t\t\t\t\tif (time>file_split_dur) {\n\t\t\t\t\t\tnb_over++;\n\t\t\t\t\t\ttki->stop_state = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!nb_add && (!max_dts || (tki->lastDTS <= 1 + (u64) (tki->time_scale*max_dts) )))\n\t\t\t\t\ttki->first_sample_done = 0;\n\t\t\t}\n\t\t\tif (nb_over==nb_tk) do_add = 0;\n\n\t\t\tif (!nb_av)\n\t\t\t\tall_av_done = GF_TRUE;\n\t\t}\n\n\t\t/*remove samples - first figure out smallest duration*/\n\t\tfile_split_dur = (Double) GF_MAX_FLOAT;\n\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\tDouble time;\n\t\t\ttki = &tks[i];\n\t\t\t/*track done*/\n\t\t\tif ((tki->stop_state==2) || (!is_last_rap && (tki->sample_count == tki->last_sample)) ) {\n\t\t\t\tif (tki->has_non_raps) last_rap_sample_time = 0;\n\t\t\t\ttime = (Double) (s64) ( gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1) - tki->firstDTS);\n\t\t\t\ttime /= tki->time_scale;\n\t\t\t\tif (file_split_dur==(Double)GF_MAX_FLOAT || file_split_dur<time) file_split_dur = time;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//if (tki->lastDTS)\n\t\t\t{\n\t\t\t\t//time = (Double) (s64) tki->lastDTS;\n\t\t\t\ttime = (Double) (s64) ( gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1) - tki->firstDTS);\n\t\t\t\ttime /= tki->time_scale;\n\t\t\t\tif ((!tki->can_duplicate || all_duplicatable) && time<file_split_dur) file_split_dur = time;\n\t\t\t\telse if (rap_split && tki->next_sample_is_rap) file_split_dur = time;\n\t\t\t}\n\t\t}\n\t\tif (file_split_dur == (Double) GF_MAX_FLOAT) {\n\t\t\tfprintf(stderr, \"Cannot split file (duration too small or size too small)\\n\");\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (chunk_extraction) {\n\t\t\tif (adjust_split_end) {\n\t\t\t\tfprintf(stderr, \"Adjusting chunk end time to previous random access at %02.2f sec\\n\", chunk_start + last_rap_sample_time);\n\t\t\t\tfile_split_dur = last_rap_sample_time;\n\t\t\t\tif (outName) strcpy(szFile, outName);\n\t\t\t\telse sprintf(szFile, \"%s_%d_%d%s\", szName, (u32) chunk_start, (u32) (chunk_start+file_split_dur), ext);\n\t\t\t\tgf_isom_set_final_name(dest, szFile);\n\t\t\t}\n\t\t\telse file_split_dur = split_dur;\n\t\t}\n\n\t\t/*don't split if eq to copy...*/\n\t\tif (is_last_rap && !cur_file && !chunk_start) {\n\t\t\tfprintf(stderr, \"Cannot split file (Not enough sync samples, duration too large or size too big)\\n\");\n\t\t\tgoto err_exit;\n\t\t}\n\n\n\t\t/*if not last chunk and longer duration adjust to previous RAP point*/\n\t\tif ( (size_exceeded || !split_size_kb) && (file_split_dur>split_dur) && !chunk_start) {\n\t\t\t/*if larger than last RAP, rewind till it*/\n\t\t\tif (last_rap_sample_time && (last_rap_sample_time<file_split_dur) ) {\n\t\t\t\tfile_split_dur = last_rap_sample_time;\n\t\t\t\tis_last_rap = 0;\n\t\t\t}\n\t\t}\n\n\t\tnb_tk_done = 0;\n\t\tif (!is_last_rap || chunk_extraction) {\n\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\tDouble time = 0;\n\t\t\t\tu32 last_samp;\n\t\t\t\ttki = &tks[i];\n\t\t\t\twhile (1) {\n\t\t\t\t\tlast_samp = gf_isom_get_sample_count(dest, tki->dst_tk);\n\n\t\t\t\t\ttime = (Double) (s64) gf_isom_get_media_duration(dest, tki->dst_tk);\n\t\t\t\t\t//time could get slightly higher than requests dur due to rounding precision. We use 1/4 of the last sample dur as safety marge\n\t\t\t\t\ttime -= (Double) (s64) gf_isom_get_sample_duration(dest, tki->dst_tk, tki->last_sample) / 4;\n\t\t\t\t\ttime /= tki->time_scale;\n\n\t\t\t\t\tif (last_samp<=1) break;\n\n\t\t\t\t\t/*done*/\n\t\t\t\t\tif (tki->last_sample==tki->sample_count) {\n\t\t\t\t\t\tif (!chunk_extraction && !tki->can_duplicate) {\n\t\t\t\t\t\t\ttki->stop_state=2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (time <= file_split_dur) break;\n\n\t\t\t\t\tgf_isom_remove_sample(dest, tki->dst_tk, last_samp);\n\t\t\t\t\ttki->last_sample--;\n\t\t\t\t\tassert(tki->last_sample);\n\t\t\t\t\tnb_done--;\n\t\t\t\t\tgf_set_progress(\"Splitting\", nb_done, nb_samp);\n\t\t\t\t}\n\t\t\t\tif (tki->last_sample<tki->sample_count) {\n\t\t\t\t\tu64 dts;\n\t\t\t\t\ttki->stop_state = 0;\n\t\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t\ttime = (Double) (s64) (dts - tki->firstDTS);\n\t\t\t\t\ttime /= tki->time_scale;\n\t\t\t\t\t/*re-insert prev sample*/\n\t\t\t\t\tif (tki->can_duplicate && (time>file_split_dur) ) {\n\t\t\t\t\t\tBool was_insert = GF_FALSE;\n\t\t\t\t\t\ttki->last_sample--;\n\t\t\t\t\t\tdts = gf_isom_get_sample_dts(mp4, tki->tk, tki->last_sample+1);\n\t\t\t\t\t\tif (dts < tki->firstDTS) was_insert = GF_TRUE;\n\t\t\t\t\t\ttki->firstDTS += (u64) (file_split_dur*tki->time_scale);\n\t\t\t\t\t\t//the original, last sample added starts before the first sample in the file: we have re-inserted\n\t\t\t\t\t\t//a single sample, use split duration as target duration\n\t\t\t\t\t\tif (was_insert) {\n\t\t\t\t\t\t\tgf_isom_set_last_sample_duration(dest, tki->dst_tk, (u32) (file_split_dur*tki->time_scale));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_isom_set_last_sample_duration(dest, tki->dst_tk, (u32) (tki->firstDTS - dts) );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttki->firstDTS = dts;\n\t\t\t\t\t}\n\t\t\t\t\ttki->first_sample_done = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnb_tk_done++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif (chunk_extraction) {\n\t\t\tfprintf(stderr, \"Extracting chunk %s - duration %02.2fs (%02.2fs->%02.2fs)\\n\", szFile, file_split_dur, chunk_start, (chunk_start+split_dur));\n\t\t} else {\n\t\t\tfprintf(stderr, \"Storing split-file %s - duration %02.2f seconds\\n\", szFile, file_split_dur);\n\t\t}\n\n\t\t/*repack CTSs*/\n\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\tu32 j;\n\t\t\tu64 new_track_dur;\n\t\t\ttki = &tks[i];\n\t\t\tif (tki->stop_state == 2) continue;\n\t\t\tif (!gf_isom_get_sample_count(dest, tki->dst_tk)) {\n\t\t\t\tgf_isom_remove_track(dest, tki->dst_tk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (gf_isom_has_time_offset(mp4, tki->tk)) {\n\t\t\t\tgf_isom_set_cts_packing(dest, tki->dst_tk, GF_FALSE);\n\t\t\t}\n\t\t\tif (is_last_rap && tki->can_duplicate) {\n\t\t\t\tgf_isom_set_last_sample_duration(dest, tki->dst_tk, gf_isom_get_sample_duration(mp4, tki->tk, tki->sample_count));\n\t\t\t}\n\n\t\t\t/*rewrite edit list*/\n\t\t\tnew_track_dur = gf_isom_get_track_duration(dest, tki->dst_tk);\n\t\t\tcount = gf_isom_get_edit_segment_count(mp4, tki->tk);\n\t\t\tif (count>2) {\n\t\t\t\tfprintf(stderr, \"Warning: %d edit segments - not supported while splitting (max 2) - ignoring extra\\n\", count);\n\t\t\t\tcount=2;\n\t\t\t}\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tu64 editTime, segDur, MediaTime;\n\t\t\t\tu8 mode;\n\n\t\t\t\tgf_isom_get_edit_segment(mp4, tki->tk, j+1, &editTime, &segDur, &MediaTime, &mode);\n\t\t\t\tif (!j && (mode!=GF_ISOM_EDIT_EMPTY) ) {\n\t\t\t\t\tfprintf(stderr, \"Warning: Edit list doesn't look like a track delay scheme - ignoring\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mode==GF_ISOM_EDIT_NORMAL) {\n\t\t\t\t\tsegDur = new_track_dur;\n\t\t\t\t}\n\t\t\t\tgf_isom_set_edit_segment(dest, tki->dst_tk, editTime, segDur, MediaTime, mode);\n\t\t\t}\n\t\t}\n\t\t/*check chapters*/\n\t\tdo_add = 1;\n\t\tfor (i=0; i<gf_isom_get_chapter_count(mp4, 0); i++) {\n\t\t\tchar *name;\n\t\t\tu64 chap_time;\n\t\t\tgf_isom_get_chapter(mp4, 0, i+1, &chap_time, (const char **) &name);\n\t\t\tmax_dts = (Double) (s64) chap_time;\n\t\t\tmax_dts /= 1000;\n\t\t\tif (max_dts<cur_file_time) continue;\n\t\t\tif (max_dts>cur_file_time+file_split_dur) break;\n\t\t\tmax_dts-=cur_file_time;\n\t\t\tchap_time = (u64) (max_dts*1000);\n\t\t\tgf_isom_add_chapter(dest, 0, chap_time, name);\n\t\t\t/*add prev*/\n\t\t\tif (do_add && i) {\n\t\t\t\tgf_isom_get_chapter(mp4, 0, i, &chap_time, (const char **) &name);\n\t\t\t\tgf_isom_add_chapter(dest, 0, 0, name);\n\t\t\t\tdo_add = 0;\n\t\t\t}\n\t\t}\n\t\tcur_file_time += file_split_dur;\n\n\t\tif (conv_type==1) gf_media_make_isma(dest, 1, 0, 0);\n\t\telse if (conv_type==2) gf_media_make_3gpp(dest);\n\t\tif (InterleavingTime) {\n\t\t\tgf_isom_make_interleave(dest, InterleavingTime);\n\t\t} else {\n\t\t\tgf_isom_set_storage_mode(dest, GF_ISOM_STORE_STREAMABLE);\n\t\t}\n\n\t\tgf_isom_clone_pl_indications(mp4, dest);\n\t\te = gf_isom_close(dest);\n\t\tdest = NULL;\n\t\tif (e) fprintf(stderr, \"Error storing file %s\\n\", gf_error_to_string(e));\n\t\tif (is_last_rap || chunk_extraction) break;\n\t\tcur_file++;\n\t}\n\tgf_set_progress(\"Splitting\", nb_samp, nb_samp);\nerr_exit:\n\tif (dest) gf_isom_delete(dest);\n\tgf_free(tks);\n\treturn e;\n}\n\nGF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command);\n\nstatic Bool merge_parameter_set(GF_List *src, GF_List *dst, const char *name)\n{\n\tu32 j, k;\n\tfor (j=0; j<gf_list_count(src); j++) {\n\t\tBool found = 0;\n\t\tGF_AVCConfigSlot *slc = gf_list_get(src, j);\n\t\tfor (k=0; k<gf_list_count(dst); k++) {\n\t\t\tGF_AVCConfigSlot *slc_dst = gf_list_get(dst, k);\n\t\t\tif ( (slc->size==slc_dst->size) && !memcmp(slc->data, slc_dst->data, slc->size) ) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nstatic u32 merge_avc_config(GF_ISOFile *dest, u32 tk_id, GF_ISOFile *orig, u32 src_track, Bool force_cat)\n{\n\tGF_AVCConfig *avc_src, *avc_dst;\n\tu32 dst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\n\tavc_src = gf_isom_avc_config_get(orig, src_track, 1);\n\tavc_dst = gf_isom_avc_config_get(dest, dst_tk, 1);\n\n\tif (avc_src->AVCLevelIndication!=avc_dst->AVCLevelIndication) {\n\t\tdst_tk = 0;\n\t} else if (avc_src->AVCProfileIndication!=avc_dst->AVCProfileIndication) {\n\t\tdst_tk = 0;\n\t}\n\telse {\n\t\t/*rewrite all samples if using different NALU size*/\n\t\tif (avc_src->nal_unit_size > avc_dst->nal_unit_size) {\n\t\t\tgf_media_avc_rewrite_samples(dest, dst_tk, 8*avc_dst->nal_unit_size, 8*avc_src->nal_unit_size);\n\t\t\tavc_dst->nal_unit_size = avc_src->nal_unit_size;\n\t\t} else if (avc_src->nal_unit_size < avc_dst->nal_unit_size) {\n\t\t\tgf_media_avc_rewrite_samples(orig, src_track, 8*avc_src->nal_unit_size, 8*avc_dst->nal_unit_size);\n\t\t}\n\n\t\t/*merge PS*/\n\t\tif (!merge_parameter_set(avc_src->sequenceParameterSets, avc_dst->sequenceParameterSets, \"SPS\"))\n\t\t\tdst_tk = 0;\n\t\tif (!merge_parameter_set(avc_src->pictureParameterSets, avc_dst->pictureParameterSets, \"PPS\"))\n\t\t\tdst_tk = 0;\n\n\t\tgf_isom_avc_config_update(dest, dst_tk, 1, avc_dst);\n\t}\n\n\tgf_odf_avc_cfg_del(avc_src);\n\tgf_odf_avc_cfg_del(avc_dst);\n\n\tif (!dst_tk) {\n\t\tdst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\t\tgf_isom_set_nalu_extract_mode(orig, src_track, GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG);\n\t\tif (!force_cat) {\n\t\t\tgf_isom_avc_set_inband_config(dest, dst_tk, 1);\n\t\t} else {\n\t\t\tfprintf(stderr, \"WARNING: Concatenating track ID %d even though sample descriptions do not match\\n\", tk_id);\n\t\t}\n\t}\n\treturn dst_tk;\n}\n\n#ifndef GPAC_DISABLE_HEVC\nstatic u32 merge_hevc_config(GF_ISOFile *dest, u32 tk_id, GF_ISOFile *orig, u32 src_track, Bool force_cat)\n{\n\tu32 i;\n\tGF_HEVCConfig *hevc_src, *hevc_dst;\n\tu32 dst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\n\thevc_src = gf_isom_hevc_config_get(orig, src_track, 1);\n\thevc_dst = gf_isom_hevc_config_get(dest, dst_tk, 1);\n\n\tif (hevc_src->profile_idc != hevc_dst->profile_idc) dst_tk = 0;\n\telse if (hevc_src->level_idc != hevc_dst->level_idc) dst_tk = 0;\n\telse if (hevc_src->general_profile_compatibility_flags != hevc_dst->general_profile_compatibility_flags ) dst_tk = 0;\n\telse {\n\t\t/*rewrite all samples if using different NALU size*/\n\t\tif (hevc_src->nal_unit_size > hevc_dst->nal_unit_size) {\n\t\t\tgf_media_avc_rewrite_samples(dest, dst_tk, 8*hevc_dst->nal_unit_size, 8*hevc_src->nal_unit_size);\n\t\t\thevc_dst->nal_unit_size = hevc_src->nal_unit_size;\n\t\t} else if (hevc_src->nal_unit_size < hevc_dst->nal_unit_size) {\n\t\t\tgf_media_avc_rewrite_samples(orig, src_track, 8*hevc_src->nal_unit_size, 8*hevc_dst->nal_unit_size);\n\t\t}\n\n\t\t/*merge PS*/\n\t\tfor (i=0; i<gf_list_count(hevc_src->param_array); i++) {\n\t\t\tu32 k;\n\t\t\tGF_HEVCParamArray *src_ar = gf_list_get(hevc_src->param_array, i);\n\t\t\tfor (k=0; k<gf_list_count(hevc_dst->param_array); k++) {\n\t\t\t\tGF_HEVCParamArray *dst_ar = gf_list_get(hevc_dst->param_array, k);\n\t\t\t\tif (dst_ar->type==src_ar->type) {\n\t\t\t\t\tif (!merge_parameter_set(src_ar->nalus, dst_ar->nalus, \"SPS\"))\n\t\t\t\t\t\tdst_tk = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgf_isom_hevc_config_update(dest, dst_tk, 1, hevc_dst);\n\t}\n\n\tgf_odf_hevc_cfg_del(hevc_src);\n\tgf_odf_hevc_cfg_del(hevc_dst);\n\n\tif (!dst_tk) {\n\t\tdst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\t\tgf_isom_set_nalu_extract_mode(orig, src_track, GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG);\n\t\tif (!force_cat) {\n\t\t\tgf_isom_hevc_set_inband_config(dest, dst_tk, 1);\n\t\t} else {\n\t\t\tfprintf(stderr, \"WARNING: Concatenating track ID %d even though sample descriptions do not match\\n\", tk_id);\n\t\t}\n\t}\n\treturn dst_tk;\n}\n#endif /*GPAC_DISABLE_HEVC */\n\nGF_Err cat_isomedia_file(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)\n{\n\tu32 i, j, count, nb_tracks, nb_samp, nb_done;\n\tGF_ISOFile *orig;\n\tGF_Err e;\n\tchar *opts, *multi_cat;\n\tDouble ts_scale;\n\tDouble dest_orig_dur;\n\tu32 dst_tk, tk_id, mtype;\n\tu64 insert_dts;\n\tBool is_isom;\n\tGF_ISOSample *samp;\n\tDouble aligned_to_DTS = 0;\n\n\tif (strchr(fileName, '*')) return cat_multiple_files(dest, fileName, import_flags, force_fps, frames_per_sample, tmp_dir, force_cat, align_timelines, allow_add_in_command);\n\n\tmulti_cat = allow_add_in_command ? strchr(fileName, '+') : NULL;\n\tif (multi_cat) {\n\t\tmulti_cat[0] = 0;\n\t\tmulti_cat = &multi_cat[1];\n\t}\n\topts = strchr(fileName, ':');\n\tif (opts && (opts[1]=='\\\\'))\n\t\topts = strchr(fileName, ':');\n\n\te = GF_OK;\n\n\t/*if options are specified, reimport the file*/\n\tis_isom = opts ? 0 : gf_isom_probe_file(fileName);\n\n\tif (!is_isom || opts) {\n\t\torig = gf_isom_open(\"temp\", GF_ISOM_WRITE_EDIT, tmp_dir);\n\t\te = import_file(orig, fileName, import_flags, force_fps, frames_per_sample);\n\t\tif (e) return e;\n\t} else {\n\t\t/*we open the original file in edit mode since we may have to rewrite AVC samples*/\n\t\torig = gf_isom_open(fileName, GF_ISOM_OPEN_EDIT, tmp_dir);\n\t}\n\n\twhile (multi_cat) {\n\t\tchar *sep = strchr(multi_cat, '+');\n\t\tif (sep) sep[0] = 0;\n\n\t\te = import_file(orig, multi_cat, import_flags, force_fps, frames_per_sample);\n\t\tif (e) {\n\t\t\tgf_isom_delete(orig);\n\t\t\treturn e;\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0]=':';\n\t\tmulti_cat = sep+1;\n\t}\n\n\tnb_samp = 0;\n\tnb_tracks = gf_isom_get_track_count(orig);\n\tfor (i=0; i<nb_tracks; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(orig, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_FLASH:\n\t\t\tfprintf(stderr, \"WARNING: Track ID %d (type %s) not handled by concatenation - removing from destination\\n\", gf_isom_get_track_id(orig, i+1), gf_4cc_to_str(mtype));\n\t\t\tcontinue;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tdefault:\n\t\t\t/*only cat self-contained files*/\n\t\t\tif (gf_isom_is_self_contained(orig, i+1, 1)) {\n\t\t\t\tnb_samp+= gf_isom_get_sample_count(orig, i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!nb_samp) {\n\t\tfprintf(stderr, \"No suitable media tracks to cat in %s - skipping\\n\", fileName);\n\t\tgoto err_exit;\n\t}\n\n\tdest_orig_dur = (Double) (s64) gf_isom_get_duration(dest);\n\tif (!gf_isom_get_timescale(dest)) {\n\t\tgf_isom_set_timescale(dest, gf_isom_get_timescale(orig));\n\t}\n\tdest_orig_dur /= gf_isom_get_timescale(dest);\n\n\taligned_to_DTS = 0;\n\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\tDouble track_dur = (Double) gf_isom_get_media_duration(dest, i+1);\n\t\ttrack_dur /= gf_isom_get_media_timescale(dest, i+1);\n\t\tif (aligned_to_DTS < track_dur) {\n\t\t\taligned_to_DTS = track_dur;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"Appending file %s\\n\", fileName);\n\tnb_done = 0;\n\tfor (i=0; i<nb_tracks; i++) {\n\t\tu64 last_DTS, dest_track_dur_before_cat;\n\t\tu32 nb_edits = 0;\n\t\tBool skip_lang_test = 1;\n\t\tBool use_ts_dur = 1;\n\t\tBool merge_edits = 0;\n\t\tBool new_track = 0;\n\t\tmtype = gf_isom_get_media_type(orig, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_FLASH:\n\t\t\tcontinue;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tuse_ts_dur = 0;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tdefault:\n\t\t\tif (!gf_isom_is_self_contained(orig, i+1, 1)) continue;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst_tk = 0;\n\t\t/*if we had a temporary import of the file, check if the original track ID matches the dst one. If so, skip all language detection code*/\n\t\ttk_id = gf_isom_get_track_original_id(orig, i+1);\n\t\tif (!tk_id) {\n\t\t\ttk_id = gf_isom_get_track_id(orig, i+1);\n\t\t\tskip_lang_test = 0;\n\t\t}\n\t\tdst_tk = gf_isom_get_track_by_id(dest, tk_id);\n\n\n\t\tif (dst_tk) {\n\t\t\tif (mtype != gf_isom_get_media_type(dest, dst_tk))\n\t\t\t\tdst_tk = 0;\n\t\t\telse if (gf_isom_get_media_subtype(dest, dst_tk, 1) != gf_isom_get_media_subtype(orig, i+1, 1))\n\t\t\t\tdst_tk = 0;\n\t\t}\n\n\t\tif (!dst_tk) {\n\t\t\tfor (j=0; j<gf_isom_get_track_count(dest); j++) {\n\t\t\t\tif (mtype != gf_isom_get_media_type(dest, j+1)) continue;\n\t\t\t\tif (gf_isom_is_same_sample_description(orig, i+1, 0, dest, j+1, 0)) {\n\t\t\t\t\tif (gf_isom_is_video_subtype(mtype) ) {\n\t\t\t\t\t\tu32 w, h, ow, oh;\n\t\t\t\t\t\tgf_isom_get_visual_info(orig, i+1, 1, &ow, &oh);\n\t\t\t\t\t\tgf_isom_get_visual_info(dest, j+1, 1, &w, &h);\n\t\t\t\t\t\tif ((ow==w) && (oh==h)) {\n\t\t\t\t\t\t\tdst_tk = j+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*check language code*/\n\t\t\t\t\telse if (!skip_lang_test && (mtype==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\t\t\tu32 lang_src, lang_dst;\n\t\t\t\t\t\tchar *lang = NULL;\n\t\t\t\t\t\tgf_isom_get_media_language(orig, i+1, &lang);\n\t\t\t\t\t\tif (lang) {\n\t\t\t\t\t\t\tlang_src = GF_4CC(lang[0], lang[1], lang[2], lang[3]);\n\t\t\t\t\t\t\tgf_free(lang);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlang_src = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_get_media_language(dest, j+1, &lang);\n\t\t\t\t\t\tif (lang) {\n\t\t\t\t\t\t\tlang_dst = GF_4CC(lang[0], lang[1], lang[2], lang[3]);\n\t\t\t\t\t\t\tgf_free(lang);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlang_dst = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lang_dst==lang_src) {\n\t\t\t\t\t\t\tdst_tk = j+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdst_tk = j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dst_tk) {\n\t\t\tu32 found_dst_tk = dst_tk;\n\t\t\tu32 stype = gf_isom_get_media_subtype(dest, dst_tk, 1);\n\t\t\t/*we MUST have the same codec*/\n\t\t\tif (gf_isom_get_media_subtype(orig, i+1, 1) != stype) dst_tk = 0;\n\t\t\t/*we only support cat with the same number of sample descriptions*/\n\t\t\tif (gf_isom_get_sample_description_count(orig, i+1) != gf_isom_get_sample_description_count(dest, dst_tk)) dst_tk = 0;\n\t\t\t/*if not forcing cat, check the media codec config is the same*/\n\t\t\tif (!gf_isom_is_same_sample_description(orig, i+1, 0, dest, dst_tk, 0)) {\n\t\t\t\tdst_tk = 0;\n\t\t\t}\n\t\t\t/*we force the same visual resolution*/\n\t\t\telse if (gf_isom_is_video_subtype(mtype) ) {\n\t\t\t\tu32 w, h, ow, oh;\n\t\t\t\tgf_isom_get_visual_info(orig, i+1, 1, &ow, &oh);\n\t\t\t\tgf_isom_get_visual_info(dest, dst_tk, 1, &w, &h);\n\t\t\t\tif ((ow!=w) || (oh!=h)) {\n\t\t\t\t\tdst_tk = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dst_tk) {\n\t\t\t\t/*merge AVC config if possible*/\n\t\t\t\tif ((stype == GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\t        || (stype == GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\t        || (stype == GF_ISOM_SUBTYPE_AVC3_H264)\n\t\t\t\t        || (stype == GF_ISOM_SUBTYPE_AVC4_H264) ) {\n\t\t\t\t\tdst_tk = merge_avc_config(dest, tk_id, orig, i+1, force_cat);\n\t\t\t\t}\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t/*merge HEVC config if possible*/\n\t\t\t\telse if ((stype == GF_ISOM_SUBTYPE_HVC1)\n\t\t\t\t         || (stype == GF_ISOM_SUBTYPE_HEV1)\n\t\t\t\t         || (stype == GF_ISOM_SUBTYPE_HVC2)\n\t\t\t\t         || (stype == GF_ISOM_SUBTYPE_HEV2)) {\n\t\t\t\t\tdst_tk = merge_hevc_config(dest, tk_id, orig, i+1, force_cat);\n\t\t\t\t}\n#endif /*GPAC_DISABLE_HEVC*/\n\t\t\t\telse if (force_cat) {\n\t\t\t\t\tdst_tk = found_dst_tk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*looks like a new track*/\n\t\tif (!dst_tk) {\n\t\t\tfprintf(stderr, \"No suitable destination track found - creating new one (type %s)\\n\", gf_4cc_to_str(mtype));\n\t\t\te = gf_isom_clone_track(orig, i+1, dest, GF_FALSE, &dst_tk);\n\t\t\tif (e) goto err_exit;\n\t\t\tgf_isom_clone_pl_indications(orig, dest);\n\t\t\tnew_track = 1;\n\n\t\t\tif (align_timelines) {\n\t\t\t\tu32 max_timescale = 0;\n//\t\t\t\tu32 dst_timescale = 0;\n\t\t\t\tu32 idx;\n\t\t\t\tfor (idx=0; idx<nb_tracks; idx++) {\n\t\t\t\t\tif (max_timescale < gf_isom_get_media_timescale(orig, idx+1))\n\t\t\t\t\t\tmax_timescale = gf_isom_get_media_timescale(orig, idx+1);\n\t\t\t\t}\n#if 0\n\t\t\t\tif (dst_timescale < max_timescale) {\n\t\t\t\t\tdst_timescale = gf_isom_get_media_timescale(dest, dst_tk);\n\t\t\t\t\tidx = max_timescale / dst_timescale;\n\t\t\t\t\tif (dst_timescale * idx < max_timescale) idx ++;\n\t\t\t\t\tdst_timescale *= idx;\n\n\t\t\t\t\tgf_isom_set_media_timescale(dest, dst_tk, max_timescale, 0);\n\t\t\t\t}\n#else\n\t\t\t\tgf_isom_set_media_timescale(dest, dst_tk, max_timescale, 0);\n#endif\n\t\t\t}\n\n\t\t\t/*remove cloned edit list, as it will be rewritten after import*/\n\t\t\tgf_isom_remove_edit_segments(dest, dst_tk);\n\t\t} else {\n\t\t\tnb_edits = gf_isom_get_edit_segment_count(orig, i+1);\n\t\t}\n\n\t\tdest_track_dur_before_cat = gf_isom_get_media_duration(dest, dst_tk);\n\t\tcount = gf_isom_get_sample_count(dest, dst_tk);\n\n\t\tif (align_timelines) {\n\t\t\tinsert_dts = (u64) (aligned_to_DTS * gf_isom_get_media_timescale(dest, dst_tk));\n\t\t} else if (use_ts_dur && (count>1)) {\n\t\t\tinsert_dts = 2*gf_isom_get_sample_dts(dest, dst_tk, count) - gf_isom_get_sample_dts(dest, dst_tk, count-1);\n\t\t} else {\n\t\t\tinsert_dts = dest_track_dur_before_cat;\n\t\t\tif (!count) insert_dts = 0;\n\t\t}\n\n\t\tts_scale = gf_isom_get_media_timescale(dest, dst_tk);\n\t\tts_scale /= gf_isom_get_media_timescale(orig, i+1);\n\n\t\t/*if not a new track, see if we can merge the edit list - this is a crude test that only checks\n\t\twe have the same edit types*/\n\t\tif (nb_edits && (nb_edits == gf_isom_get_edit_segment_count(dest, dst_tk)) ) {\n\t\t\tu64 editTime, segmentDuration, mediaTime, dst_editTime, dst_segmentDuration, dst_mediaTime;\n\t\t\tu8 dst_editMode, editMode;\n\t\t\tu32 j;\n\t\t\tmerge_edits = 1;\n\t\t\tfor (j=0; j<nb_edits; j++) {\n\t\t\t\tgf_isom_get_edit_segment(orig, i+1, j+1, &editTime, &segmentDuration, &mediaTime, &editMode);\n\t\t\t\tgf_isom_get_edit_segment(dest, dst_tk, j+1, &dst_editTime, &dst_segmentDuration, &dst_mediaTime, &dst_editMode);\n\n\t\t\t\tif (dst_editMode!=editMode) {\n\t\t\t\t\tmerge_edits=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlast_DTS = 0;\n\t\tcount = gf_isom_get_sample_count(orig, i+1);\n\t\tfor (j=0; j<count; j++) {\n\t\t\tu32 di;\n\t\t\tsamp = gf_isom_get_sample(orig, i+1, j+1, &di);\n\t\t\tlast_DTS = samp->DTS;\n\t\t\tsamp->DTS =  (u64) (ts_scale * samp->DTS + (new_track ? 0 : insert_dts));\n\t\t\tsamp->CTS_Offset =  (u32) (samp->CTS_Offset * ts_scale);\n\n\t\t\tif (gf_isom_is_self_contained(orig, i+1, di)) {\n\t\t\t\te = gf_isom_add_sample(dest, dst_tk, di, samp);\n\t\t\t} else {\n\t\t\t\tu64 offset;\n\t\t\t\tGF_ISOSample *s = gf_isom_get_sample_info(orig, i+1, j+1, &di, &offset);\n\t\t\t\te = gf_isom_add_sample_reference(dest, dst_tk, di, samp, offset);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (e) goto err_exit;\n\n\t\t\te = gf_isom_copy_sample_info(dest, dst_tk, orig, i+1, j+1);\n\t\t\tif (e) goto err_exit;\n\n\t\t\tgf_set_progress(\"Appending\", nb_done, nb_samp);\n\t\t\tnb_done++;\n\t\t}\n\t\t/*scene description and text: compute last sample duration based on original media duration*/\n\t\tif (!use_ts_dur) {\n\t\t\tinsert_dts = gf_isom_get_media_duration(orig, i+1) - last_DTS;\n\t\t\tgf_isom_set_last_sample_duration(dest, dst_tk, (u32) insert_dts);\n\t\t}\n\n\t\tif (new_track && insert_dts) {\n\t\t\tu64 media_dur = gf_isom_get_media_duration(orig, i+1);\n\t\t\t/*convert from media time to track time*/\n\t\t\tDouble rescale = (Float) gf_isom_get_timescale(dest);\n\t\t\trescale /= (Float) gf_isom_get_media_timescale(dest, dst_tk);\n\t\t\t/*convert from orig to dst time scale*/\n\t\t\trescale *= ts_scale;\n\n\t\t\tgf_isom_set_edit_segment(dest, dst_tk, 0, (u64) (s64) (insert_dts*rescale), 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit_segment(dest, dst_tk, (u64) (s64) (insert_dts*rescale), (u64) (s64) (media_dur*rescale), 0, GF_ISOM_EDIT_NORMAL);\n\t\t} else if (merge_edits) {\n\t\t\t/*convert from media time to track time*/\n\t\t\tDouble rescale = (Float) gf_isom_get_timescale(dest);\n\t\t\trescale /= (Float) gf_isom_get_media_timescale(dest, dst_tk);\n\t\t\t/*convert from orig to dst time scale*/\n\t\t\trescale *= ts_scale;\n\n\t\t\t/*get the first edit normal mode and add the new track dur*/\n\t\t\tfor (j=nb_edits; j>0; j--) {\n\t\t\t\tu64 editTime, segmentDuration, mediaTime;\n\t\t\t\tu8 editMode;\n\t\t\t\tgf_isom_get_edit_segment(dest, dst_tk, j, &editTime, &segmentDuration, &mediaTime, &editMode);\n\n\t\t\t\tif (editMode==GF_ISOM_EDIT_NORMAL) {\n\t\t\t\t\tDouble prev_dur = (Double) (s64) dest_track_dur_before_cat;\n\t\t\t\t\tDouble dur = (Double) (s64) gf_isom_get_media_duration(orig, i+1);\n\n\t\t\t\t\tdur *= rescale;\n\t\t\t\t\tprev_dur *= rescale;\n\n\t\t\t\t\t/*safety test: some files have broken edit lists. If no more than 2 entries, check that the segment duration\n\t\t\t\t\tis less or equal to the movie duration*/\n\t\t\t\t\tif (prev_dur < segmentDuration) {\n\t\t\t\t\t\tfprintf(stderr, \"Warning: suspicious edit list entry found: duration %g sec but longest track duration before cat is %g - fixing it\\n\", (Double) (s64) segmentDuration/1000.0, prev_dur/1000);\n\t\t\t\t\t\tsegmentDuration = (u64) (s64) ( (Double) (s64) (dest_track_dur_before_cat - mediaTime) * rescale );\n\t\t\t\t\t}\n\n\t\t\t\t\tsegmentDuration += (u64) (s64) dur;\n\t\t\t\t\tgf_isom_modify_edit_segment(dest, dst_tk, j, segmentDuration, mediaTime, editMode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tu64 editTime, segmentDuration, mediaTime, edit_offset;\n\t\t\tDouble t;\n\t\t\tu8 editMode;\n\t\t\tu32 j, count;\n\n\t\t\tcount = gf_isom_get_edit_segment_count(dest, dst_tk);\n\t\t\tif (count) {\n\t\t\t\te = gf_isom_get_edit_segment(dest, dst_tk, count, &editTime, &segmentDuration, &mediaTime, &editMode);\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error: edit segment error on destination track %u could not be retrieved.\\n\", dst_tk);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else if (gf_isom_get_edit_segment_count(orig, i+1)) {\n\t\t\t\t/*fake empty edit segment*/\n\t\t\t\t/*convert from media time to track time*/\n\t\t\t\tDouble rescale = (Float) gf_isom_get_timescale(dest);\n\t\t\t\trescale /= (Float) gf_isom_get_media_timescale(dest, dst_tk);\n\t\t\t\tsegmentDuration = (u64) (dest_track_dur_before_cat * rescale);\n\t\t\t\teditTime = 0;\n\t\t\t\tmediaTime = 0;\n\t\t\t\tgf_isom_set_edit_segment(dest, dst_tk, editTime, segmentDuration, mediaTime, GF_ISOM_EDIT_NORMAL);\n\t\t\t} else {\n\t\t\t\teditTime = 0;\n\t\t\t\tsegmentDuration = 0;\n\t\t\t}\n\n\t\t\t/*convert to dst time scale*/\n\t\t\tts_scale = (Float) gf_isom_get_timescale(dest);\n\t\t\tts_scale /= (Float) gf_isom_get_timescale(orig);\n\n\t\t\tedit_offset = editTime + segmentDuration;\n\t\t\tcount = gf_isom_get_edit_segment_count(orig, i+1);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tgf_isom_get_edit_segment(orig, i+1, j+1, &editTime, &segmentDuration, &mediaTime, &editMode);\n\t\t\t\tt = (Double) (s64) editTime;\n\t\t\t\tt *= ts_scale;\n\t\t\t\tt += (s64) edit_offset;\n\t\t\t\teditTime = (s64) t;\n\t\t\t\tt = (Double) (s64) segmentDuration;\n\t\t\t\tt *= ts_scale;\n\t\t\t\tsegmentDuration = (s64) t;\n\t\t\t\tt = (Double) (s64) mediaTime;\n\t\t\t\tt *= ts_scale;\n\t\t\t\tt+= (s64) dest_track_dur_before_cat;\n\t\t\t\tmediaTime = (s64) t;\n\t\t\t\tif ((editMode == GF_ISOM_EDIT_EMPTY) && (mediaTime > 0)) {\n\t\t\t\t\teditMode = GF_ISOM_EDIT_NORMAL;\n\t\t\t\t}\n\t\t\t\tgf_isom_set_edit_segment(dest, dst_tk, editTime, segmentDuration, mediaTime, editMode);\n\t\t\t}\n\t\t}\n\n\t}\n\tgf_set_progress(\"Appending\", nb_samp, nb_samp);\n\n\t/*check chapters*/\n\tfor (i=0; i<gf_isom_get_chapter_count(orig, 0); i++) {\n\t\tchar *name;\n\t\tDouble c_time;\n\t\tu64 chap_time;\n\t\tgf_isom_get_chapter(orig, 0, i+1, &chap_time, (const char **) &name);\n\t\tc_time = (Double) (s64) chap_time;\n\t\tc_time /= 1000;\n\t\tc_time += dest_orig_dur;\n\n\t\t/*check last file chapter*/\n\t\tif (!i && gf_isom_get_chapter_count(dest, 0)) {\n\t\t\tconst char *last_name;\n\t\t\tu64 last_chap_time;\n\t\t\tgf_isom_get_chapter(dest, 0, gf_isom_get_chapter_count(dest, 0), &last_chap_time, &last_name);\n\t\t\t/*last and first chapters are the same, don't duplicate*/\n\t\t\tif (last_name && name && !stricmp(last_name, name)) continue;\n\t\t}\n\n\t\tchap_time = (u64) (c_time*1000);\n\t\tgf_isom_add_chapter(dest, 0, chap_time, name);\n\t}\n\n\nerr_exit:\n\tgf_isom_delete(orig);\n\treturn e;\n}\n\ntypedef struct\n{\n\tchar szPath[GF_MAX_PATH];\n\tchar szRad1[1024], szRad2[1024], szOpt[200];\n\tGF_ISOFile *dest;\n\tu32 import_flags;\n\tDouble force_fps;\n\tu32 frames_per_sample;\n\tchar *tmp_dir;\n\tBool force_cat, align_timelines, allow_add_in_command;\n} CATEnum;\n\nBool cat_enumerate(void *cbk, char *szName, char *szPath, GF_FileEnumInfo *file_info)\n{\n\tGF_Err e;\n\tu32 len_rad1;\n\tchar szFileName[GF_MAX_PATH];\n\tCATEnum *cat_enum = (CATEnum *)cbk;\n\tlen_rad1 = (u32) strlen(cat_enum->szRad1);\n\tif (strnicmp(szName, cat_enum->szRad1, len_rad1)) return 0;\n\tif (strlen(cat_enum->szRad2) && !strstr(szName + len_rad1, cat_enum->szRad2) ) return 0;\n\n\tstrcpy(szFileName, szName);\n\tstrcat(szFileName, cat_enum->szOpt);\n\n\te = cat_isomedia_file(cat_enum->dest, szFileName, cat_enum->import_flags, cat_enum->force_fps, cat_enum->frames_per_sample, cat_enum->tmp_dir, cat_enum->force_cat, cat_enum->align_timelines, cat_enum->allow_add_in_command);\n\tif (e) return 1;\n\treturn 0;\n}\n\nGF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)\n{\n\tCATEnum cat_enum;\n\tchar *sep;\n\n\tcat_enum.dest = dest;\n\tcat_enum.import_flags = import_flags;\n\tcat_enum.force_fps = force_fps;\n\tcat_enum.frames_per_sample = frames_per_sample;\n\tcat_enum.tmp_dir = tmp_dir;\n\tcat_enum.force_cat = force_cat;\n\tcat_enum.align_timelines = align_timelines;\n\tcat_enum.allow_add_in_command = allow_add_in_command;\n\n\tif (strlen(fileName) >= sizeof(cat_enum.szPath)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", fileName));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tstrcpy(cat_enum.szPath, fileName);\n\tsep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);\n\tif (!sep) sep = strrchr(cat_enum.szPath, '/');\n\tif (!sep) {\n\t\tstrcpy(cat_enum.szPath, \".\");\n\t\tif (strlen(fileName) >= sizeof(cat_enum.szRad1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", fileName));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tstrcpy(cat_enum.szRad1, fileName);\n\t} else {\n\t\tif (strlen(sep + 1) >= sizeof(cat_enum.szRad1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", (sep + 1)));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tstrcpy(cat_enum.szRad1, sep+1);\n\t\tsep[0] = 0;\n\t}\n\tsep = strchr(cat_enum.szRad1, '*');\n\tif (strlen(sep + 1) >= sizeof(cat_enum.szRad2)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"File name %s is too long.\\n\", (sep + 1)));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tstrcpy(cat_enum.szRad2, sep+1);\n\tsep[0] = 0;\n\tsep = strchr(cat_enum.szRad2, '%');\n\tif (!sep) sep = strchr(cat_enum.szRad2, '#');\n\tif (!sep) sep = strchr(cat_enum.szRad2, ':');\n\tstrcpy(cat_enum.szOpt, \"\");\n\tif (sep) {\n\t\tif (strlen(sep) >= sizeof(cat_enum.szOpt)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Invalid option: %s.\\n\", sep));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tstrcpy(cat_enum.szOpt, sep);\n\t\tsep[0] = 0;\n\t}\n\treturn gf_enum_directory(cat_enum.szPath, 0, cat_enumerate, &cat_enum, NULL);\n}\n\n\n#ifndef GPAC_DISABLE_SCENE_ENCODER\n/*\n\t\tMPEG-4 encoding\n*/\n\nGF_Err EncodeFile(char *in, GF_ISOFile *mp4, GF_SMEncodeOptions *opts, FILE *logs)\n{\n#ifdef GPAC_DISABLE_SMGR\n\treturn GF_NOT_SUPPORTED;\n#else\n\tGF_Err e;\n\tGF_SceneLoader load;\n\tGF_SceneManager *ctx;\n\tGF_SceneGraph *sg;\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tGF_StatManager *statsman = NULL;\n#endif\n\n\tsg = gf_sg_new();\n\tctx = gf_sm_new(sg);\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = in;\n\tload.ctx = ctx;\n\tload.swf_import_flags = swf_flags;\n\tload.swf_flatten_limit = swf_flatten_angle;\n\t/*since we're encoding we must get MPEG4 nodes only*/\n\tload.flags = GF_SM_LOAD_MPEG4_STRICT;\n\te = gf_sm_load_init(&load);\n\tif (e<0) {\n\t\tgf_sm_load_done(&load);\n\t\tfprintf(stderr, \"Cannot load context %s - %s\\n\", in, gf_error_to_string(e));\n\t\tgoto err_exit;\n\t}\n\te = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tif (opts->auto_quant) {\n\t\tfprintf(stderr, \"Analysing Scene for Automatic Quantization\\n\");\n\t\tstatsman = gf_sm_stats_new();\n\t\te = gf_sm_stats_for_scene(statsman, ctx);\n\t\tif (!e) {\n\t\t\tGF_SceneStatistics *stats = gf_sm_stats_get(statsman);\n\t\t\t/*LASeR*/\n\t\t\tif (opts->auto_quant==1) {\n\t\t\t\tif (opts->resolution > (s32)stats->frac_res_2d) {\n\t\t\t\t\tfprintf(stderr, \" Given resolution %d is (unnecessarily) too high, using %d instead.\\n\", opts->resolution, stats->frac_res_2d);\n\t\t\t\t\topts->resolution = stats->frac_res_2d;\n\t\t\t\t} else if (stats->int_res_2d + opts->resolution <= 0) {\n\t\t\t\t\tfprintf(stderr, \" Given resolution %d is too low, using %d instead.\\n\", opts->resolution, stats->int_res_2d - 1);\n\t\t\t\t\topts->resolution = 1 - stats->int_res_2d;\n\t\t\t\t}\n\t\t\t\topts->coord_bits = stats->int_res_2d + opts->resolution;\n\t\t\t\tfprintf(stderr, \" Coordinates & Lengths encoded using \");\n\t\t\t\tif (opts->resolution < 0) fprintf(stderr, \"only the %d most significant bits (of %d).\\n\", opts->coord_bits, stats->int_res_2d);\n\t\t\t\telse fprintf(stderr, \"a %d.%d representation\\n\", stats->int_res_2d, opts->resolution);\n\n\t\t\t\tfprintf(stderr, \" Matrix Scale & Skew Coefficients \");\n\t\t\t\tif (opts->coord_bits - 8 < stats->scale_int_res_2d) {\n\t\t\t\t\topts->scale_bits = stats->scale_int_res_2d - opts->coord_bits + 8;\n\t\t\t\t\tfprintf(stderr, \"encoded using a %d.8 representation\\n\", stats->scale_int_res_2d);\n\t\t\t\t} else  {\n\t\t\t\t\topts->scale_bits = 0;\n\t\t\t\t\tfprintf(stderr, \"encoded using a %d.8 representation\\n\", opts->coord_bits - 8);\n\t\t\t\t}\n\t\t\t}\n#ifndef GPAC_DISABLE_VRML\n\t\t\t/*BIFS*/\n\t\t\telse if (stats->base_layer) {\n\t\t\t\tGF_AUContext *au;\n\t\t\t\tGF_CommandField *inf;\n\t\t\t\tM_QuantizationParameter *qp;\n\t\t\t\tGF_Command *com = gf_sg_command_new(ctx->scene_graph, GF_SG_GLOBAL_QUANTIZER);\n\t\t\t\tqp = (M_QuantizationParameter *) gf_node_new(ctx->scene_graph, TAG_MPEG4_QuantizationParameter);\n\n\t\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\t\tinf->new_node = (GF_Node *)qp;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\t\tgf_node_register(inf->new_node, NULL);\n\t\t\t\tau = gf_list_get(stats->base_layer->AUs, 0);\n\t\t\t\tgf_list_insert(au->commands, com, 0);\n\t\t\t\tqp->useEfficientCoding = 1;\n\t\t\t\tqp->textureCoordinateQuant = 0;\n\t\t\t\tif ((stats->count_2f+stats->count_2d) && opts->resolution) {\n\t\t\t\t\tqp->position2DMin = stats->min_2d;\n\t\t\t\t\tqp->position2DMax = stats->max_2d;\n\t\t\t\t\tqp->position2DNbBits = opts->resolution;\n\t\t\t\t\tqp->position2DQuant = 1;\n\t\t\t\t}\n\t\t\t\tif ((stats->count_3f+stats->count_3d) &&  opts->resolution) {\n\t\t\t\t\tqp->position3DMin = stats->min_3d;\n\t\t\t\t\tqp->position3DMax = stats->max_3d;\n\t\t\t\t\tqp->position3DQuant = opts->resolution;\n\t\t\t\t\tqp->position3DQuant = 1;\n\t\t\t\t\tqp->textureCoordinateQuant = 1;\n\t\t\t\t}\n\t\t\t\t//float quantif is disabled since 2008, check if we want to re-enable it\n#if 0\n\t\t\t\tif (stats->count_float && opts->resolution) {\n\t\t\t\t\tqp->scaleMin = stats->min_fixed;\n\t\t\t\t\tqp->scaleMax = stats->max_fixed;\n\t\t\t\t\tqp->scaleNbBits = 2*opts->resolution;\n\t\t\t\t\tqp->scaleQuant = 1;\n\t\t\t\t}\n#endif\n\t\t\t}\n#endif\n\t\t}\n\t}\n#endif /*GPAC_DISABLE_SCENE_STATS*/\n\n\tif (e<0) {\n\t\tfprintf(stderr, \"Error loading file %s\\n\", gf_error_to_string(e));\n\t\tgoto err_exit;\n\t} else {\n\t\tgf_log_cbk prev_logs = NULL;\n\t\tif (logs) {\n\t\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_DEBUG);\n\t\t\tprev_logs = gf_log_set_callback(logs, scene_coding_log);\n\t\t}\n\t\topts->src_url = in;\n\t\te = gf_sm_encode_to_file(ctx, mp4, opts);\n\t\tif (logs) {\n\t\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_ERROR);\n\t\t\tgf_log_set_callback(NULL, prev_logs);\n\t\t}\n\t}\n\n\tgf_isom_set_brand_info(mp4, GF_ISOM_BRAND_MP42, 1);\n\tgf_isom_modify_alternate_brand(mp4, GF_ISOM_BRAND_ISOM, 1);\n\nerr_exit:\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tif (statsman) gf_sm_stats_del(statsman);\n#endif\n\tgf_sm_del(ctx);\n\tgf_sg_del(sg);\n\treturn e;\n\n#endif /*GPAC_DISABLE_SMGR*/\n}\n#endif /*GPAC_DISABLE_SCENE_ENCODER*/\n\n\n#ifndef GPAC_DISABLE_BIFS_ENC\n/*\n\t\tMPEG-4 chunk encoding\n*/\n\nstatic u32 GetNbBits(u32 MaxVal)\n{\n\tu32 k=0;\n\twhile ((s32) MaxVal > ((1<<k)-1) ) k+=1;\n\treturn k;\n}\n\n#ifndef GPAC_DISABLE_SMGR\nGF_Err EncodeBIFSChunk(GF_SceneManager *ctx, char *bifsOutputFile, GF_Err (*AUCallback)(GF_ISOSample *))\n{\n\tGF_Err\t\t\te;\n\tchar *data;\n\tu32 data_len;\n\tGF_BifsEncoder *bifsenc;\n\tGF_InitialObjectDescriptor *iod;\n\tu32 i, j, count;\n\tGF_StreamContext *sc;\n\tGF_ESD *esd;\n\tBool encode_names, delete_bcfg;\n\tGF_BIFSConfig *bcfg;\n\tGF_AUContext\t\t*au;\n\tchar szRad[GF_MAX_PATH], *ext;\n\tchar szName[1024];\n\tFILE *f;\n\n\tstrcpy(szRad, bifsOutputFile);\n\text = strrchr(szRad, '.');\n\tif (ext) ext[0] = 0;\n\n\n\t/* step3: encoding all AUs in ctx->streams starting at AU index 1 (0 is SceneReplace from previous context) */\n\tbifsenc = gf_bifs_encoder_new(ctx->scene_graph);\n\te = GF_OK;\n\n\tiod = (GF_InitialObjectDescriptor *) ctx->root_od;\n\t/*if no iod check we only have one bifs*/\n\tif (!iod) {\n\t\tcount = 0;\n\t\tfor (i=0; i<gf_list_count(ctx->streams); i++) {\n\t\t\tsc = gf_list_get(ctx->streams, i);\n\t\t\tif (sc->streamType == GF_STREAM_OD) count++;\n\t\t}\n\t\tif (!iod && count>1) return GF_NOT_SUPPORTED;\n\t}\n\n\tcount = gf_list_count(ctx->streams);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nbb;\n\t\tGF_StreamContext *sc = gf_list_get(ctx->streams, i);\n\t\tesd = NULL;\n\t\tif (sc->streamType != GF_STREAM_SCENE) continue;\n\n\t\tesd = NULL;\n\t\tif (iod) {\n\t\t\tfor (j=0; j<gf_list_count(iod->ESDescriptors); j++) {\n\t\t\t\tesd = gf_list_get(iod->ESDescriptors, j);\n\t\t\t\tif (esd->decoderConfig && esd->decoderConfig->streamType == GF_STREAM_SCENE) {\n\t\t\t\t\tif (!sc->ESID) sc->ESID = esd->ESID;\n\t\t\t\t\tif (sc->ESID == esd->ESID) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*special BIFS direct import from NHNT*/\n\t\t\t\telse if (gf_list_count(iod->ESDescriptors)==1) {\n\t\t\t\t\tsc->ESID = esd->ESID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tesd = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (!esd) {\n\t\t\tesd = gf_odf_desc_esd_new(2);\n\t\t\tif (!esd) return GF_OUT_OF_MEM;\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd->decoderConfig->decoderSpecificInfo);\n\t\t\tesd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t\tesd->ESID = sc->ESID;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t}\n\t\tif (!esd->decoderConfig) return GF_OUT_OF_MEM;\n\n\t\t/*should NOT happen (means inputctx is not properly setup)*/\n\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n\t\t\tbcfg = (GF_BIFSConfig*)gf_odf_desc_new(GF_ODF_BIFS_CFG_TAG);\n\t\t\tdelete_bcfg = 1;\n\t\t}\n\t\t/*regular retrieve from ctx*/\n\t\telse if (esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_BIFS_CFG_TAG) {\n\t\t\tbcfg = (GF_BIFSConfig *)esd->decoderConfig->decoderSpecificInfo;\n\t\t\tdelete_bcfg = 0;\n\t\t}\n\t\t/*should not happen either (unless loading from MP4 in which case BIFSc is not decoded)*/\n\t\telse {\n\t\t\tbcfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n\t\t\tdelete_bcfg = 1;\n\t\t}\n\t\t/*NO CHANGE TO BIFSC otherwise the generated update will not match the input context*/\n\t\tnbb = GetNbBits(ctx->max_node_id);\n\t\tif (!bcfg->nodeIDbits) bcfg->nodeIDbits=nbb;\n\t\tif (bcfg->nodeIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.NodeIDBits TOO SMALL\\n\");\n\n\t\tnbb = GetNbBits(ctx->max_route_id);\n\t\tif (!bcfg->routeIDbits) bcfg->routeIDbits = nbb;\n\t\tif (bcfg->routeIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.RouteIDBits TOO SMALL\\n\");\n\n\t\tnbb = GetNbBits(ctx->max_proto_id);\n\t\tif (!bcfg->protoIDbits) bcfg->protoIDbits=nbb;\n\t\tif (bcfg->protoIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.ProtoIDBits TOO SMALL\\n\");\n\n\t\t/*this is the real pb, not stored in cfg or file level, set at EACH replaceScene*/\n\t\tencode_names = 0;\n\n\t\t/* The BIFS Config that is passed here should be the BIFSConfig from the IOD */\n\t\tgf_bifs_encoder_new_stream(bifsenc, sc->ESID, bcfg, encode_names, 0);\n\t\tif (delete_bcfg) gf_odf_desc_del((GF_Descriptor *)bcfg);\n\n\t\t/*setup MP4 track*/\n\t\tif (!esd->slConfig) esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\tif (sc->timeScale) esd->slConfig->timestampResolution = sc->timeScale;\n\t\tif (!esd->slConfig->timestampResolution) esd->slConfig->timestampResolution = 1000;\n\t\tesd->ESID = sc->ESID;\n\t\tgf_bifs_encoder_get_config(bifsenc, sc->ESID, &data, &data_len);\n\n\t\tif (esd->decoderConfig->decoderSpecificInfo) gf_odf_desc_del((GF_Descriptor *) esd->decoderConfig->decoderSpecificInfo);\n\t\tesd->decoderConfig->decoderSpecificInfo = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\t\tesd->decoderConfig->decoderSpecificInfo->data = data;\n\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = data_len;\n\t\tesd->decoderConfig->objectTypeIndication = gf_bifs_encoder_get_version(bifsenc, sc->ESID);\n\n\t\tfor (j=1; j<gf_list_count(sc->AUs); j++) {\n\t\t\tchar *data;\n\t\t\tu32 data_len;\n\t\t\tau = gf_list_get(sc->AUs, j);\n\t\t\te = gf_bifs_encode_au(bifsenc, sc->ESID, au->commands, &data, &data_len);\n\t\t\tif (data) {\n\t\t\t\tsprintf(szName, \"%s%02d.bifs\", szRad, j);\n\t\t\t\tf = gf_fopen(szName, \"wb\");\n\t\t\t\tgf_fwrite(data, data_len, 1, f);\n\t\t\t\tgf_fclose(f);\n\t\t\t\tgf_free(data);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bifs_encoder_del(bifsenc);\n\treturn e;\n}\n#endif /*GPAC_DISABLE_SMGR*/\n\n\n#endif /*GPAC_DISABLE_BIFS_ENC*/\n\n/**\n * \\param chunkFile BT chunk to be encoded\n * \\param bifs output file name for the BIFS data\n * \\param inputContext initial BT upon which the chunk is based (shall not be NULL)\n * \\param outputContext: file name to dump the context after applying the new chunk to the input context\n                   can be NULL, without .bt\n * \\param tmpdir can be NULL\n */\nGF_Err EncodeFileChunk(char *chunkFile, char *bifs, char *inputContext, char *outputContext, const char *tmpdir)\n{\n#if defined(GPAC_DISABLE_SMGR) || defined(GPAC_DISABLE_BIFS_ENC) || defined(GPAC_DISABLE_SCENE_ENCODER) || defined (GPAC_DISABLE_SCENE_DUMP)\n\tfprintf(stderr, \"BIFS encoding is not supported in this build of GPAC\\n\");\n\treturn GF_NOT_SUPPORTED;\n#else\n\tGF_Err e;\n\tGF_SceneGraph *sg;\n\tGF_SceneManager\t*ctx;\n\tGF_SceneLoader load;\n\n\t/*Step 1: create context and load input*/\n\tsg = gf_sg_new();\n\tctx = gf_sm_new(sg);\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = inputContext;\n\tload.ctx = ctx;\n\t/*since we're encoding we must get MPEG4 nodes only*/\n\tload.flags = GF_SM_LOAD_MPEG4_STRICT;\n\te = gf_sm_load_init(&load);\n\tif (!e) e = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\tif (e) {\n\t\tfprintf(stderr, \"Cannot load context %s - %s\\n\", inputContext, gf_error_to_string(e));\n\t\tgoto exit;\n\t}\n\n\t/* Step 2: make sure we have only ONE RAP for each stream*/\n\te = gf_sm_aggregate(ctx, 0);\n\tif (e) goto exit;\n\n\t/*Step 3: loading the chunk into the context*/\n\tmemset(&load, 0, sizeof(GF_SceneLoader));\n\tload.fileName = chunkFile;\n\tload.ctx = ctx;\n\tload.flags = GF_SM_LOAD_MPEG4_STRICT | GF_SM_LOAD_CONTEXT_READY;\n\te = gf_sm_load_init(&load);\n\tif (!e) e = gf_sm_load_run(&load);\n\tgf_sm_load_done(&load);\n\tif (e) {\n\t\tfprintf(stderr, \"Cannot load chunk context %s - %s\\n\", chunkFile, gf_error_to_string(e));\n\t\tgoto exit;\n\t}\n\tfprintf(stderr, \"Context and chunks loaded\\n\");\n\n\t/* Assumes that the first AU contains only one command a SceneReplace and\n\t   that is not part of the current chunk */\n\t/* Last argument is a callback to pass the encoded AUs: not needed here\n\t   Saving is not handled correctly */\n\te = EncodeBIFSChunk(ctx, bifs, NULL);\n\tif (e) goto exit;\n\n\n\tif (outputContext) {\n\t\tu32 d_mode, do_enc;\n\t\tchar szF[GF_MAX_PATH], *ext;\n\n\t\t/*make random access for storage*/\n\t\te = gf_sm_aggregate(ctx, 0);\n\t\tif (e) goto exit;\n\n\t\t/*check if we dump to BT, XMT or encode to MP4*/\n\t\tstrcpy(szF, outputContext);\n\t\text = strrchr(szF, '.');\n\t\td_mode = GF_SM_DUMP_BT;\n\t\tdo_enc = 0;\n\t\tif (ext) {\n\t\t\tif (!stricmp(ext, \".xmt\") || !stricmp(ext, \".xmta\")) d_mode = GF_SM_DUMP_XMTA;\n\t\t\telse if (!stricmp(ext, \".mp4\")) do_enc = 1;\n\t\t\text[0] = 0;\n\t\t}\n\n\t\tif (do_enc) {\n\t\t\tGF_ISOFile *mp4;\n\t\t\tstrcat(szF, \".mp4\");\n\t\t\tmp4 = gf_isom_open(szF, GF_ISOM_WRITE_EDIT, tmpdir);\n\t\t\te = gf_sm_encode_to_file(ctx, mp4, NULL);\n\t\t\tif (e) gf_isom_delete(mp4);\n\t\t\telse gf_isom_close(mp4);\n\t\t}\n\t\telse e = gf_sm_dump(ctx, szF, GF_FALSE, d_mode);\n\t}\n\nexit:\n\tif (ctx) {\n\t\tsg = ctx->scene_graph;\n\t\tgf_sm_del(ctx);\n\t\tgf_sg_del(sg);\n\t}\n\n\treturn e;\n\n#endif /*defined(GPAC_DISABLE_BIFS_ENC) || defined(GPAC_DISABLE_SCENE_ENCODER) || defined (GPAC_DISABLE_SCENE_DUMP)*/\n\n}\n\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\nvoid sax_node_start(void *sax_cbck, const char *node_name, const char *name_space, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tchar szCheck[100];\n\tGF_List *imports = sax_cbck;\n\tGF_XMLAttribute *att;\n\tu32 i=0;\n\n\t/*do not process hyperlinks*/\n\tif (!strcmp(node_name, \"a\") || !strcmp(node_name, \"Anchor\")) return;\n\n\tfor (i=0; i<nb_attributes; i++) {\n\t\tatt = (GF_XMLAttribute *) &attributes[i];\n\t\tif (stricmp(att->name, \"xlink:href\") && stricmp(att->name, \"url\")) continue;\n\t\tif (att->value[0]=='#') continue;\n\t\tif (!strnicmp(att->value, \"od:\", 3)) continue;\n\t\tsprintf(szCheck, \"%d\", atoi(att->value));\n\t\tif (!strcmp(szCheck, att->value)) continue;\n\t\tgf_list_add(imports, gf_strdup(att->value) );\n\t}\n}\n\nstatic Bool wgt_enum_files(void *cbck, char *file_name, char *file_path, GF_FileEnumInfo *file_info)\n{\n\tWGTEnum *wgt = (WGTEnum *)cbck;\n\n\tif (!strcmp(wgt->root_file, file_path)) return 0;\n\t/*remove CVS stuff*/\n\tif (strstr(file_path, \".#\")) return 0;\n\tgf_list_add(wgt->imports, gf_strdup(file_path) );\n\treturn 0;\n}\nstatic Bool wgt_enum_dir(void *cbck, char *file_name, char *file_path, GF_FileEnumInfo *file_info)\n{\n\tif (!stricmp(file_name, \"cvs\") || !stricmp(file_name, \".svn\") || !stricmp(file_name, \".git\")) return 0;\n\tgf_enum_directory(file_path, 0, wgt_enum_files, cbck, NULL);\n\treturn gf_enum_directory(file_path, 1, wgt_enum_dir, cbck, NULL);\n}\n\nGF_ISOFile *package_file(char *file_name, char *fcc, const char *tmpdir, Bool make_wgt)\n{\n\tGF_ISOFile *file = NULL;\n\tGF_Err e;\n\tGF_SAXParser *sax;\n\tGF_List *imports;\n\tBool ascii;\n\tchar root_dir[GF_MAX_PATH];\n\tchar *isom_src = NULL;\n\tu32 i, count, mtype, skip_chars;\n\tchar *type;\n\n\ttype = gf_xml_get_root_type(file_name, &e);\n\tif (!type) {\n\t\tfprintf(stderr, \"Cannot process XML file %s: %s\\n\", file_name, gf_error_to_string(e) );\n\t\treturn NULL;\n\t}\n\tif (make_wgt) {\n\t\tif (strcmp(type, \"widget\")) {\n\t\t\tfprintf(stderr, \"XML Root type %s differs from \\\"widget\\\" \\n\", type);\n\t\t\tgf_free(type);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_free(type);\n\t\ttype = gf_strdup(\"application/mw-manifest+xml\");\n\t\tfcc = \"mwgt\";\n\t}\n\timports = gf_list_new();\n\n\n\troot_dir[0] = 0;\n\tif (make_wgt) {\n\t\tWGTEnum wgt;\n\t\tchar *sep = strrchr(file_name, '\\\\');\n\t\tif (!sep) sep = strrchr(file_name, '/');\n\t\tif (sep) {\n\t\t\tchar c = sep[1];\n\t\t\tsep[1]=0;\n\t\t\tstrcpy(root_dir, file_name);\n\t\t\tsep[1] = c;\n\t\t} else {\n\t\t\tstrcpy(root_dir, \"./\");\n\t\t}\n\t\twgt.dir = root_dir;\n\t\twgt.root_file = file_name;\n\t\twgt.imports = imports;\n\t\tgf_enum_directory(wgt.dir, 0, wgt_enum_files, &wgt, NULL);\n\t\tgf_enum_directory(wgt.dir, 1, wgt_enum_dir, &wgt, NULL);\n\t\tascii = 1;\n\t} else {\n\t\tsax = gf_xml_sax_new(sax_node_start, NULL, NULL, imports);\n\t\te = gf_xml_sax_parse_file(sax, file_name, NULL);\n\t\tascii = !gf_xml_sax_binary_file(sax);\n\t\tgf_xml_sax_del(sax);\n\t\tif (e<0) goto exit;\n\t\te = GF_OK;\n\t}\n\n\tif (fcc) {\n\t\tmtype = GF_4CC(fcc[0],fcc[1],fcc[2],fcc[3]);\n\t} else {\n\t\tmtype = 0;\n\t\tif (!stricmp(type, \"svg\")) mtype = ascii ? GF_META_TYPE_SVG : GF_META_TYPE_SVGZ;\n\t\telse if (!stricmp(type, \"smil\")) mtype = ascii ? GF_META_TYPE_SMIL : GF_META_TYPE_SMLZ;\n\t\telse if (!stricmp(type, \"x3d\")) mtype = ascii ? GF_META_TYPE_X3D  : GF_META_TYPE_X3DZ  ;\n\t\telse if (!stricmp(type, \"xmt-a\")) mtype = ascii ? GF_META_TYPE_XMTA : GF_META_TYPE_XMTZ;\n\t}\n\tif (!mtype) {\n\t\tfprintf(stderr, \"Missing 4CC code for meta name - please use ABCD:fileName\\n\");\n\t\te = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\n\tif (!make_wgt) {\n\t\tcount = gf_list_count(imports);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tchar *item = gf_list_get(imports, i);\n\n\t\t\tFILE *test = gf_fopen(item, \"rb\");\n\t\t\tif (!test) {\n\t\t\t\tgf_list_rem(imports, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tgf_free(item);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgf_fclose(test);\n\t\t\tif (gf_isom_probe_file(item)) {\n\t\t\t\tif (isom_src) {\n\t\t\t\t\tfprintf(stderr, \"Cannot package several IsoMedia files together\\n\");\n\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgf_list_rem(imports, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tisom_src = item;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (isom_src) {\n\t\tfile = gf_isom_open(isom_src, GF_ISOM_OPEN_EDIT, tmpdir);\n\t} else {\n\t\tfile = gf_isom_open(\"package\", GF_ISOM_WRITE_EDIT, tmpdir);\n\t}\n\n\te = gf_isom_set_meta_type(file, 1, 0, mtype);\n\tif (e) goto exit;\n\t/*add self ref*/\n\tif (isom_src) {\n\t\te = gf_isom_add_meta_item(file, 1, 0, 1, NULL, isom_src, 0, 0, NULL, NULL, NULL,  NULL, NULL);\n\t\tif (e) goto exit;\n\t}\n\te = gf_isom_set_meta_xml(file, 1, 0, file_name, !ascii);\n\tif (e) goto exit;\n\n\tskip_chars = (u32) strlen(root_dir);\n\tcount = gf_list_count(imports);\n\tfor (i=0; i<count; i++) {\n\t\tchar *ext, *mime, *encoding, *name = NULL;\n\t\tchar *item = gf_list_get(imports, i);\n\n\t\tname = gf_strdup(item + skip_chars);\n\n\t\tif (make_wgt) {\n\t\t\tchar *sep;\n\t\t\twhile (1) {\n\t\t\t\tsep = strchr(name, '\\\\');\n\t\t\t\tif (!sep) break;\n\t\t\t\tsep[0] = '/';\n\t\t\t}\n\t\t}\n\n\n\t\tmime = encoding = NULL;\n\t\text = strrchr(item, '.');\n\t\tif (!stricmp(ext, \".gz\")) ext = strrchr(ext-1, '.');\n\n\t\tif (!stricmp(ext, \".jpg\") || !stricmp(ext, \".jpeg\")) mime = \"image/jpeg\";\n\t\telse if (!stricmp(ext, \".png\")) mime = \"image/png\";\n\t\telse if (!stricmp(ext, \".svg\")) mime = \"image/svg+xml\";\n\t\telse if (!stricmp(ext, \".x3d\")) mime = \"model/x3d+xml\";\n\t\telse if (!stricmp(ext, \".xmt\")) mime = \"application/x-xmt\";\n\t\telse if (!stricmp(ext, \".js\")) {\n\t\t\tmime = \"application/javascript\";\n\t\t}\n\t\telse if (!stricmp(ext, \".svgz\") || !stricmp(ext, \".svg.gz\")) {\n\t\t\tmime = \"image/svg+xml\";\n\t\t\tencoding = \"binary-gzip\";\n\t\t}\n\t\telse if (!stricmp(ext, \".x3dz\") || !stricmp(ext, \".x3d.gz\")) {\n\t\t\tmime = \"model/x3d+xml\";\n\t\t\tencoding = \"binary-gzip\";\n\t\t}\n\t\telse if (!stricmp(ext, \".xmtz\") || !stricmp(ext, \".xmt.gz\")) {\n\t\t\tmime = \"application/x-xmt\";\n\t\t\tencoding = \"binary-gzip\";\n\t\t}\n\n\t\te = gf_isom_add_meta_item(file, 1, 0, 0, item, name, 0, GF_META_ITEM_TYPE_MIME, mime, encoding, NULL,  NULL, NULL);\n\t\tgf_free(name);\n\t\tif (e) goto exit;\n\t}\n\nexit:\n\twhile (gf_list_count(imports)) {\n\t\tchar *item = gf_list_last(imports);\n\t\tgf_list_rem_last(imports);\n\t\tgf_free(item);\n\t}\n\tgf_list_del(imports);\n\tif (isom_src) gf_free(isom_src);\n\tif (type) gf_free(type);\n\tif (e) {\n\t\tif (file) gf_isom_delete(file);\n\t\treturn NULL;\n\t}\n\treturn file;\n}\n#else\nGF_ISOFile *package_file(char *file_name, char *fcc, const char *tmpdir, Bool make_wgt)\n{\n\tfprintf(stderr, \"XML Not supported in this build of GPAC - cannot package file\\n\");\n\treturn NULL;\n}\n#endif //#ifndef GPAC_DISABLE_CORE_TOOLS\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / command-line client\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n/*includes both terminal and od browser*/\n#include <gpac/terminal.h>\n#include <gpac/term_info.h>\n#include <gpac/constants.h>\n#include <gpac/events.h>\n#include <gpac/media_tools.h>\n#include <gpac/options.h>\n#include <gpac/modules/service.h>\n#include <gpac/avparse.h>\n#include <gpac/network.h>\n#include <gpac/utf.h>\n#include <time.h>\n\n/*ISO 639 languages*/\n#include <gpac/iso639.h>\n\n//FIXME we need a plugin for playlists\n#include <gpac/internal/terminal_dev.h>\n\n\n#ifndef WIN32\n#include <dlfcn.h>\n#include <pwd.h>\n#include <unistd.h>\n#if defined(__DARWIN__) || defined(__APPLE__)\n#include <sys/types.h>\n#include <sys/stat.h>\n\nvoid carbon_init();\nvoid carbon_uninit();\n\n#endif\n\n#else\n#include <windows.h> /*for GetModuleFileName*/\n#endif\t//WIN32\n\n/*local prototypes*/\nvoid PrintWorldInfo(GF_Terminal *term);\nvoid ViewOD(GF_Terminal *term, u32 OD_ID, u32 number, const char *URL);\nvoid PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name);\n\nvoid ViewODs(GF_Terminal *term, Bool show_timing);\nvoid PrintGPACConfig();\n\nstatic u32 gui_mode = 0;\n\nstatic Bool restart = GF_FALSE;\nstatic Bool reload = GF_FALSE;\n\nBool no_prog = 0;\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n//we keep no decoder thread because of JS_GC deadlocks between threads ...\nstatic u32 threading_flags = GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_DECODER_THREAD;\n#define VK_MOD  GF_KEY_MOD_ALT\n#else\nstatic u32 threading_flags = 0;\n#define VK_MOD  GF_KEY_MOD_CTRL\n#endif\nstatic Bool no_audio = GF_FALSE;\nstatic Bool term_step = GF_FALSE;\nstatic Bool no_regulation = GF_FALSE;\nstatic u32 bench_mode = 0;\nstatic u32 bench_mode_start = 0;\nstatic u32 bench_buffer = 0;\nstatic Bool eos_seen = GF_FALSE;\nstatic Bool addon_visible = GF_TRUE;\nBool is_connected = GF_FALSE;\nBool startup_file = GF_FALSE;\nGF_User user;\nGF_Terminal *term;\nu64 Duration;\nGF_Err last_error = GF_OK;\nstatic Bool enable_add_ons = GF_TRUE;\nstatic Fixed playback_speed = FIX_ONE;\n\nstatic s32 request_next_playlist_item = GF_FALSE;\nFILE *playlist = NULL;\nstatic Bool readonly_playlist = GF_FALSE;\n\nstatic GF_Config *cfg_file;\nstatic u32 display_rti = 0;\nstatic Bool Run;\nstatic Bool CanSeek = GF_FALSE;\nstatic char the_url[GF_MAX_PATH];\nstatic char pl_path[GF_MAX_PATH];\nstatic Bool no_mime_check = GF_TRUE;\nstatic Bool be_quiet = GF_FALSE;\nstatic u64 log_time_start = 0;\nstatic Bool log_utc_time = GF_FALSE;\nstatic Bool loop_at_end = GF_FALSE;\nstatic u32 forced_width=0;\nstatic u32 forced_height=0;\n\n/*windowless options*/\nu32 align_mode = 0;\nu32 init_w = 0;\nu32 init_h = 0;\nu32 last_x, last_y;\nBool right_down = GF_FALSE;\n\nvoid dump_frame(GF_Terminal *term, char *rad_path, u32 dump_type, u32 frameNum);\n\nenum\n{\n\tDUMP_NONE = 0,\n\tDUMP_AVI = 1,\n\tDUMP_BMP = 2,\n\tDUMP_PNG = 3,\n\tDUMP_RAW = 4,\n\tDUMP_SHA1 = 5,\n\n\t//DuMP flags\n\tDUMP_DEPTH_ONLY = 1<<16,\n\tDUMP_RGB_DEPTH = 1<<17,\n\tDUMP_RGB_DEPTH_SHAPE = 1<<18\n};\n\nBool dump_file(char *the_url, char *out_url, u32 dump_mode, Double fps, u32 width, u32 height, Float scale, u32 *times, u32 nb_times);\n\n\nstatic Bool shell_visible = GF_TRUE;\nvoid hide_shell(u32 cmd_type)\n{\n#if defined(WIN32) && !defined(_WIN32_WCE)\n\ttypedef HWND (WINAPI *GetConsoleWindowT)(void);\n\tHMODULE hk32 = GetModuleHandle(\"kernel32.dll\");\n\tGetConsoleWindowT GetConsoleWindow = (GetConsoleWindowT ) GetProcAddress(hk32,\"GetConsoleWindow\");\n\tif (cmd_type==0) {\n\t\tShowWindow( GetConsoleWindow(), SW_SHOW);\n\t\tshell_visible = GF_TRUE;\n\t}\n\telse if (cmd_type==1) {\n\t\tShowWindow( GetConsoleWindow(), SW_HIDE);\n\t\tshell_visible = GF_FALSE;\n\t}\n\telse if (cmd_type==2) PostMessage(GetConsoleWindow(), WM_CLOSE, 0, 0);\n\n#endif\n}\n\n\nvoid send_open_url(const char *url)\n{\n\tGF_Event evt;\n\tmemset(&evt, 0, sizeof(GF_Event));\n\tevt.type = GF_EVENT_NAVIGATE;\n\tevt.navigate.to_url = url;\n\tgf_term_send_event(term, &evt);\n}\n\nvoid PrintUsage()\n{\n\tfprintf(stderr, \"Usage MP4Client [options] [filename]\\n\"\n\t        \"\\t-c fileName:    user-defined configuration file. Also works with -cfg\\n\"\n#ifdef GPAC_MEMORY_TRACKING\n            \"\\t-mem-track:  enables memory tracker\\n\"\n            \"\\t-mem-track-stack:  enables memory tracker with stack dumping\\n\"\n#endif\n\t        \"\\t-rti fileName:  logs run-time info (FPS, CPU, Mem usage) to file\\n\"\n\t        \"\\t-rtix fileName: same as -rti but driven by GPAC logs\\n\"\n\t        \"\\t-quiet:         removes script message, buffering and downloading status\\n\"\n\t        \"\\t-strict-error:  exit when the player reports its first error\\n\"\n\t        \"\\t-opt option:    Overrides an option in the configuration file. String format is section:key=value. \\n\"\n\t        \"\\t                  \\\"section:key=null\\\" removes the key\\n\"\n\t        \"\\t                  \\\"section:*=null\\\" removes the section\\n\"\n\t        \"\\t-conf option:   Same as -opt but does not start player.\\n\"\n\t        \"\\t-log-file file: sets output log file. Also works with -lf\\n\"\n\t        \"\\t-logs log_args: sets log tools and levels, formatted as a ':'-separated list of toolX[:toolZ]@levelX\\n\"\n\t        \"\\t                 levelX can be one of:\\n\"\n\t        \"\\t        \\\"quiet\\\"      : skip logs\\n\"\n\t        \"\\t        \\\"error\\\"      : logs only error messages\\n\"\n\t        \"\\t        \\\"warning\\\"    : logs error+warning messages\\n\"\n\t        \"\\t        \\\"info\\\"       : logs error+warning+info messages\\n\"\n\t        \"\\t        \\\"debug\\\"      : logs all messages\\n\"\n\t        \"\\t                 toolX can be one of:\\n\"\n\t        \"\\t        \\\"core\\\"       : libgpac core\\n\"\n\t        \"\\t        \\\"coding\\\"     : bitstream formats (audio, video, scene)\\n\"\n\t        \"\\t        \\\"container\\\"  : container formats (ISO File, MPEG-2 TS, AVI, ...)\\n\"\n\t        \"\\t        \\\"network\\\"    : network data exept RTP trafic\\n\"\n\t        \"\\t        \\\"rtp\\\"        : rtp trafic\\n\"\n\t        \"\\t        \\\"author\\\"     : authoring tools (hint, import, export)\\n\"\n\t        \"\\t        \\\"sync\\\"       : terminal sync layer\\n\"\n\t        \"\\t        \\\"codec\\\"      : terminal codec messages\\n\"\n\t        \"\\t        \\\"parser\\\"     : scene parsers (svg, xmt, bt) and other\\n\"\n\t        \"\\t        \\\"media\\\"      : terminal media object management\\n\"\n\t        \"\\t        \\\"scene\\\"      : scene graph and scene manager\\n\"\n\t        \"\\t        \\\"script\\\"     : scripting engine messages\\n\"\n\t        \"\\t        \\\"interact\\\"   : interaction engine (events, scripts, etc)\\n\"\n\t        \"\\t        \\\"smil\\\"       : SMIL timing engine\\n\"\n\t        \"\\t        \\\"compose\\\"    : composition engine (2D, 3D, etc)\\n\"\n\t        \"\\t        \\\"mmio\\\"       : Audio/Video HW I/O management\\n\"\n\t        \"\\t        \\\"rti\\\"        : various run-time stats\\n\"\n\t        \"\\t        \\\"cache\\\"      : HTTP cache subsystem\\n\"\n\t        \"\\t        \\\"audio\\\"      : Audio renderer and mixers\\n\"\n#ifdef GPAC_MEMORY_TRACKING\n\t        \"\\t        \\\"mem\\\"        : GPAC memory tracker\\n\"\n#endif\n#ifndef GPAC_DISABLE_DASH_CLIENT\n\t        \"\\t        \\\"dash\\\"       : HTTP streaming logs\\n\"\n#endif\n\t        \"\\t        \\\"module\\\"     : GPAC modules debugging\\n\"\n\t        \"\\t        \\\"mutex\\\"      : mutex\\n\"\n\t        \"\\t        \\\"all\\\"        : all tools logged - other tools can be specified afterwards.\\n\"\n\t        \"\\tThe special value \\\"ncl\\\" disables color logs.\\n\"\n\t        \"\\n\"\n\t        \"\\t-log-clock or -lc      : logs time in micro sec since start time of GPAC before each log line.\\n\"\n\t        \"\\t-log-utc or -lu        : logs UTC time in ms before each log line.\\n\"\n\t        \"\\t-ifce IPIFCE           : Sets default Multicast interface\\n\"\n\t        \"\\t-size WxH:      specifies visual size (default: scene size)\\n\"\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t        \"\\t-thread:        enables thread usage for terminal and compositor \\n\"\n#else\n\t        \"\\t-no-thread:     disables thread usage (except for audio)\\n\"\n#endif\n\t        \"\\t-no-cthread:    disables compositor thread (iOS and Android mode)\\n\"\n\t        \"\\t-no-audio:      disables audio \\n\"\n\t        \"\\t-no-wnd:        uses windowless mode (Win32 only)\\n\"\n\t        \"\\t-no-back:       uses transparent background for output window when no background is specified (Win32 only)\\n\"\n\t        \"\\t-align vh:      specifies v and h alignment for windowless mode\\n\"\n\t        \"\\t                 possible v values: t(op), m(iddle), b(ottom)\\n\"\n\t        \"\\t                 possible h values: l(eft), m(iddle), r(ight)\\n\"\n\t        \"\\t                 default alignment is top-left\\n\"\n\t        \"\\t                 default alignment is top-left\\n\"\n\t        \"\\t-pause:         pauses at first frame\\n\"\n\t        \"\\t-play-from T:   starts from T seconds in media\\n\"\n\t        \"\\t-speed S:       starts with speed S\\n\"\n\t        \"\\t-loop:          loops presentation\\n\"\n\t        \"\\t-no-regulation: disables framerate regulation\\n\"\n\t        \"\\t-bench:         disable a/v output and bench source decoding (as fast as possible)\\n\"\n\t        \"\\t-vbench:        disable audio output, video sync bench source decoding/display (as fast as possible)\\n\"\n\t        \"\\t-sbench:        disable all decoders and bench systems layer (as fast as possible)\\n\"\n\t        \"\\t-fs:            starts in fullscreen mode\\n\"\n\t        \"\\t-views v1:.:vN: creates an auto-stereo scene of N views. vN can be any type of URL supported by GPAC.\\n\"\n\t        \"\\t                 in this mode, URL argument of GPAC is ignored, GUI as well.\\n\"\n\t        \"\\t                 this is equivalent as using views://v1:.:N as an URL.\\n\"\n\t        \"\\t-mosaic v1:.:vN: creates a mosaic of N views. vN can be any type of URL supported by GPAC.\\n\"\n\t        \"\\t                 in this mode, URL argument of GPAC is ignored.\\n\"\n\t        \"\\t                 this is equivalent as using mosaic://v1:.:N as an URL.\\n\"\n\t        \"\\n\"\n\t        \"\\t-exit:          automatically exits when presentation is over\\n\"\n\t        \"\\t-run-for TIME:  runs for TIME seconds and exits\\n\"\n\t        \"\\t-service ID:    auto-tune to given service ID in a multiplex\\n\"\n\t        \"\\t-noprog:        disable progress report\\n\"\n\t        \"\\t-no-save:       disable saving config file on exit\\n\"\n\t        \"\\t-no-addon:      disable automatic loading of media addons declared in source URL\\n\"\n\t        \"\\t-gui:           starts in GUI mode. The GUI is indicated in GPAC config, section General, by the key [StartupFile]\\n\"\n\t        \"\\t-ntp-shift T:   shifts NTP clock of T (signed int) milliseconds\\n\"\n\t        \"\\n\"\n\t        \"Dumper Options (times is a formated as start-end, with start being sec, h:m:s:f/fps or h:m:s:ms):\\n\"\n\t        \"\\t-bmp [times]:   dumps given frames to bmp\\n\"\n\t        \"\\t-png [times]:   dumps given frames to png\\n\"\n\t        \"\\t-raw [times]:   dumps given frames to raw\\n\"\n\t        \"\\t-avi [times]:   dumps given file to raw avi\\n\"\n\t        \"\\t-sha [times]:   dumps given file to raw SHA-1 (1 hash per frame)\\n\"\n\t        \"\\r-out filename:  name of the output file\\n\"\n\t        \"\\t-rgbds:         dumps the RGBDS pixel format texture\\n\"\n\t        \"\\t                 with -avi [times]: dumps an rgbds-format .avi\\n\"\n\t        \"\\t-rgbd:          dumps the RGBD pixel format texture\\n\"\n\t        \"\\t                 with -avi [times]: dumps an rgbd-format .avi\\n\"\n\t        \"\\t-depth:         dumps depthmap (z-buffer) frames\\n\"\n\t        \"\\t                 with -avi [times]: dumps depthmap in grayscale .avi\\n\"\n\t        \"\\t                 with -bmp: dumps depthmap in grayscale .bmp\\n\"\n\t        \"\\t                 with -png: dumps depthmap in grayscale .png\\n\"\n\t        \"\\t-fps FPS:       specifies frame rate for AVI dumping (default: %f)\\n\"\n\t        \"\\t-scale s:       scales the visual size (default: 1)\\n\"\n\t        \"\\t-fill:          uses fill aspect ratio for dumping (default: none)\\n\"\n\t        \"\\t-show:          shows window while dumping (default: no)\\n\"\n\t        \"\\n\"\n\t        \"\\t-uncache:       Revert all cached items to their original name and location. Does not start player.\\n\"\n\t        \"\\n\"\n\t        \"\\t-help:          shows this screen\\n\"\n\t        \"\\n\"\n\t        \"MP4Client - GPAC command line player and dumper - version \"GPAC_FULL_VERSION\"\\n\"\n\t        \"(c) Telecom ParisTech 2000-2018 - Licence LGPL v2\\n\"\n\t        \"GPAC Configuration: \" GPAC_CONFIGURATION \"\\n\"\n\t        \"Features: %s\\n\",\n\t        GF_IMPORT_DEFAULT_FPS,\n\t        gpac_features()\n\t       );\n}\n\nvoid PrintHelp()\n{\n\tfprintf(stderr, \"MP4Client command keys:\\n\"\n\t        \"\\tq: quit\\n\"\n\t        \"\\tX: kill\\n\"\n\t        \"\\to: connect to the specified URL\\n\"\n\t        \"\\tO: connect to the specified playlist\\n\"\n\t        \"\\tN: switch to the next URL in the playlist. Also works with \\\\n\\n\"\n\t        \"\\tP: jumps to a given number ahead in the playlist\\n\"\n\t        \"\\tr: reload current presentation\\n\"\n\t        \"\\tD: disconnects the current presentation\\n\"\n\t        \"\\tG: selects object or service ID\\n\"\n\t        \"\\n\"\n\t        \"\\tp: play/pause the presentation\\n\"\n\t        \"\\ts: step one frame ahead\\n\"\n\t        \"\\tz: seek into presentation by percentage\\n\"\n\t        \"\\tT: seek into presentation by time\\n\"\n\t        \"\\tt: print current timing\\n\"\n\t        \"\\n\"\n\t        \"\\tu: sends a command (BIFS or LASeR) to the main scene\\n\"\n\t        \"\\te: evaluates JavaScript code\\n\"\n\t        \"\\tZ: dumps output video to PNG\\n\"\n\t        \"\\n\"\n\t        \"\\tw: view world info\\n\"\n\t        \"\\tv: view Object Descriptor list\\n\"\n\t        \"\\ti: view Object Descriptor info (by ID)\\n\"\n\t        \"\\tj: view Object Descriptor info (by number)\\n\"\n\t        \"\\tb: view media objects timing and buffering info\\n\"\n\t        \"\\tm: view media objects buffering and memory info\\n\"\n\t        \"\\td: dumps scene graph\\n\"\n\t        \"\\n\"\n\t        \"\\tk: turns stress mode on/off\\n\"\n\t        \"\\tn: changes navigation mode\\n\"\n\t        \"\\tx: reset to last active viewpoint\\n\"\n\t        \"\\n\"\n\t        \"\\t3: switch OpenGL on or off for 2D scenes\\n\"\n\t        \"\\n\"\n\t        \"\\t4: forces 4/3 Aspect Ratio\\n\"\n\t        \"\\t5: forces 16/9 Aspect Ratio\\n\"\n\t        \"\\t6: forces no Aspect Ratio (always fill screen)\\n\"\n\t        \"\\t7: forces original Aspect Ratio (default)\\n\"\n\t        \"\\n\"\n\t        \"\\tL: changes to new log level. CF MP4Client usage for possible values\\n\"\n\t        \"\\tT: select new tools to log. CF MP4Client usage for possible values\\n\"\n\t        \"\\n\"\n\t        \"\\tl: list available modules\\n\"\n\t        \"\\tc: prints some GPAC configuration info\\n\"\n\t        \"\\tE: forces reload of GPAC configuration\\n\"\n\t        \"\\n\"\n\t        \"\\tR: toggles run-time info display in window title bar on/off\\n\"\n\t        \"\\tF: toggle displaying of FPS in stderr on/off\\n\"\n\t        \"\\tg: print GPAC allocated memory\\n\"\n\t        \"\\th: print this message\\n\"\n\t        \"\\n\"\n\t        \"\\tEXPERIMENTAL/UNSTABLE OPTIONS\\n\"\n\t        \"\\tC: Enable Streaming Cache\\n\"\n\t        \"\\tS: Stops Streaming Cache and save to file\\n\"\n\t        \"\\tA: Aborts Streaming Cache\\n\"\n\t        \"\\tM: specifies video cache memory for 2D objects\\n\"\n\t        \"\\n\"\n\t        \"MP4Client - GPAC command line player - version %s\\n\"\n\t        \"GPAC Written by Jean Le Feuvre (c) 2001-2005 - ENST (c) 2005-200X\\n\",\n\n\t        GPAC_FULL_VERSION\n\t       );\n}\n\n\nstatic void PrintTime(u64 time)\n{\n\tu32 ms, h, m, s;\n\th = (u32) (time / 1000 / 3600);\n\tm = (u32) (time / 1000 / 60 - h*60);\n\ts = (u32) (time / 1000 - h*3600 - m*60);\n\tms = (u32) (time - (h*3600 + m*60 + s) * 1000);\n\tfprintf(stderr, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n}\n\nvoid PrintAVInfo(Bool final);\n\n\nstatic u32 rti_update_time_ms = 200;\nstatic FILE *rti_logs = NULL;\n\nstatic void UpdateRTInfo(const char *legend)\n{\n\tGF_SystemRTInfo rti;\n\n\t/*refresh every second*/\n\tif (!display_rti && !rti_logs) return;\n\tif (!gf_sys_get_rti(rti_update_time_ms, &rti, 0) && !legend)\n\t\treturn;\n\n\tif (display_rti) {\n\t\tchar szMsg[1024];\n\n\t\tif (rti.total_cpu_usage && (bench_mode<2) ) {\n\t\t\tsprintf(szMsg, \"FPS %02.02f CPU %2d (%02d) Mem %d kB\",\n\t\t\t        gf_term_get_framerate(term, 0), rti.total_cpu_usage, rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024));\n\t\t} else {\n\t\t\tsprintf(szMsg, \"FPS %02.02f CPU %02d Mem %d kB\",\n\t\t\t        gf_term_get_framerate(term, 0), rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024) );\n\t\t}\n\n\t\tif (display_rti==2) {\n\t\t\tif (bench_mode>=2) {\n\t\t\t\tPrintAVInfo(GF_FALSE);\n\t\t\t}\n\t\t\tfprintf(stderr, \"%s\\r\", szMsg);\n\t\t} else {\n\t\t\tGF_Event evt;\n\t\t\tevt.type = GF_EVENT_SET_CAPTION;\n\t\t\tevt.caption.caption = szMsg;\n\t\t\tgf_term_user_event(term, &evt);\n\t\t}\n\t}\n\tif (rti_logs) {\n\t\tfprintf(rti_logs, \"% 8d\\t% 8d\\t% 8d\\t% 4d\\t% 8d\\t%s\",\n\t\t        gf_sys_clock(),\n\t\t        gf_term_get_time_in_ms(term),\n\t\t        rti.total_cpu_usage,\n\t\t        (u32) gf_term_get_framerate(term, 0),\n\t\t        (u32) (rti.gpac_memory / 1024),\n\t\t        legend ? legend : \"\"\n\t\t       );\n\t\tif (!legend) fprintf(rti_logs, \"\\n\");\n\t}\n}\n\nstatic void ResetCaption()\n{\n\tGF_Event event;\n\tif (display_rti) return;\n\tevent.type = GF_EVENT_SET_CAPTION;\n\tif (is_connected) {\n\t\tchar szName[1024];\n\t\tNetInfoCommand com;\n\n\t\tevent.caption.caption = NULL;\n\t\t/*get any service info*/\n\t\tif (!startup_file && gf_term_get_service_info(term, gf_term_get_root_object(term), &com) == GF_OK) {\n\t\t\tstrcpy(szName, \"\");\n\t\t\tif (com.track_info) {\n\t\t\t\tchar szBuf[10];\n\t\t\t\tsprintf(szBuf, \"%02d \", (u32) (com.track_info>>16) );\n\t\t\t\tstrcat(szName, szBuf);\n\t\t\t}\n\t\t\tif (com.artist) {\n\t\t\t\tstrcat(szName, com.artist);\n\t\t\t\tstrcat(szName, \" \");\n\t\t\t}\n\t\t\tif (com.name) {\n\t\t\t\tstrcat(szName, com.name);\n\t\t\t\tstrcat(szName, \" \");\n\t\t\t}\n\t\t\tif (com.album) {\n\t\t\t\tstrcat(szName, \"(\");\n\t\t\t\tstrcat(szName, com.album);\n\t\t\t\tstrcat(szName, \")\");\n\t\t\t}\n\t\t\tif (com.provider) {\n\t\t\t\tstrcat(szName, \"(\");\n\t\t\t\tstrcat(szName, com.provider);\n\t\t\t\tstrcat(szName, \")\");\n\t\t\t}\n\n\t\t\tif (strlen(szName)) event.caption.caption = szName;\n\t\t}\n\t\tif (!event.caption.caption) {\n\t\t\tchar *str = strrchr(the_url, '\\\\');\n\t\t\tif (!str) str = strrchr(the_url, '/');\n\t\t\tevent.caption.caption = str ? str+1 : the_url;\n\t\t}\n\t} else {\n\t\tevent.caption.caption = \"GPAC MP4Client \" GPAC_FULL_VERSION;\n\t}\n\tgf_term_user_event(term, &event);\n}\n\n#ifdef WIN32\nu32 get_sys_col(int idx)\n{\n\tu32 res;\n\tDWORD val = GetSysColor(idx);\n\tres = (val)&0xFF;\n\tres<<=8;\n\tres |= (val>>8)&0xFF;\n\tres<<=8;\n\tres |= (val>>16)&0xFF;\n\treturn res;\n}\n#endif\n\nvoid switch_bench(u32 is_on)\n{\n\tbench_mode = is_on;\n\tdisplay_rti = is_on ? 2 : 0;\n\tResetCaption();\n\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, is_on);\n}\n\n#ifndef WIN32\n#include <termios.h>\nint getch() {\n\tstruct termios old;\n\tstruct termios new;\n\tint rc;\n\tif (tcgetattr(0, &old) == -1) {\n\t\treturn -1;\n\t}\n\tnew = old;\n\tnew.c_lflag &= ~(ICANON | ECHO);\n\tnew.c_cc[VMIN] = 1;\n\tnew.c_cc[VTIME] = 0;\n\tif (tcsetattr(0, TCSANOW, &new) == -1) {\n\t\treturn -1;\n\t}\n\trc = getchar();\n\t(void) tcsetattr(0, TCSANOW, &old);\n\treturn rc;\n}\n#else\nint getch() {\n\treturn getchar();\n}\n#endif\n\n/**\n * Reads a line of input from stdin\n * @param line the buffer to fill\n * @param maxSize the maximum size of the line to read\n * @param showContent boolean indicating if the line read should be printed on stderr or not\n */\nstatic const char * read_line_input(char * line, int maxSize, Bool showContent) {\n\tchar read;\n\tint i = 0;\n\tif (fflush( stderr ))\n\t\tperror(\"Failed to flush buffer %s\");\n\tdo {\n\t\tline[i] = '\\0';\n\t\tif (i >= maxSize - 1)\n\t\t\treturn line;\n\t\tread = getch();\n\t\tif (read == 8 || read == 127) {\n\t\t\tif (i > 0) {\n\t\t\t\tfprintf(stderr, \"\\b \\b\");\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else if (read > 32) {\n\t\t\tfputc(showContent ? read : '*', stderr);\n\t\t\tline[i++] = read;\n\t\t}\n\t\tfflush(stderr);\n\t} while (read != '\\n');\n\tif (!read)\n\t\treturn 0;\n\treturn line;\n}\n\nstatic void do_set_speed(Fixed desired_speed)\n{\n\tif (gf_term_set_speed(term, desired_speed) == GF_OK) {\n\t\tplayback_speed = desired_speed;\n\t\tfprintf(stderr, \"Playing at %g speed\\n\", FIX2FLT(playback_speed));\n\t} else {\n\t\tfprintf(stderr, \"Adjusting speed to %g not supported for this content\\n\", FIX2FLT(desired_speed));\n\t}\n}\n\nBool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n\t\tbreak;\n\tcase GF_EVENT_NAVIGATE:\n\t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n\t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}\n\n\nvoid list_modules(GF_ModuleManager *modules)\n{\n\tu32 i;\n\tfprintf(stderr, \"\\rAvailable modules:\\n\");\n\tfor (i=0; i<gf_modules_get_count(modules); i++) {\n\t\tchar *str = (char *) gf_modules_get_file_name(modules, i);\n\t\tif (str) fprintf(stderr, \"\\t%s\\n\", str);\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\nvoid set_navigation()\n{\n\tGF_Err e;\n\tchar nav;\n\tu32 type = gf_term_get_option(term, GF_OPT_NAVIGATION_TYPE);\n\te = GF_OK;\n\tfflush(stdin);\n\n\tif (!type) {\n\t\tfprintf(stderr, \"Content/compositor doesn't allow user-selectable navigation\\n\");\n\t} else if (type==1) {\n\t\tfprintf(stderr, \"Select Navigation (\\'N\\'one, \\'E\\'xamine, \\'S\\'lide): \");\n\t\tnav = getch();\n\t\tif (nav=='N') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);\n\t\telse if (nav=='E') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);\n\t\telse if (nav=='S') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);\n\t\telse fprintf(stderr, \"Unknown selector \\'%c\\' - only \\'N\\',\\'E\\',\\'S\\' allowed\\n\", nav);\n\t} else if (type==2) {\n\t\tfprintf(stderr, \"Select Navigation (\\'N\\'one, \\'W\\'alk, \\'F\\'ly, \\'E\\'xamine, \\'P\\'an, \\'S\\'lide, \\'G\\'ame, \\'V\\'R, \\'O\\'rbit): \");\n\t\tnav = getch();\n\t\tif (nav=='N') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);\n\t\telse if (nav=='W') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_WALK);\n\t\telse if (nav=='F') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_FLY);\n\t\telse if (nav=='E') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);\n\t\telse if (nav=='P') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_PAN);\n\t\telse if (nav=='S') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);\n\t\telse if (nav=='G') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_GAME);\n\t\telse if (nav=='O') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_ORBIT);\n\t\telse if (nav=='V') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_VR);\n\t\telse fprintf(stderr, \"Unknown selector %c - only \\'N\\',\\'W\\',\\'F\\',\\'E\\',\\'P\\',\\'S\\',\\'G\\', \\'V\\', \\'O\\' allowed\\n\", nav);\n\t}\n\tif (e) fprintf(stderr, \"Error setting mode: %s\\n\", gf_error_to_string(e));\n}\n\n\nstatic Bool get_time_list(char *arg, u32 *times, u32 *nb_times)\n{\n\tchar *str;\n\tFloat var;\n\tDouble sec;\n\tu32 h, m, s, ms, f, fps;\n\tif (!arg || (arg[0]=='-') || !isdigit(arg[0])) return 0;\n\n\t/*SMPTE time code*/\n\tif (strchr(arg, ':') && strchr(arg, ';') && strchr(arg, '/')) {\n\t\tif (sscanf(arg, \"%02ud:%02ud:%02ud;%02ud/%02ud\", &h, &m, &s, &f, &fps)==5) {\n\t\t\tsec = 0;\n\t\t\tif (fps) sec = ((Double)f) / fps;\n\t\t\tsec += 3600*h + 60*m + s;\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\twhile (arg) {\n\t\tstr = strchr(arg, '-');\n\t\tif (str) str[0] = 0;\n\t\t/*HH:MM:SS:MS time code*/\n\t\tif (strchr(arg, ':') && (sscanf(arg, \"%u:%u:%u:%u\", &h, &m, &s, &ms)==4)) {\n\t\t\tsec = ms;\n\t\t\tsec /= 1000;\n\t\t\tsec += 3600*h + 60*m + s;\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t} else if (sscanf(arg, \"%f\", &var)==1) {\n\t\t\tsec = atof(arg);\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t}\n\t\tif (!str) break;\n\t\tstr[0] = '-';\n\t\targ = str+1;\n\t}\n\treturn 1;\n}\n\nstatic u64 last_log_time=0;\nstatic void on_gpac_log(void *cbk, GF_LOG_Level ll, GF_LOG_Tool lm, const char *fmt, va_list list)\n{\n\tFILE *logs = cbk ? cbk : stderr;\n\n\tif (rti_logs && (lm & GF_LOG_RTI)) {\n\t\tchar szMsg[2048];\n\t\tvsprintf(szMsg, fmt, list);\n\t\tUpdateRTInfo(szMsg + 6 /*\"[RTI] \"*/);\n\t} else {\n\t\tif (log_time_start) {\n\t\t\tu64 now = gf_sys_clock_high_res();\n\t\t\tfprintf(logs, \"At \"LLD\" (diff %d) - \", now - log_time_start, (u32) (now - last_log_time) );\n\t\t\tlast_log_time = now;\n\t\t}\n\t\tif (log_utc_time) {\n\t\t\tu64 utc_clock = gf_net_get_utc() ;\n\t\t\ttime_t secs = utc_clock/1000;\n\t\t\tstruct tm t;\n\t\t\tt = *gmtime(&secs);\n\t\t\tfprintf(logs, \"UTC %d-%02d-%02dT%02d:%02d:%02dZ (TS \"LLU\") - \", 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, utc_clock);\n\t\t}\n\t\tvfprintf(logs, fmt, list);\n\t\tfflush(logs);\n\t}\n}\n\nstatic void init_rti_logs(char *rti_file, char *url, Bool use_rtix)\n{\n\tif (rti_logs) gf_fclose(rti_logs);\n\trti_logs = gf_fopen(rti_file, \"wt\");\n\tif (rti_logs) {\n\t\tfprintf(rti_logs, \"!! GPAC RunTime Info \");\n\t\tif (url) fprintf(rti_logs, \"for file %s\", url);\n\t\tfprintf(rti_logs, \" !!\\n\");\n\t\tfprintf(rti_logs, \"SysTime(ms)\\tSceneTime(ms)\\tCPU\\tFPS\\tMemory(kB)\\tObservation\\n\");\n\n\t\t/*turn on RTI loging*/\n\t\tif (use_rtix) {\n\t\t\tgf_log_set_callback(NULL, on_gpac_log);\n\t\t\tgf_log_set_tool_level(GF_LOG_RTI, GF_LOG_DEBUG);\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_RTI, (\"[RTI] System state when enabling log\\n\"));\n\t\t} else if (log_time_start) {\n\t\t\tlog_time_start = gf_sys_clock_high_res();\n\t\t}\n\t}\n}\n\nvoid set_cfg_option(char *opt_string)\n{\n\tchar *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];\n\tsep = strchr(opt_string, ':');\n\tif (!sep) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep - opt_string;\n\t\tif (sepIdx >= sizeof(szSec)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - Section name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\n\t\tstrncpy(szSec, opt_string, sepIdx);\n\t\tszSec[sepIdx] = 0;\n\t}\n\tsep ++;\n\tsep2 = strchr(sep, '=');\n\tif (!sep2) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep2 - sep;\n\t\tif (sepIdx >= sizeof(szKey)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - key name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrncpy(szKey, sep, sepIdx);\n\t\tszKey[sepIdx] = 0;\n\t\tif (strlen(sep2 + 1) >= sizeof(szVal)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - value is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(szVal, sep2+1);\n\t}\n\n\tif (!stricmp(szKey, \"*\")) {\n\t\tif (stricmp(szVal, \"null\")) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:*=null\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tgf_cfg_del_section(cfg_file, szSec);\n\t\treturn;\n\t}\n\n\tif (!stricmp(szVal, \"null\")) {\n\t\tszVal[0]=0;\n\t}\n\tgf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);\n}\n\nBool revert_cache_file(void *cbck, char *item_name, char *item_path, GF_FileEnumInfo *file_info)\n{\n\tconst char *url;\n\tchar *sep;\n\tGF_Config *cached;\n\tif (strncmp(item_name, \"gpac_cache_\", 11)) return GF_FALSE;\n\tcached = gf_cfg_new(NULL, item_path);\n\turl = gf_cfg_get_key(cached, \"cache\", \"url\");\n\tif (url) url = strstr(url, \"://\");\n\tif (url) {\n\t\tu32 i, len, dir_len=0, k=0;\n\t\tchar *dst_name;\n\t\tsep = strstr(item_path, \"gpac_cache_\");\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tdir_len = (u32) strlen(item_path);\n\t\t\tsep[0] = 'g';\n\t\t}\n\t\turl+=3;\n\t\tlen = (u32) strlen(url);\n\t\tdst_name = gf_malloc(len+dir_len+1);\n\t\tmemset(dst_name, 0, len+dir_len+1);\n\n\t\tstrncpy(dst_name, item_path, dir_len);\n\t\tk=dir_len;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tdst_name[k] = url[i];\n\t\t\tif (dst_name[k]==':') dst_name[k]='_';\n\t\t\telse if (dst_name[k]=='/') {\n\t\t\t\tif (!gf_dir_exists(dst_name))\n\t\t\t\t\tgf_mkdir(dst_name);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tsep = strrchr(item_path, '.');\n\t\tif (sep) {\n\t\t\tsep[0]=0;\n\t\t\tif (gf_file_exists(item_path)) {\n\t\t\t\tgf_move_file(item_path, dst_name);\n\t\t\t}\n\t\t\tsep[0]='.';\n\t\t}\n\t\tgf_free(dst_name);\n\t}\n\tgf_cfg_del(cached);\n\tgf_delete_file(item_path);\n\treturn GF_FALSE;\n}\nvoid do_flatten_cache(const char *cache_dir)\n{\n\tgf_enum_directory(cache_dir, GF_FALSE, revert_cache_file, NULL, \"*.txt\");\n}\n\n\n#ifdef WIN32\n#include <wincon.h>\n#endif\n\nstatic void progress_quiet(const void *cbck, const char *title, u64 done, u64 total) { }\n\nint mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don't want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) >= sizeof(the_url)) {\n\t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}\n\n#if defined(WIN32) && !defined(NO_WMAIN)\nint wmain(int argc, wchar_t** wargv)\n{\n\tint i;\n\tint res;\n\tsize_t len;\n\tsize_t res_len;\n\tchar **argv;\n\targv = (char **)malloc(argc*sizeof(wchar_t *));\n\tfor (i = 0; i < argc; i++) {\n\t\twchar_t *src_str = wargv[i];\n\t\tlen = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(wargv[i]);\n\t\targv[i] = (char *)malloc(len + 1);\n\t\tres_len = gf_utf8_wcstombs(argv[i], len, &src_str);\n\t\targv[i][res_len] = 0;\n\t\tif (res_len > len) {\n\t\t\tfprintf(stderr, \"Length allocated for conversion of wide char to UTF-8 not sufficient\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tres = mp4client_main(argc, argv);\n\tfor (i = 0; i < argc; i++) {\n\t\tfree(argv[i]);\n\t}\n\tfree(argv);\n\treturn res;\n}\n#else\nint main(int argc, char** argv)\n{\n\treturn mp4client_main(argc, argv);\n}\n#endif //win32\nstatic GF_ObjectManager *video_odm = NULL;\nstatic GF_ObjectManager *audio_odm = NULL;\nstatic GF_ObjectManager *scene_odm = NULL;\nstatic u32 last_odm_count = 0;\nvoid PrintAVInfo(Bool final)\n{\n\tGF_MediaInfo a_odi, v_odi, s_odi;\n\tDouble avg_dec_time=0;\n\tu32 tot_time=0;\n\tBool print_codecs = final;\n\n\tif (scene_odm) {\n\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\tu32 count = gf_term_get_object_count(term, root_odm);\n\t\tif (last_odm_count != count) {\n\t\t\tlast_odm_count = count;\n\t\t\tscene_odm = NULL;\n\t\t}\n\t}\n\tif (!video_odm && !audio_odm && !scene_odm) {\n\t\tu32 count, i;\n\t\tGF_ObjectManager *root_odm = root_odm = gf_term_get_root_object(term);\n\t\tif (!root_odm) return;\n\n\t\tif (gf_term_get_object_info(term, root_odm, &v_odi)==GF_OK) {\n\t\t\tif (!scene_odm  && (v_odi.generated_scene== 0)) {\n\t\t\t\tscene_odm = root_odm;\n\t\t\t}\n\t\t}\n\n\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ObjectManager *odm = gf_term_get_object(term, root_odm, i);\n\t\t\tif (!odm) break;\n\t\t\tif (gf_term_get_object_info(term, odm, &v_odi) == GF_OK) {\n\t\t\t\tif (!video_odm && (v_odi.od_type == GF_STREAM_VISUAL) && (v_odi.raw_media || (v_odi.cb_max_count>1) || v_odi.direct_video_memory || (bench_mode == 3) )) {\n\t\t\t\t\tvideo_odm = odm;\n\t\t\t\t}\n\t\t\t\telse if (!audio_odm && (v_odi.od_type == GF_STREAM_AUDIO)) {\n\t\t\t\t\taudio_odm = odm;\n\t\t\t\t}\n\t\t\t\telse if (!scene_odm && (v_odi.od_type == GF_STREAM_SCENE)) {\n\t\t\t\t\tscene_odm = odm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0 && bench_buffer) {\n\t\tfprintf(stderr, \"Buffering %d %% \", bench_buffer-1);\n\t\treturn;\n\t}\n\n\tif (video_odm) {\n\t\tif (gf_term_get_object_info(term, video_odm, &v_odi)!= GF_OK) {\n\t\t\tvideo_odm = NULL;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmemset(&v_odi, 0, sizeof(v_odi));\n\t}\n\tif (print_codecs && audio_odm) {\n\t\tgf_term_get_object_info(term, audio_odm, &a_odi);\n\t} else {\n\t\tmemset(&a_odi, 0, sizeof(a_odi));\n\t}\n\tif ((print_codecs || !video_odm) && scene_odm) {\n\t\tgf_term_get_object_info(term, scene_odm, &s_odi);\n\t} else {\n\t\tmemset(&s_odi, 0, sizeof(s_odi));\n\t}\n\n\tif (final) {\n\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\tfprintf(stderr, \"                                                                                     \\r\");\n\t\tfprintf(stderr, \"************** Bench Mode Done in %d ms ********************\\n\", tot_time);\n\t\tif (bench_mode==3) fprintf(stderr, \"** Systems layer only (no decoding) **\\n\");\n\n\t\tif (!video_odm) {\n\t\t\tu32 nb_frames_drawn;\n\t\t\tDouble FPS = gf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\tfprintf(stderr, \"Drawn %d frames FPS %.2f (simulation FPS %.2f) - duration %d ms\\n\", nb_frames_drawn, ((Float)nb_frames_drawn*1000)/tot_time,(Float) FPS, gf_term_get_time_in_ms(term)  );\n\t\t}\n\t}\n\tif (print_codecs) {\n\t\tif (video_odm) {\n\t\t\tfprintf(stderr, \"%s %dx%d sar=%d:%d duration %.2fs\\n\", v_odi.codec_name, v_odi.width, v_odi.height, v_odi.par ? (v_odi.par>>16)&0xFF : 1, v_odi.par ? (v_odi.par)&0xFF : 1, v_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tu32 dec_run_time = v_odi.last_frame_time - v_odi.first_frame_time;\n\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\tif (v_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*v_odi.current_time / v_odi.duration ) );\n\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (max %d us/f) rate avg %d max %d\", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / dec_run_time, v_odi.max_dec_time, (u32) v_odi.avg_bitrate/1000, (u32) v_odi.max_bitrate/1000);\n\t\t\t\tif (v_odi.nb_dropped) {\n\t\t\t\t\tfprintf(stderr, \" (Error during bench: %d frames drop)\", v_odi.nb_dropped);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (audio_odm) {\n\t\t\tfprintf(stderr, \"%s SR %d num channels %d bpp %d duration %.2fs\\n\", a_odi.codec_name, a_odi.sample_rate, a_odi.num_channels, a_odi.bits_per_sample, a_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tu32 dec_run_time = a_odi.last_frame_time - a_odi.first_frame_time;\n\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\tif (a_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*a_odi.current_time / a_odi.duration ) );\n\t\t\t\tfprintf(stderr, \"%d frames (ms/f %.2f avg %.2f max) rate avg %d max %d\", a_odi.nb_dec_frames, ((Float)dec_run_time)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0, (u32) a_odi.avg_bitrate/1000, (u32) a_odi.max_bitrate/1000);\n\t\t\t\tif (a_odi.nb_dropped) {\n\t\t\t\t\tfprintf(stderr, \" (Error during bench: %d frames drop)\", a_odi.nb_dropped);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (scene_odm) {\n\t\t\tu32 w, h;\n\t\t\tgf_term_get_visual_output_size(term, &w, &h);\n\t\t\tfprintf(stderr, \"%s scene size %dx%d rastered to %dx%d duration %.2fs\\n\", s_odi.codec_name ? s_odi.codec_name : \"\", s_odi.width, s_odi.height, w, h, s_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tif (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {\n\t\t\t\t\tu32 dec_run_time = s_odi.last_frame_time - s_odi.first_frame_time;\n\t\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (max %d us/f) rate avg %d max %d\", s_odi.nb_dec_frames, ((Float)s_odi.nb_dec_frames*1000) / dec_run_time, s_odi.max_dec_time, (u32) s_odi.avg_bitrate/1000, (u32) s_odi.max_bitrate/1000);\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tu32 nb_frames_drawn;\n\t\t\t\t\tDouble FPS;\n\t\t\t\t\tgf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\t\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\t\t\t\tFPS = gf_term_get_framerate(term, 0);\n\t\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (abs %.2f)\\n\", nb_frames_drawn, (1000.0*nb_frames_drawn / tot_time), FPS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (final) {\n\t\t\tfprintf(stderr, \"**********************************************************\\n\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (video_odm) {\n\t\ttot_time = v_odi.last_frame_time - v_odi.first_frame_time;\n\t\tif (!tot_time) tot_time=1;\n\t\tif (v_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*v_odi.current_time / v_odi.duration ) );\n\t\tfprintf(stderr, \"%d f FPS %.2f (%.2f ms max) rate %d \", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / tot_time, v_odi.max_dec_time/1000.0, (u32) v_odi.instant_bitrate/1000);\n\t}\n\telse if (scene_odm) {\n\n\t\tif (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {\n\t\t\tavg_dec_time = (Float) 1000000 * s_odi.nb_dec_frames;\n\t\t\tavg_dec_time /= s_odi.total_dec_time;\n\t\t\tif (s_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*s_odi.current_time / s_odi.duration ) );\n\t\t\tfprintf(stderr, \"%d f %.2f (%d us max) - rate %d \", s_odi.nb_dec_frames, avg_dec_time, s_odi.max_dec_time, (u32) s_odi.instant_bitrate/1000);\n\t\t} else {\n\t\t\tu32 nb_frames_drawn;\n\t\t\tDouble FPS;\n\t\t\tgf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\t\tFPS = gf_term_get_framerate(term, 1);\n\t\t\tfprintf(stderr, \"%d f FPS %.2f (abs %.2f) \", nb_frames_drawn, (1000.0*nb_frames_drawn / tot_time), FPS);\n\t\t}\n\t}\n\telse if (audio_odm) {\n\t\tif (!print_codecs) {\n\t\t\tgf_term_get_object_info(term, audio_odm, &a_odi);\n\t\t}\n\t\ttot_time = a_odi.last_frame_time - a_odi.first_frame_time;\n\t\tif (!tot_time) tot_time=1;\n\t\tif (a_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*a_odi.current_time / a_odi.duration ) );\n\t\tfprintf(stderr, \"%d frames (ms/f %.2f avg %.2f max)\", a_odi.nb_dec_frames, ((Float)tot_time)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0);\n\t}\n}\n\nvoid PrintWorldInfo(GF_Terminal *term)\n{\n\tu32 i;\n\tconst char *title;\n\tGF_List *descs;\n\tdescs = gf_list_new();\n\ttitle = gf_term_get_world_info(term, NULL, descs);\n\tif (!title && !gf_list_count(descs)) {\n\t\tfprintf(stderr, \"No World Info available\\n\");\n\t} else {\n\t\tfprintf(stderr, \"\\t%s\\n\", title ? title : \"No title available\");\n\t\tfor (i=0; i<gf_list_count(descs); i++) {\n\t\t\tchar *str = gf_list_get(descs, i);\n\t\t\tfprintf(stderr, \"%s\\n\", str);\n\t\t}\n\t}\n\tgf_list_del(descs);\n}\n\nvoid PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name)\n{\n\tGF_MediaInfo odi;\n\tu32 i, count;\n\tchar szIndent[50];\n\tGF_ObjectManager *odm;\n\n\tif (!root_odm) {\n\t\tfprintf(stderr, \"Currently loaded objects:\\n\");\n\t\troot_odm = gf_term_get_root_object(term);\n\t}\n\tif (!root_odm) return;\n\n\tcount = gf_term_get_current_service_id(term);\n\tif (count)\n\t\tfprintf(stderr, \"Current service ID %d\\n\", count);\n\n\tif (gf_term_get_object_info(term, root_odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tfor (i=0; i<indent; i++) szIndent[i]=' ';\n\tszIndent[indent]=0;\n\n\tfprintf(stderr, \"%s\", szIndent);\n\tfprintf(stderr, \"#%d %s - \", num, root_name);\n\tif (odi.od->ServiceID) fprintf(stderr, \"Service ID %d \", odi.od->ServiceID);\n\tif (odi.media_url) {\n\t\tfprintf(stderr, \"%s\\n\", odi.media_url);\n\t} else {\n\t\tfprintf(stderr, \"OD ID %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tszIndent[indent]=' ';\n\tszIndent[indent+1]=0;\n\tindent++;\n\n\tcount = gf_term_get_object_count(term, root_odm);\n\tfor (i=0; i<count; i++) {\n\t\todm = gf_term_get_object(term, root_odm, i);\n\t\tif (!odm) break;\n\t\tnum++;\n\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\tswitch (gf_term_object_subscene_type(term, odm)) {\n\t\t\tcase 1:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Root\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Inline Scene\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tPrintODList(term, odm, num, indent, \"EXTERNPROTO Library\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"%s\", szIndent);\n\t\t\t\tfprintf(stderr, \"#%d - \", num);\n\t\t\t\tif (odi.media_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.media_url);\n\t\t\t\t} else if (odi.od) {\n\t\t\t\t \tif (odi.od->URLString) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", odi.od->URLString);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"ID %d\", odi.od->objectDescriptorID);\n\t\t\t\t\t}\n\t\t\t\t} else if (odi.service_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.service_url);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \" - %s\", (odi.od_type==GF_STREAM_VISUAL) ? \"Video\" : (odi.od_type==GF_STREAM_AUDIO) ? \"Audio\" : \"Systems\");\n\t\t\t\tif (odi.od && odi.od->ServiceID) fprintf(stderr, \" - Service ID %d\", odi.od->ServiceID);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ViewOD(GF_Terminal *term, u32 OD_ID, u32 number, const char *szURL)\n{\n\tGF_MediaInfo odi;\n\tu32 i, j, count, d_enum,id;\n\tGF_Err e;\n\tNetStatCommand com;\n\tGF_ObjectManager *odm, *root_odm = gf_term_get_root_object(term);\n\tif (!root_odm) return;\n\n\todm = NULL;\n\tif (!szURL && ((!OD_ID && (number == (u32)-1)) || ((OD_ID == (u32)(-1)) && !number))) {\n\t\todm = root_odm;\n\t\tif ((gf_term_get_object_info(term, odm, &odi) != GF_OK)) odm=NULL;\n\t} else {\n\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\tfor (i=0; i<count; i++) {\n\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\tif (!odm) break;\n\t\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\t\tif (szURL && strstr(odi.service_url, szURL)) break;\n\t\t\t\tif ((number == (u32)(-1)) && odi.od && (odi.od->objectDescriptorID == OD_ID)) break;\n\t\t\t\telse if (i == (u32)(number-1)) break;\n\t\t\t}\n\t\t\todm = NULL;\n\t\t}\n\t}\n\tif (!odm) {\n\t\tif (szURL) fprintf(stderr, \"cannot find OD for URL %s\\n\", szURL);\n\t\tif (number == (u32)-1) fprintf(stderr, \"cannot find OD with ID %d\\n\", OD_ID);\n\t\telse fprintf(stderr, \"cannot find OD with number %d\\n\", number);\n\t\treturn;\n\t}\n\tif (!odi.od) {\n\t\tif (number == (u32)-1) fprintf(stderr, \"Object %d not attached yet\\n\", OD_ID);\n\t\telse fprintf(stderr, \"Object #%d not attached yet\\n\", number);\n\t\treturn;\n\t}\n\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tif (odi.od->tag==GF_ODF_IOD_TAG) {\n\t\tfprintf(stderr, \"InitialObjectDescriptor %d\\n\", odi.od->objectDescriptorID);\n\t\tfprintf(stderr, \"Profiles and Levels: Scene %x - Graphics %x - Visual %x - Audio %x - OD %x\\n\",\n\t\t        odi.scene_pl, odi.graphics_pl, odi.visual_pl, odi.audio_pl, odi.OD_pl);\n\t\tfprintf(stderr, \"Inline Profile Flag %d\\n\", odi.inline_pl);\n\t} else {\n\t\tfprintf(stderr, \"ObjectDescriptor %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tfprintf(stderr, \"Object Duration: \");\n\tif (odi.duration) {\n\t\tPrintTime((u32) (odi.duration*1000));\n\t} else {\n\t\tfprintf(stderr, \"unknown\");\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"Service Handler: %s\\n\", odi.service_handler);\n\tfprintf(stderr, \"Service URL: %s\\n\", odi.service_url);\n\n\tif (odi.codec_name) {\n\t\tFloat avg_dec_time;\n\t\tswitch (odi.od_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tfprintf(stderr, \"Video Object: Width %d - Height %d\\r\\n\", odi.width, odi.height);\n\t\t\tfprintf(stderr, \"Media Codec: %s\\n\", odi.codec_name);\n\t\t\tif (odi.par) fprintf(stderr, \"Pixel Aspect Ratio: %d:%d\\n\", (odi.par>>16)&0xFF, (odi.par)&0xFF);\n\t\t\tbreak;\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tfprintf(stderr, \"Audio Object: Sample Rate %d - %d channels\\r\\n\", odi.sample_rate, odi.num_channels);\n\t\t\tfprintf(stderr, \"Media Codec: %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\tcase GF_STREAM_PRIVATE_SCENE:\n\t\t\tif (odi.width && odi.height) {\n\t\t\t\tfprintf(stderr, \"Scene Description - Width %d - Height %d\\n\", odi.width, odi.height);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Scene Description - no size specified\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"Scene Codec: %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\tcase GF_STREAM_TEXT:\n\t\t\tif (odi.width && odi.height) {\n\t\t\t\tfprintf(stderr, \"Text Object: Width %d - Height %d\\n\", odi.width, odi.height);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Text Object: No size specified\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"Text Codec %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\t}\n\n\t\tavg_dec_time = 0;\n\t\tif (odi.nb_dec_frames) {\n\t\t\tavg_dec_time = (Float) odi.total_dec_time;\n\t\t\tavg_dec_time /= odi.nb_dec_frames;\n\t\t}\n\t\tfprintf(stderr, \"\\tBitrate over last second: %d kbps\\n\\tMax bitrate over one second: %d kbps\\n\\tAverage Decoding Time %.2f us %d max)\\n\\tTotal decoded frames %d\\n\",\n\t\t        (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, avg_dec_time, odi.max_dec_time, odi.nb_dec_frames);\n\t}\n\tif (odi.protection) fprintf(stderr, \"Encrypted Media%s\\n\", (odi.protection==2) ? \" NOT UNLOCKED\" : \"\");\n\n\tcount = gf_list_count(odi.od->ESDescriptors);\n\tfprintf(stderr, \"%d streams in OD\\n\", count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ESD *esd = (GF_ESD *) gf_list_get(odi.od->ESDescriptors, i);\n\n\t\tfprintf(stderr, \"\\nStream ID %d - Clock ID %d\\n\", esd->ESID, esd->OCRESID);\n\t\tif (esd->dependsOnESID) fprintf(stderr, \"\\tDepends on Stream ID %d for decoding\\n\", esd->dependsOnESID);\n\n\t\tswitch (esd->decoderConfig->streamType) {\n\t\tcase GF_STREAM_OD:\n\t\t\tfprintf(stderr, \"\\tOD Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_OCR:\n\t\t\tfprintf(stderr, \"\\tOCR Stream\\n\");\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\t\tfprintf(stderr, \"\\tScene Description Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tfprintf(stderr, \"\\tVisual Stream - media type: %s\", gf_esd_get_textual_description(esd));\n\t\t\tbreak;\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tfprintf(stderr, \"\\tAudio Stream - media type: %s\", gf_esd_get_textual_description(esd));\n\t\t\tbreak;\n\t\tcase GF_STREAM_MPEG7:\n\t\t\tfprintf(stderr, \"\\tMPEG-7 Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_IPMP:\n\t\t\tfprintf(stderr, \"\\tIPMP Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_OCI:\n\t\t\tfprintf(stderr, \"\\tOCI Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_MPEGJ:\n\t\t\tfprintf(stderr, \"\\tMPEGJ Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_INTERACT:\n\t\t\tfprintf(stderr, \"\\tUser Interaction Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_TEXT:\n\t\t\tfprintf(stderr, \"\\tStreaming Text Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"\\tUnknown Stream\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfprintf(stderr, \"\\tBuffer Size %d\\n\\tAverage Bitrate %d bps\\n\\tMaximum Bitrate %d bps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate, esd->decoderConfig->maxBitrate);\n\t\tif (esd->slConfig->predefined==SLPredef_SkipSL) {\n\t\t\tfprintf(stderr, \"\\tNot using MPEG-4 Synchronization Layer\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tStream Clock Resolution %d\\n\", esd->slConfig->timestampResolution);\n\t\t}\n\t\tif (esd->URLString) fprintf(stderr, \"\\tStream Location: %s\\n\", esd->URLString);\n\n\t\t/*check language*/\n\t\tif (esd->langDesc) {\n\t\t\ts32 lang_idx;\n\t\t\tchar lan[4];\n\t\t\tlan[0] = esd->langDesc->langCode>>16;\n\t\t\tlan[1] = (esd->langDesc->langCode>>8)&0xFF;\n\t\t\tlan[2] = (esd->langDesc->langCode)&0xFF;\n\t\t\tlan[3] = 0;\n\n\t\t\tlang_idx = gf_lang_find(lan);\n\t\t\tif (lang_idx>=0) {\n\t\t\t\tfprintf(stderr, \"\\tStream Language: %s\\n\", gf_lang_get_name(lang_idx));\n\t\t\t}\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n\t/*check OCI (not everything interests us) - FIXME: support for unicode*/\n\tcount = gf_list_count(odi.od->OCIDescriptors);\n\tif (count) {\n\t\tfprintf(stderr, \"%d Object Content Information descriptors in OD\\n\", count);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *) gf_list_get(odi.od->OCIDescriptors, i);\n\t\t\tswitch (desc->tag) {\n\t\t\tcase GF_ODF_SEGMENT_TAG:\n\t\t\t{\n\t\t\t\tGF_Segment *sd = (GF_Segment *) desc;\n\t\t\t\tfprintf(stderr, \"Segment Descriptor: Name: %s - start time %g sec - duration %g sec\\n\", sd->SegmentName, sd->startTime, sd->Duration);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ODF_CC_NAME_TAG:\n\t\t\t{\n\t\t\t\tGF_CC_Name *ccn = (GF_CC_Name *)desc;\n\t\t\t\tfprintf(stderr, \"Content Creators:\\n\");\n\t\t\t\tfor (j=0; j<gf_list_count(ccn->ContentCreators); j++) {\n\t\t\t\t\tGF_ContentCreatorInfo *ci = (GF_ContentCreatorInfo *) gf_list_get(ccn->ContentCreators, j);\n\t\t\t\t\tif (!ci->isUTF8) continue;\n\t\t\t\t\tfprintf(stderr, \"\\t%s\\n\", ci->contentCreatorName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase GF_ODF_SHORT_TEXT_TAG:\n\t\t\t{\n\t\t\t\tGF_ShortTextual *std = (GF_ShortTextual *)desc;\n\t\t\t\tfprintf(stderr, \"Description:\\n\\tEvent: %s\\n\\t%s\\n\", std->eventName, std->eventText);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tswitch (odi.status) {\n\tcase 0:\n\t\tfprintf(stderr, \"Stopped - \");\n\t\tbreak;\n\tcase 1:\n\t\tfprintf(stderr, \"Playing - \");\n\t\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"Paused - \");\n\t\tbreak;\n\tcase 3:\n\t\tfprintf(stderr, \"Not setup yet\\n\");\n\t\treturn;\n\tdefault:\n\t\tfprintf(stderr, \"Setup Failed\\n\");\n\t\treturn;\n\t}\n\tif (odi.buffer>=0) fprintf(stderr, \"Buffer: %d ms - \", odi.buffer);\n\telse fprintf(stderr, \"Not buffering - \");\n\tfprintf(stderr, \"Clock drift: %d ms\\n\", odi.clock_drift);\n\tif (odi.db_unit_count) fprintf(stderr, \"%d AU in DB\\n\", odi.db_unit_count);\n\tif (odi.cb_max_count) fprintf(stderr, \"Composition Buffer: %d CU (%d max)\\n\", odi.cb_unit_count, odi.cb_max_count);\n\tfprintf(stderr, \"\\n\");\n\n\tif (odi.owns_service) {\n\t\tconst char *url;\n\t\tu32 done, total, bps;\n\t\td_enum = 0;\n\t\twhile (gf_term_get_download_info(term, odm, &d_enum, &url, NULL, &done, &total, &bps)) {\n\t\t\tif (d_enum==1) fprintf(stderr, \"Current Downloads in service:\\n\");\n\t\t\tif (done && total) {\n\t\t\t\tfprintf(stderr, \"%s: %d / %d bytes (%.2f %%) - %.2f kBps\\n\", url, done, total, (100.0f*done)/total, ((Float)bps)/1024.0f);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: %.2f kbps\\n\", url, ((Float)8*bps)/1024.0f);\n\t\t\t}\n\t\t}\n\t\tif (!d_enum) fprintf(stderr, \"No Downloads in service\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\td_enum = 0;\n\twhile (gf_term_get_channel_net_info(term, odm, &d_enum, &id, &com, &e)) {\n\t\tif (e) continue;\n\t\tif (!com.bw_down && !com.bw_up) continue;\n\n\t\tfprintf(stderr, \"Stream ID %d statistics:\\n\", id);\n\t\tif (com.multiplex_port) {\n\t\t\tfprintf(stderr, \"\\tMultiplex Port %d - multiplex ID %d\\n\", com.multiplex_port, com.port);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tPort %d\\n\", com.port);\n\t\t}\n\t\tfprintf(stderr, \"\\tPacket Loss Percentage: %.4f\\n\", com.pck_loss_percentage);\n\t\tfprintf(stderr, \"\\tDown Bandwidth: %d bps\\n\", com.bw_down);\n\t\tif (com.bw_up) fprintf(stderr, \"\\tUp Bandwidth: %d bps\\n\", com.bw_up);\n\t\tif (com.ctrl_port) {\n\t\t\tif (com.multiplex_port) {\n\t\t\t\tfprintf(stderr, \"\\tControl Multiplex Port: %d - Control Multiplex ID %d\\n\", com.multiplex_port, com.ctrl_port);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tControl Port: %d\\n\", com.ctrl_port);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tDown Bandwidth: %d bps\\n\", com.ctrl_bw_down);\n\t\t\tfprintf(stderr, \"\\tUp Bandwidth: %d bps\\n\", com.ctrl_bw_up);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid PrintODTiming(GF_Terminal *term, GF_ObjectManager *odm, u32 indent)\n{\n\tGF_MediaInfo odi;\n\tu32 ind = indent;\n\tu32 i, count;\n\tif (!odm) return;\n\n\tif (gf_term_get_object_info(term, odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\twhile (ind) {\n\t\tfprintf(stderr, \" \");\n\t\tind--;\n\t}\n\n\tif (! odi.generated_scene) {\n\n\t\tfprintf(stderr, \"- OD %d: \", odi.od->objectDescriptorID);\n\t\tswitch (odi.status) {\n\t\tcase 1:\n\t\t\tfprintf(stderr, \"Playing - \");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(stderr, \"Paused - \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Stopped - \");\n\t\t\tbreak;\n\t\t}\n\t\tif (odi.buffer>=0) fprintf(stderr, \"Buffer: %d ms - \", odi.buffer);\n\t\telse fprintf(stderr, \"Not buffering - \");\n\t\tfprintf(stderr, \"Clock drift: %d ms\", odi.clock_drift);\n\t\tfprintf(stderr, \" - time: \");\n\t\tPrintTime((u32) (odi.current_time*1000));\n\t\tfprintf(stderr, \"\\n\");\n\n\t} else {\n\t\tfprintf(stderr, \"+ Service %s:\\n\", odi.service_url);\n\t}\n\n\tcount = gf_term_get_object_count(term, odm);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ObjectManager *an_odm = gf_term_get_object(term, odm, i);\n\t\tPrintODTiming(term, an_odm, indent+1);\n\t}\n\treturn;\n\n}\n\nvoid PrintODBuffer(GF_Terminal *term, GF_ObjectManager *odm, u32 indent)\n{\n\tFloat avg_dec_time;\n\tGF_MediaInfo odi;\n\tu32 ind, i, count;\n\tif (!odm) return;\n\n\tif (gf_term_get_object_info(term, odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tind = indent;\n\twhile (ind) {\n\t\tfprintf(stderr, \" \");\n\t\tind--;\n\t}\n\n\tif (odi.generated_scene) {\n\t\tfprintf(stderr, \"+ Service %s:\\n\", odi.service_url);\n\t} else {\n\t\tfprintf(stderr, \"- OD %d: \", odi.od->objectDescriptorID);\n\t\tswitch (odi.status) {\n\t\tcase 1:\n\t\t\tfprintf(stderr, \"Playing\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(stderr, \"Paused\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Stopped\");\n\t\t\tbreak;\n\t\t}\n\t\tif (odi.buffer>=0) fprintf(stderr, \" - Buffer: %d ms\", odi.buffer);\n\t\tif (odi.db_unit_count) fprintf(stderr, \" - DB: %d AU\", odi.db_unit_count);\n\t\tif (odi.cb_max_count) fprintf(stderr, \" - CB: %d/%d CUs\", odi.cb_unit_count, odi.cb_max_count);\n\n\t\tfprintf(stderr, \"\\n\");\n\t\tind = indent;\n\t\twhile (ind) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tind--;\n\t\t}\n\n\t\tfprintf(stderr, \" %d decoded frames - %d dropped frames\\n\", odi.nb_dec_frames, odi.nb_dropped);\n\n\t\tind = indent;\n\t\twhile (ind) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tind--;\n\t\t}\n\n\t\tavg_dec_time = 0;\n\t\tif (odi.nb_dec_frames) {\n\t\t\tavg_dec_time = (Float) odi.total_dec_time;\n\t\t\tavg_dec_time /= odi.nb_dec_frames;\n\t\t}\n\t\tfprintf(stderr, \" Avg Bitrate %d kbps (%d max) - Avg Decoding Time %.2f us (%d max)\\n\",\n\t\t        (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, avg_dec_time, odi.max_dec_time);\n\t}\n\n\tcount = gf_term_get_object_count(term, odm);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ObjectManager *an_odm = gf_term_get_object(term, odm, i);\n\t\tPrintODBuffer(term, an_odm, indent+1);\n\t}\n\n}\n\nvoid ViewODs(GF_Terminal *term, Bool show_timing)\n{\n\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\tif (!root_odm) return;\n\n\tif (show_timing) {\n\t\tPrintODTiming(term, root_odm, 0);\n\t} else {\n\t\tPrintODBuffer(term, root_odm, 0);\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\n\nvoid PrintGPACConfig()\n{\n\tu32 i, j, cfg_count, key_count;\n\tchar szName[200];\n\tchar *secName = NULL;\n\n\tfprintf(stderr, \"Enter section name (\\\"*\\\" for complete dump):\\n\");\n\tif (1 > scanf(\"%s\", szName)) {\n\t\tfprintf(stderr, \"No section name, aborting.\\n\");\n\t\treturn;\n\t}\n\tif (strcmp(szName, \"*\")) secName = szName;\n\n\tfprintf(stderr, \"\\n\\n*** GPAC Configuration ***\\n\\n\");\n\n\tcfg_count = gf_cfg_get_section_count(cfg_file);\n\tfor (i=0; i<cfg_count; i++) {\n\t\tconst char *sec = gf_cfg_get_section_name(cfg_file, i);\n\t\tif (secName) {\n\t\t\tif (stricmp(sec, secName)) continue;\n\t\t} else {\n\t\t\tif (!stricmp(sec, \"General\")) continue;\n\t\t\tif (!stricmp(sec, \"MimeTypes\")) continue;\n\t\t\tif (!stricmp(sec, \"RecentFiles\")) continue;\n\t\t}\n\t\tfprintf(stderr, \"[%s]\\n\", sec);\n\t\tkey_count = gf_cfg_get_key_count(cfg_file, sec);\n\t\tfor (j=0; j<key_count; j++) {\n\t\t\tconst char *key = gf_cfg_get_key_name(cfg_file, sec, j);\n\t\t\tconst char *val = gf_cfg_get_key(cfg_file, sec, key);\n\t\t\tfprintf(stderr, \"%s=%s\\n\", key, val);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / FFMPEG module\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"ffmpeg_in.h\"\n\n#ifndef DISABLE_FFMPEG_DEMUX\n\n/*default buffer is 200 ms per channel*/\n#define FFD_DATA_BUFFER\t\t800\n\n//#define FFMPEG_DEMUX_ENABLE_MPEG2TS\n\n//#if defined(__DARWIN__) || defined(__APPLE__)\n#if !defined(WIN32) && !defined(_WIN32_WCE) && !defined(__SYMBIAN32__)\n#include <errno.h>\n#endif\n\n/**\n * New versions of ffmpeg do not declare AVERROR_NOMEM, AVERROR_IO, AVERROR_NOFMT\n */\n\n#ifndef AVERROR_NOMEM\n#define AVERROR_NOMEM AVERROR(ENOMEM)\n#endif /* AVERROR_NOMEM */\n\n#ifndef AVERROR_IO\n#define AVERROR_IO AVERROR(EIO)\n#endif /* AVERROR_IO */\n\n#ifndef AVERROR_NOFMT\n#define AVERROR_NOFMT AVERROR(EINVAL)\n#endif /* AVERROR_NOFMT */\n\n\n#if ((LIBAVFORMAT_VERSION_MAJOR == 54) && (LIBAVFORMAT_VERSION_MINOR >= 20)) || (LIBAVFORMAT_VERSION_MAJOR > 54)\n\n#define av_find_stream_info(__c)\tavformat_find_stream_info(__c, NULL)\n#define USE_AVFORMAT_OPEN_INPUT\t1\n#endif\n\n\n#if defined(GPAC_ANDROID) && (LIBAVFORMAT_VERSION_MAJOR <= 52)\n\n#ifndef FF_API_CLOSE_INPUT_FILE\n#define FF_API_CLOSE_INPUT_FILE\t1\n#endif\n\n#endif\n\n\n\nstatic u32 FFDemux_Run(void *par)\n{\n\tAVPacket pkt;\n\ts64 seek_to;\n\tGF_NetworkCommand com;\n\tGF_NetworkCommand map;\n\tGF_SLHeader slh;\n\tFFDemux *ffd = (FFDemux *) par;\n\n\tmemset(&map, 0, sizeof(GF_NetworkCommand));\n\tmap.command_type = GF_NET_CHAN_MAP_TIME;\n\n\tmemset(&com, 0, sizeof(GF_NetworkCommand));\n\tcom.command_type = GF_NET_BUFFER_QUERY;\n\n\tmemset(&slh, 0, sizeof(GF_SLHeader));\n\n\tslh.compositionTimeStampFlag = slh.decodingTimeStampFlag = 1;\n\n\twhile (ffd->is_running) {\n\t\t//nothing connected, wait\n\t\tif (!ffd->video_ch && !ffd->audio_ch) {\n\t\t\tgf_sleep(100);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((ffd->seek_time>=0) && ffd->seekable) {\n\t\t\tseek_to = (s64) (AV_TIME_BASE*ffd->seek_time);\n\t\t\tav_seek_frame(ffd->ctx, -1, seek_to, AVSEEK_FLAG_BACKWARD);\n\t\t\tffd->seek_time = -1;\n\t\t}\n\t\tpkt.stream_index = -1;\n\t\t/*EOF*/\n\t\tif (av_read_frame(ffd->ctx, &pkt) <0) break;\n\t\tif (pkt.pts == AV_NOPTS_VALUE) pkt.pts = pkt.dts;\n\t\tif (!pkt.dts) pkt.dts = pkt.pts;\n\n\t\tslh.compositionTimeStamp = pkt.pts;\n\t\tslh.decodingTimeStamp = pkt.dts;\n\n\t\tgf_mx_p(ffd->mx);\n\t\t/*blindly send audio as soon as video is init*/\n\t\tif (ffd->audio_ch && (pkt.stream_index == ffd->audio_st) ) {\n\t\t\tslh.compositionTimeStamp *= ffd->audio_tscale.num;\n\t\t\tslh.decodingTimeStamp *= ffd->audio_tscale.num;\n\n\t\t\tgf_service_send_packet(ffd->service, ffd->audio_ch, (char *) pkt.data, pkt.size, &slh, GF_OK);\n\t\t}\n\t\telse if (ffd->video_ch && (pkt.stream_index == ffd->video_st)) {\n\t\t\tslh.compositionTimeStamp *= ffd->video_tscale.num;\n\t\t\tslh.decodingTimeStamp *= ffd->video_tscale.num;\n\t\t\tslh.randomAccessPointFlag = pkt.flags&AV_PKT_FLAG_KEY ? 1 : 0;\n\t\t\tgf_service_send_packet(ffd->service, ffd->video_ch, (char *) pkt.data, pkt.size, &slh, GF_OK);\n\t\t}\n\t\tgf_mx_v(ffd->mx);\n\t\tav_free_packet(&pkt);\n\n\t\t/*sleep untill the buffer occupancy is too low - note that this work because all streams in this\n\t\tdemuxer are synchronized*/\n\t\twhile (ffd->audio_run || ffd->video_run) {\n\t\t\tgf_service_command(ffd->service, &com, GF_OK);\n\t\t\tif (com.buffer.occupancy < com.buffer.max)\n\t\t\t\tbreak;\n\n\t\t\tgf_sleep(1);\n\t\t}\n\n\t\tif (!ffd->audio_run && !ffd->video_run) break;\n\t}\n\t/*signal EOS*/\n\tif (ffd->audio_ch) gf_service_send_packet(ffd->service, ffd->audio_ch, NULL, 0, NULL, GF_EOS);\n\tif (ffd->video_ch) gf_service_send_packet(ffd->service, ffd->video_ch, NULL, 0, NULL, GF_EOS);\n\tffd->is_running = 2;\n\n\treturn 0;\n}\n\nstatic const char * FFD_MIME_TYPES[] = {\n\t\"video/x-mpeg\", \"mpg mpeg mp2 mpa mpe mpv2\", \"MPEG 1/2 Movies\",\n\t\"video/x-mpeg-systems\", \"mpg mpeg mp2 mpa mpe mpv2\", \"MPEG 1/2 Movies\",\n\t\"audio/basic\", \"snd au\", \"Basic Audio\",\n\t\"audio/x-wav\", \"wav\", \"WAV Audio\",\n\t\"audio/vnd.wave\", \"wav\", \"WAV Audio\",\n\t\"video/x-ms-asf\", \"asf wma wmv asx asr\", \"WindowsMedia Movies\",\n\t\"video/x-ms-wmv\", \"asf wma wmv asx asr\", \"WindowsMedia Movies\",\n\t\"video/x-msvideo\", \"avi\", \"AVI Movies\",\n\t\"video/x-ms-video\", \"avi\", \"AVI Movies\",\n\t\"video/avi\", \"avi\", \"AVI Movies\",\n\t\"video/vnd.avi\", \"avi\", \"AVI Movies\",\n\t\"video/H263\", \"h263 263\", \"H263 Video\",\n\t\"video/H264\", \"h264 264\", \"H264 Video\",\n\t\"video/MPEG4\", \"cmp\", \"MPEG-4 Video\",\n\t/* We let ffmpeg handle mov because some QT files with uncompressed or adpcm audio use 1 audio sample\n\t   per MP4 sample which is a killer for our MP4 lib, whereas ffmpeg handles these as complete audio chunks\n\t   moreover ffmpeg handles cmov, we don't */\n\t\"video/quicktime\", \"mov qt\", \"QuickTime Movies\",\n\t/* Supported by latest versions of FFMPEG */\n\t\"video/webm\", \"webm\", \"Google WebM Movies\",\n\t\"audio/webm\", \"webm\", \"Google WebM Music\",\n#ifdef FFMPEG_DEMUX_ENABLE_MPEG2TS\n\t\"video/mp2t\", \"ts\", \"MPEG 2 TS\",\n#endif\n\tNULL\n};\n\nstatic u32 FFD_RegisterMimeTypes(const GF_InputService *plug) {\n\tu32 i;\n\tfor (i = 0 ; FFD_MIME_TYPES[i]; i+=3)\n\t\tgf_service_register_mime(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2]);\n\treturn i/3;\n}\n\nstatic int open_file(AVFormatContext **\tic_ptr, const char * \tfilename, AVInputFormat * \tfmt, void *ops) {\n#ifdef USE_PRE_0_7\n\treturn av_open_input_file(ic_ptr, filename, fmt, 0, NULL);\n#else\n\treturn avformat_open_input(ic_ptr, filename, fmt, (AVDictionary**)ops);\n#endif\n}\n\nvoid ffd_parse_options(FFDemux *ffd, const char *url)\n{\n#ifdef USE_AVFORMAT_OPEN_INPUT\n\tint res;\n\tchar *frag = (char*) strchr(url, '#');\n\tif (frag) frag = frag+1;\n\n\tif (ffd->options) return;\n\n\twhile (frag) {\n\t\tchar *mid, *sep = strchr(frag, ':');\n\t\tif (sep) sep[0] = 0;\n\t\tmid = strchr(frag, '=');\n\t\tif (mid) {\n\t\t\tmid[0] = 0;\n\t\t\tres = av_dict_set(&ffd->options, frag, mid+1, 0);\n\t\t\tif (res<0) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] Failed to set option %s:%s\\n\", frag, mid+1) );\n\t\t\t}\n\t\t\tmid[0] = '=';\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0] = ':';\n\t\tfrag = sep+1;\n\t}\n#endif\n}\n\n\nstatic Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)\n{\n\tBool has_audio, has_video;\n\ts32 i;\n\tAVFormatContext *ctx;\n\tAVOutputFormat *fmt_out;\n\tBool ret = GF_FALSE;\n\tchar *ext, szName[1024], szExt[20];\n\tconst char *szExtList;\n\tFFDemux *ffd;\n\tif (!plug || !url)\n\t\treturn GF_FALSE;\n\t/*disable RTP/RTSP from ffmpeg*/\n\tif (!strnicmp(url, \"rtsp://\", 7)) return GF_FALSE;\n\tif (!strnicmp(url, \"rtspu://\", 8)) return GF_FALSE;\n\tif (!strnicmp(url, \"rtp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"plato://\", 8)) return GF_FALSE;\n\tif (!strnicmp(url, \"udp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"tcp://\", 6)) return GF_FALSE;\n\tif (!strnicmp(url, \"data:\", 5)) return GF_FALSE;\n\n\tffd = (FFDemux*)plug->priv;\n\n\tif (strlen(url) >= sizeof(szName))\n\t\treturn GF_FALSE;\n\n\tstrcpy(szName, url);\n\text = strrchr(szName, '#');\n\tif (ext) ext[0] = 0;\n\text = strrchr(szName, '?');\n\tif (ext) ext[0] = 0;\n\n\text = strrchr(szName, '.');\n\tif (ext && strlen(ext) > 19) ext = NULL;\n\n\tif (ext && strlen(ext) > 1 && strlen(ext) <= sizeof(szExt)) {\n\t\tstrcpy(szExt, &ext[1]);\n\t\tstrlwr(szExt);\n#ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS\n\t\tif (strstr(\"ts m2t mts dmb trp\", szExt) ) return GF_FALSE;\n#endif\n\n\t\t/*note we forbid ffmpeg to handle files we support*/\n\t\tif (!strcmp(szExt, \"mp4\") || !strcmp(szExt, \"mpg4\") || !strcmp(szExt, \"m4a\") || !strcmp(szExt, \"m21\")\n\t\t        || !strcmp(szExt, \"m4v\") || !strcmp(szExt, \"m4a\")\n\t\t        || !strcmp(szExt, \"m4s\") || !strcmp(szExt, \"3gs\")\n\t\t        || !strcmp(szExt, \"3gp\") || !strcmp(szExt, \"3gpp\") || !strcmp(szExt, \"3gp2\") || !strcmp(szExt, \"3g2\")\n\t\t        || !strcmp(szExt, \"mp3\")\n\t\t        || !strcmp(szExt, \"ac3\")\n\t\t        || !strcmp(szExt, \"amr\")\n\t\t        || !strcmp(szExt, \"bt\") || !strcmp(szExt, \"wrl\") || !strcmp(szExt, \"x3dv\")\n\t\t        || !strcmp(szExt, \"xmt\") || !strcmp(szExt, \"xmta\") || !strcmp(szExt, \"x3d\")\n\n\t\t        || !strcmp(szExt, \"jpg\") || !strcmp(szExt, \"jpeg\") || !strcmp(szExt, \"png\")\n\t\t   ) return GF_FALSE;\n\n\t\t/*check any default stuff that should work with ffmpeg*/\n\t\t{\n\t\t\tu32 i;\n\t\t\tfor (i = 0 ; FFD_MIME_TYPES[i]; i+=3) {\n\t\t\t\tif (gf_service_check_mime_register(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2], ext))\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tffd_parse_options(ffd, url);\n\n\tctx = NULL;\n\tif (open_file(&ctx, szName, NULL, ffd->options ? &ffd->options : NULL)<0) {\n\t\tAVInputFormat *av_in = NULL;\n\t\t/*some extensions not supported by ffmpeg*/\n\t\tif (ext && !strcmp(szExt, \"cmp\")) av_in = av_find_input_format(\"m4v\");\n\n\t\tif (open_file(&ctx, szName, av_in, ffd->options ? &ffd->options : NULL)<0) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\tif (!ctx) goto exit;\n\tif (av_find_stream_info(ctx) <0) goto exit;\n\n\t/*figure out if we can use codecs or not*/\n\thas_video = has_audio = GF_FALSE;\n\tfor(i = 0; i < (s32)ctx->nb_streams; i++) {\n\t\tAVCodecContext *enc = ctx->streams[i]->codec;\n\t\tswitch(enc->codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tif (!has_audio) has_audio = GF_TRUE;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tif (!has_video) has_video= GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!has_audio && !has_video) goto exit;\n\tret = GF_TRUE;\n#if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52)\n\tfmt_out = guess_stream_format(NULL, url, NULL);\n#else\n\tfmt_out = av_guess_format(NULL, url, NULL);\n#endif\n\tif (fmt_out) gf_service_register_mime(plug, fmt_out->mime_type, fmt_out->extensions, fmt_out->name);\n\telse {\n\t\text = strrchr(szName, '.');\n\t\tif (ext) {\n\t\t\tstrcpy(szExt, &ext[1]);\n\t\t\tstrlwr(szExt);\n\n\t\t\tszExtList = gf_modules_get_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\");\n\t\t\tif (!szExtList) {\n\t\t\t\tgf_service_register_mime(plug, \"application/x-ffmpeg\", szExt, \"Other Movies (FFMPEG)\");\n\t\t\t} else if (!strstr(szExtList, szExt)) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *buf;\n\t\t\t\tlen = (u32) (strlen(szExtList) + strlen(szExt) + 10);\n\t\t\t\tbuf = (char*)gf_malloc(sizeof(char)*len);\n\t\t\t\tsprintf(buf, \"\\\"%s \", szExt);\n\t\t\t\tstrcat(buf, &szExtList[1]);\n\t\t\t\tgf_modules_set_option((GF_BaseInterface *)plug, \"MimeTypes\", \"application/x-ffmpeg\", buf);\n\t\t\t\tgf_free(buf);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n#if FF_API_CLOSE_INPUT_FILE\n\tif (ctx) av_close_input_file(ctx);\n#else\n\tif (ctx) avformat_close_input(&ctx);\n#endif\n\treturn ret;\n}\n\nstatic GF_ESD *FFD_GetESDescriptor(FFDemux *ffd, Bool for_audio)\n{\n\tGF_BitStream *bs;\n\tBool dont_use_sl;\n\tGF_ESD *esd = (GF_ESD *) gf_odf_desc_esd_new(0);\n\tesd->ESID = 1 + (for_audio ? ffd->audio_st : ffd->video_st);\n\tesd->decoderConfig->streamType = for_audio ? GF_STREAM_AUDIO : GF_STREAM_VISUAL;\n\tesd->decoderConfig->avgBitrate = esd->decoderConfig->maxBitrate = 0;\n\n\t/*remap std object types - depending on input formats, FFMPEG may not have separate DSI from initial frame.\n\tIn this case we have no choice but using FFMPEG decoders*/\n\tif (for_audio) {\n\t\tAVCodecContext *dec = ffd->ctx->streams[ffd->audio_st]->codec;\n\t\tesd->slConfig->timestampResolution = ffd->audio_tscale.den;\n\t\tswitch (dec->codec_id) {\n\t\tcase CODEC_ID_MP2:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_MPEG1;\n\t\t\tbreak;\n\t\tcase CODEC_ID_MP3:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_MPEG2_PART3;\n\t\t\tbreak;\n\t\tcase CODEC_ID_AAC:\n\t\t\tif (!dec->extradata_size) goto opaque_audio;\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = dec->extradata_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = (char*)gf_malloc(sizeof(char)*dec->extradata_size);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data,\n\t\t\t       dec->extradata,\n\t\t\t       sizeof(char)*dec->extradata_size);\n\t\t\tbreak;\n\t\tdefault:\nopaque_audio:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_FFMPEG;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, dec->codec_id);\n\t\t\tgf_bs_write_u32(bs, dec->sample_rate);\n\t\t\tgf_bs_write_u16(bs, dec->channels);\n\t\t\tgf_bs_write_u16(bs, dec->frame_size);\n\t\t\tgf_bs_write_u8(bs, 16);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t/*ffmpeg specific*/\n\t\t\tgf_bs_write_u16(bs, dec->block_align);\n\t\t\tgf_bs_write_u32(bs, dec->bit_rate);\n\t\t\tgf_bs_write_u32(bs, dec->codec_tag);\n\t\t\tif (dec->extradata_size) {\n\t\t\t\tgf_bs_write_data(bs, (char *) dec->extradata, dec->extradata_size);\n\t\t\t}\n\t\t\tgf_bs_get_content(bs, (char **) &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\t}\n\t\tdont_use_sl = ffd->unreliable_audio_timing;\n\t} else {\n\t\tAVCodecContext *dec = ffd->ctx->streams[ffd->video_st]->codec;\n\t\tesd->slConfig->timestampResolution = ffd->video_tscale.den;\n\t\tswitch (dec->codec_id) {\n\t\tcase CODEC_ID_MPEG4:\n\t\t\t/*there is a bug in fragmentation of raw H264 in ffmpeg, the NALU startcode (0x00000001) is split across\n\t\t\ttwo frames - we therefore force internal ffmpeg codec ID to avoid NALU size recompute\n\t\t\tat the decoder level*/\n//\t\tcase CODEC_ID_H264:\n\t\t\t/*if dsi not detected force use ffmpeg*/\n\t\t\tif (!dec->extradata_size) goto opaque_video;\n\t\t\t/*otherwise use any MPEG-4 Visual*/\n\t\t\tesd->decoderConfig->objectTypeIndication = (dec->codec_id==CODEC_ID_H264) ? GPAC_OTI_VIDEO_AVC : GPAC_OTI_VIDEO_MPEG4_PART2;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = dec->extradata_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = (char*)gf_malloc(sizeof(char)*dec->extradata_size);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data,\n\t\t\t       dec->extradata,\n\t\t\t       sizeof(char)*dec->extradata_size);\n\t\t\tbreak;\n\t\tcase CODEC_ID_MPEG1VIDEO:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MPEG1;\n\t\t\tbreak;\n\t\tcase CODEC_ID_MPEG2VIDEO:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MPEG2_MAIN;\n\t\t\tbreak;\n\n\t\tcase CODEC_ID_H263:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_GENERIC;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, GF_4CC('s', '2', '6', '3') );\n\t\t\tgf_bs_write_u16(bs, dec->width);\n\t\t\tgf_bs_write_u16(bs, dec->height);\n\t\t\tgf_bs_get_content(bs, (char **) &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\tdefault:\nopaque_video:\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_FFMPEG;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, dec->codec_id);\n\t\t\tgf_bs_write_u16(bs, dec->width);\n\t\t\tgf_bs_write_u16(bs, dec->height);\n\t\t\t/*ffmpeg specific*/\n\t\t\tgf_bs_write_u32(bs, dec->bit_rate);\n\t\t\tgf_bs_write_u32(bs, dec->codec_tag);\n\t\t\tgf_bs_write_u32(bs, dec->pix_fmt);\n\n\t\t\tif (dec->extradata_size) {\n\t\t\t\tgf_bs_write_data(bs, (char *) dec->extradata, dec->extradata_size);\n\t\t\t}\n\t\t\tgf_bs_get_content(bs, (char **) &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\t}\n\t\tdont_use_sl = GF_FALSE;\n\t}\n\n\tif (dont_use_sl) {\n\t\tesd->slConfig->predefined = SLPredef_SkipSL;\n\t} else {\n\t\t/*only send full AUs*/\n\t\tesd->slConfig->useAccessUnitStartFlag = esd->slConfig->useAccessUnitEndFlag = 0;\n\t\tif (for_audio) {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\t} else {\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 1;\n\t\t}\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t}\n\n\treturn esd;\n}\n\n\nstatic void FFD_SetupObjects(FFDemux *ffd)\n{\n\tGF_ESD *esd;\n\tGF_ObjectDescriptor *od;\n\tu32 audio_esid = 0;\n\n\tif ((ffd->audio_st>=0) && (ffd->service_type != 1)) {\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tesd = FFD_GetESDescriptor(ffd, GF_TRUE);\n\t\tod->objectDescriptorID = esd->ESID;\n\t\taudio_esid = esd->ESID;\n\t\tgf_list_add(od->ESDescriptors, esd);\n\t\tgf_service_declare_media(ffd->service, (GF_Descriptor*)od, (ffd->video_st>=0) ? GF_TRUE : GF_FALSE);\n\t}\n\tif ((ffd->video_st>=0) && (ffd->service_type != 2)) {\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tesd = FFD_GetESDescriptor(ffd, GF_FALSE);\n\t\tod->objectDescriptorID = esd->ESID;\n\t\tesd->OCRESID = audio_esid;\n\t\tgf_list_add(od->ESDescriptors, esd);\n\t\tgf_service_declare_media(ffd->service, (GF_Descriptor*)od, GF_FALSE);\n\t}\n}\n\n#ifdef USE_PRE_0_7\nstatic int ff_url_read(void *h, unsigned char *buf, int size)\n{\n\tu32 retry = 10;\n\tu32 read;\n\tint full_size;\n\tFFDemux *ffd = (FFDemux *)h;\n\n\tfull_size = 0;\n\tif (ffd->buffer_used) {\n\t\tif (ffd->buffer_used >= (u32) size) {\n\t\t\tffd->buffer_used-=size;\n\t\t\tmemcpy(ffd->buffer, ffd->buffer+size, sizeof(char)*ffd->buffer_used);\n#ifdef FFMPEG_DUMP_REMOTE\n\t\t\tif (ffd->outdbg) gf_fwrite(buf, size, 1, ffd->outdbg);\n#endif\n\t\t\treturn size;\n\t\t}\n\t\tfull_size += ffd->buffer_used;\n\t\tbuf += ffd->buffer_used;\n\t\tsize -= ffd->buffer_used;\n\t\tffd->buffer_used = 0;\n\t}\n\n\twhile (size) {\n\t\tGF_Err e = gf_dm_sess_fetch_data(ffd->dnload, buf, size, &read);\n\t\tif (e==GF_EOS) break;\n\t\t/*we're sync!!*/\n\t\tif (e==GF_IP_NETWORK_EMPTY) {\n\t\t\tif (!retry) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] timeout fetching bytes from network\\n\") );\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tretry --;\n\t\t\tgf_sleep(100);\n\t\t\tcontinue;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] error fetching bytes from network: %s\\n\", gf_error_to_string(e) ) );\n\t\t\treturn -1;\n\t\t}\n\t\tfull_size += read;\n\t\tif (read==size) break;\n\t\tsize -= read;\n\t\tbuf += read;\n\t}\n#ifdef FFMPEG_DUMP_REMOTE\n\tif (ffd->outdbg) gf_fwrite(ffd->buffer, full_size, 1, ffd->outdbg);\n#endif\n\treturn full_size ? (int) full_size : -1;\n}\n#endif /*USE_PRE_0_7*/\n\n\nstatic GF_Err FFD_ConnectService(GF_InputService *plug, GF_ClientService *serv, const char *url)\n{\n\tGF_Err e;\n\ts64 last_aud_pts;\n\tu32 i;\n\ts32 res;\n\tBool is_local;\n\tconst char *sOpt;\n\tchar *ext, szName[1024];\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\tAVInputFormat *av_in = NULL;\n\tchar szExt[20];\n\n\tif (ffd->ctx) return GF_SERVICE_ERROR;\n\n\tassert( url && strlen(url) < 1024);\n\tstrcpy(szName, url);\n\text = strrchr(szName, '#');\n\tffd->service_type = 0;\n\tffd->service = serv;\n\n\tif (ext) {\n\t\tif (!stricmp(&ext[1], \"video\")) ffd->service_type = 1;\n\t\telse if (!stricmp(&ext[1], \"audio\")) ffd->service_type = 2;\n\t\text[0] = 0;\n\t}\n\n\tffd_parse_options(ffd, url);\n\n\t/*some extensions not supported by ffmpeg, overload input format*/\n\text = strrchr(szName, '.');\n\tstrcpy(szExt, ext ? ext+1 : \"\");\n\tstrlwr(szExt);\n\tif (!strcmp(szExt, \"cmp\")) av_in = av_find_input_format(\"m4v\");\n\n\tis_local = (strnicmp(url, \"file://\", 7) && strstr(url, \"://\")) ? GF_FALSE : GF_TRUE;\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[FFMPEG] opening file %s - local %d - av_in %08x\\n\", url, is_local, av_in));\n\n\tif (!is_local) {\n\t\tAVProbeData   pd;\n\n\t\t/*setup wraper for FFMPEG I/O*/\n\t\tffd->buffer_size = 8192;\n\t\tsOpt = gf_modules_get_option((GF_BaseInterface *)plug, \"FFMPEG\", \"IOBufferSize\");\n\t\tif (sOpt) ffd->buffer_size = atoi(sOpt);\n\t\tffd->buffer = (char*)gf_malloc(sizeof(char)*ffd->buffer_size);\n#ifdef FFMPEG_DUMP_REMOTE\n\t\tffd->outdbg = gf_fopen(\"ffdeb.raw\", \"wb\");\n#endif\n#ifdef USE_PRE_0_7\n\t\tinit_put_byte(&ffd->io, ffd->buffer, ffd->buffer_size, 0, ffd, ff_url_read, NULL, NULL);\n\t\tffd->io.is_streamed = 1;\n#else\n\t\tffd->io.seekable = 1;\n#endif\n\n\t\tffd->dnload = gf_service_download_new(ffd->service, url, GF_NETIO_SESSION_NOT_THREADED  | GF_NETIO_SESSION_NOT_CACHED, NULL, ffd);\n\t\tif (!ffd->dnload) return GF_URL_ERROR;\n\t\twhile (1) {\n\t\t\tu32 read;\n\t\t\te = gf_dm_sess_fetch_data(ffd->dnload, ffd->buffer + ffd->buffer_used, ffd->buffer_size - ffd->buffer_used, &read);\n\t\t\tif (e==GF_EOS) break;\n\t\t\t/*we're sync!!*/\n\t\t\tif (e==GF_IP_NETWORK_EMPTY) continue;\n\t\t\tif (e) goto err_exit;\n\t\t\tffd->buffer_used += read;\n\t\t\tif (ffd->buffer_used == ffd->buffer_size) break;\n\t\t}\n\t\tif (e==GF_EOS) {\n\t\t\tconst char *cache_file = gf_dm_sess_get_cache_name(ffd->dnload);\n\t\t\tres = open_file(&ffd->ctx, cache_file, av_in, ffd->options ? &ffd->options : NULL);\n\t\t} else {\n\t\t\tpd.filename = szName;\n\t\t\tpd.buf_size = ffd->buffer_used;\n\t\t\tpd.buf = (u8 *) ffd->buffer;\n\t\t\tav_in = av_probe_input_format(&pd, 1);\n\t\t\tif (!av_in) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG] error probing file %s - probe start with %c %c %c %c\\n\", url, ffd->buffer[0], ffd->buffer[1], ffd->buffer[2], ffd->buffer[3]));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\t/*setup downloader*/\n\t\t\tav_in->flags |= AVFMT_NOFILE;\n#ifdef USE_AVFORMAT_OPEN_INPUT /*commit ffmpeg 603b8bc2a109978c8499b06d2556f1433306eca7*/\n\t\t\tres = avformat_open_input(&ffd->ctx, szName, av_in, NULL);\n#else\n\t\t\tres = av_open_input_stream(&ffd->ctx, &ffd->io, szName, av_in, NULL);\n#endif\n\t\t}\n\t} else {\n\t\tres = open_file(&ffd->ctx, szName, av_in, ffd->options ? &ffd->options : NULL);\n\t}\n\n\tswitch (res) {\n#ifndef _WIN32_WCE\n\tcase 0:\n\t\te = GF_OK;\n\t\tbreak;\n\tcase AVERROR_IO:\n\t\te = GF_URL_ERROR;\n\t\tgoto err_exit;\n\tcase AVERROR_INVALIDDATA:\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto err_exit;\n\tcase AVERROR_NOMEM:\n\t\te = GF_OUT_OF_MEM;\n\t\tgoto err_exit;\n\tcase AVERROR_NOFMT:\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto err_exit;\n#endif\n\tdefault:\n\t\te = GF_SERVICE_ERROR;\n\t\tgoto err_exit;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[FFMPEG] looking for streams in %s - %d streams - type %s\\n\", ffd->ctx->filename, ffd->ctx->nb_streams, ffd->ctx->iformat->name));\n\n#ifdef USE_AVFORMAT_OPEN_INPUT\n\tres = avformat_find_stream_info(ffd->ctx, ffd->options ? &ffd->options : NULL);\n#else\n\tres = av_find_stream_info(ffd->ctx);\n#endif\n\n\tif (res <0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG] cannot locate streams - error %d\\n\", res));\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto err_exit;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[FFMPEG] file %s opened - %d streams\\n\", url, ffd->ctx->nb_streams));\n\n\t/*figure out if we can use codecs or not*/\n\tffd->audio_st = ffd->video_st = -1;\n\tfor (i = 0; i < ffd->ctx->nb_streams; i++) {\n\t\tAVCodecContext *enc = ffd->ctx->streams[i]->codec;\n\t\tswitch(enc->codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tif ((ffd->audio_st<0) && (ffd->service_type!=1)) {\n\t\t\t\tffd->audio_st = i;\n\t\t\t\tffd->audio_tscale = ffd->ctx->streams[i]->time_base;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tif ((ffd->video_st<0) && (ffd->service_type!=2)) {\n\t\t\t\tffd->video_st = i;\n\t\t\t\tffd->video_tscale = ffd->ctx->streams[i]->time_base;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((ffd->service_type==1) && (ffd->video_st<0)) goto err_exit;\n\tif ((ffd->service_type==2) && (ffd->audio_st<0)) goto err_exit;\n\tif ((ffd->video_st<0) && (ffd->audio_st<0)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG] No supported streams in file\\n\"));\n\t\tgoto err_exit;\n\t}\n\n\n\tsOpt = gf_modules_get_option((GF_BaseInterface *)plug, \"FFMPEG\", \"DataBufferMS\");\n\tffd->data_buffer_ms = 0;\n\tif (sOpt) ffd->data_buffer_ms = atoi(sOpt);\n\tif (!ffd->data_buffer_ms) ffd->data_buffer_ms = FFD_DATA_BUFFER;\n\n\t/*build seek*/\n\tif (is_local) {\n\t\t/*check we do have increasing pts. If not we can't rely on pts, we must skip SL\n\t\twe assume video pts is always present*/\n\t\tif (ffd->audio_st>=0) {\n\t\t\tlast_aud_pts = 0;\n\t\t\tfor (i=0; i<20; i++) {\n\t\t\t\tAVPacket pkt;\n\t\t\t\tpkt.stream_index = -1;\n\t\t\t\tif (av_read_frame(ffd->ctx, &pkt) <0) break;\n\t\t\t\tif (pkt.pts == AV_NOPTS_VALUE) pkt.pts = pkt.dts;\n\t\t\t\tif (pkt.stream_index==ffd->audio_st) last_aud_pts = pkt.pts;\n\t\t\t}\n\t\t\tif (last_aud_pts*ffd->audio_tscale.den<10*ffd->audio_tscale.num) ffd->unreliable_audio_timing = GF_TRUE;\n\t\t}\n\n\t\tffd->seekable = (av_seek_frame(ffd->ctx, -1, 0, AVSEEK_FLAG_BACKWARD)<0) ? GF_FALSE : GF_TRUE;\n\t\tif (!ffd->seekable) {\n#if FF_API_CLOSE_INPUT_FILE\n\t\t\tav_close_input_file(ffd->ctx);\n#else\n\t\t\tavformat_close_input(&ffd->ctx);\n#endif\n\t\t\tffd->ctx = NULL;\n\t\t\topen_file(&ffd->ctx, szName, av_in, ffd->options ? &ffd->options : NULL);\n\t\t\tav_find_stream_info(ffd->ctx);\n\t\t}\n\t}\n\n\t/*let's go*/\n\tgf_service_connect_ack(serv, NULL, GF_OK);\n\t/*if (!ffd->service_type)*/ FFD_SetupObjects(ffd);\n\tffd->service_type = 0;\n\treturn GF_OK;\n\nerr_exit:\n\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[FFMPEG] Error opening file %s: %s\\n\", url, gf_error_to_string(e)));\n#if FF_API_CLOSE_INPUT_FILE\n\tif (ffd->ctx) av_close_input_file(ffd->ctx);\n#else\n\tif (ffd->ctx) avformat_close_input(&ffd->ctx);\n#endif\n\tffd->ctx = NULL;\n\tgf_service_connect_ack(serv, NULL, e);\n\treturn e;\n}\n\n\nstatic GF_Descriptor *FFD_GetServiceDesc(GF_InputService *plug, u32 expect_type, const char *sub_url)\n{\n\tGF_ObjectDescriptor *od;\n\tGF_ESD *esd;\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\tif (!ffd->ctx) return NULL;\n\n\tif (expect_type==GF_MEDIA_OBJECT_UNDEF) {\n\t\tif (ffd->video_st>=0) expect_type=GF_MEDIA_OBJECT_VIDEO;\n\t\telse if (ffd->audio_st>=0) expect_type=GF_MEDIA_OBJECT_AUDIO;\n\t}\n\n\n\t/*since we don't handle multitrack in ffmpeg, we don't need to check sub_url, only use expected type*/\n\tif (expect_type==GF_MEDIA_OBJECT_AUDIO) {\n\t\tif (ffd->audio_st<0) return NULL;\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tod->objectDescriptorID = 1;\n\t\tesd = FFD_GetESDescriptor(ffd, GF_TRUE);\n\t\t/*if session join, setup sync*/\n\t\tif (ffd->video_ch) esd->OCRESID = ffd->video_st+1;\n\t\tgf_list_add(od->ESDescriptors, esd);\n\t\tffd->service_type = 2;\n\t\treturn (GF_Descriptor *) od;\n\t}\n\tif (expect_type==GF_MEDIA_OBJECT_VIDEO) {\n\t\tif (ffd->video_st<0) return NULL;\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tod->objectDescriptorID = 1;\n\t\tesd = FFD_GetESDescriptor(ffd, GF_FALSE);\n\t\t/*if session join, setup sync*/\n\t\tif (ffd->audio_ch) esd->OCRESID = ffd->audio_st+1;\n\t\tgf_list_add(od->ESDescriptors, esd);\n\t\tffd->service_type = 1;\n\t\treturn (GF_Descriptor *) od;\n\t}\n\treturn NULL;\n}\n\n\nstatic GF_Err FFD_CloseService(GF_InputService *plug)\n{\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\tffd->is_running = 0;\n\n#if FF_API_CLOSE_INPUT_FILE\n\tif (ffd->ctx) av_close_input_file(ffd->ctx);\n#else\n\tif (ffd->ctx) avformat_close_input(&ffd->ctx);\n#endif\n\n\tffd->ctx = NULL;\n\tffd->audio_ch = ffd->video_ch = NULL;\n\tffd->audio_run = ffd->video_run = GF_FALSE;\n\n\tif (ffd->dnload) {\n\t\tif (ffd->is_running) {\n\t\t\twhile (!ffd->is_running) gf_sleep(1);\n\t\t\tffd->is_running = 0;\n\t\t}\n\t\tgf_service_download_del(ffd->dnload);\n\t\tffd->dnload = NULL;\n\t}\n\tif (ffd->buffer) gf_free(ffd->buffer);\n\tffd->buffer = NULL;\n\n\tgf_service_disconnect_ack(ffd->service, NULL, GF_OK);\n#ifdef FFMPEG_DUMP_REMOTE\n\tif (ffd->outdbg) gf_fclose(ffd->outdbg);\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err FFD_ConnectChannel(GF_InputService *plug, LPNETCHANNEL channel, const char *url, Bool upstream)\n{\n\tGF_Err e;\n\tu32 ESID;\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\te = GF_STREAM_NOT_FOUND;\n\tif (upstream) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (!strstr(url, \"ES_ID=\")) {\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto exit;\n\t}\n\tsscanf(url, \"ES_ID=%u\", &ESID);\n\n\tif ((s32) ESID == 1 + ffd->audio_st) {\n\t\tif (ffd->audio_ch) {\n\t\t\te = GF_SERVICE_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t\tffd->audio_ch = channel;\n\t\te = GF_OK;\n\t}\n\telse if ((s32) ESID == 1 + ffd->video_st) {\n\t\tif (ffd->video_ch) {\n\t\t\te = GF_SERVICE_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t\tffd->video_ch = channel;\n\t\te = GF_OK;\n\t}\n\nexit:\n\tgf_service_connect_ack(ffd->service, channel, e);\n\treturn GF_OK;\n}\n\nstatic GF_Err FFD_DisconnectChannel(GF_InputService *plug, LPNETCHANNEL channel)\n{\n\tGF_Err e;\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\te = GF_STREAM_NOT_FOUND;\n\tif (ffd->audio_ch == channel) {\n\t\te = GF_OK;\n\t\tffd->audio_ch = NULL;\n\t\tffd->audio_run = GF_FALSE;\n\t}\n\telse if (ffd->video_ch == channel) {\n\t\te = GF_OK;\n\t\tffd->video_ch = NULL;\n\t\tffd->video_run = GF_FALSE;\n\t}\n\tgf_service_disconnect_ack(ffd->service, channel, e);\n\treturn GF_OK;\n}\n\nstatic GF_Err FFD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)\n{\n\tFFDemux *ffd = (FFDemux*)plug->priv;\n\n\n\tif (com->command_type==GF_NET_SERVICE_HAS_AUDIO) {\n\t\tif (ffd->audio_st>=0) return GF_OK;\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (!com->base.on_channel) return GF_NOT_SUPPORTED;\n\n\tswitch (com->command_type) {\n\t/*only BIFS/OD work in pull mode (cf ffmpeg_in.h)*/\n\tcase GF_NET_CHAN_SET_PULL:\n\t\treturn GF_NOT_SUPPORTED;\n\tcase GF_NET_CHAN_INTERACTIVE:\n\t\treturn ffd->seekable ? GF_OK : GF_NOT_SUPPORTED;\n\tcase GF_NET_CHAN_BUFFER:\n\t\treturn GF_OK;\n\tcase GF_NET_CHAN_DURATION:\n\t\tif (ffd->ctx->duration == AV_NOPTS_VALUE)\n\t\t\tcom->duration.duration = -1;\n\t\telse\n\t\t\tcom->duration.duration = (Double) ffd->ctx->duration / AV_TIME_BASE;\n\t\treturn GF_OK;\n\t/*fetch start time*/\n\tcase GF_NET_CHAN_PLAY:\n\t\tif (com->play.speed<0) return GF_NOT_SUPPORTED;\n\n\t\tgf_mx_p(ffd->mx);\n\t\tffd->seek_time = (com->play.start_range>=0) ? com->play.start_range : 0;\n\n\t\tif (ffd->audio_ch==com->base.on_channel) ffd->audio_run = GF_TRUE;\n\t\telse if (ffd->video_ch==com->base.on_channel) ffd->video_run = GF_TRUE;\n\n\t\t/*play on media stream, start thread*/\n\t\tif ((ffd->audio_ch==com->base.on_channel) || (ffd->video_ch==com->base.on_channel)) {\n\t\t\tif (ffd->is_running!=1) {\n\t\t\t\tffd->is_running = 1;\n\t\t\t\tgf_th_run(ffd->thread, FFDemux_Run, ffd);\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(ffd->mx);\n\t\treturn GF_OK;\n\tcase GF_NET_CHAN_STOP:\n\t\tif (ffd->audio_ch==com->base.on_channel) ffd->audio_run = GF_FALSE;\n\t\telse if (ffd->video_ch==com->base.on_channel) ffd->video_run = GF_FALSE;\n\t\treturn GF_OK;\n\t/*note we don't handle PAUSE/RESUME/SET_SPEED, this is automatically handled by the demuxing thread\n\tthrough buffer occupancy queries*/\n\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\treturn GF_OK;\n}\n\n\nstatic Bool FFD_CanHandleURLInService(GF_InputService *plug, const char *url)\n{\n\tchar szURL[2048], *sep;\n\tFFDemux *ffd;\n\tconst char *this_url;\n\tif (!plug || !url)\n\t\treturn GF_FALSE;\n\tffd = (FFDemux *)plug->priv;\n\tthis_url = gf_service_get_url(ffd->service);\n\tif (!this_url)\n\t\treturn GF_FALSE;\n\n\tstrcpy(szURL, this_url);\n\tsep = strrchr(szURL, '#');\n\tif (sep) sep[0] = 0;\n\n\tif ((url[0] != '#') && strnicmp(szURL, url, sizeof(char)*strlen(szURL))) return GF_FALSE;\n\tsep = strrchr(url, '#');\n\tif (sep && !stricmp(sep, \"#video\") && (ffd->video_st>=0)) return GF_TRUE;\n\tif (sep && !stricmp(sep, \"#audio\") && (ffd->audio_st>=0)) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nvoid *New_FFMPEG_Demux()\n{\n\tGF_InputService *ffd;\n\tFFDemux *priv;\n\tGF_SAFEALLOC(ffd, GF_InputService);\n\tif (!ffd) return NULL;\n\tGF_SAFEALLOC(priv, FFDemux);\n\tif (!priv) {\n\t\tgf_free(ffd);\n\t\treturn NULL;\n\t}\n\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] Registering all ffmpeg plugins...\\n\") );\n\t/* register all codecs, demux and protocols */\n\tav_register_all();\n\tavformat_network_init();\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[FFMPEG Demuxer] Registering all ffmpeg plugins DONE.\\n\") );\n\n\tffd->RegisterMimeTypes = FFD_RegisterMimeTypes;\n\tffd->CanHandleURL = FFD_CanHandleURL;\n\tffd->CloseService = FFD_CloseService;\n\tffd->ConnectChannel = FFD_ConnectChannel;\n\tffd->ConnectService = FFD_ConnectService;\n\tffd->DisconnectChannel = FFD_DisconnectChannel;\n\tffd->GetServiceDescriptor = FFD_GetServiceDesc;\n\tffd->ServiceCommand = FFD_ServiceCommand;\n\n\tffd->CanHandleURLInService = FFD_CanHandleURLInService;\n\n\tpriv->thread = gf_th_new(\"FFMPEG Demux\");\n\tpriv->mx = gf_mx_new(\"FFMPEG Demux\");\n\tif (!priv->thread || !priv->mx) {\n\t\tif (priv->thread) gf_th_del(priv->thread);\n\t\tif (priv->mx) gf_mx_del(priv->mx);\n\t\tgf_free(priv);\n\t\treturn NULL;\n\t}\n\n\tGF_REGISTER_MODULE_INTERFACE(ffd, GF_NET_CLIENT_INTERFACE, \"FFMPEG Demuxer\", \"gpac distribution\");\n\tffd->priv = priv;\n\treturn ffd;\n}\n\nvoid Delete_FFMPEG_Demux(void *ifce)\n{\n\tFFDemux *ffd;\n\tGF_InputService *ptr = (GF_InputService *)ifce;\n\tif (!ptr)\n\t\treturn;\n\tffd = (FFDemux*)ptr->priv;\n\tif (ffd) {\n\t\tif (ffd->thread)\n\t\t\tgf_th_del(ffd->thread);\n\t\tffd->thread = NULL;\n\t\tif (ffd->mx)\n\t\t\tgf_mx_del(ffd->mx);\n\n#ifndef USE_PRE_0_7\n\t\tif (ffd->options) av_dict_free(&ffd->options);\n#endif\n\t\tffd->mx = NULL;\n\t\tgf_free(ffd);\n\t\tptr->priv = NULL;\n\t}\n\tgf_free(ptr);\n}\n\n\n#endif\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/scene_manager.h>\n#include <gpac/constants.h>\n#include <gpac/media_tools.h>\n#include <gpac/bifs.h>\n#include <gpac/xml.h>\n#include <gpac/internal/scenegraph_dev.h>\n#include <gpac/network.h>\n\n\nGF_EXPORT\nGF_SceneManager *gf_sm_new(GF_SceneGraph *graph)\n{\n\tGF_SceneManager *tmp;\n\n\tif (!graph) return NULL;\n\tGF_SAFEALLOC(tmp, GF_SceneManager);\n\tif (!tmp) return NULL;\n\ttmp->streams = gf_list_new();\n\ttmp->scene_graph = graph;\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_StreamContext *gf_sm_stream_new(GF_SceneManager *ctx, u16 ES_ID, u8 streamType, u8 objectType)\n{\n\tu32 i;\n\tGF_StreamContext *tmp;\n\n\ti=0;\n\twhile ((tmp = (GF_StreamContext*)gf_list_enum(ctx->streams, &i))) {\n\t\t/*we MUST use the same ST*/\n\t\tif (tmp->streamType!=streamType) continue;\n\t\t/*if no ESID/OTI specified this is a base layer (default stream created by parsers)\n\t\tif ESID/OTI specified this is a stream already setup\n\t\t*/\n\t\tif ( tmp->ESID==ES_ID ) {\n\t\t\t//tmp->objectType = objectType;\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\tGF_SAFEALLOC(tmp, GF_StreamContext);\n\tif (!tmp) return NULL;\n\ttmp->AUs = gf_list_new();\n\ttmp->ESID = ES_ID;\n\ttmp->streamType = streamType;\n\ttmp->objectType = objectType ? objectType : 1;\n\ttmp->timeScale = 1000;\n\tgf_list_add(ctx->streams, tmp);\n\treturn tmp;\n}\n\nGF_StreamContext *gf_sm_stream_find(GF_SceneManager *ctx, u16 ES_ID)\n{\n\tu32 i, count;\n\tif (!ES_ID) return NULL;\n\tcount = gf_list_count(ctx->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_StreamContext *tmp = (GF_StreamContext *)gf_list_get(ctx->streams, i);\n\t\tif (tmp->ESID==ES_ID) return tmp;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_MuxInfo *gf_sm_get_mux_info(GF_ESD *src)\n{\n\tu32 i;\n\tGF_MuxInfo *mux;\n\ti=0;\n\twhile ((mux = (GF_MuxInfo *)gf_list_enum(src->extensionDescriptors, &i))) {\n\t\tif (mux->tag == GF_ODF_MUXINFO_TAG) return mux;\n\t}\n\treturn NULL;\n}\n\n\nstatic void gf_sm_au_del(GF_StreamContext *sc, GF_AUContext *au)\n{\n\twhile (gf_list_count(au->commands)) {\n\t\tvoid *comptr = gf_list_last(au->commands);\n\t\tgf_list_rem_last(au->commands);\n\t\tswitch (sc->streamType) {\n\t\tcase GF_STREAM_OD:\n\t\t\tgf_odf_com_del((GF_ODCom**) & comptr);\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\t\tgf_sg_command_del((GF_Command *)comptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_list_del(au->commands);\n\tgf_free(au);\n}\n\nstatic void gf_sm_reset_stream(GF_StreamContext *sc)\n{\n\twhile (gf_list_count(sc->AUs)) {\n\t\tGF_AUContext *au = (GF_AUContext *)gf_list_last(sc->AUs);\n\t\tgf_list_rem_last(sc->AUs);\n\t\tgf_sm_au_del(sc, au);\n\n\t}\n}\n\nstatic void gf_sm_delete_stream(GF_StreamContext *sc)\n{\n\tgf_sm_reset_stream(sc);\n\tgf_list_del(sc->AUs);\n\tif (sc->name) gf_free(sc->name);\n\tif (sc->dec_cfg) gf_free(sc->dec_cfg);\n\tgf_free(sc);\n}\n\nGF_EXPORT\nvoid gf_sm_stream_del(GF_SceneManager *ctx, GF_StreamContext *sc)\n{\n\tif (gf_list_del_item(ctx->streams, sc)>=0) {\n\t\tgf_sm_delete_stream(sc);\n\t}\n}\n\nGF_EXPORT\nvoid gf_sm_del(GF_SceneManager *ctx)\n{\n\tu32 count;\n\twhile ( (count = gf_list_count(ctx->streams)) ) {\n\t\tGF_StreamContext *sc = (GF_StreamContext *)gf_list_get(ctx->streams, count-1);\n\t\tgf_list_rem(ctx->streams, count-1);\n\t\tgf_sm_delete_stream(sc);\n\t}\n\tgf_list_del(ctx->streams);\n\tif (ctx->root_od) gf_odf_desc_del((GF_Descriptor *) ctx->root_od);\n\tgf_free(ctx);\n}\n\nGF_EXPORT\nvoid gf_sm_reset(GF_SceneManager *ctx)\n{\n\tGF_StreamContext *sc;\n\tu32 i=0;\n\twhile ( (sc = gf_list_enum(ctx->streams, &i)) ) {\n\t\tgf_sm_reset_stream(sc);\n\t}\n\tif (ctx->root_od) gf_odf_desc_del((GF_Descriptor *) ctx->root_od);\n\tctx->root_od = NULL;\n}\n\nGF_EXPORT\nGF_AUContext *gf_sm_stream_au_new(GF_StreamContext *stream, u64 timing, Double time_sec, Bool isRap)\n{\n\tu32 i;\n\tGF_AUContext *tmp;\n\tu64 tmp_timing;\n\n\ttmp_timing = timing ? timing : (u64) (time_sec*1000);\n\tif (stream->imp_exp_time >= tmp_timing) {\n\t\t/*look for existing AU*/\n\t\ti=0;\n\t\twhile ((tmp = (GF_AUContext *)gf_list_enum(stream->AUs, &i))) {\n\t\t\tif (timing && (tmp->timing==timing)) return tmp;\n\t\t\telse if (time_sec && (tmp->timing_sec == time_sec)) return tmp;\n\t\t\telse if (!time_sec && !timing && !tmp->timing && !tmp->timing_sec) return tmp;\n\t\t\t/*insert AU*/\n\t\t\telse if ((time_sec && time_sec<tmp->timing_sec) || (timing && timing<tmp->timing)) {\n\t\t\t\tGF_SAFEALLOC(tmp, GF_AUContext);\n\t\t\t\tif (!tmp) return NULL;\n\t\t\t\ttmp->commands = gf_list_new();\n\t\t\t\tif (isRap) tmp->flags = GF_SM_AU_RAP;\n\t\t\t\ttmp->timing = timing;\n\t\t\t\ttmp->timing_sec = time_sec;\n\t\t\t\ttmp->owner = stream;\n\t\t\t\tgf_list_insert(stream->AUs, tmp, i-1);\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t}\n\tGF_SAFEALLOC(tmp, GF_AUContext);\n\tif (!tmp) return NULL;\n\ttmp->commands = gf_list_new();\n\tif (isRap) tmp->flags = GF_SM_AU_RAP;\n\ttmp->timing = timing;\n\ttmp->timing_sec = time_sec;\n\ttmp->owner = stream;\n\tif (stream->disable_aggregation) tmp->flags |= GF_SM_AU_NOT_AGGREGATED;\n\tgf_list_add(stream->AUs, tmp);\n\tstream->imp_exp_time = tmp_timing;\n\treturn tmp;\n}\n\nstatic Bool node_in_commands_subtree(GF_Node *node, GF_List *commands)\n{\n#ifndef GPAC_DISABLE_VRML\n\tu32 i, j, count, nb_fields;\n\n\tcount = gf_list_count(commands);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Command *com = gf_list_get(commands, i);\n\t\tif (com->tag>=GF_SG_LAST_BIFS_COMMAND) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] Command check for LASeR/DIMS not supported\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tif (com->tag==GF_SG_SCENE_REPLACE) {\n\t\t\tif (gf_node_parent_of(com->node, node)) return 1;\n\t\t\tcontinue;\n\t\t}\n\t\tnb_fields = gf_list_count(com->command_fields);\n\t\tfor (j=0; j<nb_fields; j++) {\n\t\t\tGF_CommandField *field = gf_list_get(com->command_fields, j);\n\t\t\tswitch (field->fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tif (field->new_node) {\n\t\t\t\t\tif (gf_node_parent_of(field->new_node, node)) return 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t\tif (field->field_ptr) {\n\t\t\t\t\tGF_ChildNodeItem *child;\n\t\t\t\t\tchild = field->node_list;\n\t\t\t\t\twhile (child) {\n\t\t\t\t\t\tif (gf_node_parent_of(child->node, node)) return 1;\n\t\t\t\t\t\tchild = child->next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic u32 store_or_aggregate(GF_StreamContext *sc, GF_Command *com, GF_List *commands, Bool *has_modif)\n{\n#ifndef GPAC_DISABLE_VRML\n\tu32 i, count, j, nb_fields;\n\tGF_CommandField *field, *check_field;\n\n\t/*if our command deals with a node inserted in the commands list, apply command list*/\n\tif (node_in_commands_subtree(com->node, commands)) return 0;\n\n\t/*otherwise, check if we can substitute a previous command with this one*/\n\tcount = gf_list_count(commands);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Command *check = gf_list_get(commands, i);\n\n\t\tif (sc->streamType == GF_STREAM_SCENE) {\n\t\t\tBool check_index=0;\n\t\t\tBool original_is_index = 0;\n\t\t\tBool apply;\n\t\t\tswitch (com->tag) {\n\t\t\tcase GF_SG_INDEXED_REPLACE:\n\t\t\t\tcheck_index=1;\n\t\t\tcase GF_SG_MULTIPLE_INDEXED_REPLACE:\n\t\t\tcase GF_SG_FIELD_REPLACE:\n\t\t\tcase GF_SG_MULTIPLE_REPLACE:\n\t\t\t\tif (check->node != com->node) break;\n\t\t\t\t/*we may aggregate an indexed insertion and a replace one*/\n\t\t\t\tif (check_index) {\n\t\t\t\t\tif (check->tag == GF_SG_INDEXED_REPLACE) {}\n\t\t\t\t\telse if (check->tag == GF_SG_INDEXED_INSERT) {\n\t\t\t\t\t\toriginal_is_index = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (check->tag != com->tag) break;\n\t\t\t\t}\n\t\t\t\tnb_fields = gf_list_count(com->command_fields);\n\t\t\t\tif (gf_list_count(check->command_fields) != nb_fields) break;\n\t\t\t\tapply=1;\n\t\t\t\tfor (j=0; j<nb_fields; j++) {\n\t\t\t\t\tfield = gf_list_get(com->command_fields, j);\n\t\t\t\t\tcheck_field = gf_list_get(check->command_fields, j);\n\t\t\t\t\tif ((field->pos != check_field->pos) || (field->fieldIndex != check_field->fieldIndex)) {\n\t\t\t\t\t\tapply=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*same target node+fields, destroy first command and store new one*/\n\t\t\t\tif (apply) {\n\t\t\t\t\t/*if indexed, change command tag*/\n\t\t\t\t\tif (original_is_index) com->tag = GF_SG_INDEXED_INSERT;\n\n\t\t\t\t\tgf_sg_command_del((GF_Command *)check);\n\t\t\t\t\tgf_list_rem(commands, i);\n\t\t\t\t\tif (has_modif) *has_modif = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GF_SG_NODE_REPLACE:\n\t\t\t\tif (check->tag != GF_SG_NODE_REPLACE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*TODO - THIS IS NOT SUPPORTED IN GPAC SINCE WE NEVER ALLOW FOR DUPLICATE NODE IDs IN THE SCENE !!!*/\n\t\t\t\tif (gf_node_get_id(check->node) != gf_node_get_id(com->node) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*same node ID, destroy first command and store new one*/\n\t\t\t\tgf_sg_command_del((GF_Command *)check);\n\t\t\t\tgf_list_rem(commands, i);\n\t\t\t\tif (has_modif) *has_modif = 1;\n\t\t\t\treturn 1;\n\n\t\t\tcase GF_SG_INDEXED_DELETE:\n\t\t\t\t/*look for an indexed insert before the indexed delete with same target pos and node. If found, discard both commands!*/\n\t\t\t\tif (check->tag != GF_SG_INDEXED_INSERT) break;\n\t\t\t\tif (com->node != check->node) break;\n\t\t\t\tfield = gf_list_get(com->command_fields, 0);\n\t\t\t\tcheck_field = gf_list_get(check->command_fields, 0);\n\t\t\t\tif (!field || !check_field) break;\n\t\t\t\tif (field->pos != check_field->pos) break;\n\t\t\t\tif (field->fieldIndex != check_field->fieldIndex) break;\n\n\t\t\t\tgf_sg_command_del((GF_Command *)check);\n\t\t\t\tgf_list_rem(commands, i);\n\t\t\t\tif (has_modif) *has_modif = 1;\n\t\t\t\treturn 2;\n\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] Stream Aggregation not implemented for command - aggregating on main scene\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*the command modifies another stream than associated current carousel stream, we have to store it.*/\n\tif (has_modif) *has_modif=1;\n#endif\n\treturn 1;\n}\n\nstatic GF_StreamContext *gf_sm_get_stream(GF_SceneManager *ctx, u16 ESID)\n{\n\tu32 i, count;\n\tcount = gf_list_count(ctx->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_StreamContext *sc = gf_list_get(ctx->streams, i);\n\t\tif (sc->ESID==ESID) return sc;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Err gf_sm_aggregate(GF_SceneManager *ctx, u16 ESID)\n{\n\tGF_Err e;\n\tu32 i, stream_count;\n#ifndef GPAC_DISABLE_VRML\n\tu32 j;\n\tGF_AUContext *au;\n\tGF_Command *com;\n#endif\n\n\te = GF_OK;\n\n#if DEBUG_RAP\n\tcom_count = 0;\n\tstream_count = gf_list_count(ctx->streams);\n\tfor (i=0; i<stream_count; i++) {\n\t\tGF_StreamContext *sc = (GF_StreamContext *)gf_list_get(ctx->streams, i);\n\t\tif (sc->streamType == GF_STREAM_SCENE) {\n\t\t\tau_count = gf_list_count(sc->AUs);\n\t\t\tfor (j=0; j<au_count; j++) {\n\t\t\t\tau = (GF_AUContext *)gf_list_get(sc->AUs, j);\n\t\t\t\tcom_count += gf_list_count(au->commands);\n\t\t\t}\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_INFO, GF_LOG_SCENE, (\"[SceneManager] Making RAP with %d commands\\n\", com_count));\n#endif\n\n\tstream_count = gf_list_count(ctx->streams);\n\tfor (i=0; i<stream_count; i++) {\n\t\tGF_AUContext *carousel_au;\n\t\tGF_List *carousel_commands;\n\t\tGF_StreamContext *aggregate_on_stream;\n\t\tGF_StreamContext *sc = (GF_StreamContext *)gf_list_get(ctx->streams, i);\n\t\tif (ESID && (sc->ESID!=ESID)) continue;\n\n\t\t/*locate the AU in which our commands will be aggregated*/\n\t\tcarousel_au = NULL;\n\t\tcarousel_commands = NULL;\n\t\taggregate_on_stream = sc->aggregate_on_esid ? gf_sm_get_stream(ctx, sc->aggregate_on_esid) : NULL;\n\t\tif (aggregate_on_stream==sc) {\n\t\t\tcarousel_commands = gf_list_new();\n\t\t} else if (aggregate_on_stream) {\n\t\t\tif (!gf_list_count(aggregate_on_stream->AUs)) {\n\t\t\t\tcarousel_au = gf_sm_stream_au_new(aggregate_on_stream, 0, 0, 1);\n\t\t\t} else {\n\t\t\t\t/* assert we already performed aggregation */\n\t\t\t\tassert(gf_list_count(aggregate_on_stream->AUs)==1);\n\t\t\t\tcarousel_au = gf_list_get(aggregate_on_stream->AUs, 0);\n\t\t\t}\n\t\t\tcarousel_commands = carousel_au->commands;\n\t\t}\n\t\t/*TODO - do this as well for ODs*/\n#ifndef GPAC_DISABLE_VRML\n\t\tif (sc->streamType == GF_STREAM_SCENE) {\n\t\t\tBool has_modif = 0;\n\t\t\t/*we check for each stream if it is a base stream (SceneReplace ...) - several streams may carry RAPs if inline nodes are used*/\n\t\t\tBool base_stream_found = 0;\n\n\t\t\t/*in DIMS we use an empty initial AU with no commands to signal the RAP*/\n\t\t\tif (sc->objectType == GPAC_OTI_SCENE_DIMS) base_stream_found = 1;\n\n\t\t\t/*apply all commands - this will also apply the SceneReplace*/\n\t\t\twhile (gf_list_count(sc->AUs)) {\n\t\t\t\tu32 count;\n\t\t\t\tau = (GF_AUContext *) gf_list_get(sc->AUs, 0);\n\t\t\t\tgf_list_rem(sc->AUs, 0);\n\n\t\t\t\t/*AU not aggregated*/\n\t\t\t\tif (au->flags & GF_SM_AU_NOT_AGGREGATED) {\n\t\t\t\t\tgf_sm_au_del(sc, au);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcount = gf_list_count(au->commands);\n\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\tu32 store=0;\n\t\t\t\t\tcom = gf_list_get(au->commands, j);\n\t\t\t\t\tif (!base_stream_found) {\n\t\t\t\t\t\tswitch (com->tag) {\n\t\t\t\t\t\tcase GF_SG_SCENE_REPLACE:\n\t\t\t\t\t\tcase GF_SG_LSR_NEW_SCENE:\n\t\t\t\t\t\tcase GF_SG_LSR_REFRESH_SCENE:\n\t\t\t\t\t\t\tbase_stream_found = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*aggregate the command*/\n\n\t\t\t\t\t/*if stream doesn't carry a carousel or carries the base carousel (scene replace), always apply the command*/\n\t\t\t\t\tif (base_stream_found || !sc->aggregate_on_esid) {\n\t\t\t\t\t\tstore = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/*otherwise, check wether the command should be kept in this stream as is, or can be aggregated on this stream*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tswitch (com->tag) {\n\t\t\t\t\t\t/*the following commands do not impact a sub-tree (eg do not deal with nodes), we cannot\n\t\t\t\t\t\taggregate them... */\n\t\t\t\t\t\tcase GF_SG_ROUTE_REPLACE:\n\t\t\t\t\t\tcase GF_SG_ROUTE_DELETE:\n\t\t\t\t\t\tcase GF_SG_ROUTE_INSERT:\n\t\t\t\t\t\tcase GF_SG_PROTO_INSERT:\n\t\t\t\t\t\tcase GF_SG_PROTO_DELETE:\n\t\t\t\t\t\tcase GF_SG_PROTO_DELETE_ALL:\n\t\t\t\t\t\tcase GF_SG_GLOBAL_QUANTIZER:\n\t\t\t\t\t\tcase GF_SG_LSR_RESTORE:\n\t\t\t\t\t\tcase GF_SG_LSR_SAVE:\n\t\t\t\t\t\tcase GF_SG_LSR_SEND_EVENT:\n\t\t\t\t\t\tcase GF_SG_LSR_CLEAN:\n\t\t\t\t\t\t\t/*todo check in which category to put these commands*/\n//\t\t\t\t\t\tcase GF_SG_LSR_ACTIVATE:\n//\t\t\t\t\t\tcase GF_SG_LSR_DEACTIVATE:\n\t\t\t\t\t\t\tstore = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/*other commands:\n\t\t\t\t\t\t\t!!! we need to know if the target node of the command has been inserted in this stream !!!\n\n\t\t\t\t\t\tThis is a tedious task, for now we will consider the following cases:\n\t\t\t\t\t\t\t- locate a similar command in the stored list: remove the similar one and aggregate on stream\n\t\t\t\t\t\t\t- by default all AUs are stored if the stream is in aggregate mode - we should fix that by checking insertion points:\n\t\t\t\t\t\t\t if a command apllies on a node that has been inserted in this stream, we can aggregate, otherwise store\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/*check if we can directly store the command*/\n\t\t\t\t\t\t\tassert(carousel_commands);\n\t\t\t\t\t\t\tstore = store_or_aggregate(sc, com, carousel_commands, &has_modif);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (store) {\n\t\t\t\t\t/*command has been merged with a previous command in carousel and needs to be destroyed*/\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tgf_list_rem(au->commands, j);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tgf_sg_command_del((GF_Command *)com);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/*command shall be moved to carousel without being applied*/\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tgf_list_insert(carousel_commands, com, 0);\n\t\t\t\t\t\tgf_list_rem(au->commands, j);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/*command can be applied*/\n\t\t\t\t\tdefault:\n\t\t\t\t\t\te = gf_sg_command_apply(ctx->scene_graph, com, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_sm_au_del(sc, au);\n\t\t\t}\n\n\t\t\t/*and recreate scene replace*/\n\t\t\tif (base_stream_found) {\n\t\t\t\tau = gf_sm_stream_au_new(sc, 0, 0, 1);\n\n\t\t\t\tswitch (sc->objectType) {\n\t\t\t\tcase GPAC_OTI_SCENE_BIFS:\n\t\t\t\tcase GPAC_OTI_SCENE_BIFS_V2:\n\t\t\t\t\tcom = gf_sg_command_new(ctx->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GPAC_OTI_SCENE_LASER:\n\t\t\t\t\tcom = gf_sg_command_new(ctx->scene_graph, GF_SG_LSR_NEW_SCENE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GPAC_OTI_SCENE_DIMS:\n\t\t\t\t/* We do not create a new command, empty AU is enough in DIMS*/\n\t\t\t\tdefault:\n\t\t\t\t\tcom = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (com) {\n\t\t\t\t\tcom->node = ctx->scene_graph->RootNode;\n\t\t\t\t\tctx->scene_graph->RootNode = NULL;\n\t\t\t\t\tgf_list_del(com->new_proto_list);\n\t\t\t\t\tcom->new_proto_list = ctx->scene_graph->protos;\n\t\t\t\t\tctx->scene_graph->protos = NULL;\n\t\t\t\t\t/*indicate the command is the aggregated scene graph, so that PROTOs and ROUTEs\n\t\t\t\t\tare taken from the scenegraph when encoding*/\n\t\t\t\t\tcom->aggregated = 1;\n\t\t\t\t\tgf_list_add(au->commands, com);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*update carousel flags of the AU*/\n\t\t\telse if (carousel_commands) {\n\t\t\t\t/*if current stream caries its own carousel*/\n\t\t\t\tif (!carousel_au) {\n\t\t\t\t\tcarousel_au = gf_sm_stream_au_new(sc, 0, 0, 1);\n\t\t\t\t\tgf_list_del(carousel_au->commands);\n\t\t\t\t\tcarousel_au->commands = carousel_commands;\n\t\t\t\t}\n\t\t\t\tcarousel_au->flags |= GF_SM_AU_RAP | GF_SM_AU_CAROUSEL;\n\t\t\t\tif (has_modif) carousel_au->flags |= GF_SM_AU_MODIFIED;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_LOADER_BT\nGF_Err gf_sm_load_init_bt(GF_SceneLoader *load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_XMT\nGF_Err gf_sm_load_init_xmt(GF_SceneLoader *load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_ISOM\nGF_Err gf_sm_load_init_isom(GF_SceneLoader *load);\n#endif\n\n#ifndef GPAC_DISABLE_SVG\n\nGF_Err gf_sm_load_init_svg(GF_SceneLoader *load);\n\nGF_Err gf_sm_load_init_xbl(GF_SceneLoader *load);\nGF_Err gf_sm_load_run_xbl(GF_SceneLoader *load);\nvoid gf_sm_load_done_xbl(GF_SceneLoader *load);\n#endif\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\nGF_Err gf_sm_load_init_swf(GF_SceneLoader *load);\n#endif\n\n\n#ifndef GPAC_DISABLE_QTVR\n\nGF_Err gf_sm_load_init_qt(GF_SceneLoader *load);\n#endif\n\n\n\nGF_EXPORT\nGF_Err gf_sm_load_string(GF_SceneLoader *load, const char *str, Bool do_clean)\n{\n\tGF_Err e;\n\tif (!load->type) e = GF_BAD_PARAM;\n\telse if (load->parse_string) e = load->parse_string(load, str);\n\telse e = GF_NOT_SUPPORTED;\n\n\treturn e;\n}\n\n\n/*initializes the context loader*/\nGF_EXPORT\nGF_Err gf_sm_load_init(GF_SceneLoader *load)\n{\n\tGF_Err e = GF_NOT_SUPPORTED;\n\tchar *ext, szExt[50];\n\t/*we need at least a scene graph*/\n\tif (!load || (!load->ctx && !load->scene_graph)\n#ifndef GPAC_DISABLE_ISOM\n\t        || (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )\n#endif\n\t   ) return GF_BAD_PARAM;\n\n\tif (!load->type) {\n#ifndef GPAC_DISABLE_ISOM\n\t\tif (load->isom) {\n\t\t\tload->type = GF_SM_LOAD_MP4;\n\t\t} else\n#endif\n\t\t{\n\t\t\text = (char *)strrchr(load->fileName, '.');\n\t\t\tif (!ext) return GF_NOT_SUPPORTED;\n\t\t\tif (!stricmp(ext, \".gz\")) {\n\t\t\t\tchar *anext;\n\t\t\t\text[0] = 0;\n\t\t\t\tanext = (char *)strrchr(load->fileName, '.');\n\t\t\t\text[0] = '.';\n\t\t\t\text = anext;\n\t\t\t}\n\t\t\tif (strlen(ext) < 2 || strlen(ext) > sizeof(szExt)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] invalid extension in file name %s\\n\", load->fileName));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\tstrcpy(szExt, &ext[1]);\n\t\t\tstrlwr(szExt);\n\t\t\tif (strstr(szExt, \"bt\")) load->type = GF_SM_LOAD_BT;\n\t\t\telse if (strstr(szExt, \"wrl\")) load->type = GF_SM_LOAD_VRML;\n\t\t\telse if (strstr(szExt, \"x3dv\")) load->type = GF_SM_LOAD_X3DV;\n#ifndef GPAC_DISABLE_LOADER_XMT\n\t\t\telse if (strstr(szExt, \"xmt\") || strstr(szExt, \"xmta\")) load->type = GF_SM_LOAD_XMTA;\n\t\t\telse if (strstr(szExt, \"x3d\")) load->type = GF_SM_LOAD_X3D;\n#endif\n\t\t\telse if (strstr(szExt, \"swf\")) load->type = GF_SM_LOAD_SWF;\n\t\t\telse if (strstr(szExt, \"mov\")) load->type = GF_SM_LOAD_QT;\n\t\t\telse if (strstr(szExt, \"svg\")) load->type = GF_SM_LOAD_SVG;\n\t\t\telse if (strstr(szExt, \"xsr\")) load->type = GF_SM_LOAD_XSR;\n\t\t\telse if (strstr(szExt, \"xbl\")) load->type = GF_SM_LOAD_XBL;\n\t\t\telse if (strstr(szExt, \"xml\")) {\n\t\t\t\tchar *rtype = gf_xml_get_root_type(load->fileName, &e);\n\t\t\t\tif (rtype) {\n\t\t\t\t\tif (!strcmp(rtype, \"SAFSession\")) load->type = GF_SM_LOAD_XSR;\n\t\t\t\t\telse if (!strcmp(rtype, \"XMT-A\")) load->type = GF_SM_LOAD_XMTA;\n\t\t\t\t\telse if (!strcmp(rtype, \"X3D\")) load->type = GF_SM_LOAD_X3D;\n\t\t\t\t\telse if (!strcmp(rtype, \"bindings\")) load->type = GF_SM_LOAD_XBL;\n\n\t\t\t\t\tgf_free(rtype);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!load->type) return e;\n\n\tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;\n\n\tswitch (load->type) {\n#ifndef GPAC_DISABLE_LOADER_BT\n\tcase GF_SM_LOAD_BT:\n\tcase GF_SM_LOAD_VRML:\n\tcase GF_SM_LOAD_X3DV:\n\t\treturn gf_sm_load_init_bt(load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_XMT\n\tcase GF_SM_LOAD_XMTA:\n\tcase GF_SM_LOAD_X3D:\n\t\treturn gf_sm_load_init_xmt(load);\n#endif\n\n#ifndef GPAC_DISABLE_SVG\n\tcase GF_SM_LOAD_SVG:\n\tcase GF_SM_LOAD_XSR:\n\tcase GF_SM_LOAD_DIMS:\n\t\treturn gf_sm_load_init_svg(load);\n\n\tcase GF_SM_LOAD_XBL:\n\t\te = gf_sm_load_init_xbl(load);\n\n\t\tload->process = gf_sm_load_run_xbl;\n\t\tload->done = gf_sm_load_done_xbl;\n\t\treturn e;\n#endif\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tcase GF_SM_LOAD_SWF:\n\t\treturn gf_sm_load_init_swf(load);\n#endif\n\n#ifndef GPAC_DISABLE_LOADER_ISOM\n\tcase GF_SM_LOAD_MP4:\n\t\treturn gf_sm_load_init_isom(load);\n#endif\n\n#ifndef GPAC_DISABLE_QTVR\n\tcase GF_SM_LOAD_QT:\n\t\treturn gf_sm_load_init_qt(load);\n#endif\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\treturn GF_NOT_SUPPORTED;\n}\n\nGF_EXPORT\nvoid gf_sm_load_done(GF_SceneLoader *load)\n{\n\tif (load->done) load->done(load);\n}\n\nGF_EXPORT\nGF_Err gf_sm_load_run(GF_SceneLoader *load)\n{\n\tif (load->process) return load->process(load);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_sm_load_suspend(GF_SceneLoader *load, Bool suspend)\n{\n\tif (load->suspend) return load->suspend(load, suspend);\n\treturn GF_OK;\n}\n\n#if !defined(GPAC_DISABLE_LOADER_BT) || !defined(GPAC_DISABLE_LOADER_XMT)\n#include <gpac/base_coding.h>\nvoid gf_sm_update_bitwrapper_buffer(GF_Node *node, const char *fileName)\n{\n\tu32 data_size = 0;\n\tchar *data = NULL;\n\tchar *buffer;\n\tM_BitWrapper *bw = (M_BitWrapper *)node;\n\n\tif (!bw->buffer.buffer) return;\n\tbuffer = bw->buffer.buffer;\n\tif (!strnicmp(buffer, \"file://\", 7)) {\n\t\tchar *url = gf_url_concatenate(fileName, buffer+7);\n\t\tif (url) {\n\t\t\tFILE *f = gf_fopen(url, \"rb\");\n\t\t\tif (f) {\n\t\t\t\tfseek(f, 0, SEEK_END);\n\t\t\t\tdata_size = (u32) ftell(f);\n\t\t\t\tfseek(f, 0, SEEK_SET);\n\t\t\t\tdata = gf_malloc(sizeof(char)*data_size);\n\t\t\t\tif (data) {\n\t\t\t\t\tif (fread(data, 1, data_size, f) != data_size) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] error reading bitwrapper file %s\\n\", url));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fclose(f);\n\t\t\t}\n\t\t\tgf_free(url);\n\t\t}\n\t} else {\n\t\tBool base_64 = 0;\n\t\tif (!strnicmp(buffer, \"data:application/octet-string\", 29)) {\n\t\t\tchar *sep = strchr(bw->buffer.buffer, ',');\n\t\t\tbase_64 = strstr(bw->buffer.buffer, \";base64\") ? 1 : 0;\n\t\t\tif (sep) buffer = sep+1;\n\t\t}\n\n\t\tif (base_64) {\n\t\t\tdata_size = 2 * (u32) strlen(buffer);\n\t\t\tdata = (char*)gf_malloc(sizeof(char)*data_size);\n\t\t\tif (data)\n\t\t\t\tdata_size = gf_base64_decode(buffer, (u32) strlen(buffer), data, data_size);\n\t\t} else {\n\t\t\tu32 i, c;\n\t\t\tchar s[3];\n\t\t\tdata_size = (u32) strlen(buffer) / 3;\n\t\t\tdata = (char*)gf_malloc(sizeof(char) * data_size);\n\t\t\tif (data) {\n\t\t\t\ts[2] = 0;\n\t\t\t\tfor (i=0; i<data_size; i++) {\n\t\t\t\t\ts[0] = buffer[3*i+1];\n\t\t\t\t\ts[1] = buffer[3*i+2];\n\t\t\t\t\tsscanf(s, \"%02X\", &c);\n\t\t\t\t\tdata[i] = (unsigned char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgf_free(bw->buffer.buffer);\n\tbw->buffer.buffer = NULL;\n\tbw->buffer_len = 0;\n\tif (data) {\n\t\tbw->buffer.buffer = data;\n\t\tbw->buffer_len = data_size;\n\t}\n\n}\n#endif //!defined(GPAC_DISABLE_LOADER_BT) || !defined(GPAC_DISABLE_LOADER_XMT)\n\n\n"], "filenames": ["applications/mp4box/fileimport.c", "applications/mp4client/main.c", "modules/ffmpeg_in/ffmpeg_demux.c", "src/scene_manager/scene_manager.c"], "buggy_code_start_loc": [2358, 913, 230, 648], "buggy_code_end_loc": [2376, 1719, 256, 648], "fixing_code_start_loc": [2359, 913, 230, 649], "fixing_code_end_loc": [2397, 1744, 259, 653], "type": "CWE-119", "message": "GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.", "other": {"cve": {"id": "CVE-2018-20762", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-06T23:29:00.370", "lastModified": "2019-04-15T18:58:56.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames."}, {"lang": "es", "value": "GPAC versi\u00f3n 0.7.1 y anteriores tiene una vulnerabilidad de desbordamiento de b\u00fafer en la funci\u00f3n cat_multiple_files en aplicaciones/mp4box/fileimport.c cuando MP4Box se utiliza para un directorio local que contiene nombres de archivo creados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac_project:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.7.1", "matchCriteriaId": "B4ED3B4A-F8B8-4E70-BDF7-811129A50B0F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1187", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3926-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658"}}