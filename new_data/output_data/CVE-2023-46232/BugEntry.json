{"buggy_code": ["# The `zkvyper` changelog\n\n## [1.3.9] - 2023-07-03\n\n### Fixed\n\n- An issue with non-determinism in contract metadata hash\n\n## [1.3.8] - 2023-06-29\n\n### Changed\n\n- Each contract is now compiled in a separate process\n\n### Fixed\n\n- The CLI argument validation to rule out incompatible options\n\n## [1.3.7] - 2023-05-29\n\n### Added\n\n- The zkEVM assembly compilation mode (`--zkasm`)\n- The vyper v1.3.9 support\n\n### Fixed\n\n- The evaluation order of EVM instruction arguments in LLL IR\n\n## [1.3.6] - 2023-04-18\n\n### Added\n\n- The `CODESIZE` support in runtime code\n- An option not to include the metadata hash at the end of bytecode\n\n### Changed\n\n- Calldata instructions now return 0 in deploy code\n\n### Fixed\n\n- The LLVM crash with memory offsets `>= 2^64`\n- The LLVM crash with ternary operator on fat memory pointers\n\n## [1.3.5] - 2023-04-04\n\n### Added\n\n- An option to disable the `vyper` optimizer\n\n### Changed\n\n- Increased the stack size for `rayon` workers to 16 MB\n- Improved the CLI interface description (see `--help`)\n\n## [1.3.4] - 2023-03-15\n\n### Added\n\n- LLVM options for debugging and verification\n\n## [1.3.3] - 2023-03-09\n\n### Added\n\n- The contract metadata hash to the end of bytecode\n- More optimizations\n\n### Changed\n\n- The optimizer settings to support multiple modes\n- The optimizer now optimizes for performance instead of size by default\n\n## [1.3.2] - 2023-02-14\n\n### Added\n\n- The LLVM build commit ID to the `--version` output\n- More LLVM optimizations\n\n### Removed\n\n- The `long_version` field from the combined JSON output\n\n### Fixed\n\n- Calls now only copy `min(output_size, return_data_size)` of the return data\n\n## [1.3.1] - 2023-02-06\n\n### Changed\n\n- Some ABI data layout parameters\n\n## [1.3.0] - 2023-02-02\n\n### Added\n\n- The LLVM IR compilation mode (`--llvm-ir`)\n\n### Changed\n\n- System contract calls now use remaining ergs instead of 0\n- The LLVM optimization manager to the new one\n- The contract ABI to match that of zkEVM v1.3\n- Moved the event decoding to the system contracts\n- Simplified the CLI arguments used for debugging\n\n### Removed\n\n- The `extcodesize` check at the beginning of runtime code\n\n### Fixed\n\n- The non-zero initial return data size value\n- `msg.value >= 2^128` now set the call status code to zero\n- `BALANCE` now returns 0 if `address >= 2^160`\n- `KECCAK256` now returns an empty error in case of revert\n- `SIGNEXTEND` now returns the original value if `bytes >= 31`\n- `CODESIZE` is forbidden in Yul runtime code\n- `RETURNDATACOPY` now reverts on attempt to copy from beyond the return data\n- `RETURN` and `REVERT` offsets and lengths are now clamped to `2^32 - 1`\n- Only block hashes of the last 256 blocks are now accessible\n- `ptr.pack` is not optimized out by LLVM anymore\n\n## [1.2.2] - 2022-12-16\n\n### Added\n\n- More LLVM optimizations\n\n### Changed\n\n- Updated LLVM to v15.0.4\n\n### Fixed\n\n- The crash with some uncovered LLVM IR nodes\n- The missing check for `msg.value` > `2^128 - 1`\n\n## [1.2.1] - 2022-12-01\n\n### Added\n\n- The option to dump IRs to files\n- More contract size optimizations\n- The Windows platform support\n\n### Changed\n\n- The `CODECOPY` instruction now produces a compile-time error in the runtime code\n- The `CALLCODE` instruction now emits a compile-time error\n\n### Fixed\n\n- The `BYTE` instruction overflow\n- The forwarder constructor unhandled error\n\n## [1.2.0] - 2022-10-10\n\n### Added\n\n- Many improvements for the memory security and EVM-compatibility\n- Optimizations for the heap allocation\n- Support for optimizations for the calldata and returndata forwarding\n- More LLVM optimizations\n\n### Changed\n\n- System contract calls now require a system call flag\n- The handling of `msg.value` is made more robust\n- Failed system contract calls now do bubble-up the reverts\n\n## [1.1.4] - 2022-09-02\n\n### Added\n\n- The compiler versions to the output JSON\n\n### Changed\n\n- Unsupported instructions `PC`, `EXTCODECOPY`, `SELFDESTRUCT` now produce compile-time errors\n\n### Fixed\n\n- Bloating the array of immutables with zero values\n\n## [1.1.3] - 2022-08-16\n\n### Added\n\n- Support for the `BASEFEE` instruction\n\n## [1.1.2] - 2022-08-08\n\n### Added\n\n- Better compatibility of opcodes `GASLIMIT`, `GASPRICE`, `CHAINID`, `DIFFICULTY`, `COINBASE` etc.\n\n## [1.1.1] - 2022-07-28\n\n### Added\n\n- Support for the *SELECT* instruction, used by min/max built-ins\n\n## [1.1.0] - 2022-07-16\n\n### Added\n\n- The initial release\n", "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"aho-corasick\"\nversion = \"1.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"43f6cb1bf222025340178f382c426f13757b2960e89779dfcb319c32542a5a41\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"anyhow\"\nversion = \"1.0.72\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3b13c32d80ecc7ab747b80c3784bce54ee8a7a0cc4fbda9bf4cda2cf6fe90854\"\n\n[[package]]\nname = \"arrayvec\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711\"\n\n[[package]]\nname = \"atty\"\nversion = \"0.2.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\ndependencies = [\n \"hermit-abi 0.1.19\",\n \"libc\",\n \"winapi\",\n]\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"base16ct\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"349a06037c7bf932dd7e7d1f653678b2038b9ad46a74102f1fc7bd7872678cce\"\n\n[[package]]\nname = \"base64ct\"\nversion = \"1.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"2.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"630be753d4e58660abd17930c71b647fe46c27ea6b63cc59e1e3851406972e42\"\n\n[[package]]\nname = \"bitvec\"\nversion = \"0.20.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7774144344a4faa177370406a7ff5f1da24303817368584c6206c8303eb07848\"\ndependencies = [\n \"funty\",\n \"radium\",\n \"tap\",\n \"wyz\",\n]\n\n[[package]]\nname = \"blake2\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"46502ad458c9a52b69d4d4d32775c788b7a1b85e8bc9d482d92250fc0e3f8efe\"\ndependencies = [\n \"digest\",\n]\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"byte-slice-cast\"\nversion = \"1.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c3ac9f8b63eca6fd385229b3675f6cc0dc5c8a5c8a54a59d4f52ffd670d87b0c\"\n\n[[package]]\nname = \"byteorder\"\nversion = \"1.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n\n[[package]]\nname = \"bytes\"\nversion = \"1.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be\"\n\n[[package]]\nname = \"cc\"\nversion = \"1.0.79\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f\"\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"clap\"\nversion = \"2.34.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a0610544180c38b88101fecf2dd634b174a62eef6946f84dfc6a7127512b381c\"\ndependencies = [\n \"bitflags 1.3.2\",\n \"textwrap\",\n \"unicode-width\",\n]\n\n[[package]]\nname = \"colored\"\nversion = \"2.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2674ec482fbc38012cf31e6c42ba0177b431a0cb6f15fe40efa5aab1bda516f6\"\ndependencies = [\n \"is-terminal\",\n \"lazy_static\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"compiler-common\"\nversion = \"1.3.1\"\nsource = \"git+https://github.com/matter-labs/era-compiler-common?branch=main#a6c5b02e4f149f82f1c3821a6f258363308abd2a\"\n\n[[package]]\nname = \"compiler-llvm-context\"\nversion = \"1.3.2\"\nsource = \"git+https://github.com/matter-labs/era-compiler-llvm-context?branch=main#7d20d1323787ff50fb043cb4f798b3d9a9369ae8\"\ndependencies = [\n \"anyhow\",\n \"compiler-common\",\n \"hex\",\n \"inkwell\",\n \"itertools\",\n \"md5\",\n \"num\",\n \"once_cell\",\n \"regex\",\n \"semver\",\n \"serde\",\n \"sha2\",\n \"sha3\",\n \"zkevm-assembly\",\n \"zkevm_opcode_defs\",\n]\n\n[[package]]\nname = \"compiler-vyper\"\nversion = \"1.3.9\"\ndependencies = [\n \"anyhow\",\n \"colored\",\n \"compiler-common\",\n \"compiler-llvm-context\",\n \"hex\",\n \"inkwell\",\n \"lazy_static\",\n \"mimalloc\",\n \"once_cell\",\n \"rayon\",\n \"semver\",\n \"serde\",\n \"serde_json\",\n \"serde_stacker\",\n \"sha3\",\n \"structopt\",\n \"zkevm-assembly\",\n \"zkevm_opcode_defs\",\n]\n\n[[package]]\nname = \"const-oid\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"795bc6e66a8e340f075fcf6227e417a2dc976b92b91f3cdc778bb858778b6747\"\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a17b76ff3a4162b0b27f354a0c87015ddad39d35f9c0c36607a3bdd175dde1f1\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"crossbeam-channel\"\nversion = \"0.5.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a33c2bf77f2df06183c3aa30d1e96c0695a313d4f9c453cc3762a6db39f99200\"\ndependencies = [\n \"cfg-if\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-deque\"\nversion = \"0.8.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ce6fd6f855243022dcecf8702fef0c297d4338e226845fe067f6341ad9fa0cef\"\ndependencies = [\n \"cfg-if\",\n \"crossbeam-epoch\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-epoch\"\nversion = \"0.9.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ae211234986c545741a7dc064309f67ee1e5ad243d0e48335adc0484d960bcc7\"\ndependencies = [\n \"autocfg\",\n \"cfg-if\",\n \"crossbeam-utils\",\n \"memoffset\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"crossbeam-utils\"\nversion = \"0.8.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5a22b2d63d4d1dc0b7f1b6b2747dd0088008a9be28b6ddf0b1e7d335e3037294\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"crunchy\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7\"\n\n[[package]]\nname = \"crypto-bigint\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ef2b4b23cddf68b89b8f8069890e8c270d54e2d5fe1b143820234805e4cb17ef\"\ndependencies = [\n \"generic-array\",\n \"rand_core\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"typenum\",\n]\n\n[[package]]\nname = \"der\"\nversion = \"0.6.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f1a467a65c5e759bce6e65eaf91cc29f466cdc57cb65777bd646872a8a1fd4de\"\ndependencies = [\n \"const-oid\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n \"subtle\",\n]\n\n[[package]]\nname = \"ecdsa\"\nversion = \"0.14.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"413301934810f597c1d19ca71c8710e99a3f1ba28a0d2ebc01551a2daeea3c5c\"\ndependencies = [\n \"der\",\n \"elliptic-curve\",\n \"rfc6979\",\n \"signature\",\n]\n\n[[package]]\nname = \"either\"\nversion = \"1.8.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91\"\n\n[[package]]\nname = \"elliptic-curve\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e7bb888ab5300a19b8e5bceef25ac745ad065f3c9f7efc6de1b91958110891d3\"\ndependencies = [\n \"base16ct\",\n \"crypto-bigint\",\n \"der\",\n \"digest\",\n \"ff\",\n \"generic-array\",\n \"group\",\n \"pkcs8\",\n \"rand_core\",\n \"sec1\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"env_logger\"\nversion = \"0.9.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a12e6657c4c97ebab115a42dcee77225f7f482cdd841cf7088c657a42e9e00e7\"\ndependencies = [\n \"atty\",\n \"humantime\",\n \"log\",\n \"regex\",\n \"termcolor\",\n]\n\n[[package]]\nname = \"equivalent\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5\"\n\n[[package]]\nname = \"errno\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4bcfec3a70f97c962c307b2d2c56e358cf1d00b558d74262b5f929ee8cc7e73a\"\ndependencies = [\n \"errno-dragonfly\",\n \"libc\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"errno-dragonfly\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf\"\ndependencies = [\n \"cc\",\n \"libc\",\n]\n\n[[package]]\nname = \"ethbloom\"\nversion = \"0.11.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bfb684ac8fa8f6c5759f788862bb22ec6fe3cb392f6bfd08e3c64b603661e3f8\"\ndependencies = [\n \"crunchy\",\n \"fixed-hash\",\n \"impl-rlp\",\n \"impl-serde\",\n \"tiny-keccak\",\n]\n\n[[package]]\nname = \"ethereum-types\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05136f7057fe789f06e6d41d07b34e6f70d8c86e5693b60f97aaa6553553bdaf\"\ndependencies = [\n \"ethbloom\",\n \"fixed-hash\",\n \"impl-rlp\",\n \"impl-serde\",\n \"primitive-types\",\n \"uint\",\n]\n\n[[package]]\nname = \"ff\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d013fc25338cc558c5c2cfbad646908fb23591e2404481826742b651c9af7160\"\ndependencies = [\n \"rand_core\",\n \"subtle\",\n]\n\n[[package]]\nname = \"fixed-hash\"\nversion = \"0.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cfcf0ed7fe52a17a03854ec54a9f76d6d84508d1c0e66bc1793301c73fc8493c\"\ndependencies = [\n \"byteorder\",\n \"rand\",\n \"rustc-hex\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"funty\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fed34cd105917e91daa4da6b3728c47b068749d6a62c59811f06ed2ac71d9da7\"\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"getrandom\"\nversion = \"0.2.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"wasi\",\n]\n\n[[package]]\nname = \"group\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5dfbfb3a6cfbd390d5c9564ab283a0349b9b9fcd46a706c1eb10e0db70bfbac7\"\ndependencies = [\n \"ff\",\n \"rand_core\",\n \"subtle\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.14.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2c6201b9ff9fd90a5a3bac2e56a830d0caa509576f0e503818ee82c181b3437a\"\n\n[[package]]\nname = \"heck\"\nversion = \"0.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c\"\ndependencies = [\n \"unicode-segmentation\",\n]\n\n[[package]]\nname = \"hermit-abi\"\nversion = \"0.1.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"hermit-abi\"\nversion = \"0.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"443144c8cdadd93ebf52ddb4056d257f5b52c04d3c804e657d19eb73fc33668b\"\n\n[[package]]\nname = \"hex\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70\"\n\n[[package]]\nname = \"hmac\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e\"\ndependencies = [\n \"digest\",\n]\n\n[[package]]\nname = \"humantime\"\nversion = \"2.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n\n[[package]]\nname = \"impl-codec\"\nversion = \"0.5.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"161ebdfec3c8e3b52bf61c4f3550a1eea4f9579d10dc1b936f3171ebdcd6c443\"\ndependencies = [\n \"parity-scale-codec\",\n]\n\n[[package]]\nname = \"impl-rlp\"\nversion = \"0.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f28220f89297a075ddc7245cd538076ee98b01f2a9c23a53a4f1105d5a322808\"\ndependencies = [\n \"rlp\",\n]\n\n[[package]]\nname = \"impl-serde\"\nversion = \"0.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4551f042f3438e64dbd6226b20527fc84a6e1fe65688b58746a2f53623f25f5c\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"impl-trait-for-tuples\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11d7a9f6330b71fea57921c9b61c47ee6e84f72d394754eff6163ae67e7395eb\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d5477fe2230a79769d8dc68e0eabf5437907c0457a5614a9e8dddb67f65eb65d\"\ndependencies = [\n \"equivalent\",\n \"hashbrown\",\n]\n\n[[package]]\nname = \"inkwell\"\nversion = \"0.1.0\"\nsource = \"git+https://github.com/matter-labs-forks/inkwell?branch=llvm-15#b8578870c7357e529bf28c3b03dd3e05dd645d1d\"\ndependencies = [\n \"either\",\n \"inkwell_internals\",\n \"libc\",\n \"llvm-sys\",\n \"once_cell\",\n \"parking_lot\",\n \"serde\",\n]\n\n[[package]]\nname = \"inkwell_internals\"\nversion = \"0.6.0\"\nsource = \"git+https://github.com/matter-labs-forks/inkwell?branch=llvm-15#b8578870c7357e529bf28c3b03dd3e05dd645d1d\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"is-terminal\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cb0889898416213fab133e1d33a0e5858a48177452750691bde3666d0fdbaf8b\"\ndependencies = [\n \"hermit-abi 0.3.2\",\n \"rustix\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"itertools\"\nversion = \"0.10.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473\"\ndependencies = [\n \"either\",\n]\n\n[[package]]\nname = \"itoa\"\nversion = \"1.0.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"af150ab688ff2122fcef229be89cb50dd66af9e01a4ff320cc137eecc9bacc38\"\n\n[[package]]\nname = \"k256\"\nversion = \"0.11.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72c1e0b51e7ec0a97369623508396067a486bd0cbed95a2659a4b863d28cfc8b\"\ndependencies = [\n \"cfg-if\",\n \"ecdsa\",\n \"elliptic-curve\",\n \"sha2\",\n]\n\n[[package]]\nname = \"keccak\"\nversion = \"0.1.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8f6d5ed8676d904364de097082f4e7d240b571b67989ced0240f08b7f966f940\"\ndependencies = [\n \"cpufeatures\",\n]\n\n[[package]]\nname = \"lazy_static\"\nversion = \"1.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.147\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3\"\n\n[[package]]\nname = \"libmimalloc-sys\"\nversion = \"0.1.33\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f4ac0e912c8ef1b735e92369695618dc5b1819f5a7bf3f167301a3ba1cea515e\"\ndependencies = [\n \"cc\",\n \"libc\",\n]\n\n[[package]]\nname = \"linux-raw-sys\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"09fc20d2ca12cb9f044c93e3bd6d32d523e6e2ec3db4f7b2939cd99026ecd3f0\"\n\n[[package]]\nname = \"llvm-sys\"\nversion = \"150.0.5\"\nsource = \"git+https://github.com/matter-labs-forks/llvm-sys.rs?branch=llvm-15.0#71d3d59ea8f5974b9ffc3a6631676e0fa2825a27\"\ndependencies = [\n \"cc\",\n \"lazy_static\",\n \"libc\",\n \"regex\",\n \"semver\",\n]\n\n[[package]]\nname = \"lock_api\"\nversion = \"0.4.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c1cc9717a20b1bb222f333e6a92fd32f7d8a18ddc5a3191a11af45dcbf4dcd16\"\ndependencies = [\n \"autocfg\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"log\"\nversion = \"0.4.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b06a4cde4c0f271a446782e3eff8de789548ce57dbc8eca9292c27f4a42004b4\"\n\n[[package]]\nname = \"md5\"\nversion = \"0.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"490cc448043f947bae3cbee9c203358d62dbee0db12107a74be5c30ccfd09771\"\n\n[[package]]\nname = \"memchr\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n\n[[package]]\nname = \"memoffset\"\nversion = \"0.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5a634b1c61a95585bd15607c6ab0c4e5b226e695ff2800ba0cdccddf208c406c\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"mimalloc\"\nversion = \"0.1.37\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4e2894987a3459f3ffb755608bd82188f8ed00d0ae077f1edea29c068d639d98\"\ndependencies = [\n \"libmimalloc-sys\",\n]\n\n[[package]]\nname = \"minimal-lexical\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a\"\n\n[[package]]\nname = \"nom\"\nversion = \"7.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a\"\ndependencies = [\n \"memchr\",\n \"minimal-lexical\",\n]\n\n[[package]]\nname = \"num\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b05180d69e3da0e530ba2a1dae5110317e49e3b7f3d41be227dc5f92e49ee7af\"\ndependencies = [\n \"num-bigint\",\n \"num-complex\",\n \"num-integer\",\n \"num-iter\",\n \"num-rational\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-bigint\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f93ab6289c7b344a8a9f60f88d80aa20032336fe78da341afc91c8a2341fc75f\"\ndependencies = [\n \"autocfg\",\n \"num-integer\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-complex\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"02e0d21255c828d6f128a1e41534206671e8c3ea0c62f32291e808dc82cff17d\"\ndependencies = [\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-integer\"\nversion = \"0.1.45\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"225d3389fb3509a24c93f5c29eb6bde2586b98d9f016636dff58d7c6f7569cd9\"\ndependencies = [\n \"autocfg\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-iter\"\nversion = \"0.1.43\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7d03e6c028c5dc5cac6e2dec0efda81fc887605bb3d884578bb6d6bf7514e252\"\ndependencies = [\n \"autocfg\",\n \"num-integer\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-rational\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0638a1c9d0a3c0914158145bc76cff373a75a627e6ecbfb71cbe6f453a5a19b0\"\ndependencies = [\n \"autocfg\",\n \"num-bigint\",\n \"num-integer\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-traits\"\nversion = \"0.2.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"num_cpus\"\nversion = \"1.16.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43\"\ndependencies = [\n \"hermit-abi 0.3.2\",\n \"libc\",\n]\n\n[[package]]\nname = \"once_cell\"\nversion = \"1.18.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d\"\n\n[[package]]\nname = \"parity-scale-codec\"\nversion = \"2.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"373b1a4c1338d9cd3d1fa53b3a11bdab5ab6bd80a20f7f7becd76953ae2be909\"\ndependencies = [\n \"arrayvec\",\n \"bitvec\",\n \"byte-slice-cast\",\n \"impl-trait-for-tuples\",\n \"parity-scale-codec-derive\",\n \"serde\",\n]\n\n[[package]]\nname = \"parity-scale-codec-derive\"\nversion = \"2.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1557010476e0595c9b568d16dcfb81b93cdeb157612726f5170d31aa707bed27\"\ndependencies = [\n \"proc-macro-crate\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"parking_lot\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\ndependencies = [\n \"lock_api\",\n \"parking_lot_core\",\n]\n\n[[package]]\nname = \"parking_lot_core\"\nversion = \"0.9.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"93f00c865fe7cabf650081affecd3871070f26767e7b2070a3ffae14c654b447\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"redox_syscall\",\n \"smallvec\",\n \"windows-targets\",\n]\n\n[[package]]\nname = \"pkcs8\"\nversion = \"0.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9eca2c590a5f85da82668fa685c09ce2888b9430e83299debf1f34b65fd4a4ba\"\ndependencies = [\n \"der\",\n \"spki\",\n]\n\n[[package]]\nname = \"ppv-lite86\"\nversion = \"0.2.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de\"\n\n[[package]]\nname = \"primitive-types\"\nversion = \"0.10.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05e4722c697a58a99d5d06a08c30821d7c082a4632198de1eaa5a6c22ef42373\"\ndependencies = [\n \"fixed-hash\",\n \"impl-codec\",\n \"impl-rlp\",\n \"impl-serde\",\n \"uint\",\n]\n\n[[package]]\nname = \"proc-macro-crate\"\nversion = \"1.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919\"\ndependencies = [\n \"once_cell\",\n \"toml_edit\",\n]\n\n[[package]]\nname = \"proc-macro-error\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c\"\ndependencies = [\n \"proc-macro-error-attr\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n \"version_check\",\n]\n\n[[package]]\nname = \"proc-macro-error-attr\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"version_check\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.66\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"18fb31db3f9bddb2ea821cde30a9f70117e3f119938b5ee630b7403aa6e2ead9\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"psm\"\nversion = \"0.1.21\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5787f7cda34e3033a72192c018bc5883100330f362ef279a8cbccfce8bb4e874\"\ndependencies = [\n \"cc\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5fe8a65d69dd0808184ebb5f836ab526bb259db23c657efa38711b1072ee47f0\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"radium\"\nversion = \"0.6.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"643f8f41a8ebc4c5dc4515c82bb8abd397b527fc20fd681b7c011c2aee5d44fb\"\n\n[[package]]\nname = \"rand\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\ndependencies = [\n \"libc\",\n \"rand_chacha\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_chacha\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\ndependencies = [\n \"ppv-lite86\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_core\"\nversion = \"0.6.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\ndependencies = [\n \"getrandom\",\n]\n\n[[package]]\nname = \"rayon\"\nversion = \"1.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1d2df5196e37bcc87abebc0053e20787d73847bb33134a69841207dd0a47f03b\"\ndependencies = [\n \"either\",\n \"rayon-core\",\n]\n\n[[package]]\nname = \"rayon-core\"\nversion = \"1.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4b8f95bd6966f5c87776639160a66bd8ab9895d9d4ab01ddba9fc60661aebe8d\"\ndependencies = [\n \"crossbeam-channel\",\n \"crossbeam-deque\",\n \"crossbeam-utils\",\n \"num_cpus\",\n]\n\n[[package]]\nname = \"redox_syscall\"\nversion = \"0.3.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29\"\ndependencies = [\n \"bitflags 1.3.2\",\n]\n\n[[package]]\nname = \"regex\"\nversion = \"1.9.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b2eae68fc220f7cf2532e4494aded17545fce192d59cd996e0fe7887f4ceb575\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-automata\",\n \"regex-syntax\",\n]\n\n[[package]]\nname = \"regex-automata\"\nversion = \"0.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"39354c10dd07468c2e73926b23bb9c2caca74c5501e38a35da70406f1d923310\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-syntax\",\n]\n\n[[package]]\nname = \"regex-syntax\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e5ea92a5b6195c6ef2a0295ea818b312502c6fc94dde986c5553242e18fd4ce2\"\n\n[[package]]\nname = \"rfc6979\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7743f17af12fa0b03b803ba12cd6a8d9483a587e89c69445e3909655c0b9fabb\"\ndependencies = [\n \"crypto-bigint\",\n \"hmac\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"rlp\"\nversion = \"0.5.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bb919243f34364b6bd2fc10ef797edbfa75f33c252e7998527479c6d6b47e1ec\"\ndependencies = [\n \"bytes\",\n \"rustc-hex\",\n]\n\n[[package]]\nname = \"rustc-hex\"\nversion = \"2.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3e75f6a532d0fd9f7f13144f392b6ad56a32696bfcd9c78f797f16bbb6f072d6\"\n\n[[package]]\nname = \"rustix\"\nversion = \"0.38.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0a962918ea88d644592894bc6dc55acc6c0956488adcebbfb6e273506b7fd6e5\"\ndependencies = [\n \"bitflags 2.3.3\",\n \"errno\",\n \"libc\",\n \"linux-raw-sys\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"ryu\"\nversion = \"1.0.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1ad4cc8da4ef723ed60bced201181d83791ad433213d8c24efffda1eec85d741\"\n\n[[package]]\nname = \"scopeguard\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n\n[[package]]\nname = \"sec1\"\nversion = \"0.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3be24c1842290c45df0a7bf069e0c268a747ad05a192f2fd7dcfdbc1cba40928\"\ndependencies = [\n \"base16ct\",\n \"der\",\n \"generic-array\",\n \"pkcs8\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"semver\"\nversion = \"1.0.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0293b4b29daaf487284529cc2f5675b8e57c61f70167ba415a463651fd6a918\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.171\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"30e27d1e4fd7659406c492fd6cfaf2066ba8773de45ca75e855590f856dc34a9\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.171\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"389894603bd18c46fa56231694f8d827779c0951a667087194cf9de94ed24682\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.26\",\n]\n\n[[package]]\nname = \"serde_json\"\nversion = \"1.0.103\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d03b412469450d4404fe8499a268edd7f8b79fecb074b0d812ad64ca21f4031b\"\ndependencies = [\n \"itoa\",\n \"ryu\",\n \"serde\",\n]\n\n[[package]]\nname = \"serde_stacker\"\nversion = \"0.1.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f5321e680f77e7b5cfccc78708ff86a814d39aba030610aee67bd5eaf8a1c30\"\ndependencies = [\n \"serde\",\n \"stacker\",\n]\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"82e6b795fe2e3b1e845bafcb27aa35405c4d47cdfc92af5fc8d3002f76cebdc0\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"sha3\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bdf0c33fae925bdc080598b84bc15c55e7b9a4a43b3c704da051f977469691c9\"\ndependencies = [\n \"digest\",\n \"keccak\",\n]\n\n[[package]]\nname = \"signature\"\nversion = \"1.6.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"74233d3b3b2f6d4b006dc19dee745e73e2a6bfb6f93607cd3b02bd5b00797d7c\"\ndependencies = [\n \"digest\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"smallvec\"\nversion = \"1.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"62bb4feee49fdd9f707ef802e22365a35de4b7b299de4763d44bfea899442ff9\"\n\n[[package]]\nname = \"spki\"\nversion = \"0.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"67cf02bbac7a337dc36e4f5a693db6c21e7863f45070f7064577eb4367a3212b\"\ndependencies = [\n \"base64ct\",\n \"der\",\n]\n\n[[package]]\nname = \"stacker\"\nversion = \"0.1.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c886bd4480155fd3ef527d45e9ac8dd7118a898a46530b7b94c3e21866259fce\"\ndependencies = [\n \"cc\",\n \"cfg-if\",\n \"libc\",\n \"psm\",\n \"winapi\",\n]\n\n[[package]]\nname = \"static_assertions\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n\n[[package]]\nname = \"structopt\"\nversion = \"0.3.26\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0c6b5c64445ba8094a6ab0c3cd2ad323e07171012d9c98b0b15651daf1787a10\"\ndependencies = [\n \"clap\",\n \"lazy_static\",\n \"structopt-derive\",\n]\n\n[[package]]\nname = \"structopt-derive\"\nversion = \"0.4.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dcb5ae327f9cc13b68763b5749770cb9e048a99bd9dfdfa58d0cf05d5f64afe0\"\ndependencies = [\n \"heck\",\n \"proc-macro-error\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"subtle\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"81cdd64d312baedb58e21336b31bc043b77e01cc99033ce76ef539f78e965ebc\"\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.109\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.26\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"45c3457aacde3c65315de5031ec191ce46604304d2446e803d71ade03308d970\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"tap\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n\n[[package]]\nname = \"termcolor\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6\"\ndependencies = [\n \"winapi-util\",\n]\n\n[[package]]\nname = \"textwrap\"\nversion = \"0.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\ndependencies = [\n \"unicode-width\",\n]\n\n[[package]]\nname = \"thiserror\"\nversion = \"1.0.43\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a35fc5b8971143ca348fa6df4f024d4d55264f3468c71ad1c2f365b0a4d58c42\"\ndependencies = [\n \"thiserror-impl\",\n]\n\n[[package]]\nname = \"thiserror-impl\"\nversion = \"1.0.43\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"463fe12d7993d3b327787537ce8dd4dfa058de32fc2b195ef3cde03dc4771e8f\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.26\",\n]\n\n[[package]]\nname = \"tiny-keccak\"\nversion = \"2.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237\"\ndependencies = [\n \"crunchy\",\n]\n\n[[package]]\nname = \"toml_datetime\"\nversion = \"0.6.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7cda73e2f1397b1262d6dfdcef8aafae14d1de7748d66822d3bfeeb6d03e5e4b\"\n\n[[package]]\nname = \"toml_edit\"\nversion = \"0.19.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f8123f27e969974a3dfba720fdb560be359f57b44302d280ba72e76a74480e8a\"\ndependencies = [\n \"indexmap\",\n \"toml_datetime\",\n \"winnow\",\n]\n\n[[package]]\nname = \"typenum\"\nversion = \"1.16.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba\"\n\n[[package]]\nname = \"uint\"\nversion = \"0.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52\"\ndependencies = [\n \"byteorder\",\n \"crunchy\",\n \"hex\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"301abaae475aa91687eb82514b328ab47a211a533026cb25fc3e519b86adfc3c\"\n\n[[package]]\nname = \"unicode-segmentation\"\nversion = \"1.10.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1dd624098567895118886609431a7c3b8f516e41d30e0643f03d94592a147e36\"\n\n[[package]]\nname = \"unicode-width\"\nversion = \"0.1.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b\"\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n\n[[package]]\nname = \"winapi\"\nversion = \"0.3.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\ndependencies = [\n \"winapi-i686-pc-windows-gnu\",\n \"winapi-x86_64-pc-windows-gnu\",\n]\n\n[[package]]\nname = \"winapi-i686-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n\n[[package]]\nname = \"winapi-util\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178\"\ndependencies = [\n \"winapi\",\n]\n\n[[package]]\nname = \"winapi-x86_64-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n\n[[package]]\nname = \"windows-sys\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9\"\ndependencies = [\n \"windows-targets\",\n]\n\n[[package]]\nname = \"windows-targets\"\nversion = \"0.48.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05d4b17490f70499f20b9e791dcf6a299785ce8af4d709018206dc5b4953e95f\"\ndependencies = [\n \"windows_aarch64_gnullvm\",\n \"windows_aarch64_msvc\",\n \"windows_i686_gnu\",\n \"windows_i686_msvc\",\n \"windows_x86_64_gnu\",\n \"windows_x86_64_gnullvm\",\n \"windows_x86_64_msvc\",\n]\n\n[[package]]\nname = \"windows_aarch64_gnullvm\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"91ae572e1b79dba883e0d315474df7305d12f569b400fcf90581b06062f7e1bc\"\n\n[[package]]\nname = \"windows_aarch64_msvc\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b2ef27e0d7bdfcfc7b868b317c1d32c641a6fe4629c171b8928c7b08d98d7cf3\"\n\n[[package]]\nname = \"windows_i686_gnu\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"622a1962a7db830d6fd0a69683c80a18fda201879f0f447f065a3b7467daa241\"\n\n[[package]]\nname = \"windows_i686_msvc\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4542c6e364ce21bf45d69fdd2a8e455fa38d316158cfd43b3ac1c5b1b19f8e00\"\n\n[[package]]\nname = \"windows_x86_64_gnu\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ca2b8a661f7628cbd23440e50b05d705db3686f894fc9580820623656af974b1\"\n\n[[package]]\nname = \"windows_x86_64_gnullvm\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7896dbc1f41e08872e9d5e8f8baa8fdd2677f29468c4e156210174edc7f7b953\"\n\n[[package]]\nname = \"windows_x86_64_msvc\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a\"\n\n[[package]]\nname = \"winnow\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"81fac9742fd1ad1bd9643b991319f72dd031016d44b77039a26977eb667141e7\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"wyz\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85e60b0d1b5f99db2556934e21937020776a5d31520bf169e851ac44e6420214\"\n\n[[package]]\nname = \"zeroize\"\nversion = \"1.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2a0956f1ba7c7909bfb66c2e9e4124ab6f6482560f6628b5aaeba39207c9aad9\"\n\n[[package]]\nname = \"zkevm-assembly\"\nversion = \"1.3.2\"\nsource = \"git+https://github.com/matter-labs/era-zkEVM-assembly?branch=v1.3.2#edc364e59a2eea9c4b1d4ce79f15d0b7c6b55b98\"\ndependencies = [\n \"env_logger\",\n \"hex\",\n \"lazy_static\",\n \"log\",\n \"nom\",\n \"num-bigint\",\n \"num-traits\",\n \"sha3\",\n \"smallvec\",\n \"structopt\",\n \"thiserror\",\n \"zkevm_opcode_defs\",\n]\n\n[[package]]\nname = \"zkevm_opcode_defs\"\nversion = \"1.3.2\"\nsource = \"git+https://github.com/matter-labs/era-zkevm_opcode_defs?branch=v1.3.2#2f69c6975a272e8c31d2d82c136a4ea81df25115\"\ndependencies = [\n \"bitflags 2.3.3\",\n \"blake2\",\n \"ethereum-types\",\n \"k256\",\n \"lazy_static\",\n \"sha2\",\n \"sha3\",\n]\n", "[package]\nname = \"compiler-vyper\"\nversion = \"1.3.9\"\nauthors = [\n    \"Alex Zarudnyy <a.zarudnyy@matterlabs.dev>\",\n]\nlicense = \"MIT OR Apache-2.0\"\nedition = \"2021\"\ndescription = \"The zkEVM Vyper compiler\"\n\n[[bin]]\nname = \"zkvyper\"\npath = \"src/zkvyper/main.rs\"\n\n[lib]\ndoctest = false\n\n[dependencies]\nstructopt = { version = \"0.3\", default-features = false }\ncolored = \"2.0\"\nanyhow = \"1.0\"\n\nrayon = \"1.7\"\n\nserde = { version = \"1.0\", \"features\" = [ \"derive\" ] }\nserde_json = { version = \"1.0\", features = [ \"arbitrary_precision\", \"unbounded_depth\" ]}\nserde_stacker = \"0.1\"\nonce_cell = \"1.17\"\nlazy_static = \"1.4\"\nhex = \"0.4\"\nsha3 = \"0.10\"\nsemver = { version = \"1.0\", features = [ \"serde\" ] }\n\nzkevm_opcode_defs = { git = \"https://github.com/matter-labs/era-zkevm_opcode_defs\", branch = \"v1.3.2\" }\nzkevm-assembly = { git = \"https://github.com/matter-labs/era-zkEVM-assembly\", branch = \"v1.3.2\" }\n\ncompiler-common = { git = \"https://github.com/matter-labs/era-compiler-common\", branch = \"main\" }\ncompiler-llvm-context = { git = \"https://github.com/matter-labs/era-compiler-llvm-context\", branch = \"main\" }\n\n[dependencies.inkwell]\ngit = \"https://github.com/matter-labs-forks/inkwell\"\nbranch = \"llvm-15\"\ndefault-features = false\nfeatures = [\"llvm15-0\", \"no-libffi-linking\", \"target-syncvm\"]\n\n[target.'cfg(target_env = \"musl\")'.dependencies]\nmimalloc = { version = \"*\", default-features = false }\n", "# zkSync Era: Vyper Compiler\n\n[![Logo](eraLogo.svg)](https://zksync.io/)\n\nzkSync Era is a layer 2 rollup that uses zero-knowledge proofs to scale Ethereum without compromising on security\nor decentralization. As it\u2019s EVM-compatible (with Solidity/Vyper), 99% of Ethereum projects can redeploy without\nneeding to refactor or re-audit any code. zkSync Era also uses an LLVM-based compiler that will eventually enable\ndevelopers to write smart contracts in popular languages such as C++ and Rust.\n\nThis repository contains the compiler from Vyper to zkEVM bytecode.\n\n## System Requirements\n\nSupported platforms:\n- **Linux: x86_64**  \n   MUSL-based static builds do not depend on system libraries and run on any recent Linux distribution.  \n- **MacOS 11+: x86_64, arm64 (M1, M2)**\n- **Windows: x86_64**  \n   Only Windows 10 has been tested so far, but other versions should be OK as well.  \n\nWe recommend at least 4 GB of RAM available for the build process.\n\n## Building\n\n1. Install some tools system-wide:  \n   1.a. `apt install cmake ninja-build clang-13 lld-13 parallel` on a Debian-based Linux, with optional `musl-tools` if you need a `musl` build.  \n   1.b. `pacman -S cmake ninja clang lld parallel` on an Arch-based Linux.  \n   1.c. On MacOS, install the [HomeBrew](https://brew.sh) package manager (being careful to install it as the appropriate user), then `brew install cmake ninja coreutils parallel`. Install your choice of a recent LLVM/[Clang](https://clang.llvm.org) compiler, e.g. via [Xcode](https://developer.apple.com/xcode/), [Apple\u2019s Command Line Tools](https://developer.apple.com/library/archive/technotes/tn2339/_index.html), or your preferred package manager.  \n   1.d. Their equivalents with other package managers.  \n\n2. [Install Rust](https://www.rust-lang.org/tools/install)\n\n   Currently we are not pinned to any specific version of Rust, so just install the latest stable build for your platform.  \n   Also install the `musl` target if you are compiling on Linux in order to distribute the binary:  \n   `rustup target add x86_64-unknown-linux-musl`  \n\n3. Download [v0.3.3 or v0.3.9 of the Vyper compiler](https://github.com/vyperlang/vyper/releases).  \n   If it is not named exactly `vyper` in your `$PATH`, see the `--vyper` option below.  \n   \n4. Check out or clone the appropriate branch of this repository.  \n\n5. Go to the project root and run `git checkout <ref>` with the tag, branch, or commit you want to build.  \n\n6. Install the zkEVM LLVM framework builder:  \n   6.a. `cargo install compiler-llvm-builder` on MacOS, or Linux for personal use.  \n   6.b. `cargo install compiler-llvm-builder --target x86_64-unknown-linux-musl` on Linux for distribution.  \n\n   The builder is not the [zkEVM LLVM framework](https://github.com/matter-labs/compiler-llvm) itself; it is just a tool that clones our repository and runs the sequence of build commands.  \n   By default it is installed in `~/.cargo/bin/`, which is recommended to be added to your `$PATH`. Execute `zkevm-llvm --help` for more information.  \n   If you need a specific branch of zkEVM LLVM, change it in the `LLVM.lock` file at the root of this repository.  \n\n7. Run the builder to clone and build the zkEVM LLVM framework at this repository root:  \n   7.1. `zkevm-llvm clone`  \n   7.2. `zkevm-llvm build`  \n\n8. Build the Vyper compiler executable:  \n   8.a. `cargo build --release` on MacOS or Linux for personal use.  \n   8.b. `cargo build --release --target x86_64-unknown-linux-musl` on Linux for distribution.  \n\n9. If you need to move the built binary elsewhere, grab it from the build directory:  \n   9.a. On MacOS or Linux for the default target: `./target/release/zkvyper`  \n   9.b. On Linux, if you are building for the target `x86_64-unknown-linux-musl`: `./target/x86_64-unknown-linux-musl/release/zkvyper`  \n\n## Usage\n\nCheck `./target/*/zkvyper --help` for compiler usage.  \n\nA support version of the Vyper compiler must be available in `$PATH`, or its path must be passed explicitly with the `--vyper` option.\n\nSupported versions:\n- 0.3.3\n- 0.3.9\n\nFor big projects it is more convenient to use the compiler via the Hardhat plugin. For single-file contracts, or small\nprojects, the CLI suffices.\n\n## Unit testing\n\nFor running unit tests, `zkvyper` itself must also be available in `$PATH`, because it calls itself recursively to allow\ncompiling each contract in a separate process. To successfully run unit tests:\n\n1. Run `cargo build --release`.\n2. Move the binary from `./target/release/zkvyper` to a directory from `$PATH`, or add the target directory itself to `$PATH`.\n3. Run `cargo test`.\n\n## CLI reference\n\n#### `--version`\nPrint the version and exit.  \n\n#### `<input_files>`\nSpecify the input file paths.  \nMultiple Vyper files can be passed in the default Vyper mode.  \nLLVM IR mode currently supports only a single file.  \n\n#### `-o`, `--output-dir <path>`\nCreate one file per component and contract/file at the specified directory, if given.  \n\n#### `--overwrite`\nOverwrite existing files (used together with -o).  \n\n#### `-O`, `--optimization <level>`\nSet the LLVM optimization parameter `-O[0 | 1 | 2 | 3 | s | z]`.  \nUse `3` for best performance and `z` for minimal size.  \n\n#### `--disable-vyper-optimizer`\nDisable the `vyper` LLL IR optimizer.  \n\n#### `--vyper <path>`\nSpecify the path to the `vyper` executable. By default, the one in `${PATH}` is used.  \nIn LLVM IR mode `vyper` is unused.  \n\n#### `-f <format>`\nAn extra output format string.\nSee `vyper --help` for available options.\n\n#### `--llvm-ir`\nSwitch to LLVM IR mode.  \nOnly one input LLVM IR file is allowed.  \nCannot be used with combined or standard JSON modes.  \n\n#### `--zkasm`\nSwitch to zkEVM assembly mode.  \nOnly one input zkEVM assembly file is allowed.  \nCannot be used with combined or standard JSON modes.  \n\n#### `--metadata-hash`\nSet metadata hash mode: `keccak256` | `none`.\n`keccak256` is enabled by default.\n\n#### `--debug-output-dir <path>`\nDump all IR (LLL, LLVM IR, assembly) to files in the specified directory.  \nOnly for testing and debugging.  \n\n#### `--llvm-verify-each`\nSet the `verify-each` option in LLVM.\nOnly for testing and debugging.  \n\n#### `--llvm-debug-logging`\nSet the `debug-logging` option in LLVM.\nOnly for testing and debugging.  \n\n#### `--recursive-process`\nRun this process recursively and provide JSON input to compile a single contract.  \nOnly for usage from within the compiler.  \n\n## Troubleshooting\n\n- If you get a \u201cfailed to authenticate when downloading repository\u2026 if the git CLI succeeds then net.git-fetch-with-cli may help here\u201d error, then prepending the `cargo` command with `CARGO_NET_GIT_FETCH_WITH_CLI=true` may help.\n- On MacOS, `git config --global credential.helper osxkeychain` followed by cloning a repository manually with a personal access token may help.\n- Unset any LLVM-related environment variables you may have set, especially `LLVM_SYS_<version>_PREFIX` (see e.g. [https://crates.io/crates/llvm-sys](https://crates.io/crates/llvm-sys) and [https://llvm.org/docs/GettingStarted.html#local-llvm-configuration](https://llvm.org/docs/GettingStarted.html#local-llvm-configuration)). To make sure: `set | grep LLVM`\n\n## License\n\nThe Vyper compiler is distributed under the terms of either\n\n- Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)\n- MIT license ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)\n\nat your option.\n\n## Resources\n\n[zkSync Era compiler toolchain documentation](https://era.zksync.io/docs/api/compiler-toolchain)  \n\n[Vyper v0.3.3 documentation](https://vyper.readthedocs.io/en/v0.3.3/)  \n[Vyper v0.3.9 documentation](https://vyper.readthedocs.io/en/v0.3.9/)  \n\n[Vyper LLL IR](https://github.com/vyperlang/vyper/blob/master/vyper/ir/README.md)  \n\n> Some parts of the Vyper documentation may be outdated.  \n> Please contact the Vyper team for assistance.  \n\n## Official Links\n\n- [Website](https://zksync.io/)\n- [GitHub](https://github.com/matter-labs)\n- [Twitter](https://twitter.com/zksync)\n- [Twitter for Devs](https://twitter.com/zkSyncDevs)\n- [Discord](https://join.zksync.dev/)\n\n## Disclaimer\n\nzkSync Era has been through extensive testing and audits, and although it is live, it is still in alpha state and\nwill undergo further audits and bug bounty programs. We would love to hear our community's thoughts and suggestions\nabout it!\nIt's important to note that forking it now could potentially lead to missing important\nsecurity updates, critical features, and performance improvements.\n", "//!\n//! The Vyper contract build.\n//!\n\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::Path;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::vyper::combined_json::contract::Contract as CombinedJsonContract;\n\n///\n/// The Vyper contract build.\n///\n#[derive(Debug, Serialize, Deserialize)]\npub struct Contract {\n    /// The LLVM module build.\n    pub build: compiler_llvm_context::Build,\n}\n\nimpl Contract {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(build: compiler_llvm_context::Build) -> Self {\n        Self { build }\n    }\n\n    ///\n    /// Writes the contract text assembly and bytecode to files.\n    ///\n    pub fn write_to_directory(\n        self,\n        output_directory: &Path,\n        contract_path: &Path,\n        overwrite: bool,\n    ) -> anyhow::Result<()> {\n        let contract_name = Self::short_path(contract_path.to_str().expect(\"Always valid\"));\n\n        let assembly_file_name = format!(\n            \"{}.{}\",\n            contract_name,\n            compiler_common::EXTENSION_ZKEVM_ASSEMBLY\n        );\n        let mut assembly_file_path = output_directory.to_owned();\n        assembly_file_path.push(assembly_file_name);\n\n        if assembly_file_path.exists() && !overwrite {\n            eprintln!(\n                \"Refusing to overwrite an existing file {assembly_file_path:?} (use --overwrite to force).\",\n            );\n        } else {\n            File::create(&assembly_file_path)\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} creating error: {}\", assembly_file_path, error)\n                })?\n                .write_all(self.build.assembly_text.as_bytes())\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} writing error: {}\", assembly_file_path, error)\n                })?;\n        }\n\n        let binary_file_name = format!(\n            \"{}.{}\",\n            contract_name,\n            compiler_common::EXTENSION_ZKEVM_BINARY\n        );\n        let mut binary_file_path = output_directory.to_owned();\n        binary_file_path.push(binary_file_name);\n\n        if binary_file_path.exists() && !overwrite {\n            eprintln!(\n                \"Refusing to overwrite an existing file {binary_file_path:?} (use --overwrite to force).\",\n            );\n        } else {\n            File::create(&binary_file_path)\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} creating error: {}\", binary_file_path, error)\n                })?\n                .write_all(self.build.bytecode.as_slice())\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} writing error: {}\", binary_file_path, error)\n                })?;\n        }\n\n        Ok(())\n    }\n\n    ///\n    /// Writes the contract text assembly and bytecode to the combined JSON.\n    ///\n    pub fn write_to_combined_json(\n        self,\n        combined_json_contract: &mut CombinedJsonContract,\n    ) -> anyhow::Result<()> {\n        let hexadecimal_bytecode = hex::encode(self.build.bytecode);\n        match (\n            combined_json_contract.bytecode.as_mut(),\n            combined_json_contract.bytecode_runtime.as_mut(),\n        ) {\n            (Some(bytecode), Some(bytecode_runtime)) => {\n                *bytecode = hexadecimal_bytecode;\n                *bytecode_runtime = bytecode.clone();\n            }\n            (Some(bytecode), None) => {\n                *bytecode = hexadecimal_bytecode;\n            }\n            (None, Some(bytecode_runtime)) => {\n                *bytecode_runtime = hexadecimal_bytecode;\n            }\n            (None, None) => {}\n        }\n\n        combined_json_contract.factory_deps = Some(self.build.factory_dependencies);\n\n        Ok(())\n    }\n\n    ///\n    /// Converts the full path to a short one.\n    ///\n    pub fn short_path(path: &str) -> &str {\n        path.rfind('/')\n            .map(|last_slash| &path[last_slash + 1..])\n            .unwrap_or_else(|| path)\n    }\n}\n", "//!\n//! The LLVM IR contract.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::build::contract::Contract as ContractBuild;\nuse crate::project::contract::metadata::Metadata as ContractMetadata;\n\n///\n/// The LLVM IR contract.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Contract {\n    /// The LLVM framework version.\n    pub version: semver::Version,\n    /// The contract source code.\n    pub source_code: String,\n}\n\nimpl Contract {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(version: semver::Version, source_code: String) -> Self {\n        Self {\n            version,\n            source_code,\n        }\n    }\n\n    ///\n    /// Compiles the contract, returning the build.\n    ///\n    pub fn compile(\n        self,\n        contract_path: &str,\n        source_code_hash: Option<[u8; compiler_common::BYTE_LENGTH_FIELD]>,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<ContractBuild> {\n        let llvm = inkwell::context::Context::create();\n        let optimizer = compiler_llvm_context::Optimizer::new(optimizer_settings);\n\n        let metadata_hash = source_code_hash.map(|source_code_hash| {\n            ContractMetadata::new(\n                &source_code_hash,\n                &self.version,\n                semver::Version::parse(env!(\"CARGO_PKG_VERSION\")).expect(\"Always valid\"),\n                optimizer.settings().to_owned(),\n            )\n            .keccak256()\n        });\n\n        let memory_buffer = inkwell::memory_buffer::MemoryBuffer::create_from_memory_range_copy(\n            self.source_code.as_bytes(),\n            contract_path,\n        );\n        let module = llvm\n            .create_module_from_ir(memory_buffer)\n            .map_err(|error| anyhow::anyhow!(error.to_string()))?;\n        let context = compiler_llvm_context::Context::<compiler_llvm_context::DummyDependency>::new(\n            &llvm,\n            module,\n            optimizer,\n            None,\n            metadata_hash.is_some(),\n            debug_config,\n        );\n\n        let build = context.build(contract_path, metadata_hash)?;\n\n        Ok(ContractBuild::new(build))\n    }\n}\n", "//!\n//! The `assert` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `assert` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Assert([Box<Expression>; 1]);\n\nimpl Assert {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let [condition] = self.0;\n\n        let error_block = context.append_basic_block(\"if_error\");\n        let join_block = context.append_basic_block(\"if_join\");\n\n        let condition = condition\n            .into_llvm_value(context)?\n            .expect(\"Always exists\")\n            .into_int_value();\n        let condition = context.builder().build_int_z_extend_or_bit_cast(\n            condition,\n            context.field_type(),\n            \"if_condition_extended\",\n        );\n        let condition = context.builder().build_int_compare(\n            inkwell::IntPredicate::NE,\n            condition,\n            context.field_const(0),\n            \"if_condition_compared\",\n        );\n        context.build_conditional_branch(condition, join_block, error_block);\n\n        context.set_basic_block(error_block);\n        context.build_exit(\n            context.intrinsics().revert,\n            context.field_const(0),\n            context.field_const(0),\n        );\n\n        context.set_basic_block(join_block);\n\n        Ok(())\n    }\n}\n", "//!\n//! The Vyper LLL-specific `clamp` instructions.\n//!\n\nuse inkwell::values::BasicValue;\n\n///\n/// Translates the two-sides bounded clamp.\n///\npub fn ordinary<'ctx, D>(\n    context: &mut compiler_llvm_context::Context<'ctx, D>,\n    operand_1: inkwell::values::IntValue<'ctx>,\n    operand_2: inkwell::values::IntValue<'ctx>,\n    operand_3: inkwell::values::IntValue<'ctx>,\n    is_signed: bool,\n) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>\nwhere\n    D: compiler_llvm_context::Dependency + Clone,\n{\n    let error_block = context.append_basic_block(\"if_error\");\n    let join_block = context.append_basic_block(\"if_join\");\n\n    let (predicate_one, predicate_two) = if is_signed {\n        (inkwell::IntPredicate::SLE, inkwell::IntPredicate::SGE)\n    } else {\n        (inkwell::IntPredicate::ULE, inkwell::IntPredicate::UGE)\n    };\n\n    let condition_one = context.builder().build_int_compare(\n        predicate_one,\n        operand_2,\n        operand_3,\n        \"clamp_condition_one\",\n    );\n    let condition_two = context.builder().build_int_compare(\n        predicate_two,\n        operand_3,\n        operand_1,\n        \"clamp_condition_two\",\n    );\n    let condition = context\n        .builder()\n        .build_and(condition_one, condition_two, \"clamp_condition\");\n    context.build_conditional_branch(condition, join_block, error_block);\n\n    context.set_basic_block(error_block);\n    context.build_exit(\n        context.intrinsics().revert,\n        context.field_const(0),\n        context.field_const(0),\n    );\n\n    context.set_basic_block(join_block);\n\n    Ok(operand_2.as_basic_value_enum())\n}\n\n///\n/// Translates the one-side bounded clamp with predicate.\n///\npub fn with_predicate<'ctx, D>(\n    context: &mut compiler_llvm_context::Context<'ctx, D>,\n    operand_1: inkwell::values::IntValue<'ctx>,\n    operand_2: inkwell::values::IntValue<'ctx>,\n    predicate: inkwell::IntPredicate,\n) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>\nwhere\n    D: compiler_llvm_context::Dependency + Clone,\n{\n    let error_block = context.append_basic_block(\"clamp_single_error\");\n    let join_block = context.append_basic_block(\"clamp_single_join\");\n\n    let condition = context.builder().build_int_compare(\n        predicate,\n        operand_1,\n        operand_2,\n        \"clamp_single_condition\",\n    );\n    context.build_conditional_branch(condition, join_block, error_block);\n\n    context.set_basic_block(error_block);\n    context.build_exit(\n        context.intrinsics().revert,\n        context.field_const(0),\n        context.field_const(0),\n    );\n\n    context.set_basic_block(join_block);\n\n    Ok(operand_1.as_basic_value_enum())\n}\n", "//!\n//! The `create` instruction adapter.\n//!\n\n///\n/// Translates the Vyper LLL `create` input layout into the one expected by zkEVM.\n///\n/// This function extracts the address from the calldata previously assembled in the LLL by the\n/// Vyper compiler. Then the address is written to the corresponding offset as the first argument\n/// of the forwarder's constructor.\n///\npub fn create<'ctx, D>(\n    context: &mut compiler_llvm_context::Context<'ctx, D>,\n    value: inkwell::values::IntValue<'ctx>,\n    input_offset: inkwell::values::IntValue<'ctx>,\n    salt: Option<inkwell::values::IntValue<'ctx>>,\n) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>\nwhere\n    D: compiler_llvm_context::Dependency + Clone,\n{\n    let success_block = context.append_basic_block(\"create_success_block\");\n    let failure_block = context.append_basic_block(\"create_failure_block\");\n    let join_block = context.append_basic_block(\"create_join_block\");\n\n    let address_offset = context.builder().build_int_add(\n        input_offset,\n        context.field_const(19),\n        \"create_address_offset\",\n    );\n    let address_dirty_pointer = compiler_llvm_context::Pointer::new_with_offset(\n        context,\n        compiler_llvm_context::AddressSpace::Heap,\n        context.field_type(),\n        address_offset,\n        \"create_address_dirty_pointer\",\n    );\n    let address_dirty = context.build_load(address_dirty_pointer, \"create_address_dirty\");\n    let address = context.builder().build_right_shift(\n        address_dirty.into_int_value(),\n        context.field_const(\n            ((compiler_common::BYTE_LENGTH_FIELD - compiler_common::BYTE_LENGTH_ETH_ADDRESS)\n                * compiler_common::BIT_LENGTH_BYTE) as u64,\n        ),\n        false,\n        \"create_address\",\n    );\n\n    let calldata_offset = context.field_const(compiler_llvm_context::HEAP_AUX_OFFSET_EXTERNAL_CALL);\n    let calldata_length = context.field_const(\n        (compiler_llvm_context::DEPLOYER_CALL_HEADER_SIZE + compiler_common::BYTE_LENGTH_FIELD)\n            as u64,\n    );\n\n    let hash_input_offset = context.builder().build_int_add(\n        calldata_offset,\n        context.field_const(\n            (compiler_common::BYTE_LENGTH_X32 + compiler_common::BYTE_LENGTH_FIELD) as u64,\n        ),\n        \"create_hash_input_offset\",\n    );\n    let hash_input_offset_pointer = compiler_llvm_context::Pointer::new_with_offset(\n        context,\n        compiler_llvm_context::AddressSpace::HeapAuxiliary,\n        context.field_type(),\n        hash_input_offset,\n        \"create_hash_input_offset_pointer\",\n    );\n    let hash = context.compile_dependency(crate::r#const::FORWARDER_CONTRACT_NAME)?;\n    context.build_store(\n        hash_input_offset_pointer,\n        context.field_const_str_hex(hash.as_str()),\n    );\n\n    let address_input_offset = context.builder().build_int_add(\n        calldata_offset,\n        context.field_const(compiler_llvm_context::DEPLOYER_CALL_HEADER_SIZE as u64),\n        \"create_address_input_offset\",\n    );\n    let address_input_offset_pointer = compiler_llvm_context::Pointer::new_with_offset(\n        context,\n        compiler_llvm_context::AddressSpace::HeapAuxiliary,\n        context.field_type(),\n        address_input_offset,\n        \"create_address_input_offset_pointer\",\n    );\n    context.build_store(address_input_offset_pointer, address);\n\n    let result_pointer = context.build_alloca(context.field_type(), \"create_result_pointer\");\n    context.build_store(result_pointer, context.field_const(0));\n    let address_or_status_code = match salt {\n        Some(salt) => compiler_llvm_context::create::create2(\n            context,\n            value,\n            calldata_offset,\n            calldata_length,\n            Some(salt),\n        ),\n        None => {\n            compiler_llvm_context::create::create(context, value, calldata_offset, calldata_length)\n        }\n    }?;\n    let address_or_status_code_is_zero = context.builder().build_int_compare(\n        inkwell::IntPredicate::EQ,\n        address_or_status_code.into_int_value(),\n        context.field_const(0),\n        \"create_address_or_status_code_is_zero\",\n    );\n    context.build_conditional_branch(address_or_status_code_is_zero, failure_block, success_block);\n\n    context.set_basic_block(success_block);\n    context.build_store(result_pointer, address_or_status_code);\n    context.build_unconditional_branch(join_block);\n\n    context.set_basic_block(failure_block);\n    let return_data_size = context.get_global(compiler_llvm_context::GLOBAL_RETURN_DATA_SIZE)?;\n    compiler_llvm_context::return_data::copy(\n        context,\n        context.field_const(0),\n        context.field_const(0),\n        return_data_size.into_int_value(),\n    )?;\n    context.build_exit(\n        context.intrinsics().revert,\n        context.field_const(0),\n        return_data_size.into_int_value(),\n    );\n    context.build_unconditional_branch(join_block);\n\n    context.set_basic_block(join_block);\n    let result = context.build_load(result_pointer, \"create_result\");\n    Ok(result)\n}\n", "//!\n//! The `exit_to` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `exit_to` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ExitTo(Vec<Expression>);\n\nimpl ExitTo {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        mut self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let label_name = self.0.remove(0).try_into_identifier()?;\n        if label_name.as_str() == crate::r#const::VARIABLE_IDENTIFIER_RETURN_PC {\n            context.build_unconditional_branch(context.current_function().borrow().return_block());\n            return Ok(());\n        }\n        let label_name = label_name\n            .strip_prefix(crate::r#const::LABEL_DESTINATION_PREFIX)\n            .ok_or_else(|| {\n                anyhow::anyhow!(\n                    \"Block `{}` has no `{}` prefix\",\n                    label_name,\n                    crate::r#const::LABEL_DESTINATION_PREFIX\n                )\n            })?;\n\n        let block = context\n            .current_function()\n            .borrow()\n            .declaration()\n            .value\n            .get_basic_blocks()\n            .iter()\n            .find(|block| block.get_name().to_string_lossy() == label_name)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Block `{}` does not exist\", label_name))?;\n\n        let argument_names = context\n            .current_function()\n            .borrow()\n            .vyper()\n            .label_arguments(label_name);\n        if let Some(argument_names) = argument_names {\n            for (name, expression) in argument_names.into_iter().zip(self.0) {\n                let pointer = context\n                    .current_function()\n                    .borrow()\n                    .get_stack_pointer(name.as_str())\n                    .ok_or_else(|| anyhow::anyhow!(\"Variable `{}` not found\", name))?;\n                let value = expression.into_llvm_value(context)?.expect(\"Always exists\");\n                context.build_store(pointer, value);\n            }\n        }\n\n        context.build_unconditional_branch(block);\n        Ok(())\n    }\n}\n", "//!\n//! The `goto` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `goto` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Goto(Vec<Expression>);\n\nimpl Goto {\n    ///\n    /// Return a `goto` to the specified block.\n    ///\n    pub fn new_to_block(name: &str) -> Self {\n        Self(vec![Expression::Identifier(name.to_string())])\n    }\n\n    ///\n    /// Generates the function call code.\n    ///\n    pub fn into_function_call<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::Context<D>,\n        label_name: String,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let function = context\n            .get_function(label_name.as_str())\n            .ok_or_else(|| anyhow::anyhow!(\"Function `{}` does not exist\", label_name))?;\n\n        let mut arguments = Vec::new();\n        for expression in self.0.into_iter() {\n            if let Expression::Identifier(ref identifier) = expression {\n                if identifier.starts_with(crate::r#const::LABEL_DESTINATION_PREFIX) {\n                    continue;\n                }\n            }\n\n            let value = expression.into_llvm_value(context)?.expect(\"Always exists\");\n            arguments.push(value);\n        }\n\n        context.build_call(\n            function.borrow().declaration(),\n            arguments.as_slice(),\n            label_name.as_str(),\n        );\n\n        Ok(None)\n    }\n\n    ///\n    /// Generates the block call code.\n    ///\n    pub fn into_block_call<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::Context<D>,\n        label_name: String,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let block = context\n            .current_function()\n            .borrow()\n            .declaration()\n            .value\n            .get_basic_blocks()\n            .iter()\n            .find(|block| block.get_name().to_string_lossy() == label_name)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Block `{}` does not exist\", label_name))?;\n\n        let argument_names = context\n            .current_function()\n            .borrow()\n            .vyper()\n            .label_arguments(label_name.as_str());\n        if let Some(argument_names) = argument_names {\n            for (name, expression) in argument_names.into_iter().zip(self.0) {\n                let pointer = context\n                    .current_function()\n                    .borrow()\n                    .get_stack_pointer(name.as_str())\n                    .ok_or_else(|| anyhow::anyhow!(\"Variable `{}` not found\", name))?;\n                let value = expression.into_llvm_value(context)?.expect(\"Always exists\");\n                context.build_store(pointer, value);\n            }\n        }\n\n        context.build_unconditional_branch(block);\n\n        Ok(None)\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        mut self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let label_name = self.0.remove(0).try_into_identifier()?;\n\n        if label_name.ends_with(crate::r#const::LABEL_SUFFIX_CLEANUP)\n            || label_name == crate::r#const::FUNCTION_IDENTIFIER_FALLBACK\n        {\n            return self.into_block_call(context, label_name);\n        }\n\n        self.into_function_call(context, label_name)\n    }\n}\n", "//!\n//! The `if` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `if` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct If(Vec<Expression>);\n\nimpl If {\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        let mut result = self\n            .0\n            .get_mut(1)\n            .expect(\"Always exists\")\n            .extract_functions()?;\n        if let Some(else_expression) = self.0.get_mut(2) {\n            result.extend(else_expression.extract_functions()?);\n        }\n        Ok(result)\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        mut self,\n        context: &mut compiler_llvm_context::Context<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let main_block = context.append_basic_block(\"if_main\");\n        let join_block = context.append_basic_block(\"if_join\");\n\n        let condition_expression = self.0.remove(0);\n        let main_expression = self.0.remove(0);\n        let else_expression = self.0.pop();\n\n        let result_pointer = context.build_alloca(context.field_type(), \"if_result_pointer\");\n        context.build_store(result_pointer, context.field_const(0));\n        let mut returns_value = false;\n\n        let condition = condition_expression\n            .into_llvm_value(context)?\n            .expect(\"Always exists\")\n            .into_int_value();\n        let condition = context.builder().build_int_z_extend_or_bit_cast(\n            condition,\n            context.field_type(),\n            \"if_condition_extended\",\n        );\n        let condition = context.builder().build_int_compare(\n            inkwell::IntPredicate::NE,\n            condition,\n            context.field_const(0),\n            \"if_condition_compared\",\n        );\n\n        if let Some(else_expression) = else_expression {\n            let else_block = context.append_basic_block(\"if_else\");\n            context.build_conditional_branch(condition, main_block, else_block);\n\n            context.set_basic_block(else_block);\n            if let Some(argument) = else_expression.into_llvm_value(context)? {\n                returns_value = true;\n                context.build_store(result_pointer, argument);\n            }\n            context.build_unconditional_branch(join_block);\n        } else {\n            context.build_conditional_branch(condition, main_block, join_block);\n        }\n\n        context.set_basic_block(main_block);\n        if let Some(argument) = main_expression.into_llvm_value(context)? {\n            returns_value = true;\n            context.build_store(result_pointer, argument);\n        }\n        context.build_unconditional_branch(join_block);\n\n        context.set_basic_block(join_block);\n        if !returns_value {\n            return Ok(None);\n        }\n\n        let result = context.build_load(result_pointer, \"if_result\");\n        Ok(Some(result))\n    }\n}\n", "//!\n//! The immutable instructions.\n//!\n\n///\n/// Translates the immutable load sequence.\n///\n/// It is a custom Vyper-specific instruction, which is capable of copying an array of immutables\n/// from the immutable storage system contract to the heap.\n///\npub fn load_bytes<'ctx, D>(\n    context: &mut compiler_llvm_context::Context<'ctx, D>,\n    heap_offset: inkwell::values::IntValue<'ctx>,\n    immutable_offset: inkwell::values::IntValue<'ctx>,\n    length: inkwell::values::IntValue<'ctx>,\n) -> anyhow::Result<()>\nwhere\n    D: compiler_llvm_context::Dependency + Clone,\n{\n    let condition_block = context.append_basic_block(\"immutable_load_bytes_repeat_condition\");\n    let body_block = context.append_basic_block(\"immutable_load_bytes_repeat_body\");\n    let increment_block = context.append_basic_block(\"immutable_load_bytes_repeat_increment\");\n    let join_block = context.append_basic_block(\"immutable_load_bytes_repeat_join\");\n\n    let heap_offset_pointer = context.build_alloca(\n        context.field_type(),\n        \"immutable_load_bytes_heap_offset_pointer\",\n    );\n    context.build_store(heap_offset_pointer, heap_offset);\n    let immutable_offset_pointer = context.build_alloca(\n        context.field_type(),\n        \"immutable_load_bytes_immutable_pointer\",\n    );\n    context.build_store(immutable_offset_pointer, immutable_offset);\n    let index_offset_pointer = context.build_alloca(\n        context.field_type(),\n        \"immutable_load_bytes_index_offset_pointer\",\n    );\n    context.build_store(index_offset_pointer, context.field_const(0));\n    context.build_unconditional_branch(condition_block);\n\n    context.set_basic_block(condition_block);\n    let index_offset_value = context.build_load(\n        index_offset_pointer,\n        \"immutable_load_bytes_condition_index_offset_pointer\",\n    );\n    let condition = context.builder().build_int_compare(\n        inkwell::IntPredicate::ULT,\n        index_offset_value.into_int_value(),\n        length,\n        \"immutable_load_bytes_condition_compared\",\n    );\n    context.build_conditional_branch(condition, body_block, join_block);\n\n    context.set_basic_block(body_block);\n    let immutable_offset_value = context.build_load(\n        immutable_offset_pointer,\n        \"immutable_load_bytes_immutable_offset_value\",\n    );\n    let immutable_value =\n        compiler_llvm_context::immutable::load(context, immutable_offset_value.into_int_value())?;\n\n    let heap_offset_value = context.build_load(\n        heap_offset_pointer,\n        \"immutable_load_bytes_heap_offset_value\",\n    );\n    let heap_pointer = compiler_llvm_context::Pointer::new_with_offset(\n        context,\n        compiler_llvm_context::AddressSpace::Heap,\n        context.field_type(),\n        heap_offset_value.into_int_value(),\n        \"immutable_load_bytes_heap_pointer\",\n    );\n    context.build_store(heap_pointer, immutable_value);\n    context.build_unconditional_branch(increment_block);\n\n    context.set_basic_block(increment_block);\n    let heap_offset_value = context.build_load(\n        heap_offset_pointer,\n        \"immutable_load_bytes_increment_heap_offset_value\",\n    );\n    let heap_offset_value_incremented = context.builder().build_int_add(\n        heap_offset_value.into_int_value(),\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"immutable_load_bytes_heap_offset_value_incremented\",\n    );\n    context.build_store(heap_offset_pointer, heap_offset_value_incremented);\n\n    let immutable_offset_value = context.build_load(\n        immutable_offset_pointer,\n        \"immutable_load_bytes_increment_immutable_offset_value\",\n    );\n    let immutable_offset_value_incremented = context.builder().build_int_add(\n        immutable_offset_value.into_int_value(),\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"immutable_load_bytes_immutable_offset_value_incremented\",\n    );\n    context.build_store(immutable_offset_pointer, immutable_offset_value_incremented);\n\n    let index_offset_value = context.build_load(\n        index_offset_pointer,\n        \"immutable_load_bytes_increment_index_offset_value\",\n    );\n    let index_offset_value_incremented = context.builder().build_int_add(\n        index_offset_value.into_int_value(),\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"immutable_load_bytes_increment_index_offset_value_incremented\",\n    );\n    context.build_store(index_offset_pointer, index_offset_value_incremented);\n    context.build_unconditional_branch(condition_block);\n\n    context.set_basic_block(join_block);\n\n    Ok(())\n}\n", "//!\n//! The `label` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse inkwell::values::BasicValue;\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::instruction::Instruction;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `label` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Label(Vec<Expression>);\n\nimpl Label {\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        self.0\n            .last_mut()\n            .expect(\"Always exists\")\n            .extract_functions()\n    }\n\n    ///\n    /// Whether the label is a function entry block.\n    ///\n    pub fn is_function_entry(&self) -> anyhow::Result<bool> {\n        let label_name = self.name()?;\n        Ok(\n            label_name.starts_with(crate::r#const::FUNCTION_PREFIX_EXTERNAL)\n                || label_name.starts_with(crate::r#const::FUNCTION_PREFIX_INTERNAL),\n        )\n    }\n\n    ///\n    /// Checks whether the label is empty. If it is, nothing is generated.\n    ///\n    pub fn is_empty(&self) -> bool {\n        self.0.len() <= 1\n    }\n\n    ///\n    /// Checks whether the label body is empty. If it is, nothing is generated.\n    ///\n    /// The cleanup block cannot be ignored in deploy code, because `vyper` generates jumps to them.\n    ///\n    pub fn can_block_be_ignored(&self) -> bool {\n        let label_name = match self.0.get(0).expect(\"Always exists\").try_into_identifier() {\n            Ok(identifier) => identifier,\n            Err(_) => return true,\n        };\n\n        if label_name.starts_with(\"external___init\")\n            && label_name.ends_with(crate::r#const::LABEL_SUFFIX_CLEANUP)\n        {\n            return false;\n        }\n\n        matches!(\n            self.0.get(2),\n            Some(Expression::Instruction(Instruction::Pass))\n        )\n    }\n\n    ///\n    /// Checks whether the label body is an empty sequence. If it is, a return is appended.\n    ///\n    /// Only used by the cleanup block in deploy code.\n    ///\n    pub fn is_block_empty_sequence(&self) -> bool {\n        match self.0.get(2) {\n            Some(Expression::Instruction(Instruction::Pass)) => true,\n            Some(Expression::Instruction(Instruction::Seq(sequence))) => {\n                sequence.is_pass_or_empty()\n            }\n            Some(Expression::Identifier(identifier)) => {\n                identifier.as_str() == crate::r#const::DEFAULT_PASS_IDENTIFIER\n            }\n            Some(_) => false,\n            None => true,\n        }\n    }\n\n    ///\n    /// Returns the label name.\n    ///\n    pub fn name(&self) -> anyhow::Result<String> {\n        self.0.get(0).expect(\"Always exists\").try_into_identifier()\n    }\n\n    ///\n    /// Declares the label block, so all the blocks are predeclared before translating the bodies.\n    ///\n    pub fn declare<D>(&self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        if self.is_empty() || self.can_block_be_ignored() {\n            return Ok(());\n        }\n\n        let label_name = self\n            .0\n            .get(0)\n            .expect(\"Always exists\")\n            .try_into_identifier()?;\n        context.append_basic_block(label_name.as_str());\n\n        context.set_basic_block(context.current_function().borrow().entry_block());\n        let mut label_arguments = Vec::new();\n        match self.0.get(1) {\n            Some(Expression::Instruction(Instruction::Var_List(ref arguments))) => {\n                for argument in arguments.iter() {\n                    let name = argument.try_into_identifier()?;\n                    if name.as_str() == crate::r#const::VARIABLE_IDENTIFIER_RETURN_PC {\n                        continue;\n                    }\n                    label_arguments.push(name.clone());\n\n                    let pointer = context.build_alloca(context.field_type(), name.as_str());\n                    let value =\n                        if name.as_str() == crate::r#const::VARIABLE_IDENTIFIER_RETURN_BUFFER {\n                            context.current_function().borrow().get_nth_param(0)\n                        } else {\n                            context.field_const(0).as_basic_value_enum()\n                        };\n                    context.build_store(pointer, value);\n                    context\n                        .current_function()\n                        .borrow_mut()\n                        .insert_stack_pointer(name, pointer);\n                }\n            }\n            Some(Expression::Identifier(identifier)) if identifier.as_str() == \"var_list\" => {}\n            expression => anyhow::bail!(\"Expected a variable list, found `{:?}`\", expression),\n        };\n\n        context\n            .current_function()\n            .borrow_mut()\n            .vyper_mut()\n            .insert_label_arguments(label_name, label_arguments);\n\n        Ok(())\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        mut self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        if self.is_empty() || self.can_block_be_ignored() {\n            return Ok(());\n        }\n        let is_block_empty_sequence = self.is_block_empty_sequence();\n\n        let label_name = self.0.remove(0);\n        let block = self.0.remove(1);\n\n        let current_block = context.basic_block();\n\n        let label_name = label_name.try_into_identifier()?;\n        let label_block = context\n            .current_function()\n            .borrow()\n            .declaration()\n            .value\n            .get_basic_blocks()\n            .iter()\n            .find(|block| block.get_name().to_string_lossy() == label_name)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Block `{}` does not exist\", label_name))?;\n\n        context.set_basic_block(label_block);\n        block.into_llvm_value(context)?;\n\n        if label_name == crate::r#const::FUNCTION_IDENTIFIER_FALLBACK {\n            context.build_unconditional_branch(context.current_function().borrow().return_block());\n        }\n\n        if label_name.starts_with(\"external___init\")\n            && label_name.ends_with(crate::r#const::LABEL_SUFFIX_CLEANUP)\n            && is_block_empty_sequence\n        {\n            compiler_llvm_context::r#return::stop(context)?;\n        }\n\n        context.set_basic_block(current_block);\n\n        Ok(())\n    }\n}\n", "//!\n//! The LLL IR instruction.\n//!\n\npub mod assert;\npub mod clamp;\npub mod create;\npub mod deploy;\npub mod exit_to;\npub mod goto;\npub mod r#if;\npub mod immutable;\npub mod label;\npub mod offset;\npub mod repeat;\npub mod r#return;\npub mod revert;\npub mod seq;\npub mod set;\npub mod with;\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse inkwell::values::BasicValue;\n\nuse crate::project::contract::vyper::expression::Expression;\n\nuse self::assert::Assert;\nuse self::deploy::Deploy;\nuse self::exit_to::ExitTo;\nuse self::goto::Goto;\nuse self::label::Label;\nuse self::r#if::If;\nuse self::r#return::Return;\nuse self::repeat::Repeat;\nuse self::revert::Revert;\nuse self::seq::Seq;\nuse self::set::Set;\nuse self::with::With;\n\n///\n/// The LLL IR instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"lowercase\")]\n#[allow(non_camel_case_types)]\n#[allow(clippy::upper_case_acronyms)]\npub enum Instruction {\n    /// The LLL IR `with` expression.\n    With(With),\n    /// The LLL IR `set` expression.\n    Set(Set),\n    /// The LLL IR `seq` expression.\n    Seq(Seq),\n    /// The LLL IR `if` statement.\n    If(If),\n    /// The LLL IR `repeat` statement.\n    Repeat(Repeat),\n\n    /// The LLL IR `goto` instruction.\n    GoTo(Goto),\n    /// The LLL IR `exit_to` instruction.\n    Exit_To(ExitTo),\n    /// The LLL IR `jump` instruction.\n    Jump([Box<Expression>; 1]),\n    /// The LLL IR `label` instruction.\n    Label(Label),\n    /// The LLL IR `cleanup_repeat` instruction.\n    Cleanup_Repeat,\n    /// The LLL IR `break` instruction.\n    Break,\n    /// The LLL IR `continue` instruction.\n    Continue,\n    /// The LLL IR `pass` instruction.\n    Pass,\n    /// The LLL IR `deploy` instruction.\n    Deploy(Deploy),\n    /// The LLL IR `unique_symbol` instruction.\n    Unique_Symbol([Box<Expression>; 1]),\n\n    /// The LLL IR pseudo opcode.\n    UCLAMP([Box<Expression>; 3]),\n    /// The LLL IR pseudo opcode.\n    CLAMP([Box<Expression>; 3]),\n    /// The LLL IR pseudo opcode.\n    UCLAMPLT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    UCLAMPLE([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    UCLAMPGT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    UCLAMPGE([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMPLT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMPLE([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMPGT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMPGE([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMP_NONZERO([Box<Expression>; 1]),\n\n    /// The LLL IR pseudo opcode.\n    CEIL32([Box<Expression>; 1]),\n    /// The LLL IR pseudo opcode.\n    SELECT([Box<Expression>; 3]),\n\n    /// The LLL IR pseudo opcode.\n    Assert(Assert),\n    /// The LLL IR pseudo opcode.\n    Assert_Unreachable(Assert),\n\n    /// The LLL IR `var_list` instruction.\n    Var_List(Vec<Expression>),\n\n    /// The LLL IR EVM opcode.\n    POP([Box<Expression>; 1]),\n\n    /// The LLL IR EVM opcode.\n    ADD([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SUB([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    MUL([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    DIV([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    MOD([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SDIV([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SMOD([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    LT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    LE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    GT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    GE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    EQ([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    NE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    ISZERO([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    SLT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    SLE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SGT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    SGE([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    OR([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    XOR([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    NOT([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    AND([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SHL([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SHR([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SAR([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    BYTE([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    ADDMOD([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    MULMOD([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    EXP([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SIGNEXTEND([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    SHA3([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    KECCAK256([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    SHA3_32([Box<Expression>; 1]),\n    /// The LLL IR pseudo opcode.\n    SHA3_64([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    MLOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    MSTORE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    MSTORE8([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    SLOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    SSTORE([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    ILOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    ISTORE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    DLOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    DLOADBYTES([Box<Expression>; 3]),\n\n    /// The LLL IR EVM opcode.\n    CALLDATALOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    CALLDATASIZE,\n    /// The LLL IR EVM opcode.\n    CALLDATACOPY([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    CODESIZE,\n    /// The LLL IR EVM opcode.\n    CODECOPY([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    EXTCODESIZE([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    EXTCODEHASH([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    RETURNDATASIZE,\n    /// The LLL IR EVM opcode.\n    RETURNDATACOPY([Box<Expression>; 3]),\n\n    /// The LLL IR EVM opcode.\n    RETURN(Return),\n    /// The LLL IR EVM opcode.\n    REVERT(Revert),\n    /// The LLL IR EVM opcode.\n    STOP,\n    /// The LLL IR EVM opcode.\n    INVALID,\n\n    /// The LLL IR EVM opcode.\n    LOG0([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    LOG1([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    LOG2([Box<Expression>; 4]),\n    /// The LLL IR EVM opcode.\n    LOG3([Box<Expression>; 5]),\n    /// The LLL IR EVM opcode.\n    LOG4([Box<Expression>; 6]),\n\n    /// The LLL IR EVM opcode.\n    CALL([Box<Expression>; 7]),\n    /// The LLL IR EVM opcode.\n    STATICCALL([Box<Expression>; 6]),\n    /// The LLL IR EVM opcode.\n    DELEGATECALL([Box<Expression>; 6]),\n\n    /// The LLL IR EVM opcode.\n    CREATE([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    CREATE2([Box<Expression>; 4]),\n\n    /// The LLL IR EVM opcode.\n    ADDRESS,\n    /// The LLL IR EVM opcode.\n    CALLER,\n\n    /// The LLL IR EVM opcode.\n    CALLVALUE,\n    /// The LLL IR EVM opcode.\n    GAS,\n    /// The LLL IR EVM opcode.\n    BALANCE([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    SELFBALANCE,\n\n    /// The LLL IR EVM opcode.\n    GASLIMIT,\n    /// The LLL IR EVM opcode.\n    GASPRICE,\n    /// The LLL IR EVM opcode.\n    ORIGIN,\n    /// The LLL IR EVM opcode.\n    CHAINID,\n    /// The LLL IR EVM opcode.\n    NUMBER,\n    /// The LLL IR EVM opcode.\n    TIMESTAMP,\n    /// The LLL IR EVM opcode.\n    BLOCKHASH([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    DIFFICULTY,\n    /// The LLL IR EVM opcode.\n    COINBASE,\n    /// The LLL IR EVM opcode.\n    BASEFEE,\n    /// The LLL IR EVM opcode.\n    MSIZE,\n\n    /// The LLL IR EVM opcode.\n    CALLCODE([Box<Expression>; 7]),\n    /// The LLL IR EVM opcode.\n    PC,\n    /// The LLL IR EVM opcode.\n    EXTCODECOPY([Box<Expression>; 4]),\n    /// The LLL IR EVM opcode.\n    SELFDESTRUCT([Box<Expression>; 1]),\n\n    /// The LLL unknown trap.\n    Unknown(serde_json::Value),\n}\n\nimpl Instruction {\n    ///\n    /// Translates the specified number of arguments.\n    ///\n    fn translate_arguments_llvm<'ctx, D, const N: usize>(\n        arguments: [Box<Expression>; N],\n        context: &mut compiler_llvm_context::Context<'ctx, D>,\n    ) -> anyhow::Result<[inkwell::values::BasicValueEnum<'ctx>; N]>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let debug_string = format!(\"`{arguments:?}`\");\n\n        let mut values = Vec::with_capacity(N);\n        for (index, expression) in arguments.into_iter().enumerate().rev() {\n            values.push(expression.into_llvm_value(context)?.ok_or_else(|| {\n                anyhow::anyhow!(\n                    \"Expression #{} of the instruction `{}` has zero valency\",\n                    index,\n                    debug_string\n                )\n            })?);\n        }\n        values.reverse();\n\n        if values.len() != N {\n            anyhow::bail!(\n                \"Expected {} arguments, found only {}: `{:?}`\",\n                N,\n                values.len(),\n                values\n            );\n        }\n\n        Ok(values.try_into().expect(\"Always valid\"))\n    }\n\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        match self {\n            Self::Seq(inner) => inner.extract_functions(),\n            Self::With(inner) => inner.extract_functions(),\n            Self::If(inner) => inner.extract_functions(),\n            Self::Repeat(inner) => inner.extract_functions(),\n            Self::Label(inner) => inner.extract_functions(),\n            _ => Ok(BTreeMap::new()),\n        }\n    }\n\n    ///\n    /// Whether the instruction is a function entry block.\n    ///\n    pub fn is_function(&self) -> anyhow::Result<bool> {\n        match self {\n            Self::Seq(sequence) => sequence.is_function(),\n            _ => Ok(false),\n        }\n    }\n\n    ///\n    /// Returns the function name.\n    ///\n    pub fn function_name(&self) -> anyhow::Result<String> {\n        match self {\n            Self::Seq(inner) => inner.function_name(),\n            expression => anyhow::bail!(\"Expected a function sequence, found `{:?}`\", expression),\n        }\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::Context<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        match self {\n            Self::With(inner) => inner.into_llvm_value(context),\n            Self::Set(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::Seq(inner) => inner.into_llvm_value(context),\n            Self::If(inner) => inner.into_llvm_value(context),\n            Self::Repeat(inner) => inner.into_llvm_value(context).map(|_| None),\n\n            Self::GoTo(inner) => inner.into_llvm_value(context),\n            Self::Exit_To(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::Jump(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                let block = context.current_function().borrow().return_block();\n                context.build_unconditional_branch(block);\n                Ok(None)\n            }\n            Self::Label(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::Cleanup_Repeat => Ok(None),\n            Self::Break => {\n                let block = context.r#loop().join_block;\n                context.build_unconditional_branch(block);\n                Ok(None)\n            }\n            Self::Continue => {\n                let block = context.r#loop().continue_block;\n                context.build_unconditional_branch(block);\n                Ok(None)\n            }\n            Self::Pass => Ok(None),\n            Self::Deploy(_inner) => Ok(None),\n            Self::Unique_Symbol(_inner) => Ok(None),\n\n            Self::UCLAMP(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                clamp::ordinary(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                    false,\n                )\n                .map(Some)\n            }\n            Self::CLAMP(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                clamp::ordinary(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                    true,\n                )\n                .map(Some)\n            }\n            Self::UCLAMPLT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::ULT,\n                )\n                .map(Some)\n            }\n            Self::UCLAMPLE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::ULE,\n                )\n                .map(Some)\n            }\n            Self::UCLAMPGT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::UGT,\n                )\n                .map(Some)\n            }\n            Self::UCLAMPGE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::UGE,\n                )\n                .map(Some)\n            }\n            Self::CLAMPLT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SLT,\n                )\n                .map(Some)\n            }\n            Self::CLAMPLE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SLE,\n                )\n                .map(Some)\n            }\n            Self::CLAMPGT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SGT,\n                )\n                .map(Some)\n            }\n            Self::CLAMPGE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SGE,\n                )\n                .map(Some)\n            }\n            Self::CLAMP_NONZERO(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    context.field_const(0),\n                    inkwell::IntPredicate::NE,\n                )\n                .map(Some)\n            }\n\n            Self::CEIL32(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                offset::ceil_32(context, arguments[0].into_int_value()).map(Some)\n            }\n            Self::SELECT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                let condition = context.builder().build_int_compare(\n                    inkwell::IntPredicate::NE,\n                    arguments[0].into_int_value(),\n                    context.field_const(0),\n                    \"select_condition\",\n                );\n                Ok(Some(context.builder().build_select(\n                    condition,\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                    \"select\",\n                )))\n            }\n\n            Self::Assert(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::Assert_Unreachable(inner) => inner.into_llvm_value(context).map(|_| None),\n\n            Self::Var_List(_inner) => Ok(None),\n\n            Self::POP(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                Ok(None)\n            }\n\n            Self::ADD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::arithmetic::addition(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SUB(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::arithmetic::subtraction(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::MUL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::arithmetic::multiplication(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::DIV(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::arithmetic::division(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::MOD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::arithmetic::remainder(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SDIV(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::arithmetic::division_signed(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SMOD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::arithmetic::remainder_signed(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n\n            Self::LT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::ULT,\n                )\n                .map(Some)\n            }\n            Self::LE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::ULE,\n                )\n                .map(Some)\n            }\n            Self::GT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::UGT,\n                )\n                .map(Some)\n            }\n            Self::GE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::UGE,\n                )\n                .map(Some)\n            }\n            Self::EQ(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::EQ,\n                )\n                .map(Some)\n            }\n            Self::NE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::NE,\n                )\n                .map(Some)\n            }\n            Self::ISZERO(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    context.field_const(0),\n                    inkwell::IntPredicate::EQ,\n                )\n                .map(Some)\n            }\n            Self::SLT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SLT,\n                )\n                .map(Some)\n            }\n            Self::SLE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SLE,\n                )\n                .map(Some)\n            }\n            Self::SGT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SGT,\n                )\n                .map(Some)\n            }\n            Self::SGE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SGE,\n                )\n                .map(Some)\n            }\n\n            Self::OR(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::bitwise::or(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::XOR(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::bitwise::xor(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::NOT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::bitwise::xor(\n                    context,\n                    arguments[0].into_int_value(),\n                    context.field_type().const_all_ones(),\n                )\n                .map(Some)\n            }\n            Self::AND(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::bitwise::and(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SHL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::bitwise::shift_left(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SHR(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::bitwise::shift_right(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SAR(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::bitwise::shift_right_arithmetic(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::BYTE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::bitwise::byte(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n\n            Self::ADDMOD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::math::add_mod(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::MULMOD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::math::mul_mod(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::EXP(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::math::exponent(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SIGNEXTEND(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::math::sign_extend(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n\n            Self::SHA3(arguments) | Self::KECCAK256(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                let input_offset = arguments[0].into_int_value();\n                let input_length = arguments[1].into_int_value();\n\n                let function = compiler_llvm_context::Runtime::keccak256(context);\n                Ok(context.build_call(\n                    function,\n                    &[\n                        input_offset.as_basic_value_enum(),\n                        input_length.as_basic_value_enum(),\n                    ],\n                    \"sha3_call\",\n                ))\n            }\n            Self::SHA3_32(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n\n                let pointer_one = compiler_llvm_context::Pointer::new_with_offset(\n                    context,\n                    compiler_llvm_context::AddressSpace::Heap,\n                    context.field_type(),\n                    context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64),\n                    \"sha3_pointer_one\",\n                );\n                context.build_store(pointer_one, arguments[0]);\n\n                let function = compiler_llvm_context::Runtime::keccak256(context);\n                Ok(context.build_call(\n                    function,\n                    &[\n                        context\n                            .field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64)\n                            .as_basic_value_enum(),\n                        context\n                            .field_const(compiler_common::BYTE_LENGTH_FIELD as u64)\n                            .as_basic_value_enum(),\n                    ],\n                    \"sha3_32_call\",\n                ))\n            }\n            Self::SHA3_64(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n\n                let pointer_one = compiler_llvm_context::Pointer::new_with_offset(\n                    context,\n                    compiler_llvm_context::AddressSpace::Heap,\n                    context.field_type(),\n                    context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64),\n                    \"sha3_pointer_one\",\n                );\n                context.build_store(pointer_one, arguments[0]);\n                let pointer_two = compiler_llvm_context::Pointer::new_with_offset(\n                    context,\n                    compiler_llvm_context::AddressSpace::Heap,\n                    context.field_type(),\n                    context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE2 as u64),\n                    \"sha3_pointer_two\",\n                );\n                context.build_store(pointer_two, arguments[1]);\n\n                let function = compiler_llvm_context::Runtime::keccak256(context);\n                Ok(context.build_call(\n                    function,\n                    &[\n                        context\n                            .field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64)\n                            .as_basic_value_enum(),\n                        context\n                            .field_const((compiler_common::BYTE_LENGTH_FIELD * 2) as u64)\n                            .as_basic_value_enum(),\n                    ],\n                    \"sha3_64_call\",\n                ))\n            }\n\n            Self::MLOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::memory::load(context, arguments[0].into_int_value())\n                    .map(Some)\n            }\n            Self::MSTORE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::memory::store(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(|_| None)\n            }\n            Self::MSTORE8(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::memory::store_byte(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(|_| None)\n            }\n\n            Self::SLOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::storage::load(context, arguments[0].into_int_value())\n                    .map(Some)\n            }\n            Self::SSTORE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::storage::store(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(|_| None)\n            }\n\n            Self::ILOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::immutable::load(context, arguments[0].into_int_value())\n                    .map(Some)\n            }\n            Self::ISTORE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::immutable::store(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(|_| None)\n            }\n\n            Self::CALLDATALOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n\n                match context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    compiler_llvm_context::CodeType::Deploy => {\n                        Ok(Some(context.field_const(0).as_basic_value_enum()))\n                    }\n                    compiler_llvm_context::CodeType::Runtime => {\n                        compiler_llvm_context::calldata::load(\n                            context,\n                            arguments[0].into_int_value(),\n                        )\n                        .map(Some)\n                    }\n                }\n            }\n            Self::CALLDATASIZE => {\n                match context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    compiler_llvm_context::CodeType::Deploy => {\n                        Ok(Some(context.field_const(0).as_basic_value_enum()))\n                    }\n                    compiler_llvm_context::CodeType::Runtime => {\n                        compiler_llvm_context::calldata::size(context).map(Some)\n                    }\n                }\n            }\n            Self::CALLDATACOPY(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n\n                let source_offset = match context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    compiler_llvm_context::CodeType::Deploy => {\n                        compiler_llvm_context::calldata::size(context)?\n                    }\n                    compiler_llvm_context::CodeType::Runtime => {\n                        arguments[1].into_int_value().as_basic_value_enum()\n                    }\n                }\n                .into_int_value();\n\n                compiler_llvm_context::calldata::copy(\n                    context,\n                    arguments[0].into_int_value(),\n                    source_offset,\n                    arguments[2].into_int_value(),\n                )\n                .map(|_| None)\n            }\n            Self::DLOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n\n                match context.code_type() {\n                    None => {\n                        anyhow::bail!(\n                            \"Immutables are not available if the contract part is undefined\"\n                        );\n                    }\n                    Some(compiler_llvm_context::CodeType::Deploy) => {\n                        compiler_llvm_context::calldata::load(\n                            context,\n                            arguments[0].into_int_value(),\n                        )\n                    }\n                    Some(compiler_llvm_context::CodeType::Runtime) => {\n                        compiler_llvm_context::immutable::load(\n                            context,\n                            arguments[0].into_int_value(),\n                        )\n                    }\n                }\n                .map(Some)\n            }\n            Self::DLOADBYTES(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n\n                match context.code_type() {\n                    None => {\n                        anyhow::bail!(\n                            \"Immutables are not available if the contract part is undefined\"\n                        );\n                    }\n                    Some(compiler_llvm_context::CodeType::Deploy) => {\n                        compiler_llvm_context::calldata::copy(\n                            context,\n                            arguments[0].into_int_value(),\n                            arguments[1].into_int_value(),\n                            arguments[2].into_int_value(),\n                        )\n                    }\n                    Some(compiler_llvm_context::CodeType::Runtime) => immutable::load_bytes(\n                        context,\n                        arguments[0].into_int_value(),\n                        arguments[1].into_int_value(),\n                        arguments[2].into_int_value(),\n                    ),\n                }\n                .map(|_| None)\n            }\n            Self::CODESIZE => {\n                match context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    compiler_llvm_context::CodeType::Deploy => {\n                        compiler_llvm_context::calldata::size(context).map(Some)\n                    }\n                    compiler_llvm_context::CodeType::Runtime => {\n                        let code_source =\n                            compiler_llvm_context::zkevm_general::code_source(context)?;\n                        compiler_llvm_context::ext_code::size(context, code_source.into_int_value())\n                            .map(Some)\n                    }\n                }\n            }\n            Self::CODECOPY(arguments) => {\n                if let compiler_llvm_context::CodeType::Runtime = context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    anyhow::bail!(\n                        \"The `CODECOPY` instruction is not supported in the runtime code\",\n                    );\n                }\n\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::calldata::copy(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                )\n                .map(|_| None)\n            }\n            Self::RETURNDATASIZE => compiler_llvm_context::return_data::size(context).map(Some),\n            Self::RETURNDATACOPY(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::return_data::copy(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                )\n                .map(|_| None)\n            }\n            Self::EXTCODESIZE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::ext_code::size(context, arguments[0].into_int_value())\n                    .map(Some)\n            }\n            Self::EXTCODEHASH(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::ext_code::hash(context, arguments[0].into_int_value())\n                    .map(Some)\n            }\n\n            Self::RETURN(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::REVERT(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::STOP => compiler_llvm_context::r#return::stop(context).map(|_| None),\n            Self::INVALID => compiler_llvm_context::r#return::invalid(context).map(|_| None),\n\n            Self::LOG0(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    vec![],\n                )\n                .map(|_| None)\n            }\n            Self::LOG1(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2..]\n                        .iter()\n                        .map(|argument| argument.into_int_value())\n                        .collect(),\n                )\n                .map(|_| None)\n            }\n            Self::LOG2(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 4>(arguments, context)?;\n                compiler_llvm_context::event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2..]\n                        .iter()\n                        .map(|argument| argument.into_int_value())\n                        .collect(),\n                )\n                .map(|_| None)\n            }\n            Self::LOG3(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 5>(arguments, context)?;\n                compiler_llvm_context::event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2..]\n                        .iter()\n                        .map(|argument| argument.into_int_value())\n                        .collect(),\n                )\n                .map(|_| None)\n            }\n            Self::LOG4(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 6>(arguments, context)?;\n                compiler_llvm_context::event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2..]\n                        .iter()\n                        .map(|argument| argument.into_int_value())\n                        .collect(),\n                )\n                .map(|_| None)\n            }\n\n            Self::CALL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 7>(arguments, context)?;\n\n                let gas = arguments[0].into_int_value();\n                let address = arguments[1].into_int_value();\n                let value = arguments[2].into_int_value();\n                let input_offset = arguments[3].into_int_value();\n                let input_size = arguments[4].into_int_value();\n                let output_offset = arguments[5].into_int_value();\n                let output_size = arguments[6].into_int_value();\n\n                compiler_llvm_context::call::default(\n                    context,\n                    context.llvm_runtime().far_call,\n                    gas,\n                    address,\n                    Some(value),\n                    input_offset,\n                    input_size,\n                    output_offset,\n                    output_size,\n                    None,\n                )\n                .map(Some)\n            }\n            Self::STATICCALL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 6>(arguments, context)?;\n\n                let gas = arguments[0].into_int_value();\n                let address = arguments[1].into_int_value();\n                let input_offset = arguments[2].into_int_value();\n                let input_size = arguments[3].into_int_value();\n                let output_offset = arguments[4].into_int_value();\n                let output_size = arguments[5].into_int_value();\n\n                compiler_llvm_context::call::default(\n                    context,\n                    context.llvm_runtime().static_call,\n                    gas,\n                    address,\n                    None,\n                    input_offset,\n                    input_size,\n                    output_offset,\n                    output_size,\n                    None,\n                )\n                .map(Some)\n            }\n            Self::DELEGATECALL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 6>(arguments, context)?;\n\n                let gas = arguments[0].into_int_value();\n                let address = arguments[1].into_int_value();\n                let input_offset = arguments[2].into_int_value();\n                let input_size = arguments[3].into_int_value();\n                let output_offset = arguments[4].into_int_value();\n                let output_size = arguments[5].into_int_value();\n\n                compiler_llvm_context::call::default(\n                    context,\n                    context.llvm_runtime().delegate_call,\n                    gas,\n                    address,\n                    None,\n                    input_offset,\n                    input_size,\n                    output_offset,\n                    output_size,\n                    None,\n                )\n                .map(Some)\n            }\n\n            Self::CREATE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n\n                create::create(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    None,\n                )\n                .map(Some)\n            }\n            Self::CREATE2(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 4>(arguments, context)?;\n\n                create::create(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    Some(arguments[3].into_int_value()),\n                )\n                .map(Some)\n            }\n\n            Self::ADDRESS => Ok(context.build_call(context.intrinsics().address, &[], \"address\")),\n            Self::CALLER => Ok(context.build_call(context.intrinsics().caller, &[], \"caller\")),\n\n            Self::CALLVALUE => compiler_llvm_context::ether_gas::value(context).map(Some),\n            Self::GAS => compiler_llvm_context::ether_gas::gas(context).map(Some),\n            Self::BALANCE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n\n                let address = arguments[0].into_int_value();\n                compiler_llvm_context::ether_gas::balance(context, address).map(Some)\n            }\n            Self::SELFBALANCE => {\n                let address = context\n                    .build_call(context.intrinsics().address, &[], \"self_balance_address\")\n                    .expect(\"Always exists\")\n                    .into_int_value();\n\n                compiler_llvm_context::ether_gas::balance(context, address).map(Some)\n            }\n\n            Self::GASLIMIT => compiler_llvm_context::contract_context::gas_limit(context).map(Some),\n            Self::GASPRICE => compiler_llvm_context::contract_context::gas_price(context).map(Some),\n            Self::ORIGIN => compiler_llvm_context::contract_context::origin(context).map(Some),\n            Self::CHAINID => compiler_llvm_context::contract_context::chain_id(context).map(Some),\n            Self::NUMBER => {\n                compiler_llvm_context::contract_context::block_number(context).map(Some)\n            }\n            Self::TIMESTAMP => {\n                compiler_llvm_context::contract_context::block_timestamp(context).map(Some)\n            }\n            Self::BLOCKHASH(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                let index = arguments[0].into_int_value();\n\n                compiler_llvm_context::contract_context::block_hash(context, index).map(Some)\n            }\n            Self::DIFFICULTY => {\n                compiler_llvm_context::contract_context::difficulty(context).map(Some)\n            }\n            Self::COINBASE => compiler_llvm_context::contract_context::coinbase(context).map(Some),\n            Self::BASEFEE => compiler_llvm_context::contract_context::basefee(context).map(Some),\n            Self::MSIZE => compiler_llvm_context::contract_context::msize(context).map(Some),\n\n            Self::CALLCODE(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 7>(arguments, context)?;\n                anyhow::bail!(\"The `CALLCODE` instruction is not supported\")\n            }\n            Self::PC => anyhow::bail!(\"The `PC` instruction is not supported\"),\n            Self::EXTCODECOPY(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 4>(arguments, context)?;\n                anyhow::bail!(\"The `EXTCODECOPY` instruction is not supported\")\n            }\n            Self::SELFDESTRUCT(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                anyhow::bail!(\"The `SELFDESTRUCT` instruction is not supported\")\n            }\n\n            Self::Unknown(value) => {\n                anyhow::bail!(\"Unknown LLL instruction: {}\", value);\n            }\n        }\n    }\n}\n", "//!\n//! The offset instructions.\n//!\n\nuse inkwell::values::BasicValue;\n\n///\n/// Translates the Vyper LLL-specific `ceil32` instruction.\n///\npub fn ceil_32<'ctx, D>(\n    context: &mut compiler_llvm_context::Context<'ctx, D>,\n    value: inkwell::values::IntValue<'ctx>,\n) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>\nwhere\n    D: compiler_llvm_context::Dependency + Clone,\n{\n    let remainder = context.builder().build_int_unsigned_rem(\n        value,\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"ceil32_remainder\",\n    );\n    let shift = context.builder().build_int_sub(\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        remainder,\n        \"ceil32_shift\",\n    );\n    let shift_remainder = context.builder().build_int_unsigned_rem(\n        shift,\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"ceil32_shift_remainder\",\n    );\n    let result = context\n        .builder()\n        .build_int_add(value, shift_remainder, \"ceil32_ceiled\");\n    Ok(result.as_basic_value_enum())\n}\n", "//!\n//! The `repeat` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `repeat` instruction.\n///\n/// The instruction describes a well-known for-loop.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Repeat(Vec<Expression>);\n\nimpl Repeat {\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        self.0\n            .last_mut()\n            .expect(\"Always exists\")\n            .extract_functions()\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        mut self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let index_identifier = self.0.remove(0).try_into_identifier()?;\n        let start = self.0.remove(0);\n        let rounds = self.0.remove(0);\n        let _rounds_bound = self.0.remove(0);\n        let body = self.0.remove(0);\n\n        let condition_block = context.append_basic_block(\"repeat_condition\");\n        let body_block = context.append_basic_block(\"repeat_body\");\n        let increment_block = context.append_basic_block(\"repeat_increment\");\n        let join_block = context.append_basic_block(\"repeat_join\");\n\n        let start = start.into_llvm_value(context)?.expect(\"Always exists\");\n        let rounds = rounds.into_llvm_value(context)?.expect(\"Always exists\");\n        let rounds_pointer = context.build_alloca(context.field_type(), \"repeat_rounds\");\n        context.build_store(rounds_pointer, context.field_const(0));\n\n        let index_pointer = context.build_alloca(context.field_type(), \"repeat_index_pointer\");\n        context.build_store(index_pointer, start);\n        context\n            .current_function()\n            .borrow_mut()\n            .insert_stack_pointer(index_identifier.clone(), index_pointer);\n        context.build_unconditional_branch(condition_block);\n\n        context.set_basic_block(condition_block);\n        let rounds_value = context.build_load(rounds_pointer, \"repeat_condition_rounds_value\");\n        let condition = context.builder().build_int_compare(\n            inkwell::IntPredicate::ULT,\n            rounds_value.into_int_value(),\n            rounds.into_int_value(),\n            \"repeat_condition_compared\",\n        );\n        context.build_conditional_branch(condition, body_block, join_block);\n\n        context.push_loop(body_block, increment_block, join_block);\n\n        context.set_basic_block(body_block);\n        body.into_llvm_value(context)?;\n        context.build_unconditional_branch(increment_block);\n\n        context.set_basic_block(increment_block);\n        let index_value = context.build_load(index_pointer, \"repeat_increment_index_value\");\n        let index_value_incremented = context.builder().build_int_add(\n            index_value.into_int_value(),\n            context.field_const(1),\n            \"repeat_increment_index_value_incremented\",\n        );\n        context.build_store(index_pointer, index_value_incremented);\n\n        let rounds_value = context.build_load(rounds_pointer, \"repeat_increment_rounds_value\");\n        let rounds_value_incremented = context.builder().build_int_add(\n            rounds_value.into_int_value(),\n            context.field_const(1),\n            \"repeat_rounds_value_incremented\",\n        );\n        context.build_store(rounds_pointer, rounds_value_incremented);\n        context.build_unconditional_branch(condition_block);\n\n        context.pop_loop();\n        context\n            .current_function()\n            .borrow_mut()\n            .remove_stack_pointer(index_identifier.as_str());\n        context.set_basic_block(join_block);\n\n        Ok(())\n    }\n}\n", "//!\n//! The `return` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::instruction::Instruction;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The `return` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Return([Box<Expression>; 2]);\n\nimpl Default for Return {\n    fn default() -> Self {\n        let offset = Expression::IntegerLiteral(serde_json::Number::from(0));\n        let size = Expression::IntegerLiteral(serde_json::Number::from(0));\n        Self([Box::new(offset), Box::new(size)])\n    }\n}\n\nimpl Return {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let arguments = Instruction::translate_arguments_llvm::<D, 2>(self.0, context)?;\n        compiler_llvm_context::r#return::r#return(\n            context,\n            arguments[0].into_int_value(),\n            arguments[1].into_int_value(),\n        )\n    }\n}\n", "//!\n//! The `revert` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::instruction::Instruction;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The `revert` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Revert([Box<Expression>; 2]);\n\nimpl Default for Revert {\n    fn default() -> Self {\n        let offset = Expression::IntegerLiteral(serde_json::Number::from(0));\n        let size = Expression::IntegerLiteral(serde_json::Number::from(0));\n        Self([Box::new(offset), Box::new(size)])\n    }\n}\n\nimpl Revert {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let arguments = Instruction::translate_arguments_llvm::<D, 2>(self.0, context)?;\n        compiler_llvm_context::r#return::revert(\n            context,\n            arguments[0].into_int_value(),\n            arguments[1].into_int_value(),\n        )\n    }\n}\n", "//!\n//! The `seq` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::instruction::label::Label as LabelInstruction;\nuse crate::project::contract::vyper::expression::instruction::r#return::Return as ReturnInstruction;\nuse crate::project::contract::vyper::expression::instruction::revert::Revert as RevertInstruction;\nuse crate::project::contract::vyper::expression::instruction::Instruction;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The `seq` instruction.\n///\n/// This instruction contains a lot of methods to adjust the Vyper LLL structure to that of our\n/// smart contract architecture or the structure of LLVM IR.\n/// Among the methods there are tools of extracting the runtime code from the deploy code's\n/// return statement and some logic of hoisting the contract methods to the upper levels.\n///\n#[derive(Debug, Default, Serialize, Deserialize, Clone)]\npub struct Seq(Vec<Expression>);\n\nimpl Seq {\n    ///\n    /// Checks whether the sequence only contains a single pass.\n    ///\n    pub fn is_pass_or_empty(&self) -> bool {\n        if self.0.len() > 1 {\n            return false;\n        }\n\n        match self.0.get(0) {\n            Some(Expression::Instruction(Instruction::Pass)) => true,\n            Some(_) => false,\n            None => true,\n        }\n    }\n\n    ///\n    /// Extracts the runtime code expression from the deploy code.\n    ///\n    pub fn extract_runtime_code(&mut self) -> anyhow::Result<Option<(Self, Expression)>> {\n        for expression in self.0.iter_mut() {\n            if let Ok(Some(result)) = expression.extract_runtime_code() {\n                return Ok(Some(result));\n            }\n        }\n        Ok(None)\n    }\n\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        let mut index = 0;\n        let mut functions = BTreeMap::new();\n\n        while let Some(expression) = self.0.get_mut(index) {\n            if expression.is_function()? {\n                let name = expression.function_name()?;\n                functions.insert(name, self.0.remove(index));\n            } else {\n                functions.extend(expression.extract_functions()?);\n                index += 1;\n            }\n        }\n\n        Ok(functions)\n    }\n\n    ///\n    /// Drains the expression list and splits it into labels and the rest.\n    ///\n    pub fn drain_and_split(&mut self) -> (Vec<LabelInstruction>, Vec<Expression>) {\n        let mut labels = Vec::with_capacity(2);\n        let mut expressions = Vec::with_capacity(self.0.len());\n\n        for expression in self.0.drain(..) {\n            match expression {\n                Expression::Instruction(Instruction::Label(label)) => labels.push(label),\n                expression => expressions.push(expression),\n            }\n        }\n\n        (labels, expressions)\n    }\n\n    ///\n    /// Normalizes the deploy code by inserting an empty return.\n    ///\n    /// If the deploy code does not have a terminator, a normal return is inserted.\n    ///\n    pub fn normalize_deploy_code(&mut self) {\n        if self.0.is_empty()\n            || matches!(\n                self.0.get(0),\n                Some(Expression::Instruction(Instruction::Deploy(_)))\n            )\n        {\n            self.0.push(Expression::Instruction(Instruction::RETURN(\n                ReturnInstruction::default(),\n            )))\n        }\n    }\n\n    ///\n    /// Normalizes the runtime code by inserting an empty return.\n    ///\n    /// If the runtime code does not have a terminator, a revert is inserted.\n    ///\n    pub fn normalize_runtime_code(&mut self) {\n        if !self.0.is_empty() {\n            return;\n        }\n\n        self.0.push(Expression::Instruction(Instruction::REVERT(\n            RevertInstruction::default(),\n        )))\n    }\n\n    ///\n    /// Whether the sequence is a function entry block.\n    ///\n    pub fn is_function(&self) -> anyhow::Result<bool> {\n        match self.0.first() {\n            Some(Expression::Instruction(Instruction::Label(label))) => label.is_function_entry(),\n            _ => Ok(false),\n        }\n    }\n\n    ///\n    /// Returns the function name.\n    ///\n    pub fn function_name(&self) -> anyhow::Result<String> {\n        match self.0.first() {\n            Some(Expression::Instruction(Instruction::Label(label))) => label.name(),\n            expression => anyhow::bail!(\"Expected a function sequence, found `{:?}`\", expression),\n        }\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        mut self,\n        context: &mut compiler_llvm_context::Context<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let (mut labels, expressions) = self.drain_and_split();\n\n        for label in labels.iter_mut() {\n            label.declare(context)?;\n        }\n        for label in labels.into_iter() {\n            label.into_llvm_value(context)?;\n        }\n\n        let mut result = None;\n        for expression in expressions.into_iter() {\n            if context.basic_block().get_terminator().is_some() {\n                break;\n            }\n\n            result = expression.into_llvm_value(context)?;\n        }\n\n        Ok(result)\n    }\n}\n\nimpl<D> compiler_llvm_context::WriteLLVM<D> for Seq\nwhere\n    D: compiler_llvm_context::Dependency + Clone,\n{\n    fn into_llvm(mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {\n        let current_block = context.basic_block();\n\n        let (mut labels, expressions) = self.drain_and_split();\n\n        for label in labels.iter_mut() {\n            label.declare(context)?;\n        }\n        for label in labels.into_iter() {\n            label.into_llvm_value(context)?;\n        }\n\n        context.set_basic_block(current_block);\n        for expression in expressions.into_iter() {\n            expression.into_llvm_value(context)?;\n        }\n\n        Ok(())\n    }\n}\n", "//!\n//! The `set` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `set` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Set([Box<Expression>; 2]);\n\nimpl Set {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let [identifier, value] = self.0;\n        let identifier = identifier.try_into_identifier()?;\n\n        let pointer = context\n            .current_function()\n            .borrow()\n            .get_stack_pointer(identifier.as_str())\n            .ok_or_else(|| anyhow::anyhow!(\"Variable `{}` not found\", identifier))?;\n\n        let value = value\n            .into_llvm_value(context)?\n            .ok_or_else(|| anyhow::anyhow!(\"Expected a value\"))?;\n        context.build_store(pointer, value);\n\n        Ok(())\n    }\n}\n", "//!\n//! The `with` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `with` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct With([Box<Expression>; 3]);\n\nimpl With {\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        self.0\n            .get_mut(2)\n            .expect(\"Always exists\")\n            .extract_functions()\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::Context<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let [identifier, value, block] = self.0;\n        let identifier = identifier.try_into_identifier()?;\n\n        let pointer = context.build_alloca(context.field_type(), identifier.as_str());\n        let value = value\n            .into_llvm_value(context)?\n            .ok_or_else(|| anyhow::anyhow!(\"Expected a value\"))?;\n        context.build_store(pointer, value);\n        let shadowed_pointer = context\n            .current_function()\n            .borrow_mut()\n            .insert_stack_pointer(identifier.clone(), pointer);\n\n        let result = block.into_llvm_value(context)?;\n\n        match shadowed_pointer {\n            Some(old_pointer) => {\n                context\n                    .current_function()\n                    .borrow_mut()\n                    .insert_stack_pointer(identifier, old_pointer);\n            }\n            None => {\n                context\n                    .current_function()\n                    .borrow_mut()\n                    .remove_stack_pointer(identifier.as_str());\n            }\n        }\n\n        Ok(result)\n    }\n}\n", "//!\n//! The `vyper -f ir_json` output.\n//!\n\npub mod instruction;\n\nuse std::collections::BTreeMap;\n\nuse inkwell::values::BasicValue;\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Number;\n\nuse self::instruction::seq::Seq as SeqInstruction;\nuse self::instruction::Instruction;\n\n///\n/// The LLL IR JSON expression.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(untagged)]\npub enum Expression {\n    /// The LLL IR instruction.\n    Instruction(Instruction),\n    /// The LLL IR integer literal.\n    IntegerLiteral(Number),\n    /// The LLL IR identifier.\n    Identifier(String),\n\n    /// The LLL unknown variant trap.\n    Unknown(serde_json::Value),\n}\n\nimpl Default for Expression {\n    fn default() -> Self {\n        Self::Instruction(Instruction::Seq(SeqInstruction::default()))\n    }\n}\n\nimpl Expression {\n    ///\n    /// Extracts the deploy code expression.\n    ///\n    pub fn try_into_deploy_code(self) -> anyhow::Result<SeqInstruction> {\n        match self {\n            Self::Instruction(Instruction::Seq(mut sequence)) => {\n                sequence.normalize_deploy_code();\n                Ok(sequence)\n            }\n            Self::Instruction(Instruction::Deploy(_deploy)) => {\n                let mut sequence = SeqInstruction::default();\n                sequence.normalize_deploy_code();\n                Ok(sequence)\n            }\n            instruction => anyhow::bail!(\"Expected [`seq`, `deploy`], found `{:?}`\", instruction),\n        }\n    }\n\n    ///\n    /// Extracts the runtime code expression from the deploy code.\n    ///\n    pub fn extract_runtime_code(&mut self) -> anyhow::Result<Option<(SeqInstruction, Self)>> {\n        match self {\n            Self::Instruction(Instruction::Seq(ref mut sequence)) => {\n                match sequence.extract_runtime_code()? {\n                    Some((mut runtime_code, immutables_size)) => {\n                        runtime_code.normalize_runtime_code();\n                        Ok(Some((runtime_code, immutables_size)))\n                    }\n                    None => Ok(None),\n                }\n            }\n            Self::Instruction(Instruction::Deploy(ref mut deploy)) => {\n                let (mut runtime_code, immutables_size) = deploy.extract_runtime_code()?;\n                runtime_code.normalize_runtime_code();\n                Ok(Some((runtime_code, immutables_size)))\n            }\n            instruction => anyhow::bail!(\"Expected [`seq`, `deploy`], found `{:?}`\", instruction),\n        }\n    }\n\n    ///\n    /// Converts the entity to an identifier.\n    ///\n    pub fn try_into_identifier(&self) -> anyhow::Result<String> {\n        match self {\n            Self::Identifier(string) => Ok(string.to_owned()),\n            expression => anyhow::bail!(\"Expected identifier, found `{:?}`\", expression),\n        }\n    }\n\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        match self {\n            Self::Instruction(inner) => inner.extract_functions(),\n            _ => Ok(BTreeMap::new()),\n        }\n    }\n\n    ///\n    /// Whether the expression is a function entry block.\n    ///\n    pub fn is_function(&self) -> anyhow::Result<bool> {\n        match self {\n            Self::Instruction(instruction) => instruction.is_function(),\n            _ => Ok(false),\n        }\n    }\n\n    ///\n    /// Returns the function name.\n    ///\n    pub fn function_name(&self) -> anyhow::Result<String> {\n        match self {\n            Expression::Instruction(inner) => inner.function_name(),\n            expression => anyhow::bail!(\"Expected a function sequence, found `{:?}`\", expression),\n        }\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::Context<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        match self {\n            Self::Instruction(inner) => inner.into_llvm_value(context),\n            Self::IntegerLiteral(number) => {\n                let string = number.to_string();\n\n                let value = if let Some(string) = string.strip_prefix('-') {\n                    let modulo = context.field_const_str_dec(string);\n                    let max_value_diff = context.builder().build_int_sub(\n                        modulo,\n                        context.field_const(1),\n                        \"max_value_diff\",\n                    );\n                    let max_value = context.field_type().const_all_ones();\n                    let value = context.builder().build_int_sub(\n                        max_value,\n                        max_value_diff,\n                        \"negative_value\",\n                    );\n                    value.as_basic_value_enum()\n                } else {\n                    context\n                        .field_const_str_dec(string.as_str())\n                        .as_basic_value_enum()\n                };\n\n                Ok(Some(value))\n            }\n            Self::Identifier(identifier) => {\n                if identifier.as_str() == crate::r#const::DEFAULT_SEQUENCE_IDENTIFIER {\n                    context.build_exit(\n                        context.intrinsics().revert,\n                        context.field_const(0),\n                        context.field_const(0),\n                    );\n                }\n\n                let value = match context\n                    .current_function()\n                    .borrow()\n                    .get_stack_pointer(identifier.as_str())\n                {\n                    Some(pointer) => context.build_load(pointer, identifier.as_str()),\n                    None => context.field_const(0).as_basic_value_enum(),\n                };\n\n                Ok(Some(value))\n            }\n\n            Self::Unknown(value) => {\n                anyhow::bail!(\"Unknown LLL expression: {}\", value);\n            }\n        }\n    }\n}\n", "//!\n//! The Vyper contract function.\n//!\n\nuse inkwell::types::BasicType;\n\nuse compiler_llvm_context::Dependency;\nuse compiler_llvm_context::WriteLLVM;\n\nuse crate::metadata::function::Function as FunctionMetadata;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper contract function.\n///\n#[derive(Debug)]\npub struct Function {\n    /// The function name.\n    pub name: String,\n    /// The function metadata.\n    pub metadata: Option<FunctionMetadata>,\n    /// The function body expression.\n    pub expression: Expression,\n}\n\nimpl Function {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(name: String, metadata: Option<FunctionMetadata>, expression: Expression) -> Self {\n        Self {\n            name,\n            metadata,\n            expression,\n        }\n    }\n}\n\nimpl<D> WriteLLVM<D> for Function\nwhere\n    D: Dependency + Clone,\n{\n    fn declare(&mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {\n        let mut argument_types = vec![];\n        if self\n            .name\n            .starts_with(crate::r#const::FUNCTION_PREFIX_INTERNAL)\n        {\n            if let Some(ref metadata) = self.metadata {\n                if !metadata.return_type.is_empty() && metadata.return_type != \"None\" {\n                    argument_types.push(context.field_type().as_basic_type_enum());\n                }\n            }\n        }\n\n        let function = context.add_function(\n            self.name.as_str(),\n            context.function_type(argument_types, 0, false),\n            0,\n            Some(inkwell::module::Linkage::Private),\n        )?;\n        function\n            .borrow_mut()\n            .set_vyper_data(compiler_llvm_context::FunctionVyperData::default());\n\n        Ok(())\n    }\n\n    fn into_llvm(self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {\n        context.set_current_function(self.name.as_str())?;\n\n        let llvm_entry_block = context.current_function().borrow().entry_block();\n        let llvm_value = context.current_function().borrow().declaration().value;\n\n        self.expression.into_llvm_value(context)?;\n\n        context.set_basic_block(llvm_entry_block);\n        let ir_entry_block = llvm_value\n            .get_basic_blocks()\n            .iter()\n            .find(|block| block.get_name().to_string_lossy() == self.name)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Block `{}` does not exist\", self.name))?;\n        context.build_unconditional_branch(ir_entry_block);\n\n        context.set_basic_block(context.current_function().borrow().return_block());\n        context.build_return(None);\n\n        for block in llvm_value.get_basic_blocks() {\n            if block.get_terminator().is_none() {\n                context.set_basic_block(block);\n                context.build_exit(\n                    context.intrinsics().revert,\n                    context.field_const(0),\n                    context.field_const(0),\n                );\n            }\n        }\n\n        Ok(())\n    }\n}\n", "//!\n//! The Vyper contract.\n//!\n\npub mod expression;\npub mod function;\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse compiler_llvm_context::Dependency;\nuse compiler_llvm_context::WriteLLVM;\n\nuse crate::build::contract::Contract as ContractBuild;\nuse crate::metadata::Metadata as SourceMetadata;\nuse crate::project::contract::metadata::Metadata as ContractMetadata;\nuse crate::project::dependency_data::DependencyData;\n\nuse self::expression::Expression;\nuse self::function::Function;\n\n///\n/// The Vyper contract.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Contract {\n    /// The Vyper compiler version.\n    pub version: semver::Version,\n    /// The Vyper contract source code.\n    pub source_code: String,\n    /// The source metadata.\n    pub source_metadata: SourceMetadata,\n    /// The inner expression.\n    pub expression: Expression,\n    /// The contract ABI data.\n    pub abi: BTreeMap<String, String>,\n    /// The dependency data.\n    pub dependency_data: DependencyData,\n}\n\nimpl Contract {\n    /// The number of vyper compiler output lines per contract.\n    pub const EXPECTED_LINES: usize = 3;\n\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(\n        version: semver::Version,\n        source_code: String,\n        source_metadata: SourceMetadata,\n        expression: Expression,\n        abi: BTreeMap<String, String>,\n    ) -> Self {\n        Self {\n            version,\n            source_code,\n            source_metadata,\n            expression,\n            abi,\n            dependency_data: DependencyData::default(),\n        }\n    }\n\n    ///\n    /// Parses three lines with JSONs, returned by the Vyper compiler.\n    /// The order must be:\n    /// 1. The LLL IR JSON\n    /// 2. The contract functions metadata\n    /// 3. The contract ABI data\n    ///\n    pub fn try_from_lines(\n        version: semver::Version,\n        source_code: String,\n        mut lines: Vec<&str>,\n    ) -> anyhow::Result<Self> {\n        if lines.len() != Self::EXPECTED_LINES {\n            anyhow::bail!(\n                \"Expected {} lines with JSONs, found {}\",\n                Self::EXPECTED_LINES,\n                lines.len()\n            );\n        }\n\n        let mut deserializer = serde_json::Deserializer::from_str(lines.remove(0));\n        deserializer.disable_recursion_limit();\n        let deserializer = serde_stacker::Deserializer::new(&mut deserializer);\n        let expression = Expression::deserialize(deserializer)?;\n\n        let metadata: SourceMetadata = serde_json::from_str(lines.remove(0))?;\n\n        let abi: BTreeMap<String, String> = serde_json::from_str(lines.remove(0))?;\n\n        Ok(Self::new(version, source_code, metadata, expression, abi))\n    }\n\n    ///\n    /// Compiles the contract, returning the build.\n    ///\n    pub fn compile(\n        mut self,\n        contract_path: &str,\n        source_code_hash: Option<[u8; compiler_common::BYTE_LENGTH_FIELD]>,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<ContractBuild> {\n        let llvm = inkwell::context::Context::create();\n        let optimizer = compiler_llvm_context::Optimizer::new(optimizer_settings);\n\n        let metadata_hash = source_code_hash.map(|source_code_hash| {\n            ContractMetadata::new(\n                &source_code_hash,\n                &self.version,\n                semver::Version::parse(env!(\"CARGO_PKG_VERSION\")).expect(\"Always valid\"),\n                optimizer.settings().to_owned(),\n            )\n            .keccak256()\n        });\n\n        let dependency_data = DependencyData::default();\n        let mut context = compiler_llvm_context::Context::<DependencyData>::new(\n            &llvm,\n            llvm.create_module(contract_path),\n            optimizer,\n            Some(dependency_data),\n            metadata_hash.is_some(),\n            debug_config,\n        );\n\n        self.declare(&mut context).map_err(|error| {\n            anyhow::anyhow!(\n                \"The contract `{}` LLVM IR generator declaration pass error: {}\",\n                contract_path,\n                error\n            )\n        })?;\n        self.into_llvm(&mut context).map_err(|error| {\n            anyhow::anyhow!(\n                \"The contract `{}` LLVM IR generator definition pass error: {}\",\n                contract_path,\n                error\n            )\n        })?;\n\n        let is_forwarder_used = context.vyper().is_forwarder_used();\n        let mut build = context.build(contract_path, metadata_hash)?;\n\n        if is_forwarder_used {\n            build.factory_dependencies.insert(\n                crate::r#const::FORWARDER_CONTRACT_HASH.clone(),\n                crate::r#const::FORWARDER_CONTRACT_NAME.to_owned(),\n            );\n        }\n\n        Ok(ContractBuild::new(build))\n    }\n}\n\nimpl<D> WriteLLVM<D> for Contract\nwhere\n    D: Dependency + Clone,\n{\n    fn declare(&mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {\n        let mut entry = compiler_llvm_context::EntryFunction::default();\n        entry.declare(context)?;\n\n        let mut runtime =\n            compiler_llvm_context::Runtime::new(compiler_llvm_context::AddressSpace::HeapAuxiliary);\n        runtime.declare(context)?;\n\n        compiler_llvm_context::DeployCodeFunction::new(\n            compiler_llvm_context::DummyLLVMWritable::default(),\n        )\n        .declare(context)?;\n        compiler_llvm_context::RuntimeCodeFunction::new(\n            compiler_llvm_context::DummyLLVMWritable::default(),\n        )\n        .declare(context)?;\n\n        for name in [\n            compiler_llvm_context::Runtime::FUNCTION_DEPLOY_CODE,\n            compiler_llvm_context::Runtime::FUNCTION_RUNTIME_CODE,\n            compiler_llvm_context::Runtime::FUNCTION_ENTRY,\n        ]\n        .into_iter()\n        {\n            context\n                .get_function(name)\n                .expect(\"Always exists\")\n                .borrow_mut()\n                .set_vyper_data(compiler_llvm_context::FunctionVyperData::default());\n        }\n\n        entry.into_llvm(context)?;\n\n        runtime.into_llvm(context)?;\n\n        Ok(())\n    }\n\n    fn into_llvm(mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {\n        let (mut runtime_code, immutables_size) =\n            self.expression.extract_runtime_code()?.unwrap_or_default();\n        let mut deploy_code = self.expression.try_into_deploy_code()?;\n\n        match immutables_size {\n            Expression::IntegerLiteral(number) => {\n                let immutables_size = number\n                    .as_u64()\n                    .ok_or_else(|| anyhow::anyhow!(\"Immutable size `{}` parsing error\", number))?;\n                let vyper_data =\n                    compiler_llvm_context::ContextVyperData::new(immutables_size as usize, false);\n                context.set_vyper_data(vyper_data);\n            }\n            expression => anyhow::bail!(\"Invalid immutables size format: {:?}\", expression),\n        }\n\n        let mut function_expressions = deploy_code\n            .extract_functions()?\n            .into_iter()\n            .map(|(label, expression)| (label, expression, compiler_llvm_context::CodeType::Deploy))\n            .collect::<Vec<(String, Expression, compiler_llvm_context::CodeType)>>();\n        function_expressions.extend(\n            runtime_code\n                .extract_functions()?\n                .into_iter()\n                .map(|(label, expression)| {\n                    (label, expression, compiler_llvm_context::CodeType::Runtime)\n                })\n                .collect::<Vec<(String, Expression, compiler_llvm_context::CodeType)>>(),\n        );\n\n        let mut functions = Vec::with_capacity(function_expressions.capacity());\n        for (label, expression, code_type) in function_expressions.into_iter() {\n            let mut metadata_label = label\n                .strip_suffix(format!(\"_{}\", compiler_llvm_context::CodeType::Deploy).as_str())\n                .unwrap_or(label.as_str());\n            metadata_label = label\n                .strip_suffix(format!(\"_{}\", compiler_llvm_context::CodeType::Runtime).as_str())\n                .unwrap_or(metadata_label);\n            metadata_label = label\n                .strip_suffix(format!(\"_{}\", crate::r#const::LABEL_SUFFIX_COMMON).as_str())\n                .unwrap_or(metadata_label);\n\n            let metadata_name =\n                self.source_metadata\n                    .function_info\n                    .iter()\n                    .find_map(|(name, function)| {\n                        if metadata_label == function.ir_identifier.as_str() {\n                            Some(name.to_owned())\n                        } else {\n                            None\n                        }\n                    });\n            let metadata = match metadata_name {\n                Some(metadata_name) => self\n                    .source_metadata\n                    .function_info\n                    .get(metadata_name.as_str())\n                    .cloned(),\n                None => None,\n            };\n            functions.push((Function::new(label, metadata, expression), code_type));\n        }\n        for (function, _code_type) in functions.iter_mut() {\n            function.declare(context)?;\n        }\n        for (function, code_type) in functions.into_iter() {\n            context.set_code_type(code_type);\n            function.into_llvm(context)?;\n        }\n\n        compiler_llvm_context::DeployCodeFunction::new(deploy_code).into_llvm(context)?;\n        compiler_llvm_context::RuntimeCodeFunction::new(runtime_code).into_llvm(context)?;\n\n        Ok(())\n    }\n}\n\nimpl Dependency for DependencyData {\n    fn compile(\n        _contract: Self,\n        _name: &str,\n        _optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        _is_system_mode: bool,\n        _include_metadata_hash: bool,\n        _debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<String> {\n        Ok(crate::r#const::FORWARDER_CONTRACT_HASH.clone())\n    }\n\n    fn resolve_path(&self, _identifier: &str) -> anyhow::Result<String> {\n        anyhow::bail!(\"The dependency mechanism is not available in Vyper\");\n    }\n\n    fn resolve_library(&self, _path: &str) -> anyhow::Result<String> {\n        anyhow::bail!(\"The dependency mechanism is not available in Vyper\");\n    }\n}\n", "//!\n//! The zkEVM assembly contract.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::build::contract::Contract as ContractBuild;\nuse crate::project::contract::metadata::Metadata as ContractMetadata;\n\n///\n/// The zkEVM assembly contract.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Contract {\n    /// The zkEVM version.\n    pub version: semver::Version,\n    /// The contract source code.\n    pub source_code: String,\n}\n\nimpl Contract {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(version: semver::Version, source_code: String) -> Self {\n        Self {\n            version,\n            source_code,\n        }\n    }\n\n    ///\n    /// Compiles the contract, returning the build.\n    ///\n    pub fn compile(\n        self,\n        contract_path: &str,\n        source_code_hash: Option<[u8; compiler_common::BYTE_LENGTH_FIELD]>,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<ContractBuild> {\n        let metadata_hash = source_code_hash.map(|source_code_hash| {\n            ContractMetadata::new(\n                &source_code_hash,\n                &self.version,\n                semver::Version::parse(env!(\"CARGO_PKG_VERSION\")).expect(\"Always valid\"),\n                optimizer_settings,\n            )\n            .keccak256()\n        });\n\n        let build = compiler_llvm_context::build_assembly_text(\n            contract_path,\n            self.source_code.as_str(),\n            metadata_hash,\n            debug_config.as_ref(),\n        )?;\n\n        Ok(ContractBuild::new(build))\n    }\n}\n", "//!\n//! The Vyper project.\n//!\n\npub mod contract;\npub mod dependency_data;\n\nuse std::collections::BTreeMap;\nuse std::path::Path;\n\nuse rayon::iter::IntoParallelIterator;\nuse rayon::iter::ParallelIterator;\nuse sha3::Digest;\n\nuse crate::build::contract::Contract as ContractBuild;\nuse crate::build::Build;\nuse crate::process::input::Input as ProcessInput;\n\nuse self::contract::llvm_ir::Contract as LLVMIRContract;\nuse self::contract::zkasm::Contract as ZKASMContract;\nuse self::contract::Contract;\n\n///\n/// The Vyper project.\n///\n#[derive(Debug, Clone)]\npub struct Project {\n    /// The Vyper compiler version.\n    pub version: semver::Version,\n    /// The project source code hash.\n    pub source_code_hash: [u8; compiler_common::BYTE_LENGTH_FIELD],\n    /// The contract data,\n    pub contracts: BTreeMap<String, Contract>,\n}\n\nimpl Project {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(\n        version: semver::Version,\n        source_code_hash: [u8; compiler_common::BYTE_LENGTH_FIELD],\n        contracts: BTreeMap<String, Contract>,\n    ) -> Self {\n        Self {\n            version,\n            source_code_hash,\n            contracts,\n        }\n    }\n\n    ///\n    /// Parses the LLVM IR source code file and returns the source data.\n    ///\n    pub fn try_from_llvm_ir_path(path: &Path) -> anyhow::Result<Self> {\n        let source_code = std::fs::read_to_string(path)\n            .map_err(|error| anyhow::anyhow!(\"LLVM IR file {:?} reading error: {}\", path, error))?;\n        let path = path.to_string_lossy().to_string();\n\n        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();\n\n        let mut project_contracts = BTreeMap::new();\n        project_contracts.insert(\n            path,\n            LLVMIRContract::new(compiler_llvm_context::LLVM_VERSION, source_code).into(),\n        );\n\n        Ok(Self::new(\n            compiler_llvm_context::LLVM_VERSION,\n            source_code_hash,\n            project_contracts,\n        ))\n    }\n\n    ///\n    /// Parses the zkEVM assembly source code file and returns the source data.\n    ///\n    pub fn try_from_zkasm_path(path: &Path) -> anyhow::Result<Self> {\n        let source_code = std::fs::read_to_string(path).map_err(|error| {\n            anyhow::anyhow!(\"zkEVM assembly file {:?} reading error: {}\", path, error)\n        })?;\n        let path = path.to_string_lossy().to_string();\n\n        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();\n\n        let mut project_contracts = BTreeMap::new();\n        project_contracts.insert(\n            path,\n            ZKASMContract::new(compiler_llvm_context::ZKEVM_VERSION, source_code).into(),\n        );\n\n        Ok(Self::new(\n            compiler_llvm_context::ZKEVM_VERSION,\n            source_code_hash,\n            project_contracts,\n        ))\n    }\n\n    ///\n    /// Compiles all contracts, returning the build.\n    ///\n    pub fn compile(\n        self,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        include_metadata_hash: bool,\n        bytecode_encoding: zkevm_assembly::RunningVmEncodingMode,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<Build> {\n        let mut build = Build::default();\n        let source_code_hash = if include_metadata_hash {\n            Some(self.source_code_hash)\n        } else {\n            None\n        };\n        let results: BTreeMap<String, anyhow::Result<ContractBuild>> = self\n            .contracts\n            .into_par_iter()\n            .map(|(full_path, contract)| {\n                let process_output = crate::process::call(ProcessInput::new(\n                    full_path.clone(),\n                    contract,\n                    source_code_hash,\n                    bytecode_encoding == zkevm_assembly::RunningVmEncodingMode::Testing,\n                    optimizer_settings.clone(),\n                    debug_config.clone(),\n                ));\n\n                (full_path, process_output.map(|output| output.build))\n            })\n            .collect();\n\n        let is_forwarder_used = results.iter().any(|(_path, result)| {\n            result\n                .as_ref()\n                .map(|contract| {\n                    contract\n                        .build\n                        .factory_dependencies\n                        .contains_key(crate::r#const::FORWARDER_CONTRACT_HASH.as_str())\n                })\n                .unwrap_or_default()\n        });\n        if is_forwarder_used {\n            let forwarder_build = compiler_llvm_context::Build::new(\n                crate::r#const::FORWARDER_CONTRACT_ASSEMBLY.to_owned(),\n                None,\n                crate::r#const::FORWARDER_CONTRACT_BYTECODE.clone(),\n                crate::r#const::FORWARDER_CONTRACT_HASH.clone(),\n            );\n            build.contracts.insert(\n                crate::r#const::FORWARDER_CONTRACT_NAME.to_owned(),\n                ContractBuild::new(forwarder_build),\n            );\n        }\n\n        for (path, result) in results.into_iter() {\n            match result {\n                Ok(contract) => {\n                    build.contracts.insert(path, contract);\n                }\n                Err(error) => {\n                    anyhow::bail!(\"Contract `{}` compiling error: {:?}\", path, error);\n                }\n            }\n        }\n\n        Ok(build)\n    }\n}\n", "//!\n//! The Vyper compiler unit tests.\n//!\n\n#![cfg(test)]\n#![allow(dead_code)]\n\npub mod builtins;\n\nuse std::collections::BTreeMap;\nuse std::path::PathBuf;\n\nuse crate::vyper::standard_json::input::settings::evm_version::EVMVersion as VyperStandardJsonInputSettingsEVMVersion;\nuse crate::vyper::standard_json::input::settings::selection::Selection as VyperStandardJsonInputSettingsSelection;\nuse crate::vyper::standard_json::input::Input as VyperStandardJsonInput;\nuse crate::vyper::Compiler as VyperCompiler;\n\nfn check_dependencies() {\n    for executable in [\n        crate::r#const::DEFAULT_EXECUTABLE_NAME,\n        VyperCompiler::DEFAULT_EXECUTABLE_NAME,\n    ]\n    .iter()\n    {\n        assert!(\n            which::which(executable).is_ok(),\n            \"The `{executable}` executable not found in ${{PATH}}\"\n        );\n    }\n}\n\npub fn build_vyper(\n    source_code: &str,\n    version: semver::Version,\n    message_version: &str,\n) -> anyhow::Result<()> {\n    check_dependencies();\n\n    let vyper = VyperCompiler::new(VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned());\n    if vyper.version.default != version {\n        panic!(\"{}\", message_version);\n    }\n\n    inkwell::support::enable_llvm_pretty_stack_trace();\n    compiler_llvm_context::initialize_target();\n    let _ = crate::process::EXECUTABLE.set(PathBuf::from(crate::r#const::DEFAULT_EXECUTABLE_NAME));\n    let optimizer_settings = compiler_llvm_context::OptimizerSettings::none();\n\n    let mut sources = BTreeMap::new();\n    sources.insert(\"test.vy\".to_string(), source_code.to_string());\n    let input = VyperStandardJsonInput::try_from_sources(\n        sources.clone(),\n        VyperStandardJsonInputSettingsEVMVersion::Paris,\n        VyperStandardJsonInputSettingsSelection::generate_default(),\n        true,\n    )?;\n\n    let output = vyper.standard_json(input)?;\n\n    let project = output.try_into_project(&vyper.version.default)?;\n    let _build = project.compile(\n        optimizer_settings,\n        false,\n        zkevm_assembly::RunningVmEncodingMode::Production,\n        None,\n    )?;\n\n    Ok(())\n}\n", "//!\n//! The Vyper compiler.\n//!\n\npub mod combined_json;\npub mod standard_json;\npub mod version;\n\nuse std::collections::BTreeMap;\nuse std::io::Write;\nuse std::path::Path;\nuse std::path::PathBuf;\n\nuse rayon::iter::IndexedParallelIterator;\nuse rayon::iter::IntoParallelIterator;\nuse rayon::iter::ParallelIterator;\nuse sha3::digest::FixedOutput;\nuse sha3::Digest;\n\nuse crate::project::contract::vyper::Contract as VyperContract;\nuse crate::project::contract::Contract;\nuse crate::project::Project;\n\nuse self::combined_json::CombinedJson;\nuse self::standard_json::input::Input as StandardJsonInput;\nuse self::standard_json::output::Output as StandardJsonOutput;\nuse self::version::Version;\n\n///\n/// The Vyper compiler.\n///\npub struct Compiler {\n    /// The binary executable name.\n    pub executable: String,\n    /// The binary version.\n    pub version: Version,\n}\n\nimpl Compiler {\n    /// The default executable name.\n    pub const DEFAULT_EXECUTABLE_NAME: &'static str = \"vyper\";\n\n    /// The supported versions of `vyper`.\n    pub const SUPPORTED_VERSIONS: [semver::Version; 2] =\n        [semver::Version::new(0, 3, 3), semver::Version::new(0, 3, 9)];\n\n    ///\n    /// A shortcut constructor.\n    ///\n    /// Different tools may use different `executable` names. For example, the integration tester\n    /// uses `vyper-<version>` format.\n    ///\n    pub fn new(executable: String) -> Self {\n        let version = Self::version(&executable).expect(\"Version getting error\");\n        Self {\n            executable,\n            version,\n        }\n    }\n\n    ///\n    /// The `vyper -f combined_json input_files...` mirror.\n    ///\n    pub fn combined_json(&self, paths: &[PathBuf]) -> anyhow::Result<CombinedJson> {\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.arg(\"-f\");\n        command.arg(\"combined_json\");\n        command.args(paths);\n        let output = command.output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess error: {:?}\", self.executable, error)\n        })?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let combined_json = serde_json::from_slice(output.stdout.as_slice()).expect(\"Always valid\");\n\n        Ok(combined_json)\n    }\n\n    ///\n    /// The `vyper --standard-json` mirror.\n    ///\n    pub fn standard_json(&self, input: StandardJsonInput) -> anyhow::Result<StandardJsonOutput> {\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.stdin(std::process::Stdio::piped());\n        command.stdout(std::process::Stdio::piped());\n        command.arg(\"--standard-json\");\n\n        let input_json = serde_json::to_vec(&input).expect(\"Always valid\");\n\n        let process = command.spawn().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess spawning error: {:?}\", self.executable, error)\n        })?;\n        process\n            .stdin\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"{} stdin getting error\", self.executable))?\n            .write_all(input_json.as_slice())\n            .map_err(|error| {\n                anyhow::anyhow!(\"{} stdin writing error: {:?}\", self.executable, error)\n            })?;\n\n        let output = process.wait_with_output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess output error: {:?}\", self.executable, error)\n        })?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let mut output: StandardJsonOutput = serde_json::from_slice(output.stdout.as_slice())\n            .map_err(|error| {\n                anyhow::anyhow!(\n                    \"{} subprocess output parsing error: {}\\n{}\",\n                    self.executable,\n                    error,\n                    serde_json::from_slice::<serde_json::Value>(output.stdout.as_slice())\n                        .map(|json| serde_json::to_string_pretty(&json).expect(\"Always valid\"))\n                        .unwrap_or_else(\n                            |_| String::from_utf8_lossy(output.stdout.as_slice()).to_string()\n                        ),\n                )\n            })?;\n\n        for (full_path, source) in input.sources.into_iter() {\n            let last_slash_position = full_path.rfind('/');\n            let last_dot_position = full_path.rfind('.');\n            let contract_name = &full_path[last_slash_position.unwrap_or_default()\n                ..last_dot_position.unwrap_or(full_path.len())];\n\n            Self::check_unsupported(source.content.as_str())\n                .map_err(|error| anyhow::anyhow!(\"Contract `{}`: {}\", full_path, error))?;\n\n            output\n                .files\n                .as_mut()\n                .ok_or_else(|| anyhow::anyhow!(\"No contracts in the standard JSON output\"))?\n                .get_mut(full_path.as_str())\n                .ok_or_else(|| {\n                    anyhow::anyhow!(\"File `{}` not found in the standard JSON output\", full_path)\n                })?\n                .get_mut(contract_name)\n                .ok_or_else(|| {\n                    anyhow::anyhow!(\n                        \"Contract `{}` not found in the standard JSON output\",\n                        contract_name\n                    )\n                })?\n                .source_code = Some(source.content);\n        }\n\n        Ok(output)\n    }\n\n    ///\n    /// Returns the Vyper LLL in the native format for the contract at `path`.\n    ///\n    /// Is used to print the IR for debugging.\n    ///\n    pub fn lll_debug(&self, path: &Path, optimize: bool) -> anyhow::Result<String> {\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.arg(\"-f\");\n        command.arg(\"ir\");\n        if !optimize {\n            command.arg(\"--no-optimize\");\n        }\n        command.arg(path);\n\n        let output = command.output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess error: {:?}\", self.executable, error)\n        })?;\n\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let stdout = String::from_utf8_lossy(output.stdout.as_slice()).to_string();\n\n        Ok(stdout)\n    }\n\n    ///\n    /// Returns all the Vyper data required to compile the contracts at `paths`.\n    ///\n    pub fn batch(\n        &self,\n        version: &semver::Version,\n        mut paths: Vec<PathBuf>,\n        optimize: bool,\n    ) -> anyhow::Result<Project> {\n        paths.sort();\n\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.arg(\"-f\");\n        command.arg(\"ir_json,metadata,method_identifiers\");\n        if !optimize {\n            command.arg(\"--no-optimize\");\n        }\n        command.args(paths.as_slice());\n\n        let output = command.output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess error: {:?}\", self.executable, error)\n        })?;\n\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let stdout = String::from_utf8_lossy(output.stdout.as_slice()).to_string();\n        let lines: Vec<&str> = stdout.lines().collect();\n        let results: BTreeMap<String, anyhow::Result<VyperContract>> = paths\n            .into_par_iter()\n            .zip(lines.into_par_iter().chunks(3))\n            .map(|(path, group)| {\n                let path_str = path.to_string_lossy().to_string();\n                let source_code = match std::fs::read_to_string(path).map_err(|error| {\n                    anyhow::anyhow!(\"Source code file `{}` reading error: {}\", path_str, error)\n                }) {\n                    Ok(source_code) => source_code,\n                    Err(error) => return (path_str, Err(error)),\n                };\n\n                if let Err(error) = Self::check_unsupported(source_code.as_str()) {\n                    let error = anyhow::anyhow!(\"Contract `{}`: {}\", path_str, error);\n                    return (path_str, Err(error));\n                }\n\n                let contract_result =\n                    VyperContract::try_from_lines(version.to_owned(), source_code, group.to_vec())\n                        .map_err(|error| {\n                            anyhow::anyhow!(\n                                \"Contract `{}` JSON output parsing: {}\",\n                                path_str,\n                                error\n                            )\n                        });\n\n                (path_str, contract_result)\n            })\n            .collect();\n        let contracts =\n            results\n                .into_iter()\n                .try_fold(BTreeMap::new(), |mut accumulator, (path, result)| {\n                    accumulator.insert(path, result?.into());\n                    Ok::<BTreeMap<String, Contract>, anyhow::Error>(accumulator)\n                })?;\n\n        let mut source_code_hasher = sha3::Keccak256::new();\n        for (_path, contract) in contracts.iter() {\n            source_code_hasher.update(contract.source_code().as_bytes());\n        }\n        let source_code_hash: [u8; compiler_common::BYTE_LENGTH_FIELD] =\n            source_code_hasher.finalize_fixed().into();\n\n        let project = Project::new(version.to_owned(), source_code_hash, contracts);\n\n        Ok(project)\n    }\n\n    ///\n    /// The `vyper -f <identifiers> ...` mirror.\n    ///\n    pub fn extra_output(&self, path: &Path, extra_output: &str) -> anyhow::Result<String> {\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.arg(\"-f\");\n        command.arg(extra_output);\n        command.arg(path);\n        let output = command.output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess error: {:?}\", self.executable, error)\n        })?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        Ok(String::from_utf8_lossy(output.stdout.as_slice()).to_string())\n    }\n\n    ///\n    /// Checks for unsupported code is a Vyper source code file.\n    ///\n    pub fn check_unsupported(source_code: &str) -> anyhow::Result<()> {\n        for function in [\n            crate::r#const::FORBIDDEN_FUNCTION_NAME_CREATE_COPY_OF,\n            crate::r#const::FORBIDDEN_FUNCTION_NAME_CREATE_FROM_BLUEPRINT,\n        ] {\n            if source_code.contains(function) {\n                return Err(anyhow::anyhow!(\n                    \"Built-in function `{}` is not supported\",\n                    function\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    ///\n    /// The `vyper --version` mini-parser.\n    ///\n    fn version(executable: &str) -> anyhow::Result<Version> {\n        let mut command = std::process::Command::new(executable);\n        command.arg(\"--version\");\n        let output = command\n            .output()\n            .map_err(|error| anyhow::anyhow!(\"{} subprocess error: {:?}\", executable, error))?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let stdout = String::from_utf8_lossy(output.stdout.as_slice());\n        let long = stdout.to_string();\n        let default: semver::Version = long\n            .split('+')\n            .next()\n            .ok_or_else(|| anyhow::anyhow!(\"{} version parsing: metadata dropping\", executable))?\n            .parse()\n            .map_err(|error| anyhow::anyhow!(\"{} version parsing: {}\", executable, error))?;\n\n        let version = Version::new(long, default);\n        if !Self::SUPPORTED_VERSIONS.contains(&version.default) {\n            anyhow::bail!(\n                \"Only `vyper` versions [ {} ] are supported, found {}\",\n                Self::SUPPORTED_VERSIONS\n                    .into_iter()\n                    .map(|version| version.to_string())\n                    .collect::<Vec<String>>()\n                    .join(\", \"),\n                version.default,\n            );\n        }\n\n        Ok(version)\n    }\n}\n", "//!\n//! Vyper to zkEVM compiler arguments.\n//!\n\nuse std::path::PathBuf;\n\nuse structopt::StructOpt;\n\n///\n/// Pythonic Smart Contract Language for the zkEVM.\n///\n/// Example: `zkvyper ERC20.vy`\n///\n#[derive(Debug, StructOpt)]\n#[structopt(name = \"The zkEVM Vyper compiler\")]\npub struct Arguments {\n    /// Print the version and exit.\n    #[structopt(long = \"version\")]\n    pub version: bool,\n\n    /// Specify the input file paths.\n    /// Multiple Vyper files can be passed in the default Vyper mode.\n    /// LLVM IR mode currently supports only a single file.\n    #[structopt(parse(from_os_str))]\n    pub input_files: Vec<PathBuf>,\n\n    /// Create one file per component and contract/file at the specified directory, if given.\n    #[structopt(short = \"o\", long = \"output-dir\")]\n    pub output_directory: Option<PathBuf>,\n\n    /// Overwrite existing files (used together with -o).\n    #[structopt(long = \"overwrite\")]\n    pub overwrite: bool,\n\n    /// Set the optimization parameter -O[0 | 1 | 2 | 3 | s | z].\n    /// Use `3` for best performance and `z` for minimal size.\n    #[structopt(short = \"O\", long = \"optimization\")]\n    pub optimization: Option<char>,\n\n    /// Disable the `vyper` LLL IR optimizer.\n    #[structopt(long = \"disable-vyper-optimizer\")]\n    pub disable_vyper_optimizer: bool,\n\n    /// Specify the path to the `vyper` executable. By default, the one in `${PATH}` is used.\n    /// In LLVM IR mode `vyper` is unused.\n    #[structopt(long = \"vyper\")]\n    pub vyper: Option<String>,\n\n    /// An extra output format string.\n    /// See `vyper --help` for available options.\n    #[structopt(short = \"f\")]\n    pub format: Option<String>,\n\n    /// Switch to LLVM IR mode.\n    /// Only one input LLVM IR file is allowed.\n    /// Cannot be used with combined or standard JSON modes.\n    #[structopt(long = \"llvm-ir\")]\n    pub llvm_ir: bool,\n\n    /// Switch to zkEVM assembly mode.\n    /// Only one input zkEVM assembly file is allowed.\n    /// Cannot be used with combined or standard JSON modes.\n    #[structopt(long = \"zkasm\")]\n    pub zkasm: bool,\n\n    /// Set metadata hash mode: `keccak256` | `none`.\n    /// `keccak256` is enabled by default.\n    #[structopt(long = \"metadata-hash\")]\n    pub metadata_hash: Option<String>,\n\n    /// Dump all IR (LLL, LLVM IR, assembly) to files in the specified directory.\n    /// Only for testing and debugging.\n    #[structopt(long = \"debug-output-dir\")]\n    pub debug_output_directory: Option<PathBuf>,\n\n    /// Set the `verify-each` option in LLVM.\n    /// Only for testing and debugging.\n    #[structopt(long = \"llvm-verify-each\")]\n    pub llvm_verify_each: bool,\n\n    /// Set the `debug-logging` option in LLVM.\n    /// Only for testing and debugging.\n    #[structopt(long = \"llvm-debug-logging\")]\n    pub llvm_debug_logging: bool,\n\n    /// Run this process recursively and provide JSON input to compile a single contract.\n    /// Only for usage from within the compiler.\n    #[structopt(long = \"recursive-process\")]\n    pub recursive_process: bool,\n}\n\nimpl Default for Arguments {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Arguments {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new() -> Self {\n        Self::from_args()\n    }\n\n    ///\n    /// Validates the arguments.\n    ///\n    pub fn validate(&self) -> anyhow::Result<()> {\n        if self.version && std::env::args().count() > 2 {\n            anyhow::bail!(\"No other options are allowed while getting the compiler version.\");\n        }\n\n        if self.recursive_process && std::env::args().count() > 2 {\n            anyhow::bail!(\"No other options are allowed in recursive mode.\");\n        }\n\n        if self.llvm_ir && self.zkasm {\n            anyhow::bail!(\"Either LLVM IR or assembly mode can be used, but not both.\");\n        }\n\n        Ok(())\n    }\n}\n", "//!\n//! Vyper to zkEVM compiler binary.\n//!\n\npub mod arguments;\n\nuse std::path::PathBuf;\nuse std::str::FromStr;\n\nuse self::arguments::Arguments;\n\n/// The rayon worker stack size.\nconst RAYON_WORKER_STACK_SIZE: usize = 16 * 1024 * 1024;\n\n#[cfg(target_env = \"musl\")]\n#[global_allocator]\nstatic GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;\n\n///\n/// The application entry point.\n///\nfn main() {\n    std::process::exit(match main_inner() {\n        Ok(()) => 0,\n        Err(error) => {\n            eprintln!(\"{error}\");\n            1\n        }\n    })\n}\n\n///\n/// The auxiliary `main` function to facilitate the `?` error conversion operator.\n///\nfn main_inner() -> anyhow::Result<()> {\n    let mut arguments = Arguments::new();\n    arguments.validate()?;\n\n    rayon::ThreadPoolBuilder::new()\n        .stack_size(RAYON_WORKER_STACK_SIZE)\n        .build_global()\n        .expect(\"Thread pool configuration failure\");\n    inkwell::support::enable_llvm_pretty_stack_trace();\n    compiler_llvm_context::initialize_target();\n\n    if arguments.version {\n        println!(\n            \"{} v{} (LLVM build {})\",\n            env!(\"CARGO_PKG_DESCRIPTION\"),\n            env!(\"CARGO_PKG_VERSION\"),\n            inkwell::support::get_commit_id().to_string(),\n        );\n        return Ok(());\n    }\n\n    if arguments.recursive_process {\n        return compiler_vyper::run_process();\n    }\n\n    let debug_config = match arguments.debug_output_directory {\n        Some(debug_output_directory) => {\n            std::fs::create_dir_all(debug_output_directory.as_path())?;\n            Some(compiler_llvm_context::DebugConfig::new(\n                debug_output_directory,\n            ))\n        }\n        None => None,\n    };\n\n    for path in arguments.input_files.iter_mut() {\n        *path = path.canonicalize()?;\n    }\n\n    let vyper = compiler_vyper::VyperCompiler::new(\n        arguments\n            .vyper\n            .unwrap_or_else(|| compiler_vyper::VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned()),\n    );\n\n    let mut optimizer_settings = match arguments.optimization {\n        Some(mode) => compiler_llvm_context::OptimizerSettings::try_from_cli(mode)?,\n        None => compiler_llvm_context::OptimizerSettings::cycles(),\n    };\n    optimizer_settings.is_verify_each_enabled = arguments.llvm_verify_each;\n    optimizer_settings.is_debug_logging_enabled = arguments.llvm_debug_logging;\n\n    let include_metadata_hash = match arguments.metadata_hash {\n        Some(metadata_hash) => {\n            let metadata = compiler_llvm_context::MetadataHash::from_str(metadata_hash.as_str())?;\n            metadata != compiler_llvm_context::MetadataHash::None\n        }\n        None => true,\n    };\n\n    let build = if arguments.llvm_ir {\n        compiler_vyper::llvm_ir(\n            arguments.input_files,\n            optimizer_settings,\n            include_metadata_hash,\n            debug_config,\n        )\n    } else if arguments.zkasm {\n        compiler_vyper::zkasm(arguments.input_files, include_metadata_hash, debug_config)\n    } else {\n        match arguments.format.as_deref() {\n            Some(\"combined_json\") => {\n                compiler_vyper::combined_json(\n                    arguments.input_files,\n                    &vyper,\n                    !arguments.disable_vyper_optimizer,\n                    optimizer_settings,\n                    include_metadata_hash,\n                    debug_config,\n                    arguments.output_directory,\n                    arguments.overwrite,\n                )?;\n                return Ok(());\n            }\n            Some(format) if format.split(',').any(|format| format == \"combined_json\") => {\n                anyhow::bail!(\"If using combined_json it must be the only output format requested\");\n            }\n            Some(_) | None => compiler_vyper::standard_output(\n                arguments.input_files,\n                &vyper,\n                !arguments.disable_vyper_optimizer,\n                optimizer_settings,\n                include_metadata_hash,\n                debug_config,\n            ),\n        }\n    }?;\n\n    match arguments.output_directory {\n        Some(output_directory) => {\n            std::fs::create_dir_all(output_directory.as_path())?;\n\n            build.write_to_directory(output_directory.as_path(), arguments.overwrite)?;\n        }\n        None => {\n            for (path, contract) in build.contracts.into_iter() {\n                eprintln!(\"Contract `{path}`:\");\n                let bytecode_string = hex::encode(contract.build.bytecode);\n                println!(\"0x{bytecode_string}\");\n\n                if let Some(format) = arguments.format.as_deref() {\n                    let extra_output = vyper.extra_output(PathBuf::from(path).as_path(), format)?;\n                    println!();\n                    println!(\"{extra_output}\");\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n"], "fixing_code": ["# The `zkvyper` changelog\n\n## [1.3.10] - 2023-09-13\n\n### Fixed\n\n- An issue with uninitialized immutable values\n\n## [1.3.9] - 2023-07-03\n\n### Fixed\n\n- An issue with non-determinism in contract metadata hash\n\n## [1.3.8] - 2023-06-29\n\n### Changed\n\n- Each contract is now compiled in a separate process\n\n### Fixed\n\n- The CLI argument validation to rule out incompatible options\n\n## [1.3.7] - 2023-05-29\n\n### Added\n\n- The zkEVM assembly compilation mode (`--zkasm`)\n- The vyper v0.3.9 support\n\n### Fixed\n\n- The evaluation order of EVM instruction arguments in LLL IR\n\n## [1.3.6] - 2023-04-18\n\n### Added\n\n- The `CODESIZE` support in runtime code\n- An option not to include the metadata hash at the end of bytecode\n\n### Changed\n\n- Calldata instructions now return 0 in deploy code\n\n### Fixed\n\n- The LLVM crash with memory offsets `>= 2^64`\n- The LLVM crash with ternary operator on fat memory pointers\n\n## [1.3.5] - 2023-04-04\n\n### Added\n\n- An option to disable the `vyper` optimizer\n\n### Changed\n\n- Increased the stack size for `rayon` workers to 16 MB\n- Improved the CLI interface description (see `--help`)\n\n## [1.3.4] - 2023-03-15\n\n### Added\n\n- LLVM options for debugging and verification\n\n## [1.3.3] - 2023-03-09\n\n### Added\n\n- The contract metadata hash to the end of bytecode\n- More optimizations\n\n### Changed\n\n- The optimizer settings to support multiple modes\n- The optimizer now optimizes for performance instead of size by default\n\n## [1.3.2] - 2023-02-14\n\n### Added\n\n- The LLVM build commit ID to the `--version` output\n- More LLVM optimizations\n\n### Removed\n\n- The `long_version` field from the combined JSON output\n\n### Fixed\n\n- Calls now only copy `min(output_size, return_data_size)` of the return data\n\n## [1.3.1] - 2023-02-06\n\n### Changed\n\n- Some ABI data layout parameters\n\n## [1.3.0] - 2023-02-02\n\n### Added\n\n- The LLVM IR compilation mode (`--llvm-ir`)\n\n### Changed\n\n- System contract calls now use remaining ergs instead of 0\n- The LLVM optimization manager to the new one\n- The contract ABI to match that of zkEVM v1.3\n- Moved the event decoding to the system contracts\n- Simplified the CLI arguments used for debugging\n\n### Removed\n\n- The `extcodesize` check at the beginning of runtime code\n\n### Fixed\n\n- The non-zero initial return data size value\n- `msg.value >= 2^128` now set the call status code to zero\n- `BALANCE` now returns 0 if `address >= 2^160`\n- `KECCAK256` now returns an empty error in case of revert\n- `SIGNEXTEND` now returns the original value if `bytes >= 31`\n- `CODESIZE` is forbidden in Yul runtime code\n- `RETURNDATACOPY` now reverts on attempt to copy from beyond the return data\n- `RETURN` and `REVERT` offsets and lengths are now clamped to `2^32 - 1`\n- Only block hashes of the last 256 blocks are now accessible\n- `ptr.pack` is not optimized out by LLVM anymore\n\n## [1.2.2] - 2022-12-16\n\n### Added\n\n- More LLVM optimizations\n\n### Changed\n\n- Updated LLVM to v15.0.4\n\n### Fixed\n\n- The crash with some uncovered LLVM IR nodes\n- The missing check for `msg.value` > `2^128 - 1`\n\n## [1.2.1] - 2022-12-01\n\n### Added\n\n- The option to dump IRs to files\n- More contract size optimizations\n- The Windows platform support\n\n### Changed\n\n- The `CODECOPY` instruction now produces a compile-time error in the runtime code\n- The `CALLCODE` instruction now emits a compile-time error\n\n### Fixed\n\n- The `BYTE` instruction overflow\n- The forwarder constructor unhandled error\n\n## [1.2.0] - 2022-10-10\n\n### Added\n\n- Many improvements for the memory security and EVM-compatibility\n- Optimizations for the heap allocation\n- Support for optimizations for the calldata and returndata forwarding\n- More LLVM optimizations\n\n### Changed\n\n- System contract calls now require a system call flag\n- The handling of `msg.value` is made more robust\n- Failed system contract calls now do bubble-up the reverts\n\n## [1.1.4] - 2022-09-02\n\n### Added\n\n- The compiler versions to the output JSON\n\n### Changed\n\n- Unsupported instructions `PC`, `EXTCODECOPY`, `SELFDESTRUCT` now produce compile-time errors\n\n### Fixed\n\n- Bloating the array of immutables with zero values\n\n## [1.1.3] - 2022-08-16\n\n### Added\n\n- Support for the `BASEFEE` instruction\n\n## [1.1.2] - 2022-08-08\n\n### Added\n\n- Better compatibility of opcodes `GASLIMIT`, `GASPRICE`, `CHAINID`, `DIFFICULTY`, `COINBASE` etc.\n\n## [1.1.1] - 2022-07-28\n\n### Added\n\n- Support for the *SELECT* instruction, used by min/max built-ins\n\n## [1.1.0] - 2022-07-16\n\n### Added\n\n- The initial release\n", "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"aho-corasick\"\nversion = \"1.0.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0c378d78423fdad8089616f827526ee33c19f2fddbd5de1629152c9593ba4783\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"anyhow\"\nversion = \"1.0.75\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a4668cab20f66d8d020e1fbc0ebe47217433c1b6c8f2040faf858554e394ace6\"\n\n[[package]]\nname = \"arrayvec\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711\"\n\n[[package]]\nname = \"atty\"\nversion = \"0.2.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\ndependencies = [\n \"hermit-abi 0.1.19\",\n \"libc\",\n \"winapi\",\n]\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"base16ct\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"349a06037c7bf932dd7e7d1f653678b2038b9ad46a74102f1fc7bd7872678cce\"\n\n[[package]]\nname = \"base64ct\"\nversion = \"1.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"2.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b4682ae6287fcf752ecaabbfcc7b6f9b72aa33933dc23a554d853aea8eea8635\"\n\n[[package]]\nname = \"bitvec\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c\"\ndependencies = [\n \"funty\",\n \"radium\",\n \"tap\",\n \"wyz\",\n]\n\n[[package]]\nname = \"blake2\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"46502ad458c9a52b69d4d4d32775c788b7a1b85e8bc9d482d92250fc0e3f8efe\"\ndependencies = [\n \"digest\",\n]\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"byte-slice-cast\"\nversion = \"1.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c3ac9f8b63eca6fd385229b3675f6cc0dc5c8a5c8a54a59d4f52ffd670d87b0c\"\n\n[[package]]\nname = \"byteorder\"\nversion = \"1.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n\n[[package]]\nname = \"bytes\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2bd12c1caf447e69cd4528f47f94d203fd2582878ecb9e9465484c4148a8223\"\n\n[[package]]\nname = \"cc\"\nversion = \"1.0.83\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f1174fb0b6ec23863f8b971027804a42614e347eafb0a95bf0b12cdae21fc4d0\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"clap\"\nversion = \"2.34.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a0610544180c38b88101fecf2dd634b174a62eef6946f84dfc6a7127512b381c\"\ndependencies = [\n \"bitflags 1.3.2\",\n \"textwrap\",\n \"unicode-width\",\n]\n\n[[package]]\nname = \"colored\"\nversion = \"2.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2674ec482fbc38012cf31e6c42ba0177b431a0cb6f15fe40efa5aab1bda516f6\"\ndependencies = [\n \"is-terminal\",\n \"lazy_static\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"compiler-common\"\nversion = \"1.3.3\"\nsource = \"git+https://github.com/matter-labs/era-compiler-common?branch=main#aac58a37982885dd09f7d4fa838c16a96ef23683\"\n\n[[package]]\nname = \"compiler-llvm-context\"\nversion = \"1.3.2\"\nsource = \"git+https://github.com/matter-labs/era-compiler-llvm-context?branch=main#419bd6067c1e1f0bc64acb7cb5307d8398dfbe2a\"\ndependencies = [\n \"anyhow\",\n \"compiler-common\",\n \"hex\",\n \"inkwell\",\n \"itertools\",\n \"md5\",\n \"num\",\n \"once_cell\",\n \"regex\",\n \"semver\",\n \"serde\",\n \"sha2\",\n \"sha3\",\n \"zkevm-assembly\",\n \"zkevm_opcode_defs\",\n]\n\n[[package]]\nname = \"compiler-vyper\"\nversion = \"1.3.10\"\ndependencies = [\n \"anyhow\",\n \"colored\",\n \"compiler-common\",\n \"compiler-llvm-context\",\n \"hex\",\n \"inkwell\",\n \"lazy_static\",\n \"mimalloc\",\n \"once_cell\",\n \"rayon\",\n \"semver\",\n \"serde\",\n \"serde_json\",\n \"serde_stacker\",\n \"sha3\",\n \"structopt\",\n \"which\",\n \"zkevm-assembly\",\n \"zkevm_opcode_defs\",\n]\n\n[[package]]\nname = \"const-oid\"\nversion = \"0.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"28c122c3980598d243d63d9a704629a2d748d101f278052ff068be5a4423ab6f\"\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a17b76ff3a4162b0b27f354a0c87015ddad39d35f9c0c36607a3bdd175dde1f1\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"crossbeam-channel\"\nversion = \"0.5.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a33c2bf77f2df06183c3aa30d1e96c0695a313d4f9c453cc3762a6db39f99200\"\ndependencies = [\n \"cfg-if\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-deque\"\nversion = \"0.8.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ce6fd6f855243022dcecf8702fef0c297d4338e226845fe067f6341ad9fa0cef\"\ndependencies = [\n \"cfg-if\",\n \"crossbeam-epoch\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-epoch\"\nversion = \"0.9.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ae211234986c545741a7dc064309f67ee1e5ad243d0e48335adc0484d960bcc7\"\ndependencies = [\n \"autocfg\",\n \"cfg-if\",\n \"crossbeam-utils\",\n \"memoffset\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"crossbeam-utils\"\nversion = \"0.8.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5a22b2d63d4d1dc0b7f1b6b2747dd0088008a9be28b6ddf0b1e7d335e3037294\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"crunchy\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7\"\n\n[[package]]\nname = \"crypto-bigint\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ef2b4b23cddf68b89b8f8069890e8c270d54e2d5fe1b143820234805e4cb17ef\"\ndependencies = [\n \"generic-array\",\n \"rand_core\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"typenum\",\n]\n\n[[package]]\nname = \"der\"\nversion = \"0.6.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f1a467a65c5e759bce6e65eaf91cc29f466cdc57cb65777bd646872a8a1fd4de\"\ndependencies = [\n \"const-oid\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n \"subtle\",\n]\n\n[[package]]\nname = \"ecdsa\"\nversion = \"0.14.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"413301934810f597c1d19ca71c8710e99a3f1ba28a0d2ebc01551a2daeea3c5c\"\ndependencies = [\n \"der\",\n \"elliptic-curve\",\n \"rfc6979\",\n \"signature\",\n]\n\n[[package]]\nname = \"either\"\nversion = \"1.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07\"\n\n[[package]]\nname = \"elliptic-curve\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e7bb888ab5300a19b8e5bceef25ac745ad065f3c9f7efc6de1b91958110891d3\"\ndependencies = [\n \"base16ct\",\n \"crypto-bigint\",\n \"der\",\n \"digest\",\n \"ff\",\n \"generic-array\",\n \"group\",\n \"pkcs8\",\n \"rand_core\",\n \"sec1\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"env_logger\"\nversion = \"0.9.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a12e6657c4c97ebab115a42dcee77225f7f482cdd841cf7088c657a42e9e00e7\"\ndependencies = [\n \"atty\",\n \"humantime\",\n \"log\",\n \"regex\",\n \"termcolor\",\n]\n\n[[package]]\nname = \"equivalent\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5\"\n\n[[package]]\nname = \"errno\"\nversion = \"0.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"136526188508e25c6fef639d7927dfb3e0e3084488bf202267829cf7fc23dbdd\"\ndependencies = [\n \"errno-dragonfly\",\n \"libc\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"errno-dragonfly\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf\"\ndependencies = [\n \"cc\",\n \"libc\",\n]\n\n[[package]]\nname = \"ethbloom\"\nversion = \"0.13.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c22d4b5885b6aa2fe5e8b9329fb8d232bf739e434e6b87347c63bdd00c120f60\"\ndependencies = [\n \"crunchy\",\n \"fixed-hash\",\n \"impl-rlp\",\n \"impl-serde\",\n \"tiny-keccak\",\n]\n\n[[package]]\nname = \"ethereum-types\"\nversion = \"0.14.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"02d215cbf040552efcbe99a38372fe80ab9d00268e20012b79fcd0f073edd8ee\"\ndependencies = [\n \"ethbloom\",\n \"fixed-hash\",\n \"impl-rlp\",\n \"impl-serde\",\n \"primitive-types\",\n \"uint\",\n]\n\n[[package]]\nname = \"ff\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d013fc25338cc558c5c2cfbad646908fb23591e2404481826742b651c9af7160\"\ndependencies = [\n \"rand_core\",\n \"subtle\",\n]\n\n[[package]]\nname = \"fixed-hash\"\nversion = \"0.8.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"835c052cb0c08c1acf6ffd71c022172e18723949c8282f2b9f27efbc51e64534\"\ndependencies = [\n \"byteorder\",\n \"rand\",\n \"rustc-hex\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"funty\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c\"\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"getrandom\"\nversion = \"0.2.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"wasi\",\n]\n\n[[package]]\nname = \"group\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5dfbfb3a6cfbd390d5c9564ab283a0349b9b9fcd46a706c1eb10e0db70bfbac7\"\ndependencies = [\n \"ff\",\n \"rand_core\",\n \"subtle\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.14.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2c6201b9ff9fd90a5a3bac2e56a830d0caa509576f0e503818ee82c181b3437a\"\n\n[[package]]\nname = \"heck\"\nversion = \"0.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c\"\ndependencies = [\n \"unicode-segmentation\",\n]\n\n[[package]]\nname = \"hermit-abi\"\nversion = \"0.1.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"hermit-abi\"\nversion = \"0.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"443144c8cdadd93ebf52ddb4056d257f5b52c04d3c804e657d19eb73fc33668b\"\n\n[[package]]\nname = \"hex\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70\"\n\n[[package]]\nname = \"hmac\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e\"\ndependencies = [\n \"digest\",\n]\n\n[[package]]\nname = \"home\"\nversion = \"0.5.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5444c27eef6923071f7ebcc33e3444508466a76f7a2b93da00ed6e19f30c1ddb\"\ndependencies = [\n \"windows-sys\",\n]\n\n[[package]]\nname = \"humantime\"\nversion = \"2.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n\n[[package]]\nname = \"impl-codec\"\nversion = \"0.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ba6a270039626615617f3f36d15fc827041df3b78c439da2cadfa47455a77f2f\"\ndependencies = [\n \"parity-scale-codec\",\n]\n\n[[package]]\nname = \"impl-rlp\"\nversion = \"0.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f28220f89297a075ddc7245cd538076ee98b01f2a9c23a53a4f1105d5a322808\"\ndependencies = [\n \"rlp\",\n]\n\n[[package]]\nname = \"impl-serde\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ebc88fc67028ae3db0c853baa36269d398d5f45b6982f95549ff5def78c935cd\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"impl-trait-for-tuples\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11d7a9f6330b71fea57921c9b61c47ee6e84f72d394754eff6163ae67e7395eb\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d5477fe2230a79769d8dc68e0eabf5437907c0457a5614a9e8dddb67f65eb65d\"\ndependencies = [\n \"equivalent\",\n \"hashbrown\",\n]\n\n[[package]]\nname = \"inkwell\"\nversion = \"0.1.0\"\nsource = \"git+https://github.com/matter-labs-forks/inkwell?branch=llvm-15#b8578870c7357e529bf28c3b03dd3e05dd645d1d\"\ndependencies = [\n \"either\",\n \"inkwell_internals\",\n \"libc\",\n \"llvm-sys\",\n \"once_cell\",\n \"parking_lot\",\n \"serde\",\n]\n\n[[package]]\nname = \"inkwell_internals\"\nversion = \"0.6.0\"\nsource = \"git+https://github.com/matter-labs-forks/inkwell?branch=llvm-15#b8578870c7357e529bf28c3b03dd3e05dd645d1d\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"is-terminal\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cb0889898416213fab133e1d33a0e5858a48177452750691bde3666d0fdbaf8b\"\ndependencies = [\n \"hermit-abi 0.3.2\",\n \"rustix\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"itertools\"\nversion = \"0.10.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473\"\ndependencies = [\n \"either\",\n]\n\n[[package]]\nname = \"itoa\"\nversion = \"1.0.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"af150ab688ff2122fcef229be89cb50dd66af9e01a4ff320cc137eecc9bacc38\"\n\n[[package]]\nname = \"k256\"\nversion = \"0.11.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72c1e0b51e7ec0a97369623508396067a486bd0cbed95a2659a4b863d28cfc8b\"\ndependencies = [\n \"cfg-if\",\n \"ecdsa\",\n \"elliptic-curve\",\n \"sha2\",\n]\n\n[[package]]\nname = \"keccak\"\nversion = \"0.1.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8f6d5ed8676d904364de097082f4e7d240b571b67989ced0240f08b7f966f940\"\ndependencies = [\n \"cpufeatures\",\n]\n\n[[package]]\nname = \"lazy_static\"\nversion = \"1.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.148\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9cdc71e17332e86d2e1d38c1f99edcb6288ee11b815fb1a4b049eaa2114d369b\"\n\n[[package]]\nname = \"libmimalloc-sys\"\nversion = \"0.1.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3979b5c37ece694f1f5e51e7ecc871fdb0f517ed04ee45f88d15d6d553cb9664\"\ndependencies = [\n \"cc\",\n \"libc\",\n]\n\n[[package]]\nname = \"linux-raw-sys\"\nversion = \"0.4.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1a9bad9f94746442c783ca431b22403b519cd7fbeed0533fdd6328b2f2212128\"\n\n[[package]]\nname = \"llvm-sys\"\nversion = \"150.0.5\"\nsource = \"git+https://github.com/matter-labs-forks/llvm-sys.rs?branch=llvm-15.0#71d3d59ea8f5974b9ffc3a6631676e0fa2825a27\"\ndependencies = [\n \"cc\",\n \"lazy_static\",\n \"libc\",\n \"regex\",\n \"semver\",\n]\n\n[[package]]\nname = \"lock_api\"\nversion = \"0.4.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c1cc9717a20b1bb222f333e6a92fd32f7d8a18ddc5a3191a11af45dcbf4dcd16\"\ndependencies = [\n \"autocfg\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"log\"\nversion = \"0.4.20\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f\"\n\n[[package]]\nname = \"md5\"\nversion = \"0.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"490cc448043f947bae3cbee9c203358d62dbee0db12107a74be5c30ccfd09771\"\n\n[[package]]\nname = \"memchr\"\nversion = \"2.6.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8f232d6ef707e1956a43342693d2a31e72989554d58299d7a88738cc95b0d35c\"\n\n[[package]]\nname = \"memoffset\"\nversion = \"0.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5a634b1c61a95585bd15607c6ab0c4e5b226e695ff2800ba0cdccddf208c406c\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"mimalloc\"\nversion = \"0.1.39\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fa01922b5ea280a911e323e4d2fd24b7fe5cc4042e0d2cda3c40775cdc4bdc9c\"\ndependencies = [\n \"libmimalloc-sys\",\n]\n\n[[package]]\nname = \"minimal-lexical\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a\"\n\n[[package]]\nname = \"nom\"\nversion = \"7.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a\"\ndependencies = [\n \"memchr\",\n \"minimal-lexical\",\n]\n\n[[package]]\nname = \"num\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b05180d69e3da0e530ba2a1dae5110317e49e3b7f3d41be227dc5f92e49ee7af\"\ndependencies = [\n \"num-bigint\",\n \"num-complex\",\n \"num-integer\",\n \"num-iter\",\n \"num-rational\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-bigint\"\nversion = \"0.4.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"608e7659b5c3d7cba262d894801b9ec9d00de989e8a82bd4bef91d08da45cdc0\"\ndependencies = [\n \"autocfg\",\n \"num-integer\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-complex\"\nversion = \"0.4.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1ba157ca0885411de85d6ca030ba7e2a83a28636056c7c699b07c8b6f7383214\"\ndependencies = [\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-integer\"\nversion = \"0.1.45\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"225d3389fb3509a24c93f5c29eb6bde2586b98d9f016636dff58d7c6f7569cd9\"\ndependencies = [\n \"autocfg\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-iter\"\nversion = \"0.1.43\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7d03e6c028c5dc5cac6e2dec0efda81fc887605bb3d884578bb6d6bf7514e252\"\ndependencies = [\n \"autocfg\",\n \"num-integer\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-rational\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0638a1c9d0a3c0914158145bc76cff373a75a627e6ecbfb71cbe6f453a5a19b0\"\ndependencies = [\n \"autocfg\",\n \"num-bigint\",\n \"num-integer\",\n \"num-traits\",\n]\n\n[[package]]\nname = \"num-traits\"\nversion = \"0.2.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f30b0abd723be7e2ffca1272140fac1a2f084c77ec3e123c192b66af1ee9e6c2\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"num_cpus\"\nversion = \"1.16.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43\"\ndependencies = [\n \"hermit-abi 0.3.2\",\n \"libc\",\n]\n\n[[package]]\nname = \"once_cell\"\nversion = \"1.18.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d\"\n\n[[package]]\nname = \"parity-scale-codec\"\nversion = \"3.6.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0dec8a8073036902368c2cdc0387e85ff9a37054d7e7c98e592145e0c92cd4fb\"\ndependencies = [\n \"arrayvec\",\n \"bitvec\",\n \"byte-slice-cast\",\n \"impl-trait-for-tuples\",\n \"parity-scale-codec-derive\",\n \"serde\",\n]\n\n[[package]]\nname = \"parity-scale-codec-derive\"\nversion = \"3.6.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"312270ee71e1cd70289dacf597cab7b207aa107d2f28191c2ae45b2ece18a260\"\ndependencies = [\n \"proc-macro-crate\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"parking_lot\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\ndependencies = [\n \"lock_api\",\n \"parking_lot_core\",\n]\n\n[[package]]\nname = \"parking_lot_core\"\nversion = \"0.9.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"93f00c865fe7cabf650081affecd3871070f26767e7b2070a3ffae14c654b447\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"redox_syscall\",\n \"smallvec\",\n \"windows-targets\",\n]\n\n[[package]]\nname = \"pkcs8\"\nversion = \"0.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9eca2c590a5f85da82668fa685c09ce2888b9430e83299debf1f34b65fd4a4ba\"\ndependencies = [\n \"der\",\n \"spki\",\n]\n\n[[package]]\nname = \"ppv-lite86\"\nversion = \"0.2.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de\"\n\n[[package]]\nname = \"primitive-types\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9f3486ccba82358b11a77516035647c34ba167dfa53312630de83b12bd4f3d66\"\ndependencies = [\n \"fixed-hash\",\n \"impl-codec\",\n \"impl-rlp\",\n \"impl-serde\",\n \"uint\",\n]\n\n[[package]]\nname = \"proc-macro-crate\"\nversion = \"1.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919\"\ndependencies = [\n \"once_cell\",\n \"toml_edit\",\n]\n\n[[package]]\nname = \"proc-macro-error\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c\"\ndependencies = [\n \"proc-macro-error-attr\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n \"version_check\",\n]\n\n[[package]]\nname = \"proc-macro-error-attr\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"version_check\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.67\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3d433d9f1a3e8c1263d9456598b16fec66f4acc9a74dacffd35c7bb09b3a1328\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"psm\"\nversion = \"0.1.21\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5787f7cda34e3033a72192c018bc5883100330f362ef279a8cbccfce8bb4e874\"\ndependencies = [\n \"cc\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.33\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5267fca4496028628a95160fc423a33e8b2e6af8a5302579e322e4b520293cae\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"radium\"\nversion = \"0.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09\"\n\n[[package]]\nname = \"rand\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\ndependencies = [\n \"libc\",\n \"rand_chacha\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_chacha\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\ndependencies = [\n \"ppv-lite86\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_core\"\nversion = \"0.6.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\ndependencies = [\n \"getrandom\",\n]\n\n[[package]]\nname = \"rayon\"\nversion = \"1.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1d2df5196e37bcc87abebc0053e20787d73847bb33134a69841207dd0a47f03b\"\ndependencies = [\n \"either\",\n \"rayon-core\",\n]\n\n[[package]]\nname = \"rayon-core\"\nversion = \"1.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4b8f95bd6966f5c87776639160a66bd8ab9895d9d4ab01ddba9fc60661aebe8d\"\ndependencies = [\n \"crossbeam-channel\",\n \"crossbeam-deque\",\n \"crossbeam-utils\",\n \"num_cpus\",\n]\n\n[[package]]\nname = \"redox_syscall\"\nversion = \"0.3.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29\"\ndependencies = [\n \"bitflags 1.3.2\",\n]\n\n[[package]]\nname = \"regex\"\nversion = \"1.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"697061221ea1b4a94a624f67d0ae2bfe4e22b8a17b6a192afb11046542cc8c47\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-automata\",\n \"regex-syntax\",\n]\n\n[[package]]\nname = \"regex-automata\"\nversion = \"0.3.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c2f401f4955220693b56f8ec66ee9c78abffd8d1c4f23dc41a23839eb88f0795\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-syntax\",\n]\n\n[[package]]\nname = \"regex-syntax\"\nversion = \"0.7.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dbb5fb1acd8a1a18b3dd5be62d25485eb770e05afb408a9627d14d451bae12da\"\n\n[[package]]\nname = \"rfc6979\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7743f17af12fa0b03b803ba12cd6a8d9483a587e89c69445e3909655c0b9fabb\"\ndependencies = [\n \"crypto-bigint\",\n \"hmac\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"rlp\"\nversion = \"0.5.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bb919243f34364b6bd2fc10ef797edbfa75f33c252e7998527479c6d6b47e1ec\"\ndependencies = [\n \"bytes\",\n \"rustc-hex\",\n]\n\n[[package]]\nname = \"rustc-hex\"\nversion = \"2.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3e75f6a532d0fd9f7f13144f392b6ad56a32696bfcd9c78f797f16bbb6f072d6\"\n\n[[package]]\nname = \"rustix\"\nversion = \"0.38.13\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d7db8590df6dfcd144d22afd1b83b36c21a18d7cbc1dc4bb5295a8712e9eb662\"\ndependencies = [\n \"bitflags 2.4.0\",\n \"errno\",\n \"libc\",\n \"linux-raw-sys\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"ryu\"\nversion = \"1.0.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1ad4cc8da4ef723ed60bced201181d83791ad433213d8c24efffda1eec85d741\"\n\n[[package]]\nname = \"scopeguard\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49\"\n\n[[package]]\nname = \"sec1\"\nversion = \"0.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3be24c1842290c45df0a7bf069e0c268a747ad05a192f2fd7dcfdbc1cba40928\"\ndependencies = [\n \"base16ct\",\n \"der\",\n \"generic-array\",\n \"pkcs8\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"semver\"\nversion = \"1.0.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0293b4b29daaf487284529cc2f5675b8e57c61f70167ba415a463651fd6a918\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.188\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cf9e0fcba69a370eed61bcf2b728575f726b50b55cba78064753d708ddc7549e\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.188\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4eca7ac642d82aa35b60049a6eccb4be6be75e599bd2e9adb5f875a737654af2\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.33\",\n]\n\n[[package]]\nname = \"serde_json\"\nversion = \"1.0.107\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6b420ce6e3d8bd882e9b243c6eed35dbc9a6110c9769e74b584e0d68d1f20c65\"\ndependencies = [\n \"itoa\",\n \"ryu\",\n \"serde\",\n]\n\n[[package]]\nname = \"serde_stacker\"\nversion = \"0.1.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f5321e680f77e7b5cfccc78708ff86a814d39aba030610aee67bd5eaf8a1c30\"\ndependencies = [\n \"serde\",\n \"stacker\",\n]\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"82e6b795fe2e3b1e845bafcb27aa35405c4d47cdfc92af5fc8d3002f76cebdc0\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"sha3\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bdf0c33fae925bdc080598b84bc15c55e7b9a4a43b3c704da051f977469691c9\"\ndependencies = [\n \"digest\",\n \"keccak\",\n]\n\n[[package]]\nname = \"signature\"\nversion = \"1.6.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"74233d3b3b2f6d4b006dc19dee745e73e2a6bfb6f93607cd3b02bd5b00797d7c\"\ndependencies = [\n \"digest\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"smallvec\"\nversion = \"1.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"62bb4feee49fdd9f707ef802e22365a35de4b7b299de4763d44bfea899442ff9\"\n\n[[package]]\nname = \"spki\"\nversion = \"0.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"67cf02bbac7a337dc36e4f5a693db6c21e7863f45070f7064577eb4367a3212b\"\ndependencies = [\n \"base64ct\",\n \"der\",\n]\n\n[[package]]\nname = \"stacker\"\nversion = \"0.1.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c886bd4480155fd3ef527d45e9ac8dd7118a898a46530b7b94c3e21866259fce\"\ndependencies = [\n \"cc\",\n \"cfg-if\",\n \"libc\",\n \"psm\",\n \"winapi\",\n]\n\n[[package]]\nname = \"static_assertions\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n\n[[package]]\nname = \"structopt\"\nversion = \"0.3.26\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0c6b5c64445ba8094a6ab0c3cd2ad323e07171012d9c98b0b15651daf1787a10\"\ndependencies = [\n \"clap\",\n \"lazy_static\",\n \"structopt-derive\",\n]\n\n[[package]]\nname = \"structopt-derive\"\nversion = \"0.4.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dcb5ae327f9cc13b68763b5749770cb9e048a99bd9dfdfa58d0cf05d5f64afe0\"\ndependencies = [\n \"heck\",\n \"proc-macro-error\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"subtle\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"81cdd64d312baedb58e21336b31bc043b77e01cc99033ce76ef539f78e965ebc\"\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.109\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.33\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9caece70c63bfba29ec2fed841a09851b14a235c60010fa4de58089b6c025668\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"tap\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n\n[[package]]\nname = \"termcolor\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6\"\ndependencies = [\n \"winapi-util\",\n]\n\n[[package]]\nname = \"textwrap\"\nversion = \"0.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\ndependencies = [\n \"unicode-width\",\n]\n\n[[package]]\nname = \"thiserror\"\nversion = \"1.0.48\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9d6d7a740b8a666a7e828dd00da9c0dc290dff53154ea77ac109281de90589b7\"\ndependencies = [\n \"thiserror-impl\",\n]\n\n[[package]]\nname = \"thiserror-impl\"\nversion = \"1.0.48\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"49922ecae66cc8a249b77e68d1d0623c1b2c514f0060c27cdc68bd62a1219d35\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.33\",\n]\n\n[[package]]\nname = \"tiny-keccak\"\nversion = \"2.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237\"\ndependencies = [\n \"crunchy\",\n]\n\n[[package]]\nname = \"toml_datetime\"\nversion = \"0.6.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7cda73e2f1397b1262d6dfdcef8aafae14d1de7748d66822d3bfeeb6d03e5e4b\"\n\n[[package]]\nname = \"toml_edit\"\nversion = \"0.19.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421\"\ndependencies = [\n \"indexmap\",\n \"toml_datetime\",\n \"winnow\",\n]\n\n[[package]]\nname = \"typenum\"\nversion = \"1.16.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba\"\n\n[[package]]\nname = \"uint\"\nversion = \"0.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52\"\ndependencies = [\n \"byteorder\",\n \"crunchy\",\n \"hex\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b\"\n\n[[package]]\nname = \"unicode-segmentation\"\nversion = \"1.10.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1dd624098567895118886609431a7c3b8f516e41d30e0643f03d94592a147e36\"\n\n[[package]]\nname = \"unicode-width\"\nversion = \"0.1.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b\"\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n\n[[package]]\nname = \"which\"\nversion = \"4.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7\"\ndependencies = [\n \"either\",\n \"home\",\n \"once_cell\",\n \"rustix\",\n]\n\n[[package]]\nname = \"winapi\"\nversion = \"0.3.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\ndependencies = [\n \"winapi-i686-pc-windows-gnu\",\n \"winapi-x86_64-pc-windows-gnu\",\n]\n\n[[package]]\nname = \"winapi-i686-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n\n[[package]]\nname = \"winapi-util\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178\"\ndependencies = [\n \"winapi\",\n]\n\n[[package]]\nname = \"winapi-x86_64-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n\n[[package]]\nname = \"windows-sys\"\nversion = \"0.48.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9\"\ndependencies = [\n \"windows-targets\",\n]\n\n[[package]]\nname = \"windows-targets\"\nversion = \"0.48.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c\"\ndependencies = [\n \"windows_aarch64_gnullvm\",\n \"windows_aarch64_msvc\",\n \"windows_i686_gnu\",\n \"windows_i686_msvc\",\n \"windows_x86_64_gnu\",\n \"windows_x86_64_gnullvm\",\n \"windows_x86_64_msvc\",\n]\n\n[[package]]\nname = \"windows_aarch64_gnullvm\"\nversion = \"0.48.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8\"\n\n[[package]]\nname = \"windows_aarch64_msvc\"\nversion = \"0.48.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc\"\n\n[[package]]\nname = \"windows_i686_gnu\"\nversion = \"0.48.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e\"\n\n[[package]]\nname = \"windows_i686_msvc\"\nversion = \"0.48.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406\"\n\n[[package]]\nname = \"windows_x86_64_gnu\"\nversion = \"0.48.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e\"\n\n[[package]]\nname = \"windows_x86_64_gnullvm\"\nversion = \"0.48.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc\"\n\n[[package]]\nname = \"windows_x86_64_msvc\"\nversion = \"0.48.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538\"\n\n[[package]]\nname = \"winnow\"\nversion = \"0.5.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7c2e3184b9c4e92ad5167ca73039d0c42476302ab603e2fec4487511f38ccefc\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"wyz\"\nversion = \"0.5.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed\"\ndependencies = [\n \"tap\",\n]\n\n[[package]]\nname = \"zeroize\"\nversion = \"1.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2a0956f1ba7c7909bfb66c2e9e4124ab6f6482560f6628b5aaeba39207c9aad9\"\n\n[[package]]\nname = \"zkevm-assembly\"\nversion = \"1.3.2\"\nsource = \"git+https://github.com/matter-labs/era-zkEVM-assembly?branch=v1.3.2#edc364e59a2eea9c4b1d4ce79f15d0b7c6b55b98\"\ndependencies = [\n \"env_logger\",\n \"hex\",\n \"lazy_static\",\n \"log\",\n \"nom\",\n \"num-bigint\",\n \"num-traits\",\n \"sha3\",\n \"smallvec\",\n \"structopt\",\n \"thiserror\",\n \"zkevm_opcode_defs\",\n]\n\n[[package]]\nname = \"zkevm_opcode_defs\"\nversion = \"1.3.2\"\nsource = \"git+https://github.com/matter-labs/era-zkevm_opcode_defs?branch=v1.3.2#a40648727910621b46a1023d940befefb0469cba\"\ndependencies = [\n \"bitflags 2.4.0\",\n \"blake2\",\n \"ethereum-types\",\n \"k256\",\n \"lazy_static\",\n \"sha2\",\n \"sha3\",\n]\n", "[package]\nname = \"compiler-vyper\"\nversion = \"1.3.10\"\nauthors = [\n    \"Oleksandr Zarudnyi <a.zarudnyy@matterlabs.dev>\",\n]\nlicense = \"MIT OR Apache-2.0\"\nedition = \"2021\"\ndescription = \"The zkEVM Vyper compiler\"\n\n[[bin]]\nname = \"zkvyper\"\npath = \"src/zkvyper/main.rs\"\n\n[lib]\ndoctest = false\n\n[dependencies]\nstructopt = { version = \"0.3\", default-features = false }\ncolored = \"2.0\"\nanyhow = \"1.0\"\n\nrayon = \"1.7\"\n\nserde = { version = \"1.0\", \"features\" = [ \"derive\" ] }\nserde_json = { version = \"1.0\", features = [ \"arbitrary_precision\", \"unbounded_depth\" ] }\nserde_stacker = \"0.1\"\nlazy_static = \"1.4\"\nonce_cell = \"1.17\"\nhex = \"0.4\"\nsha3 = \"0.10\"\nwhich = \"4.4\"\nsemver = { version = \"1.0\", features = [ \"serde\" ] }\n\nzkevm_opcode_defs = { git = \"https://github.com/matter-labs/era-zkevm_opcode_defs\", branch = \"v1.3.2\" }\nzkevm-assembly = { git = \"https://github.com/matter-labs/era-zkEVM-assembly\", branch = \"v1.3.2\" }\n\ncompiler-common = { git = \"https://github.com/matter-labs/era-compiler-common\", branch = \"main\" }\ncompiler-llvm-context = { git = \"https://github.com/matter-labs/era-compiler-llvm-context\", branch = \"main\" }\n\n[dependencies.inkwell]\ngit = \"https://github.com/matter-labs-forks/inkwell\"\nbranch = \"llvm-15\"\ndefault-features = false\nfeatures = [\"llvm15-0\", \"no-libffi-linking\", \"target-syncvm\"]\n\n[target.'cfg(target_env = \"musl\")'.dependencies]\nmimalloc = { version = \"*\", default-features = false }\n", "# zkSync Era: Vyper Compiler\n\n[![Logo](eraLogo.svg)](https://zksync.io/)\n\nzkSync Era is a layer 2 rollup that uses zero-knowledge proofs to scale Ethereum without compromising on security\nor decentralization. As it\u2019s EVM-compatible (with Solidity/Vyper), 99% of Ethereum projects can redeploy without\nneeding to refactor or re-audit any code. zkSync Era also uses an LLVM-based compiler that will eventually enable\ndevelopers to write smart contracts in popular languages such as C++ and Rust.\n\nThis repository contains the compiler from Vyper to zkEVM bytecode.\n\n## System Requirements\n\nSupported platforms:\n- **Linux: x86_64**  \n   MUSL-based static builds do not depend on system libraries and run on any recent Linux distribution.  \n- **MacOS 11+: x86_64, arm64 (M1, M2)**\n- **Windows: x86_64**  \n   Only Windows 10 has been tested so far, but other versions should be OK as well.  \n\nWe recommend at least 4 GB of RAM available for the build process.\n\n## Building\n\n1. Install some tools system-wide:  \n   1.a. `apt install cmake ninja-build clang-13 lld-13 parallel` on a Debian-based Linux, with optional `musl-tools` if you need a `musl` build.  \n   1.b. `pacman -S cmake ninja clang lld parallel` on an Arch-based Linux.  \n   1.c. On MacOS, install the [HomeBrew](https://brew.sh) package manager (being careful to install it as the appropriate user), then `brew install cmake ninja coreutils parallel`. Install your choice of a recent LLVM/[Clang](https://clang.llvm.org) compiler, e.g. via [Xcode](https://developer.apple.com/xcode/), [Apple\u2019s Command Line Tools](https://developer.apple.com/library/archive/technotes/tn2339/_index.html), or your preferred package manager.  \n   1.d. Their equivalents with other package managers.  \n\n2. [Install Rust](https://www.rust-lang.org/tools/install)\n\n   Currently we are not pinned to any specific version of Rust, so just install the latest stable build for your platform.  \n   Also install the `musl` target if you are compiling on Linux in order to distribute the binary:  \n   `rustup target add x86_64-unknown-linux-musl`  \n\n3. Download [v0.3.3 or v0.3.9 of the Vyper compiler](https://github.com/vyperlang/vyper/releases).  \n   If it is not named exactly `vyper` in your `$PATH`, see the `--vyper` option below.  \n   \n4. Check out or clone the appropriate branch of this repository.  \n\n5. Go to the project root and run `git checkout <ref>` with the tag, branch, or commit you want to build.  \n\n6. Install the zkEVM LLVM framework builder:  \n   6.a. `cargo install compiler-llvm-builder` on MacOS, or Linux for personal use.  \n   6.b. `cargo install compiler-llvm-builder --target x86_64-unknown-linux-musl` on Linux for distribution.  \n\n   The builder is not the [zkEVM LLVM framework](https://github.com/matter-labs/compiler-llvm) itself; it is just a tool that clones our repository and runs the sequence of build commands.  \n   By default it is installed in `~/.cargo/bin/`, which is recommended to be added to your `$PATH`. Execute `zkevm-llvm --help` for more information.  \n   If you need a specific branch of zkEVM LLVM, change it in the `LLVM.lock` file at the root of this repository.  \n\n7. Run the builder to clone and build the zkEVM LLVM framework at this repository root:  \n   7.1. `zkevm-llvm clone`  \n   7.2. `zkevm-llvm build`  \n\n8. Build the Vyper compiler executable:  \n   8.a. `cargo build --release` on MacOS or Linux for personal use.  \n   8.b. `cargo build --release --target x86_64-unknown-linux-musl` on Linux for distribution.  \n\n9. If you need to move the built binary elsewhere, grab it from the build directory:  \n   9.a. On MacOS or Linux for the default target: `./target/release/zkvyper`  \n   9.b. On Linux, if you are building for the target `x86_64-unknown-linux-musl`: `./target/x86_64-unknown-linux-musl/release/zkvyper`  \n\n## Usage\n\nCheck `./target/*/zkvyper --help` for compiler usage.  \n\nA support version of the Vyper compiler must be available in `$PATH`, or its path must be passed explicitly with the `--vyper` option.\n\nSupported versions:\n- 0.3.3\n- 0.3.9\n\nFor big projects it is more convenient to use the compiler via the Hardhat plugin. For single-file contracts, or small\nprojects, the CLI suffices.\n\n## Unit testing\n\nFor running unit tests, `zkvyper` itself must also be available in `$PATH`, because it calls itself recursively to allow\ncompiling each contract in a separate process. To successfully run unit tests:\n\n1. Run `cargo build --release`.\n2. Move the binary from `./target/release/zkvyper` to a directory from `$PATH`, or add the target directory itself to `$PATH`.\n3. Run `cargo test`.\n\n## CLI reference\n\n#### `--version`\nPrint the version and exit.  \n\n#### `<input_files>`\nSpecify the input file paths.  \nMultiple Vyper files can be passed in the default Vyper mode.  \nLLVM IR mode currently supports only a single file.  \n\n#### `-o`, `--output-dir <path>`\nCreate one file per component and contract/file at the specified directory, if given.  \n\n#### `--overwrite`\nOverwrite existing files (used together with -o).  \n\n#### `-O`, `--optimization <level>`\nSet the LLVM optimization parameter `-O[0 | 1 | 2 | 3 | s | z]`.  \nUse `3` for best performance and `z` for minimal size.  \n\n#### `--disable-vyper-optimizer`\nDisable the `vyper` LLL IR optimizer.  \n\n#### `--vyper <path>`\nSpecify the path to the `vyper` executable. By default, the one in `${PATH}` is used.  \nIn LLVM IR mode `vyper` is unused.  \n\n#### `-f <format>`\nAn extra output format string.  \nSee `vyper --help` for available options including combined JSON mode.\n\n#### `--llvm-ir`\nSwitch to LLVM IR mode.  \nOnly one input LLVM IR file is allowed.  \nCannot be used with combined JSON mode.  \nUse this mode at your own risk, as LLVM IR input validation is not implemented.  \n\n#### `--zkasm`\nSwitch to zkEVM assembly mode.  \nOnly one input zkEVM assembly file is allowed.  \nCannot be used with combined JSON mode.  \nUse this mode at your own risk, as EraVM assembly input validation is not implemented.  \n\n#### `--metadata-hash`\nSet metadata hash mode: `keccak256` | `none`.\n`keccak256` is enabled by default.\n\n#### `--debug-output-dir <path>`\nDump all IR (LLL, LLVM IR, assembly) to files in the specified directory.  \nOnly for testing and debugging.  \n\n#### `--llvm-verify-each`\nSet the `verify-each` option in LLVM.\nOnly for testing and debugging.  \n\n#### `--llvm-debug-logging`\nSet the `debug-logging` option in LLVM.\nOnly for testing and debugging.  \n\n#### `--recursive-process`\nRun this process recursively and provide JSON input to compile a single contract.  \nOnly for usage from within the compiler.  \n\n## Troubleshooting\n\n- If you get a \u201cfailed to authenticate when downloading repository\u2026 if the git CLI succeeds then net.git-fetch-with-cli may help here\u201d error, then prepending the `cargo` command with `CARGO_NET_GIT_FETCH_WITH_CLI=true` may help.\n- On MacOS, `git config --global credential.helper osxkeychain` followed by cloning a repository manually with a personal access token may help.\n- Unset any LLVM-related environment variables you may have set, especially `LLVM_SYS_<version>_PREFIX` (see e.g. [https://crates.io/crates/llvm-sys](https://crates.io/crates/llvm-sys) and [https://llvm.org/docs/GettingStarted.html#local-llvm-configuration](https://llvm.org/docs/GettingStarted.html#local-llvm-configuration)). To make sure: `set | grep LLVM`\n\n## License\n\nThe Vyper compiler is distributed under the terms of either\n\n- Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)\n- MIT license ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)\n\nat your option.\n\n## Resources\n\n[zkSync Era compiler toolchain documentation](https://era.zksync.io/docs/api/compiler-toolchain)  \n\n[Vyper v0.3.3 documentation](https://vyper.readthedocs.io/en/v0.3.3/)  \n[Vyper v0.3.9 documentation](https://vyper.readthedocs.io/en/v0.3.9/)  \n\n[Vyper LLL IR](https://github.com/vyperlang/vyper/blob/master/vyper/ir/README.md)  \n\n> Some parts of the Vyper documentation may be outdated.  \n> Please contact the Vyper team for assistance.  \n\n## Official Links\n\n- [Website](https://zksync.io/)\n- [GitHub](https://github.com/matter-labs)\n- [Twitter](https://twitter.com/zksync)\n- [Twitter for Devs](https://twitter.com/zkSyncDevs)\n- [Discord](https://join.zksync.dev/)\n\n## Disclaimer\n\nzkSync Era has been through extensive testing and audits, and although it is live, it is still in alpha state and\nwill undergo further audits and bug bounty programs. We would love to hear our community's thoughts and suggestions\nabout it!\nIt's important to note that forking it now could potentially lead to missing important\nsecurity updates, critical features, and performance improvements.\n", "//!\n//! The Vyper contract build.\n//!\n\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::Path;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::vyper::combined_json::contract::Contract as CombinedJsonContract;\n\n///\n/// The Vyper contract build.\n///\n#[derive(Debug, Serialize, Deserialize)]\npub struct Contract {\n    /// The LLVM module build.\n    pub build: compiler_llvm_context::EraVMBuild,\n}\n\nimpl Contract {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(build: compiler_llvm_context::EraVMBuild) -> Self {\n        Self { build }\n    }\n\n    ///\n    /// Writes the contract text assembly and bytecode to files.\n    ///\n    pub fn write_to_directory(\n        self,\n        output_directory: &Path,\n        contract_path: &Path,\n        overwrite: bool,\n    ) -> anyhow::Result<()> {\n        let contract_name = Self::short_path(contract_path.to_str().expect(\"Always valid\"));\n\n        let assembly_file_name = format!(\n            \"{}.{}\",\n            contract_name,\n            compiler_common::EXTENSION_ERAVM_ASSEMBLY\n        );\n        let mut assembly_file_path = output_directory.to_owned();\n        assembly_file_path.push(assembly_file_name);\n\n        if assembly_file_path.exists() && !overwrite {\n            eprintln!(\n                \"Refusing to overwrite an existing file {assembly_file_path:?} (use --overwrite to force).\",\n            );\n        } else {\n            File::create(&assembly_file_path)\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} creating error: {}\", assembly_file_path, error)\n                })?\n                .write_all(self.build.assembly_text.as_bytes())\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} writing error: {}\", assembly_file_path, error)\n                })?;\n        }\n\n        let binary_file_name = format!(\n            \"{}.{}\",\n            contract_name,\n            compiler_common::EXTENSION_ERAVM_BINARY\n        );\n        let mut binary_file_path = output_directory.to_owned();\n        binary_file_path.push(binary_file_name);\n\n        if binary_file_path.exists() && !overwrite {\n            eprintln!(\n                \"Refusing to overwrite an existing file {binary_file_path:?} (use --overwrite to force).\",\n            );\n        } else {\n            File::create(&binary_file_path)\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} creating error: {}\", binary_file_path, error)\n                })?\n                .write_all(self.build.bytecode.as_slice())\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} writing error: {}\", binary_file_path, error)\n                })?;\n        }\n\n        Ok(())\n    }\n\n    ///\n    /// Writes the contract text assembly and bytecode to the combined JSON.\n    ///\n    pub fn write_to_combined_json(\n        self,\n        combined_json_contract: &mut CombinedJsonContract,\n    ) -> anyhow::Result<()> {\n        let hexadecimal_bytecode = hex::encode(self.build.bytecode);\n        match (\n            combined_json_contract.bytecode.as_mut(),\n            combined_json_contract.bytecode_runtime.as_mut(),\n        ) {\n            (Some(bytecode), Some(bytecode_runtime)) => {\n                *bytecode = hexadecimal_bytecode;\n                *bytecode_runtime = bytecode.clone();\n            }\n            (Some(bytecode), None) => {\n                *bytecode = hexadecimal_bytecode;\n            }\n            (None, Some(bytecode_runtime)) => {\n                *bytecode_runtime = hexadecimal_bytecode;\n            }\n            (None, None) => {}\n        }\n\n        combined_json_contract.factory_deps = Some(self.build.factory_dependencies);\n\n        Ok(())\n    }\n\n    ///\n    /// Converts the full path to a short one.\n    ///\n    pub fn short_path(path: &str) -> &str {\n        path.rfind('/')\n            .map(|last_slash| &path[last_slash + 1..])\n            .unwrap_or_else(|| path)\n    }\n}\n", "//!\n//! The LLVM IR contract.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::build::contract::Contract as ContractBuild;\nuse crate::project::contract::metadata::Metadata as ContractMetadata;\n\n///\n/// The LLVM IR contract.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Contract {\n    /// The LLVM framework version.\n    pub version: semver::Version,\n    /// The contract source code.\n    pub source_code: String,\n}\n\nimpl Contract {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(version: semver::Version, source_code: String) -> Self {\n        Self {\n            version,\n            source_code,\n        }\n    }\n\n    ///\n    /// Compiles the contract, returning the build.\n    ///\n    pub fn compile(\n        self,\n        contract_path: &str,\n        source_code_hash: Option<[u8; compiler_common::BYTE_LENGTH_FIELD]>,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<ContractBuild> {\n        let llvm = inkwell::context::Context::create();\n        let optimizer = compiler_llvm_context::Optimizer::new(optimizer_settings);\n\n        let metadata_hash = source_code_hash.map(|source_code_hash| {\n            ContractMetadata::new(\n                &source_code_hash,\n                &self.version,\n                semver::Version::parse(env!(\"CARGO_PKG_VERSION\")).expect(\"Always valid\"),\n                optimizer.settings().to_owned(),\n            )\n            .keccak256()\n        });\n\n        let memory_buffer = inkwell::memory_buffer::MemoryBuffer::create_from_memory_range_copy(\n            self.source_code.as_bytes(),\n            contract_path,\n        );\n        let module = llvm\n            .create_module_from_ir(memory_buffer)\n            .map_err(|error| anyhow::anyhow!(error.to_string()))?;\n        let context = compiler_llvm_context::EraVMContext::<\n            compiler_llvm_context::EraVMDummyDependency,\n        >::new(\n            &llvm,\n            module,\n            optimizer,\n            None,\n            metadata_hash.is_some(),\n            debug_config,\n        );\n\n        let build = context.build(contract_path, metadata_hash)?;\n\n        Ok(ContractBuild::new(build))\n    }\n}\n", "//!\n//! The `assert` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `assert` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Assert([Box<Expression>; 1]);\n\nimpl Assert {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let [condition] = self.0;\n\n        let error_block = context.append_basic_block(\"if_error\");\n        let join_block = context.append_basic_block(\"if_join\");\n\n        let condition = condition\n            .into_llvm_value(context)?\n            .expect(\"Always exists\")\n            .into_int_value();\n        let condition = context.builder().build_int_z_extend_or_bit_cast(\n            condition,\n            context.field_type(),\n            \"if_condition_extended\",\n        );\n        let condition = context.builder().build_int_compare(\n            inkwell::IntPredicate::NE,\n            condition,\n            context.field_const(0),\n            \"if_condition_compared\",\n        );\n        context.build_conditional_branch(condition, join_block, error_block);\n\n        context.set_basic_block(error_block);\n        context.build_exit(\n            context.intrinsics().revert,\n            context.field_const(0),\n            context.field_const(0),\n        );\n\n        context.set_basic_block(join_block);\n\n        Ok(())\n    }\n}\n", "//!\n//! The Vyper LLL-specific `clamp` instructions.\n//!\n\nuse inkwell::values::BasicValue;\n\n///\n/// Translates the two-sides bounded clamp.\n///\npub fn ordinary<'ctx, D>(\n    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    operand_1: inkwell::values::IntValue<'ctx>,\n    operand_2: inkwell::values::IntValue<'ctx>,\n    operand_3: inkwell::values::IntValue<'ctx>,\n    is_signed: bool,\n) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>\nwhere\n    D: compiler_llvm_context::EraVMDependency + Clone,\n{\n    let error_block = context.append_basic_block(\"if_error\");\n    let join_block = context.append_basic_block(\"if_join\");\n\n    let (predicate_one, predicate_two) = if is_signed {\n        (inkwell::IntPredicate::SLE, inkwell::IntPredicate::SGE)\n    } else {\n        (inkwell::IntPredicate::ULE, inkwell::IntPredicate::UGE)\n    };\n\n    let condition_one = context.builder().build_int_compare(\n        predicate_one,\n        operand_2,\n        operand_3,\n        \"clamp_condition_one\",\n    );\n    let condition_two = context.builder().build_int_compare(\n        predicate_two,\n        operand_3,\n        operand_1,\n        \"clamp_condition_two\",\n    );\n    let condition = context\n        .builder()\n        .build_and(condition_one, condition_two, \"clamp_condition\");\n    context.build_conditional_branch(condition, join_block, error_block);\n\n    context.set_basic_block(error_block);\n    context.build_exit(\n        context.intrinsics().revert,\n        context.field_const(0),\n        context.field_const(0),\n    );\n\n    context.set_basic_block(join_block);\n\n    Ok(operand_2.as_basic_value_enum())\n}\n\n///\n/// Translates the one-side bounded clamp with predicate.\n///\npub fn with_predicate<'ctx, D>(\n    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    operand_1: inkwell::values::IntValue<'ctx>,\n    operand_2: inkwell::values::IntValue<'ctx>,\n    predicate: inkwell::IntPredicate,\n) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>\nwhere\n    D: compiler_llvm_context::EraVMDependency + Clone,\n{\n    let error_block = context.append_basic_block(\"clamp_single_error\");\n    let join_block = context.append_basic_block(\"clamp_single_join\");\n\n    let condition = context.builder().build_int_compare(\n        predicate,\n        operand_1,\n        operand_2,\n        \"clamp_single_condition\",\n    );\n    context.build_conditional_branch(condition, join_block, error_block);\n\n    context.set_basic_block(error_block);\n    context.build_exit(\n        context.intrinsics().revert,\n        context.field_const(0),\n        context.field_const(0),\n    );\n\n    context.set_basic_block(join_block);\n\n    Ok(operand_1.as_basic_value_enum())\n}\n", "//!\n//! The `create` instruction adapter.\n//!\n\n///\n/// Translates the Vyper LLL `create` input layout into the one expected by zkEVM.\n///\n/// This function extracts the address from the calldata previously assembled in the LLL by the\n/// Vyper compiler. Then the address is written to the corresponding offset as the first argument\n/// of the forwarder's constructor.\n///\npub fn create<'ctx, D>(\n    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    value: inkwell::values::IntValue<'ctx>,\n    input_offset: inkwell::values::IntValue<'ctx>,\n    salt: Option<inkwell::values::IntValue<'ctx>>,\n) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>\nwhere\n    D: compiler_llvm_context::EraVMDependency + Clone,\n{\n    let success_block = context.append_basic_block(\"create_success_block\");\n    let failure_block = context.append_basic_block(\"create_failure_block\");\n    let join_block = context.append_basic_block(\"create_join_block\");\n\n    let address_offset = context.builder().build_int_add(\n        input_offset,\n        context.field_const(19),\n        \"create_address_offset\",\n    );\n    let address_dirty_pointer = compiler_llvm_context::EraVMPointer::new_with_offset(\n        context,\n        compiler_llvm_context::EraVMAddressSpace::Heap,\n        context.field_type(),\n        address_offset,\n        \"create_address_dirty_pointer\",\n    );\n    let address_dirty = context.build_load(address_dirty_pointer, \"create_address_dirty\");\n    let address = context.builder().build_right_shift(\n        address_dirty.into_int_value(),\n        context.field_const(\n            ((compiler_common::BYTE_LENGTH_FIELD - compiler_common::BYTE_LENGTH_ETH_ADDRESS)\n                * compiler_common::BIT_LENGTH_BYTE) as u64,\n        ),\n        false,\n        \"create_address\",\n    );\n\n    let calldata_offset =\n        context.field_const(compiler_llvm_context::eravm_const::HEAP_AUX_OFFSET_EXTERNAL_CALL);\n    let calldata_length = context.field_const(\n        (compiler_llvm_context::eravm_const::DEPLOYER_CALL_HEADER_SIZE\n            + compiler_common::BYTE_LENGTH_FIELD) as u64,\n    );\n\n    let hash_input_offset = context.builder().build_int_add(\n        calldata_offset,\n        context.field_const(\n            (compiler_common::BYTE_LENGTH_X32 + compiler_common::BYTE_LENGTH_FIELD) as u64,\n        ),\n        \"create_hash_input_offset\",\n    );\n    let hash_input_offset_pointer = compiler_llvm_context::EraVMPointer::new_with_offset(\n        context,\n        compiler_llvm_context::EraVMAddressSpace::HeapAuxiliary,\n        context.field_type(),\n        hash_input_offset,\n        \"create_hash_input_offset_pointer\",\n    );\n    let hash = context.compile_dependency(crate::r#const::FORWARDER_CONTRACT_NAME)?;\n    context.build_store(\n        hash_input_offset_pointer,\n        context.field_const_str_hex(hash.as_str()),\n    );\n\n    let address_input_offset = context.builder().build_int_add(\n        calldata_offset,\n        context.field_const(compiler_llvm_context::eravm_const::DEPLOYER_CALL_HEADER_SIZE as u64),\n        \"create_address_input_offset\",\n    );\n    let address_input_offset_pointer = compiler_llvm_context::EraVMPointer::new_with_offset(\n        context,\n        compiler_llvm_context::EraVMAddressSpace::HeapAuxiliary,\n        context.field_type(),\n        address_input_offset,\n        \"create_address_input_offset_pointer\",\n    );\n    context.build_store(address_input_offset_pointer, address);\n\n    let result_pointer = context.build_alloca(context.field_type(), \"create_result_pointer\");\n    context.build_store(result_pointer, context.field_const(0));\n    let address_or_status_code = match salt {\n        Some(salt) => compiler_llvm_context::eravm_evm_create::create2(\n            context,\n            value,\n            calldata_offset,\n            calldata_length,\n            Some(salt),\n        ),\n        None => compiler_llvm_context::eravm_evm_create::create(\n            context,\n            value,\n            calldata_offset,\n            calldata_length,\n        ),\n    }?;\n    let address_or_status_code_is_zero = context.builder().build_int_compare(\n        inkwell::IntPredicate::EQ,\n        address_or_status_code.into_int_value(),\n        context.field_const(0),\n        \"create_address_or_status_code_is_zero\",\n    );\n    context.build_conditional_branch(address_or_status_code_is_zero, failure_block, success_block);\n\n    context.set_basic_block(success_block);\n    context.build_store(result_pointer, address_or_status_code);\n    context.build_unconditional_branch(join_block);\n\n    context.set_basic_block(failure_block);\n    let return_data_size =\n        context.get_global(compiler_llvm_context::eravm_const::GLOBAL_RETURN_DATA_SIZE)?;\n    compiler_llvm_context::eravm_evm_return_data::copy(\n        context,\n        context.field_const(0),\n        context.field_const(0),\n        return_data_size.into_int_value(),\n    )?;\n    context.build_exit(\n        context.intrinsics().revert,\n        context.field_const(0),\n        return_data_size.into_int_value(),\n    );\n    context.build_unconditional_branch(join_block);\n\n    context.set_basic_block(join_block);\n    let result = context.build_load(result_pointer, \"create_result\");\n    Ok(result)\n}\n", "//!\n//! The `exit_to` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `exit_to` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ExitTo(Vec<Expression>);\n\nimpl ExitTo {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let label_name = self.0.remove(0).try_into_identifier()?;\n        if label_name.as_str() == crate::r#const::VARIABLE_IDENTIFIER_RETURN_PC {\n            context.build_unconditional_branch(context.current_function().borrow().return_block());\n            return Ok(());\n        }\n        let label_name = label_name\n            .strip_prefix(crate::r#const::LABEL_DESTINATION_PREFIX)\n            .unwrap_or(label_name.as_str());\n\n        let block = context\n            .current_function()\n            .borrow()\n            .declaration()\n            .value\n            .get_basic_blocks()\n            .iter()\n            .find(|block| block.get_name().to_string_lossy() == label_name)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Block `{}` does not exist\", label_name))?;\n\n        let argument_names = context\n            .current_function()\n            .borrow()\n            .vyper()\n            .label_arguments(label_name);\n        if let Some(argument_names) = argument_names {\n            for (name, expression) in argument_names.into_iter().zip(self.0) {\n                let pointer = context\n                    .current_function()\n                    .borrow()\n                    .get_stack_pointer(name.as_str())\n                    .ok_or_else(|| anyhow::anyhow!(\"Variable `{}` not found\", name))?;\n                let value = expression.into_llvm_value(context)?.expect(\"Always exists\");\n                context.build_store(pointer, value);\n            }\n        }\n\n        context.build_unconditional_branch(block);\n        Ok(())\n    }\n}\n", "//!\n//! The `goto` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `goto` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Goto(Vec<Expression>);\n\nimpl Goto {\n    ///\n    /// Return a `goto` to the specified block.\n    ///\n    pub fn new_to_block(name: &str) -> Self {\n        Self(vec![Expression::Identifier(name.to_string())])\n    }\n\n    ///\n    /// Generates the function call code.\n    ///\n    pub fn into_function_call<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n        label_name: String,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let function = context\n            .get_function(label_name.as_str())\n            .ok_or_else(|| anyhow::anyhow!(\"Function `{}` does not exist\", label_name))?;\n\n        let mut arguments = Vec::new();\n        for expression in self.0.into_iter() {\n            if let Expression::Identifier(ref identifier) = expression {\n                if identifier.starts_with(crate::r#const::LABEL_DESTINATION_PREFIX) {\n                    continue;\n                }\n            }\n            if let Some(value) = expression.into_llvm_value(context)? {\n                arguments.push(value);\n            }\n        }\n\n        context.build_call(\n            function.borrow().declaration(),\n            arguments.as_slice(),\n            label_name.as_str(),\n        );\n\n        Ok(None)\n    }\n\n    ///\n    /// Generates the block call code.\n    ///\n    pub fn into_block_call<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n        label_name: String,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let block = context\n            .current_function()\n            .borrow()\n            .declaration()\n            .value\n            .get_basic_blocks()\n            .iter()\n            .find(|block| block.get_name().to_string_lossy() == label_name)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Block `{}` does not exist\", label_name))?;\n\n        let argument_names = context\n            .current_function()\n            .borrow()\n            .vyper()\n            .label_arguments(label_name.as_str());\n        if let Some(argument_names) = argument_names {\n            for (name, expression) in argument_names.into_iter().zip(self.0) {\n                let pointer = context\n                    .current_function()\n                    .borrow()\n                    .get_stack_pointer(name.as_str())\n                    .ok_or_else(|| anyhow::anyhow!(\"Variable `{}` not found\", name))?;\n                let value = expression.into_llvm_value(context)?.expect(\"Always exists\");\n                context.build_store(pointer, value);\n            }\n        }\n\n        context.build_unconditional_branch(block);\n\n        Ok(None)\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let label_name = self.0.remove(0).try_into_identifier()?;\n\n        if label_name.ends_with(crate::r#const::LABEL_SUFFIX_CLEANUP)\n            || label_name == crate::r#const::FUNCTION_IDENTIFIER_FALLBACK\n        {\n            return self.into_block_call(context, label_name);\n        }\n\n        self.into_function_call(context, label_name)\n    }\n}\n", "//!\n//! The `if` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `if` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct If(Vec<Expression>);\n\nimpl If {\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        let mut result = self\n            .0\n            .get_mut(1)\n            .expect(\"Always exists\")\n            .extract_functions()?;\n        if let Some(else_expression) = self.0.get_mut(2) {\n            result.extend(else_expression.extract_functions()?);\n        }\n        Ok(result)\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let main_block = context.append_basic_block(\"if_main\");\n        let join_block = context.append_basic_block(\"if_join\");\n\n        let condition_expression = self.0.remove(0);\n        let main_expression = self.0.remove(0);\n        let else_expression = self.0.pop();\n\n        let result_pointer = context.build_alloca(context.field_type(), \"if_result_pointer\");\n        context.build_store(result_pointer, context.field_const(0));\n        let mut returns_value = false;\n\n        let condition = condition_expression\n            .into_llvm_value(context)?\n            .expect(\"Always exists\")\n            .into_int_value();\n        let condition = context.builder().build_int_z_extend_or_bit_cast(\n            condition,\n            context.field_type(),\n            \"if_condition_extended\",\n        );\n        let condition = context.builder().build_int_compare(\n            inkwell::IntPredicate::NE,\n            condition,\n            context.field_const(0),\n            \"if_condition_compared\",\n        );\n\n        if let Some(else_expression) = else_expression {\n            let else_block = context.append_basic_block(\"if_else\");\n            context.build_conditional_branch(condition, main_block, else_block);\n\n            context.set_basic_block(else_block);\n            if let Some(argument) = else_expression.into_llvm_value(context)? {\n                returns_value = true;\n                context.build_store(result_pointer, argument);\n            }\n            context.build_unconditional_branch(join_block);\n        } else {\n            context.build_conditional_branch(condition, main_block, join_block);\n        }\n\n        context.set_basic_block(main_block);\n        if let Some(argument) = main_expression.into_llvm_value(context)? {\n            returns_value = true;\n            context.build_store(result_pointer, argument);\n        }\n        context.build_unconditional_branch(join_block);\n\n        context.set_basic_block(join_block);\n        if !returns_value {\n            return Ok(None);\n        }\n\n        let result = context.build_load(result_pointer, \"if_result\");\n        Ok(Some(result))\n    }\n}\n", "//!\n//! The immutable instructions.\n//!\n\n///\n/// Translates the immutable load sequence.\n///\n/// It is a custom Vyper-specific instruction, which is capable of copying an array of immutables\n/// from the immutable storage system contract to the heap.\n///\npub fn load_bytes<'ctx, D>(\n    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    heap_offset: inkwell::values::IntValue<'ctx>,\n    immutable_offset: inkwell::values::IntValue<'ctx>,\n    length: inkwell::values::IntValue<'ctx>,\n) -> anyhow::Result<()>\nwhere\n    D: compiler_llvm_context::EraVMDependency + Clone,\n{\n    let condition_block = context.append_basic_block(\"immutable_load_bytes_repeat_condition\");\n    let body_block = context.append_basic_block(\"immutable_load_bytes_repeat_body\");\n    let increment_block = context.append_basic_block(\"immutable_load_bytes_repeat_increment\");\n    let join_block = context.append_basic_block(\"immutable_load_bytes_repeat_join\");\n\n    let heap_offset_pointer = context.build_alloca(\n        context.field_type(),\n        \"immutable_load_bytes_heap_offset_pointer\",\n    );\n    context.build_store(heap_offset_pointer, heap_offset);\n    let immutable_offset_pointer = context.build_alloca(\n        context.field_type(),\n        \"immutable_load_bytes_immutable_pointer\",\n    );\n    context.build_store(immutable_offset_pointer, immutable_offset);\n    let index_offset_pointer = context.build_alloca(\n        context.field_type(),\n        \"immutable_load_bytes_index_offset_pointer\",\n    );\n    context.build_store(index_offset_pointer, context.field_const(0));\n    context.build_unconditional_branch(condition_block);\n\n    context.set_basic_block(condition_block);\n    let index_offset_value = context.build_load(\n        index_offset_pointer,\n        \"immutable_load_bytes_condition_index_offset_pointer\",\n    );\n    let condition = context.builder().build_int_compare(\n        inkwell::IntPredicate::ULT,\n        index_offset_value.into_int_value(),\n        length,\n        \"immutable_load_bytes_condition_compared\",\n    );\n    context.build_conditional_branch(condition, body_block, join_block);\n\n    context.set_basic_block(body_block);\n    let immutable_offset_value = context.build_load(\n        immutable_offset_pointer,\n        \"immutable_load_bytes_immutable_offset_value\",\n    );\n    let immutable_value = compiler_llvm_context::eravm_evm_immutable::load(\n        context,\n        immutable_offset_value.into_int_value(),\n    )?;\n\n    let heap_offset_value = context.build_load(\n        heap_offset_pointer,\n        \"immutable_load_bytes_heap_offset_value\",\n    );\n    let heap_pointer = compiler_llvm_context::EraVMPointer::new_with_offset(\n        context,\n        compiler_llvm_context::EraVMAddressSpace::Heap,\n        context.field_type(),\n        heap_offset_value.into_int_value(),\n        \"immutable_load_bytes_heap_pointer\",\n    );\n    context.build_store(heap_pointer, immutable_value);\n    context.build_unconditional_branch(increment_block);\n\n    context.set_basic_block(increment_block);\n    let heap_offset_value = context.build_load(\n        heap_offset_pointer,\n        \"immutable_load_bytes_increment_heap_offset_value\",\n    );\n    let heap_offset_value_incremented = context.builder().build_int_add(\n        heap_offset_value.into_int_value(),\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"immutable_load_bytes_heap_offset_value_incremented\",\n    );\n    context.build_store(heap_offset_pointer, heap_offset_value_incremented);\n\n    let immutable_offset_value = context.build_load(\n        immutable_offset_pointer,\n        \"immutable_load_bytes_increment_immutable_offset_value\",\n    );\n    let immutable_offset_value_incremented = context.builder().build_int_add(\n        immutable_offset_value.into_int_value(),\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"immutable_load_bytes_immutable_offset_value_incremented\",\n    );\n    context.build_store(immutable_offset_pointer, immutable_offset_value_incremented);\n\n    let index_offset_value = context.build_load(\n        index_offset_pointer,\n        \"immutable_load_bytes_increment_index_offset_value\",\n    );\n    let index_offset_value_incremented = context.builder().build_int_add(\n        index_offset_value.into_int_value(),\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"immutable_load_bytes_increment_index_offset_value_incremented\",\n    );\n    context.build_store(index_offset_pointer, index_offset_value_incremented);\n    context.build_unconditional_branch(condition_block);\n\n    context.set_basic_block(join_block);\n\n    Ok(())\n}\n", "//!\n//! The `label` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse inkwell::values::BasicValue;\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::instruction::Instruction;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `label` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Label(Vec<Expression>);\n\nimpl Label {\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        self.0\n            .last_mut()\n            .expect(\"Always exists\")\n            .extract_functions()\n    }\n\n    ///\n    /// Whether the label is a function entry block.\n    ///\n    pub fn is_function_entry(&self) -> anyhow::Result<bool> {\n        let label_name = self.name()?;\n        Ok(\n            label_name.starts_with(crate::r#const::FUNCTION_PREFIX_EXTERNAL)\n                || label_name.starts_with(crate::r#const::FUNCTION_PREFIX_INTERNAL),\n        )\n    }\n\n    ///\n    /// Checks whether the label is empty. If it is, nothing is generated.\n    ///\n    pub fn is_empty(&self) -> bool {\n        self.0.len() <= 1\n    }\n\n    ///\n    /// Checks whether the label body is empty. If it is, nothing is generated.\n    ///\n    /// The cleanup block cannot be ignored in deploy code, because `vyper` generates jumps to them.\n    ///\n    pub fn can_block_be_ignored(&self) -> bool {\n        let label_name = match self.0.get(0).expect(\"Always exists\").try_into_identifier() {\n            Ok(identifier) => identifier,\n            Err(_) => return true,\n        };\n\n        if label_name.starts_with(\"external___init\")\n            && label_name.ends_with(crate::r#const::LABEL_SUFFIX_CLEANUP)\n        {\n            return false;\n        }\n\n        matches!(\n            self.0.get(2),\n            Some(Expression::Instruction(Instruction::Pass))\n        )\n    }\n\n    ///\n    /// Checks whether the label body is an empty sequence. If it is, a return is appended.\n    ///\n    /// Only used by the cleanup block in deploy code.\n    ///\n    pub fn is_block_empty_sequence(&self) -> bool {\n        match self.0.get(2) {\n            Some(Expression::Instruction(Instruction::Pass)) => true,\n            Some(Expression::Instruction(Instruction::Seq(sequence))) => {\n                sequence.is_pass_or_empty()\n            }\n            Some(Expression::Identifier(identifier)) => {\n                identifier.as_str() == crate::r#const::DEFAULT_PASS_IDENTIFIER\n            }\n            Some(_) => false,\n            None => true,\n        }\n    }\n\n    ///\n    /// Returns the label name.\n    ///\n    pub fn name(&self) -> anyhow::Result<String> {\n        self.0.get(0).expect(\"Always exists\").try_into_identifier()\n    }\n\n    ///\n    /// Declares the label block, so all the blocks are predeclared before translating the bodies.\n    ///\n    pub fn declare<D>(\n        &self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        if self.is_empty() || self.can_block_be_ignored() {\n            return Ok(());\n        }\n\n        let label_name = self\n            .0\n            .get(0)\n            .expect(\"Always exists\")\n            .try_into_identifier()?;\n        context.append_basic_block(label_name.as_str());\n\n        context.set_basic_block(context.current_function().borrow().entry_block());\n        let mut label_arguments = Vec::new();\n        match self.0.get(1) {\n            Some(Expression::Instruction(Instruction::Var_List(ref arguments))) => {\n                for argument in arguments.iter() {\n                    let name = argument.try_into_identifier()?;\n                    if name.as_str() == crate::r#const::VARIABLE_IDENTIFIER_RETURN_PC {\n                        continue;\n                    }\n                    label_arguments.push(name.clone());\n\n                    let pointer = context.build_alloca(context.field_type(), name.as_str());\n                    let value =\n                        if name.as_str() == crate::r#const::VARIABLE_IDENTIFIER_RETURN_BUFFER {\n                            context.current_function().borrow().get_nth_param(0)\n                        } else {\n                            context.field_const(0).as_basic_value_enum()\n                        };\n                    context.build_store(pointer, value);\n                    context\n                        .current_function()\n                        .borrow_mut()\n                        .insert_stack_pointer(name, pointer);\n                }\n            }\n            Some(Expression::Identifier(identifier)) if identifier.as_str() == \"var_list\" => {}\n            expression => anyhow::bail!(\"Expected a variable list, found `{:?}`\", expression),\n        };\n\n        context\n            .current_function()\n            .borrow_mut()\n            .vyper_mut()\n            .insert_label_arguments(label_name, label_arguments);\n\n        Ok(())\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        if self.is_empty() || self.can_block_be_ignored() {\n            return Ok(());\n        }\n        let is_block_empty_sequence = self.is_block_empty_sequence();\n\n        let label_name = self.0.remove(0);\n        let block = self.0.remove(1);\n\n        let current_block = context.basic_block();\n\n        let label_name = label_name.try_into_identifier()?;\n        let label_block = context\n            .current_function()\n            .borrow()\n            .declaration()\n            .value\n            .get_basic_blocks()\n            .iter()\n            .find(|block| block.get_name().to_string_lossy() == label_name)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Block `{}` does not exist\", label_name))?;\n\n        context.set_basic_block(label_block);\n        block.into_llvm_value(context)?;\n\n        if label_name == crate::r#const::FUNCTION_IDENTIFIER_FALLBACK {\n            context.build_unconditional_branch(context.current_function().borrow().return_block());\n        }\n\n        if label_name.starts_with(\"external___init\")\n            && label_name.ends_with(crate::r#const::LABEL_SUFFIX_CLEANUP)\n            && is_block_empty_sequence\n        {\n            compiler_llvm_context::eravm_evm_return::stop(context)?;\n        }\n\n        context.set_basic_block(current_block);\n\n        Ok(())\n    }\n}\n", "//!\n//! The LLL IR instruction.\n//!\n\npub mod assert;\npub mod clamp;\npub mod create;\npub mod deploy;\npub mod exit_to;\npub mod goto;\npub mod r#if;\npub mod immutable;\npub mod label;\npub mod offset;\npub mod repeat;\npub mod r#return;\npub mod revert;\npub mod seq;\npub mod set;\npub mod with;\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse inkwell::values::BasicValue;\n\nuse crate::project::contract::vyper::expression::Expression;\n\nuse self::assert::Assert;\nuse self::deploy::Deploy;\nuse self::exit_to::ExitTo;\nuse self::goto::Goto;\nuse self::label::Label;\nuse self::r#if::If;\nuse self::r#return::Return;\nuse self::repeat::Repeat;\nuse self::revert::Revert;\nuse self::seq::Seq;\nuse self::set::Set;\nuse self::with::With;\n\n///\n/// The LLL IR instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"lowercase\")]\n#[allow(non_camel_case_types)]\n#[allow(clippy::upper_case_acronyms)]\npub enum Instruction {\n    /// The LLL IR `with` expression.\n    With(With),\n    /// The LLL IR `set` expression.\n    Set(Set),\n    /// The LLL IR `seq` expression.\n    Seq(Seq),\n    /// The LLL IR `if` statement.\n    If(If),\n    /// The LLL IR `repeat` statement.\n    Repeat(Repeat),\n\n    /// The LLL IR `goto` instruction.\n    GoTo(Goto),\n    /// The LLL IR `exit_to` instruction.\n    Exit_To(ExitTo),\n    /// The LLL IR `jump` instruction.\n    Jump([Box<Expression>; 1]),\n    /// The LLL IR `label` instruction.\n    Label(Label),\n    /// The LLL IR `cleanup_repeat` instruction.\n    Cleanup_Repeat,\n    /// The LLL IR `break` instruction.\n    Break,\n    /// The LLL IR `continue` instruction.\n    Continue,\n    /// The LLL IR `pass` instruction.\n    Pass,\n    /// The LLL IR `deploy` instruction.\n    Deploy(Deploy),\n    /// The LLL IR `symbol` instruction.\n    Symbol([Box<Expression>; 1]),\n    /// The LLL IR `unique_symbol` instruction.\n    Unique_Symbol([Box<Expression>; 1]),\n\n    /// The LLL IR pseudo opcode.\n    UCLAMP([Box<Expression>; 3]),\n    /// The LLL IR pseudo opcode.\n    CLAMP([Box<Expression>; 3]),\n    /// The LLL IR pseudo opcode.\n    UCLAMPLT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    UCLAMPLE([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    UCLAMPGT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    UCLAMPGE([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMPLT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMPLE([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMPGT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMPGE([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    CLAMP_NONZERO([Box<Expression>; 1]),\n\n    /// The LLL IR pseudo opcode.\n    CEIL32([Box<Expression>; 1]),\n    /// The LLL IR pseudo opcode.\n    SELECT([Box<Expression>; 3]),\n\n    /// The LLL IR pseudo opcode.\n    Assert(Assert),\n    /// The LLL IR pseudo opcode.\n    Assert_Unreachable(Assert),\n\n    /// The LLL IR `var_list` instruction.\n    Var_List(Vec<Expression>),\n\n    /// The LLL IR EVM opcode.\n    POP([Box<Expression>; 1]),\n\n    /// The LLL IR EVM opcode.\n    ADD([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SUB([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    MUL([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    DIV([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    MOD([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SDIV([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SMOD([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    LT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    LE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    GT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    GE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    EQ([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    NE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    ISZERO([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    SLT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    SLE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SGT([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    SGE([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    OR([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    XOR([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    NOT([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    AND([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SHL([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SHR([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SAR([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    BYTE([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    ADDMOD([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    MULMOD([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    EXP([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    SIGNEXTEND([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    SHA3([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    KECCAK256([Box<Expression>; 2]),\n    /// The LLL IR pseudo opcode.\n    SHA3_32([Box<Expression>; 1]),\n    /// The LLL IR pseudo opcode.\n    SHA3_64([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    MLOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    MSTORE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    MSTORE8([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    SLOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    SSTORE([Box<Expression>; 2]),\n\n    /// The LLL IR EVM opcode.\n    ILOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    ISTORE([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    DLOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    DLOADBYTES([Box<Expression>; 3]),\n\n    /// The LLL IR EVM opcode.\n    CALLDATALOAD([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    CALLDATASIZE,\n    /// The LLL IR EVM opcode.\n    CALLDATACOPY([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    CODESIZE,\n    /// The LLL IR EVM opcode.\n    CODECOPY([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    EXTCODESIZE([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    EXTCODEHASH([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    RETURNDATASIZE,\n    /// The LLL IR EVM opcode.\n    RETURNDATACOPY([Box<Expression>; 3]),\n\n    /// The LLL IR EVM opcode.\n    RETURN(Return),\n    /// The LLL IR EVM opcode.\n    REVERT(Revert),\n    /// The LLL IR EVM opcode.\n    STOP,\n    /// The LLL IR EVM opcode.\n    INVALID,\n\n    /// The LLL IR EVM opcode.\n    LOG0([Box<Expression>; 2]),\n    /// The LLL IR EVM opcode.\n    LOG1([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    LOG2([Box<Expression>; 4]),\n    /// The LLL IR EVM opcode.\n    LOG3([Box<Expression>; 5]),\n    /// The LLL IR EVM opcode.\n    LOG4([Box<Expression>; 6]),\n\n    /// The LLL IR EVM opcode.\n    CALL([Box<Expression>; 7]),\n    /// The LLL IR EVM opcode.\n    STATICCALL([Box<Expression>; 6]),\n    /// The LLL IR EVM opcode.\n    DELEGATECALL([Box<Expression>; 6]),\n\n    /// The LLL IR EVM opcode.\n    CREATE([Box<Expression>; 3]),\n    /// The LLL IR EVM opcode.\n    CREATE2([Box<Expression>; 4]),\n\n    /// The LLL IR EVM opcode.\n    ADDRESS,\n    /// The LLL IR EVM opcode.\n    CALLER,\n\n    /// The LLL IR EVM opcode.\n    CALLVALUE,\n    /// The LLL IR EVM opcode.\n    GAS,\n    /// The LLL IR EVM opcode.\n    BALANCE([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    SELFBALANCE,\n\n    /// The LLL IR EVM opcode.\n    GASLIMIT,\n    /// The LLL IR EVM opcode.\n    GASPRICE,\n    /// The LLL IR EVM opcode.\n    ORIGIN,\n    /// The LLL IR EVM opcode.\n    CHAINID,\n    /// The LLL IR EVM opcode.\n    NUMBER,\n    /// The LLL IR EVM opcode.\n    TIMESTAMP,\n    /// The LLL IR EVM opcode.\n    BLOCKHASH([Box<Expression>; 1]),\n    /// The LLL IR EVM opcode.\n    DIFFICULTY,\n    /// The LLL IR EVM opcode.\n    COINBASE,\n    /// The LLL IR EVM opcode.\n    BASEFEE,\n    /// The LLL IR EVM opcode.\n    MSIZE,\n\n    /// The LLL IR EVM opcode.\n    CALLCODE([Box<Expression>; 7]),\n    /// The LLL IR EVM opcode.\n    PC,\n    /// The LLL IR EVM opcode.\n    EXTCODECOPY([Box<Expression>; 4]),\n    /// The LLL IR EVM opcode.\n    SELFDESTRUCT([Box<Expression>; 1]),\n\n    /// The LLL unknown trap.\n    Unknown(serde_json::Value),\n}\n\nimpl Instruction {\n    ///\n    /// Translates the specified number of arguments.\n    ///\n    fn translate_arguments_llvm<'ctx, D, const N: usize>(\n        arguments: [Box<Expression>; N],\n        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    ) -> anyhow::Result<[inkwell::values::BasicValueEnum<'ctx>; N]>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let debug_string = format!(\"`{arguments:?}`\");\n\n        let mut values = Vec::with_capacity(N);\n        for (index, expression) in arguments.into_iter().enumerate().rev() {\n            values.push(expression.into_llvm_value(context)?.ok_or_else(|| {\n                anyhow::anyhow!(\n                    \"Expression #{} of the instruction `{}` has zero valency\",\n                    index,\n                    debug_string\n                )\n            })?);\n        }\n        values.reverse();\n\n        if values.len() != N {\n            anyhow::bail!(\n                \"Expected {} arguments, found only {}: `{:?}`\",\n                N,\n                values.len(),\n                values\n            );\n        }\n\n        Ok(values.try_into().expect(\"Always valid\"))\n    }\n\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        match self {\n            Self::Seq(inner) => inner.extract_functions(),\n            Self::With(inner) => inner.extract_functions(),\n            Self::If(inner) => inner.extract_functions(),\n            Self::Repeat(inner) => inner.extract_functions(),\n            Self::Label(inner) => inner.extract_functions(),\n            _ => Ok(BTreeMap::new()),\n        }\n    }\n\n    ///\n    /// Whether the instruction is a function entry block.\n    ///\n    pub fn is_function(&self) -> anyhow::Result<bool> {\n        match self {\n            Self::Seq(sequence) => sequence.is_function(),\n            _ => Ok(false),\n        }\n    }\n\n    ///\n    /// Returns the function name.\n    ///\n    pub fn function_name(&self) -> anyhow::Result<String> {\n        match self {\n            Self::Seq(inner) => inner.function_name(),\n            expression => anyhow::bail!(\"Expected a function sequence, found `{:?}`\", expression),\n        }\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        match self {\n            Self::With(inner) => inner.into_llvm_value(context),\n            Self::Set(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::Seq(inner) => inner.into_llvm_value(context),\n            Self::If(inner) => inner.into_llvm_value(context),\n            Self::Repeat(inner) => inner.into_llvm_value(context).map(|_| None),\n\n            Self::GoTo(inner) => inner.into_llvm_value(context),\n            Self::Exit_To(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::Jump(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                let block = context.current_function().borrow().return_block();\n                context.build_unconditional_branch(block);\n                Ok(None)\n            }\n            Self::Label(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::Cleanup_Repeat => Ok(None),\n            Self::Break => {\n                let block = context.r#loop().join_block;\n                context.build_unconditional_branch(block);\n                Ok(None)\n            }\n            Self::Continue => {\n                let block = context.r#loop().continue_block;\n                context.build_unconditional_branch(block);\n                Ok(None)\n            }\n            Self::Pass => Ok(None),\n            Self::Deploy(_inner) => Ok(None),\n            Self::Symbol(_inner) => Ok(None),\n            Self::Unique_Symbol(_inner) => Ok(None),\n\n            Self::UCLAMP(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                clamp::ordinary(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                    false,\n                )\n                .map(Some)\n            }\n            Self::CLAMP(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                clamp::ordinary(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                    true,\n                )\n                .map(Some)\n            }\n            Self::UCLAMPLT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::ULT,\n                )\n                .map(Some)\n            }\n            Self::UCLAMPLE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::ULE,\n                )\n                .map(Some)\n            }\n            Self::UCLAMPGT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::UGT,\n                )\n                .map(Some)\n            }\n            Self::UCLAMPGE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::UGE,\n                )\n                .map(Some)\n            }\n            Self::CLAMPLT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SLT,\n                )\n                .map(Some)\n            }\n            Self::CLAMPLE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SLE,\n                )\n                .map(Some)\n            }\n            Self::CLAMPGT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SGT,\n                )\n                .map(Some)\n            }\n            Self::CLAMPGE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SGE,\n                )\n                .map(Some)\n            }\n            Self::CLAMP_NONZERO(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                clamp::with_predicate(\n                    context,\n                    arguments[0].into_int_value(),\n                    context.field_const(0),\n                    inkwell::IntPredicate::NE,\n                )\n                .map(Some)\n            }\n\n            Self::CEIL32(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                offset::ceil_32(context, arguments[0].into_int_value()).map(Some)\n            }\n            Self::SELECT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                let condition = context.builder().build_int_compare(\n                    inkwell::IntPredicate::NE,\n                    arguments[0].into_int_value(),\n                    context.field_const(0),\n                    \"select_condition\",\n                );\n                Ok(Some(context.builder().build_select(\n                    condition,\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                    \"select\",\n                )))\n            }\n\n            Self::Assert(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::Assert_Unreachable(inner) => inner.into_llvm_value(context).map(|_| None),\n\n            Self::Var_List(_inner) => Ok(None),\n\n            Self::POP(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                Ok(None)\n            }\n\n            Self::ADD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_arithmetic::addition(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SUB(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_arithmetic::subtraction(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::MUL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_arithmetic::multiplication(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::DIV(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_arithmetic::division(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::MOD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_arithmetic::remainder(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SDIV(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_arithmetic::division_signed(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SMOD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_arithmetic::remainder_signed(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n\n            Self::LT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::ULT,\n                )\n                .map(Some)\n            }\n            Self::LE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::ULE,\n                )\n                .map(Some)\n            }\n            Self::GT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::UGT,\n                )\n                .map(Some)\n            }\n            Self::GE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::UGE,\n                )\n                .map(Some)\n            }\n            Self::EQ(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::EQ,\n                )\n                .map(Some)\n            }\n            Self::NE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::NE,\n                )\n                .map(Some)\n            }\n            Self::ISZERO(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    context.field_const(0),\n                    inkwell::IntPredicate::EQ,\n                )\n                .map(Some)\n            }\n            Self::SLT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SLT,\n                )\n                .map(Some)\n            }\n            Self::SLE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SLE,\n                )\n                .map(Some)\n            }\n            Self::SGT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SGT,\n                )\n                .map(Some)\n            }\n            Self::SGE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_comparison::compare(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    inkwell::IntPredicate::SGE,\n                )\n                .map(Some)\n            }\n\n            Self::OR(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_bitwise::or(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::XOR(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_bitwise::xor(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::NOT(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_bitwise::xor(\n                    context,\n                    arguments[0].into_int_value(),\n                    context.field_type().const_all_ones(),\n                )\n                .map(Some)\n            }\n            Self::AND(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_bitwise::and(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SHL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_bitwise::shift_left(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SHR(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_bitwise::shift_right(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SAR(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_bitwise::shift_right_arithmetic(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::BYTE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_bitwise::byte(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n\n            Self::ADDMOD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_math::add_mod(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::MULMOD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_math::mul_mod(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::EXP(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_math::exponent(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SIGNEXTEND(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_math::sign_extend(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(Some)\n            }\n\n            Self::SHA3(arguments) | Self::KECCAK256(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                let input_offset = arguments[0].into_int_value();\n                let input_length = arguments[1].into_int_value();\n\n                let function = compiler_llvm_context::EraVMRuntime::keccak256(context);\n                Ok(context.build_call(\n                    function,\n                    &[\n                        input_offset.as_basic_value_enum(),\n                        input_length.as_basic_value_enum(),\n                    ],\n                    \"sha3_call\",\n                ))\n            }\n            Self::SHA3_32(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n\n                let pointer_one = compiler_llvm_context::EraVMPointer::new_with_offset(\n                    context,\n                    compiler_llvm_context::EraVMAddressSpace::Heap,\n                    context.field_type(),\n                    context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64),\n                    \"sha3_pointer_one\",\n                );\n                context.build_store(pointer_one, arguments[0]);\n\n                let function = compiler_llvm_context::EraVMRuntime::keccak256(context);\n                Ok(context.build_call(\n                    function,\n                    &[\n                        context\n                            .field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64)\n                            .as_basic_value_enum(),\n                        context\n                            .field_const(compiler_common::BYTE_LENGTH_FIELD as u64)\n                            .as_basic_value_enum(),\n                    ],\n                    \"sha3_32_call\",\n                ))\n            }\n            Self::SHA3_64(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n\n                let pointer_one = compiler_llvm_context::EraVMPointer::new_with_offset(\n                    context,\n                    compiler_llvm_context::EraVMAddressSpace::Heap,\n                    context.field_type(),\n                    context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64),\n                    \"sha3_pointer_one\",\n                );\n                context.build_store(pointer_one, arguments[0]);\n                let pointer_two = compiler_llvm_context::EraVMPointer::new_with_offset(\n                    context,\n                    compiler_llvm_context::EraVMAddressSpace::Heap,\n                    context.field_type(),\n                    context.field_const(crate::r#const::OFFSET_FREE_VAR_SPACE2 as u64),\n                    \"sha3_pointer_two\",\n                );\n                context.build_store(pointer_two, arguments[1]);\n\n                let function = compiler_llvm_context::EraVMRuntime::keccak256(context);\n                Ok(context.build_call(\n                    function,\n                    &[\n                        context\n                            .field_const(crate::r#const::OFFSET_FREE_VAR_SPACE as u64)\n                            .as_basic_value_enum(),\n                        context\n                            .field_const((compiler_common::BYTE_LENGTH_FIELD * 2) as u64)\n                            .as_basic_value_enum(),\n                    ],\n                    \"sha3_64_call\",\n                ))\n            }\n\n            Self::MLOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_memory::load(\n                    context,\n                    arguments[0].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::MSTORE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_memory::store(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(|_| None)\n            }\n            Self::MSTORE8(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_memory::store_byte(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(|_| None)\n            }\n\n            Self::SLOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_storage::load(\n                    context,\n                    arguments[0].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::SSTORE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_storage::store(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(|_| None)\n            }\n\n            Self::ILOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_immutable::load(\n                    context,\n                    arguments[0].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::ISTORE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_immutable::store(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                )\n                .map(|_| None)\n            }\n\n            Self::CALLDATALOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n\n                match context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    compiler_llvm_context::EraVMCodeType::Deploy => {\n                        Ok(Some(context.field_const(0).as_basic_value_enum()))\n                    }\n                    compiler_llvm_context::EraVMCodeType::Runtime => {\n                        compiler_llvm_context::eravm_evm_calldata::load(\n                            context,\n                            arguments[0].into_int_value(),\n                        )\n                        .map(Some)\n                    }\n                }\n            }\n            Self::CALLDATASIZE => {\n                match context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    compiler_llvm_context::EraVMCodeType::Deploy => {\n                        Ok(Some(context.field_const(0).as_basic_value_enum()))\n                    }\n                    compiler_llvm_context::EraVMCodeType::Runtime => {\n                        compiler_llvm_context::eravm_evm_calldata::size(context).map(Some)\n                    }\n                }\n            }\n            Self::CALLDATACOPY(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n\n                let source_offset = match context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    compiler_llvm_context::EraVMCodeType::Deploy => {\n                        compiler_llvm_context::eravm_evm_calldata::size(context)?\n                    }\n                    compiler_llvm_context::EraVMCodeType::Runtime => {\n                        arguments[1].into_int_value().as_basic_value_enum()\n                    }\n                }\n                .into_int_value();\n\n                compiler_llvm_context::eravm_evm_calldata::copy(\n                    context,\n                    arguments[0].into_int_value(),\n                    source_offset,\n                    arguments[2].into_int_value(),\n                )\n                .map(|_| None)\n            }\n            Self::DLOAD(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n\n                match context.code_type() {\n                    None => {\n                        anyhow::bail!(\n                            \"Immutables are not available if the contract part is undefined\"\n                        );\n                    }\n                    Some(compiler_llvm_context::EraVMCodeType::Deploy) => {\n                        compiler_llvm_context::eravm_evm_calldata::load(\n                            context,\n                            arguments[0].into_int_value(),\n                        )\n                    }\n                    Some(compiler_llvm_context::EraVMCodeType::Runtime) => {\n                        compiler_llvm_context::eravm_evm_immutable::load(\n                            context,\n                            arguments[0].into_int_value(),\n                        )\n                    }\n                }\n                .map(Some)\n            }\n            Self::DLOADBYTES(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n\n                match context.code_type() {\n                    None => {\n                        anyhow::bail!(\n                            \"Immutables are not available if the contract part is undefined\"\n                        );\n                    }\n                    Some(compiler_llvm_context::EraVMCodeType::Deploy) => {\n                        compiler_llvm_context::eravm_evm_calldata::copy(\n                            context,\n                            arguments[0].into_int_value(),\n                            arguments[1].into_int_value(),\n                            arguments[2].into_int_value(),\n                        )\n                    }\n                    Some(compiler_llvm_context::EraVMCodeType::Runtime) => immutable::load_bytes(\n                        context,\n                        arguments[0].into_int_value(),\n                        arguments[1].into_int_value(),\n                        arguments[2].into_int_value(),\n                    ),\n                }\n                .map(|_| None)\n            }\n            Self::CODESIZE => {\n                match context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    compiler_llvm_context::EraVMCodeType::Deploy => {\n                        compiler_llvm_context::eravm_evm_calldata::size(context).map(Some)\n                    }\n                    compiler_llvm_context::EraVMCodeType::Runtime => {\n                        let code_source =\n                            compiler_llvm_context::eravm_general::code_source(context)?;\n                        compiler_llvm_context::eravm_evm_ext_code::size(\n                            context,\n                            code_source.into_int_value(),\n                        )\n                        .map(Some)\n                    }\n                }\n            }\n            Self::CODECOPY(arguments) => {\n                if let compiler_llvm_context::EraVMCodeType::Runtime = context\n                    .code_type()\n                    .ok_or_else(|| anyhow::anyhow!(\"The contract code part type is undefined\"))?\n                {\n                    anyhow::bail!(\n                        \"The `CODECOPY` instruction is not supported in the runtime code\",\n                    );\n                }\n\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_calldata::copy(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                )\n                .map(|_| None)\n            }\n            Self::RETURNDATASIZE => {\n                compiler_llvm_context::eravm_evm_return_data::size(context).map(Some)\n            }\n            Self::RETURNDATACOPY(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_return_data::copy(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2].into_int_value(),\n                )\n                .map(|_| None)\n            }\n            Self::EXTCODESIZE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_ext_code::size(\n                    context,\n                    arguments[0].into_int_value(),\n                )\n                .map(Some)\n            }\n            Self::EXTCODEHASH(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_ext_code::hash(\n                    context,\n                    arguments[0].into_int_value(),\n                )\n                .map(Some)\n            }\n\n            Self::RETURN(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::REVERT(inner) => inner.into_llvm_value(context).map(|_| None),\n            Self::STOP => compiler_llvm_context::eravm_evm_return::stop(context).map(|_| None),\n            Self::INVALID => {\n                compiler_llvm_context::eravm_evm_return::invalid(context).map(|_| None)\n            }\n\n            Self::LOG0(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 2>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    vec![],\n                )\n                .map(|_| None)\n            }\n            Self::LOG1(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2..]\n                        .iter()\n                        .map(|argument| argument.into_int_value())\n                        .collect(),\n                )\n                .map(|_| None)\n            }\n            Self::LOG2(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 4>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2..]\n                        .iter()\n                        .map(|argument| argument.into_int_value())\n                        .collect(),\n                )\n                .map(|_| None)\n            }\n            Self::LOG3(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 5>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2..]\n                        .iter()\n                        .map(|argument| argument.into_int_value())\n                        .collect(),\n                )\n                .map(|_| None)\n            }\n            Self::LOG4(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 6>(arguments, context)?;\n                compiler_llvm_context::eravm_evm_event::log(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    arguments[2..]\n                        .iter()\n                        .map(|argument| argument.into_int_value())\n                        .collect(),\n                )\n                .map(|_| None)\n            }\n\n            Self::CALL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 7>(arguments, context)?;\n\n                let gas = arguments[0].into_int_value();\n                let address = arguments[1].into_int_value();\n                let value = arguments[2].into_int_value();\n                let input_offset = arguments[3].into_int_value();\n                let input_size = arguments[4].into_int_value();\n                let output_offset = arguments[5].into_int_value();\n                let output_size = arguments[6].into_int_value();\n\n                compiler_llvm_context::eravm_evm_call::default(\n                    context,\n                    context.llvm_runtime().far_call,\n                    gas,\n                    address,\n                    Some(value),\n                    input_offset,\n                    input_size,\n                    output_offset,\n                    output_size,\n                    None,\n                )\n                .map(Some)\n            }\n            Self::STATICCALL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 6>(arguments, context)?;\n\n                let gas = arguments[0].into_int_value();\n                let address = arguments[1].into_int_value();\n                let input_offset = arguments[2].into_int_value();\n                let input_size = arguments[3].into_int_value();\n                let output_offset = arguments[4].into_int_value();\n                let output_size = arguments[5].into_int_value();\n\n                compiler_llvm_context::eravm_evm_call::default(\n                    context,\n                    context.llvm_runtime().static_call,\n                    gas,\n                    address,\n                    None,\n                    input_offset,\n                    input_size,\n                    output_offset,\n                    output_size,\n                    None,\n                )\n                .map(Some)\n            }\n            Self::DELEGATECALL(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 6>(arguments, context)?;\n\n                let gas = arguments[0].into_int_value();\n                let address = arguments[1].into_int_value();\n                let input_offset = arguments[2].into_int_value();\n                let input_size = arguments[3].into_int_value();\n                let output_offset = arguments[4].into_int_value();\n                let output_size = arguments[5].into_int_value();\n\n                compiler_llvm_context::eravm_evm_call::default(\n                    context,\n                    context.llvm_runtime().delegate_call,\n                    gas,\n                    address,\n                    None,\n                    input_offset,\n                    input_size,\n                    output_offset,\n                    output_size,\n                    None,\n                )\n                .map(Some)\n            }\n\n            Self::CREATE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 3>(arguments, context)?;\n\n                create::create(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    None,\n                )\n                .map(Some)\n            }\n            Self::CREATE2(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 4>(arguments, context)?;\n\n                create::create(\n                    context,\n                    arguments[0].into_int_value(),\n                    arguments[1].into_int_value(),\n                    Some(arguments[3].into_int_value()),\n                )\n                .map(Some)\n            }\n\n            Self::ADDRESS => Ok(context.build_call(context.intrinsics().address, &[], \"address\")),\n            Self::CALLER => Ok(context.build_call(context.intrinsics().caller, &[], \"caller\")),\n\n            Self::CALLVALUE => compiler_llvm_context::eravm_evm_ether_gas::value(context).map(Some),\n            Self::GAS => compiler_llvm_context::eravm_evm_ether_gas::gas(context).map(Some),\n            Self::BALANCE(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n\n                let address = arguments[0].into_int_value();\n                compiler_llvm_context::eravm_evm_ether_gas::balance(context, address).map(Some)\n            }\n            Self::SELFBALANCE => {\n                let address = context\n                    .build_call(context.intrinsics().address, &[], \"self_balance_address\")\n                    .expect(\"Always exists\")\n                    .into_int_value();\n\n                compiler_llvm_context::eravm_evm_ether_gas::balance(context, address).map(Some)\n            }\n\n            Self::GASLIMIT => {\n                compiler_llvm_context::eravm_evm_contract_context::gas_limit(context).map(Some)\n            }\n            Self::GASPRICE => {\n                compiler_llvm_context::eravm_evm_contract_context::gas_price(context).map(Some)\n            }\n            Self::ORIGIN => {\n                compiler_llvm_context::eravm_evm_contract_context::origin(context).map(Some)\n            }\n            Self::CHAINID => {\n                compiler_llvm_context::eravm_evm_contract_context::chain_id(context).map(Some)\n            }\n            Self::NUMBER => {\n                compiler_llvm_context::eravm_evm_contract_context::block_number(context).map(Some)\n            }\n            Self::TIMESTAMP => {\n                compiler_llvm_context::eravm_evm_contract_context::block_timestamp(context)\n                    .map(Some)\n            }\n            Self::BLOCKHASH(arguments) => {\n                let arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                let index = arguments[0].into_int_value();\n\n                compiler_llvm_context::eravm_evm_contract_context::block_hash(context, index)\n                    .map(Some)\n            }\n            Self::DIFFICULTY => {\n                compiler_llvm_context::eravm_evm_contract_context::difficulty(context).map(Some)\n            }\n            Self::COINBASE => {\n                compiler_llvm_context::eravm_evm_contract_context::coinbase(context).map(Some)\n            }\n            Self::BASEFEE => {\n                compiler_llvm_context::eravm_evm_contract_context::basefee(context).map(Some)\n            }\n            Self::MSIZE => {\n                compiler_llvm_context::eravm_evm_contract_context::msize(context).map(Some)\n            }\n\n            Self::CALLCODE(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 7>(arguments, context)?;\n                anyhow::bail!(\"The `CALLCODE` instruction is not supported\")\n            }\n            Self::PC => anyhow::bail!(\"The `PC` instruction is not supported\"),\n            Self::EXTCODECOPY(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 4>(arguments, context)?;\n                anyhow::bail!(\"The `EXTCODECOPY` instruction is not supported\")\n            }\n            Self::SELFDESTRUCT(arguments) => {\n                let _arguments = Self::translate_arguments_llvm::<D, 1>(arguments, context)?;\n                anyhow::bail!(\"The `SELFDESTRUCT` instruction is not supported\")\n            }\n\n            Self::Unknown(value) => {\n                anyhow::bail!(\"Unknown LLL instruction: {}\", value);\n            }\n        }\n    }\n}\n", "//!\n//! The offset instructions.\n//!\n\nuse inkwell::values::BasicValue;\n\n///\n/// Translates the Vyper LLL-specific `ceil32` instruction.\n///\npub fn ceil_32<'ctx, D>(\n    context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    value: inkwell::values::IntValue<'ctx>,\n) -> anyhow::Result<inkwell::values::BasicValueEnum<'ctx>>\nwhere\n    D: compiler_llvm_context::EraVMDependency + Clone,\n{\n    let remainder = context.builder().build_int_unsigned_rem(\n        value,\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"ceil32_remainder\",\n    );\n    let shift = context.builder().build_int_sub(\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        remainder,\n        \"ceil32_shift\",\n    );\n    let shift_remainder = context.builder().build_int_unsigned_rem(\n        shift,\n        context.field_const(compiler_common::BYTE_LENGTH_FIELD as u64),\n        \"ceil32_shift_remainder\",\n    );\n    let result = context\n        .builder()\n        .build_int_add(value, shift_remainder, \"ceil32_ceiled\");\n    Ok(result.as_basic_value_enum())\n}\n", "//!\n//! The `repeat` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `repeat` instruction.\n///\n/// The instruction describes a well-known for-loop.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Repeat(Vec<Expression>);\n\nimpl Repeat {\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        self.0\n            .last_mut()\n            .expect(\"Always exists\")\n            .extract_functions()\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let index_identifier = self.0.remove(0).try_into_identifier()?;\n        let start = self.0.remove(0);\n        let rounds = self.0.remove(0);\n        let _rounds_bound = self.0.remove(0);\n        let body = self.0.remove(0);\n\n        let condition_block = context.append_basic_block(\"repeat_condition\");\n        let body_block = context.append_basic_block(\"repeat_body\");\n        let increment_block = context.append_basic_block(\"repeat_increment\");\n        let join_block = context.append_basic_block(\"repeat_join\");\n\n        let start = start.into_llvm_value(context)?.expect(\"Always exists\");\n        let rounds = rounds.into_llvm_value(context)?.expect(\"Always exists\");\n        let rounds_pointer = context.build_alloca(context.field_type(), \"repeat_rounds\");\n        context.build_store(rounds_pointer, context.field_const(0));\n\n        let index_pointer = context.build_alloca(context.field_type(), \"repeat_index_pointer\");\n        context.build_store(index_pointer, start);\n        context\n            .current_function()\n            .borrow_mut()\n            .insert_stack_pointer(index_identifier.clone(), index_pointer);\n        context.build_unconditional_branch(condition_block);\n\n        context.set_basic_block(condition_block);\n        let rounds_value = context.build_load(rounds_pointer, \"repeat_condition_rounds_value\");\n        let condition = context.builder().build_int_compare(\n            inkwell::IntPredicate::ULT,\n            rounds_value.into_int_value(),\n            rounds.into_int_value(),\n            \"repeat_condition_compared\",\n        );\n        context.build_conditional_branch(condition, body_block, join_block);\n\n        context.push_loop(body_block, increment_block, join_block);\n\n        context.set_basic_block(body_block);\n        body.into_llvm_value(context)?;\n        context.build_unconditional_branch(increment_block);\n\n        context.set_basic_block(increment_block);\n        let index_value = context.build_load(index_pointer, \"repeat_increment_index_value\");\n        let index_value_incremented = context.builder().build_int_add(\n            index_value.into_int_value(),\n            context.field_const(1),\n            \"repeat_increment_index_value_incremented\",\n        );\n        context.build_store(index_pointer, index_value_incremented);\n\n        let rounds_value = context.build_load(rounds_pointer, \"repeat_increment_rounds_value\");\n        let rounds_value_incremented = context.builder().build_int_add(\n            rounds_value.into_int_value(),\n            context.field_const(1),\n            \"repeat_rounds_value_incremented\",\n        );\n        context.build_store(rounds_pointer, rounds_value_incremented);\n        context.build_unconditional_branch(condition_block);\n\n        context.pop_loop();\n        context\n            .current_function()\n            .borrow_mut()\n            .remove_stack_pointer(index_identifier.as_str());\n        context.set_basic_block(join_block);\n\n        Ok(())\n    }\n}\n", "//!\n//! The `return` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::instruction::Instruction;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The `return` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Return([Box<Expression>; 2]);\n\nimpl Default for Return {\n    fn default() -> Self {\n        let offset = Expression::IntegerLiteral(serde_json::Number::from(0));\n        let size = Expression::IntegerLiteral(serde_json::Number::from(0));\n        Self([Box::new(offset), Box::new(size)])\n    }\n}\n\nimpl Return {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let arguments = Instruction::translate_arguments_llvm::<D, 2>(self.0, context)?;\n        compiler_llvm_context::eravm_evm_return::r#return(\n            context,\n            arguments[0].into_int_value(),\n            arguments[1].into_int_value(),\n        )\n    }\n}\n", "//!\n//! The `revert` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::instruction::Instruction;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The `revert` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Revert([Box<Expression>; 2]);\n\nimpl Default for Revert {\n    fn default() -> Self {\n        let offset = Expression::IntegerLiteral(serde_json::Number::from(0));\n        let size = Expression::IntegerLiteral(serde_json::Number::from(0));\n        Self([Box::new(offset), Box::new(size)])\n    }\n}\n\nimpl Revert {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let arguments = Instruction::translate_arguments_llvm::<D, 2>(self.0, context)?;\n        compiler_llvm_context::eravm_evm_return::revert(\n            context,\n            arguments[0].into_int_value(),\n            arguments[1].into_int_value(),\n        )\n    }\n}\n", "//!\n//! The `seq` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::instruction::label::Label as LabelInstruction;\nuse crate::project::contract::vyper::expression::instruction::r#return::Return as ReturnInstruction;\nuse crate::project::contract::vyper::expression::instruction::revert::Revert as RevertInstruction;\nuse crate::project::contract::vyper::expression::instruction::Instruction;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The `seq` instruction.\n///\n/// This instruction contains a lot of methods to adjust the Vyper LLL structure to that of our\n/// smart contract architecture or the structure of LLVM IR.\n/// Among the methods there are tools of extracting the runtime code from the deploy code's\n/// return statement and some logic of hoisting the contract methods to the upper levels.\n///\n#[derive(Debug, Default, Serialize, Deserialize, Clone)]\npub struct Seq(Vec<Expression>);\n\nimpl Seq {\n    ///\n    /// Checks whether the sequence only contains a single pass.\n    ///\n    pub fn is_pass_or_empty(&self) -> bool {\n        if self.0.len() > 1 {\n            return false;\n        }\n\n        match self.0.get(0) {\n            Some(Expression::Instruction(Instruction::Pass)) => true,\n            Some(_) => false,\n            None => true,\n        }\n    }\n\n    ///\n    /// Extracts the runtime code expression from the deploy code.\n    ///\n    pub fn extract_runtime_code(&mut self) -> anyhow::Result<Option<(Self, Expression)>> {\n        for expression in self.0.iter_mut() {\n            if let Ok(Some(result)) = expression.extract_runtime_code() {\n                return Ok(Some(result));\n            }\n        }\n        Ok(None)\n    }\n\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        let mut index = 0;\n        let mut functions = BTreeMap::new();\n\n        while let Some(expression) = self.0.get_mut(index) {\n            if expression.is_function()? {\n                let name = expression.function_name()?;\n                functions.insert(name, self.0.remove(index));\n            } else {\n                functions.extend(expression.extract_functions()?);\n                index += 1;\n            }\n        }\n\n        Ok(functions)\n    }\n\n    ///\n    /// Drains the expression list and splits it into labels and the rest.\n    ///\n    pub fn drain_and_split(&mut self) -> (Vec<LabelInstruction>, Vec<Expression>) {\n        let mut labels = Vec::with_capacity(2);\n        let mut expressions = Vec::with_capacity(self.0.len());\n\n        for expression in self.0.drain(..) {\n            match expression {\n                Expression::Instruction(Instruction::Label(label)) => labels.push(label),\n                expression => expressions.push(expression),\n            }\n        }\n\n        (labels, expressions)\n    }\n\n    ///\n    /// Normalizes the deploy code by inserting an empty return.\n    ///\n    /// If the deploy code does not have a terminator, a normal return is inserted.\n    ///\n    pub fn normalize_deploy_code(&mut self) {\n        if self.0.is_empty()\n            || matches!(\n                self.0.get(0),\n                Some(Expression::Instruction(Instruction::Deploy(_)))\n            )\n        {\n            self.0.push(Expression::Instruction(Instruction::RETURN(\n                ReturnInstruction::default(),\n            )))\n        }\n    }\n\n    ///\n    /// Normalizes the runtime code by inserting an empty return.\n    ///\n    /// If the runtime code does not have a terminator, a revert is inserted.\n    ///\n    pub fn normalize_runtime_code(&mut self) {\n        if !self.0.is_empty() {\n            return;\n        }\n\n        self.0.push(Expression::Instruction(Instruction::REVERT(\n            RevertInstruction::default(),\n        )))\n    }\n\n    ///\n    /// Whether the sequence is a function entry block.\n    ///\n    pub fn is_function(&self) -> anyhow::Result<bool> {\n        match self.0.first() {\n            Some(Expression::Instruction(Instruction::Label(label))) => label.is_function_entry(),\n            _ => Ok(false),\n        }\n    }\n\n    ///\n    /// Returns the function name.\n    ///\n    pub fn function_name(&self) -> anyhow::Result<String> {\n        match self.0.first() {\n            Some(Expression::Instruction(Instruction::Label(label))) => label.name(),\n            expression => anyhow::bail!(\"Expected a function sequence, found `{:?}`\", expression),\n        }\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let (mut labels, expressions) = self.drain_and_split();\n\n        for label in labels.iter_mut() {\n            label.declare(context)?;\n        }\n        for label in labels.into_iter() {\n            label.into_llvm_value(context)?;\n        }\n\n        let mut result = None;\n        for expression in expressions.into_iter() {\n            if context.basic_block().get_terminator().is_some() {\n                break;\n            }\n\n            result = expression.into_llvm_value(context)?;\n        }\n\n        Ok(result)\n    }\n}\n\nimpl<D> compiler_llvm_context::EraVMWriteLLVM<D> for Seq\nwhere\n    D: compiler_llvm_context::EraVMDependency + Clone,\n{\n    fn into_llvm(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()> {\n        let current_block = context.basic_block();\n\n        let (mut labels, expressions) = self.drain_and_split();\n\n        for label in labels.iter_mut() {\n            label.declare(context)?;\n        }\n        for label in labels.into_iter() {\n            label.into_llvm_value(context)?;\n        }\n\n        context.set_basic_block(current_block);\n        for expression in expressions.into_iter() {\n            expression.into_llvm_value(context)?;\n        }\n\n        Ok(())\n    }\n}\n", "//!\n//! The `set` instruction.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `set` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Set([Box<Expression>; 2]);\n\nimpl Set {\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let [identifier, value] = self.0;\n        let identifier = identifier.try_into_identifier()?;\n\n        let pointer = context\n            .current_function()\n            .borrow()\n            .get_stack_pointer(identifier.as_str())\n            .ok_or_else(|| anyhow::anyhow!(\"Variable `{}` not found\", identifier))?;\n\n        let value = value\n            .into_llvm_value(context)?\n            .ok_or_else(|| anyhow::anyhow!(\"Expected a value\"))?;\n        context.build_store(pointer, value);\n\n        Ok(())\n    }\n}\n", "//!\n//! The `with` instruction.\n//!\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper LLL-specific `with` instruction.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct With([Box<Expression>; 3]);\n\nimpl With {\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        self.0\n            .get_mut(2)\n            .expect(\"Always exists\")\n            .extract_functions()\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let [identifier, value, block] = self.0;\n        let identifier = identifier.try_into_identifier()?;\n\n        let pointer = context.build_alloca(context.field_type(), identifier.as_str());\n        let value = value\n            .into_llvm_value(context)?\n            .ok_or_else(|| anyhow::anyhow!(\"Expected a value\"))?;\n        context.build_store(pointer, value);\n        let shadowed_pointer = context\n            .current_function()\n            .borrow_mut()\n            .insert_stack_pointer(identifier.clone(), pointer);\n\n        let result = block.into_llvm_value(context)?;\n\n        match shadowed_pointer {\n            Some(old_pointer) => {\n                context\n                    .current_function()\n                    .borrow_mut()\n                    .insert_stack_pointer(identifier, old_pointer);\n            }\n            None => {\n                context\n                    .current_function()\n                    .borrow_mut()\n                    .remove_stack_pointer(identifier.as_str());\n            }\n        }\n\n        Ok(result)\n    }\n}\n", "//!\n//! The `vyper -f ir_json` output.\n//!\n\npub mod instruction;\n\nuse std::collections::BTreeMap;\n\nuse inkwell::values::BasicValue;\nuse serde::Deserialize;\nuse serde::Serialize;\nuse serde_json::Number;\n\nuse self::instruction::seq::Seq as SeqInstruction;\nuse self::instruction::Instruction;\n\n///\n/// The LLL IR JSON expression.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(untagged)]\npub enum Expression {\n    /// The LLL IR instruction.\n    Instruction(Instruction),\n    /// The LLL IR integer literal.\n    IntegerLiteral(Number),\n    /// The LLL IR identifier.\n    Identifier(String),\n\n    /// The LLL unknown variant trap.\n    Unknown(serde_json::Value),\n}\n\nimpl Default for Expression {\n    fn default() -> Self {\n        Self::Instruction(Instruction::Seq(SeqInstruction::default()))\n    }\n}\n\nimpl Expression {\n    ///\n    /// Extracts the deploy code expression.\n    ///\n    pub fn try_into_deploy_code(self) -> anyhow::Result<SeqInstruction> {\n        match self {\n            Self::Instruction(Instruction::Seq(mut sequence)) => {\n                sequence.normalize_deploy_code();\n                Ok(sequence)\n            }\n            Self::Instruction(Instruction::Deploy(_deploy)) => {\n                let mut sequence = SeqInstruction::default();\n                sequence.normalize_deploy_code();\n                Ok(sequence)\n            }\n            instruction => anyhow::bail!(\"Expected [`seq`, `deploy`], found `{:?}`\", instruction),\n        }\n    }\n\n    ///\n    /// Extracts the runtime code expression from the deploy code.\n    ///\n    pub fn extract_runtime_code(&mut self) -> anyhow::Result<Option<(SeqInstruction, Self)>> {\n        match self {\n            Self::Instruction(Instruction::Seq(ref mut sequence)) => {\n                match sequence.extract_runtime_code()? {\n                    Some((mut runtime_code, immutables_size)) => {\n                        runtime_code.normalize_runtime_code();\n                        Ok(Some((runtime_code, immutables_size)))\n                    }\n                    None => Ok(None),\n                }\n            }\n            Self::Instruction(Instruction::Deploy(ref mut deploy)) => {\n                let (mut runtime_code, immutables_size) = deploy.extract_runtime_code()?;\n                runtime_code.normalize_runtime_code();\n                Ok(Some((runtime_code, immutables_size)))\n            }\n            instruction => anyhow::bail!(\"Expected [`seq`, `deploy`], found `{:?}`\", instruction),\n        }\n    }\n\n    ///\n    /// Converts the entity to an identifier.\n    ///\n    pub fn try_into_identifier(&self) -> anyhow::Result<String> {\n        match self {\n            Self::Identifier(string) => Ok(string.to_owned()),\n            expression => anyhow::bail!(\"Expected identifier, found `{:?}`\", expression),\n        }\n    }\n\n    ///\n    /// Extracts the functions from the deploy or runtime code.\n    ///\n    pub fn extract_functions(&mut self) -> anyhow::Result<BTreeMap<String, Expression>> {\n        match self {\n            Self::Instruction(inner) => inner.extract_functions(),\n            _ => Ok(BTreeMap::new()),\n        }\n    }\n\n    ///\n    /// Whether the expression is a function entry block.\n    ///\n    pub fn is_function(&self) -> anyhow::Result<bool> {\n        match self {\n            Self::Instruction(instruction) => instruction.is_function(),\n            _ => Ok(false),\n        }\n    }\n\n    ///\n    /// Returns the function name.\n    ///\n    pub fn function_name(&self) -> anyhow::Result<String> {\n        match self {\n            Expression::Instruction(inner) => inner.function_name(),\n            expression => anyhow::bail!(\"Expected a function sequence, found `{:?}`\", expression),\n        }\n    }\n\n    ///\n    /// Converts the entity to an LLVM value.\n    ///\n    pub fn into_llvm_value<'ctx, D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<'ctx, D>,\n    ) -> anyhow::Result<Option<inkwell::values::BasicValueEnum<'ctx>>>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        match self {\n            Self::Instruction(inner) => inner.into_llvm_value(context),\n            Self::IntegerLiteral(number) => {\n                let string = number.to_string();\n\n                let value = if let Some(string) = string.strip_prefix('-') {\n                    let modulo = context.field_const_str_dec(string);\n                    let max_value_diff = context.builder().build_int_sub(\n                        modulo,\n                        context.field_const(1),\n                        \"max_value_diff\",\n                    );\n                    let max_value = context.field_type().const_all_ones();\n                    let value = context.builder().build_int_sub(\n                        max_value,\n                        max_value_diff,\n                        \"negative_value\",\n                    );\n                    value.as_basic_value_enum()\n                } else {\n                    context\n                        .field_const_str_dec(string.as_str())\n                        .as_basic_value_enum()\n                };\n\n                Ok(Some(value))\n            }\n            Self::Identifier(identifier) => {\n                if identifier.as_str() == crate::r#const::DEFAULT_SEQUENCE_IDENTIFIER {\n                    context.build_exit(\n                        context.intrinsics().revert,\n                        context.field_const(0),\n                        context.field_const(0),\n                    );\n                }\n\n                let value = match context\n                    .current_function()\n                    .borrow()\n                    .get_stack_pointer(identifier.as_str())\n                {\n                    Some(pointer) => context.build_load(pointer, identifier.as_str()),\n                    None => context.field_const(0).as_basic_value_enum(),\n                };\n\n                Ok(Some(value))\n            }\n\n            Self::Unknown(value) => {\n                anyhow::bail!(\"Unknown LLL expression: {}\", value);\n            }\n        }\n    }\n}\n", "//!\n//! The Vyper contract function.\n//!\n\nuse inkwell::types::BasicType;\n\nuse compiler_llvm_context::EraVMDependency;\nuse compiler_llvm_context::EraVMWriteLLVM;\n\nuse crate::metadata::function::Function as FunctionMetadata;\nuse crate::project::contract::vyper::expression::Expression;\n\n///\n/// The Vyper contract function.\n///\n#[derive(Debug)]\npub struct Function {\n    /// The function name.\n    pub name: String,\n    /// The function metadata.\n    pub metadata: Option<FunctionMetadata>,\n    /// The function body expression.\n    pub expression: Expression,\n}\n\nimpl Function {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(name: String, metadata: Option<FunctionMetadata>, expression: Expression) -> Self {\n        Self {\n            name,\n            metadata,\n            expression,\n        }\n    }\n}\n\nimpl<D> EraVMWriteLLVM<D> for Function\nwhere\n    D: EraVMDependency + Clone,\n{\n    fn declare(\n        &mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()> {\n        let mut argument_types = vec![];\n        if self\n            .name\n            .starts_with(crate::r#const::FUNCTION_PREFIX_INTERNAL)\n        {\n            if let Some(ref metadata) = self.metadata {\n                if !metadata.return_type.is_empty() && metadata.return_type != \"None\" {\n                    argument_types.push(context.field_type().as_basic_type_enum());\n                }\n            }\n        }\n\n        let function = context.add_function(\n            self.name.as_str(),\n            context.function_type(argument_types, 0, false),\n            0,\n            Some(inkwell::module::Linkage::Private),\n        )?;\n        function\n            .borrow_mut()\n            .set_vyper_data(compiler_llvm_context::EraVMFunctionVyperData::default());\n\n        Ok(())\n    }\n\n    fn into_llvm(self, context: &mut compiler_llvm_context::EraVMContext<D>) -> anyhow::Result<()> {\n        context.set_current_function(self.name.as_str())?;\n\n        let llvm_entry_block = context.current_function().borrow().entry_block();\n        let llvm_value = context.current_function().borrow().declaration().value;\n\n        self.expression.into_llvm_value(context)?;\n\n        context.set_basic_block(llvm_entry_block);\n        let ir_entry_block = llvm_value\n            .get_basic_blocks()\n            .iter()\n            .find(|block| block.get_name().to_string_lossy() == self.name)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Block `{}` does not exist\", self.name))?;\n        context.build_unconditional_branch(ir_entry_block);\n\n        context.set_basic_block(context.current_function().borrow().return_block());\n        context.build_return(None);\n\n        for block in llvm_value.get_basic_blocks() {\n            if block.get_terminator().is_none() {\n                context.set_basic_block(block);\n                context.build_exit(\n                    context.intrinsics().revert,\n                    context.field_const(0),\n                    context.field_const(0),\n                );\n            }\n        }\n\n        Ok(())\n    }\n}\n", "//!\n//! The Vyper contract.\n//!\n\npub mod expression;\npub mod function;\n\nuse std::collections::BTreeMap;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse compiler_llvm_context::EraVMDependency;\nuse compiler_llvm_context::EraVMWriteLLVM;\n\nuse crate::build::contract::Contract as ContractBuild;\nuse crate::metadata::Metadata as SourceMetadata;\nuse crate::project::contract::metadata::Metadata as ContractMetadata;\nuse crate::project::dependency_data::DependencyData;\n\nuse self::expression::Expression;\nuse self::function::Function;\n\n///\n/// The Vyper contract.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Contract {\n    /// The Vyper compiler version.\n    pub version: semver::Version,\n    /// The Vyper contract source code.\n    pub source_code: String,\n    /// The source metadata.\n    pub source_metadata: SourceMetadata,\n    /// The inner expression.\n    pub expression: Expression,\n    /// The contract ABI data.\n    pub abi: BTreeMap<String, String>,\n    /// The dependency data.\n    pub dependency_data: DependencyData,\n}\n\nimpl Contract {\n    /// The number of vyper compiler output lines per contract.\n    pub const EXPECTED_LINES: usize = 3;\n\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(\n        version: semver::Version,\n        source_code: String,\n        source_metadata: SourceMetadata,\n        expression: Expression,\n        abi: BTreeMap<String, String>,\n    ) -> Self {\n        Self {\n            version,\n            source_code,\n            source_metadata,\n            expression,\n            abi,\n            dependency_data: DependencyData::default(),\n        }\n    }\n\n    ///\n    /// Parses three lines with JSONs, returned by the Vyper compiler.\n    /// The order must be:\n    /// 1. The LLL IR JSON\n    /// 2. The contract functions metadata\n    /// 3. The contract ABI data\n    ///\n    pub fn try_from_lines(\n        version: semver::Version,\n        source_code: String,\n        mut lines: Vec<&str>,\n    ) -> anyhow::Result<Self> {\n        if lines.len() != Self::EXPECTED_LINES {\n            anyhow::bail!(\n                \"Expected {} lines with JSONs, found {}\",\n                Self::EXPECTED_LINES,\n                lines.len()\n            );\n        }\n\n        let mut deserializer = serde_json::Deserializer::from_str(lines.remove(0));\n        deserializer.disable_recursion_limit();\n        let deserializer = serde_stacker::Deserializer::new(&mut deserializer);\n        let expression = Expression::deserialize(deserializer)?;\n\n        let metadata: SourceMetadata = serde_json::from_str(lines.remove(0))?;\n\n        let abi: BTreeMap<String, String> = serde_json::from_str(lines.remove(0))?;\n\n        Ok(Self::new(version, source_code, metadata, expression, abi))\n    }\n\n    ///\n    /// Compiles the contract, returning the build.\n    ///\n    pub fn compile(\n        mut self,\n        contract_path: &str,\n        source_code_hash: Option<[u8; compiler_common::BYTE_LENGTH_FIELD]>,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<ContractBuild> {\n        let llvm = inkwell::context::Context::create();\n        let optimizer = compiler_llvm_context::Optimizer::new(optimizer_settings);\n\n        let metadata_hash = source_code_hash.map(|source_code_hash| {\n            ContractMetadata::new(\n                &source_code_hash,\n                &self.version,\n                semver::Version::parse(env!(\"CARGO_PKG_VERSION\")).expect(\"Always valid\"),\n                optimizer.settings().to_owned(),\n            )\n            .keccak256()\n        });\n\n        let dependency_data = DependencyData::default();\n        let mut context = compiler_llvm_context::EraVMContext::<DependencyData>::new(\n            &llvm,\n            llvm.create_module(contract_path),\n            optimizer,\n            Some(dependency_data),\n            metadata_hash.is_some(),\n            debug_config,\n        );\n\n        self.declare(&mut context).map_err(|error| {\n            anyhow::anyhow!(\n                \"The contract `{}` LLVM IR generator declaration pass error: {}\",\n                contract_path,\n                error\n            )\n        })?;\n        self.into_llvm(&mut context).map_err(|error| {\n            anyhow::anyhow!(\n                \"The contract `{}` LLVM IR generator definition pass error: {}\",\n                contract_path,\n                error\n            )\n        })?;\n\n        let is_forwarder_used = context.vyper().is_forwarder_used();\n        let mut build = context.build(contract_path, metadata_hash)?;\n\n        if is_forwarder_used {\n            build.factory_dependencies.insert(\n                crate::r#const::FORWARDER_CONTRACT_HASH.clone(),\n                crate::r#const::FORWARDER_CONTRACT_NAME.to_owned(),\n            );\n        }\n\n        Ok(ContractBuild::new(build))\n    }\n}\n\nimpl<D> EraVMWriteLLVM<D> for Contract\nwhere\n    D: EraVMDependency + Clone,\n{\n    fn declare(\n        &mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()> {\n        let mut entry = compiler_llvm_context::EraVMEntryFunction::default();\n        entry.declare(context)?;\n\n        let mut runtime = compiler_llvm_context::EraVMRuntime::new(\n            compiler_llvm_context::EraVMAddressSpace::HeapAuxiliary,\n        );\n        runtime.declare(context)?;\n\n        compiler_llvm_context::EraVMDeployCodeFunction::new(\n            compiler_llvm_context::EraVMDummyLLVMWritable::default(),\n        )\n        .declare(context)?;\n        compiler_llvm_context::EraVMRuntimeCodeFunction::new(\n            compiler_llvm_context::EraVMDummyLLVMWritable::default(),\n        )\n        .declare(context)?;\n\n        for name in [\n            compiler_llvm_context::EraVMRuntime::FUNCTION_DEPLOY_CODE,\n            compiler_llvm_context::EraVMRuntime::FUNCTION_RUNTIME_CODE,\n            compiler_llvm_context::EraVMRuntime::FUNCTION_ENTRY,\n        ]\n        .into_iter()\n        {\n            context\n                .get_function(name)\n                .expect(\"Always exists\")\n                .borrow_mut()\n                .set_vyper_data(compiler_llvm_context::EraVMFunctionVyperData::default());\n        }\n\n        entry.into_llvm(context)?;\n\n        runtime.into_llvm(context)?;\n\n        Ok(())\n    }\n\n    fn into_llvm(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()> {\n        let (mut runtime_code, immutables_size) =\n            self.expression.extract_runtime_code()?.unwrap_or_default();\n        let mut deploy_code = self.expression.try_into_deploy_code()?;\n\n        match immutables_size {\n            Expression::IntegerLiteral(number) => {\n                let immutables_size = number\n                    .as_u64()\n                    .ok_or_else(|| anyhow::anyhow!(\"Immutable size `{}` parsing error\", number))?;\n                let vyper_data = compiler_llvm_context::EraVMContextVyperData::new(\n                    immutables_size as usize,\n                    false,\n                );\n                context.set_vyper_data(vyper_data);\n            }\n            expression => anyhow::bail!(\"Invalid immutables size format: {:?}\", expression),\n        }\n\n        let mut function_expressions = deploy_code\n            .extract_functions()?\n            .into_iter()\n            .map(|(label, expression)| {\n                (\n                    label,\n                    expression,\n                    compiler_llvm_context::EraVMCodeType::Deploy,\n                )\n            })\n            .collect::<Vec<(String, Expression, compiler_llvm_context::EraVMCodeType)>>();\n        function_expressions.extend(\n            runtime_code\n                .extract_functions()?\n                .into_iter()\n                .map(|(label, expression)| {\n                    (\n                        label,\n                        expression,\n                        compiler_llvm_context::EraVMCodeType::Runtime,\n                    )\n                })\n                .collect::<Vec<(String, Expression, compiler_llvm_context::EraVMCodeType)>>(),\n        );\n\n        let mut functions = Vec::with_capacity(function_expressions.capacity());\n        for (label, expression, code_type) in function_expressions.into_iter() {\n            let mut metadata_label = label\n                .strip_suffix(format!(\"_{}\", compiler_llvm_context::EraVMCodeType::Deploy).as_str())\n                .unwrap_or(label.as_str());\n            metadata_label = label\n                .strip_suffix(\n                    format!(\"_{}\", compiler_llvm_context::EraVMCodeType::Runtime).as_str(),\n                )\n                .unwrap_or(metadata_label);\n            metadata_label = label\n                .strip_suffix(format!(\"_{}\", crate::r#const::LABEL_SUFFIX_COMMON).as_str())\n                .unwrap_or(metadata_label);\n\n            let metadata_name =\n                self.source_metadata\n                    .function_info\n                    .iter()\n                    .find_map(|(name, function)| {\n                        if metadata_label == function.ir_identifier.as_str() {\n                            Some(name.to_owned())\n                        } else {\n                            None\n                        }\n                    });\n            let metadata = match metadata_name {\n                Some(metadata_name) => self\n                    .source_metadata\n                    .function_info\n                    .get(metadata_name.as_str())\n                    .cloned(),\n                None => None,\n            };\n            functions.push((Function::new(label, metadata, expression), code_type));\n        }\n        for (function, _code_type) in functions.iter_mut() {\n            function.declare(context)?;\n        }\n        for (function, code_type) in functions.into_iter() {\n            context.set_code_type(code_type);\n            function.into_llvm(context)?;\n        }\n\n        compiler_llvm_context::EraVMDeployCodeFunction::new(deploy_code).into_llvm(context)?;\n        compiler_llvm_context::EraVMRuntimeCodeFunction::new(runtime_code).into_llvm(context)?;\n\n        Ok(())\n    }\n}\n\nimpl EraVMDependency for DependencyData {\n    fn compile(\n        _contract: Self,\n        _name: &str,\n        _optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        _is_system_mode: bool,\n        _include_metadata_hash: bool,\n        _debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<String> {\n        Ok(crate::r#const::FORWARDER_CONTRACT_HASH.clone())\n    }\n\n    fn resolve_path(&self, _identifier: &str) -> anyhow::Result<String> {\n        anyhow::bail!(\"The dependency mechanism is not available in Vyper\");\n    }\n\n    fn resolve_library(&self, _path: &str) -> anyhow::Result<String> {\n        anyhow::bail!(\"The dependency mechanism is not available in Vyper\");\n    }\n}\n", "//!\n//! The zkEVM assembly contract.\n//!\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\nuse crate::build::contract::Contract as ContractBuild;\nuse crate::project::contract::metadata::Metadata as ContractMetadata;\n\n///\n/// The zkEVM assembly contract.\n///\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Contract {\n    /// The zkEVM version.\n    pub version: semver::Version,\n    /// The contract source code.\n    pub source_code: String,\n}\n\nimpl Contract {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(version: semver::Version, source_code: String) -> Self {\n        Self {\n            version,\n            source_code,\n        }\n    }\n\n    ///\n    /// Compiles the contract, returning the build.\n    ///\n    pub fn compile(\n        self,\n        contract_path: &str,\n        source_code_hash: Option<[u8; compiler_common::BYTE_LENGTH_FIELD]>,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<ContractBuild> {\n        let metadata_hash = source_code_hash.map(|source_code_hash| {\n            ContractMetadata::new(\n                &source_code_hash,\n                &self.version,\n                semver::Version::parse(env!(\"CARGO_PKG_VERSION\")).expect(\"Always valid\"),\n                optimizer_settings,\n            )\n            .keccak256()\n        });\n\n        let build = compiler_llvm_context::eravm_build_assembly_text(\n            contract_path,\n            self.source_code.as_str(),\n            metadata_hash,\n            debug_config.as_ref(),\n        )?;\n\n        Ok(ContractBuild::new(build))\n    }\n}\n", "//!\n//! The Vyper project.\n//!\n\npub mod contract;\npub mod dependency_data;\n\nuse std::collections::BTreeMap;\nuse std::path::Path;\n\nuse rayon::iter::IntoParallelIterator;\nuse rayon::iter::ParallelIterator;\nuse sha3::Digest;\n\nuse crate::build::contract::Contract as ContractBuild;\nuse crate::build::Build;\nuse crate::process::input::Input as ProcessInput;\n\nuse self::contract::llvm_ir::Contract as LLVMIRContract;\nuse self::contract::zkasm::Contract as ZKASMContract;\nuse self::contract::Contract;\n\n///\n/// The Vyper project.\n///\n#[derive(Debug, Clone)]\npub struct Project {\n    /// The Vyper compiler version.\n    pub version: semver::Version,\n    /// The project source code hash.\n    pub source_code_hash: [u8; compiler_common::BYTE_LENGTH_FIELD],\n    /// The contract data,\n    pub contracts: BTreeMap<String, Contract>,\n}\n\nimpl Project {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new(\n        version: semver::Version,\n        source_code_hash: [u8; compiler_common::BYTE_LENGTH_FIELD],\n        contracts: BTreeMap<String, Contract>,\n    ) -> Self {\n        Self {\n            version,\n            source_code_hash,\n            contracts,\n        }\n    }\n\n    ///\n    /// Parses the LLVM IR source code file and returns the source data.\n    ///\n    pub fn try_from_llvm_ir_path(path: &Path) -> anyhow::Result<Self> {\n        let source_code = std::fs::read_to_string(path)\n            .map_err(|error| anyhow::anyhow!(\"LLVM IR file {:?} reading error: {}\", path, error))?;\n        let path = path.to_string_lossy().to_string();\n\n        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();\n\n        let mut project_contracts = BTreeMap::new();\n        project_contracts.insert(\n            path,\n            LLVMIRContract::new(\n                compiler_llvm_context::eravm_const::LLVM_VERSION,\n                source_code,\n            )\n            .into(),\n        );\n\n        Ok(Self::new(\n            compiler_llvm_context::eravm_const::LLVM_VERSION,\n            source_code_hash,\n            project_contracts,\n        ))\n    }\n\n    ///\n    /// Parses the zkEVM assembly source code file and returns the source data.\n    ///\n    pub fn try_from_zkasm_path(path: &Path) -> anyhow::Result<Self> {\n        let source_code = std::fs::read_to_string(path).map_err(|error| {\n            anyhow::anyhow!(\"zkEVM assembly file {:?} reading error: {}\", path, error)\n        })?;\n        let path = path.to_string_lossy().to_string();\n\n        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();\n\n        let mut project_contracts = BTreeMap::new();\n        project_contracts.insert(\n            path,\n            ZKASMContract::new(\n                compiler_llvm_context::eravm_const::ZKEVM_VERSION,\n                source_code,\n            )\n            .into(),\n        );\n\n        Ok(Self::new(\n            compiler_llvm_context::eravm_const::ZKEVM_VERSION,\n            source_code_hash,\n            project_contracts,\n        ))\n    }\n\n    ///\n    /// Compiles all contracts, returning the build.\n    ///\n    pub fn compile(\n        self,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        include_metadata_hash: bool,\n        bytecode_encoding: zkevm_assembly::RunningVmEncodingMode,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<Build> {\n        let mut build = Build::default();\n        let source_code_hash = if include_metadata_hash {\n            Some(self.source_code_hash)\n        } else {\n            None\n        };\n        let results: BTreeMap<String, anyhow::Result<ContractBuild>> = self\n            .contracts\n            .into_par_iter()\n            .map(|(full_path, contract)| {\n                let process_output = crate::process::call(ProcessInput::new(\n                    full_path.clone(),\n                    contract,\n                    source_code_hash,\n                    bytecode_encoding == zkevm_assembly::RunningVmEncodingMode::Testing,\n                    optimizer_settings.clone(),\n                    debug_config.clone(),\n                ));\n\n                (full_path, process_output.map(|output| output.build))\n            })\n            .collect();\n\n        let is_forwarder_used = results.iter().any(|(_path, result)| {\n            result\n                .as_ref()\n                .map(|contract| {\n                    contract\n                        .build\n                        .factory_dependencies\n                        .contains_key(crate::r#const::FORWARDER_CONTRACT_HASH.as_str())\n                })\n                .unwrap_or_default()\n        });\n        if is_forwarder_used {\n            let forwarder_build = compiler_llvm_context::EraVMBuild::new(\n                crate::r#const::FORWARDER_CONTRACT_ASSEMBLY.to_owned(),\n                None,\n                crate::r#const::FORWARDER_CONTRACT_BYTECODE.clone(),\n                crate::r#const::FORWARDER_CONTRACT_HASH.clone(),\n            );\n            build.contracts.insert(\n                crate::r#const::FORWARDER_CONTRACT_NAME.to_owned(),\n                ContractBuild::new(forwarder_build),\n            );\n        }\n\n        for (path, result) in results.into_iter() {\n            match result {\n                Ok(contract) => {\n                    build.contracts.insert(path, contract);\n                }\n                Err(error) => {\n                    anyhow::bail!(\"Contract `{}` compiling error: {:?}\", path, error);\n                }\n            }\n        }\n\n        Ok(build)\n    }\n}\n", "//!\n//! The Vyper compiler unit tests.\n//!\n\n#![cfg(test)]\n#![allow(dead_code)]\n\npub mod builtins;\n\nuse std::collections::BTreeMap;\nuse std::path::PathBuf;\n\nuse crate::vyper::standard_json::input::settings::evm_version::EVMVersion as VyperStandardJsonInputSettingsEVMVersion;\nuse crate::vyper::standard_json::input::settings::selection::Selection as VyperStandardJsonInputSettingsSelection;\nuse crate::vyper::standard_json::input::Input as VyperStandardJsonInput;\nuse crate::vyper::Compiler as VyperCompiler;\n\nfn check_dependencies() {\n    for executable in [\n        crate::r#const::DEFAULT_EXECUTABLE_NAME,\n        VyperCompiler::DEFAULT_EXECUTABLE_NAME,\n    ]\n    .iter()\n    {\n        assert!(\n            which::which(executable).is_ok(),\n            \"The `{executable}` executable not found in ${{PATH}}\"\n        );\n    }\n}\n\npub fn build_vyper(\n    source_code: &str,\n    version: semver::Version,\n    message_version: &str,\n) -> anyhow::Result<()> {\n    check_dependencies();\n\n    let vyper = VyperCompiler::new(VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned());\n    if vyper.version.default != version {\n        panic!(\"{}\", message_version);\n    }\n\n    inkwell::support::enable_llvm_pretty_stack_trace();\n    compiler_llvm_context::initialize_target(compiler_llvm_context::Target::EraVM);\n    let _ = crate::process::EXECUTABLE.set(PathBuf::from(crate::r#const::DEFAULT_EXECUTABLE_NAME));\n    let optimizer_settings = compiler_llvm_context::OptimizerSettings::none();\n\n    let mut sources = BTreeMap::new();\n    sources.insert(\"test.vy\".to_string(), source_code.to_string());\n    let input = VyperStandardJsonInput::try_from_sources(\n        sources.clone(),\n        VyperStandardJsonInputSettingsEVMVersion::Paris,\n        VyperStandardJsonInputSettingsSelection::generate_default(),\n        true,\n    )?;\n\n    let output = vyper.standard_json(input)?;\n\n    let project = output.try_into_project(&vyper.version.default)?;\n    let _build = project.compile(\n        optimizer_settings,\n        false,\n        zkevm_assembly::RunningVmEncodingMode::Production,\n        None,\n    )?;\n\n    Ok(())\n}\n", "//!\n//! The Vyper compiler.\n//!\n\npub mod combined_json;\npub mod standard_json;\npub mod version;\n\nuse std::collections::BTreeMap;\nuse std::io::Write;\nuse std::path::Path;\nuse std::path::PathBuf;\n\nuse rayon::iter::IndexedParallelIterator;\nuse rayon::iter::IntoParallelIterator;\nuse rayon::iter::ParallelIterator;\nuse sha3::digest::FixedOutput;\nuse sha3::Digest;\n\nuse crate::project::contract::vyper::Contract as VyperContract;\nuse crate::project::contract::Contract;\nuse crate::project::Project;\n\nuse self::combined_json::CombinedJson;\nuse self::standard_json::input::Input as StandardJsonInput;\nuse self::standard_json::output::Output as StandardJsonOutput;\nuse self::version::Version;\n\n///\n/// The Vyper compiler.\n///\npub struct Compiler {\n    /// The binary executable name.\n    pub executable: String,\n    /// The binary version.\n    pub version: Version,\n}\n\nimpl Compiler {\n    /// The default executable name.\n    pub const DEFAULT_EXECUTABLE_NAME: &'static str = \"vyper\";\n\n    /// The supported versions of `vyper`.\n    pub const SUPPORTED_VERSIONS: [semver::Version; 2 /* 3 */] = [\n        semver::Version::new(0, 3, 3),\n        semver::Version::new(0, 3, 9),\n        // semver::Version::new(0, 3, 10),\n    ];\n\n    ///\n    /// A shortcut constructor.\n    ///\n    /// Different tools may use different `executable` names. For example, the integration tester\n    /// uses `vyper-<version>` format.\n    ///\n    pub fn new(executable: String) -> Self {\n        let version = Self::version(&executable).expect(\"Version getting error\");\n        Self {\n            executable,\n            version,\n        }\n    }\n\n    ///\n    /// The `vyper -f combined_json input_files...` mirror.\n    ///\n    pub fn combined_json(&self, paths: &[PathBuf]) -> anyhow::Result<CombinedJson> {\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.arg(\"-f\");\n        command.arg(\"combined_json\");\n        command.args(paths);\n        if self.version.default >= semver::Version::new(0, 3, 10) {\n            command.arg(\"--no-optimize\");\n        }\n        let output = command.output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess error: {:?}\", self.executable, error)\n        })?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let combined_json = serde_json::from_slice(output.stdout.as_slice()).expect(\"Always valid\");\n\n        Ok(combined_json)\n    }\n\n    ///\n    /// The `vyper --standard-json` mirror.\n    ///\n    pub fn standard_json(\n        &self,\n        mut input: StandardJsonInput,\n    ) -> anyhow::Result<StandardJsonOutput> {\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.stdin(std::process::Stdio::piped());\n        command.stdout(std::process::Stdio::piped());\n        command.arg(\"--standard-json\");\n\n        if self.version.default >= semver::Version::new(0, 3, 10) {\n            input.settings.optimize = false;\n        }\n        let input_json = serde_json::to_vec(&input).expect(\"Always valid\");\n\n        let process = command.spawn().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess spawning error: {:?}\", self.executable, error)\n        })?;\n        process\n            .stdin\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"{} stdin getting error\", self.executable))?\n            .write_all(input_json.as_slice())\n            .map_err(|error| {\n                anyhow::anyhow!(\"{} stdin writing error: {:?}\", self.executable, error)\n            })?;\n\n        let output = process.wait_with_output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess output error: {:?}\", self.executable, error)\n        })?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let mut output: StandardJsonOutput = serde_json::from_slice(output.stdout.as_slice())\n            .map_err(|error| {\n                anyhow::anyhow!(\n                    \"{} subprocess output parsing error: {}\\n{}\",\n                    self.executable,\n                    error,\n                    serde_json::from_slice::<serde_json::Value>(output.stdout.as_slice())\n                        .map(|json| serde_json::to_string_pretty(&json).expect(\"Always valid\"))\n                        .unwrap_or_else(\n                            |_| String::from_utf8_lossy(output.stdout.as_slice()).to_string()\n                        ),\n                )\n            })?;\n\n        for (full_path, source) in input.sources.into_iter() {\n            let last_slash_position = full_path.rfind('/');\n            let last_dot_position = full_path.rfind('.');\n            let contract_name = &full_path[last_slash_position.unwrap_or_default()\n                ..last_dot_position.unwrap_or(full_path.len())];\n\n            Self::check_unsupported(source.content.as_str())\n                .map_err(|error| anyhow::anyhow!(\"Contract `{}`: {}\", full_path, error))?;\n\n            output\n                .files\n                .as_mut()\n                .ok_or_else(|| anyhow::anyhow!(\"No contracts in the standard JSON output\"))?\n                .get_mut(full_path.as_str())\n                .ok_or_else(|| {\n                    anyhow::anyhow!(\"File `{}` not found in the standard JSON output\", full_path)\n                })?\n                .get_mut(contract_name)\n                .ok_or_else(|| {\n                    anyhow::anyhow!(\n                        \"Contract `{}` not found in the standard JSON output\",\n                        contract_name\n                    )\n                })?\n                .source_code = Some(source.content);\n        }\n\n        Ok(output)\n    }\n\n    ///\n    /// Returns the Vyper LLL in the native format for the contract at `path`.\n    ///\n    /// Is used to print the IR for debugging.\n    ///\n    pub fn lll_debug(&self, path: &Path, optimize: bool) -> anyhow::Result<String> {\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.arg(\"-f\");\n        command.arg(\"ir\");\n        if !optimize || self.version.default >= semver::Version::new(0, 3, 10) {\n            command.arg(\"--no-optimize\");\n        }\n        command.arg(path);\n\n        let output = command.output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess error: {:?}\", self.executable, error)\n        })?;\n\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let stdout = String::from_utf8_lossy(output.stdout.as_slice()).to_string();\n\n        Ok(stdout)\n    }\n\n    ///\n    /// Returns all the Vyper data required to compile the contracts at `paths`.\n    ///\n    pub fn batch(\n        &self,\n        version: &semver::Version,\n        mut paths: Vec<PathBuf>,\n        optimize: bool,\n    ) -> anyhow::Result<Project> {\n        paths.sort();\n\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.arg(\"-f\");\n        command.arg(\"ir_json,metadata,method_identifiers\");\n        if !optimize || self.version.default >= semver::Version::new(0, 3, 10) {\n            command.arg(\"--no-optimize\");\n        }\n        command.args(paths.as_slice());\n\n        let output = command.output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess error: {:?}\", self.executable, error)\n        })?;\n\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let stdout = String::from_utf8_lossy(output.stdout.as_slice()).to_string();\n        let lines: Vec<&str> = stdout.lines().collect();\n        let results: BTreeMap<String, anyhow::Result<VyperContract>> = paths\n            .into_par_iter()\n            .zip(lines.into_par_iter().chunks(3))\n            .map(|(path, group)| {\n                let path_str = path.to_string_lossy().to_string();\n                let source_code = match std::fs::read_to_string(path).map_err(|error| {\n                    anyhow::anyhow!(\"Source code file `{}` reading error: {}\", path_str, error)\n                }) {\n                    Ok(source_code) => source_code,\n                    Err(error) => return (path_str, Err(error)),\n                };\n\n                if let Err(error) = Self::check_unsupported(source_code.as_str()) {\n                    let error = anyhow::anyhow!(\"Contract `{}`: {}\", path_str, error);\n                    return (path_str, Err(error));\n                }\n\n                let contract_result =\n                    VyperContract::try_from_lines(version.to_owned(), source_code, group.to_vec())\n                        .map_err(|error| {\n                            anyhow::anyhow!(\n                                \"Contract `{}` JSON output parsing: {}\",\n                                path_str,\n                                error\n                            )\n                        });\n\n                (path_str, contract_result)\n            })\n            .collect();\n        let contracts =\n            results\n                .into_iter()\n                .try_fold(BTreeMap::new(), |mut accumulator, (path, result)| {\n                    accumulator.insert(path, result?.into());\n                    Ok::<BTreeMap<String, Contract>, anyhow::Error>(accumulator)\n                })?;\n\n        let mut source_code_hasher = sha3::Keccak256::new();\n        for (_path, contract) in contracts.iter() {\n            source_code_hasher.update(contract.source_code().as_bytes());\n        }\n        let source_code_hash: [u8; compiler_common::BYTE_LENGTH_FIELD] =\n            source_code_hasher.finalize_fixed().into();\n\n        let project = Project::new(version.to_owned(), source_code_hash, contracts);\n\n        Ok(project)\n    }\n\n    ///\n    /// The `vyper -f <identifiers> ...` mirror.\n    ///\n    pub fn extra_output(&self, path: &Path, extra_output: &str) -> anyhow::Result<String> {\n        let mut command = std::process::Command::new(self.executable.as_str());\n        command.arg(\"-f\");\n        command.arg(extra_output);\n        command.arg(path);\n        let output = command.output().map_err(|error| {\n            anyhow::anyhow!(\"{} subprocess error: {:?}\", self.executable, error)\n        })?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                self.executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        Ok(String::from_utf8_lossy(output.stdout.as_slice()).to_string())\n    }\n\n    ///\n    /// Checks for unsupported code is a Vyper source code file.\n    ///\n    pub fn check_unsupported(source_code: &str) -> anyhow::Result<()> {\n        for function in [\n            crate::r#const::FORBIDDEN_FUNCTION_NAME_CREATE_COPY_OF,\n            crate::r#const::FORBIDDEN_FUNCTION_NAME_CREATE_FROM_BLUEPRINT,\n        ] {\n            if source_code.contains(function) {\n                return Err(anyhow::anyhow!(\n                    \"Built-in function `{}` is not supported\",\n                    function\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    ///\n    /// The `vyper --version` mini-parser.\n    ///\n    fn version(executable: &str) -> anyhow::Result<Version> {\n        let mut command = std::process::Command::new(executable);\n        command.arg(\"--version\");\n        let output = command\n            .output()\n            .map_err(|error| anyhow::anyhow!(\"{} subprocess error: {:?}\", executable, error))?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"{} error: {}\",\n                executable,\n                String::from_utf8_lossy(output.stderr.as_slice()).to_string()\n            );\n        }\n\n        let stdout = String::from_utf8_lossy(output.stdout.as_slice());\n        let long = stdout.to_string();\n        let default: semver::Version = long\n            .split('+')\n            .next()\n            .ok_or_else(|| anyhow::anyhow!(\"{} version parsing: metadata dropping\", executable))?\n            .parse()\n            .map_err(|error| anyhow::anyhow!(\"{} version parsing: {}\", executable, error))?;\n\n        let version = Version::new(long, default);\n        if !Self::SUPPORTED_VERSIONS.contains(&version.default) {\n            anyhow::bail!(\n                \"Only `vyper` versions [ {} ] are supported, found {}\",\n                Self::SUPPORTED_VERSIONS\n                    .into_iter()\n                    .map(|version| version.to_string())\n                    .collect::<Vec<String>>()\n                    .join(\", \"),\n                version.default,\n            );\n        }\n\n        Ok(version)\n    }\n}\n", "//!\n//! Vyper to zkEVM compiler arguments.\n//!\n\nuse std::path::PathBuf;\n\nuse structopt::StructOpt;\n\n///\n/// Pythonic Smart Contract Language for the zkEVM.\n///\n/// Example: `zkvyper ERC20.vy`\n///\n#[derive(Debug, StructOpt)]\n#[structopt(name = \"The zkEVM Vyper compiler\")]\npub struct Arguments {\n    /// Print the version and exit.\n    #[structopt(long = \"version\")]\n    pub version: bool,\n\n    /// Specify the input file paths.\n    /// Multiple Vyper files can be passed in the default Vyper mode.\n    /// LLVM IR mode currently supports only a single file.\n    #[structopt(parse(from_os_str))]\n    pub input_files: Vec<PathBuf>,\n\n    /// Create one file per component and contract/file at the specified directory, if given.\n    #[structopt(short = \"o\", long = \"output-dir\")]\n    pub output_directory: Option<PathBuf>,\n\n    /// Overwrite existing files (used together with -o).\n    #[structopt(long = \"overwrite\")]\n    pub overwrite: bool,\n\n    /// Set the optimization parameter -O[0 | 1 | 2 | 3 | s | z].\n    /// Use `3` for best performance and `z` for minimal size.\n    #[structopt(short = \"O\", long = \"optimization\")]\n    pub optimization: Option<char>,\n\n    /// Disable the `vyper` LLL IR optimizer.\n    #[structopt(long = \"disable-vyper-optimizer\")]\n    pub disable_vyper_optimizer: bool,\n\n    /// Specify the path to the `vyper` executable. By default, the one in `${PATH}` is used.\n    /// In LLVM IR mode `vyper` is unused.\n    #[structopt(long = \"vyper\")]\n    pub vyper: Option<String>,\n\n    /// An extra output format string.\n    /// See `vyper --help` for available options including combined JSON mode.\n    #[structopt(short = \"f\")]\n    pub format: Option<String>,\n\n    /// Switch to LLVM IR mode.\n    /// Only one input LLVM IR file is allowed.\n    /// Cannot be used with combined JSON mode.\n    /// Use this mode at your own risk, as LLVM IR input validation is not implemented.\n    #[structopt(long = \"llvm-ir\")]\n    pub llvm_ir: bool,\n\n    /// Switch to zkEVM assembly mode.\n    /// Only one input zkEVM assembly file is allowed.\n    /// Cannot be used with combined JSON modes.\n    /// Use this mode at your own risk, as EraVM assembly input validation is not implemented.\n    #[structopt(long = \"zkasm\")]\n    pub zkasm: bool,\n\n    /// Set metadata hash mode: `keccak256` | `none`.\n    /// `keccak256` is enabled by default.\n    #[structopt(long = \"metadata-hash\")]\n    pub metadata_hash: Option<String>,\n\n    /// Dump all IR (LLL, LLVM IR, assembly) to files in the specified directory.\n    /// Only for testing and debugging.\n    #[structopt(long = \"debug-output-dir\")]\n    pub debug_output_directory: Option<PathBuf>,\n\n    /// Set the `verify-each` option in LLVM.\n    /// Only for testing and debugging.\n    #[structopt(long = \"llvm-verify-each\")]\n    pub llvm_verify_each: bool,\n\n    /// Set the `debug-logging` option in LLVM.\n    /// Only for testing and debugging.\n    #[structopt(long = \"llvm-debug-logging\")]\n    pub llvm_debug_logging: bool,\n\n    /// Run this process recursively and provide JSON input to compile a single contract.\n    /// Only for usage from within the compiler.\n    #[structopt(long = \"recursive-process\")]\n    pub recursive_process: bool,\n}\n\nimpl Default for Arguments {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Arguments {\n    ///\n    /// A shortcut constructor.\n    ///\n    pub fn new() -> Self {\n        Self::from_args()\n    }\n\n    ///\n    /// Validates the arguments.\n    ///\n    pub fn validate(&self) -> anyhow::Result<()> {\n        if self.version && std::env::args().count() > 2 {\n            anyhow::bail!(\"No other options are allowed while getting the compiler version.\");\n        }\n\n        if self.recursive_process && std::env::args().count() > 2 {\n            anyhow::bail!(\"No other options are allowed in recursive mode.\");\n        }\n\n        if self.llvm_ir && self.zkasm {\n            anyhow::bail!(\"Either LLVM IR or assembly mode can be used, but not both.\");\n        }\n\n        Ok(())\n    }\n}\n", "//!\n//! Vyper to zkEVM compiler binary.\n//!\n\npub mod arguments;\n\nuse std::path::PathBuf;\nuse std::str::FromStr;\n\nuse self::arguments::Arguments;\n\n/// The rayon worker stack size.\nconst RAYON_WORKER_STACK_SIZE: usize = 16 * 1024 * 1024;\n\n#[cfg(target_env = \"musl\")]\n#[global_allocator]\nstatic GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;\n\n///\n/// The application entry point.\n///\nfn main() {\n    std::process::exit(match main_inner() {\n        Ok(()) => 0,\n        Err(error) => {\n            eprintln!(\"{error}\");\n            1\n        }\n    })\n}\n\n///\n/// The auxiliary `main` function to facilitate the `?` error conversion operator.\n///\nfn main_inner() -> anyhow::Result<()> {\n    let mut arguments = Arguments::new();\n    arguments.validate()?;\n\n    rayon::ThreadPoolBuilder::new()\n        .stack_size(RAYON_WORKER_STACK_SIZE)\n        .build_global()\n        .expect(\"Thread pool configuration failure\");\n    inkwell::support::enable_llvm_pretty_stack_trace();\n    compiler_llvm_context::initialize_target(compiler_llvm_context::Target::EraVM); // TODO: pass from CLI\n\n    if arguments.version {\n        println!(\n            \"{} v{} (LLVM build {})\",\n            env!(\"CARGO_PKG_DESCRIPTION\"),\n            env!(\"CARGO_PKG_VERSION\"),\n            inkwell::support::get_commit_id().to_string(),\n        );\n        return Ok(());\n    }\n\n    if arguments.recursive_process {\n        return compiler_vyper::run_process();\n    }\n\n    let debug_config = match arguments.debug_output_directory {\n        Some(debug_output_directory) => {\n            std::fs::create_dir_all(debug_output_directory.as_path())?;\n            Some(compiler_llvm_context::DebugConfig::new(\n                debug_output_directory,\n            ))\n        }\n        None => None,\n    };\n\n    for path in arguments.input_files.iter_mut() {\n        *path = path.canonicalize()?;\n    }\n\n    let vyper = compiler_vyper::VyperCompiler::new(\n        arguments\n            .vyper\n            .unwrap_or_else(|| compiler_vyper::VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned()),\n    );\n\n    let mut optimizer_settings = match arguments.optimization {\n        Some(mode) => compiler_llvm_context::OptimizerSettings::try_from_cli(mode)?,\n        None => compiler_llvm_context::OptimizerSettings::cycles(),\n    };\n    optimizer_settings.is_verify_each_enabled = arguments.llvm_verify_each;\n    optimizer_settings.is_debug_logging_enabled = arguments.llvm_debug_logging;\n\n    let include_metadata_hash = match arguments.metadata_hash {\n        Some(metadata_hash) => {\n            let metadata =\n                compiler_llvm_context::EraVMMetadataHash::from_str(metadata_hash.as_str())?;\n            metadata != compiler_llvm_context::EraVMMetadataHash::None\n        }\n        None => true,\n    };\n\n    let build = if arguments.llvm_ir {\n        compiler_vyper::llvm_ir(\n            arguments.input_files,\n            optimizer_settings,\n            include_metadata_hash,\n            debug_config,\n        )\n    } else if arguments.zkasm {\n        compiler_vyper::zkasm(arguments.input_files, include_metadata_hash, debug_config)\n    } else {\n        match arguments.format.as_deref() {\n            Some(\"combined_json\") => {\n                compiler_vyper::combined_json(\n                    arguments.input_files,\n                    &vyper,\n                    !arguments.disable_vyper_optimizer,\n                    optimizer_settings,\n                    include_metadata_hash,\n                    debug_config,\n                    arguments.output_directory,\n                    arguments.overwrite,\n                )?;\n                return Ok(());\n            }\n            Some(format) if format.split(',').any(|format| format == \"combined_json\") => {\n                anyhow::bail!(\"If using combined_json it must be the only output format requested\");\n            }\n            Some(_) | None => compiler_vyper::standard_output(\n                arguments.input_files,\n                &vyper,\n                !arguments.disable_vyper_optimizer,\n                optimizer_settings,\n                include_metadata_hash,\n                debug_config,\n            ),\n        }\n    }?;\n\n    match arguments.output_directory {\n        Some(output_directory) => {\n            std::fs::create_dir_all(output_directory.as_path())?;\n\n            build.write_to_directory(output_directory.as_path(), arguments.overwrite)?;\n        }\n        None => {\n            for (path, contract) in build.contracts.into_iter() {\n                eprintln!(\"Contract `{path}`:\");\n                let bytecode_string = hex::encode(contract.build.bytecode);\n                println!(\"0x{bytecode_string}\");\n\n                if let Some(format) = arguments.format.as_deref() {\n                    let extra_output = vyper.extra_output(PathBuf::from(path).as_path(), format)?;\n                    println!();\n                    println!(\"{extra_output}\");\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n"], "filenames": ["CHANGELOG.md", "Cargo.lock", "Cargo.toml", "README.md", "src/build/contract.rs", "src/project/contract/llvm_ir.rs", "src/project/contract/vyper/expression/instruction/assert.rs", "src/project/contract/vyper/expression/instruction/clamp.rs", "src/project/contract/vyper/expression/instruction/create.rs", "src/project/contract/vyper/expression/instruction/exit_to.rs", "src/project/contract/vyper/expression/instruction/goto.rs", "src/project/contract/vyper/expression/instruction/if.rs", "src/project/contract/vyper/expression/instruction/immutable.rs", "src/project/contract/vyper/expression/instruction/label.rs", "src/project/contract/vyper/expression/instruction/mod.rs", "src/project/contract/vyper/expression/instruction/offset.rs", "src/project/contract/vyper/expression/instruction/repeat.rs", "src/project/contract/vyper/expression/instruction/return.rs", "src/project/contract/vyper/expression/instruction/revert.rs", "src/project/contract/vyper/expression/instruction/seq.rs", "src/project/contract/vyper/expression/instruction/set.rs", "src/project/contract/vyper/expression/instruction/with.rs", "src/project/contract/vyper/expression/mod.rs", "src/project/contract/vyper/function.rs", "src/project/contract/vyper/mod.rs", "src/project/contract/zkasm.rs", "src/project/mod.rs", "src/tests/mod.rs", "src/vyper/mod.rs", "src/zkvyper/arguments.rs", "src/zkvyper/main.rs"], "buggy_code_start_loc": [2, 7, 3, 114, 20, 63, 22, 11, 13, 22, 29, 39, 12, 101, 80, 11, 36, 31, 31, 150, 22, 34, 127, 7, 13, 53, 65, 45, 44, 50, 44], "buggy_code_end_loc": [25, 1566, 31, 126, 69, 64, 26, 69, 117, 41, 113, 43, 70, 198, 1360, 16, 40, 38, 38, 182, 26, 38, 131, 70, 284, 54, 145, 46, 209, 63, 91], "fixing_code_start_loc": [3, 7, 3, 114, 20, 63, 22, 11, 13, 22, 29, 39, 12, 101, 81, 11, 36, 31, 31, 150, 22, 34, 127, 7, 13, 53, 65, 45, 44, 50, 44], "fixing_code_end_loc": [31, 1594, 33, 128, 69, 66, 26, 69, 122, 35, 113, 43, 72, 201, 1401, 16, 40, 38, 38, 185, 26, 38, 131, 73, 305, 54, 153, 46, 221, 65, 92], "type": "NVD-CWE-noinfo", "message": "era-compiler-vyper is the EraVM Vyper compiler for zkSync Era, a layer 2 rollup that uses zero-knowledge proofs to scale Ethereum. Prior to era-compiler-vype version 1.3.10, a bug prevented the initialization of the first immutable variable for Vyper contracts meeting certain criteria. The problem arises when there is a String or Array with more 256-bit words allocated than initialized. It results in the second word\u2019s index unset, that is effectively set to 0, so the first immutable value with the actual 0 index is overwritten in the ImmutableSimulator. Version 1.3.10 fixes this issue by setting all indexes in advance. The problem will go away, but it will get more expensive if the user allocates a lot of uninitialized space, e.g. `String[4096]`. Upgrading and redeploying affected contracts is the only way of working around the issue.\n", "other": {"cve": {"id": "CVE-2023-46232", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-25T22:15:09.477", "lastModified": "2023-11-06T16:52:55.210", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "era-compiler-vyper is the EraVM Vyper compiler for zkSync Era, a layer 2 rollup that uses zero-knowledge proofs to scale Ethereum. Prior to era-compiler-vype version 1.3.10, a bug prevented the initialization of the first immutable variable for Vyper contracts meeting certain criteria. The problem arises when there is a String or Array with more 256-bit words allocated than initialized. It results in the second word\u2019s index unset, that is effectively set to 0, so the first immutable value with the actual 0 index is overwritten in the ImmutableSimulator. Version 1.3.10 fixes this issue by setting all indexes in advance. The problem will go away, but it will get more expensive if the user allocates a lot of uninitialized space, e.g. `String[4096]`. Upgrading and redeploying affected contracts is the only way of working around the issue.\n"}, {"lang": "es", "value": "era-compiler-vyper es el compilador EraVM Vyper para zkSync Era, un paquete acumulativo de capa 2 que utiliza pruebas de conocimiento cero para escalar Ethereum. Antes de la versi\u00f3n 1.3.10 de era-compiler-vype, un error imped\u00eda la inicializaci\u00f3n de la primera variable inmutable para los contratos de Vyper que cumpl\u00edan ciertos criterios. El problema surge cuando hay un String o Array con m\u00e1s palabras de 256 bits asignadas que inicializadas. Esto da como resultado que el \u00edndice de la segunda palabra no est\u00e9 configurado, que efectivamente se establece en 0, por lo que el primer valor inmutable con el \u00edndice 0 real se sobrescribe en ImmutableSimulator. La versi\u00f3n 1.3.10 soluciona este problema configurando todos los \u00edndices por adelantado. El problema desaparecer\u00e1, pero ser\u00e1 m\u00e1s costoso si el usuario asigna una gran cantidad de espacio no inicializado, por ejemplo, `String[4096]`. Actualizar y redistribuir los contratos afectados es la \u00fanica forma de solucionar el problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-471"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matter-labs:zkvyper:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.10", "matchCriteriaId": "E7C9B8B4-113C-405C-8961-D90E30AF0A3A"}]}]}], "references": [{"url": "https://github.com/matter-labs/era-compiler-vyper/commit/8be305a1b9c68d0fd47dad3434224ed85944ca25", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/matter-labs/era-compiler-vyper/security/advisories/GHSA-h8jv-969m-94r4", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://github.com/matter-labs/era-system-contracts/blob/main/contracts/ImmutableSimulator.sol#L37", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/matter-labs/era-compiler-vyper/commit/8be305a1b9c68d0fd47dad3434224ed85944ca25"}}