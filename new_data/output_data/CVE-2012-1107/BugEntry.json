{"buggy_code": ["/***************************************************************************\n    copyright            : (C) 2010 by Alex Novichkov\n    email                : novichko@atnet.ru\n\n    copyright            : (C) 2006 by Luk\u00e1\u0161 Lalinsk\u00fd\n    email                : lalinsky@gmail.com\n                           (original WavPack implementation)\n ***************************************************************************/\n\n/***************************************************************************\n *   This library is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU Lesser General Public License version   *\n *   2.1 as published by the Free Software Foundation.                     *\n *                                                                         *\n *   This library is distributed in the hope that it will be useful, but   *\n *   WITHOUT ANY WARRANTY; without even the implied warranty of            *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *\n *   Lesser General Public License for more details.                       *\n *                                                                         *\n *   You should have received a copy of the GNU Lesser General Public      *\n *   License along with this library; if not, write to the Free Software   *\n *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *\n *   02110-1301  USA                                                       *\n *                                                                         *\n *   Alternatively, this file is available under the Mozilla Public        *\n *   License Version 1.1.  You may obtain a copy of the License at         *\n *   http://www.mozilla.org/MPL/                                           *\n ***************************************************************************/\n\n#include <tstring.h>\n#include <tdebug.h>\n#include <bitset>\n#include \"id3v2tag.h\"\n#include \"apeproperties.h\"\n#include \"apefile.h\"\n\nusing namespace TagLib;\n\nclass APE::Properties::PropertiesPrivate\n{\npublic:\n  PropertiesPrivate(File *file, long streamLength) :\n    length(0),\n    bitrate(0),\n    sampleRate(0),\n    channels(0),\n    version(0),\n    bitsPerSample(0),\n    file(file),\n    streamLength(streamLength) {}\n\n  int length;\n  int bitrate;\n  int sampleRate;\n  int channels;\n  int version;\n  int bitsPerSample;\n  File *file;\n  long streamLength;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// public members\n////////////////////////////////////////////////////////////////////////////////\n\nAPE::Properties::Properties(File *file, ReadStyle style) : AudioProperties(style)\n{\n  d = new PropertiesPrivate(file, file->length());\n  read();\n}\n\nAPE::Properties::~Properties()\n{\n  delete d;\n}\n\nint APE::Properties::length() const\n{\n  return d->length;\n}\n\nint APE::Properties::bitrate() const\n{\n  return d->bitrate;\n}\n\nint APE::Properties::sampleRate() const\n{\n  return d->sampleRate;\n}\n\nint APE::Properties::channels() const\n{\n  return d->channels;\n}\n\nint APE::Properties::version() const\n{\n  return d->version;\n}\n\nint APE::Properties::bitsPerSample() const\n{\n  return d->bitsPerSample;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// private members\n////////////////////////////////////////////////////////////////////////////////\n\n\nvoid APE::Properties::read()\n{\n  // First we are searching the descriptor\n  long offset = findDescriptor();\n  if(offset < 0)\n    return;\n\n  // Then we read the header common for all versions of APE\n  d->file->seek(offset);\n  ByteVector commonHeader=d->file->readBlock(6);\n  if(!commonHeader.startsWith(\"MAC \"))\n    return;\n  d->version = commonHeader.mid(4).toUInt(false);\n\n  if(d->version >= 3980) {\n    analyzeCurrent();\n  }\n  else {\n    analyzeOld();\n  }\n}\n\nlong APE::Properties::findDescriptor()\n{\n  long ID3v2Location = findID3v2();\n  long ID3v2OriginalSize = 0;\n  bool hasID3v2 = false;\n  if(ID3v2Location >= 0) {\n    ID3v2::Tag tag(d->file, ID3v2Location);\n    ID3v2OriginalSize = tag.header()->completeTagSize();\n    if(tag.header()->tagSize() > 0)\n      hasID3v2 = true;\n  }\n\n  long offset = 0;\n  if(hasID3v2)\n    offset = d->file->find(\"MAC \", ID3v2Location + ID3v2OriginalSize);\n  else\n    offset = d->file->find(\"MAC \");\n\n  if(offset < 0) {\n    debug(\"APE::Properties::findDescriptor() -- APE descriptor not found\");\n    return -1;\n  }\n\n  return offset;\n}\n\nlong APE::Properties::findID3v2()\n{\n  if(!d->file->isValid())\n    return -1;\n\n  d->file->seek(0);\n\n  if(d->file->readBlock(3) == ID3v2::Header::fileIdentifier())\n    return 0;\n\n  return -1;\n}\n\nvoid APE::Properties::analyzeCurrent()\n{\n  // Read the descriptor\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n\n  // Read the header\n  ByteVector header = d->file->readBlock(24);\n\n  // Get the APE info\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  //d->compressionLevel =\n\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}\n\nvoid APE::Properties::analyzeOld()\n{\n  ByteVector header = d->file->readBlock(26);\n  uint totalFrames = header.mid(18, 4).toUInt(false);\n\n  // Fail on 0 length APE files (catches non-finalized APE files)\n  if(totalFrames == 0)\n    return;\n\n  short compressionLevel = header.mid(0, 2).toShort(false);\n  uint blocksPerFrame;\n  if(d->version >= 3950)\n    blocksPerFrame = 73728 * 4;\n  else if(d->version >= 3900 || (d->version >= 3800 && compressionLevel == 4000))\n    blocksPerFrame = 73728;\n  else\n    blocksPerFrame = 9216;\n  d->channels = header.mid(4, 2).toShort(false);\n  d->sampleRate = header.mid(6, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(22, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames - 1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}\n\n"], "fixing_code": ["/***************************************************************************\n    copyright            : (C) 2010 by Alex Novichkov\n    email                : novichko@atnet.ru\n\n    copyright            : (C) 2006 by Luk\u00e1\u0161 Lalinsk\u00fd\n    email                : lalinsky@gmail.com\n                           (original WavPack implementation)\n ***************************************************************************/\n\n/***************************************************************************\n *   This library is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU Lesser General Public License version   *\n *   2.1 as published by the Free Software Foundation.                     *\n *                                                                         *\n *   This library is distributed in the hope that it will be useful, but   *\n *   WITHOUT ANY WARRANTY; without even the implied warranty of            *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *\n *   Lesser General Public License for more details.                       *\n *                                                                         *\n *   You should have received a copy of the GNU Lesser General Public      *\n *   License along with this library; if not, write to the Free Software   *\n *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *\n *   02110-1301  USA                                                       *\n *                                                                         *\n *   Alternatively, this file is available under the Mozilla Public        *\n *   License Version 1.1.  You may obtain a copy of the License at         *\n *   http://www.mozilla.org/MPL/                                           *\n ***************************************************************************/\n\n#include <tstring.h>\n#include <tdebug.h>\n#include <bitset>\n#include \"id3v2tag.h\"\n#include \"apeproperties.h\"\n#include \"apefile.h\"\n\nusing namespace TagLib;\n\nclass APE::Properties::PropertiesPrivate\n{\npublic:\n  PropertiesPrivate(File *file, long streamLength) :\n    length(0),\n    bitrate(0),\n    sampleRate(0),\n    channels(0),\n    version(0),\n    bitsPerSample(0),\n    file(file),\n    streamLength(streamLength) {}\n\n  int length;\n  int bitrate;\n  int sampleRate;\n  int channels;\n  int version;\n  int bitsPerSample;\n  File *file;\n  long streamLength;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// public members\n////////////////////////////////////////////////////////////////////////////////\n\nAPE::Properties::Properties(File *file, ReadStyle style) : AudioProperties(style)\n{\n  d = new PropertiesPrivate(file, file->length());\n  read();\n}\n\nAPE::Properties::~Properties()\n{\n  delete d;\n}\n\nint APE::Properties::length() const\n{\n  return d->length;\n}\n\nint APE::Properties::bitrate() const\n{\n  return d->bitrate;\n}\n\nint APE::Properties::sampleRate() const\n{\n  return d->sampleRate;\n}\n\nint APE::Properties::channels() const\n{\n  return d->channels;\n}\n\nint APE::Properties::version() const\n{\n  return d->version;\n}\n\nint APE::Properties::bitsPerSample() const\n{\n  return d->bitsPerSample;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// private members\n////////////////////////////////////////////////////////////////////////////////\n\n\nvoid APE::Properties::read()\n{\n  // First we are searching the descriptor\n  long offset = findDescriptor();\n  if(offset < 0)\n    return;\n\n  // Then we read the header common for all versions of APE\n  d->file->seek(offset);\n  ByteVector commonHeader=d->file->readBlock(6);\n  if(!commonHeader.startsWith(\"MAC \"))\n    return;\n  d->version = commonHeader.mid(4).toUInt(false);\n\n  if(d->version >= 3980) {\n    analyzeCurrent();\n  }\n  else {\n    analyzeOld();\n  }\n}\n\nlong APE::Properties::findDescriptor()\n{\n  long ID3v2Location = findID3v2();\n  long ID3v2OriginalSize = 0;\n  bool hasID3v2 = false;\n  if(ID3v2Location >= 0) {\n    ID3v2::Tag tag(d->file, ID3v2Location);\n    ID3v2OriginalSize = tag.header()->completeTagSize();\n    if(tag.header()->tagSize() > 0)\n      hasID3v2 = true;\n  }\n\n  long offset = 0;\n  if(hasID3v2)\n    offset = d->file->find(\"MAC \", ID3v2Location + ID3v2OriginalSize);\n  else\n    offset = d->file->find(\"MAC \");\n\n  if(offset < 0) {\n    debug(\"APE::Properties::findDescriptor() -- APE descriptor not found\");\n    return -1;\n  }\n\n  return offset;\n}\n\nlong APE::Properties::findID3v2()\n{\n  if(!d->file->isValid())\n    return -1;\n\n  d->file->seek(0);\n\n  if(d->file->readBlock(3) == ID3v2::Header::fileIdentifier())\n    return 0;\n\n  return -1;\n}\n\nvoid APE::Properties::analyzeCurrent()\n{\n  // Read the descriptor\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n\n  // Read the header\n  ByteVector header = d->file->readBlock(24);\n\n  // Get the APE info\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  //d->compressionLevel =\n\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = d->sampleRate > 0 ? totalBlocks / d->sampleRate : 0;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}\n\nvoid APE::Properties::analyzeOld()\n{\n  ByteVector header = d->file->readBlock(26);\n  uint totalFrames = header.mid(18, 4).toUInt(false);\n\n  // Fail on 0 length APE files (catches non-finalized APE files)\n  if(totalFrames == 0)\n    return;\n\n  short compressionLevel = header.mid(0, 2).toShort(false);\n  uint blocksPerFrame;\n  if(d->version >= 3950)\n    blocksPerFrame = 73728 * 4;\n  else if(d->version >= 3900 || (d->version >= 3800 && compressionLevel == 4000))\n    blocksPerFrame = 73728;\n  else\n    blocksPerFrame = 9216;\n  d->channels = header.mid(4, 2).toShort(false);\n  d->sampleRate = header.mid(6, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(22, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames - 1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}\n\n"], "filenames": ["taglib/ape/apeproperties.cpp"], "buggy_code_start_loc": [196], "buggy_code_end_loc": [197], "fixing_code_start_loc": [196], "fixing_code_end_loc": [197], "type": "NVD-CWE-noinfo", "message": "The analyzeCurrent function in ape/apeproperties.cpp in TagLib 1.7 and earlier allows context-dependent attackers to cause a denial of service (application crash) via a crafted sampleRate in an ape file, which triggers a divide-by-zero error.", "other": {"cve": {"id": "CVE-2012-1107", "sourceIdentifier": "secalert@redhat.com", "published": "2012-09-06T18:55:00.987", "lastModified": "2017-08-29T01:31:12.257", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The analyzeCurrent function in ape/apeproperties.cpp in TagLib 1.7 and earlier allows context-dependent attackers to cause a denial of service (application crash) via a crafted sampleRate in an ape file, which triggers a divide-by-zero error."}, {"lang": "es", "value": "La funci\u00f3n analyzeCurrent en ape/apeproperties.cpp en TagLib v1.7 y anteriores permite a atacantes dependientes de contexto provocar una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de una frecuencia de muestreo dise\u00f1ado en un archivo mono, lo que provoca un error de divisi\u00f3n por cero."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.7", "matchCriteriaId": "0F562C2E-4011-40CD-B0D0-2A3F9DBCAB8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "C28F20C9-4939-4F4A-96A8-B44B84F20DA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "11625F29-9539-45ED-8C69-BE49CB3E1640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "D74F6CEA-4FEE-44CD-844A-886E5A6B2D76"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "A7EE066F-C257-4AE8-81ED-880F0DB35CDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3BEFD3D-3091-41B2-93E1-9BB5464455B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.4:*:*:*:*:*:*:*", "matchCriteriaId": "403A4D45-BE2E-41DC-971E-6A83B0F44DD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "C64D253F-DE01-46D0-A1BD-099DF5ABC445"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.6:*:*:*:*:*:*:*", "matchCriteriaId": "062A2172-E47F-43BA-AB6C-E7CE669D2BD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "34AF2A82-886F-42F5-9841-ECACE1BED7C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "CDBC7873-2E15-44AA-8D31-10394CED96BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "F990984E-7F9F-4DC0-B05D-60F88F8DC947"}]}]}], "references": [{"url": "http://mail.kde.org/pipermail/taglib-devel/2012-March/002186.html", "source": "secalert@redhat.com"}, {"url": "http://mail.kde.org/pipermail/taglib-devel/2012-March/002187.html", "source": "secalert@redhat.com"}, {"url": "http://www.gentoo.org/security/en/glsa/glsa-201206-16.xml", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/03/05/19", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/52284", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/73666", "source": "secalert@redhat.com"}, {"url": "https://github.com/taglib/taglib/commit/77d61c6eca4d08b9b025738acf6b926cc750db23", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/taglib/taglib/commit/77d61c6eca4d08b9b025738acf6b926cc750db23"}}