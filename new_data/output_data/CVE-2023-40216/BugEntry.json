{"buggy_code": ["/* $OpenBSD: wsemul_sun.c,v 1.36 2023/03/06 20:34:35 miod Exp $ */\n/* $NetBSD: wsemul_sun.c,v 1.11 2000/01/05 11:19:36 drochner Exp $ */\n\n/*\n * Copyright (c) 2007, 2013 Miodrag Vallat.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice, this permission notice, and the disclaimer below\n * appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n/*\n * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *      This product includes software developed by Christopher G. Demetriou\n *\tfor the NetBSD Project.\n * 4. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This file implements a sun terminal personality for wscons.\n *\n * Derived from old rcons code.\n * Color support from NetBSD's rcons color code, and wsemul_vt100.\n */\n\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n\n#include <dev/wscons/wscons_features.h>\n#include <dev/wscons/wsconsio.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/ascii.h>\n\nvoid\t*wsemul_sun_cnattach(const struct wsscreen_descr *, void *,\n    int, int, uint32_t);\nvoid\t*wsemul_sun_attach(int, const struct wsscreen_descr *,\n    void *, int, int, void *, uint32_t);\nu_int\twsemul_sun_output(void *, const u_char *, u_int, int);\nint\twsemul_sun_translate(void *, kbd_t, keysym_t, const u_char **);\nvoid\twsemul_sun_detach(void *, u_int *, u_int *);\nvoid\twsemul_sun_resetop(void *, enum wsemul_resetops);\n\nconst struct wsemul_ops wsemul_sun_ops = {\n\t\"sun\",\n\twsemul_sun_cnattach,\n\twsemul_sun_attach,\n\twsemul_sun_output,\n\twsemul_sun_translate,\n\twsemul_sun_detach,\n\twsemul_sun_resetop\n};\n\n#define\tSUN_EMUL_STATE_NORMAL\t0\t/* normal processing */\n#define\tSUN_EMUL_STATE_HAVEESC\t1\t/* seen start of ctl seq */\n#define\tSUN_EMUL_STATE_CONTROL\t2\t/* processing ESC [ ctl seq */\n#define\tSUN_EMUL_STATE_PERCENT\t3\t/* processing ESC % ctl seq */\n\n#define\tSUN_EMUL_FLAGS_UTF8\t0x01\t/* UTF-8 character set */\n\n#define\tSUN_EMUL_NARGS\t2\t\t/* max # of args to a command */\n\nstruct wsemul_sun_emuldata {\n\tconst struct wsdisplay_emulops *emulops;\n\tstruct wsemul_abortstate abortstate;\n\tvoid *emulcookie;\n\tvoid *cbcookie;\n\tint scrcapabilities;\n\tu_int nrows, ncols, crow, ccol;\n\tuint32_t defattr;\t\t/* default attribute (rendition) */\n\n\tu_int state;\t\t\t/* processing state */\n\tu_int flags;\n\tu_int args[SUN_EMUL_NARGS];\t/* command args, if CONTROL */\n\tint nargs;\t\t\t/* number of args */\n\n\tu_int scrolldist;\t\t/* distance to scroll */\n\tuint32_t curattr, bkgdattr;\t/* currently used attribute */\n\tuint32_t kernattr;\t\t/* attribute for kernel output */\n\tint attrflags, fgcol, bgcol;\t/* properties of curattr */\n\n\tstruct wsemul_inputstate instate;\t/* userland input state */\n\tstruct wsemul_inputstate kstate;\t/* kernel input state */\n\n#ifdef HAVE_UTF8_SUPPORT\n\tu_char translatebuf[4];\n#else\n\tu_char translatebuf[1];\n#endif\n\n#ifdef DIAGNOSTIC\n\tint console;\n#endif\n};\n\nvoid\twsemul_sun_init(struct wsemul_sun_emuldata *,\n\t    const struct wsscreen_descr *, void *, int, int, uint32_t);\nint\twsemul_sun_jump_scroll(struct wsemul_sun_emuldata *, const u_char *,\n\t    u_int, int);\nvoid\twsemul_sun_reset(struct wsemul_sun_emuldata *);\nint\twsemul_sun_output_lowchars(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *, int);\nint\twsemul_sun_output_normal(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *, int);\nint\twsemul_sun_output_haveesc(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *);\nint\twsemul_sun_output_control(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *);\nint\twsemul_sun_output_percent(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *);\nint\twsemul_sun_control(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *);\nint\twsemul_sun_selectattribute(struct wsemul_sun_emuldata *, int, int, int,\n\t    uint32_t *, uint32_t *);\nint\twsemul_sun_scrollup(struct wsemul_sun_emuldata *, u_int);\n\nstruct wsemul_sun_emuldata wsemul_sun_console_emuldata;\n\n/* some useful utility macros */\n#define\tARG(n,c) \\\n\t((n) >= edp->nargs ? 0 : edp->args[(n) + MAX(0, edp->nargs - (c))])\n#define\tNORMALIZE(arg)\t\t((arg) != 0 ? (arg) : 1)\n#define\tCOLS_LEFT\t\t(edp->ncols - 1 - edp->ccol)\n#define\tROWS_LEFT\t\t(edp->nrows - 1 - edp->crow)\n\nvoid\nwsemul_sun_init(struct wsemul_sun_emuldata *edp,\n    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,\n    uint32_t defattr)\n{\n\tedp->emulops = type->textops;\n\tedp->emulcookie = cookie;\n\tedp->scrcapabilities = type->capabilities;\n\tedp->nrows = type->nrows;\n\tedp->ncols = type->ncols;\n\tedp->crow = crow;\n\tedp->ccol = ccol;\n\tedp->defattr = defattr;\n\twsemul_reset_abortstate(&edp->abortstate);\n}\n\nvoid\nwsemul_sun_reset(struct wsemul_sun_emuldata *edp)\n{\n\tedp->flags = 0;\n\tedp->state = SUN_EMUL_STATE_NORMAL;\n\tedp->bkgdattr = edp->curattr = edp->defattr;\n\tedp->attrflags = 0;\n\tedp->fgcol = WSCOL_BLACK;\n\tedp->bgcol = WSCOL_WHITE;\n\tedp->scrolldist = 1;\n\tedp->instate.inchar = 0;\n\tedp->instate.lbound = 0;\n\tedp->instate.mbleft = 0;\n\tedp->kstate.inchar = 0;\n\tedp->kstate.lbound = 0;\n\tedp->kstate.mbleft = 0;\n}\n\nvoid *\nwsemul_sun_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,\n    int crow, uint32_t defattr)\n{\n\tstruct wsemul_sun_emuldata *edp;\n\tint res;\n\n\tedp = &wsemul_sun_console_emuldata;\n\twsemul_sun_init(edp, type, cookie, ccol, crow, defattr);\n\n#ifndef WS_KERNEL_FG\n#define WS_KERNEL_FG WSCOL_BLACK\n#endif\n#ifndef WS_KERNEL_BG\n#define WS_KERNEL_BG WSCOL_WHITE\n#endif\n#ifndef WS_KERNEL_COLATTR\n#define WS_KERNEL_COLATTR 0\n#endif\n#ifndef WS_KERNEL_MONOATTR\n#define WS_KERNEL_MONOATTR 0\n#endif\n\tif (type->capabilities & WSSCREEN_WSCOLORS)\n\t\tres = (*edp->emulops->pack_attr)(cookie,\n\t\t\t\t\t    WS_KERNEL_FG, WS_KERNEL_BG,\n\t\t\t\t\t    WS_KERNEL_COLATTR | WSATTR_WSCOLORS,\n\t\t\t\t\t    &edp->kernattr);\n\telse\n\t\tres = (*edp->emulops->pack_attr)(cookie, 0, 0,\n\t\t\t\t\t    WS_KERNEL_MONOATTR,\n\t\t\t\t\t    &edp->kernattr);\n\tif (res)\n\t\tedp->kernattr = defattr;\n\n\tedp->cbcookie = NULL;\n\n#ifdef DIAGNOSTIC\n\tedp->console = 1;\n#endif\n\n\twsemul_sun_reset(edp);\n\treturn (edp);\n}\n\nvoid *\nwsemul_sun_attach(int console, const struct wsscreen_descr *type, void *cookie,\n    int ccol, int crow, void *cbcookie, uint32_t defattr)\n{\n\tstruct wsemul_sun_emuldata *edp;\n\n\tif (console) {\n\t\tedp = &wsemul_sun_console_emuldata;\n#ifdef DIAGNOSTIC\n\t\tKASSERT(edp->console == 1);\n#endif\n\t} else {\n\t\tedp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);\n\t\tif (edp == NULL)\n\t\t\treturn (NULL);\n\t\twsemul_sun_init(edp, type, cookie, ccol, crow, defattr);\n\n#ifdef DIAGNOSTIC\n\t\tedp->console = 0;\n#endif\n\t}\n\n\tedp->cbcookie = cbcookie;\n\n\twsemul_sun_reset(edp);\n\treturn (edp);\n}\n\nint\nwsemul_sun_output_lowchars(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate, int kernel)\n{\n\tu_int n;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase ASCII_NUL:\n\tdefault:\n\t\t/* ignore */\n\t\tbreak;\n\n\tcase ASCII_BEL:\t\t/* \"Bell (BEL)\" */\n\t\twsdisplay_emulbell(edp->cbcookie);\n\t\tbreak;\n\n\tcase ASCII_BS:\t\t/* \"Backspace (BS)\" */\n\t\tif (edp->ccol > 0)\n\t\t\tedp->ccol--;\n\t\tbreak;\n\n\tcase ASCII_CR:\t\t/* \"Return (CR)\" */\n\t\tedp->ccol = 0;\n\t\tbreak;\n\n\tcase ASCII_HT:\t\t/* \"Tab (TAB)\" */\n\t\tn = min(8 - (edp->ccol & 7), COLS_LEFT);\n\t\tif (n != 0) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t\t    (edp->emulcookie, edp->crow, edp->ccol, n,\n\t\t\t     kernel ? edp->kernattr : edp->bkgdattr));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tedp->ccol += n;\n\t\t}\n\t\tbreak;\n\n\tcase ASCII_FF:\t\t/* \"Form Feed (FF)\" */\n\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t    (edp->emulcookie, 0, edp->nrows, edp->bkgdattr));\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tedp->ccol = edp->crow = 0;\n\t\tbreak;\n\n\tcase ASCII_VT:\t\t/* \"Reverse Line Feed\" */\n\t\tif (edp->crow > 0)\n\t\t\tedp->crow--;\n\t\tbreak;\n\n\tcase ASCII_ESC:\t\t/* \"Escape (ESC)\" */\n\t\tif (kernel) {\n\t\t\tprintf(\"wsemul_sun_output_lowchars: ESC in kernel \"\n\t\t\t    \"output ignored\\n\");\n\t\t\tbreak;\t/* ignore the ESC */\n\t\t}\n\n\t\tedp->state = SUN_EMUL_STATE_HAVEESC;\n\t\tbreak;\n\n\tcase ASCII_LF:\t\t/* \"Line Feed (LF)\" */\n\t\t/* if the cur line isn't the last, incr and leave. */\n\t\tif (ROWS_LEFT > 0)\n\t\t\tedp->crow++;\n\t\telse {\n\t\t\trc = wsemul_sun_scrollup(edp, edp->scrolldist);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint\nwsemul_sun_output_normal(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate, int kernel)\n{\n\tint rc;\n\tu_int outchar;\n\n\t(*edp->emulops->mapchar)(edp->emulcookie, instate->inchar, &outchar);\n\tWSEMULOP(rc, edp, &edp->abortstate, putchar,\n\t    (edp->emulcookie, edp->crow, edp->ccol,\n\t     outchar, kernel ? edp->kernattr : edp->curattr));\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (++edp->ccol >= edp->ncols) {\n\t\t/* if the cur line isn't the last, incr and leave. */\n\t\tif (ROWS_LEFT > 0)\n\t\t\tedp->crow++;\n\t\telse {\n\t\t\trc = wsemul_sun_scrollup(edp, edp->scrolldist);\n\t\t\tif (rc != 0) {\n\t\t\t\t/* undo line wrap */\n\t\t\t\tedp->ccol--;\n\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tedp->ccol = 0;\n\t}\n\n\treturn 0;\n}\n\nint\nwsemul_sun_output_haveesc(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase '[':\t\t/* continuation of multi-char sequence */\n\t\tedp->nargs = 0;\n\t\tbzero(edp->args, sizeof (edp->args));\n\t\tedp->state = SUN_EMUL_STATE_CONTROL;\n\t\tbreak;\n#ifdef HAVE_UTF8_SUPPORT\n\tcase '%':\n\t\tedp->state = SUN_EMUL_STATE_PERCENT;\n\t\tbreak;\n#endif\n\tdefault:\n#ifdef DEBUG\n\t\tprintf(\"ESC %x unknown\\n\", instate->inchar);\n#endif\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\t/* XXX is this wise? */\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint\nwsemul_sun_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int n, src, dst;\n\tint flags, fgcol, bgcol;\n\tuint32_t attr, bkgdattr;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase '@':\t\t/* \"Insert Character (ICH)\" */\n\t\tn = min(NORMALIZE(ARG(0,1)), COLS_LEFT + 1);\n\t\tsrc = edp->ccol;\n\t\tdst = edp->ccol + n;\n\t\tif (dst < edp->ncols) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t\t    (edp->emulcookie, edp->crow, src, dst,\n\t\t\t     edp->ncols - dst));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t    (edp->emulcookie, edp->crow, src, n, edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'A':\t\t/* \"Cursor Up (CUU)\" */\n\t\tedp->crow -= min(NORMALIZE(ARG(0,1)), edp->crow);\n\t\tbreak;\n\n\tcase 'E':\t\t/* \"Cursor Next Line (CNL)\" */\n\t\tedp->ccol = 0;\n\t\t/* FALLTHROUGH */\n\tcase 'B':\t\t/* \"Cursor Down (CUD)\" */\n\t\tedp->crow += min(NORMALIZE(ARG(0,1)), ROWS_LEFT);\n\t\tbreak;\n\n\tcase 'C':\t\t/* \"Cursor Forward (CUF)\" */\n\t\tedp->ccol += min(NORMALIZE(ARG(0,1)), COLS_LEFT);\n\t\tbreak;\n\n\tcase 'D':\t\t/* \"Cursor Backward (CUB)\" */\n\t\tedp->ccol -= min(NORMALIZE(ARG(0,1)), edp->ccol);\n\t\tbreak;\n\n\tcase 'f':\t\t/* \"Horizontal And Vertical Position (HVP)\" */\n\tcase 'H':\t\t/* \"Cursor Position (CUP)\" */\n\t\tedp->crow = min(NORMALIZE(ARG(0,2)), edp->nrows) - 1;\n\t\tedp->ccol = min(NORMALIZE(ARG(1,2)), edp->ncols) - 1;\n\t\tbreak;\n\n\tcase 'J':\t\t/* \"Erase in Display (ED)\" */\n\t\tif (ROWS_LEFT > 0) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t\t    (edp->emulcookie, edp->crow + 1, ROWS_LEFT,\n\t\t\t     edp->bkgdattr));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase 'K':\t\t/* \"Erase in Line (EL)\" */\n\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t    (edp->emulcookie, edp->crow, edp->ccol, COLS_LEFT + 1,\n\t\t     edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'L':\t\t/* \"Insert Line (IL)\" */\n\t\tn = min(NORMALIZE(ARG(0,1)), ROWS_LEFT + 1);\n\t\tsrc = edp->crow;\n\t\tdst = edp->crow + n;\n\t\tif (dst < edp->nrows) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copyrows,\n\t\t\t    (edp->emulcookie, src, dst, edp->nrows - dst));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t    (edp->emulcookie, src, n, edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'M':\t\t/* \"Delete Line (DL)\" */\n\t\tn = min(NORMALIZE(ARG(0,1)), ROWS_LEFT + 1);\n\t\tsrc = edp->crow + n;\n\t\tdst = edp->crow;\n\t\tif (src < edp->nrows) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copyrows,\n\t\t\t    (edp->emulcookie, src, dst, edp->nrows - src));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t    (edp->emulcookie, dst + edp->nrows - src, n,\n\t\t     edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'P':\t\t/* \"Delete Character (DCH)\" */\n\t\tn = min(NORMALIZE(ARG(0,1)), COLS_LEFT + 1);\n\t\tsrc = edp->ccol + n;\n\t\tdst = edp->ccol;\n\t\tif (src < edp->ncols) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t\t    (edp->emulcookie, edp->crow, src, dst,\n\t\t\t     edp->ncols - src));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t    (edp->emulcookie, edp->crow, edp->ncols - n, n,\n\t\t     edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'm':\t\t/* \"Select Graphic Rendition (SGR)\" */\n\t\tflags = edp->attrflags;\n\t\tfgcol = edp->fgcol;\n\t\tbgcol = edp->bgcol;\n\n\t\tfor (n = 0; n < edp->nargs; n++) {\n\t\t\tswitch (ARG(n,edp->nargs)) {\n\t\t\t/* Clear all attributes || End underline */\n\t\t\tcase 0:\n\t\t\t\tif (n == edp->nargs - 1) {\n\t\t\t\t\tedp->bkgdattr =\n\t\t\t\t\t    edp->curattr = edp->defattr;\n\t\t\t\t\tedp->attrflags = 0;\n\t\t\t\t\tedp->fgcol = WSCOL_BLACK;\n\t\t\t\t\tedp->bgcol = WSCOL_WHITE;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tflags = 0;\n\t\t\t\tfgcol = WSCOL_BLACK;\n\t\t\t\tbgcol = WSCOL_WHITE;\n\t\t\t\tbreak;\n\t\t\t/* Begin bold */\n\t\t\tcase 1:\n\t\t\t\tflags |= WSATTR_HILIT;\n\t\t\t\tbreak;\n\t\t\t/* Begin underline */\n\t\t\tcase 4:\n\t\t\t\tflags |= WSATTR_UNDERLINE;\n\t\t\t\tbreak;\n\t\t\t/* Begin reverse */\n\t\t\tcase 7:\n\t\t\t\tflags |= WSATTR_REVERSE;\n\t\t\t\tbreak;\n\t\t\t/* ANSI foreground color */\n\t\t\tcase 30: case 31: case 32: case 33:\n\t\t\tcase 34: case 35: case 36: case 37:\n\t\t\t\tfgcol = ARG(n,edp->nargs) - 30;\n\t\t\t\tbreak;\n\t\t\t/* ANSI background color */\n\t\t\tcase 40: case 41: case 42: case 43:\n\t\t\tcase 44: case 45: case 46: case 47:\n\t\t\t\tbgcol = ARG(n,edp->nargs) - 40;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nsetattr:\n\t\tif (wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, &attr,\n\t\t    &bkgdattr)) {\n#ifdef DEBUG\n\t\t\tprintf(\"error allocating attr %d/%d/%x\\n\",\n\t\t\t    fgcol, bgcol, flags);\n#endif\n\t\t} else {\n\t\t\tedp->curattr = attr;\n\t\t\tedp->bkgdattr = bkgdattr;\n\t\t\tedp->attrflags = flags;\n\t\t\tedp->fgcol = fgcol;\n\t\t\tedp->bgcol = bgcol;\n\t\t}\n\t\tbreak;\n\n\tcase 'p':\t\t/* \"Black On White (SUNBOW)\" */\n\t\tflags = 0;\n\t\tfgcol = WSCOL_BLACK;\n\t\tbgcol = WSCOL_WHITE;\n\t\tgoto setattr;\n\n\tcase 'q':\t\t/* \"White On Black (SUNWOB)\" */\n\t\tflags = 0;\n\t\tfgcol = WSCOL_WHITE;\n\t\tbgcol = WSCOL_BLACK;\n\t\tgoto setattr;\n\n\tcase 'r':\t\t/* \"Set Scrolling (SUNSCRL)\" */\n\t\tedp->scrolldist = min(ARG(0,1), edp->nrows);\n\t\tbreak;\n\n\tcase 's':\t\t/* \"Reset Terminal Emulator (SUNRESET)\" */\n\t\twsemul_sun_reset(edp);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint\nwsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': /* argument digit */\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/*\n\t\t * If we receive more arguments than we are expecting,\n\t\t * discard the earliest arguments.\n\t\t */\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t/* argument terminator */\n\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t/* end of escape sequence */\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t/* undo nargs progress */\n\t\t\tedp->nargs = oargs;\n\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#ifdef HAVE_UTF8_SUPPORT\nint\nwsemul_sun_output_percent(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase 'G':\n\t\tedp->flags |= SUN_EMUL_FLAGS_UTF8;\n\t\tedp->kstate.mbleft = edp->instate.mbleft = 0;\n\t\tbreak;\n\tcase '@':\n\t\tedp->flags &= ~SUN_EMUL_FLAGS_UTF8;\n\t\tbreak;\n\t}\n\tedp->state = SUN_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n#endif\n\nu_int\nwsemul_sun_output(void *cookie, const u_char *data, u_int count, int kernel)\n{\n\tstruct wsemul_sun_emuldata *edp = cookie;\n\tstruct wsemul_inputstate *instate;\n\tu_int prev_count, processed = 0;\n#ifdef HAVE_JUMP_SCROLL\n\tint lines;\n#endif\n\tint rc = 0;\n\n#ifdef DIAGNOSTIC\n\tif (kernel && !edp->console)\n\t\tpanic(\"wsemul_sun_output: kernel output, not console\");\n#endif\n\n\tinstate = kernel ? &edp->kstate : &edp->instate;\n\n\tswitch (edp->abortstate.state) {\n\tcase ABORT_FAILED_CURSOR:\n\t\t/*\n\t\t * If we could not display the cursor back, we pretended not\n\t\t * having been able to process the last byte. But this\n\t\t * is a lie, so compensate here.\n\t\t */\n\t\tdata++, count--;\n\t\tprocessed++;\n\t\twsemul_reset_abortstate(&edp->abortstate);\n\t\tbreak;\n\tcase ABORT_OK:\n\t\t/* remove cursor image */\n\t\trc = (*edp->emulops->cursor)\n\t\t    (edp->emulcookie, 0, edp->crow, edp->ccol);\n\t\tif (rc != 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (;;) {\n#ifdef HAVE_JUMP_SCROLL\n\t\tswitch (edp->abortstate.state) {\n\t\tcase ABORT_FAILED_JUMP_SCROLL:\n\t\t\t/*\n\t\t\t * If we failed a previous jump scroll attempt, we\n\t\t\t * need to try to resume it with the same distance.\n\t\t\t * We can not recompute it since there might be more\n\t\t\t * bytes in the tty ring, causing a different result.\n\t\t\t */\n\t\t\tlines = edp->abortstate.lines;\n\t\t\tbreak;\n\t\tcase ABORT_OK:\n\t\t\t/*\n\t\t\t * If scrolling is not disabled and we are the bottom of\n\t\t\t * the screen, count newlines until an escape sequence\n\t\t\t * appears.\n\t\t\t */\n\t\t\tif ((edp->state == SUN_EMUL_STATE_NORMAL || kernel) &&\n\t\t\t    ROWS_LEFT == 0 && edp->scrolldist != 0)\n\t\t\t\tlines = wsemul_sun_jump_scroll(edp, data,\n\t\t\t\t    count, kernel);\n\t\t\telse\n\t\t\t\tlines = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * If we are recovering a non-scrolling failure,\n\t\t\t * do not try to scroll yet.\n\t\t\t */\n\t\t\tlines = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (lines > 1) {\n\t\t\twsemul_resume_abort(&edp->abortstate);\n\t\t\trc = wsemul_sun_scrollup(edp, lines);\n\t\t\tif (rc != 0) {\n\t\t\t\twsemul_abort_jump_scroll(&edp->abortstate,\n\t\t\t\t    lines);\n\t\t\t\treturn processed;\n\t\t\t}\n\t\t\twsemul_reset_abortstate(&edp->abortstate);\n\t\t\tedp->crow--;\n\t\t}\n#endif\n\n\t\twsemul_resume_abort(&edp->abortstate);\n\n\t\tprev_count = count;\n\t\tif (wsemul_getchar(&data, &count, instate,\n#ifdef HAVE_UTF8_SUPPORT\n\t\t    (edp->state == SUN_EMUL_STATE_NORMAL && !kernel) ?\n\t\t      edp->flags & SUN_EMUL_FLAGS_UTF8 : 0\n#else\n\t\t    0\n#endif\n\t\t    ) != 0)\n\t\t\tbreak;\n\n\t\tif (instate->inchar < ' ') {\n\t\t\trc = wsemul_sun_output_lowchars(edp, instate, kernel);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tprocessed += prev_count - count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (kernel) {\n\t\t\trc = wsemul_sun_output_normal(edp, instate, 1);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tprocessed += prev_count - count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (edp->state) {\n\t\tcase SUN_EMUL_STATE_NORMAL:\n\t\t\trc = wsemul_sun_output_normal(edp, instate, 0);\n\t\t\tbreak;\n\t\tcase SUN_EMUL_STATE_HAVEESC:\n\t\t\trc = wsemul_sun_output_haveesc(edp, instate);\n\t\t\tbreak;\n\t\tcase SUN_EMUL_STATE_CONTROL:\n\t\t\trc = wsemul_sun_output_control(edp, instate);\n\t\t\tbreak;\n#ifdef HAVE_UTF8_SUPPORT\n\t\tcase SUN_EMUL_STATE_PERCENT:\n\t\t\trc = wsemul_sun_output_percent(edp, instate);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n#ifdef DIAGNOSTIC\n\t\t\tpanic(\"wsemul_sun: invalid state %d\", edp->state);\n#else\n\t\t\t/* try to recover, if things get screwed up... */\n\t\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\t\trc = wsemul_sun_output_normal(edp, instate, 0);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tprocessed += prev_count - count;\n\t}\n\n\tif (rc != 0)\n\t\twsemul_abort_other(&edp->abortstate);\n\telse {\n\t\t/* put cursor image back */\n\t\trc = (*edp->emulops->cursor)\n\t\t    (edp->emulcookie, 1, edp->crow, edp->ccol);\n\t\tif (rc != 0) {\n\t\t\t/*\n\t\t\t * Pretend the last byte hasn't been processed, while\n\t\t\t * remembering that only the cursor operation really\n\t\t\t * needs to be done.\n\t\t\t */\n\t\t\twsemul_abort_cursor(&edp->abortstate);\n\t\t\tprocessed--;\n\t\t}\n\t}\n\n\tif (rc == 0)\n\t\twsemul_reset_abortstate(&edp->abortstate);\n\n\treturn processed;\n}\n\n#ifdef HAVE_JUMP_SCROLL\nint\nwsemul_sun_jump_scroll(struct wsemul_sun_emuldata *edp, const u_char *data,\n    u_int count, int kernel)\n{\n\tu_int pos, lines;\n\tstruct wsemul_inputstate tmpstate;\n\n\tlines = 0;\n\tpos = edp->ccol;\n\ttmpstate = kernel ? edp->kstate : edp->instate;\t/* structure copy */\n\n\twhile (wsemul_getchar(&data, &count, &tmpstate,\n#ifdef HAVE_UTF8_SUPPORT\n\t    kernel ? 0 : edp->flags & SUN_EMUL_FLAGS_UTF8\n#else\n\t    0\n#endif\n\t    ) == 0) {\n\t\tif (tmpstate.inchar == ASCII_FF ||\n\t\t    tmpstate.inchar == ASCII_VT ||\n\t\t    tmpstate.inchar == ASCII_ESC)\n\t\t\tbreak;\n\n\t\tswitch (tmpstate.inchar) {\n\t\tcase ASCII_BS:\n\t\t\tif (pos > 0)\n\t\t\t\tpos--;\n\t\t\tbreak;\n\t\tcase ASCII_CR:\n\t\t\tpos = 0;\n\t\t\tbreak;\n\t\tcase ASCII_HT:\n\t\t\tpos = (pos + 7) & ~7;\n\t\t\tif (pos >= edp->ncols)\n\t\t\t\tpos = edp->ncols - 1;\n\t\t\tbreak;\n\t\tcase ASCII_LF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (++pos >= edp->ncols) {\n\t\t\t\tpos = 0;\n\t\t\t\ttmpstate.inchar = ASCII_LF;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (tmpstate.inchar == ASCII_LF) {\n\t\t\tif (++lines >= edp->nrows - 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n#endif\n\n/*\n * Get an attribute from the graphics driver.\n * Try to find replacements if the desired appearance is not supported.\n */\nint\nwsemul_sun_selectattribute(struct wsemul_sun_emuldata *edp, int flags,\n    int fgcol, int bgcol, uint32_t *attr, uint32_t *bkgdattr)\n{\n\tint error;\n\n\t/*\n\t * Rasops will force white on black as normal output colors, unless\n\t * WSATTR_WSCOLORS is specified. Since Sun console is black on white,\n\t * always use WSATTR_WSCOLORS and our colors, as we know better.\n\t */\n\tif (!(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {\n\t\tflags &= ~WSATTR_WSCOLORS;\n\t} else {\n\t\tflags |= WSATTR_WSCOLORS;\n\t}\n\n\terror = (*edp->emulops->pack_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags & WSATTR_WSCOLORS, bkgdattr);\n\tif (error)\n\t\treturn (error);\n\n\tif ((flags & WSATTR_HILIT) &&\n\t    !(edp->scrcapabilities & WSSCREEN_HILIT)) {\n\t\tflags &= ~WSATTR_HILIT;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tfgcol = WSCOL_RED;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t}\n\t}\n\tif ((flags & WSATTR_UNDERLINE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {\n\t\tflags &= ~WSATTR_UNDERLINE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tfgcol = WSCOL_CYAN;\n\t\t\tflags &= ~WSATTR_UNDERLINE;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t}\n\t}\n\tif ((flags & WSATTR_BLINK) &&\n\t    !(edp->scrcapabilities & WSSCREEN_BLINK)) {\n\t\tflags &= ~WSATTR_BLINK;\n\t}\n\tif ((flags & WSATTR_REVERSE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {\n\t\tflags &= ~WSATTR_REVERSE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tint help;\n\t\t\thelp = bgcol;\n\t\t\tbgcol = fgcol;\n\t\t\tfgcol = help;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t}\n\t}\n\terror = (*edp->emulops->pack_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags, attr);\n\tif (error)\n\t\treturn (error);\n\n\treturn (0);\n}\n\nstatic const u_char *sun_fkeys[] = {\n\t\"\\033[224z\",\t/* F1 */\n\t\"\\033[225z\",\n\t\"\\033[226z\",\n\t\"\\033[227z\",\n\t\"\\033[228z\",\n\t\"\\033[229z\",\n\t\"\\033[230z\",\n\t\"\\033[231z\",\n\t\"\\033[232z\",\n\t\"\\033[233z\",\n\t\"\\033[234z\",\n\t\"\\033[235z\",\t/* F12 */\n};\n\nstatic const u_char *sun_lkeys[] = {\n\t\"\\033[207z\",\t/* KS_Help */\n\tNULL,\t\t/* KS_Execute */\n\t\"\\033[200z\",\t/* KS_Find */\n\tNULL,\t\t/* KS_Select */\n\t\"\\033[193z\",\t/* KS_Again */\n\t\"\\033[194z\",\t/* KS_Props */\n\t\"\\033[195z\",\t/* KS_Undo */\n\t\"\\033[196z\",\t/* KS_Front */\n\t\"\\033[197z\",\t/* KS_Copy */\n\t\"\\033[198z\",\t/* KS_Open */\n\t\"\\033[199z\",\t/* KS_Paste */\n\t\"\\033[201z\",\t/* KS_Cut */\n};\n\nint\nwsemul_sun_translate(void *cookie, kbd_t layout, keysym_t in,\n    const u_char **out)\n{\n\tstruct wsemul_sun_emuldata *edp = cookie;\n\n\tif (KS_GROUP(in) == KS_GROUP_Ascii) {\n\t\t*out = edp->translatebuf;\n\t\treturn (wsemul_utf8_translate(KS_VALUE(in), layout,\n\t\t    edp->translatebuf, edp->flags & SUN_EMUL_FLAGS_UTF8));\n\t}\n\n\tif (KS_GROUP(in) == KS_GROUP_Keypad && (in & 0x80) == 0) {\n\t\tedp->translatebuf[0] = in & 0xff; /* turn into ASCII */\n\t\t*out = edp->translatebuf;\n\t\treturn (1);\n\t}\n\n\tif (in >= KS_f1 && in <= KS_f12) {\n\t\t*out = sun_fkeys[in - KS_f1];\n\t\treturn (6);\n\t}\n\tif (in >= KS_F1 && in <= KS_F12) {\n\t\t*out = sun_fkeys[in - KS_F1];\n\t\treturn (6);\n\t}\n\tif (in >= KS_KP_F1 && in <= KS_KP_F4) {\n\t\t*out = sun_fkeys[in - KS_KP_F1];\n\t\treturn (6);\n\t}\n\tif (in >= KS_Help && in <= KS_Cut && sun_lkeys[in - KS_Help] != NULL) {\n\t\t*out = sun_lkeys[in - KS_Help];\n\t\treturn (6);\n\t}\n\n\tswitch (in) {\n\tcase KS_Home:\n\tcase KS_KP_Home:\n\tcase KS_KP_Begin:\n\t\t*out = \"\\033[214z\";\n\t\treturn (6);\n\tcase KS_End:\n\tcase KS_KP_End:\n\t\t*out = \"\\033[220z\";\n\t\treturn (6);\n\tcase KS_Insert:\n\tcase KS_KP_Insert:\n\t\t*out = \"\\033[247z\";\n\t\treturn (6);\n\tcase KS_Prior:\n\tcase KS_KP_Prior:\n\t\t*out = \"\\033[216z\";\n\t\treturn (6);\n\tcase KS_Next:\n\tcase KS_KP_Next:\n\t\t*out = \"\\033[222z\";\n\t\treturn (6);\n\tcase KS_Up:\n\tcase KS_KP_Up:\n\t\t*out = \"\\033[A\";\n\t\treturn (3);\n\tcase KS_Down:\n\tcase KS_KP_Down:\n\t\t*out = \"\\033[B\";\n\t\treturn (3);\n\tcase KS_Left:\n\tcase KS_KP_Left:\n\t\t*out = \"\\033[D\";\n\t\treturn (3);\n\tcase KS_Right:\n\tcase KS_KP_Right:\n\t\t*out = \"\\033[C\";\n\t\treturn (3);\n\tcase KS_KP_Delete:\n\t\t*out = \"\\177\";\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid\nwsemul_sun_detach(void *cookie, u_int *crowp, u_int *ccolp)\n{\n\tstruct wsemul_sun_emuldata *edp = cookie;\n\n\t*crowp = edp->crow;\n\t*ccolp = edp->ccol;\n\tif (edp != &wsemul_sun_console_emuldata)\n\t\tfree(edp, M_DEVBUF, sizeof *edp);\n}\n\nvoid\nwsemul_sun_resetop(void *cookie, enum wsemul_resetops op)\n{\n\tstruct wsemul_sun_emuldata *edp = cookie;\n\n\tswitch (op) {\n\tcase WSEMUL_RESET:\n\t\twsemul_sun_reset(edp);\n\t\tbreak;\n\tcase WSEMUL_CLEARSCREEN:\n\t\t(*edp->emulops->eraserows)(edp->emulcookie, 0, edp->nrows,\n\t\t    edp->bkgdattr);\n\t\tedp->ccol = edp->crow = 0;\n\t\t(*edp->emulops->cursor)(edp->emulcookie, 1, 0, 0);\n\t\tbreak;\n\tcase WSEMUL_CLEARCURSOR:\n\t\t(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow,\n\t\t    edp->ccol);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint\nwsemul_sun_scrollup(struct wsemul_sun_emuldata *edp, u_int lines)\n{\n\tint rc;\n\n\t/*\n\t * if we're in wrap-around mode, go to the first\n\t * line and clear it.\n\t */\n\tif (lines == 0) {\n\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t    (edp->emulcookie, 0, 1, edp->bkgdattr));\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\n\t\tedp->crow = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the scrolling distance is equal to the screen height\n\t * (usually 34), clear the screen; otherwise, scroll by the\n\t * scrolling distance.\n\t */\n\tif (lines < edp->nrows) {\n\t\tWSEMULOP(rc, edp, &edp->abortstate, copyrows,\n\t\t    (edp->emulcookie, lines, 0, edp->nrows - lines));\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t}\n\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t    (edp->emulcookie, edp->nrows - lines, lines, edp->bkgdattr));\n\tif (rc != 0)\n\t\treturn rc;\n\n\tedp->crow -= lines - 1;\n\n\treturn 0;\n}\n", "/* $OpenBSD: wsemul_vt100.c,v 1.45 2023/03/06 20:34:35 miod Exp $ */\n/* $NetBSD: wsemul_vt100.c,v 1.13 2000/04/28 21:56:16 mycroft Exp $ */\n\n/*\n * Copyright (c) 2007, 2013 Miodrag Vallat.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice, this permission notice, and the disclaimer below\n * appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n/*\n * Copyright (c) 1998\n *\tMatthias Drochner.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n\n#include <dev/wscons/wscons_features.h>\n#include <dev/wscons/wsconsio.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/ascii.h>\n\nvoid\t*wsemul_vt100_cnattach(const struct wsscreen_descr *, void *,\n\t\t\t\t  int, int, uint32_t);\nvoid\t*wsemul_vt100_attach(int, const struct wsscreen_descr *,\n\t\t\t\t  void *, int, int, void *, uint32_t);\nu_int\twsemul_vt100_output(void *, const u_char *, u_int, int);\nvoid\twsemul_vt100_detach(void *, u_int *, u_int *);\nvoid\twsemul_vt100_resetop(void *, enum wsemul_resetops);\n\nconst struct wsemul_ops wsemul_vt100_ops = {\n\t\"vt100\",\n\twsemul_vt100_cnattach,\n\twsemul_vt100_attach,\n\twsemul_vt100_output,\n\twsemul_vt100_translate,\n\twsemul_vt100_detach,\n\twsemul_vt100_resetop\n};\n\nstruct wsemul_vt100_emuldata wsemul_vt100_console_emuldata;\n\nvoid\twsemul_vt100_init(struct wsemul_vt100_emuldata *,\n\t    const struct wsscreen_descr *, void *, int, int, uint32_t);\nint\twsemul_vt100_jump_scroll(struct wsemul_vt100_emuldata *,\n\t    const u_char *, u_int, int);\nint\twsemul_vt100_output_normal(struct wsemul_vt100_emuldata *,\n\t    struct wsemul_inputstate *, int);\nint\twsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *,\n\t    struct wsemul_inputstate *, int);\nint\twsemul_vt100_nextline(struct wsemul_vt100_emuldata *);\n\ntypedef int vt100_handler(struct wsemul_vt100_emuldata *, struct\n\t    wsemul_inputstate *);\nvt100_handler\n\twsemul_vt100_output_esc,\n\twsemul_vt100_output_csi,\n\twsemul_vt100_output_scs94,\n\twsemul_vt100_output_scs94_percent,\n\twsemul_vt100_output_scs96,\n\twsemul_vt100_output_scs96_percent,\n\twsemul_vt100_output_esc_hash,\n\twsemul_vt100_output_esc_spc,\n\twsemul_vt100_output_string,\n\twsemul_vt100_output_string_esc,\n\twsemul_vt100_output_dcs,\n\twsemul_vt100_output_dcs_dollar,\n\twsemul_vt100_output_esc_percent;\n\n#define\tVT100_EMUL_STATE_NORMAL\t\t0\t/* normal processing */\n#define\tVT100_EMUL_STATE_ESC\t\t1\t/* got ESC */\n#define\tVT100_EMUL_STATE_CSI\t\t2\t/* got CSI (ESC[) */\n#define\tVT100_EMUL_STATE_SCS94\t\t3\t/* got ESC{()*+} */\n#define\tVT100_EMUL_STATE_SCS94_PERCENT\t4\t/* got ESC{()*+}% */\n#define\tVT100_EMUL_STATE_SCS96\t\t5\t/* got ESC{-./} */\n#define\tVT100_EMUL_STATE_SCS96_PERCENT\t6\t/* got ESC{-./}% */\n#define\tVT100_EMUL_STATE_ESC_HASH\t7\t/* got ESC# */\n#define\tVT100_EMUL_STATE_ESC_SPC\t8\t/* got ESC<SPC> */\n#define\tVT100_EMUL_STATE_STRING\t\t9\t/* waiting for ST (ESC\\) */\n#define\tVT100_EMUL_STATE_STRING_ESC\t10\t/* waiting for ST, got ESC */\n#define\tVT100_EMUL_STATE_DCS\t\t11\t/* got DCS (ESC P) */\n#define\tVT100_EMUL_STATE_DCS_DOLLAR\t12\t/* got DCS<p>$ */\n#define\tVT100_EMUL_STATE_ESC_PERCENT\t13\t/* got ESC% */\n\nvt100_handler *vt100_output[] = {\n\twsemul_vt100_output_esc,\n\twsemul_vt100_output_csi,\n\twsemul_vt100_output_scs94,\n\twsemul_vt100_output_scs94_percent,\n\twsemul_vt100_output_scs96,\n\twsemul_vt100_output_scs96_percent,\n\twsemul_vt100_output_esc_hash,\n\twsemul_vt100_output_esc_spc,\n\twsemul_vt100_output_string,\n\twsemul_vt100_output_string_esc,\n\twsemul_vt100_output_dcs,\n\twsemul_vt100_output_dcs_dollar,\n\twsemul_vt100_output_esc_percent,\n};\n\nvoid\nwsemul_vt100_init(struct wsemul_vt100_emuldata *edp,\n    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,\n    uint32_t defattr)\n{\n\tedp->emulops = type->textops;\n\tedp->emulcookie = cookie;\n\tedp->scrcapabilities = type->capabilities;\n\tedp->nrows = type->nrows;\n\tedp->ncols = type->ncols;\n\tedp->crow = crow;\n\tedp->ccol = ccol;\n\tedp->defattr = defattr;\n\twsemul_reset_abortstate(&edp->abortstate);\n}\n\nvoid *\nwsemul_vt100_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,\n    int crow, uint32_t defattr)\n{\n\tstruct wsemul_vt100_emuldata *edp;\n\tint res;\n\n\tedp = &wsemul_vt100_console_emuldata;\n\twsemul_vt100_init(edp, type, cookie, ccol, crow, defattr);\n#ifdef DIAGNOSTIC\n\tedp->console = 1;\n#endif\n\tedp->cbcookie = NULL;\n\n#ifndef WS_KERNEL_FG\n#define WS_KERNEL_FG WSCOL_WHITE\n#endif\n#ifndef WS_KERNEL_BG\n#define WS_KERNEL_BG WSCOL_BLUE\n#endif\n#ifndef WS_KERNEL_COLATTR\n#define WS_KERNEL_COLATTR 0\n#endif\n#ifndef WS_KERNEL_MONOATTR\n#define WS_KERNEL_MONOATTR 0\n#endif\n\tif (type->capabilities & WSSCREEN_WSCOLORS)\n\t\tres = (*edp->emulops->pack_attr)(cookie,\n\t\t    WS_KERNEL_FG, WS_KERNEL_BG,\n\t\t    WS_KERNEL_COLATTR | WSATTR_WSCOLORS, &edp->kernattr);\n\telse\n\t\tres = (*edp->emulops->pack_attr)(cookie, 0, 0,\n\t\t    WS_KERNEL_MONOATTR, &edp->kernattr);\n\tif (res)\n\t\tedp->kernattr = defattr;\n\n\tedp->tabs = NULL;\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\tedp->dblwid = NULL;\n\tedp->dw = 0;\n#endif\n\tedp->dcsarg = NULL;\n\tedp->isolatin1tab = edp->decgraphtab = edp->dectechtab = NULL;\n\tedp->nrctab = NULL;\n\twsemul_vt100_reset(edp);\n\treturn (edp);\n}\n\nvoid *\nwsemul_vt100_attach(int console, const struct wsscreen_descr *type,\n    void *cookie, int ccol, int crow, void *cbcookie, uint32_t defattr)\n{\n\tstruct wsemul_vt100_emuldata *edp;\n\n\tif (console) {\n\t\tedp = &wsemul_vt100_console_emuldata;\n\t\tKASSERT(edp->console == 1);\n\t} else {\n\t\tedp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);\n\t\tif (edp == NULL)\n\t\t\treturn (NULL);\n\t\twsemul_vt100_init(edp, type, cookie, ccol, crow, defattr);\n#ifdef DIAGNOSTIC\n\t\tedp->console = 0;\n#endif\n\t}\n\tedp->cbcookie = cbcookie;\n\n\tedp->tabs = malloc(edp->ncols, M_DEVBUF, M_NOWAIT);\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\tedp->dblwid = malloc(edp->nrows, M_DEVBUF, M_NOWAIT | M_ZERO);\n\tedp->dw = 0;\n#endif\n\tedp->dcsarg = malloc(DCS_MAXLEN, M_DEVBUF, M_NOWAIT);\n\tedp->isolatin1tab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);\n\tedp->decgraphtab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);\n\tedp->dectechtab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);\n\tedp->nrctab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);\n\tvt100_initchartables(edp);\n\twsemul_vt100_reset(edp);\n\treturn (edp);\n}\n\nvoid\nwsemul_vt100_detach(void *cookie, u_int *crowp, u_int *ccolp)\n{\n\tstruct wsemul_vt100_emuldata *edp = cookie;\n\n\t*crowp = edp->crow;\n\t*ccolp = edp->ccol;\n#define f(ptr) do { free(ptr, M_DEVBUF, 0); ptr = NULL; } while (0)\n\tf(edp->tabs);\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\tf(edp->dblwid);\n#endif\n\tf(edp->dcsarg);\n\tf(edp->isolatin1tab);\n\tf(edp->decgraphtab);\n\tf(edp->dectechtab);\n\tf(edp->nrctab);\n#undef f\n\tif (edp != &wsemul_vt100_console_emuldata)\n\t\tfree(edp, M_DEVBUF, sizeof *edp);\n}\n\nvoid\nwsemul_vt100_resetop(void *cookie, enum wsemul_resetops op)\n{\n\tstruct wsemul_vt100_emuldata *edp = cookie;\n\n\tswitch (op) {\n\tcase WSEMUL_RESET:\n\t\twsemul_vt100_reset(edp);\n\t\tbreak;\n\tcase WSEMUL_SYNCFONT:\n\t\tvt100_initchartables(edp);\n\t\tbreak;\n\tcase WSEMUL_CLEARSCREEN:\n\t\t(void)wsemul_vt100_ed(edp, 2);\n\t\tedp->ccol = edp->crow = 0;\n\t\t(*edp->emulops->cursor)(edp->emulcookie,\n\t\t    edp->flags & VTFL_CURSORON, 0, 0);\n\t\tbreak;\n\tcase WSEMUL_CLEARCURSOR:\n\t\t(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow,\n\t\t    edp->ccol);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid\nwsemul_vt100_reset(struct wsemul_vt100_emuldata *edp)\n{\n\tint i;\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\tedp->flags = VTFL_DECAWM | VTFL_CURSORON;\n\tedp->bkgdattr = edp->curattr = edp->defattr;\n\tedp->attrflags = 0;\n\tedp->fgcol = WSCOL_WHITE;\n\tedp->bgcol = WSCOL_BLACK;\n\tedp->scrreg_startrow = 0;\n\tedp->scrreg_nrows = edp->nrows;\n\tif (edp->tabs) {\n\t\tmemset(edp->tabs, 0, edp->ncols);\n\t\tfor (i = 8; i < edp->ncols; i += 8)\n\t\t\tedp->tabs[i] = 1;\n\t}\n\tedp->dcspos = 0;\n\tedp->dcstype = 0;\n\tedp->chartab_G[0] = NULL;\n\tedp->chartab_G[1] = edp->nrctab; /* ??? */\n\tedp->chartab_G[2] = edp->isolatin1tab;\n\tedp->chartab_G[3] = edp->isolatin1tab;\n\tedp->chartab0 = 0;\n\tedp->chartab1 = 2;\n\tedp->sschartab = 0;\n\tedp->instate.inchar = 0;\n\tedp->instate.lbound = 0;\n\tedp->instate.mbleft = 0;\n\tedp->kstate.inchar = 0;\n\tedp->kstate.lbound = 0;\n\tedp->kstate.mbleft = 0;\n}\n\n/*\n * Move the cursor to the next line if possible. If the cursor is at\n * the bottom of the scroll area, then scroll it up. If the cursor is\n * at the bottom of the screen then don't move it down.\n */\nint\nwsemul_vt100_nextline(struct wsemul_vt100_emuldata *edp)\n{\n\tint rc;\n\n\tif (ROWS_BELOW == 0) {\n\t\t/* Bottom of the scroll region. */\n\t  \trc = wsemul_vt100_scrollup(edp, 1);\n\t} else {\n\t\tif ((edp->crow+1) < edp->nrows)\n\t\t\t/* Cursor not at the bottom of the screen. */\n\t\t\tedp->crow++;\n\t\tCHECK_DW;\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\n/*\n * now all the state machine bits\n */\n\nint\nwsemul_vt100_output_normal(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate, int kernel)\n{\n\tu_int *ct, dc;\n\tu_char c;\n\tint oldsschartab = edp->sschartab;\n\tint rc = 0;\n\n\tif ((edp->flags & (VTFL_LASTCHAR | VTFL_DECAWM)) ==\n\t    (VTFL_LASTCHAR | VTFL_DECAWM)) {\n\t\trc = wsemul_vt100_nextline(edp);\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t\tedp->ccol = 0;\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\t}\n\n#ifdef HAVE_UTF8_SUPPORT\n\tif (edp->flags & VTFL_UTF8) {\n\t\t(*edp->emulops->mapchar)(edp->emulcookie, instate->inchar, &dc);\n\t} else\n#endif\n\t{\n\t\tc = instate->inchar & 0xff;\n\t\tif (c & 0x80) {\n\t\t\tc &= 0x7f;\n\t\t\tct = edp->chartab_G[edp->chartab1];\n\t\t} else {\n\t\t\tif (edp->sschartab) {\n\t\t\t\tct = edp->chartab_G[edp->sschartab];\n\t\t\t\tedp->sschartab = 0;\n\t\t\t} else\n\t\t\t\tct = edp->chartab_G[edp->chartab0];\n\t\t}\n\t\tdc = ct ? ct[c] : c;\n\t}\n\n\tif ((edp->flags & VTFL_INSERTMODE) && COLS_LEFT) {\n\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t    COPYCOLS(edp->ccol, edp->ccol + 1, COLS_LEFT));\n\t\tif (rc != 0) {\n\t\t\t/* undo potential sschartab update */\n\t\t\tedp->sschartab = oldsschartab;\n\n\t\t\treturn rc;\n\t\t}\n\t}\n\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\tWSEMULOP(rc, edp, &edp->abortstate, putchar,\n\t    (edp->emulcookie, edp->crow, edp->ccol << edp->dw, dc,\n\t     kernel ? edp->kernattr : edp->curattr));\n#else\n\tWSEMULOP(rc, edp, &edp->abortstate, putchar,\n\t    (edp->emulcookie, edp->crow, edp->ccol, dc,\n\t     kernel ? edp->kernattr : edp->curattr));\n#endif\n\tif (rc != 0) {\n\t\t/* undo potential sschartab update */\n\t\tedp->sschartab = oldsschartab;\n\n\t\treturn rc;\n\t}\n\n\tif (COLS_LEFT)\n\t\tedp->ccol++;\n\telse\n\t\tedp->flags |= VTFL_LASTCHAR;\n\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate, int kernel)\n{\n\tu_int n;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase ASCII_NUL:\n\tdefault:\n\t\t/* ignore */\n\t\tbreak;\n\tcase ASCII_BEL:\n\t\tif (edp->state == VT100_EMUL_STATE_STRING) {\n\t\t\t/* acts as an equivalent to the ``ESC \\'' string end */\n\t\t\twsemul_vt100_handle_dcs(edp);\n\t\t\tedp->state = VT100_EMUL_STATE_NORMAL;\n\t\t} else {\n\t\t\twsdisplay_emulbell(edp->cbcookie);\n\t\t}\n\t\tbreak;\n\tcase ASCII_BS:\n\t\tif (edp->ccol > 0) {\n\t\t\tedp->ccol--;\n\t\t\tedp->flags &= ~VTFL_LASTCHAR;\n\t\t}\n\t\tbreak;\n\tcase ASCII_CR:\n\t\tedp->ccol = 0;\n\t\tbreak;\n\tcase ASCII_HT:\n\t\tif (edp->tabs) {\n\t\t\tif (!COLS_LEFT)\n\t\t\t\tbreak;\n\t\t\tfor (n = edp->ccol + 1; n < NCOLS - 1; n++)\n\t\t\t\tif (edp->tabs[n])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tn = edp->ccol + min(8 - (edp->ccol & 7), COLS_LEFT);\n\t\t}\n\t\tedp->ccol = n;\n\t\tbreak;\n\tcase ASCII_SO: /* LS1 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab0 = 1;\n\t\tbreak;\n\tcase ASCII_SI: /* LS0 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab0 = 0;\n\t\tbreak;\n\tcase ASCII_ESC:\n\t\tif (kernel) {\n\t\t\tprintf(\"wsemul_vt100_output_c0c1: ESC in kernel \"\n\t\t\t    \"output ignored\\n\");\n\t\t\tbreak;\t/* ignore the ESC */\n\t\t}\n\n\t\tif (edp->state == VT100_EMUL_STATE_STRING) {\n\t\t\t/* might be a string end */\n\t\t\tedp->state = VT100_EMUL_STATE_STRING_ESC;\n\t\t} else {\n\t\t\t/* XXX cancel current escape sequence */\n\t\t\tedp->state = VT100_EMUL_STATE_ESC;\n\t\t}\n\t\tbreak;\n\tcase ASCII_CAN:\n\tcase ASCII_SUB:\n\t\t/* cancel current escape sequence */\n\t\tedp->state = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\tcase ASCII_LF:\n\tcase ASCII_VT:\n\tcase ASCII_FF:\n\t\trc = wsemul_vt100_nextline(edp);\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\treturn rc;\n}\n\nint\nwsemul_vt100_output_esc(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_NORMAL;\n\tint rc = 0;\n\tint i;\n\n\tswitch (instate->inchar) {\n\tcase '[': /* CSI */\n\t\tedp->nargs = 0;\n\t\tmemset(edp->args, 0, sizeof (edp->args));\n\t\tedp->modif1 = edp->modif2 = '\\0';\n\t\tnewstate = VT100_EMUL_STATE_CSI;\n\t\tbreak;\n\tcase '7': /* DECSC */\n\t\tedp->flags |= VTFL_SAVEDCURS;\n\t\tedp->savedcursor_row = edp->crow;\n\t\tedp->savedcursor_col = edp->ccol;\n\t\tedp->savedattr = edp->curattr;\n\t\tedp->savedbkgdattr = edp->bkgdattr;\n\t\tedp->savedattrflags = edp->attrflags;\n\t\tedp->savedfgcol = edp->fgcol;\n\t\tedp->savedbgcol = edp->bgcol;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tedp->savedchartab_G[i] = edp->chartab_G[i];\n\t\tedp->savedchartab0 = edp->chartab0;\n\t\tedp->savedchartab1 = edp->chartab1;\n\t\tbreak;\n\tcase '8': /* DECRC */\n\t\tif ((edp->flags & VTFL_SAVEDCURS) == 0)\n\t\t\tbreak;\n\t\tedp->crow = edp->savedcursor_row;\n\t\tedp->ccol = edp->savedcursor_col;\n\t\tedp->curattr = edp->savedattr;\n\t\tedp->bkgdattr = edp->savedbkgdattr;\n\t\tedp->attrflags = edp->savedattrflags;\n\t\tedp->fgcol = edp->savedfgcol;\n\t\tedp->bgcol = edp->savedbgcol;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tedp->chartab_G[i] = edp->savedchartab_G[i];\n\t\tedp->chartab0 = edp->savedchartab0;\n\t\tedp->chartab1 = edp->savedchartab1;\n\t\tbreak;\n\tcase '=': /* DECKPAM application mode */\n\t\tedp->flags |= VTFL_APPLKEYPAD;\n\t\tbreak;\n\tcase '>': /* DECKPNM numeric mode */\n\t\tedp->flags &= ~VTFL_APPLKEYPAD;\n\t\tbreak;\n\tcase 'E': /* NEL */\n\t\tedp->ccol = 0;\n\t\t/* FALLTHROUGH */\n\tcase 'D': /* IND */\n\t\trc = wsemul_vt100_nextline(edp);\n\t\tbreak;\n\tcase 'H': /* HTS */\n\t\tif (edp->tabs != NULL)\n\t\t\tedp->tabs[edp->ccol] = 1;\n\t\tbreak;\n\tcase '~': /* LS1R */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab1 = 1;\n\t\tbreak;\n\tcase 'n': /* LS2 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab0 = 2;\n\t\tbreak;\n\tcase '}': /* LS2R */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab1 = 2;\n\t\tbreak;\n\tcase 'o': /* LS3 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab0 = 3;\n\t\tbreak;\n\tcase '|': /* LS3R */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab1 = 3;\n\t\tbreak;\n\tcase 'N': /* SS2 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->sschartab = 2;\n\t\tbreak;\n\tcase 'O': /* SS3 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->sschartab = 3;\n\t\tbreak;\n\tcase 'M': /* RI */\n\t\ti = ROWS_ABOVE;\n\t\tif (i > 0) {\n\t\t\tif (edp->crow > 0)\n\t\t\t\tedp->crow--;\n\t\t\tCHECK_DW;\n\t\t} else if (i == 0) {\n\t\t\t/* Top of scroll region. */\n\t\t\trc = wsemul_vt100_scrolldown(edp, 1);\n\t\t}\n\t\tbreak;\n\tcase 'P': /* DCS */\n\t\tedp->nargs = 0;\n\t\tmemset(edp->args, 0, sizeof (edp->args));\n\t\tnewstate = VT100_EMUL_STATE_DCS;\n\t\tbreak;\n\tcase 'c': /* RIS */\n\t\twsemul_vt100_reset(edp);\n\t\trc = wsemul_vt100_ed(edp, 2);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tedp->ccol = edp->crow = 0;\n\t\tbreak;\n\tcase '(': case ')': case '*': case '+': /* SCS */\n\t\tedp->designating = instate->inchar - '(';\n\t\tnewstate = VT100_EMUL_STATE_SCS94;\n\t\tbreak;\n\tcase '-': case '.': case '/': /* SCS */\n\t\tedp->designating = instate->inchar - '-' + 1;\n\t\tnewstate = VT100_EMUL_STATE_SCS96;\n\t\tbreak;\n\tcase '#':\n\t\tnewstate = VT100_EMUL_STATE_ESC_HASH;\n\t\tbreak;\n\tcase ' ': /* 7/8 bit */\n\t\tnewstate = VT100_EMUL_STATE_ESC_SPC;\n\t\tbreak;\n\tcase ']': /* OSC operating system command */\n\tcase '^': /* PM privacy message */\n\tcase '_': /* APC application program command */\n\t\t/* ignored */\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tbreak;\n\tcase '<': /* exit VT52 mode - ignored */\n\t\tbreak;\n\tcase '%': /* UTF-8 encoding sequences */\n\t\tnewstate = VT100_EMUL_STATE_ESC_PERCENT;\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC %x unknown\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_scs94(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_NORMAL;\n\n\tswitch (instate->inchar) {\n\tcase '%': /* probably DEC supplemental graphic */\n\t\tnewstate = VT100_EMUL_STATE_SCS94_PERCENT;\n\t\tbreak;\n\tcase 'A': /* british / national */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->nrctab;\n\t\tbreak;\n\tcase 'B': /* ASCII */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = 0;\n\t\tbreak;\n\tcase '<': /* user preferred supplemental */\n\t\t/* XXX not really \"user\" preferred */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->isolatin1tab;\n\t\tbreak;\n\tcase '0': /* DEC special graphic */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->decgraphtab;\n\t\tbreak;\n\tcase '>': /* DEC tech */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->dectechtab;\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC%c %x unknown\\n\", edp->designating + '(',\n\t\t    instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_scs94_percent(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase '5': /* DEC supplemental graphic */\n\t\t/* XXX there are differences */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->isolatin1tab;\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC%c%% %x unknown\\n\", edp->designating + '(',\n\t\t    instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_scs96(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_NORMAL;\n\tint nrc;\n\n\tswitch (instate->inchar) {\n\tcase '%': /* probably portuguese */\n\t\tnewstate = VT100_EMUL_STATE_SCS96_PERCENT;\n\t\tbreak;\n\tcase 'A': /* ISO-latin-1 supplemental */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->isolatin1tab;\n\t\tbreak;\n\tcase '4': /* dutch */\n\t\tnrc = 1;\n\t\tgoto setnrc;\n\tcase '5': case 'C': /* finnish */\n\t\tnrc = 2;\n\t\tgoto setnrc;\n\tcase 'R': /* french */\n\t\tnrc = 3;\n\t\tgoto setnrc;\n\tcase 'Q': /* french canadian */\n\t\tnrc = 4;\n\t\tgoto setnrc;\n\tcase 'K': /* german */\n\t\tnrc = 5;\n\t\tgoto setnrc;\n\tcase 'Y': /* italian */\n\t\tnrc = 6;\n\t\tgoto setnrc;\n\tcase 'E': case '6': /* norwegian / danish */\n\t\tnrc = 7;\n\t\tgoto setnrc;\n\tcase 'Z': /* spanish */\n\t\tnrc = 9;\n\t\tgoto setnrc;\n\tcase '7': case 'H': /* swedish */\n\t\tnrc = 10;\n\t\tgoto setnrc;\n\tcase '=': /* swiss */\n\t\tnrc = 11;\nsetnrc:\n\t\tif (vt100_setnrc(edp, nrc) == 0) /* what table ??? */\n\t\t\tbreak;\n\t\t/* else FALLTHROUGH */\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC%c %x unknown\\n\", edp->designating + '-' - 1,\n\t\t    instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_scs96_percent(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase '6': /* portuguese */\n\t\tif (vt100_setnrc(edp, 8) == 0)\n\t\t\tbreak;\n\t\t/* else FALLTHROUGH */\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC%c%% %x unknown\\n\", edp->designating + '-' - 1,\n\t\t    instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_esc_spc(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase 'F': /* 7-bit controls */\n\tcase 'G': /* 8-bit controls */\n#ifdef VT100_PRINTNOTIMPL\n\t\tprintf(\"ESC<SPC> %x ignored\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC<SPC> %x unknown\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_string(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tif (edp->dcsarg && edp->dcstype && edp->dcspos < DCS_MAXLEN) {\n\t\tif (instate->inchar & ~0xff) {\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"unknown char %x in DCS\\n\", instate->inchar);\n#endif\n\t\t} else\n\t\t\tedp->dcsarg[edp->dcspos++] = (char)instate->inchar;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_STRING;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_string_esc(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tif (instate->inchar == '\\\\') { /* ST complete */\n\t\twsemul_vt100_handle_dcs(edp);\n\t\tedp->state = VT100_EMUL_STATE_NORMAL;\n\t} else\n\t\tedp->state = VT100_EMUL_STATE_STRING;\n\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/* argument digit */\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': /* argument terminator */\n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': /* DECDLD soft charset */\t/* } */\n\t\tcase '!': /* DECRQUPSS user preferred supplemental set */\n\t\t\t/* 'u' must follow - need another state */\n\t\tcase '|': /* DECUDK program F6..F20 */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_dcs_dollar(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase 'p': /* DECRSTS terminal state restore */\n\tcase 'q': /* DECRQSS control function request */\n#ifdef VT100_PRINTNOTIMPL\n\t\tprintf(\"DCS$%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\tbreak;\n\tcase 't': /* DECRSPS restore presentation state */\n\t\tswitch (ARG(0)) {\n\t\tcase 0: /* error */\n\t\t\tbreak;\n\t\tcase 1: /* cursor information restore */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS1$t ignored\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 2: /* tab stop restore */\n\t\t\tedp->dcspos = 0;\n\t\t\tedp->dcstype = DCSTYPE_TABRESTORE;\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS%d$t unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"DCS$ %x (%d, %d) unknown\\n\",\n\t\t    instate->inchar, ARG(0), ARG(1));\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_STRING;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_esc_percent(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n#ifdef HAVE_UTF8_SUPPORT\n\tcase 'G':\n\t\tedp->flags |= VTFL_UTF8;\n\t\tedp->kstate.mbleft = edp->instate.mbleft = 0;\n\t\tbreak;\n\tcase '@':\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tbreak;\n#endif\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC% %x unknown\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_esc_hash(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase '5': /*  DECSWL single width, single height */\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\t\tif (edp->dblwid != NULL && edp->dw != 0) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < edp->ncols / 2; i++) {\n\t\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t\t\t    (edp->emulcookie, edp->crow, 2 * i, i, 1));\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t\t    (edp->emulcookie, edp->crow, i, edp->ncols - i,\n\t\t\t     edp->bkgdattr));\n\t\t\tif (rc != 0)\n\t\t\t\treturn rc;\n\t\t\tedp->dblwid[edp->crow] = 0;\n\t\t\tedp->dw = 0;\n\t\t}\n#endif\n\t\tbreak;\n\tcase '6': /*  DECDWL double width, single height */\n\tcase '3': /*  DECDHL double width, double height, top half */\n\tcase '4': /*  DECDHL double width, double height, bottom half */\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\t\tif (edp->dblwid != NULL && edp->dw == 0) {\n\t\t\tint i;\n\t\t\tfor (i = edp->ncols / 2 - 1; i >= 0; i--) {\n\t\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t\t\t    (edp->emulcookie, edp->crow, i, 2 * i, 1));\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tfor (i = 0; i < edp->ncols / 2; i++) {\n\t\t\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t\t\t    (edp->emulcookie, edp->crow, 2 * i + 1, 1,\n\t\t\t\t     edp->bkgdattr));\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tedp->dblwid[edp->crow] = 1;\n\t\t\tedp->dw = 1;\n\t\t\tif (edp->ccol > (edp->ncols >> 1) - 1)\n\t\t\t\tedp->ccol = (edp->ncols >> 1) - 1;\n\t\t}\n#endif\n\t\tbreak;\n\tcase '8': { /* DECALN */\n\t\tint i, j;\n\t\tfor (i = 0; i < edp->nrows; i++)\n\t\t\tfor (j = 0; j < edp->ncols; j++) {\n\t\t\t\tWSEMULOP(rc, edp, &edp->abortstate, putchar,\n\t\t\t\t    (edp->emulcookie, i, j, 'E', edp->curattr));\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tedp->ccol = 0;\n\t\tedp->crow = 0;\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC# %x unknown\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/* argument digit */\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': /* argument terminator */\n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': /* DEC specific */\n\tcase '>': /* DA query */\n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: /* end of escape sequence */\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nu_int\nwsemul_vt100_output(void *cookie, const u_char *data, u_int count, int kernel)\n{\n\tstruct wsemul_vt100_emuldata *edp = cookie;\n\tstruct wsemul_inputstate *instate;\n\tu_int prev_count, processed = 0;\n#ifdef HAVE_JUMP_SCROLL\n\tint lines;\n#endif\n\tint rc = 0;\n\n#ifdef DIAGNOSTIC\n\tif (kernel && !edp->console)\n\t\tpanic(\"wsemul_vt100_output: kernel output, not console\");\n#endif\n\n\tinstate = kernel ? &edp->kstate : &edp->instate;\n\n\tswitch (edp->abortstate.state) {\n\tcase ABORT_FAILED_CURSOR:\n\t\t/*\n\t\t * If we could not display the cursor back, we pretended not\n\t\t * having been able to process the last byte. But this\n\t\t * is a lie, so compensate here.\n\t\t */\n\t\tdata++, count--;\n\t\tprocessed++;\n\t\twsemul_reset_abortstate(&edp->abortstate);\n\t\tbreak;\n\tcase ABORT_OK:\n\t\t/* remove cursor image if visible */\n\t\tif (edp->flags & VTFL_CURSORON) {\n\t\t\trc = (*edp->emulops->cursor)\n\t\t\t    (edp->emulcookie, 0, edp->crow,\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\t\t\t     edp->ccol << edp->dw);\n#else\n\t\t\t     edp->ccol);\n#endif\n\t\t\tif (rc != 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (;;) {\n#ifdef HAVE_JUMP_SCROLL\n\t\tswitch (edp->abortstate.state) {\n\t\tcase ABORT_FAILED_JUMP_SCROLL:\n\t\t\t/*\n\t\t\t * If we failed a previous jump scroll attempt, we\n\t\t\t * need to try to resume it with the same distance.\n\t\t\t * We can not recompute it since there might be more\n\t\t\t * bytes in the tty ring, causing a different result.\n\t\t\t */\n\t\t\tlines = edp->abortstate.lines;\n\t\t\tbreak;\n\t\tcase ABORT_OK:\n\t\t\t/*\n\t\t\t * If we are at the bottom of the scrolling area, count\n\t\t\t * newlines until an escape sequence appears.\n\t\t\t */\n\t\t\tif ((edp->state == VT100_EMUL_STATE_NORMAL || kernel) &&\n\t\t\t    ROWS_BELOW == 0)\n\t\t\t\tlines = wsemul_vt100_jump_scroll(edp, data,\n\t\t\t\t    count, kernel);\n\t\t\telse\n\t\t\t\tlines = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * If we are recovering a non-scrolling failure,\n\t\t\t * do not try to scroll yet.\n\t\t\t */\n\t\t\tlines = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (lines > 1) {\n\t\t\twsemul_resume_abort(&edp->abortstate);\n\t\t\trc = wsemul_vt100_scrollup(edp, lines);\n\t\t\tif (rc != 0) {\n\t\t\t\twsemul_abort_jump_scroll(&edp->abortstate,\n\t\t\t\t    lines);\n\t\t\t\treturn processed;\n\t\t\t}\n\t\t\twsemul_reset_abortstate(&edp->abortstate);\n\t\t\tedp->crow -= lines;\n\t\t}\n#endif\n\n\t\twsemul_resume_abort(&edp->abortstate);\n\n\t\tprev_count = count;\n\t\tif (wsemul_getchar(&data, &count, instate,\n#ifdef HAVE_UTF8_SUPPORT\n\t\t    (edp->state == VT100_EMUL_STATE_NORMAL && !kernel) ?\n\t\t      edp->flags & VTFL_UTF8 : 0\n#else\n\t\t    0\n#endif\n\t\t    ) != 0)\n\t\t\tbreak;\n\n\t\tif (!(instate->inchar & ~0xff) &&\n\t\t    (instate->inchar & 0x7f) < 0x20) {\n\t\t\trc = wsemul_vt100_output_c0c1(edp, instate, kernel);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tprocessed += prev_count - count;\n \t\t\tcontinue;\n \t\t}\n\n\t\tif (edp->state == VT100_EMUL_STATE_NORMAL || kernel) {\n\t\t\trc = wsemul_vt100_output_normal(edp, instate, kernel);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tprocessed += prev_count - count;\n\t\t\tcontinue;\n\t\t}\n#ifdef DIAGNOSTIC\n\t\tif (edp->state > nitems(vt100_output))\n\t\t\tpanic(\"wsemul_vt100: invalid state %d\", edp->state);\n#endif\n\t\trc = vt100_output[edp->state - 1](edp, instate);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tprocessed += prev_count - count;\n\t}\n\n\tif (rc != 0)\n\t\twsemul_abort_other(&edp->abortstate);\n\telse {\n\t\t/* put cursor image back if visible */\n\t\tif (edp->flags & VTFL_CURSORON) {\n\t\t\trc = (*edp->emulops->cursor)\n\t\t\t    (edp->emulcookie, 1, edp->crow,\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\t\t\t     edp->ccol << edp->dw);\n#else\n\t\t\t     edp->ccol);\n#endif\n\t\t\tif (rc != 0) {\n\t\t\t\t/*\n\t\t\t\t * Pretend the last byte hasn't been processed,\n\t\t\t\t * while remembering that only the cursor\n\t\t\t\t * operation really needs to be done.\n\t\t\t\t */\n\t\t\t\twsemul_abort_cursor(&edp->abortstate);\n\t\t\t\tprocessed--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rc == 0)\n\t\twsemul_reset_abortstate(&edp->abortstate);\n\n\treturn processed;\n}\n\n#ifdef HAVE_JUMP_SCROLL\nint\nwsemul_vt100_jump_scroll(struct wsemul_vt100_emuldata *edp, const u_char *data,\n    u_int count, int kernel)\n{\n\tstruct wsemul_inputstate tmpstate;\n\tu_int pos, lines;\n\n\tlines = 0;\n\tpos = edp->ccol;\n\ttmpstate = kernel ? edp->kstate : edp->instate;\t/* structure copy */\n\n\twhile (wsemul_getchar(&data, &count, &tmpstate,\n#ifdef HAVE_UTF8_SUPPORT\n\t    kernel ? 0 : edp->flags & VTFL_UTF8\n#else\n\t    0\n#endif\n\t    ) == 0) {\n\t\t/*\n\t\t * Only char causing a transition from\n\t\t * VT100_EMUL_STATE_NORMAL to another state, for now.\n\t\t * Revisit this if this changes...\n\t\t */\n\t\tif (tmpstate.inchar == ASCII_ESC)\n\t\t\tbreak;\n\n\t\tif (ISSET(edp->flags, VTFL_DECAWM))\n\t\t\tswitch (tmpstate.inchar) {\n\t\t\tcase ASCII_BS:\n\t\t\t\tif (pos > 0)\n\t\t\t\t\tpos--;\n\t\t\t\tbreak;\n\t\t\tcase ASCII_CR:\n\t\t\t\tpos = 0;\n\t\t\t\tbreak;\n\t\t\tcase ASCII_HT:\n\t\t\t\tif (edp->tabs) {\n\t\t\t\t\tpos++;\n\t\t\t\t\twhile (pos < NCOLS - 1 &&\n\t\t\t\t\t    edp->tabs[pos] == 0)\n\t\t\t\t\t\tpos++;\n\t\t\t\t} else {\n\t\t\t\t\tpos = (pos + 7) & ~7;\n\t\t\t\t\tif (pos >= NCOLS)\n\t\t\t\t\t\tpos = NCOLS - 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!(tmpstate.inchar & ~0xff) &&\n\t\t\t\t    (tmpstate.inchar & 0x7f) < 0x20)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pos++ >= NCOLS) {\n\t\t\t\t\tpos = 0;\n\t\t\t\t\ttmpstate.inchar = ASCII_LF;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (tmpstate.inchar == ASCII_LF ||\n\t\t    tmpstate.inchar == ASCII_VT ||\n\t\t    tmpstate.inchar == ASCII_FF) {\n\t\t\tif (++lines >= edp->scrreg_nrows - 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n#endif\n"], "fixing_code": ["/* $OpenBSD: wsemul_sun.c,v 1.37 2023/07/24 17:03:32 miod Exp $ */\n/* $NetBSD: wsemul_sun.c,v 1.11 2000/01/05 11:19:36 drochner Exp $ */\n\n/*\n * Copyright (c) 2007, 2013 Miodrag Vallat.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice, this permission notice, and the disclaimer below\n * appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n/*\n * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *      This product includes software developed by Christopher G. Demetriou\n *\tfor the NetBSD Project.\n * 4. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This file implements a sun terminal personality for wscons.\n *\n * Derived from old rcons code.\n * Color support from NetBSD's rcons color code, and wsemul_vt100.\n */\n\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n\n#include <dev/wscons/wscons_features.h>\n#include <dev/wscons/wsconsio.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/ascii.h>\n\nvoid\t*wsemul_sun_cnattach(const struct wsscreen_descr *, void *,\n    int, int, uint32_t);\nvoid\t*wsemul_sun_attach(int, const struct wsscreen_descr *,\n    void *, int, int, void *, uint32_t);\nu_int\twsemul_sun_output(void *, const u_char *, u_int, int);\nint\twsemul_sun_translate(void *, kbd_t, keysym_t, const u_char **);\nvoid\twsemul_sun_detach(void *, u_int *, u_int *);\nvoid\twsemul_sun_resetop(void *, enum wsemul_resetops);\n\nconst struct wsemul_ops wsemul_sun_ops = {\n\t\"sun\",\n\twsemul_sun_cnattach,\n\twsemul_sun_attach,\n\twsemul_sun_output,\n\twsemul_sun_translate,\n\twsemul_sun_detach,\n\twsemul_sun_resetop\n};\n\n#define\tSUN_EMUL_STATE_NORMAL\t0\t/* normal processing */\n#define\tSUN_EMUL_STATE_HAVEESC\t1\t/* seen start of ctl seq */\n#define\tSUN_EMUL_STATE_CONTROL\t2\t/* processing ESC [ ctl seq */\n#define\tSUN_EMUL_STATE_PERCENT\t3\t/* processing ESC % ctl seq */\n\n#define\tSUN_EMUL_FLAGS_UTF8\t0x01\t/* UTF-8 character set */\n\n#define\tSUN_EMUL_NARGS\t2\t\t/* max # of args to a command */\n\nstruct wsemul_sun_emuldata {\n\tconst struct wsdisplay_emulops *emulops;\n\tstruct wsemul_abortstate abortstate;\n\tvoid *emulcookie;\n\tvoid *cbcookie;\n\tint scrcapabilities;\n\tu_int nrows, ncols, crow, ccol;\n\tuint32_t defattr;\t\t/* default attribute (rendition) */\n\n\tu_int state;\t\t\t/* processing state */\n\tu_int flags;\n\tu_int args[SUN_EMUL_NARGS];\t/* command args, if CONTROL */\n\tint nargs;\t\t\t/* number of args */\n\n\tu_int scrolldist;\t\t/* distance to scroll */\n\tuint32_t curattr, bkgdattr;\t/* currently used attribute */\n\tuint32_t kernattr;\t\t/* attribute for kernel output */\n\tint attrflags, fgcol, bgcol;\t/* properties of curattr */\n\n\tstruct wsemul_inputstate instate;\t/* userland input state */\n\tstruct wsemul_inputstate kstate;\t/* kernel input state */\n\n#ifdef HAVE_UTF8_SUPPORT\n\tu_char translatebuf[4];\n#else\n\tu_char translatebuf[1];\n#endif\n\n#ifdef DIAGNOSTIC\n\tint console;\n#endif\n};\n\nvoid\twsemul_sun_init(struct wsemul_sun_emuldata *,\n\t    const struct wsscreen_descr *, void *, int, int, uint32_t);\nint\twsemul_sun_jump_scroll(struct wsemul_sun_emuldata *, const u_char *,\n\t    u_int, int);\nvoid\twsemul_sun_reset(struct wsemul_sun_emuldata *);\nint\twsemul_sun_output_lowchars(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *, int);\nint\twsemul_sun_output_normal(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *, int);\nint\twsemul_sun_output_haveesc(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *);\nint\twsemul_sun_output_control(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *);\nint\twsemul_sun_output_percent(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *);\nint\twsemul_sun_control(struct wsemul_sun_emuldata *,\n\t    struct wsemul_inputstate *);\nint\twsemul_sun_selectattribute(struct wsemul_sun_emuldata *, int, int, int,\n\t    uint32_t *, uint32_t *);\nint\twsemul_sun_scrollup(struct wsemul_sun_emuldata *, u_int);\n\nstruct wsemul_sun_emuldata wsemul_sun_console_emuldata;\n\n/* some useful utility macros */\n#define\tARG(n,c) \\\n\t((n) >= edp->nargs ? 0 : edp->args[(n) + MAX(0, edp->nargs - (c))])\n#define\tNORMALIZE(arg)\t\t((arg) != 0 ? (arg) : 1)\n#define\tCOLS_LEFT\t\t(edp->ncols - 1 - edp->ccol)\n#define\tROWS_LEFT\t\t(edp->nrows - 1 - edp->crow)\n\nvoid\nwsemul_sun_init(struct wsemul_sun_emuldata *edp,\n    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,\n    uint32_t defattr)\n{\n\tedp->emulops = type->textops;\n\tedp->emulcookie = cookie;\n\tedp->scrcapabilities = type->capabilities;\n\tedp->nrows = type->nrows;\n\tedp->ncols = type->ncols;\n\tedp->crow = crow;\n\tedp->ccol = ccol;\n\tedp->defattr = defattr;\n\twsemul_reset_abortstate(&edp->abortstate);\n}\n\nvoid\nwsemul_sun_reset(struct wsemul_sun_emuldata *edp)\n{\n\tedp->flags = 0;\n\tedp->state = SUN_EMUL_STATE_NORMAL;\n\tedp->bkgdattr = edp->curattr = edp->defattr;\n\tedp->attrflags = 0;\n\tedp->fgcol = WSCOL_BLACK;\n\tedp->bgcol = WSCOL_WHITE;\n\tedp->scrolldist = 1;\n\tedp->instate.inchar = 0;\n\tedp->instate.lbound = 0;\n\tedp->instate.mbleft = 0;\n\tedp->kstate.inchar = 0;\n\tedp->kstate.lbound = 0;\n\tedp->kstate.mbleft = 0;\n}\n\nvoid *\nwsemul_sun_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,\n    int crow, uint32_t defattr)\n{\n\tstruct wsemul_sun_emuldata *edp;\n\tint res;\n\n\tedp = &wsemul_sun_console_emuldata;\n\twsemul_sun_init(edp, type, cookie, ccol, crow, defattr);\n\n#ifndef WS_KERNEL_FG\n#define WS_KERNEL_FG WSCOL_BLACK\n#endif\n#ifndef WS_KERNEL_BG\n#define WS_KERNEL_BG WSCOL_WHITE\n#endif\n#ifndef WS_KERNEL_COLATTR\n#define WS_KERNEL_COLATTR 0\n#endif\n#ifndef WS_KERNEL_MONOATTR\n#define WS_KERNEL_MONOATTR 0\n#endif\n\tif (type->capabilities & WSSCREEN_WSCOLORS)\n\t\tres = (*edp->emulops->pack_attr)(cookie,\n\t\t\t\t\t    WS_KERNEL_FG, WS_KERNEL_BG,\n\t\t\t\t\t    WS_KERNEL_COLATTR | WSATTR_WSCOLORS,\n\t\t\t\t\t    &edp->kernattr);\n\telse\n\t\tres = (*edp->emulops->pack_attr)(cookie, 0, 0,\n\t\t\t\t\t    WS_KERNEL_MONOATTR,\n\t\t\t\t\t    &edp->kernattr);\n\tif (res)\n\t\tedp->kernattr = defattr;\n\n\tedp->cbcookie = NULL;\n\n#ifdef DIAGNOSTIC\n\tedp->console = 1;\n#endif\n\n\twsemul_sun_reset(edp);\n\treturn (edp);\n}\n\nvoid *\nwsemul_sun_attach(int console, const struct wsscreen_descr *type, void *cookie,\n    int ccol, int crow, void *cbcookie, uint32_t defattr)\n{\n\tstruct wsemul_sun_emuldata *edp;\n\n\tif (console) {\n\t\tedp = &wsemul_sun_console_emuldata;\n#ifdef DIAGNOSTIC\n\t\tKASSERT(edp->console == 1);\n#endif\n\t} else {\n\t\tedp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);\n\t\tif (edp == NULL)\n\t\t\treturn (NULL);\n\t\twsemul_sun_init(edp, type, cookie, ccol, crow, defattr);\n\n#ifdef DIAGNOSTIC\n\t\tedp->console = 0;\n#endif\n\t}\n\n\tedp->cbcookie = cbcookie;\n\n\twsemul_sun_reset(edp);\n\treturn (edp);\n}\n\nint\nwsemul_sun_output_lowchars(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate, int kernel)\n{\n\tu_int n;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase ASCII_NUL:\n\tdefault:\n\t\t/* ignore */\n\t\tbreak;\n\n\tcase ASCII_BEL:\t\t/* \"Bell (BEL)\" */\n\t\twsdisplay_emulbell(edp->cbcookie);\n\t\tbreak;\n\n\tcase ASCII_BS:\t\t/* \"Backspace (BS)\" */\n\t\tif (edp->ccol > 0)\n\t\t\tedp->ccol--;\n\t\tbreak;\n\n\tcase ASCII_CR:\t\t/* \"Return (CR)\" */\n\t\tedp->ccol = 0;\n\t\tbreak;\n\n\tcase ASCII_HT:\t\t/* \"Tab (TAB)\" */\n\t\tn = min(8 - (edp->ccol & 7), COLS_LEFT);\n\t\tif (n != 0) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t\t    (edp->emulcookie, edp->crow, edp->ccol, n,\n\t\t\t     kernel ? edp->kernattr : edp->bkgdattr));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tedp->ccol += n;\n\t\t}\n\t\tbreak;\n\n\tcase ASCII_FF:\t\t/* \"Form Feed (FF)\" */\n\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t    (edp->emulcookie, 0, edp->nrows, edp->bkgdattr));\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tedp->ccol = edp->crow = 0;\n\t\tbreak;\n\n\tcase ASCII_VT:\t\t/* \"Reverse Line Feed\" */\n\t\tif (edp->crow > 0)\n\t\t\tedp->crow--;\n\t\tbreak;\n\n\tcase ASCII_ESC:\t\t/* \"Escape (ESC)\" */\n\t\tif (kernel) {\n\t\t\tprintf(\"wsemul_sun_output_lowchars: ESC in kernel \"\n\t\t\t    \"output ignored\\n\");\n\t\t\tbreak;\t/* ignore the ESC */\n\t\t}\n\n\t\tedp->state = SUN_EMUL_STATE_HAVEESC;\n\t\tbreak;\n\n\tcase ASCII_LF:\t\t/* \"Line Feed (LF)\" */\n\t\t/* if the cur line isn't the last, incr and leave. */\n\t\tif (ROWS_LEFT > 0)\n\t\t\tedp->crow++;\n\t\telse {\n\t\t\trc = wsemul_sun_scrollup(edp, edp->scrolldist);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint\nwsemul_sun_output_normal(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate, int kernel)\n{\n\tint rc;\n\tu_int outchar;\n\n\t(*edp->emulops->mapchar)(edp->emulcookie, instate->inchar, &outchar);\n\tWSEMULOP(rc, edp, &edp->abortstate, putchar,\n\t    (edp->emulcookie, edp->crow, edp->ccol,\n\t     outchar, kernel ? edp->kernattr : edp->curattr));\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (++edp->ccol >= edp->ncols) {\n\t\t/* if the cur line isn't the last, incr and leave. */\n\t\tif (ROWS_LEFT > 0)\n\t\t\tedp->crow++;\n\t\telse {\n\t\t\trc = wsemul_sun_scrollup(edp, edp->scrolldist);\n\t\t\tif (rc != 0) {\n\t\t\t\t/* undo line wrap */\n\t\t\t\tedp->ccol--;\n\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tedp->ccol = 0;\n\t}\n\n\treturn 0;\n}\n\nint\nwsemul_sun_output_haveesc(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase '[':\t\t/* continuation of multi-char sequence */\n\t\tedp->nargs = 0;\n\t\tbzero(edp->args, sizeof (edp->args));\n\t\tedp->state = SUN_EMUL_STATE_CONTROL;\n\t\tbreak;\n#ifdef HAVE_UTF8_SUPPORT\n\tcase '%':\n\t\tedp->state = SUN_EMUL_STATE_PERCENT;\n\t\tbreak;\n#endif\n\tdefault:\n#ifdef DEBUG\n\t\tprintf(\"ESC %x unknown\\n\", instate->inchar);\n#endif\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\t/* XXX is this wise? */\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint\nwsemul_sun_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int n, src, dst;\n\tint flags, fgcol, bgcol;\n\tuint32_t attr, bkgdattr;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase '@':\t\t/* \"Insert Character (ICH)\" */\n\t\tn = min(NORMALIZE(ARG(0,1)), COLS_LEFT + 1);\n\t\tsrc = edp->ccol;\n\t\tdst = edp->ccol + n;\n\t\tif (dst < edp->ncols) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t\t    (edp->emulcookie, edp->crow, src, dst,\n\t\t\t     edp->ncols - dst));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t    (edp->emulcookie, edp->crow, src, n, edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'A':\t\t/* \"Cursor Up (CUU)\" */\n\t\tedp->crow -= min(NORMALIZE(ARG(0,1)), edp->crow);\n\t\tbreak;\n\n\tcase 'E':\t\t/* \"Cursor Next Line (CNL)\" */\n\t\tedp->ccol = 0;\n\t\t/* FALLTHROUGH */\n\tcase 'B':\t\t/* \"Cursor Down (CUD)\" */\n\t\tedp->crow += min(NORMALIZE(ARG(0,1)), ROWS_LEFT);\n\t\tbreak;\n\n\tcase 'C':\t\t/* \"Cursor Forward (CUF)\" */\n\t\tedp->ccol += min(NORMALIZE(ARG(0,1)), COLS_LEFT);\n\t\tbreak;\n\n\tcase 'D':\t\t/* \"Cursor Backward (CUB)\" */\n\t\tedp->ccol -= min(NORMALIZE(ARG(0,1)), edp->ccol);\n\t\tbreak;\n\n\tcase 'f':\t\t/* \"Horizontal And Vertical Position (HVP)\" */\n\tcase 'H':\t\t/* \"Cursor Position (CUP)\" */\n\t\tedp->crow = min(NORMALIZE(ARG(0,2)), edp->nrows) - 1;\n\t\tedp->ccol = min(NORMALIZE(ARG(1,2)), edp->ncols) - 1;\n\t\tbreak;\n\n\tcase 'J':\t\t/* \"Erase in Display (ED)\" */\n\t\tif (ROWS_LEFT > 0) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t\t    (edp->emulcookie, edp->crow + 1, ROWS_LEFT,\n\t\t\t     edp->bkgdattr));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase 'K':\t\t/* \"Erase in Line (EL)\" */\n\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t    (edp->emulcookie, edp->crow, edp->ccol, COLS_LEFT + 1,\n\t\t     edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'L':\t\t/* \"Insert Line (IL)\" */\n\t\tn = min(NORMALIZE(ARG(0,1)), ROWS_LEFT + 1);\n\t\tsrc = edp->crow;\n\t\tdst = edp->crow + n;\n\t\tif (dst < edp->nrows) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copyrows,\n\t\t\t    (edp->emulcookie, src, dst, edp->nrows - dst));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t    (edp->emulcookie, src, n, edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'M':\t\t/* \"Delete Line (DL)\" */\n\t\tn = min(NORMALIZE(ARG(0,1)), ROWS_LEFT + 1);\n\t\tsrc = edp->crow + n;\n\t\tdst = edp->crow;\n\t\tif (src < edp->nrows) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copyrows,\n\t\t\t    (edp->emulcookie, src, dst, edp->nrows - src));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t    (edp->emulcookie, dst + edp->nrows - src, n,\n\t\t     edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'P':\t\t/* \"Delete Character (DCH)\" */\n\t\tn = min(NORMALIZE(ARG(0,1)), COLS_LEFT + 1);\n\t\tsrc = edp->ccol + n;\n\t\tdst = edp->ccol;\n\t\tif (src < edp->ncols) {\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t\t    (edp->emulcookie, edp->crow, src, dst,\n\t\t\t     edp->ncols - src));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t    (edp->emulcookie, edp->crow, edp->ncols - n, n,\n\t\t     edp->bkgdattr));\n\t\tbreak;\n\n\tcase 'm':\t\t/* \"Select Graphic Rendition (SGR)\" */\n\t\tflags = edp->attrflags;\n\t\tfgcol = edp->fgcol;\n\t\tbgcol = edp->bgcol;\n\n\t\tfor (n = 0; n < edp->nargs; n++) {\n\t\t\tswitch (ARG(n,edp->nargs)) {\n\t\t\t/* Clear all attributes || End underline */\n\t\t\tcase 0:\n\t\t\t\tif (n == edp->nargs - 1) {\n\t\t\t\t\tedp->bkgdattr =\n\t\t\t\t\t    edp->curattr = edp->defattr;\n\t\t\t\t\tedp->attrflags = 0;\n\t\t\t\t\tedp->fgcol = WSCOL_BLACK;\n\t\t\t\t\tedp->bgcol = WSCOL_WHITE;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tflags = 0;\n\t\t\t\tfgcol = WSCOL_BLACK;\n\t\t\t\tbgcol = WSCOL_WHITE;\n\t\t\t\tbreak;\n\t\t\t/* Begin bold */\n\t\t\tcase 1:\n\t\t\t\tflags |= WSATTR_HILIT;\n\t\t\t\tbreak;\n\t\t\t/* Begin underline */\n\t\t\tcase 4:\n\t\t\t\tflags |= WSATTR_UNDERLINE;\n\t\t\t\tbreak;\n\t\t\t/* Begin reverse */\n\t\t\tcase 7:\n\t\t\t\tflags |= WSATTR_REVERSE;\n\t\t\t\tbreak;\n\t\t\t/* ANSI foreground color */\n\t\t\tcase 30: case 31: case 32: case 33:\n\t\t\tcase 34: case 35: case 36: case 37:\n\t\t\t\tfgcol = ARG(n,edp->nargs) - 30;\n\t\t\t\tbreak;\n\t\t\t/* ANSI background color */\n\t\t\tcase 40: case 41: case 42: case 43:\n\t\t\tcase 44: case 45: case 46: case 47:\n\t\t\t\tbgcol = ARG(n,edp->nargs) - 40;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nsetattr:\n\t\tif (wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, &attr,\n\t\t    &bkgdattr)) {\n#ifdef DEBUG\n\t\t\tprintf(\"error allocating attr %d/%d/%x\\n\",\n\t\t\t    fgcol, bgcol, flags);\n#endif\n\t\t} else {\n\t\t\tedp->curattr = attr;\n\t\t\tedp->bkgdattr = bkgdattr;\n\t\t\tedp->attrflags = flags;\n\t\t\tedp->fgcol = fgcol;\n\t\t\tedp->bgcol = bgcol;\n\t\t}\n\t\tbreak;\n\n\tcase 'p':\t\t/* \"Black On White (SUNBOW)\" */\n\t\tflags = 0;\n\t\tfgcol = WSCOL_BLACK;\n\t\tbgcol = WSCOL_WHITE;\n\t\tgoto setattr;\n\n\tcase 'q':\t\t/* \"White On Black (SUNWOB)\" */\n\t\tflags = 0;\n\t\tfgcol = WSCOL_WHITE;\n\t\tbgcol = WSCOL_BLACK;\n\t\tgoto setattr;\n\n\tcase 'r':\t\t/* \"Set Scrolling (SUNSCRL)\" */\n\t\tedp->scrolldist = min(ARG(0,1), edp->nrows);\n\t\tbreak;\n\n\tcase 's':\t\t/* \"Reset Terminal Emulator (SUNRESET)\" */\n\t\twsemul_sun_reset(edp);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint\nwsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': /* argument digit */\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/*\n\t\t * If we receive more arguments than we are expecting,\n\t\t * discard the earliest arguments.\n\t\t */\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t/* argument terminator */\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t/* end of escape sequence */\n\t\toargs = edp->nargs;\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t/* undo nargs progress */\n\t\t\tedp->nargs = oargs;\n\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#ifdef HAVE_UTF8_SUPPORT\nint\nwsemul_sun_output_percent(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase 'G':\n\t\tedp->flags |= SUN_EMUL_FLAGS_UTF8;\n\t\tedp->kstate.mbleft = edp->instate.mbleft = 0;\n\t\tbreak;\n\tcase '@':\n\t\tedp->flags &= ~SUN_EMUL_FLAGS_UTF8;\n\t\tbreak;\n\t}\n\tedp->state = SUN_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n#endif\n\nu_int\nwsemul_sun_output(void *cookie, const u_char *data, u_int count, int kernel)\n{\n\tstruct wsemul_sun_emuldata *edp = cookie;\n\tstruct wsemul_inputstate *instate;\n\tu_int prev_count, processed = 0;\n#ifdef HAVE_JUMP_SCROLL\n\tint lines;\n#endif\n\tint rc = 0;\n\n#ifdef DIAGNOSTIC\n\tif (kernel && !edp->console)\n\t\tpanic(\"wsemul_sun_output: kernel output, not console\");\n#endif\n\n\tinstate = kernel ? &edp->kstate : &edp->instate;\n\n\tswitch (edp->abortstate.state) {\n\tcase ABORT_FAILED_CURSOR:\n\t\t/*\n\t\t * If we could not display the cursor back, we pretended not\n\t\t * having been able to process the last byte. But this\n\t\t * is a lie, so compensate here.\n\t\t */\n\t\tdata++, count--;\n\t\tprocessed++;\n\t\twsemul_reset_abortstate(&edp->abortstate);\n\t\tbreak;\n\tcase ABORT_OK:\n\t\t/* remove cursor image */\n\t\trc = (*edp->emulops->cursor)\n\t\t    (edp->emulcookie, 0, edp->crow, edp->ccol);\n\t\tif (rc != 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (;;) {\n#ifdef HAVE_JUMP_SCROLL\n\t\tswitch (edp->abortstate.state) {\n\t\tcase ABORT_FAILED_JUMP_SCROLL:\n\t\t\t/*\n\t\t\t * If we failed a previous jump scroll attempt, we\n\t\t\t * need to try to resume it with the same distance.\n\t\t\t * We can not recompute it since there might be more\n\t\t\t * bytes in the tty ring, causing a different result.\n\t\t\t */\n\t\t\tlines = edp->abortstate.lines;\n\t\t\tbreak;\n\t\tcase ABORT_OK:\n\t\t\t/*\n\t\t\t * If scrolling is not disabled and we are the bottom of\n\t\t\t * the screen, count newlines until an escape sequence\n\t\t\t * appears.\n\t\t\t */\n\t\t\tif ((edp->state == SUN_EMUL_STATE_NORMAL || kernel) &&\n\t\t\t    ROWS_LEFT == 0 && edp->scrolldist != 0)\n\t\t\t\tlines = wsemul_sun_jump_scroll(edp, data,\n\t\t\t\t    count, kernel);\n\t\t\telse\n\t\t\t\tlines = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * If we are recovering a non-scrolling failure,\n\t\t\t * do not try to scroll yet.\n\t\t\t */\n\t\t\tlines = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (lines > 1) {\n\t\t\twsemul_resume_abort(&edp->abortstate);\n\t\t\trc = wsemul_sun_scrollup(edp, lines);\n\t\t\tif (rc != 0) {\n\t\t\t\twsemul_abort_jump_scroll(&edp->abortstate,\n\t\t\t\t    lines);\n\t\t\t\treturn processed;\n\t\t\t}\n\t\t\twsemul_reset_abortstate(&edp->abortstate);\n\t\t\tedp->crow--;\n\t\t}\n#endif\n\n\t\twsemul_resume_abort(&edp->abortstate);\n\n\t\tprev_count = count;\n\t\tif (wsemul_getchar(&data, &count, instate,\n#ifdef HAVE_UTF8_SUPPORT\n\t\t    (edp->state == SUN_EMUL_STATE_NORMAL && !kernel) ?\n\t\t      edp->flags & SUN_EMUL_FLAGS_UTF8 : 0\n#else\n\t\t    0\n#endif\n\t\t    ) != 0)\n\t\t\tbreak;\n\n\t\tif (instate->inchar < ' ') {\n\t\t\trc = wsemul_sun_output_lowchars(edp, instate, kernel);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tprocessed += prev_count - count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (kernel) {\n\t\t\trc = wsemul_sun_output_normal(edp, instate, 1);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tprocessed += prev_count - count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (edp->state) {\n\t\tcase SUN_EMUL_STATE_NORMAL:\n\t\t\trc = wsemul_sun_output_normal(edp, instate, 0);\n\t\t\tbreak;\n\t\tcase SUN_EMUL_STATE_HAVEESC:\n\t\t\trc = wsemul_sun_output_haveesc(edp, instate);\n\t\t\tbreak;\n\t\tcase SUN_EMUL_STATE_CONTROL:\n\t\t\trc = wsemul_sun_output_control(edp, instate);\n\t\t\tbreak;\n#ifdef HAVE_UTF8_SUPPORT\n\t\tcase SUN_EMUL_STATE_PERCENT:\n\t\t\trc = wsemul_sun_output_percent(edp, instate);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n#ifdef DIAGNOSTIC\n\t\t\tpanic(\"wsemul_sun: invalid state %d\", edp->state);\n#else\n\t\t\t/* try to recover, if things get screwed up... */\n\t\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\t\trc = wsemul_sun_output_normal(edp, instate, 0);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tprocessed += prev_count - count;\n\t}\n\n\tif (rc != 0)\n\t\twsemul_abort_other(&edp->abortstate);\n\telse {\n\t\t/* put cursor image back */\n\t\trc = (*edp->emulops->cursor)\n\t\t    (edp->emulcookie, 1, edp->crow, edp->ccol);\n\t\tif (rc != 0) {\n\t\t\t/*\n\t\t\t * Pretend the last byte hasn't been processed, while\n\t\t\t * remembering that only the cursor operation really\n\t\t\t * needs to be done.\n\t\t\t */\n\t\t\twsemul_abort_cursor(&edp->abortstate);\n\t\t\tprocessed--;\n\t\t}\n\t}\n\n\tif (rc == 0)\n\t\twsemul_reset_abortstate(&edp->abortstate);\n\n\treturn processed;\n}\n\n#ifdef HAVE_JUMP_SCROLL\nint\nwsemul_sun_jump_scroll(struct wsemul_sun_emuldata *edp, const u_char *data,\n    u_int count, int kernel)\n{\n\tu_int pos, lines;\n\tstruct wsemul_inputstate tmpstate;\n\n\tlines = 0;\n\tpos = edp->ccol;\n\ttmpstate = kernel ? edp->kstate : edp->instate;\t/* structure copy */\n\n\twhile (wsemul_getchar(&data, &count, &tmpstate,\n#ifdef HAVE_UTF8_SUPPORT\n\t    kernel ? 0 : edp->flags & SUN_EMUL_FLAGS_UTF8\n#else\n\t    0\n#endif\n\t    ) == 0) {\n\t\tif (tmpstate.inchar == ASCII_FF ||\n\t\t    tmpstate.inchar == ASCII_VT ||\n\t\t    tmpstate.inchar == ASCII_ESC)\n\t\t\tbreak;\n\n\t\tswitch (tmpstate.inchar) {\n\t\tcase ASCII_BS:\n\t\t\tif (pos > 0)\n\t\t\t\tpos--;\n\t\t\tbreak;\n\t\tcase ASCII_CR:\n\t\t\tpos = 0;\n\t\t\tbreak;\n\t\tcase ASCII_HT:\n\t\t\tpos = (pos + 7) & ~7;\n\t\t\tif (pos >= edp->ncols)\n\t\t\t\tpos = edp->ncols - 1;\n\t\t\tbreak;\n\t\tcase ASCII_LF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (++pos >= edp->ncols) {\n\t\t\t\tpos = 0;\n\t\t\t\ttmpstate.inchar = ASCII_LF;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (tmpstate.inchar == ASCII_LF) {\n\t\t\tif (++lines >= edp->nrows - 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n#endif\n\n/*\n * Get an attribute from the graphics driver.\n * Try to find replacements if the desired appearance is not supported.\n */\nint\nwsemul_sun_selectattribute(struct wsemul_sun_emuldata *edp, int flags,\n    int fgcol, int bgcol, uint32_t *attr, uint32_t *bkgdattr)\n{\n\tint error;\n\n\t/*\n\t * Rasops will force white on black as normal output colors, unless\n\t * WSATTR_WSCOLORS is specified. Since Sun console is black on white,\n\t * always use WSATTR_WSCOLORS and our colors, as we know better.\n\t */\n\tif (!(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {\n\t\tflags &= ~WSATTR_WSCOLORS;\n\t} else {\n\t\tflags |= WSATTR_WSCOLORS;\n\t}\n\n\terror = (*edp->emulops->pack_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags & WSATTR_WSCOLORS, bkgdattr);\n\tif (error)\n\t\treturn (error);\n\n\tif ((flags & WSATTR_HILIT) &&\n\t    !(edp->scrcapabilities & WSSCREEN_HILIT)) {\n\t\tflags &= ~WSATTR_HILIT;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tfgcol = WSCOL_RED;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t}\n\t}\n\tif ((flags & WSATTR_UNDERLINE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {\n\t\tflags &= ~WSATTR_UNDERLINE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tfgcol = WSCOL_CYAN;\n\t\t\tflags &= ~WSATTR_UNDERLINE;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t}\n\t}\n\tif ((flags & WSATTR_BLINK) &&\n\t    !(edp->scrcapabilities & WSSCREEN_BLINK)) {\n\t\tflags &= ~WSATTR_BLINK;\n\t}\n\tif ((flags & WSATTR_REVERSE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {\n\t\tflags &= ~WSATTR_REVERSE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tint help;\n\t\t\thelp = bgcol;\n\t\t\tbgcol = fgcol;\n\t\t\tfgcol = help;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t}\n\t}\n\terror = (*edp->emulops->pack_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags, attr);\n\tif (error)\n\t\treturn (error);\n\n\treturn (0);\n}\n\nstatic const u_char *sun_fkeys[] = {\n\t\"\\033[224z\",\t/* F1 */\n\t\"\\033[225z\",\n\t\"\\033[226z\",\n\t\"\\033[227z\",\n\t\"\\033[228z\",\n\t\"\\033[229z\",\n\t\"\\033[230z\",\n\t\"\\033[231z\",\n\t\"\\033[232z\",\n\t\"\\033[233z\",\n\t\"\\033[234z\",\n\t\"\\033[235z\",\t/* F12 */\n};\n\nstatic const u_char *sun_lkeys[] = {\n\t\"\\033[207z\",\t/* KS_Help */\n\tNULL,\t\t/* KS_Execute */\n\t\"\\033[200z\",\t/* KS_Find */\n\tNULL,\t\t/* KS_Select */\n\t\"\\033[193z\",\t/* KS_Again */\n\t\"\\033[194z\",\t/* KS_Props */\n\t\"\\033[195z\",\t/* KS_Undo */\n\t\"\\033[196z\",\t/* KS_Front */\n\t\"\\033[197z\",\t/* KS_Copy */\n\t\"\\033[198z\",\t/* KS_Open */\n\t\"\\033[199z\",\t/* KS_Paste */\n\t\"\\033[201z\",\t/* KS_Cut */\n};\n\nint\nwsemul_sun_translate(void *cookie, kbd_t layout, keysym_t in,\n    const u_char **out)\n{\n\tstruct wsemul_sun_emuldata *edp = cookie;\n\n\tif (KS_GROUP(in) == KS_GROUP_Ascii) {\n\t\t*out = edp->translatebuf;\n\t\treturn (wsemul_utf8_translate(KS_VALUE(in), layout,\n\t\t    edp->translatebuf, edp->flags & SUN_EMUL_FLAGS_UTF8));\n\t}\n\n\tif (KS_GROUP(in) == KS_GROUP_Keypad && (in & 0x80) == 0) {\n\t\tedp->translatebuf[0] = in & 0xff; /* turn into ASCII */\n\t\t*out = edp->translatebuf;\n\t\treturn (1);\n\t}\n\n\tif (in >= KS_f1 && in <= KS_f12) {\n\t\t*out = sun_fkeys[in - KS_f1];\n\t\treturn (6);\n\t}\n\tif (in >= KS_F1 && in <= KS_F12) {\n\t\t*out = sun_fkeys[in - KS_F1];\n\t\treturn (6);\n\t}\n\tif (in >= KS_KP_F1 && in <= KS_KP_F4) {\n\t\t*out = sun_fkeys[in - KS_KP_F1];\n\t\treturn (6);\n\t}\n\tif (in >= KS_Help && in <= KS_Cut && sun_lkeys[in - KS_Help] != NULL) {\n\t\t*out = sun_lkeys[in - KS_Help];\n\t\treturn (6);\n\t}\n\n\tswitch (in) {\n\tcase KS_Home:\n\tcase KS_KP_Home:\n\tcase KS_KP_Begin:\n\t\t*out = \"\\033[214z\";\n\t\treturn (6);\n\tcase KS_End:\n\tcase KS_KP_End:\n\t\t*out = \"\\033[220z\";\n\t\treturn (6);\n\tcase KS_Insert:\n\tcase KS_KP_Insert:\n\t\t*out = \"\\033[247z\";\n\t\treturn (6);\n\tcase KS_Prior:\n\tcase KS_KP_Prior:\n\t\t*out = \"\\033[216z\";\n\t\treturn (6);\n\tcase KS_Next:\n\tcase KS_KP_Next:\n\t\t*out = \"\\033[222z\";\n\t\treturn (6);\n\tcase KS_Up:\n\tcase KS_KP_Up:\n\t\t*out = \"\\033[A\";\n\t\treturn (3);\n\tcase KS_Down:\n\tcase KS_KP_Down:\n\t\t*out = \"\\033[B\";\n\t\treturn (3);\n\tcase KS_Left:\n\tcase KS_KP_Left:\n\t\t*out = \"\\033[D\";\n\t\treturn (3);\n\tcase KS_Right:\n\tcase KS_KP_Right:\n\t\t*out = \"\\033[C\";\n\t\treturn (3);\n\tcase KS_KP_Delete:\n\t\t*out = \"\\177\";\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid\nwsemul_sun_detach(void *cookie, u_int *crowp, u_int *ccolp)\n{\n\tstruct wsemul_sun_emuldata *edp = cookie;\n\n\t*crowp = edp->crow;\n\t*ccolp = edp->ccol;\n\tif (edp != &wsemul_sun_console_emuldata)\n\t\tfree(edp, M_DEVBUF, sizeof *edp);\n}\n\nvoid\nwsemul_sun_resetop(void *cookie, enum wsemul_resetops op)\n{\n\tstruct wsemul_sun_emuldata *edp = cookie;\n\n\tswitch (op) {\n\tcase WSEMUL_RESET:\n\t\twsemul_sun_reset(edp);\n\t\tbreak;\n\tcase WSEMUL_CLEARSCREEN:\n\t\t(*edp->emulops->eraserows)(edp->emulcookie, 0, edp->nrows,\n\t\t    edp->bkgdattr);\n\t\tedp->ccol = edp->crow = 0;\n\t\t(*edp->emulops->cursor)(edp->emulcookie, 1, 0, 0);\n\t\tbreak;\n\tcase WSEMUL_CLEARCURSOR:\n\t\t(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow,\n\t\t    edp->ccol);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint\nwsemul_sun_scrollup(struct wsemul_sun_emuldata *edp, u_int lines)\n{\n\tint rc;\n\n\t/*\n\t * if we're in wrap-around mode, go to the first\n\t * line and clear it.\n\t */\n\tif (lines == 0) {\n\t\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t\t    (edp->emulcookie, 0, 1, edp->bkgdattr));\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\n\t\tedp->crow = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the scrolling distance is equal to the screen height\n\t * (usually 34), clear the screen; otherwise, scroll by the\n\t * scrolling distance.\n\t */\n\tif (lines < edp->nrows) {\n\t\tWSEMULOP(rc, edp, &edp->abortstate, copyrows,\n\t\t    (edp->emulcookie, lines, 0, edp->nrows - lines));\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t}\n\tWSEMULOP(rc, edp, &edp->abortstate, eraserows,\n\t    (edp->emulcookie, edp->nrows - lines, lines, edp->bkgdattr));\n\tif (rc != 0)\n\t\treturn rc;\n\n\tedp->crow -= lines - 1;\n\n\treturn 0;\n}\n", "/* $OpenBSD: wsemul_vt100.c,v 1.46 2023/07/24 17:03:32 miod Exp $ */\n/* $NetBSD: wsemul_vt100.c,v 1.13 2000/04/28 21:56:16 mycroft Exp $ */\n\n/*\n * Copyright (c) 2007, 2013 Miodrag Vallat.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice, this permission notice, and the disclaimer below\n * appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n/*\n * Copyright (c) 1998\n *\tMatthias Drochner.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n\n#include <dev/wscons/wscons_features.h>\n#include <dev/wscons/wsconsio.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/ascii.h>\n\nvoid\t*wsemul_vt100_cnattach(const struct wsscreen_descr *, void *,\n\t\t\t\t  int, int, uint32_t);\nvoid\t*wsemul_vt100_attach(int, const struct wsscreen_descr *,\n\t\t\t\t  void *, int, int, void *, uint32_t);\nu_int\twsemul_vt100_output(void *, const u_char *, u_int, int);\nvoid\twsemul_vt100_detach(void *, u_int *, u_int *);\nvoid\twsemul_vt100_resetop(void *, enum wsemul_resetops);\n\nconst struct wsemul_ops wsemul_vt100_ops = {\n\t\"vt100\",\n\twsemul_vt100_cnattach,\n\twsemul_vt100_attach,\n\twsemul_vt100_output,\n\twsemul_vt100_translate,\n\twsemul_vt100_detach,\n\twsemul_vt100_resetop\n};\n\nstruct wsemul_vt100_emuldata wsemul_vt100_console_emuldata;\n\nvoid\twsemul_vt100_init(struct wsemul_vt100_emuldata *,\n\t    const struct wsscreen_descr *, void *, int, int, uint32_t);\nint\twsemul_vt100_jump_scroll(struct wsemul_vt100_emuldata *,\n\t    const u_char *, u_int, int);\nint\twsemul_vt100_output_normal(struct wsemul_vt100_emuldata *,\n\t    struct wsemul_inputstate *, int);\nint\twsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *,\n\t    struct wsemul_inputstate *, int);\nint\twsemul_vt100_nextline(struct wsemul_vt100_emuldata *);\n\ntypedef int vt100_handler(struct wsemul_vt100_emuldata *, struct\n\t    wsemul_inputstate *);\nvt100_handler\n\twsemul_vt100_output_esc,\n\twsemul_vt100_output_csi,\n\twsemul_vt100_output_scs94,\n\twsemul_vt100_output_scs94_percent,\n\twsemul_vt100_output_scs96,\n\twsemul_vt100_output_scs96_percent,\n\twsemul_vt100_output_esc_hash,\n\twsemul_vt100_output_esc_spc,\n\twsemul_vt100_output_string,\n\twsemul_vt100_output_string_esc,\n\twsemul_vt100_output_dcs,\n\twsemul_vt100_output_dcs_dollar,\n\twsemul_vt100_output_esc_percent;\n\n#define\tVT100_EMUL_STATE_NORMAL\t\t0\t/* normal processing */\n#define\tVT100_EMUL_STATE_ESC\t\t1\t/* got ESC */\n#define\tVT100_EMUL_STATE_CSI\t\t2\t/* got CSI (ESC[) */\n#define\tVT100_EMUL_STATE_SCS94\t\t3\t/* got ESC{()*+} */\n#define\tVT100_EMUL_STATE_SCS94_PERCENT\t4\t/* got ESC{()*+}% */\n#define\tVT100_EMUL_STATE_SCS96\t\t5\t/* got ESC{-./} */\n#define\tVT100_EMUL_STATE_SCS96_PERCENT\t6\t/* got ESC{-./}% */\n#define\tVT100_EMUL_STATE_ESC_HASH\t7\t/* got ESC# */\n#define\tVT100_EMUL_STATE_ESC_SPC\t8\t/* got ESC<SPC> */\n#define\tVT100_EMUL_STATE_STRING\t\t9\t/* waiting for ST (ESC\\) */\n#define\tVT100_EMUL_STATE_STRING_ESC\t10\t/* waiting for ST, got ESC */\n#define\tVT100_EMUL_STATE_DCS\t\t11\t/* got DCS (ESC P) */\n#define\tVT100_EMUL_STATE_DCS_DOLLAR\t12\t/* got DCS<p>$ */\n#define\tVT100_EMUL_STATE_ESC_PERCENT\t13\t/* got ESC% */\n\nvt100_handler *vt100_output[] = {\n\twsemul_vt100_output_esc,\n\twsemul_vt100_output_csi,\n\twsemul_vt100_output_scs94,\n\twsemul_vt100_output_scs94_percent,\n\twsemul_vt100_output_scs96,\n\twsemul_vt100_output_scs96_percent,\n\twsemul_vt100_output_esc_hash,\n\twsemul_vt100_output_esc_spc,\n\twsemul_vt100_output_string,\n\twsemul_vt100_output_string_esc,\n\twsemul_vt100_output_dcs,\n\twsemul_vt100_output_dcs_dollar,\n\twsemul_vt100_output_esc_percent,\n};\n\nvoid\nwsemul_vt100_init(struct wsemul_vt100_emuldata *edp,\n    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,\n    uint32_t defattr)\n{\n\tedp->emulops = type->textops;\n\tedp->emulcookie = cookie;\n\tedp->scrcapabilities = type->capabilities;\n\tedp->nrows = type->nrows;\n\tedp->ncols = type->ncols;\n\tedp->crow = crow;\n\tedp->ccol = ccol;\n\tedp->defattr = defattr;\n\twsemul_reset_abortstate(&edp->abortstate);\n}\n\nvoid *\nwsemul_vt100_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,\n    int crow, uint32_t defattr)\n{\n\tstruct wsemul_vt100_emuldata *edp;\n\tint res;\n\n\tedp = &wsemul_vt100_console_emuldata;\n\twsemul_vt100_init(edp, type, cookie, ccol, crow, defattr);\n#ifdef DIAGNOSTIC\n\tedp->console = 1;\n#endif\n\tedp->cbcookie = NULL;\n\n#ifndef WS_KERNEL_FG\n#define WS_KERNEL_FG WSCOL_WHITE\n#endif\n#ifndef WS_KERNEL_BG\n#define WS_KERNEL_BG WSCOL_BLUE\n#endif\n#ifndef WS_KERNEL_COLATTR\n#define WS_KERNEL_COLATTR 0\n#endif\n#ifndef WS_KERNEL_MONOATTR\n#define WS_KERNEL_MONOATTR 0\n#endif\n\tif (type->capabilities & WSSCREEN_WSCOLORS)\n\t\tres = (*edp->emulops->pack_attr)(cookie,\n\t\t    WS_KERNEL_FG, WS_KERNEL_BG,\n\t\t    WS_KERNEL_COLATTR | WSATTR_WSCOLORS, &edp->kernattr);\n\telse\n\t\tres = (*edp->emulops->pack_attr)(cookie, 0, 0,\n\t\t    WS_KERNEL_MONOATTR, &edp->kernattr);\n\tif (res)\n\t\tedp->kernattr = defattr;\n\n\tedp->tabs = NULL;\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\tedp->dblwid = NULL;\n\tedp->dw = 0;\n#endif\n\tedp->dcsarg = NULL;\n\tedp->isolatin1tab = edp->decgraphtab = edp->dectechtab = NULL;\n\tedp->nrctab = NULL;\n\twsemul_vt100_reset(edp);\n\treturn (edp);\n}\n\nvoid *\nwsemul_vt100_attach(int console, const struct wsscreen_descr *type,\n    void *cookie, int ccol, int crow, void *cbcookie, uint32_t defattr)\n{\n\tstruct wsemul_vt100_emuldata *edp;\n\n\tif (console) {\n\t\tedp = &wsemul_vt100_console_emuldata;\n\t\tKASSERT(edp->console == 1);\n\t} else {\n\t\tedp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);\n\t\tif (edp == NULL)\n\t\t\treturn (NULL);\n\t\twsemul_vt100_init(edp, type, cookie, ccol, crow, defattr);\n#ifdef DIAGNOSTIC\n\t\tedp->console = 0;\n#endif\n\t}\n\tedp->cbcookie = cbcookie;\n\n\tedp->tabs = malloc(edp->ncols, M_DEVBUF, M_NOWAIT);\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\tedp->dblwid = malloc(edp->nrows, M_DEVBUF, M_NOWAIT | M_ZERO);\n\tedp->dw = 0;\n#endif\n\tedp->dcsarg = malloc(DCS_MAXLEN, M_DEVBUF, M_NOWAIT);\n\tedp->isolatin1tab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);\n\tedp->decgraphtab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);\n\tedp->dectechtab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);\n\tedp->nrctab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);\n\tvt100_initchartables(edp);\n\twsemul_vt100_reset(edp);\n\treturn (edp);\n}\n\nvoid\nwsemul_vt100_detach(void *cookie, u_int *crowp, u_int *ccolp)\n{\n\tstruct wsemul_vt100_emuldata *edp = cookie;\n\n\t*crowp = edp->crow;\n\t*ccolp = edp->ccol;\n#define f(ptr) do { free(ptr, M_DEVBUF, 0); ptr = NULL; } while (0)\n\tf(edp->tabs);\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\tf(edp->dblwid);\n#endif\n\tf(edp->dcsarg);\n\tf(edp->isolatin1tab);\n\tf(edp->decgraphtab);\n\tf(edp->dectechtab);\n\tf(edp->nrctab);\n#undef f\n\tif (edp != &wsemul_vt100_console_emuldata)\n\t\tfree(edp, M_DEVBUF, sizeof *edp);\n}\n\nvoid\nwsemul_vt100_resetop(void *cookie, enum wsemul_resetops op)\n{\n\tstruct wsemul_vt100_emuldata *edp = cookie;\n\n\tswitch (op) {\n\tcase WSEMUL_RESET:\n\t\twsemul_vt100_reset(edp);\n\t\tbreak;\n\tcase WSEMUL_SYNCFONT:\n\t\tvt100_initchartables(edp);\n\t\tbreak;\n\tcase WSEMUL_CLEARSCREEN:\n\t\t(void)wsemul_vt100_ed(edp, 2);\n\t\tedp->ccol = edp->crow = 0;\n\t\t(*edp->emulops->cursor)(edp->emulcookie,\n\t\t    edp->flags & VTFL_CURSORON, 0, 0);\n\t\tbreak;\n\tcase WSEMUL_CLEARCURSOR:\n\t\t(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow,\n\t\t    edp->ccol);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid\nwsemul_vt100_reset(struct wsemul_vt100_emuldata *edp)\n{\n\tint i;\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\tedp->flags = VTFL_DECAWM | VTFL_CURSORON;\n\tedp->bkgdattr = edp->curattr = edp->defattr;\n\tedp->attrflags = 0;\n\tedp->fgcol = WSCOL_WHITE;\n\tedp->bgcol = WSCOL_BLACK;\n\tedp->scrreg_startrow = 0;\n\tedp->scrreg_nrows = edp->nrows;\n\tif (edp->tabs) {\n\t\tmemset(edp->tabs, 0, edp->ncols);\n\t\tfor (i = 8; i < edp->ncols; i += 8)\n\t\t\tedp->tabs[i] = 1;\n\t}\n\tedp->dcspos = 0;\n\tedp->dcstype = 0;\n\tedp->chartab_G[0] = NULL;\n\tedp->chartab_G[1] = edp->nrctab; /* ??? */\n\tedp->chartab_G[2] = edp->isolatin1tab;\n\tedp->chartab_G[3] = edp->isolatin1tab;\n\tedp->chartab0 = 0;\n\tedp->chartab1 = 2;\n\tedp->sschartab = 0;\n\tedp->instate.inchar = 0;\n\tedp->instate.lbound = 0;\n\tedp->instate.mbleft = 0;\n\tedp->kstate.inchar = 0;\n\tedp->kstate.lbound = 0;\n\tedp->kstate.mbleft = 0;\n}\n\n/*\n * Move the cursor to the next line if possible. If the cursor is at\n * the bottom of the scroll area, then scroll it up. If the cursor is\n * at the bottom of the screen then don't move it down.\n */\nint\nwsemul_vt100_nextline(struct wsemul_vt100_emuldata *edp)\n{\n\tint rc;\n\n\tif (ROWS_BELOW == 0) {\n\t\t/* Bottom of the scroll region. */\n\t  \trc = wsemul_vt100_scrollup(edp, 1);\n\t} else {\n\t\tif ((edp->crow+1) < edp->nrows)\n\t\t\t/* Cursor not at the bottom of the screen. */\n\t\t\tedp->crow++;\n\t\tCHECK_DW;\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\n/*\n * now all the state machine bits\n */\n\nint\nwsemul_vt100_output_normal(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate, int kernel)\n{\n\tu_int *ct, dc;\n\tu_char c;\n\tint oldsschartab = edp->sschartab;\n\tint rc = 0;\n\n\tif ((edp->flags & (VTFL_LASTCHAR | VTFL_DECAWM)) ==\n\t    (VTFL_LASTCHAR | VTFL_DECAWM)) {\n\t\trc = wsemul_vt100_nextline(edp);\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t\tedp->ccol = 0;\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\t}\n\n#ifdef HAVE_UTF8_SUPPORT\n\tif (edp->flags & VTFL_UTF8) {\n\t\t(*edp->emulops->mapchar)(edp->emulcookie, instate->inchar, &dc);\n\t} else\n#endif\n\t{\n\t\tc = instate->inchar & 0xff;\n\t\tif (c & 0x80) {\n\t\t\tc &= 0x7f;\n\t\t\tct = edp->chartab_G[edp->chartab1];\n\t\t} else {\n\t\t\tif (edp->sschartab) {\n\t\t\t\tct = edp->chartab_G[edp->sschartab];\n\t\t\t\tedp->sschartab = 0;\n\t\t\t} else\n\t\t\t\tct = edp->chartab_G[edp->chartab0];\n\t\t}\n\t\tdc = ct ? ct[c] : c;\n\t}\n\n\tif ((edp->flags & VTFL_INSERTMODE) && COLS_LEFT) {\n\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t    COPYCOLS(edp->ccol, edp->ccol + 1, COLS_LEFT));\n\t\tif (rc != 0) {\n\t\t\t/* undo potential sschartab update */\n\t\t\tedp->sschartab = oldsschartab;\n\n\t\t\treturn rc;\n\t\t}\n\t}\n\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\tWSEMULOP(rc, edp, &edp->abortstate, putchar,\n\t    (edp->emulcookie, edp->crow, edp->ccol << edp->dw, dc,\n\t     kernel ? edp->kernattr : edp->curattr));\n#else\n\tWSEMULOP(rc, edp, &edp->abortstate, putchar,\n\t    (edp->emulcookie, edp->crow, edp->ccol, dc,\n\t     kernel ? edp->kernattr : edp->curattr));\n#endif\n\tif (rc != 0) {\n\t\t/* undo potential sschartab update */\n\t\tedp->sschartab = oldsschartab;\n\n\t\treturn rc;\n\t}\n\n\tif (COLS_LEFT)\n\t\tedp->ccol++;\n\telse\n\t\tedp->flags |= VTFL_LASTCHAR;\n\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate, int kernel)\n{\n\tu_int n;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase ASCII_NUL:\n\tdefault:\n\t\t/* ignore */\n\t\tbreak;\n\tcase ASCII_BEL:\n\t\tif (edp->state == VT100_EMUL_STATE_STRING) {\n\t\t\t/* acts as an equivalent to the ``ESC \\'' string end */\n\t\t\twsemul_vt100_handle_dcs(edp);\n\t\t\tedp->state = VT100_EMUL_STATE_NORMAL;\n\t\t} else {\n\t\t\twsdisplay_emulbell(edp->cbcookie);\n\t\t}\n\t\tbreak;\n\tcase ASCII_BS:\n\t\tif (edp->ccol > 0) {\n\t\t\tedp->ccol--;\n\t\t\tedp->flags &= ~VTFL_LASTCHAR;\n\t\t}\n\t\tbreak;\n\tcase ASCII_CR:\n\t\tedp->ccol = 0;\n\t\tbreak;\n\tcase ASCII_HT:\n\t\tif (edp->tabs) {\n\t\t\tif (!COLS_LEFT)\n\t\t\t\tbreak;\n\t\t\tfor (n = edp->ccol + 1; n < NCOLS - 1; n++)\n\t\t\t\tif (edp->tabs[n])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tn = edp->ccol + min(8 - (edp->ccol & 7), COLS_LEFT);\n\t\t}\n\t\tedp->ccol = n;\n\t\tbreak;\n\tcase ASCII_SO: /* LS1 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab0 = 1;\n\t\tbreak;\n\tcase ASCII_SI: /* LS0 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab0 = 0;\n\t\tbreak;\n\tcase ASCII_ESC:\n\t\tif (kernel) {\n\t\t\tprintf(\"wsemul_vt100_output_c0c1: ESC in kernel \"\n\t\t\t    \"output ignored\\n\");\n\t\t\tbreak;\t/* ignore the ESC */\n\t\t}\n\n\t\tif (edp->state == VT100_EMUL_STATE_STRING) {\n\t\t\t/* might be a string end */\n\t\t\tedp->state = VT100_EMUL_STATE_STRING_ESC;\n\t\t} else {\n\t\t\t/* XXX cancel current escape sequence */\n\t\t\tedp->state = VT100_EMUL_STATE_ESC;\n\t\t}\n\t\tbreak;\n\tcase ASCII_CAN:\n\tcase ASCII_SUB:\n\t\t/* cancel current escape sequence */\n\t\tedp->state = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\tcase ASCII_LF:\n\tcase ASCII_VT:\n\tcase ASCII_FF:\n\t\trc = wsemul_vt100_nextline(edp);\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\treturn rc;\n}\n\nint\nwsemul_vt100_output_esc(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_NORMAL;\n\tint rc = 0;\n\tint i;\n\n\tswitch (instate->inchar) {\n\tcase '[': /* CSI */\n\t\tedp->nargs = 0;\n\t\tmemset(edp->args, 0, sizeof (edp->args));\n\t\tedp->modif1 = edp->modif2 = '\\0';\n\t\tnewstate = VT100_EMUL_STATE_CSI;\n\t\tbreak;\n\tcase '7': /* DECSC */\n\t\tedp->flags |= VTFL_SAVEDCURS;\n\t\tedp->savedcursor_row = edp->crow;\n\t\tedp->savedcursor_col = edp->ccol;\n\t\tedp->savedattr = edp->curattr;\n\t\tedp->savedbkgdattr = edp->bkgdattr;\n\t\tedp->savedattrflags = edp->attrflags;\n\t\tedp->savedfgcol = edp->fgcol;\n\t\tedp->savedbgcol = edp->bgcol;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tedp->savedchartab_G[i] = edp->chartab_G[i];\n\t\tedp->savedchartab0 = edp->chartab0;\n\t\tedp->savedchartab1 = edp->chartab1;\n\t\tbreak;\n\tcase '8': /* DECRC */\n\t\tif ((edp->flags & VTFL_SAVEDCURS) == 0)\n\t\t\tbreak;\n\t\tedp->crow = edp->savedcursor_row;\n\t\tedp->ccol = edp->savedcursor_col;\n\t\tedp->curattr = edp->savedattr;\n\t\tedp->bkgdattr = edp->savedbkgdattr;\n\t\tedp->attrflags = edp->savedattrflags;\n\t\tedp->fgcol = edp->savedfgcol;\n\t\tedp->bgcol = edp->savedbgcol;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tedp->chartab_G[i] = edp->savedchartab_G[i];\n\t\tedp->chartab0 = edp->savedchartab0;\n\t\tedp->chartab1 = edp->savedchartab1;\n\t\tbreak;\n\tcase '=': /* DECKPAM application mode */\n\t\tedp->flags |= VTFL_APPLKEYPAD;\n\t\tbreak;\n\tcase '>': /* DECKPNM numeric mode */\n\t\tedp->flags &= ~VTFL_APPLKEYPAD;\n\t\tbreak;\n\tcase 'E': /* NEL */\n\t\tedp->ccol = 0;\n\t\t/* FALLTHROUGH */\n\tcase 'D': /* IND */\n\t\trc = wsemul_vt100_nextline(edp);\n\t\tbreak;\n\tcase 'H': /* HTS */\n\t\tif (edp->tabs != NULL)\n\t\t\tedp->tabs[edp->ccol] = 1;\n\t\tbreak;\n\tcase '~': /* LS1R */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab1 = 1;\n\t\tbreak;\n\tcase 'n': /* LS2 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab0 = 2;\n\t\tbreak;\n\tcase '}': /* LS2R */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab1 = 2;\n\t\tbreak;\n\tcase 'o': /* LS3 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab0 = 3;\n\t\tbreak;\n\tcase '|': /* LS3R */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab1 = 3;\n\t\tbreak;\n\tcase 'N': /* SS2 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->sschartab = 2;\n\t\tbreak;\n\tcase 'O': /* SS3 */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->sschartab = 3;\n\t\tbreak;\n\tcase 'M': /* RI */\n\t\ti = ROWS_ABOVE;\n\t\tif (i > 0) {\n\t\t\tif (edp->crow > 0)\n\t\t\t\tedp->crow--;\n\t\t\tCHECK_DW;\n\t\t} else if (i == 0) {\n\t\t\t/* Top of scroll region. */\n\t\t\trc = wsemul_vt100_scrolldown(edp, 1);\n\t\t}\n\t\tbreak;\n\tcase 'P': /* DCS */\n\t\tedp->nargs = 0;\n\t\tmemset(edp->args, 0, sizeof (edp->args));\n\t\tnewstate = VT100_EMUL_STATE_DCS;\n\t\tbreak;\n\tcase 'c': /* RIS */\n\t\twsemul_vt100_reset(edp);\n\t\trc = wsemul_vt100_ed(edp, 2);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tedp->ccol = edp->crow = 0;\n\t\tbreak;\n\tcase '(': case ')': case '*': case '+': /* SCS */\n\t\tedp->designating = instate->inchar - '(';\n\t\tnewstate = VT100_EMUL_STATE_SCS94;\n\t\tbreak;\n\tcase '-': case '.': case '/': /* SCS */\n\t\tedp->designating = instate->inchar - '-' + 1;\n\t\tnewstate = VT100_EMUL_STATE_SCS96;\n\t\tbreak;\n\tcase '#':\n\t\tnewstate = VT100_EMUL_STATE_ESC_HASH;\n\t\tbreak;\n\tcase ' ': /* 7/8 bit */\n\t\tnewstate = VT100_EMUL_STATE_ESC_SPC;\n\t\tbreak;\n\tcase ']': /* OSC operating system command */\n\tcase '^': /* PM privacy message */\n\tcase '_': /* APC application program command */\n\t\t/* ignored */\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tbreak;\n\tcase '<': /* exit VT52 mode - ignored */\n\t\tbreak;\n\tcase '%': /* UTF-8 encoding sequences */\n\t\tnewstate = VT100_EMUL_STATE_ESC_PERCENT;\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC %x unknown\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_scs94(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_NORMAL;\n\n\tswitch (instate->inchar) {\n\tcase '%': /* probably DEC supplemental graphic */\n\t\tnewstate = VT100_EMUL_STATE_SCS94_PERCENT;\n\t\tbreak;\n\tcase 'A': /* british / national */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->nrctab;\n\t\tbreak;\n\tcase 'B': /* ASCII */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = 0;\n\t\tbreak;\n\tcase '<': /* user preferred supplemental */\n\t\t/* XXX not really \"user\" preferred */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->isolatin1tab;\n\t\tbreak;\n\tcase '0': /* DEC special graphic */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->decgraphtab;\n\t\tbreak;\n\tcase '>': /* DEC tech */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->dectechtab;\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC%c %x unknown\\n\", edp->designating + '(',\n\t\t    instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_scs94_percent(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase '5': /* DEC supplemental graphic */\n\t\t/* XXX there are differences */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->isolatin1tab;\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC%c%% %x unknown\\n\", edp->designating + '(',\n\t\t    instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_scs96(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_NORMAL;\n\tint nrc;\n\n\tswitch (instate->inchar) {\n\tcase '%': /* probably portuguese */\n\t\tnewstate = VT100_EMUL_STATE_SCS96_PERCENT;\n\t\tbreak;\n\tcase 'A': /* ISO-latin-1 supplemental */\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tedp->chartab_G[edp->designating] = edp->isolatin1tab;\n\t\tbreak;\n\tcase '4': /* dutch */\n\t\tnrc = 1;\n\t\tgoto setnrc;\n\tcase '5': case 'C': /* finnish */\n\t\tnrc = 2;\n\t\tgoto setnrc;\n\tcase 'R': /* french */\n\t\tnrc = 3;\n\t\tgoto setnrc;\n\tcase 'Q': /* french canadian */\n\t\tnrc = 4;\n\t\tgoto setnrc;\n\tcase 'K': /* german */\n\t\tnrc = 5;\n\t\tgoto setnrc;\n\tcase 'Y': /* italian */\n\t\tnrc = 6;\n\t\tgoto setnrc;\n\tcase 'E': case '6': /* norwegian / danish */\n\t\tnrc = 7;\n\t\tgoto setnrc;\n\tcase 'Z': /* spanish */\n\t\tnrc = 9;\n\t\tgoto setnrc;\n\tcase '7': case 'H': /* swedish */\n\t\tnrc = 10;\n\t\tgoto setnrc;\n\tcase '=': /* swiss */\n\t\tnrc = 11;\nsetnrc:\n\t\tif (vt100_setnrc(edp, nrc) == 0) /* what table ??? */\n\t\t\tbreak;\n\t\t/* else FALLTHROUGH */\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC%c %x unknown\\n\", edp->designating + '-' - 1,\n\t\t    instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_scs96_percent(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase '6': /* portuguese */\n\t\tif (vt100_setnrc(edp, 8) == 0)\n\t\t\tbreak;\n\t\t/* else FALLTHROUGH */\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC%c%% %x unknown\\n\", edp->designating + '-' - 1,\n\t\t    instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_esc_spc(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase 'F': /* 7-bit controls */\n\tcase 'G': /* 8-bit controls */\n#ifdef VT100_PRINTNOTIMPL\n\t\tprintf(\"ESC<SPC> %x ignored\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC<SPC> %x unknown\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_string(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tif (edp->dcsarg && edp->dcstype && edp->dcspos < DCS_MAXLEN) {\n\t\tif (instate->inchar & ~0xff) {\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"unknown char %x in DCS\\n\", instate->inchar);\n#endif\n\t\t} else\n\t\t\tedp->dcsarg[edp->dcspos++] = (char)instate->inchar;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_STRING;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_string_esc(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tif (instate->inchar == '\\\\') { /* ST complete */\n\t\twsemul_vt100_handle_dcs(edp);\n\t\tedp->state = VT100_EMUL_STATE_NORMAL;\n\t} else\n\t\tedp->state = VT100_EMUL_STATE_STRING;\n\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/* argument digit */\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': /* argument terminator */\n\t\tif (edp->nargs < VT100_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tif (edp->nargs < VT100_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': /* DECDLD soft charset */\t/* } */\n\t\tcase '!': /* DECRQUPSS user preferred supplemental set */\n\t\t\t/* 'u' must follow - need another state */\n\t\tcase '|': /* DECUDK program F6..F20 */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_dcs_dollar(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n\tcase 'p': /* DECRSTS terminal state restore */\n\tcase 'q': /* DECRQSS control function request */\n#ifdef VT100_PRINTNOTIMPL\n\t\tprintf(\"DCS$%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\tbreak;\n\tcase 't': /* DECRSPS restore presentation state */\n\t\tswitch (ARG(0)) {\n\t\tcase 0: /* error */\n\t\t\tbreak;\n\t\tcase 1: /* cursor information restore */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS1$t ignored\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 2: /* tab stop restore */\n\t\t\tedp->dcspos = 0;\n\t\t\tedp->dcstype = DCSTYPE_TABRESTORE;\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS%d$t unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"DCS$ %x (%d, %d) unknown\\n\",\n\t\t    instate->inchar, ARG(0), ARG(1));\n#endif\n\t\tbreak;\n\t}\n\n\tedp->state = VT100_EMUL_STATE_STRING;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_esc_percent(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tswitch (instate->inchar) {\n#ifdef HAVE_UTF8_SUPPORT\n\tcase 'G':\n\t\tedp->flags |= VTFL_UTF8;\n\t\tedp->kstate.mbleft = edp->instate.mbleft = 0;\n\t\tbreak;\n\tcase '@':\n\t\tedp->flags &= ~VTFL_UTF8;\n\t\tbreak;\n#endif\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC% %x unknown\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_esc_hash(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase '5': /*  DECSWL single width, single height */\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\t\tif (edp->dblwid != NULL && edp->dw != 0) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < edp->ncols / 2; i++) {\n\t\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t\t\t    (edp->emulcookie, edp->crow, 2 * i, i, 1));\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t\t    (edp->emulcookie, edp->crow, i, edp->ncols - i,\n\t\t\t     edp->bkgdattr));\n\t\t\tif (rc != 0)\n\t\t\t\treturn rc;\n\t\t\tedp->dblwid[edp->crow] = 0;\n\t\t\tedp->dw = 0;\n\t\t}\n#endif\n\t\tbreak;\n\tcase '6': /*  DECDWL double width, single height */\n\tcase '3': /*  DECDHL double width, double height, top half */\n\tcase '4': /*  DECDHL double width, double height, bottom half */\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\t\tif (edp->dblwid != NULL && edp->dw == 0) {\n\t\t\tint i;\n\t\t\tfor (i = edp->ncols / 2 - 1; i >= 0; i--) {\n\t\t\t\tWSEMULOP(rc, edp, &edp->abortstate, copycols,\n\t\t\t\t    (edp->emulcookie, edp->crow, i, 2 * i, 1));\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tfor (i = 0; i < edp->ncols / 2; i++) {\n\t\t\t\tWSEMULOP(rc, edp, &edp->abortstate, erasecols,\n\t\t\t\t    (edp->emulcookie, edp->crow, 2 * i + 1, 1,\n\t\t\t\t     edp->bkgdattr));\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tedp->dblwid[edp->crow] = 1;\n\t\t\tedp->dw = 1;\n\t\t\tif (edp->ccol > (edp->ncols >> 1) - 1)\n\t\t\t\tedp->ccol = (edp->ncols >> 1) - 1;\n\t\t}\n#endif\n\t\tbreak;\n\tcase '8': { /* DECALN */\n\t\tint i, j;\n\t\tfor (i = 0; i < edp->nrows; i++)\n\t\t\tfor (j = 0; j < edp->ncols; j++) {\n\t\t\t\tWSEMULOP(rc, edp, &edp->abortstate, putchar,\n\t\t\t\t    (edp->emulcookie, i, j, 'E', edp->curattr));\n\t\t\t\tif (rc != 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tedp->ccol = 0;\n\t\tedp->crow = 0;\n\t\tbreak;\n\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ESC# %x unknown\\n\", instate->inchar);\n#endif\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\treturn 0;\n}\n\nint\nwsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/* argument digit */\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': /* argument terminator */\n\t\tif (edp->nargs < VT100_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': /* DEC specific */\n\tcase '>': /* DA query */\n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: /* end of escape sequence */\n\t\toargs = edp->nargs;\n\t\tif (edp->nargs < VT100_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\tedp->state = newstate;\n\treturn 0;\n}\n\nu_int\nwsemul_vt100_output(void *cookie, const u_char *data, u_int count, int kernel)\n{\n\tstruct wsemul_vt100_emuldata *edp = cookie;\n\tstruct wsemul_inputstate *instate;\n\tu_int prev_count, processed = 0;\n#ifdef HAVE_JUMP_SCROLL\n\tint lines;\n#endif\n\tint rc = 0;\n\n#ifdef DIAGNOSTIC\n\tif (kernel && !edp->console)\n\t\tpanic(\"wsemul_vt100_output: kernel output, not console\");\n#endif\n\n\tinstate = kernel ? &edp->kstate : &edp->instate;\n\n\tswitch (edp->abortstate.state) {\n\tcase ABORT_FAILED_CURSOR:\n\t\t/*\n\t\t * If we could not display the cursor back, we pretended not\n\t\t * having been able to process the last byte. But this\n\t\t * is a lie, so compensate here.\n\t\t */\n\t\tdata++, count--;\n\t\tprocessed++;\n\t\twsemul_reset_abortstate(&edp->abortstate);\n\t\tbreak;\n\tcase ABORT_OK:\n\t\t/* remove cursor image if visible */\n\t\tif (edp->flags & VTFL_CURSORON) {\n\t\t\trc = (*edp->emulops->cursor)\n\t\t\t    (edp->emulcookie, 0, edp->crow,\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\t\t\t     edp->ccol << edp->dw);\n#else\n\t\t\t     edp->ccol);\n#endif\n\t\t\tif (rc != 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (;;) {\n#ifdef HAVE_JUMP_SCROLL\n\t\tswitch (edp->abortstate.state) {\n\t\tcase ABORT_FAILED_JUMP_SCROLL:\n\t\t\t/*\n\t\t\t * If we failed a previous jump scroll attempt, we\n\t\t\t * need to try to resume it with the same distance.\n\t\t\t * We can not recompute it since there might be more\n\t\t\t * bytes in the tty ring, causing a different result.\n\t\t\t */\n\t\t\tlines = edp->abortstate.lines;\n\t\t\tbreak;\n\t\tcase ABORT_OK:\n\t\t\t/*\n\t\t\t * If we are at the bottom of the scrolling area, count\n\t\t\t * newlines until an escape sequence appears.\n\t\t\t */\n\t\t\tif ((edp->state == VT100_EMUL_STATE_NORMAL || kernel) &&\n\t\t\t    ROWS_BELOW == 0)\n\t\t\t\tlines = wsemul_vt100_jump_scroll(edp, data,\n\t\t\t\t    count, kernel);\n\t\t\telse\n\t\t\t\tlines = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * If we are recovering a non-scrolling failure,\n\t\t\t * do not try to scroll yet.\n\t\t\t */\n\t\t\tlines = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (lines > 1) {\n\t\t\twsemul_resume_abort(&edp->abortstate);\n\t\t\trc = wsemul_vt100_scrollup(edp, lines);\n\t\t\tif (rc != 0) {\n\t\t\t\twsemul_abort_jump_scroll(&edp->abortstate,\n\t\t\t\t    lines);\n\t\t\t\treturn processed;\n\t\t\t}\n\t\t\twsemul_reset_abortstate(&edp->abortstate);\n\t\t\tedp->crow -= lines;\n\t\t}\n#endif\n\n\t\twsemul_resume_abort(&edp->abortstate);\n\n\t\tprev_count = count;\n\t\tif (wsemul_getchar(&data, &count, instate,\n#ifdef HAVE_UTF8_SUPPORT\n\t\t    (edp->state == VT100_EMUL_STATE_NORMAL && !kernel) ?\n\t\t      edp->flags & VTFL_UTF8 : 0\n#else\n\t\t    0\n#endif\n\t\t    ) != 0)\n\t\t\tbreak;\n\n\t\tif (!(instate->inchar & ~0xff) &&\n\t\t    (instate->inchar & 0x7f) < 0x20) {\n\t\t\trc = wsemul_vt100_output_c0c1(edp, instate, kernel);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tprocessed += prev_count - count;\n \t\t\tcontinue;\n \t\t}\n\n\t\tif (edp->state == VT100_EMUL_STATE_NORMAL || kernel) {\n\t\t\trc = wsemul_vt100_output_normal(edp, instate, kernel);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tprocessed += prev_count - count;\n\t\t\tcontinue;\n\t\t}\n#ifdef DIAGNOSTIC\n\t\tif (edp->state > nitems(vt100_output))\n\t\t\tpanic(\"wsemul_vt100: invalid state %d\", edp->state);\n#endif\n\t\trc = vt100_output[edp->state - 1](edp, instate);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tprocessed += prev_count - count;\n\t}\n\n\tif (rc != 0)\n\t\twsemul_abort_other(&edp->abortstate);\n\telse {\n\t\t/* put cursor image back if visible */\n\t\tif (edp->flags & VTFL_CURSORON) {\n\t\t\trc = (*edp->emulops->cursor)\n\t\t\t    (edp->emulcookie, 1, edp->crow,\n#ifdef HAVE_DOUBLE_WIDTH_HEIGHT\n\t\t\t     edp->ccol << edp->dw);\n#else\n\t\t\t     edp->ccol);\n#endif\n\t\t\tif (rc != 0) {\n\t\t\t\t/*\n\t\t\t\t * Pretend the last byte hasn't been processed,\n\t\t\t\t * while remembering that only the cursor\n\t\t\t\t * operation really needs to be done.\n\t\t\t\t */\n\t\t\t\twsemul_abort_cursor(&edp->abortstate);\n\t\t\t\tprocessed--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rc == 0)\n\t\twsemul_reset_abortstate(&edp->abortstate);\n\n\treturn processed;\n}\n\n#ifdef HAVE_JUMP_SCROLL\nint\nwsemul_vt100_jump_scroll(struct wsemul_vt100_emuldata *edp, const u_char *data,\n    u_int count, int kernel)\n{\n\tstruct wsemul_inputstate tmpstate;\n\tu_int pos, lines;\n\n\tlines = 0;\n\tpos = edp->ccol;\n\ttmpstate = kernel ? edp->kstate : edp->instate;\t/* structure copy */\n\n\twhile (wsemul_getchar(&data, &count, &tmpstate,\n#ifdef HAVE_UTF8_SUPPORT\n\t    kernel ? 0 : edp->flags & VTFL_UTF8\n#else\n\t    0\n#endif\n\t    ) == 0) {\n\t\t/*\n\t\t * Only char causing a transition from\n\t\t * VT100_EMUL_STATE_NORMAL to another state, for now.\n\t\t * Revisit this if this changes...\n\t\t */\n\t\tif (tmpstate.inchar == ASCII_ESC)\n\t\t\tbreak;\n\n\t\tif (ISSET(edp->flags, VTFL_DECAWM))\n\t\t\tswitch (tmpstate.inchar) {\n\t\t\tcase ASCII_BS:\n\t\t\t\tif (pos > 0)\n\t\t\t\t\tpos--;\n\t\t\t\tbreak;\n\t\t\tcase ASCII_CR:\n\t\t\t\tpos = 0;\n\t\t\t\tbreak;\n\t\t\tcase ASCII_HT:\n\t\t\t\tif (edp->tabs) {\n\t\t\t\t\tpos++;\n\t\t\t\t\twhile (pos < NCOLS - 1 &&\n\t\t\t\t\t    edp->tabs[pos] == 0)\n\t\t\t\t\t\tpos++;\n\t\t\t\t} else {\n\t\t\t\t\tpos = (pos + 7) & ~7;\n\t\t\t\t\tif (pos >= NCOLS)\n\t\t\t\t\t\tpos = NCOLS - 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!(tmpstate.inchar & ~0xff) &&\n\t\t\t\t    (tmpstate.inchar & 0x7f) < 0x20)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pos++ >= NCOLS) {\n\t\t\t\t\tpos = 0;\n\t\t\t\t\ttmpstate.inchar = ASCII_LF;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (tmpstate.inchar == ASCII_LF ||\n\t\t    tmpstate.inchar == ASCII_VT ||\n\t\t    tmpstate.inchar == ASCII_FF) {\n\t\t\tif (++lines >= edp->scrreg_nrows - 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n#endif\n"], "filenames": ["sys/dev/wscons/wsemul_sun.c", "sys/dev/wscons/wsemul_vt100.c"], "buggy_code_start_loc": [1, 1], "buggy_code_end_loc": [627, 1092], "fixing_code_start_loc": [1, 1], "fixing_code_end_loc": [628, 1085], "type": "CWE-862", "message": "OpenBSD 7.3 before errata 014 is missing an argument-count bounds check in console terminal emulation. This could cause incorrect memory access and a kernel crash after receiving crafted DCS or CSI terminal escape sequences.", "other": {"cve": {"id": "CVE-2023-40216", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-10T16:15:09.907", "lastModified": "2023-08-23T15:21:05.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenBSD 7.3 before errata 014 is missing an argument-count bounds check in console terminal emulation. This could cause incorrect memory access and a kernel crash after receiving crafted DCS or CSI terminal escape sequences."}, {"lang": "es", "value": "OpenBSD 7.3 antes de la errata 014 carece de una comprobaci\u00f3n de l\u00edmites de recuento de argumentos en la emulaci\u00f3n de terminal de consola. Esto podr\u00eda provocar un acceso incorrecto a la memoria y un bloqueo del kernel tras recibir secuencias de escape de terminal DCS o CSI falsificadas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:-:*:*:*:*:*:*", "matchCriteriaId": "7BAA0C9B-7CEA-4647-809F-027EB34C142E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_001:*:*:*:*:*:*", "matchCriteriaId": "B3CC37B8-46C0-407B-8DE4-2B5BC36BA969"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_002:*:*:*:*:*:*", "matchCriteriaId": "D53FE3CA-1A90-4783-8AC2-C0B4CF6F052D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_003:*:*:*:*:*:*", "matchCriteriaId": "9C32DD2B-BBE0-4031-B105-743E4058B4A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_004:*:*:*:*:*:*", "matchCriteriaId": "3F481F84-81C2-4E5F-BD60-4C46CD3DD603"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_005:*:*:*:*:*:*", "matchCriteriaId": "DCAE527B-1176-4759-B903-59A72245517B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_006:*:*:*:*:*:*", "matchCriteriaId": "90AFDC54-DCAD-46F5-8198-3632335D5529"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_007:*:*:*:*:*:*", "matchCriteriaId": "C7289DE0-7A7C-4535-BCA8-23D882468D28"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_008:*:*:*:*:*:*", "matchCriteriaId": "40791FF0-EFA3-4471-BCEB-0E1F36ABF973"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_009:*:*:*:*:*:*", "matchCriteriaId": "2AE8017A-F84D-4A8E-BAF0-8AC795D74FFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_010:*:*:*:*:*:*", "matchCriteriaId": "FFFC349B-AA6F-4286-8440-699D1F8A934A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_011:*:*:*:*:*:*", "matchCriteriaId": "B5AD12A6-74D4-4696-8126-402E61995D2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_012:*:*:*:*:*:*", "matchCriteriaId": "A9921E2D-DC9B-46FB-A01F-540C4B721D50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.3:errata_013:*:*:*:*:*:*", "matchCriteriaId": "CEFF0DA3-7CF7-42EB-9AA8-914EFD83466A"}]}]}], "references": [{"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/7.3/common/014_wscons.patch.sig", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/openbsd/src/commit/9d3f688f46eba347e96ff0ae9506ef2061622e0c", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/9d3f688f46eba347e96ff0ae9506ef2061622e0c"}}