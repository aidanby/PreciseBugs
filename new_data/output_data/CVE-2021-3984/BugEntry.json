{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * cindent.c: C indentation related functions\n *\n * Many of C-indenting functions originally come from Eric Fischer.\n *\n * Below \"XXX\" means that this function may unlock the current line.\n */\n\n#include \"vim.h\"\n\n// values for the \"lookfor\" state\n#define LOOKFOR_INITIAL\t\t0\n#define LOOKFOR_IF\t\t1\n#define LOOKFOR_DO\t\t2\n#define LOOKFOR_CASE\t\t3\n#define LOOKFOR_ANY\t\t4\n#define LOOKFOR_TERM\t\t5\n#define LOOKFOR_UNTERM\t\t6\n#define LOOKFOR_SCOPEDECL\t7\n#define LOOKFOR_NOBREAK\t\t8\n#define LOOKFOR_CPP_BASECLASS\t9\n#define LOOKFOR_ENUM_OR_INIT\t10\n#define LOOKFOR_JS_KEY\t\t11\n#define LOOKFOR_COMMA\t\t12\n\n#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)\n/*\n * Return TRUE if the string \"line\" starts with a word from 'cinwords'.\n */\n    int\ncin_is_cinword(char_u *line)\n{\n    char_u\t*cinw;\n    char_u\t*cinw_buf;\n    int\t\tcinw_len;\n    int\t\tretval = FALSE;\n    int\t\tlen;\n\n    cinw_len = (int)STRLEN(curbuf->b_p_cinw) + 1;\n    cinw_buf = alloc(cinw_len);\n    if (cinw_buf != NULL)\n    {\n\tline = skipwhite(line);\n\tfor (cinw = curbuf->b_p_cinw; *cinw; )\n\t{\n\t    len = copy_option_part(&cinw, cinw_buf, cinw_len, \",\");\n\t    if (STRNCMP(line, cinw_buf, len) == 0\n\t\t    && (!vim_iswordc(line[len]) || !vim_iswordc(line[len - 1])))\n\t    {\n\t\tretval = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tvim_free(cinw_buf);\n    }\n    return retval;\n}\n#endif\n\n#if defined(FEAT_CINDENT) || defined(FEAT_SYN_HL)\n\n/*\n * Skip to the end of a \"string\" and a 'c' character.\n * If there is no string or character, return argument unmodified.\n */\n    static char_u *\nskip_string(char_u *p)\n{\n    int\t    i;\n\n    // We loop, because strings may be concatenated: \"date\"\"time\".\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    // 'c' or '\\n' or '\\000'\n\t{\n\t    if (p[1] == NUL)\t\t    // ' at end of line\n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    // '\\n' or '\\000'\n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   // '\\000'\n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    // check for trailing '\n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    // start of string\n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    // end of string\n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; // continue for another string\n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    // Raw string: R\"[delim](...)[delim]\"\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; // continue for another string\n\t    }\n\t}\n\tbreak;\t\t\t\t    // no string found\n    }\n    if (!*p)\n\t--p;\t\t\t\t    // backup from NUL\n    return p;\n}\n\n/*\n * Find the start of a comment, not knowing if we are in a comment right now.\n * Search starts at w_cursor.lnum and goes backwards.\n * Return NULL when not inside a comment.\n */\n    static pos_T *\nind_find_start_comment(void)\t    // XXX\n{\n    return find_start_comment(curbuf->b_ind_maxcomment);\n}\n\n    pos_T *\nfind_start_comment(int ind_maxcomment)\t// XXX\n{\n    pos_T\t*pos;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcur_maxcomment = ind_maxcomment;\n\n    for (;;)\n    {\n\tpos = findmatchlimit(NULL, '*', FM_BACKWARD, cur_maxcomment);\n\tif (pos == NULL)\n\t    break;\n\n\t// Check if the comment start we found is inside a string.\n\t// If it is then restrict the search to below this line and try again.\n\tline = ml_get(pos->lnum);\n\tfor (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)\n\t    p = skip_string(p);\n\tif ((colnr_T)(p - line) <= pos->col)\n\t    break;\n\tcur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;\n\tif (cur_maxcomment <= 0)\n\t{\n\t    pos = NULL;\n\t    break;\n\t}\n    }\n    return pos;\n}\n\n/*\n * Find the start of a raw string, not knowing if we are in one right now.\n * Search starts at w_cursor.lnum and goes backwards.\n * Return NULL when not inside a raw string.\n */\n    static pos_T *\nfind_start_rawstring(int ind_maxcomment)\t// XXX\n{\n    pos_T\t*pos;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcur_maxcomment = ind_maxcomment;\n\n    for (;;)\n    {\n\tpos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);\n\tif (pos == NULL)\n\t    break;\n\n\t// Check if the raw string start we found is inside a string.\n\t// If it is then restrict the search to below this line and try again.\n\tline = ml_get(pos->lnum);\n\tfor (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)\n\t    p = skip_string(p);\n\tif ((colnr_T)(p - line) <= pos->col)\n\t    break;\n\tcur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;\n\tif (cur_maxcomment <= 0)\n\t{\n\t    pos = NULL;\n\t    break;\n\t}\n    }\n    return pos;\n}\n\n/*\n * Find the start of a comment or raw string, not knowing if we are in a\n * comment or raw string right now.\n * Search starts at w_cursor.lnum and goes backwards.\n * If is_raw is given and returns start of raw_string, sets it to true.\n * Return NULL when not inside a comment or raw string.\n * \"CORS\" -> Comment Or Raw String\n */\n    static pos_T *\nind_find_start_CORS(linenr_T *is_raw)\t    // XXX\n{\n    static pos_T comment_pos_copy;\n    pos_T\t*comment_pos;\n    pos_T\t*rs_pos;\n\n    comment_pos = find_start_comment(curbuf->b_ind_maxcomment);\n    if (comment_pos != NULL)\n    {\n\t// Need to make a copy of the static pos in findmatchlimit(),\n\t// calling find_start_rawstring() may change it.\n\tcomment_pos_copy = *comment_pos;\n\tcomment_pos = &comment_pos_copy;\n    }\n    rs_pos = find_start_rawstring(curbuf->b_ind_maxcomment);\n\n    // If comment_pos is before rs_pos the raw string is inside the comment.\n    // If rs_pos is before comment_pos the comment is inside the raw string.\n    if (comment_pos == NULL || (rs_pos != NULL\n\t\t\t\t\t     && LT_POS(*rs_pos, *comment_pos)))\n    {\n\tif (is_raw != NULL && rs_pos != NULL)\n\t    *is_raw = rs_pos->lnum;\n\treturn rs_pos;\n    }\n    return comment_pos;\n}\n#endif // FEAT_CINDENT || FEAT_SYN_HL\n\n#if defined(FEAT_CINDENT) || defined(PROTO)\n\n/*\n * Return TRUE if C-indenting is on.\n */\n    int\ncindent_on(void)\n{\n    return (!p_paste && (curbuf->b_p_cin\n# ifdef FEAT_EVAL\n\t\t    || *curbuf->b_p_inde != NUL\n# endif\n\t\t    ));\n}\n\n// Find result cache for cpp_baseclass\ntypedef struct {\n    int\t    found;\n    lpos_T  lpos;\n} cpp_baseclass_cache_T;\n\n/*\n * Skip over white space and C comments within the line.\n * Also skip over Perl/shell comments if desired.\n */\n    static char_u *\ncin_skipcomment(char_u *s)\n{\n    while (*s)\n    {\n\tchar_u *prev_s = s;\n\n\ts = skipwhite(s);\n\n\t// Perl/shell # comment comment continues until eol.  Require a space\n\t// before # to avoid recognizing $#array.\n\tif (curbuf->b_ind_hash_comment != 0 && s != prev_s && *s == '#')\n\t{\n\t    s += STRLEN(s);\n\t    break;\n\t}\n\tif (*s != '/')\n\t    break;\n\t++s;\n\tif (*s == '/')\t\t// slash-slash comment continues till eol\n\t{\n\t    s += STRLEN(s);\n\t    break;\n\t}\n\tif (*s != '*')\n\t    break;\n\tfor (++s; *s; ++s)\t// skip slash-star comment\n\t    if (s[0] == '*' && s[1] == '/')\n\t    {\n\t\ts += 2;\n\t\tbreak;\n\t    }\n    }\n    return s;\n}\n\n/*\n * Return TRUE if there is no code at *s.  White space and comments are\n * not considered code.\n */\n    static int\ncin_nocode(char_u *s)\n{\n    return *cin_skipcomment(s) == NUL;\n}\n\n/*\n * Recognize the start of a C or C++ comment.\n */\n    static int\ncin_iscomment(char_u *p)\n{\n    return (p[0] == '/' && (p[1] == '*' || p[1] == '/'));\n}\n\n/*\n * Recognize the start of a \"//\" comment.\n */\n    static int\ncin_islinecomment(char_u *p)\n{\n    return (p[0] == '/' && p[1] == '/');\n}\n\n/*\n * Check previous lines for a \"//\" line comment, skipping over blank lines.\n */\n    static pos_T *\nfind_line_comment(void) // XXX\n{\n    static pos_T pos;\n    char_u\t *line;\n    char_u\t *p;\n\n    pos = curwin->w_cursor;\n    while (--pos.lnum > 0)\n    {\n\tline = ml_get(pos.lnum);\n\tp = skipwhite(line);\n\tif (cin_islinecomment(p))\n\t{\n\t    pos.col = (int)(p - line);\n\t    return &pos;\n\t}\n\tif (*p != NUL)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Return TRUE if \"text\" starts with \"key:\".\n */\n    static int\ncin_has_js_key(char_u *text)\n{\n    char_u *s = skipwhite(text);\n    int\t    quote = -1;\n\n    if (*s == '\\'' || *s == '\"')\n    {\n\t// can be 'key': or \"key\":\n\tquote = *s;\n\t++s;\n    }\n    if (!vim_isIDc(*s))\t    // need at least one ID character\n\treturn FALSE;\n\n    while (vim_isIDc(*s))\n\t++s;\n    if (*s == quote)\n\t++s;\n\n    s = cin_skipcomment(s);\n\n    // \"::\" is not a label, it's C++\n    return (*s == ':' && s[1] != ':');\n}\n\n/*\n * Check if string matches \"label:\"; move to character after ':' if true.\n * \"*s\" must point to the start of the label, if there is one.\n */\n    static int\ncin_islabel_skip(char_u **s)\n{\n    if (!vim_isIDc(**s))\t    // need at least one ID character\n\treturn FALSE;\n\n    while (vim_isIDc(**s))\n\t(*s)++;\n\n    *s = cin_skipcomment(*s);\n\n    // \"::\" is not a label, it's C++\n    return (**s == ':' && *++*s != ':');\n}\n\n/*\n * Recognize a \"public/private/protected\" scope declaration label.\n */\n    static int\ncin_isscopedecl(char_u *s)\n{\n    int\t\ti;\n\n    s = cin_skipcomment(s);\n    if (STRNCMP(s, \"public\", 6) == 0)\n\ti = 6;\n    else if (STRNCMP(s, \"protected\", 9) == 0)\n\ti = 9;\n    else if (STRNCMP(s, \"private\", 7) == 0)\n\ti = 7;\n    else\n\treturn FALSE;\n    return (*(s = cin_skipcomment(s + i)) == ':' && s[1] != ':');\n}\n\n/*\n * Recognize a preprocessor statement: Any line that starts with '#'.\n */\n    static int\ncin_ispreproc(char_u *s)\n{\n    if (*skipwhite(s) == '#')\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE if line \"*pp\" at \"*lnump\" is a preprocessor statement or a\n * continuation line of a preprocessor statement.  Decrease \"*lnump\" to the\n * start and return the line in \"*pp\".\n * Put the amount of indent in \"*amount\".\n */\n    static int\ncin_ispreproc_cont(char_u **pp, linenr_T *lnump, int *amount)\n{\n    char_u\t*line = *pp;\n    linenr_T\tlnum = *lnump;\n    int\t\tretval = FALSE;\n    int\t\tcandidate_amount = *amount;\n\n    if (*line != NUL && line[STRLEN(line) - 1] == '\\\\')\n\tcandidate_amount = get_indent_lnum(lnum);\n\n    for (;;)\n    {\n\tif (cin_ispreproc(line))\n\t{\n\t    retval = TRUE;\n\t    *lnump = lnum;\n\t    break;\n\t}\n\tif (lnum == 1)\n\t    break;\n\tline = ml_get(--lnum);\n\tif (*line == NUL || line[STRLEN(line) - 1] != '\\\\')\n\t    break;\n    }\n\n    if (lnum != *lnump)\n\t*pp = ml_get(*lnump);\n    if (retval)\n\t*amount = candidate_amount;\n    return retval;\n}\n\n    static int\ncin_iselse(\n    char_u  *p)\n{\n    if (*p == '}')\t    // accept \"} else\"\n\tp = cin_skipcomment(p + 1);\n    return (STRNCMP(p, \"else\", 4) == 0 && !vim_isIDc(p[4]));\n}\n\n/*\n * Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or\n * '}'.\n * Don't consider \"} else\" a terminated line.\n * If a line begins with an \"else\", only consider it terminated if no unmatched\n * opening braces follow (handle \"else { foo();\" correctly).\n * Return the character terminating the line (ending char's have precedence if\n * both apply in order to determine initializations).\n */\n    static int\ncin_isterminated(\n    char_u\t*s,\n    int\t\tincl_open,\t// include '{' at the end as terminator\n    int\t\tincl_comma)\t// recognize a trailing comma\n{\n    char_u\tfound_start = 0;\n    unsigned\tn_open = 0;\n    int\t\tis_else = FALSE;\n\n    s = cin_skipcomment(s);\n\n    if (*s == '{' || (*s == '}' && !cin_iselse(s)))\n\tfound_start = *s;\n\n    if (!found_start)\n\tis_else = cin_iselse(s);\n\n    while (*s)\n    {\n\t// skip over comments, \"\" strings and 'c'haracters\n\ts = skip_string(cin_skipcomment(s));\n\tif (*s == '}' && n_open > 0)\n\t    --n_open;\n\tif ((!is_else || n_open == 0)\n\t\t&& (*s == ';' || *s == '}' || (incl_comma && *s == ','))\n\t\t&& cin_nocode(s + 1))\n\t    return *s;\n\telse if (*s == '{')\n\t{\n\t    if (incl_open && cin_nocode(s + 1))\n\t\treturn *s;\n\t    else\n\t\t++n_open;\n\t}\n\n\tif (*s)\n\t    s++;\n    }\n    return found_start;\n}\n\n/*\n * Return TRUE when \"s\" starts with \"word\" and then a non-ID character.\n */\n    static int\ncin_starts_with(char_u *s, char *word)\n{\n    int l = (int)STRLEN(word);\n\n    return (STRNCMP(s, word, l) == 0 && !vim_isIDc(s[l]));\n}\n\n/*\n * Recognize a \"default\" switch label.\n */\n    static int\ncin_isdefault(char_u *s)\n{\n    return (STRNCMP(s, \"default\", 7) == 0\n\t    && *(s = cin_skipcomment(s + 7)) == ':'\n\t    && s[1] != ':');\n}\n\n/*\n * Recognize a switch label: \"case .*:\" or \"default:\".\n */\n     static int\ncin_iscase(\n    char_u *s,\n    int strict) // Allow relaxed check of case statement for JS\n{\n    s = cin_skipcomment(s);\n    if (cin_starts_with(s, \"case\"))\n    {\n\tfor (s += 4; *s; ++s)\n\t{\n\t    s = cin_skipcomment(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\t    if (*s == ':')\n\t    {\n\t\tif (s[1] == ':')\t// skip over \"::\" for C++\n\t\t    ++s;\n\t\telse\n\t\t    return TRUE;\n\t    }\n\t    if (*s == '\\'' && s[1] && s[2] == '\\'')\n\t\ts += 2;\t\t\t// skip over ':'\n\t    else if (*s == '/' && (s[1] == '*' || s[1] == '/'))\n\t\treturn FALSE;\t\t// stop at comment\n\t    else if (*s == '\"')\n\t    {\n\t\t// JS etc.\n\t\tif (strict)\n\t\t    return FALSE;\t\t// stop at string\n\t\telse\n\t\t    return TRUE;\n\t    }\n\t}\n\treturn FALSE;\n    }\n\n    if (cin_isdefault(s))\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Recognize a label: \"label:\".\n * Note: curwin->w_cursor must be where we are looking for the label.\n */\n    static int\ncin_islabel(void)\t\t// XXX\n{\n    char_u\t*s;\n\n    s = cin_skipcomment(ml_get_curline());\n\n    // Exclude \"default\" from labels, since it should be indented\n    // like a switch label.  Same for C++ scope declarations.\n    if (cin_isdefault(s))\n\treturn FALSE;\n    if (cin_isscopedecl(s))\n\treturn FALSE;\n\n    if (cin_islabel_skip(&s))\n    {\n\t// Only accept a label if the previous line is terminated or is a case\n\t// label.\n\tpos_T\tcursor_save;\n\tpos_T\t*trypos;\n\tchar_u\t*line;\n\n\tcursor_save = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1)\n\t{\n\t    --curwin->w_cursor.lnum;\n\n\t    // If we're in a comment or raw string now, skip to the start of\n\t    // it.\n\t    curwin->w_cursor.col = 0;\n\t    if ((trypos = ind_find_start_CORS(NULL)) != NULL) // XXX\n\t\tcurwin->w_cursor = *trypos;\n\n\t    line = ml_get_curline();\n\t    if (cin_ispreproc(line))\t// ignore #defines, #if, etc.\n\t\tcontinue;\n\t    if (*(line = cin_skipcomment(line)) == NUL)\n\t\tcontinue;\n\n\t    curwin->w_cursor = cursor_save;\n\t    if (cin_isterminated(line, TRUE, FALSE)\n\t\t    || cin_isscopedecl(line)\n\t\t    || cin_iscase(line, TRUE)\n\t\t    || (cin_islabel_skip(&line) && cin_nocode(line)))\n\t\treturn TRUE;\n\t    return FALSE;\n\t}\n\tcurwin->w_cursor = cursor_save;\n\treturn TRUE;\t\t// label at start of file???\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if string \"s\" ends with the string \"find\", possibly followed by\n * white space and comments.  Skip strings and comments.\n * Ignore \"ignore\" after \"find\" if it's not NULL.\n */\n    static int\ncin_ends_in(char_u *s, char_u *find, char_u *ignore)\n{\n    char_u\t*p = s;\n    char_u\t*r;\n    int\t\tlen = (int)STRLEN(find);\n\n    while (*p != NUL)\n    {\n\tp = cin_skipcomment(p);\n\tif (STRNCMP(p, find, len) == 0)\n\t{\n\t    r = skipwhite(p + len);\n\t    if (ignore != NULL && STRNCMP(r, ignore, STRLEN(ignore)) == 0)\n\t\tr = skipwhite(r + STRLEN(ignore));\n\t    if (cin_nocode(r))\n\t\treturn TRUE;\n\t}\n\tif (*p != NUL)\n\t    ++p;\n    }\n    return FALSE;\n}\n\n/*\n * Recognize structure initialization and enumerations:\n * \"[typedef] [static|public|protected|private] enum\"\n * \"[typedef] [static|public|protected|private] = {\"\n */\n    static int\ncin_isinit(void)\n{\n    char_u\t*s;\n    static char *skip[] = {\"static\", \"public\", \"protected\", \"private\"};\n\n    s = cin_skipcomment(ml_get_curline());\n\n    if (cin_starts_with(s, \"typedef\"))\n\ts = cin_skipcomment(s + 7);\n\n    for (;;)\n    {\n\tint i, l;\n\n\tfor (i = 0; i < (int)ARRAY_LENGTH(skip); ++i)\n\t{\n\t    l = (int)strlen(skip[i]);\n\t    if (cin_starts_with(s, skip[i]))\n\t    {\n\t\ts = cin_skipcomment(s + l);\n\t\tl = 0;\n\t\tbreak;\n\t    }\n\t}\n\tif (l != 0)\n\t    break;\n    }\n\n    if (cin_starts_with(s, \"enum\"))\n\treturn TRUE;\n\n    if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))\n\treturn TRUE;\n\n    return FALSE;\n}\n\n// Maximum number of lines to search back for a \"namespace\" line.\n#define FIND_NAMESPACE_LIM 20\n\n/*\n * Recognize a \"namespace\" scope declaration.\n */\n    static int\ncin_is_cpp_namespace(char_u *s)\n{\n    char_u\t*p;\n    int\t\thas_name = FALSE;\n    int\t\thas_name_start = FALSE;\n\n    s = cin_skipcomment(s);\n    if (STRNCMP(s, \"namespace\", 9) == 0 && (s[9] == NUL || !vim_iswordc(s[9])))\n    {\n\tp = cin_skipcomment(skipwhite(s + 9));\n\twhile (*p != NUL)\n\t{\n\t    if (VIM_ISWHITE(*p))\n\t    {\n\t\thas_name = TRUE; // found end of a name\n\t\tp = cin_skipcomment(skipwhite(p));\n\t    }\n\t    else if (*p == '{')\n\t    {\n\t\tbreak;\n\t    }\n\t    else if (vim_iswordc(*p))\n\t    {\n\t\thas_name_start = TRUE;\n\t\tif (has_name)\n\t\t    return FALSE; // word character after skipping past name\n\t\t++p;\n\t    }\n\t    else if (p[0] == ':' && p[1] == ':' && vim_iswordc(p[2]))\n\t    {\n\t\tif (!has_name_start || has_name)\n\t\t    return FALSE;\n\t\t// C++ 17 nested namespace\n\t\tp += 3;\n\t    }\n\t    else\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Recognize a `extern \"C\"` or `extern \"C++\"` linkage specifications.\n */\n    static int\ncin_is_cpp_extern_c(char_u *s)\n{\n    char_u\t*p;\n    int\t\thas_string_literal = FALSE;\n\n    s = cin_skipcomment(s);\n    if (STRNCMP(s, \"extern\", 6) == 0 && (s[6] == NUL || !vim_iswordc(s[6])))\n    {\n\tp = cin_skipcomment(skipwhite(s + 6));\n\twhile (*p != NUL)\n\t{\n\t    if (VIM_ISWHITE(*p))\n\t    {\n\t\tp = cin_skipcomment(skipwhite(p));\n\t    }\n\t    else if (*p == '{')\n\t    {\n\t\tbreak;\n\t    }\n\t    else if (p[0] == '\"' && p[1] == 'C' && p[2] == '\"')\n\t    {\n\t\tif (has_string_literal)\n\t\t    return FALSE;\n\t\thas_string_literal = TRUE;\n\t\tp += 3;\n\t    }\n\t    else if (p[0] == '\"' && p[1] == 'C' && p[2] == '+' && p[3] == '+'\n\t\t    && p[4] == '\"')\n\t    {\n\t\tif (has_string_literal)\n\t\t    return FALSE;\n\t\thas_string_literal = TRUE;\n\t\tp += 5;\n\t    }\n\t    else\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\treturn has_string_literal ? TRUE : FALSE;\n    }\n    return FALSE;\n}\n\n/*\n * Return a pointer to the first non-empty non-comment character after a ':'.\n * Return NULL if not found.\n *\t  case 234:    a = b;\n *\t\t       ^\n */\n    static char_u *\nafter_label(char_u *l)\n{\n    for ( ; *l; ++l)\n    {\n\tif (*l == ':')\n\t{\n\t    if (l[1] == ':')\t    // skip over \"::\" for C++\n\t\t++l;\n\t    else if (!cin_iscase(l + 1, FALSE))\n\t\tbreak;\n\t}\n\telse if (*l == '\\'' && l[1] && l[2] == '\\'')\n\t    l += 2;\t\t    // skip over 'x'\n    }\n    if (*l == NUL)\n\treturn NULL;\n    l = cin_skipcomment(l + 1);\n    if (*l == NUL)\n\treturn NULL;\n    return l;\n}\n\n/*\n * Get indent of line \"lnum\", skipping a label.\n * Return 0 if there is nothing after the label.\n */\n    static int\nget_indent_nolabel (linenr_T lnum)\t// XXX\n{\n    char_u\t*l;\n    pos_T\tfp;\n    colnr_T\tcol;\n    char_u\t*p;\n\n    l = ml_get(lnum);\n    p = after_label(l);\n    if (p == NULL)\n\treturn 0;\n\n    fp.col = (colnr_T)(p - l);\n    fp.lnum = lnum;\n    getvcol(curwin, &fp, &col, NULL, NULL);\n    return (int)col;\n}\n\n/*\n * Find indent for line \"lnum\", ignoring any case or jump label.\n * Also return a pointer to the text (after the label) in \"pp\".\n *   label:\tif (asdf && asdfasdf)\n *\t\t^\n */\n    static int\nskip_label(linenr_T lnum, char_u **pp)\n{\n    char_u\t*l;\n    int\t\tamount;\n    pos_T\tcursor_save;\n\n    cursor_save = curwin->w_cursor;\n    curwin->w_cursor.lnum = lnum;\n    l = ml_get_curline();\n\t\t\t\t    // XXX\n    if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel())\n    {\n\tamount = get_indent_nolabel(lnum);\n\tl = after_label(ml_get_curline());\n\tif (l == NULL)\t\t// just in case\n\t    l = ml_get_curline();\n    }\n    else\n    {\n\tamount = get_indent();\n\tl = ml_get_curline();\n    }\n    *pp = l;\n\n    curwin->w_cursor = cursor_save;\n    return amount;\n}\n\n/*\n * Return the indent of the first variable name after a type in a declaration.\n *  int\t    a,\t\t\tindent of \"a\"\n *  static struct foo    b,\tindent of \"b\"\n *  enum bla    c,\t\tindent of \"c\"\n * Returns zero when it doesn't look like a declaration.\n */\n    static int\ncin_first_id_amount(void)\n{\n    char_u\t*line, *p, *s;\n    int\t\tlen;\n    pos_T\tfp;\n    colnr_T\tcol;\n\n    line = ml_get_curline();\n    p = skipwhite(line);\n    len = (int)(skiptowhite(p) - p);\n    if (len == 6 && STRNCMP(p, \"static\", 6) == 0)\n    {\n\tp = skipwhite(p + 6);\n\tlen = (int)(skiptowhite(p) - p);\n    }\n    if (len == 6 && STRNCMP(p, \"struct\", 6) == 0)\n\tp = skipwhite(p + 6);\n    else if (len == 4 && STRNCMP(p, \"enum\", 4) == 0)\n\tp = skipwhite(p + 4);\n    else if ((len == 8 && STRNCMP(p, \"unsigned\", 8) == 0)\n\t    || (len == 6 && STRNCMP(p, \"signed\", 6) == 0))\n    {\n\ts = skipwhite(p + len);\n\tif ((STRNCMP(s, \"int\", 3) == 0 && VIM_ISWHITE(s[3]))\n\t\t|| (STRNCMP(s, \"long\", 4) == 0 && VIM_ISWHITE(s[4]))\n\t\t|| (STRNCMP(s, \"short\", 5) == 0 && VIM_ISWHITE(s[5]))\n\t\t|| (STRNCMP(s, \"char\", 4) == 0 && VIM_ISWHITE(s[4])))\n\t    p = s;\n    }\n    for (len = 0; vim_isIDc(p[len]); ++len)\n\t;\n    if (len == 0 || !VIM_ISWHITE(p[len]) || cin_nocode(p))\n\treturn 0;\n\n    p = skipwhite(p + len);\n    fp.lnum = curwin->w_cursor.lnum;\n    fp.col = (colnr_T)(p - line);\n    getvcol(curwin, &fp, &col, NULL, NULL);\n    return (int)col;\n}\n\n/*\n * Return the indent of the first non-blank after an equal sign.\n *       char *foo = \"here\";\n * Return zero if no (useful) equal sign found.\n * Return -1 if the line above \"lnum\" ends in a backslash.\n *      foo = \"asdf\\\n *\t       asdf\\\n *\t       here\";\n */\n    static int\ncin_get_equal_amount(linenr_T lnum)\n{\n    char_u\t*line;\n    char_u\t*s;\n    colnr_T\tcol;\n    pos_T\tfp;\n\n    if (lnum > 1)\n    {\n\tline = ml_get(lnum - 1);\n\tif (*line != NUL && line[STRLEN(line) - 1] == '\\\\')\n\t    return -1;\n    }\n\n    line = s = ml_get(lnum);\n    while (*s != NUL && vim_strchr((char_u *)\"=;{}\\\"'\", *s) == NULL)\n    {\n\tif (cin_iscomment(s))\t// ignore comments\n\t    s = cin_skipcomment(s);\n\telse\n\t    ++s;\n    }\n    if (*s != '=')\n\treturn 0;\n\n    s = skipwhite(s + 1);\n    if (cin_nocode(s))\n\treturn 0;\n\n    if (*s == '\"')\t// nice alignment for continued strings\n\t++s;\n\n    fp.lnum = lnum;\n    fp.col = (colnr_T)(s - line);\n    getvcol(curwin, &fp, &col, NULL, NULL);\n    return (int)col;\n}\n\n/*\n * Skip strings, chars and comments until at or past \"trypos\".\n * Return the column found.\n */\n    static int\ncin_skip2pos(pos_T *trypos)\n{\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*new_p;\n\n    p = line = ml_get(trypos->lnum);\n    while (*p && (colnr_T)(p - line) < trypos->col)\n    {\n\tif (cin_iscomment(p))\n\t    p = cin_skipcomment(p);\n\telse\n\t{\n\t    new_p = skip_string(p);\n\t    if (new_p == p)\n\t\t++p;\n\t    else\n\t\tp = new_p;\n\t}\n    }\n    return (int)(p - line);\n}\n\n    static pos_T *\nfind_match_char(int c, int ind_maxparen)\t// XXX\n{\n    pos_T\tcursor_save;\n    pos_T\t*trypos;\n    static pos_T pos_copy;\n    int\t\tind_maxp_wk;\n\n    cursor_save = curwin->w_cursor;\n    ind_maxp_wk = ind_maxparen;\nretry:\n    if ((trypos = findmatchlimit(NULL, c, 0, ind_maxp_wk)) != NULL)\n    {\n\t// check if the ( is in a // comment\n\tif ((colnr_T)cin_skip2pos(trypos) > trypos->col)\n\t{\n\t    ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos->lnum);\n\t    if (ind_maxp_wk > 0)\n\t    {\n\t\tcurwin->w_cursor = *trypos;\n\t\tcurwin->w_cursor.col = 0;\t// XXX\n\t\tgoto retry;\n\t    }\n\t    trypos = NULL;\n\t}\n\telse\n\t{\n\t    pos_T\t*trypos_wk;\n\n\t    pos_copy = *trypos;\t    // copy trypos, findmatch will change it\n\t    trypos = &pos_copy;\n\t    curwin->w_cursor = *trypos;\n\t    if ((trypos_wk = ind_find_start_CORS(NULL)) != NULL) // XXX\n\t    {\n\t\tind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum\n\t\t\t- trypos_wk->lnum);\n\t\tif (ind_maxp_wk > 0)\n\t\t{\n\t\t    curwin->w_cursor = *trypos_wk;\n\t\t    goto retry;\n\t\t}\n\t\ttrypos = NULL;\n\t    }\n\t}\n    }\n    curwin->w_cursor = cursor_save;\n    return trypos;\n}\n\n/*\n * Find the matching '(', ignoring it if it is in a comment.\n * Return NULL if no match found.\n */\n    static pos_T *\nfind_match_paren(int ind_maxparen)\t// XXX\n{\n    return find_match_char('(', ind_maxparen);\n}\n\n/*\n * Set w_cursor.col to the column number of the last unmatched ')' or '{' in\n * line \"l\".  \"l\" must point to the start of the line.\n */\n    static int\nfind_last_paren(char_u *l, int start, int end)\n{\n    int\t\ti;\n    int\t\tretval = FALSE;\n    int\t\topen_count = 0;\n\n    curwin->w_cursor.col = 0;\t\t    // default is start of line\n\n    for (i = 0; l[i] != NUL; i++)\n    {\n\ti = (int)(cin_skipcomment(l + i) - l); // ignore parens in comments\n\ti = (int)(skip_string(l + i) - l);    // ignore parens in quotes\n\tif (l[i] == start)\n\t    ++open_count;\n\telse if (l[i] == end)\n\t{\n\t    if (open_count > 0)\n\t\t--open_count;\n\t    else\n\t    {\n\t\tcurwin->w_cursor.col = i;\n\t\tretval = TRUE;\n\t    }\n\t}\n    }\n    return retval;\n}\n\n/*\n * Recognize the basic picture of a function declaration -- it needs to\n * have an open paren somewhere and a close paren at the end of the line and\n * no semicolons anywhere.\n * When a line ends in a comma we continue looking in the next line.\n * \"sp\" points to a string with the line.  When looking at other lines it must\n * be restored to the line.  When it's NULL fetch lines here.\n * \"first_lnum\" is where we start looking.\n * \"min_lnum\" is the line before which we will not be looking.\n */\n    static int\ncin_isfuncdecl(\n    char_u\t**sp,\n    linenr_T\tfirst_lnum,\n    linenr_T\tmin_lnum)\n{\n    char_u\t*s;\n    linenr_T\tlnum = first_lnum;\n    linenr_T\tsave_lnum = curwin->w_cursor.lnum;\n    int\t\tretval = FALSE;\n    pos_T\t*trypos;\n    int\t\tjust_started = TRUE;\n\n    if (sp == NULL)\n\ts = ml_get(lnum);\n    else\n\ts = *sp;\n\n    curwin->w_cursor.lnum = lnum;\n    if (find_last_paren(s, '(', ')')\n\t&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)\n    {\n\tlnum = trypos->lnum;\n\tif (lnum < min_lnum)\n\t{\n\t    curwin->w_cursor.lnum = save_lnum;\n\t    return FALSE;\n\t}\n\n\ts = ml_get(lnum);\n    }\n    curwin->w_cursor.lnum = save_lnum;\n\n    // Ignore line starting with #.\n    if (cin_ispreproc(s))\n\treturn FALSE;\n\n    while (*s && *s != '(' && *s != ';' && *s != '\\'' && *s != '\"')\n    {\n\tif (cin_iscomment(s))\t// ignore comments\n\t    s = cin_skipcomment(s);\n\telse if (*s == ':')\n\t{\n\t    if (*(s + 1) == ':')\n\t\ts += 2;\n\t    else\n\t\t// To avoid a mistake in the following situation:\n\t\t// A::A(int a, int b)\n\t\t//     : a(0)  // <--not a function decl\n\t\t//     , b(0)\n\t\t// {...\n\t\treturn FALSE;\n\t}\n\telse\n\t    ++s;\n    }\n    if (*s != '(')\n\treturn FALSE;\t\t// ';', ' or \"  before any () or no '('\n\n    while (*s && *s != ';' && *s != '\\'' && *s != '\"')\n    {\n\tif (*s == ')' && cin_nocode(s + 1))\n\t{\n\t    // ')' at the end: may have found a match\n\t    // Check for he previous line not to end in a backslash:\n\t    //       #if defined(x) && {backslash}\n\t    //\t\t defined(y)\n\t    lnum = first_lnum - 1;\n\t    s = ml_get(lnum);\n\t    if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')\n\t\tretval = TRUE;\n\t    goto done;\n\t}\n\tif ((*s == ',' && cin_nocode(s + 1)) || s[1] == NUL || cin_nocode(s))\n\t{\n\t    int comma = (*s == ',');\n\n\t    // ',' at the end: continue looking in the next line.\n\t    // At the end: check for ',' in the next line, for this style:\n\t    // func(arg1\n\t    //       , arg2)\n\t    for (;;)\n\t    {\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t\ts = ml_get(++lnum);\n\t\tif (!cin_ispreproc(s))\n\t\t    break;\n\t    }\n\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\tbreak;\n\t    // Require a comma at end of the line or a comma or ')' at the\n\t    // start of next line.\n\t    s = skipwhite(s);\n\t    if (!just_started && (!comma && *s != ',' && *s != ')'))\n\t\tbreak;\n\t    just_started = FALSE;\n\t}\n\telse if (cin_iscomment(s))\t// ignore comments\n\t    s = cin_skipcomment(s);\n\telse\n\t{\n\t    ++s;\n\t    just_started = FALSE;\n\t}\n    }\n\ndone:\n    if (lnum != first_lnum && sp != NULL)\n\t*sp = ml_get(first_lnum);\n\n    return retval;\n}\n\n    static int\ncin_isif(char_u *p)\n{\n return (STRNCMP(p, \"if\", 2) == 0 && !vim_isIDc(p[2]));\n}\n\n    static int\ncin_isdo(char_u *p)\n{\n    return (STRNCMP(p, \"do\", 2) == 0 && !vim_isIDc(p[2]));\n}\n\n/*\n * Check if this is a \"while\" that should have a matching \"do\".\n * We only accept a \"while (condition) ;\", with only white space between the\n * ')' and ';'. The condition may be spread over several lines.\n */\n    static int\ncin_iswhileofdo (char_u *p, linenr_T lnum)\t// XXX\n{\n    pos_T\tcursor_save;\n    pos_T\t*trypos;\n    int\t\tretval = FALSE;\n\n    p = cin_skipcomment(p);\n    if (*p == '}')\t\t// accept \"} while (cond);\"\n\tp = cin_skipcomment(p + 1);\n    if (cin_starts_with(p, \"while\"))\n    {\n\tcursor_save = curwin->w_cursor;\n\tcurwin->w_cursor.lnum = lnum;\n\tcurwin->w_cursor.col = 0;\n\tp = ml_get_curline();\n\twhile (*p && *p != 'w')\t// skip any '}', until the 'w' of the \"while\"\n\t{\n\t    ++p;\n\t    ++curwin->w_cursor.col;\n\t}\n\tif ((trypos = findmatchlimit(NULL, 0, 0,\n\t\t\t\t\t      curbuf->b_ind_maxparen)) != NULL\n\t\t&& *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')\n\t    retval = TRUE;\n\tcurwin->w_cursor = cursor_save;\n    }\n    return retval;\n}\n\n/*\n * Check whether in \"p\" there is an \"if\", \"for\" or \"while\" before \"*poffset\".\n * Return 0 if there is none.\n * Otherwise return !0 and update \"*poffset\" to point to the place where the\n * string was found.\n */\n    static int\ncin_is_if_for_while_before_offset(char_u *line, int *poffset)\n{\n    int offset = *poffset;\n\n    if (offset-- < 2)\n\treturn 0;\n    while (offset > 2 && VIM_ISWHITE(line[offset]))\n\t--offset;\n\n    offset -= 1;\n    if (!STRNCMP(line + offset, \"if\", 2))\n\tgoto probablyFound;\n\n    if (offset >= 1)\n    {\n\toffset -= 1;\n\tif (!STRNCMP(line + offset, \"for\", 3))\n\t    goto probablyFound;\n\n\tif (offset >= 2)\n\t{\n\t    offset -= 2;\n\t    if (!STRNCMP(line + offset, \"while\", 5))\n\t\tgoto probablyFound;\n\t}\n    }\n    return 0;\n\nprobablyFound:\n    if (!offset || !vim_isIDc(line[offset - 1]))\n    {\n\t*poffset = offset;\n\treturn 1;\n    }\n    return 0;\n}\n\n/*\n * Return TRUE if we are at the end of a do-while.\n *    do\n *       nothing;\n *    while (foo\n *\t       && bar);  <-- here\n * Adjust the cursor to the line with \"while\".\n */\n    static int\ncin_iswhileofdo_end(int terminated)\n{\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*s;\n    pos_T\t*trypos;\n    int\t\ti;\n\n    if (terminated != ';')\t// there must be a ';' at the end\n\treturn FALSE;\n\n    p = line = ml_get_curline();\n    while (*p != NUL)\n    {\n\tp = cin_skipcomment(p);\n\tif (*p == ')')\n\t{\n\t    s = skipwhite(p + 1);\n\t    if (*s == ';' && cin_nocode(s + 1))\n\t    {\n\t\t// Found \");\" at end of the line, now check there is \"while\"\n\t\t// before the matching '('.  XXX\n\t\ti = (int)(p - line);\n\t\tcurwin->w_cursor.col = i;\n\t\ttrypos = find_match_paren(curbuf->b_ind_maxparen);\n\t\tif (trypos != NULL)\n\t\t{\n\t\t    s = cin_skipcomment(ml_get(trypos->lnum));\n\t\t    if (*s == '}')\t\t// accept \"} while (cond);\"\n\t\t\ts = cin_skipcomment(s + 1);\n\t\t    if (cin_starts_with(s, \"while\"))\n\t\t    {\n\t\t\tcurwin->w_cursor.lnum = trypos->lnum;\n\t\t\treturn TRUE;\n\t\t    }\n\t\t}\n\n\t\t// Searching may have made \"line\" invalid, get it again.\n\t\tline = ml_get_curline();\n\t\tp = line + i;\n\t    }\n\t}\n\tif (*p != NUL)\n\t    ++p;\n    }\n    return FALSE;\n}\n\n    static int\ncin_isbreak(char_u *p)\n{\n    return (STRNCMP(p, \"break\", 5) == 0 && !vim_isIDc(p[5]));\n}\n\n/*\n * Find the position of a C++ base-class declaration or\n * constructor-initialization. eg:\n *\n * class MyClass :\n *\tbaseClass\t\t<-- here\n * class MyClass : public baseClass,\n *\tanotherBaseClass\t<-- here (should probably lineup ??)\n * MyClass::MyClass(...) :\n *\tbaseClass(...)\t\t<-- here (constructor-initialization)\n *\n * This is a lot of guessing.  Watch out for \"cond ? func() : foo\".\n */\n    static int\ncin_is_cpp_baseclass(\n    cpp_baseclass_cache_T *cached) // input and output\n{\n    lpos_T\t*pos = &cached->lpos;\t    // find position\n    char_u\t*s;\n    int\t\tclass_or_struct, lookfor_ctor_init, cpp_base_class;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    char_u\t*line = ml_get_curline();\n\n    if (pos->lnum <= lnum)\n\treturn cached->found;\t// Use the cached result\n\n    pos->col = 0;\n\n    s = skipwhite(line);\n    if (*s == '#')\t\t// skip #define FOO x ? (x) : x\n\treturn FALSE;\n    s = cin_skipcomment(s);\n    if (*s == NUL)\n\treturn FALSE;\n\n    cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;\n\n    // Search for a line starting with '#', empty, ending in ';' or containing\n    // '{' or '}' and start below it.  This handles the following situations:\n    //\ta = cond ?\n    //\t      func() :\n    //\t\t   asdf;\n    //\tfunc::foo()\n    //\t      : something\n    //\t{}\n    //\tFoo::Foo (int one, int two)\n    //\t\t: something(4),\n    //\t\tsomethingelse(3)\n    //\t{}\n    while (lnum > 1)\n    {\n\tline = ml_get(lnum - 1);\n\ts = skipwhite(line);\n\tif (*s == '#' || *s == NUL)\n\t    break;\n\twhile (*s != NUL)\n\t{\n\t    s = cin_skipcomment(s);\n\t    if (*s == '{' || *s == '}'\n\t\t    || (*s == ';' && cin_nocode(s + 1)))\n\t\tbreak;\n\t    if (*s != NUL)\n\t\t++s;\n\t}\n\tif (*s != NUL)\n\t    break;\n\t--lnum;\n    }\n\n    pos->lnum = lnum;\n    line = ml_get(lnum);\n    s = line;\n    for (;;)\n    {\n\tif (*s == NUL)\n\t{\n\t    if (lnum == curwin->w_cursor.lnum)\n\t\tbreak;\n\t    // Continue in the cursor line.\n\t    line = ml_get(++lnum);\n\t    s = line;\n\t}\n\tif (s == line)\n\t{\n\t    // don't recognize \"case (foo):\" as a baseclass\n\t    if (cin_iscase(s, FALSE))\n\t\tbreak;\n\t    s = cin_skipcomment(line);\n\t    if (*s == NUL)\n\t\tcontinue;\n\t}\n\n\tif (s[0] == '\"' || (s[0] == 'R' && s[1] == '\"'))\n\t    s = skip_string(s) + 1;\n\telse if (s[0] == ':')\n\t{\n\t    if (s[1] == ':')\n\t    {\n\t\t// skip double colon. It can't be a constructor\n\t\t// initialization any more\n\t\tlookfor_ctor_init = FALSE;\n\t\ts = cin_skipcomment(s + 2);\n\t    }\n\t    else if (lookfor_ctor_init || class_or_struct)\n\t    {\n\t\t// we have something found, that looks like the start of\n\t\t// cpp-base-class-declaration or constructor-initialization\n\t\tcpp_base_class = TRUE;\n\t\tlookfor_ctor_init = class_or_struct = FALSE;\n\t\tpos->col = 0;\n\t\ts = cin_skipcomment(s + 1);\n\t    }\n\t    else\n\t\ts = cin_skipcomment(s + 1);\n\t}\n\telse if ((STRNCMP(s, \"class\", 5) == 0 && !vim_isIDc(s[5]))\n\t\t|| (STRNCMP(s, \"struct\", 6) == 0 && !vim_isIDc(s[6])))\n\t{\n\t    class_or_struct = TRUE;\n\t    lookfor_ctor_init = FALSE;\n\n\t    if (*s == 'c')\n\t\ts = cin_skipcomment(s + 5);\n\t    else\n\t\ts = cin_skipcomment(s + 6);\n\t}\n\telse\n\t{\n\t    if (s[0] == '{' || s[0] == '}' || s[0] == ';')\n\t    {\n\t\tcpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;\n\t    }\n\t    else if (s[0] == ')')\n\t    {\n\t\t// Constructor-initialization is assumed if we come across\n\t\t// something like \"):\"\n\t\tclass_or_struct = FALSE;\n\t\tlookfor_ctor_init = TRUE;\n\t    }\n\t    else if (s[0] == '?')\n\t    {\n\t\t// Avoid seeing '() :' after '?' as constructor init.\n\t\treturn FALSE;\n\t    }\n\t    else if (!vim_isIDc(s[0]))\n\t    {\n\t\t// if it is not an identifier, we are wrong\n\t\tclass_or_struct = FALSE;\n\t\tlookfor_ctor_init = FALSE;\n\t    }\n\t    else if (pos->col == 0)\n\t    {\n\t\t// it can't be a constructor-initialization any more\n\t\tlookfor_ctor_init = FALSE;\n\n\t\t// the first statement starts here: lineup with this one...\n\t\tif (cpp_base_class)\n\t\t    pos->col = (colnr_T)(s - line);\n\t    }\n\n\t    // When the line ends in a comma don't align with it.\n\t    if (lnum == curwin->w_cursor.lnum && *s == ',' && cin_nocode(s + 1))\n\t\tpos->col = 0;\n\n\t    s = cin_skipcomment(s + 1);\n\t}\n    }\n\n    cached->found = cpp_base_class;\n    if (cpp_base_class)\n\tpos->lnum = lnum;\n    return cpp_base_class;\n}\n\n    static int\nget_baseclass_amount(int col)\n{\n    int\t\tamount;\n    colnr_T\tvcol;\n    pos_T\t*trypos;\n\n    if (col == 0)\n    {\n\tamount = get_indent();\n\tif (find_last_paren(ml_get_curline(), '(', ')')\n\t\t&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)\n\t    amount = get_indent_lnum(trypos->lnum); // XXX\n\tif (!cin_ends_in(ml_get_curline(), (char_u *)\",\", NULL))\n\t    amount += curbuf->b_ind_cpp_baseclass;\n    }\n    else\n    {\n\tcurwin->w_cursor.col = col;\n\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\tamount = (int)vcol;\n    }\n    if (amount < curbuf->b_ind_cpp_baseclass)\n\tamount = curbuf->b_ind_cpp_baseclass;\n    return amount;\n}\n\n/*\n * Find the '{' at the start of the block we are in.\n * Return NULL if no match found.\n * Ignore a '{' that is in a comment, makes indenting the next three lines\n * work.\n */\n// foo()\n// {\n// }\n\n    static pos_T *\nfind_start_brace(void)\t    // XXX\n{\n    pos_T\tcursor_save;\n    pos_T\t*trypos;\n    pos_T\t*pos;\n    static pos_T\tpos_copy;\n\n    cursor_save = curwin->w_cursor;\n    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)\n    {\n\tpos_copy = *trypos;\t// copy pos_T, next findmatch will change it\n\ttrypos = &pos_copy;\n\tcurwin->w_cursor = *trypos;\n\tpos = NULL;\n\t// ignore the { if it's in a // or / *  * / comment\n\tif ((colnr_T)cin_skip2pos(trypos) == trypos->col\n\t\t       && (pos = ind_find_start_CORS(NULL)) == NULL) // XXX\n\t    break;\n\tif (pos != NULL)\n\t    curwin->w_cursor.lnum = pos->lnum;\n    }\n    curwin->w_cursor = cursor_save;\n    return trypos;\n}\n\n/*\n * Find the matching '(', ignoring it if it is in a comment or before an\n * unmatched {.\n * Return NULL if no match found.\n */\n    static pos_T *\nfind_match_paren_after_brace (int ind_maxparen)\t    // XXX\n{\n    pos_T\t*trypos = find_match_paren(ind_maxparen);\n\n    if (trypos != NULL)\n    {\n\tpos_T\t*tryposBrace = find_start_brace();\n\n\t// If both an unmatched '(' and '{' is found.  Ignore the '('\n\t// position if the '{' is further down.\n\tif (tryposBrace != NULL\n\t\t&& (trypos->lnum != tryposBrace->lnum\n\t\t    ? trypos->lnum < tryposBrace->lnum\n\t\t    : trypos->col < tryposBrace->col))\n\t    trypos = NULL;\n    }\n    return trypos;\n}\n\n/*\n * Return ind_maxparen corrected for the difference in line number between the\n * cursor position and \"startpos\".  This makes sure that searching for a\n * matching paren above the cursor line doesn't find a match because of\n * looking a few lines further.\n */\n    static int\ncorr_ind_maxparen(pos_T *startpos)\n{\n    long\tn = (long)startpos->lnum - (long)curwin->w_cursor.lnum;\n\n    if (n > 0 && n < curbuf->b_ind_maxparen / 2)\n\treturn curbuf->b_ind_maxparen - (int)n;\n    return curbuf->b_ind_maxparen;\n}\n\n/*\n * Parse 'cinoptions' and set the values in \"curbuf\".\n * Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.\n */\n    void\nparse_cino(buf_T *buf)\n{\n    char_u\t*p;\n    char_u\t*l;\n    char_u\t*digits;\n    int\t\tn;\n    int\t\tdivider;\n    int\t\tfraction = 0;\n    int\t\tsw = (int)get_sw_value(buf);\n\n    // Set the default values.\n\n    // Spaces from a block's opening brace the prevailing indent for that\n    // block should be.\n    buf->b_ind_level = sw;\n\n    // Spaces from the edge of the line an open brace that's at the end of a\n    // line is imagined to be.\n    buf->b_ind_open_imag = 0;\n\n    // Spaces from the prevailing indent for a line that is not preceded by\n    // an opening brace.\n    buf->b_ind_no_brace = 0;\n\n    // Column where the first { of a function should be located }.\n    buf->b_ind_first_open = 0;\n\n    // Spaces from the prevailing indent a leftmost open brace should be\n    // located.\n    buf->b_ind_open_extra = 0;\n\n    // Spaces from the matching open brace (real location for one at the left\n    // edge; imaginary location from one that ends a line) the matching close\n    // brace should be located.\n    buf->b_ind_close_extra = 0;\n\n    // Spaces from the edge of the line an open brace sitting in the leftmost\n    // column is imagined to be.\n    buf->b_ind_open_left_imag = 0;\n\n    // Spaces jump labels should be shifted to the left if N is non-negative,\n    // otherwise the jump label will be put to column 1.\n    buf->b_ind_jump_label = -1;\n\n    // Spaces from the switch() indent a \"case xx\" label should be located.\n    buf->b_ind_case = sw;\n\n    // Spaces from the \"case xx:\" code after a switch() should be located.\n    buf->b_ind_case_code = sw;\n\n    // Lineup break at end of case in switch() with case label.\n    buf->b_ind_case_break = 0;\n\n    // Spaces from the class declaration indent a scope declaration label\n    // should be located.\n    buf->b_ind_scopedecl = sw;\n\n    // Spaces from the scope declaration label code should be located.\n    buf->b_ind_scopedecl_code = sw;\n\n    // Amount K&R-style parameters should be indented.\n    buf->b_ind_param = sw;\n\n    // Amount a function type spec should be indented.\n    buf->b_ind_func_type = sw;\n\n    // Amount a cpp base class declaration or constructor initialization\n    // should be indented.\n    buf->b_ind_cpp_baseclass = sw;\n\n    // additional spaces beyond the prevailing indent a continuation line\n    // should be located.\n    buf->b_ind_continuation = sw;\n\n    // Spaces from the indent of the line with an unclosed parenthesis.\n    buf->b_ind_unclosed = sw * 2;\n\n    // Spaces from the indent of the line with an unclosed parenthesis, which\n    // itself is also unclosed.\n    buf->b_ind_unclosed2 = sw;\n\n    // Suppress ignoring spaces from the indent of a line starting with an\n    // unclosed parentheses.\n    buf->b_ind_unclosed_noignore = 0;\n\n    // If the opening paren is the last nonwhite character on the line, and\n    // b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer\n    // context (for very long lines).\n    buf->b_ind_unclosed_wrapped = 0;\n\n    // Suppress ignoring white space when lining up with the character after\n    // an unclosed parenthesis.\n    buf->b_ind_unclosed_whiteok = 0;\n\n    // Indent a closing parentheses under the line start of the matching\n    // opening parentheses.\n    buf->b_ind_matching_paren = 0;\n\n    // Indent a closing parentheses under the previous line.\n    buf->b_ind_paren_prev = 0;\n\n    // Extra indent for comments.\n    buf->b_ind_comment = 0;\n\n    // Spaces from the comment opener when there is nothing after it.\n    buf->b_ind_in_comment = 3;\n\n    // Boolean: if non-zero, use b_ind_in_comment even if there is something\n    // after the comment opener.\n    buf->b_ind_in_comment2 = 0;\n\n    // Max lines to search for an open paren.\n    buf->b_ind_maxparen = 20;\n\n    // Max lines to search for an open comment.\n    buf->b_ind_maxcomment = 70;\n\n    // Handle braces for java code.\n    buf->b_ind_java = 0;\n\n    // Not to confuse JS object properties with labels.\n    buf->b_ind_js = 0;\n\n    // Handle blocked cases correctly.\n    buf->b_ind_keep_case_label = 0;\n\n    // Handle C++ namespace.\n    buf->b_ind_cpp_namespace = 0;\n\n    // Handle continuation lines containing conditions of if(), for() and\n    // while().\n    buf->b_ind_if_for_while = 0;\n\n    // indentation for # comments\n    buf->b_ind_hash_comment = 0;\n\n    // Handle C++ extern \"C\" or \"C++\"\n    buf->b_ind_cpp_extern_c = 0;\n\n    // Handle C #pragma directives\n    buf->b_ind_pragma = 0;\n\n    for (p = buf->b_p_cino; *p; )\n    {\n\tl = p++;\n\tif (*p == '-')\n\t    ++p;\n\tdigits = p;\t    // remember where the digits start\n\tn = getdigits(&p);\n\tdivider = 0;\n\tif (*p == '.')\t    // \".5s\" means a fraction\n\t{\n\t    fraction = atol((char *)++p);\n\t    while (VIM_ISDIGIT(*p))\n\t    {\n\t\t++p;\n\t\tif (divider)\n\t\t    divider *= 10;\n\t\telse\n\t\t    divider = 10;\n\t    }\n\t}\n\tif (*p == 's')\t    // \"2s\" means two times 'shiftwidth'\n\t{\n\t    if (p == digits)\n\t\tn = sw;\t// just \"s\" is one 'shiftwidth'\n\t    else\n\t    {\n\t\tn *= sw;\n\t\tif (divider)\n\t\t    n += (sw * fraction + divider / 2) / divider;\n\t    }\n\t    ++p;\n\t}\n\tif (l[1] == '-')\n\t    n = -n;\n\n\t// When adding an entry here, also update the default 'cinoptions' in\n\t// doc/indent.txt, and add explanation for it!\n\tswitch (*l)\n\t{\n\t    case '>': buf->b_ind_level = n; break;\n\t    case 'e': buf->b_ind_open_imag = n; break;\n\t    case 'n': buf->b_ind_no_brace = n; break;\n\t    case 'f': buf->b_ind_first_open = n; break;\n\t    case '{': buf->b_ind_open_extra = n; break;\n\t    case '}': buf->b_ind_close_extra = n; break;\n\t    case '^': buf->b_ind_open_left_imag = n; break;\n\t    case 'L': buf->b_ind_jump_label = n; break;\n\t    case ':': buf->b_ind_case = n; break;\n\t    case '=': buf->b_ind_case_code = n; break;\n\t    case 'b': buf->b_ind_case_break = n; break;\n\t    case 'p': buf->b_ind_param = n; break;\n\t    case 't': buf->b_ind_func_type = n; break;\n\t    case '/': buf->b_ind_comment = n; break;\n\t    case 'c': buf->b_ind_in_comment = n; break;\n\t    case 'C': buf->b_ind_in_comment2 = n; break;\n\t    case 'i': buf->b_ind_cpp_baseclass = n; break;\n\t    case '+': buf->b_ind_continuation = n; break;\n\t    case '(': buf->b_ind_unclosed = n; break;\n\t    case 'u': buf->b_ind_unclosed2 = n; break;\n\t    case 'U': buf->b_ind_unclosed_noignore = n; break;\n\t    case 'W': buf->b_ind_unclosed_wrapped = n; break;\n\t    case 'w': buf->b_ind_unclosed_whiteok = n; break;\n\t    case 'm': buf->b_ind_matching_paren = n; break;\n\t    case 'M': buf->b_ind_paren_prev = n; break;\n\t    case ')': buf->b_ind_maxparen = n; break;\n\t    case '*': buf->b_ind_maxcomment = n; break;\n\t    case 'g': buf->b_ind_scopedecl = n; break;\n\t    case 'h': buf->b_ind_scopedecl_code = n; break;\n\t    case 'j': buf->b_ind_java = n; break;\n\t    case 'J': buf->b_ind_js = n; break;\n\t    case 'l': buf->b_ind_keep_case_label = n; break;\n\t    case '#': buf->b_ind_hash_comment = n; break;\n\t    case 'N': buf->b_ind_cpp_namespace = n; break;\n\t    case 'k': buf->b_ind_if_for_while = n; break;\n\t    case 'E': buf->b_ind_cpp_extern_c = n; break;\n\t    case 'P': buf->b_ind_pragma = n; break;\n\t}\n\tif (*p == ',')\n\t    ++p;\n    }\n}\n\n    static int\nfind_match(int lookfor, linenr_T ourscope)\n{\n    char_u\t*look;\n    pos_T\t*theirscope;\n    char_u\t*mightbeif;\n    int\t\telselevel;\n    int\t\twhilelevel;\n\n    if (lookfor == LOOKFOR_IF)\n    {\n\telselevel = 1;\n\twhilelevel = 0;\n    }\n    else\n    {\n\telselevel = 0;\n\twhilelevel = 1;\n    }\n\n    curwin->w_cursor.col = 0;\n\n    while (curwin->w_cursor.lnum > ourscope + 1)\n    {\n\tcurwin->w_cursor.lnum--;\n\tcurwin->w_cursor.col = 0;\n\n\tlook = cin_skipcomment(ml_get_curline());\n\tif (cin_iselse(look)\n\t\t|| cin_isif(look)\n\t\t|| cin_isdo(look)\t\t\t    // XXX\n\t\t|| cin_iswhileofdo(look, curwin->w_cursor.lnum))\n\t{\n\t    // if we've gone outside the braces entirely,\n\t    // we must be out of scope...\n\t    theirscope = find_start_brace();  // XXX\n\t    if (theirscope == NULL)\n\t\tbreak;\n\n\t    // and if the brace enclosing this is further\n\t    // back than the one enclosing the else, we're\n\t    // out of luck too.\n\t    if (theirscope->lnum < ourscope)\n\t\tbreak;\n\n\t    // and if they're enclosed in a *deeper* brace,\n\t    // then we can ignore it because it's in a\n\t    // different scope...\n\t    if (theirscope->lnum > ourscope)\n\t\tcontinue;\n\n\t    // if it was an \"else\" (that's not an \"else if\")\n\t    // then we need to go back to another if, so\n\t    // increment elselevel\n\t    look = cin_skipcomment(ml_get_curline());\n\t    if (cin_iselse(look))\n\t    {\n\t\tmightbeif = cin_skipcomment(look + 4);\n\t\tif (!cin_isif(mightbeif))\n\t\t    ++elselevel;\n\t\tcontinue;\n\t    }\n\n\t    // if it was a \"while\" then we need to go back to\n\t    // another \"do\", so increment whilelevel.  XXX\n\t    if (cin_iswhileofdo(look, curwin->w_cursor.lnum))\n\t    {\n\t\t++whilelevel;\n\t\tcontinue;\n\t    }\n\n\t    // If it's an \"if\" decrement elselevel\n\t    look = cin_skipcomment(ml_get_curline());\n\t    if (cin_isif(look))\n\t    {\n\t\telselevel--;\n\t\t// When looking for an \"if\" ignore \"while\"s that\n\t\t// get in the way.\n\t\tif (elselevel == 0 && lookfor == LOOKFOR_IF)\n\t\t    whilelevel = 0;\n\t    }\n\n\t    // If it's a \"do\" decrement whilelevel\n\t    if (cin_isdo(look))\n\t\twhilelevel--;\n\n\t    // if we've used up all the elses, then\n\t    // this must be the if that we want!\n\t    // match the indent level of that if.\n\t    if (elselevel <= 0 && whilelevel <= 0)\n\t\treturn OK;\n\t}\n    }\n    return FAIL;\n}\n\n/*\n * Return the desired indent for C code.\n * Return -1 if the indent should be left alone (inside a raw string).\n */\n    int\nget_c_indent(void)\n{\n    pos_T\tcur_curpos;\n    int\t\tamount;\n    int\t\tscope_amount;\n    int\t\tcur_amount = MAXCOL;\n    colnr_T\tcol;\n    char_u\t*theline;\n    char_u\t*linecopy;\n    pos_T\t*trypos;\n    pos_T\t*comment_pos;\n    pos_T\t*tryposBrace = NULL;\n    pos_T\ttryposCopy;\n    pos_T\tour_paren_pos;\n    char_u\t*start;\n    int\t\tstart_brace;\n#define BRACE_IN_COL0\t\t1\t    // '{' is in column 0\n#define BRACE_AT_START\t\t2\t    // '{' is at start of line\n#define BRACE_AT_END\t\t3\t    // '{' is at end of line\n    linenr_T\tourscope;\n    char_u\t*l;\n    char_u\t*look;\n    char_u\tterminated;\n    int\t\tlookfor;\n    int\t\twhilelevel;\n    linenr_T\tlnum;\n    int\t\tn;\n    int\t\tiscase;\n    int\t\tlookfor_break;\n    int\t\tlookfor_cpp_namespace = FALSE;\n    int\t\tcont_amount = 0;    // amount for continuation line\n    int\t\toriginal_line_islabel;\n    int\t\tadded_to_amount = 0;\n    int\t\tjs_cur_has_key = 0;\n    linenr_T\traw_string_start = 0;\n    cpp_baseclass_cache_T cache_cpp_baseclass = { FALSE, { MAXLNUM, 0 } };\n\n    // make a copy, value is changed below\n    int\t\tind_continuation = curbuf->b_ind_continuation;\n\n    // remember where the cursor was when we started\n    cur_curpos = curwin->w_cursor;\n\n    // if we are at line 1 zero indent is fine, right?\n    if (cur_curpos.lnum == 1)\n\treturn 0;\n\n    // Get a copy of the current contents of the line.\n    // This is required, because only the most recent line obtained with\n    // ml_get is valid!\n    linecopy = vim_strsave(ml_get(cur_curpos.lnum));\n    if (linecopy == NULL)\n\treturn 0;\n\n    // In insert mode and the cursor is on a ')' truncate the line at the\n    // cursor position.  We don't want to line up with the matching '(' when\n    // inserting new stuff.\n    // For unknown reasons the cursor might be past the end of the line, thus\n    // check for that.\n    if ((State & INSERT)\n\t    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)\n\t    && linecopy[curwin->w_cursor.col] == ')')\n\tlinecopy[curwin->w_cursor.col] = NUL;\n\n    theline = skipwhite(linecopy);\n\n    // move the cursor to the start of the line\n\n    curwin->w_cursor.col = 0;\n\n    original_line_islabel = cin_islabel();  // XXX\n\n    // If we are inside a raw string don't change the indent.\n    // Ignore a raw string inside a comment.\n    comment_pos = ind_find_start_comment();\n    if (comment_pos != NULL)\n    {\n\t// findmatchlimit() static pos is overwritten, make a copy\n\ttryposCopy = *comment_pos;\n\tcomment_pos = &tryposCopy;\n    }\n    trypos = find_start_rawstring(curbuf->b_ind_maxcomment);\n    if (trypos != NULL && (comment_pos == NULL\n\t\t\t\t\t     || LT_POS(*trypos, *comment_pos)))\n    {\n\tamount = -1;\n\tgoto laterend;\n    }\n\n    // #defines and so on go at the left when included in 'cinkeys',\n    // excluding pragmas when customized in 'cinoptions'\n    if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))\n    {\n\tchar_u *directive = skipwhite(theline + 1);\n\tif (curbuf->b_ind_pragma == 0 || STRNCMP(directive, \"pragma\", 6) != 0)\n\t{\n\t    amount = curbuf->b_ind_hash_comment;\n\t    goto theend;\n\t}\n    }\n\n    // Is it a non-case label?\tThen that goes at the left margin too unless:\n    //  - JS flag is set.\n    //  - 'L' item has a positive value.\n    if (original_line_islabel && !curbuf->b_ind_js\n\t\t\t\t\t      && curbuf->b_ind_jump_label < 0)\n    {\n\tamount = 0;\n\tgoto theend;\n    }\n\n    // If we're inside a \"//\" comment and there is a \"//\" comment in a\n    // previous line, lineup with that one.\n    if (cin_islinecomment(theline)\n\t    && (trypos = find_line_comment()) != NULL) // XXX\n    {\n\t// find how indented the line beginning the comment is\n\tgetvcol(curwin, trypos, &col, NULL, NULL);\n\tamount = col;\n\tgoto theend;\n    }\n\n    // If we're inside a comment and not looking at the start of the\n    // comment, try using the 'comments' option.\n    if (!cin_iscomment(theline) && comment_pos != NULL) // XXX\n    {\n\tint\tlead_start_len = 2;\n\tint\tlead_middle_len = 1;\n\tchar_u\tlead_start[COM_MAX_LEN];\t// start-comment string\n\tchar_u\tlead_middle[COM_MAX_LEN];\t// middle-comment string\n\tchar_u\tlead_end[COM_MAX_LEN];\t\t// end-comment string\n\tchar_u\t*p;\n\tint\tstart_align = 0;\n\tint\tstart_off = 0;\n\tint\tdone = FALSE;\n\n\t// find how indented the line beginning the comment is\n\tgetvcol(curwin, comment_pos, &col, NULL, NULL);\n\tamount = col;\n\t*lead_start = NUL;\n\t*lead_middle = NUL;\n\n\tp = curbuf->b_p_com;\n\twhile (*p != NUL)\n\t{\n\t    int\talign = 0;\n\t    int\toff = 0;\n\t    int what = 0;\n\n\t    while (*p != NUL && *p != ':')\n\t    {\n\t\tif (*p == COM_START || *p == COM_END || *p == COM_MIDDLE)\n\t\t    what = *p++;\n\t\telse if (*p == COM_LEFT || *p == COM_RIGHT)\n\t\t    align = *p++;\n\t\telse if (VIM_ISDIGIT(*p) || *p == '-')\n\t\t    off = getdigits(&p);\n\t\telse\n\t\t    ++p;\n\t    }\n\n\t    if (*p == ':')\n\t\t++p;\n\t    (void)copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\t    if (what == COM_START)\n\t    {\n\t\tSTRCPY(lead_start, lead_end);\n\t\tlead_start_len = (int)STRLEN(lead_start);\n\t\tstart_off = off;\n\t\tstart_align = align;\n\t    }\n\t    else if (what == COM_MIDDLE)\n\t    {\n\t\tSTRCPY(lead_middle, lead_end);\n\t\tlead_middle_len = (int)STRLEN(lead_middle);\n\t    }\n\t    else if (what == COM_END)\n\t    {\n\t\t// If our line starts with the middle comment string, line it\n\t\t// up with the comment opener per the 'comments' option.\n\t\tif (STRNCMP(theline, lead_middle, lead_middle_len) == 0\n\t\t\t&& STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0)\n\t\t{\n\t\t    done = TRUE;\n\t\t    if (curwin->w_cursor.lnum > 1)\n\t\t    {\n\t\t\t// If the start comment string matches in the previous\n\t\t\t// line, use the indent of that line plus offset.  If\n\t\t\t// the middle comment string matches in the previous\n\t\t\t// line, use the indent of that line.  XXX\n\t\t\tlook = skipwhite(ml_get(curwin->w_cursor.lnum - 1));\n\t\t\tif (STRNCMP(look, lead_start, lead_start_len) == 0)\n\t\t\t    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);\n\t\t\telse if (STRNCMP(look, lead_middle,\n\t\t\t\t\t\t\tlead_middle_len) == 0)\n\t\t\t{\n\t\t\t    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);\n\t\t\t    break;\n\t\t\t}\n\t\t\t// If the start comment string doesn't match with the\n\t\t\t// start of the comment, skip this entry.  XXX\n\t\t\telse if (STRNCMP(ml_get(comment_pos->lnum) + comment_pos->col,\n\t\t\t\t\t     lead_start, lead_start_len) != 0)\n\t\t\t    continue;\n\t\t    }\n\t\t    if (start_off != 0)\n\t\t\tamount += start_off;\n\t\t    else if (start_align == COM_RIGHT)\n\t\t\tamount += vim_strsize(lead_start)\n\t\t\t\t\t\t   - vim_strsize(lead_middle);\n\t\t    break;\n\t\t}\n\n\t\t// If our line starts with the end comment string, line it up\n\t\t// with the middle comment\n\t\tif (STRNCMP(theline, lead_middle, lead_middle_len) != 0\n\t\t\t&& STRNCMP(theline, lead_end, STRLEN(lead_end)) == 0)\n\t\t{\n\t\t    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);\n\t\t\t\t\t\t\t\t     // XXX\n\t\t    if (off != 0)\n\t\t\tamount += off;\n\t\t    else if (align == COM_RIGHT)\n\t\t\tamount += vim_strsize(lead_start)\n\t\t\t\t\t\t   - vim_strsize(lead_middle);\n\t\t    done = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t// If our line starts with an asterisk, line up with the\n\t// asterisk in the comment opener; otherwise, line up\n\t// with the first character of the comment text.\n\tif (done)\n\t    ;\n\telse if (theline[0] == '*')\n\t    amount += 1;\n\telse\n\t{\n\t    // If we are more than one line away from the comment opener, take\n\t    // the indent of the previous non-empty line.  If 'cino' has \"CO\"\n\t    // and we are just below the comment opener and there are any\n\t    // white characters after it line up with the text after it;\n\t    // otherwise, add the amount specified by \"c\" in 'cino'\n\t    amount = -1;\n\t    for (lnum = cur_curpos.lnum - 1; lnum > comment_pos->lnum; --lnum)\n\t    {\n\t\tif (linewhite(lnum))\t\t    // skip blank lines\n\t\t    continue;\n\t\tamount = get_indent_lnum(lnum);\t    // XXX\n\t\tbreak;\n\t    }\n\t    if (amount == -1)\t\t\t    // use the comment opener\n\t    {\n\t\tif (!curbuf->b_ind_in_comment2)\n\t\t{\n\t\t    start = ml_get(comment_pos->lnum);\n\t\t    look = start + comment_pos->col + 2; // skip / and *\n\t\t    if (*look != NUL)\t\t    // if something after it\n\t\t\tcomment_pos->col = (colnr_T)(skipwhite(look) - start);\n\t\t}\n\t\tgetvcol(curwin, comment_pos, &col, NULL, NULL);\n\t\tamount = col;\n\t\tif (curbuf->b_ind_in_comment2 || *look == NUL)\n\t\t    amount += curbuf->b_ind_in_comment;\n\t    }\n\t}\n\tgoto theend;\n    }\n\n    // Are we looking at a ']' that has a match?\n    if (*skipwhite(theline) == ']'\n\t    && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL)\n    {\n\t// align with the line containing the '['.\n\tamount = get_indent_lnum(trypos->lnum);\n\tgoto theend;\n    }\n\n    // Are we inside parentheses or braces?  XXX\n    if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL\n\t\t&& curbuf->b_ind_java == 0)\n\t    || (tryposBrace = find_start_brace()) != NULL\n\t    || trypos != NULL)\n    {\n      if (trypos != NULL && tryposBrace != NULL)\n      {\n\t  // Both an unmatched '(' and '{' is found.  Use the one which is\n\t  // closer to the current cursor position, set the other to NULL.\n\t  if (trypos->lnum != tryposBrace->lnum\n\t\t  ? trypos->lnum < tryposBrace->lnum\n\t\t  : trypos->col < tryposBrace->col)\n\t      trypos = NULL;\n\t  else\n\t      tryposBrace = NULL;\n      }\n\n      if (trypos != NULL)\n      {\n\t// If the matching paren is more than one line away, use the indent of\n\t// a previous non-empty line that matches the same paren.\n\tif (theline[0] == ')' && curbuf->b_ind_paren_prev)\n\t{\n\t    // Line up with the start of the matching paren line.\n\t    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);  // XXX\n\t}\n\telse\n\t{\n\t    amount = -1;\n\t    our_paren_pos = *trypos;\n\t    for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum)\n\t    {\n\t\tl = skipwhite(ml_get(lnum));\n\t\tif (cin_nocode(l))\t\t// skip comment lines\n\t\t    continue;\n\t\tif (cin_ispreproc_cont(&l, &lnum, &amount))\n\t\t    continue;\t\t\t// ignore #define, #if, etc.\n\t\tcurwin->w_cursor.lnum = lnum;\n\n\t\t// Skip a comment or raw string.  XXX\n\t\tif ((trypos = ind_find_start_CORS(NULL)) != NULL)\n\t\t{\n\t\t    lnum = trypos->lnum + 1;\n\t\t    continue;\n\t\t}\n\n\t\t// XXX\n\t\tif ((trypos = find_match_paren(\n\t\t\tcorr_ind_maxparen(&cur_curpos))) != NULL\n\t\t\t&& trypos->lnum == our_paren_pos.lnum\n\t\t\t&& trypos->col == our_paren_pos.col)\n\t\t{\n\t\t\tamount = get_indent_lnum(lnum);\t// XXX\n\n\t\t\tif (theline[0] == ')')\n\t\t\t{\n\t\t\t    if (our_paren_pos.lnum != lnum\n\t\t\t\t\t\t       && cur_amount > amount)\n\t\t\t\tcur_amount = amount;\n\t\t\t    amount = -1;\n\t\t\t}\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t// Line up with line where the matching paren is. XXX\n\t// If the line starts with a '(' or the indent for unclosed\n\t// parentheses is zero, line up with the unclosed parentheses.\n\tif (amount == -1)\n\t{\n\t    int\t    ignore_paren_col = 0;\n\t    int\t    is_if_for_while = 0;\n\n\t    if (curbuf->b_ind_if_for_while)\n\t    {\n\t\t// Look for the outermost opening parenthesis on this line\n\t\t// and check whether it belongs to an \"if\", \"for\" or \"while\".\n\n\t\tpos_T\t    cursor_save = curwin->w_cursor;\n\t\tpos_T\t    outermost;\n\t\tchar_u\t    *line;\n\n\t\ttrypos = &our_paren_pos;\n\t\tdo {\n\t\t    outermost = *trypos;\n\t\t    curwin->w_cursor.lnum = outermost.lnum;\n\t\t    curwin->w_cursor.col = outermost.col;\n\n\t\t    trypos = find_match_paren(curbuf->b_ind_maxparen);\n\t\t} while (trypos && trypos->lnum == outermost.lnum);\n\n\t\tcurwin->w_cursor = cursor_save;\n\n\t\tline = ml_get(outermost.lnum);\n\n\t\tis_if_for_while =\n\t\t    cin_is_if_for_while_before_offset(line, &outermost.col);\n\t    }\n\n\t    amount = skip_label(our_paren_pos.lnum, &look);\n\t    look = skipwhite(look);\n\t    if (*look == '(')\n\t    {\n\t\tlinenr_T    save_lnum = curwin->w_cursor.lnum;\n\t\tchar_u\t    *line;\n\t\tint\t    look_col;\n\n\t\t// Ignore a '(' in front of the line that has a match before\n\t\t// our matching '('.\n\t\tcurwin->w_cursor.lnum = our_paren_pos.lnum;\n\t\tline = ml_get_curline();\n\t\tlook_col = (int)(look - line);\n\t\tcurwin->w_cursor.col = look_col + 1;\n\t\tif ((trypos = findmatchlimit(NULL, ')', 0,\n\t\t\t\t\t\t      curbuf->b_ind_maxparen))\n\t\t\t\t\t\t\t\t      != NULL\n\t\t\t  && trypos->lnum == our_paren_pos.lnum\n\t\t\t  && trypos->col < our_paren_pos.col)\n\t\t    ignore_paren_col = trypos->col + 1;\n\n\t\tcurwin->w_cursor.lnum = save_lnum;\n\t\tlook = ml_get(our_paren_pos.lnum) + look_col;\n\t    }\n\t    if (theline[0] == ')' || (curbuf->b_ind_unclosed == 0\n\t\t\t\t\t\t      && is_if_for_while == 0)\n\t\t    || (!curbuf->b_ind_unclosed_noignore && *look == '('\n\t\t\t\t\t\t    && ignore_paren_col == 0))\n\t    {\n\t\t// If we're looking at a close paren, line up right there;\n\t\t// otherwise, line up with the next (non-white) character.\n\t\t// When b_ind_unclosed_wrapped is set and the matching paren is\n\t\t// the last nonwhite character of the line, use either the\n\t\t// indent of the current line or the indentation of the next\n\t\t// outer paren and add b_ind_unclosed_wrapped (for very long\n\t\t// lines).\n\t\tif (theline[0] != ')')\n\t\t{\n\t\t    cur_amount = MAXCOL;\n\t\t    l = ml_get(our_paren_pos.lnum);\n\t\t    if (curbuf->b_ind_unclosed_wrapped\n\t\t\t\t       && cin_ends_in(l, (char_u *)\"(\", NULL))\n\t\t    {\n\t\t\t// look for opening unmatched paren, indent one level\n\t\t\t// for each additional level\n\t\t\tn = 1;\n\t\t\tfor (col = 0; col < our_paren_pos.col; ++col)\n\t\t\t{\n\t\t\t    switch (l[col])\n\t\t\t    {\n\t\t\t\tcase '(':\n\t\t\t\tcase '{': ++n;\n\t\t\t\t\t  break;\n\n\t\t\t\tcase ')':\n\t\t\t\tcase '}': if (n > 1)\n\t\t\t\t\t      --n;\n\t\t\t\t\t  break;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tour_paren_pos.col = 0;\n\t\t\tamount += n * curbuf->b_ind_unclosed_wrapped;\n\t\t    }\n\t\t    else if (curbuf->b_ind_unclosed_whiteok)\n\t\t\tour_paren_pos.col++;\n\t\t    else\n\t\t    {\n\t\t\tcol = our_paren_pos.col + 1;\n\t\t\twhile (VIM_ISWHITE(l[col]))\n\t\t\t    col++;\n\t\t\tif (l[col] != NUL)\t// In case of trailing space\n\t\t\t    our_paren_pos.col = col;\n\t\t\telse\n\t\t\t    our_paren_pos.col++;\n\t\t    }\n\t\t}\n\n\t\t// Find how indented the paren is, or the character after it\n\t\t// if we did the above \"if\".\n\t\tif (our_paren_pos.col > 0)\n\t\t{\n\t\t    getvcol(curwin, &our_paren_pos, &col, NULL, NULL);\n\t\t    if (cur_amount > (int)col)\n\t\t\tcur_amount = col;\n\t\t}\n\t    }\n\n\t    if (theline[0] == ')' && curbuf->b_ind_matching_paren)\n\t    {\n\t\t// Line up with the start of the matching paren line.\n\t    }\n\t    else if ((curbuf->b_ind_unclosed == 0 && is_if_for_while == 0)\n\t\t     || (!curbuf->b_ind_unclosed_noignore\n\t\t\t\t    && *look == '(' && ignore_paren_col == 0))\n\t    {\n\t\tif (cur_amount != MAXCOL)\n\t\t    amount = cur_amount;\n\t    }\n\t    else\n\t    {\n\t\t// Add b_ind_unclosed2 for each '(' before our matching one,\n\t\t// but ignore (void) before the line (ignore_paren_col).\n\t\tcol = our_paren_pos.col;\n\t\twhile ((int)our_paren_pos.col > ignore_paren_col)\n\t\t{\n\t\t    --our_paren_pos.col;\n\t\t    switch (*ml_get_pos(&our_paren_pos))\n\t\t    {\n\t\t\tcase '(': amount += curbuf->b_ind_unclosed2;\n\t\t\t\t  col = our_paren_pos.col;\n\t\t\t\t  break;\n\t\t\tcase ')': amount -= curbuf->b_ind_unclosed2;\n\t\t\t\t  col = MAXCOL;\n\t\t\t\t  break;\n\t\t    }\n\t\t}\n\n\t\t// Use b_ind_unclosed once, when the first '(' is not inside\n\t\t// braces\n\t\tif (col == MAXCOL)\n\t\t    amount += curbuf->b_ind_unclosed;\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = our_paren_pos.lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    if (find_match_paren_after_brace(curbuf->b_ind_maxparen)\n\t\t\t\t\t\t\t\t      != NULL)\n\t\t\tamount += curbuf->b_ind_unclosed2;\n\t\t    else\n\t\t    {\n\t\t\tif (is_if_for_while)\n\t\t\t    amount += curbuf->b_ind_if_for_while;\n\t\t\telse\n\t\t\t    amount += curbuf->b_ind_unclosed;\n\t\t    }\n\t\t}\n\t\t// For a line starting with ')' use the minimum of the two\n\t\t// positions, to avoid giving it more indent than the previous\n\t\t// lines:\n\t\t//  func_long_name(\t\t    if (x\n\t\t//\targ\t\t\t\t    && yy\n\t\t//\t)\t  ^ not here\t       )    ^ not here\n\t\tif (cur_amount < amount)\n\t\t    amount = cur_amount;\n\t    }\n\t}\n\n\t// add extra indent for a comment\n\tif (cin_iscomment(theline))\n\t    amount += curbuf->b_ind_comment;\n      }\n      else\n      {\n\t// We are inside braces, there is a { before this line at the position\n\t// stored in tryposBrace.\n\t// Make a copy of tryposBrace, it may point to pos_copy inside\n\t// find_start_brace(), which may be changed somewhere.\n\ttryposCopy = *tryposBrace;\n\ttryposBrace = &tryposCopy;\n\ttrypos = tryposBrace;\n\tourscope = trypos->lnum;\n\tstart = ml_get(ourscope);\n\n\t// Now figure out how indented the line is in general.\n\t// If the brace was at the start of the line, we use that;\n\t// otherwise, check out the indentation of the line as\n\t// a whole and then add the \"imaginary indent\" to that.\n\tlook = skipwhite(start);\n\tif (*look == '{')\n\t{\n\t    getvcol(curwin, trypos, &col, NULL, NULL);\n\t    amount = col;\n\t    if (*start == '{')\n\t\tstart_brace = BRACE_IN_COL0;\n\t    else\n\t\tstart_brace = BRACE_AT_START;\n\t}\n\telse\n\t{\n\t    // That opening brace might have been on a continuation\n\t    // line.  if so, find the start of the line.\n\t    curwin->w_cursor.lnum = ourscope;\n\n\t    // Position the cursor over the rightmost paren, so that\n\t    // matching it will take us back to the start of the line.\n\t    lnum = ourscope;\n\t    if (find_last_paren(start, '(', ')')\n\t\t\t&& (trypos = find_match_paren(curbuf->b_ind_maxparen))\n\t\t\t\t\t\t\t\t      != NULL)\n\t\tlnum = trypos->lnum;\n\n\t    // It could have been something like\n\t    //\t   case 1: if (asdf &&\n\t    //\t\t\tldfd) {\n\t    //\t\t    }\n\t    if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)\n\t\t\t   && cin_iscase(skipwhite(ml_get_curline()), FALSE))\n\t\tamount = get_indent();\n\t    else if (curbuf->b_ind_js)\n\t\tamount = get_indent_lnum(lnum);\n\t    else\n\t\tamount = skip_label(lnum, &l);\n\n\t    start_brace = BRACE_AT_END;\n\t}\n\n\t// For Javascript check if the line starts with \"key:\".\n\tif (curbuf->b_ind_js)\n\t    js_cur_has_key = cin_has_js_key(theline);\n\n\t// If we're looking at a closing brace, that's where\n\t// we want to be.  otherwise, add the amount of room\n\t// that an indent is supposed to be.\n\tif (theline[0] == '}')\n\t{\n\t    // they may want closing braces to line up with something\n\t    // other than the open brace.  indulge them, if so.\n\t    amount += curbuf->b_ind_close_extra;\n\t}\n\telse\n\t{\n\t    // If we're looking at an \"else\", try to find an \"if\"\n\t    // to match it with.\n\t    // If we're looking at a \"while\", try to find a \"do\"\n\t    // to match it with.\n\t    lookfor = LOOKFOR_INITIAL;\n\t    if (cin_iselse(theline))\n\t\tlookfor = LOOKFOR_IF;\n\t    else if (cin_iswhileofdo(theline, cur_curpos.lnum)) // XXX\n\t\tlookfor = LOOKFOR_DO;\n\t    if (lookfor != LOOKFOR_INITIAL)\n\t    {\n\t\tcurwin->w_cursor.lnum = cur_curpos.lnum;\n\t\tif (find_match(lookfor, ourscope) == OK)\n\t\t{\n\t\t    amount = get_indent();\t// XXX\n\t\t    goto theend;\n\t\t}\n\t    }\n\n\t    // We get here if we are not on an \"while-of-do\" or \"else\" (or\n\t    // failed to find a matching \"if\").\n\t    // Search backwards for something to line up with.\n\t    // First set amount for when we don't find anything.\n\n\t    // if the '{' is  _really_ at the left margin, use the imaginary\n\t    // location of a left-margin brace.  Otherwise, correct the\n\t    // location for b_ind_open_extra.\n\n\t    if (start_brace == BRACE_IN_COL0)\t    // '{' is in column 0\n\t    {\n\t\tamount = curbuf->b_ind_open_left_imag;\n\t\tlookfor_cpp_namespace = TRUE;\n\t    }\n\t    else if (start_brace == BRACE_AT_START &&\n\t\t    lookfor_cpp_namespace)\t  // '{' is at start\n\t    {\n\n\t\tlookfor_cpp_namespace = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (start_brace == BRACE_AT_END)    // '{' is at end of line\n\t\t{\n\t\t    amount += curbuf->b_ind_open_imag;\n\n\t\t    l = skipwhite(ml_get_curline());\n\t\t    if (cin_is_cpp_namespace(l))\n\t\t\tamount += curbuf->b_ind_cpp_namespace;\n\t\t    else if (cin_is_cpp_extern_c(l))\n\t\t\tamount += curbuf->b_ind_cpp_extern_c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Compensate for adding b_ind_open_extra later.\n\t\t    amount -= curbuf->b_ind_open_extra;\n\t\t    if (amount < 0)\n\t\t\tamount = 0;\n\t\t}\n\t    }\n\n\t    lookfor_break = FALSE;\n\n\t    if (cin_iscase(theline, FALSE))\t// it's a switch() label\n\t    {\n\t\tlookfor = LOOKFOR_CASE;\t// find a previous switch() label\n\t\tamount += curbuf->b_ind_case;\n\t    }\n\t    else if (cin_isscopedecl(theline))\t// private:, ...\n\t    {\n\t\tlookfor = LOOKFOR_SCOPEDECL;\t// class decl is this block\n\t\tamount += curbuf->b_ind_scopedecl;\n\t    }\n\t    else\n\t    {\n\t\tif (curbuf->b_ind_case_break && cin_isbreak(theline))\n\t\t    // break; ...\n\t\t    lookfor_break = TRUE;\n\n\t\tlookfor = LOOKFOR_INITIAL;\n\t\t// b_ind_level from start of block\n\t\tamount += curbuf->b_ind_level;\n\t    }\n\t    scope_amount = amount;\n\t    whilelevel = 0;\n\n\t    // Search backwards.  If we find something we recognize, line up\n\t    // with that.\n\t    //\n\t    // If we're looking at an open brace, indent\n\t    // the usual amount relative to the conditional\n\t    // that opens the block.\n\t    curwin->w_cursor = cur_curpos;\n\t    for (;;)\n\t    {\n\t\tcurwin->w_cursor.lnum--;\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// If we went all the way back to the start of our scope, line\n\t\t// up with it.\n\t\tif (curwin->w_cursor.lnum <= ourscope)\n\t\t{\n\t\t    // We reached end of scope:\n\t\t    // If looking for an enum or structure initialization\n\t\t    // go further back:\n\t\t    // If it is an initializer (enum xxx or xxx =), then\n\t\t    // don't add ind_continuation, otherwise it is a variable\n\t\t    // declaration:\n\t\t    // int x,\n\t\t    //     here; <-- add ind_continuation\n\t\t    if (lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t    {\n\t\t\tif (curwin->w_cursor.lnum == 0\n\t\t\t\t|| curwin->w_cursor.lnum\n\t\t\t\t\t  < ourscope - curbuf->b_ind_maxparen)\n\t\t\t{\n\t\t\t    // nothing found (abuse curbuf->b_ind_maxparen as\n\t\t\t    // limit) assume terminated line (i.e. a variable\n\t\t\t    // initialization)\n\t\t\t    if (cont_amount > 0)\n\t\t\t\tamount = cont_amount;\n\t\t\t    else if (!curbuf->b_ind_js)\n\t\t\t\tamount += ind_continuation;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\tl = ml_get_curline();\n\n\t\t\t// If we're in a comment or raw string now, skip to\n\t\t\t// the start of it.\n\t\t\ttrypos = ind_find_start_CORS(NULL);\n\t\t\tif (trypos != NULL)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t\t    curwin->w_cursor.col = 0;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// Skip preprocessor directives and blank lines.\n\t\t\tif (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t    &amount))\n\t\t\t    continue;\n\n\t\t\tif (cin_nocode(l))\n\t\t\t    continue;\n\n\t\t\tterminated = cin_isterminated(l, FALSE, TRUE);\n\n\t\t\t// If we are at top level and the line looks like a\n\t\t\t// function declaration, we are done\n\t\t\t// (it's a variable declaration).\n\t\t\tif (start_brace != BRACE_IN_COL0\n\t\t\t     || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))\n\t\t\t{\n\t\t\t    // if the line is terminated with another ','\n\t\t\t    // it is a continued variable initialization.\n\t\t\t    // don't add extra indent.\n\t\t\t    // TODO: does not work, if  a function\n\t\t\t    // declaration is split over multiple lines:\n\t\t\t    // cin_isfuncdecl returns FALSE then.\n\t\t\t    if (terminated == ',')\n\t\t\t\tbreak;\n\n\t\t\t    // if it is an enum declaration or an assignment,\n\t\t\t    // we are done.\n\t\t\t    if (terminated != ';' && cin_isinit())\n\t\t\t\tbreak;\n\n\t\t\t    // nothing useful found\n\t\t\t    if (terminated == 0 || terminated == '{')\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (terminated != ';')\n\t\t\t{\n\t\t\t    // Skip parens and braces. Position the cursor\n\t\t\t    // over the rightmost paren, so that matching it\n\t\t\t    // will take us back to the start of the line.\n\t\t\t    // XXX\n\t\t\t    trypos = NULL;\n\t\t\t    if (find_last_paren(l, '(', ')'))\n\t\t\t\ttrypos = find_match_paren(\n\t\t\t\t\t\t      curbuf->b_ind_maxparen);\n\n\t\t\t    if (trypos == NULL && find_last_paren(l, '{', '}'))\n\t\t\t\ttrypos = find_start_brace();\n\n\t\t\t    if (trypos != NULL)\n\t\t\t    {\n\t\t\t\tcurwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// it's a variable declaration, add indentation\n\t\t\t// like in\n\t\t\t// int a,\n\t\t\t//    b;\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t    }\n\t\t    else if (lookfor == LOOKFOR_UNTERM)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (lookfor != LOOKFOR_TERM\n\t\t\t\t\t&& lookfor != LOOKFOR_CPP_BASECLASS\n\t\t\t\t\t&& lookfor != LOOKFOR_COMMA)\n\t\t\t{\n\t\t\t    amount = scope_amount;\n\t\t\t    if (theline[0] == '{')\n\t\t\t    {\n\t\t\t\tamount += curbuf->b_ind_open_extra;\n\t\t\t\tadded_to_amount = curbuf->b_ind_open_extra;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (lookfor_cpp_namespace)\n\t\t\t{\n\t\t\t    // Looking for C++ namespace, need to look further\n\t\t\t    // back.\n\t\t\t    if (curwin->w_cursor.lnum == ourscope)\n\t\t\t\tcontinue;\n\n\t\t\t    if (curwin->w_cursor.lnum == 0\n\t\t\t\t    || curwin->w_cursor.lnum\n\t\t\t\t\t      < ourscope - FIND_NAMESPACE_LIM)\n\t\t\t\tbreak;\n\n\t\t\t    l = ml_get_curline();\n\n\t\t\t    // If we're in a comment or raw string now, skip\n\t\t\t    // to the start of it.\n\t\t\t    trypos = ind_find_start_CORS(NULL);\n\t\t\t    if (trypos != NULL)\n\t\t\t    {\n\t\t\t\tcurwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\t    // Skip preprocessor directives and blank lines.\n\t\t\t    if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t    &amount))\n\t\t\t\tcontinue;\n\n\t\t\t    // Finally the actual check for \"namespace\".\n\t\t\t    if (cin_is_cpp_namespace(l))\n\t\t\t    {\n\t\t\t\tamount += curbuf->b_ind_cpp_namespace\n\t\t\t\t\t\t\t    - added_to_amount;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else if (cin_is_cpp_extern_c(l))\n\t\t\t    {\n\t\t\t\tamount += curbuf->b_ind_cpp_extern_c\n\t\t\t\t\t\t\t    - added_to_amount;\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\t    if (cin_nocode(l))\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t\t// If we're in a comment or raw string now, skip to the start\n\t\t// of it.  XXX\n\t\tif ((trypos = ind_find_start_CORS(&raw_string_start)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    continue;\n\t\t}\n\n\t\tl = ml_get_curline();\n\n\t\t// If this is a switch() label, may line up relative to that.\n\t\t// If this is a C++ scope declaration, do the same.\n\t\tiscase = cin_iscase(l, FALSE);\n\t\tif (iscase || cin_isscopedecl(l))\n\t\t{\n\t\t    // we are only looking for cpp base class\n\t\t    // declaration/initialization any longer\n\t\t    if (lookfor == LOOKFOR_CPP_BASECLASS)\n\t\t\tbreak;\n\n\t\t    // When looking for a \"do\" we are not interested in\n\t\t    // labels.\n\t\t    if (whilelevel > 0)\n\t\t\tcontinue;\n\n\t\t    //\tcase xx:\n\t\t    //\t    c = 99 +\t    <- this indent plus continuation\n\t\t    //->\t   here;\n\t\t    if (lookfor == LOOKFOR_UNTERM\n\t\t\t\t\t   || lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    //\tcase xx:\t<- line up with this case\n\t\t    //\t    x = 333;\n\t\t    //\tcase yy:\n\t\t    if (       (iscase && lookfor == LOOKFOR_CASE)\n\t\t\t    || (iscase && lookfor_break)\n\t\t\t    || (!iscase && lookfor == LOOKFOR_SCOPEDECL))\n\t\t    {\n\t\t\t// Check that this case label is not for another\n\t\t\t// switch()\t\t    XXX\n\t\t\tif ((trypos = find_start_brace()) == NULL\n\t\t\t\t\t\t  || trypos->lnum == ourscope)\n\t\t\t{\n\t\t\t    amount = get_indent();\t// XXX\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    n = get_indent_nolabel(curwin->w_cursor.lnum);  // XXX\n\n\t\t    //\t case xx: if (cond)\t    <- line up with this if\n\t\t    //\t\t      y = y + 1;\n\t\t    // ->\t  s = 99;\n\t\t    //\n\t\t    //\t case xx:\n\t\t    //\t     if (cond)\t\t<- line up with this line\n\t\t    //\t\t y = y + 1;\n\t\t    // ->    s = 99;\n\t\t    if (lookfor == LOOKFOR_TERM)\n\t\t    {\n\t\t\tif (n)\n\t\t\t    amount = n;\n\n\t\t\tif (!lookfor_break)\n\t\t\t    break;\n\t\t    }\n\n\t\t    //\t case xx: x = x + 1;\t    <- line up with this x\n\t\t    // ->\t  y = y + 1;\n\t\t    //\n\t\t    //\t case xx: if (cond)\t    <- line up with this if\n\t\t    // ->\t       y = y + 1;\n\t\t    if (n)\n\t\t    {\n\t\t\tamount = n;\n\t\t\tl = after_label(ml_get_curline());\n\t\t\tif (l != NULL && cin_is_cinword(l))\n\t\t\t{\n\t\t\t    if (theline[0] == '{')\n\t\t\t\tamount += curbuf->b_ind_open_extra;\n\t\t\t    else\n\t\t\t\tamount += curbuf->b_ind_level\n\t\t\t\t\t\t     + curbuf->b_ind_no_brace;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\n\t\t    // Try to get the indent of a statement before the switch\n\t\t    // label.  If nothing is found, line up relative to the\n\t\t    // switch label.\n\t\t    //\t    break;\t\t<- may line up with this line\n\t\t    //\t case xx:\n\t\t    // ->   y = 1;\n\t\t    scope_amount = get_indent() + (iscase    // XXX\n\t\t\t\t\t? curbuf->b_ind_case_code\n\t\t\t\t\t: curbuf->b_ind_scopedecl_code);\n\t\t    lookfor = curbuf->b_ind_case_break\n\t\t\t\t\t      ? LOOKFOR_NOBREAK : LOOKFOR_ANY;\n\t\t    continue;\n\t\t}\n\n\t\t// Looking for a switch() label or C++ scope declaration,\n\t\t// ignore other lines, skip {}-blocks.\n\t\tif (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)\n\t\t{\n\t\t    if (find_last_paren(l, '{', '}')\n\t\t\t\t     && (trypos = find_start_brace()) != NULL)\n\t\t    {\n\t\t\tcurwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    }\n\t\t    continue;\n\t\t}\n\n\t\t// Ignore jump labels with nothing after them.\n\t\tif (!curbuf->b_ind_js && cin_islabel())\n\t\t{\n\t\t    l = after_label(ml_get_curline());\n\t\t    if (l == NULL || cin_nocode(l))\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore #defines, #if, etc.\n\t\t// Ignore comment and empty lines.\n\t\t// (need to get the line again, cin_islabel() may have\n\t\t// unlocked it)\n\t\tl = ml_get_curline();\n\t\tif (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount)\n\t\t\t\t\t\t\t     || cin_nocode(l))\n\t\t    continue;\n\n\t\t// Are we at the start of a cpp base class declaration or\n\t\t// constructor initialization?  XXX\n\t\tn = FALSE;\n\t\tif (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0)\n\t\t{\n\t\t    n = cin_is_cpp_baseclass(&cache_cpp_baseclass);\n\t\t    l = ml_get_curline();\n\t\t}\n\t\tif (n)\n\t\t{\n\t\t    if (lookfor == LOOKFOR_UNTERM)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t    }\n\t\t    else if (theline[0] == '{')\n\t\t    {\n\t\t\t// Need to find start of the declaration.\n\t\t\tlookfor = LOOKFOR_UNTERM;\n\t\t\tind_continuation = 0;\n\t\t\tcontinue;\n\t\t    }\n\t\t    else\n\t\t\t// XXX\n\t\t\tamount = get_baseclass_amount(\n\t\t\t\t\t\tcache_cpp_baseclass.lpos.col);\n\t\t    break;\n\t\t}\n\t\telse if (lookfor == LOOKFOR_CPP_BASECLASS)\n\t\t{\n\t\t    // only look, whether there is a cpp base class\n\t\t    // declaration or initialization before the opening brace.\n\t\t    if (cin_isterminated(l, TRUE, FALSE))\n\t\t\tbreak;\n\t\t    else\n\t\t\tcontinue;\n\t\t}\n\n\t\t// What happens next depends on the line being terminated.\n\t\t// If terminated with a ',' only consider it terminating if\n\t\t// there is another unterminated statement behind, eg:\n\t\t//   123,\n\t\t//   sizeof\n\t\t//\t  here\n\t\t// Otherwise check whether it is an enumeration or structure\n\t\t// initialisation (not indented) or a variable declaration\n\t\t// (indented).\n\t\tterminated = cin_isterminated(l, FALSE, TRUE);\n\n\t\tif (js_cur_has_key)\n\t\t{\n\t\t    js_cur_has_key = 0; // only check the first line\n\t\t    if (curbuf->b_ind_js && terminated == ',')\n\t\t    {\n\t\t\t// For Javascript we might be inside an object:\n\t\t\t//   key: something,  <- align with this\n\t\t\t//   key: something\n\t\t\t// or:\n\t\t\t//   key: something +  <- align with this\n\t\t\t//       something,\n\t\t\t//   key: something\n\t\t\tlookfor = LOOKFOR_JS_KEY;\n\t\t    }\n\t\t}\n\t\tif (lookfor == LOOKFOR_JS_KEY && cin_has_js_key(l))\n\t\t{\n\t\t    amount = get_indent();\n\t\t    break;\n\t\t}\n\t\tif (lookfor == LOOKFOR_COMMA)\n\t\t{\n\t\t    if (tryposBrace != NULL && tryposBrace->lnum\n\t\t\t\t\t\t    >= curwin->w_cursor.lnum)\n\t\t\tbreak;\n\t\t    if (terminated == ',')\n\t\t\t// line below current line is the one that starts a\n\t\t\t// (possibly broken) line ending in a comma.\n\t\t\tbreak;\n\t\t    else\n\t\t    {\n\t\t\tamount = get_indent();\n\t\t\tif (curwin->w_cursor.lnum - 1 == ourscope)\n\t\t\t    // line above is start of the scope, thus current\n\t\t\t    // line is the one that stars a (possibly broken)\n\t\t\t    // line ending in a comma.\n\t\t\t    break;\n\t\t    }\n\t\t}\n\n\t\tif (terminated == 0 || (lookfor != LOOKFOR_UNTERM\n\t\t\t\t\t\t\t&& terminated == ','))\n\t\t{\n\t\t    if (lookfor != LOOKFOR_ENUM_OR_INIT &&\n\t\t\t    (*skipwhite(l) == '[' || l[STRLEN(l) - 1] == '['))\n\t\t\tamount += ind_continuation;\n\t\t    // if we're in the middle of a paren thing,\n\t\t    // go back to the line that starts it so\n\t\t    // we can get the right prevailing indent\n\t\t    //\t   if ( foo &&\n\t\t    //\t\t    bar )\n\n\t\t    // Position the cursor over the rightmost paren, so that\n\t\t    // matching it will take us back to the start of the line.\n\t\t    // Ignore a match before the start of the block.\n\t\t    (void)find_last_paren(l, '(', ')');\n\t\t    trypos = find_match_paren(corr_ind_maxparen(&cur_curpos));\n\t\t    if (trypos != NULL && (trypos->lnum < tryposBrace->lnum\n\t\t\t\t|| (trypos->lnum == tryposBrace->lnum\n\t\t\t\t    && trypos->col < tryposBrace->col)))\n\t\t\ttrypos = NULL;\n\n\t\t    // If we are looking for ',', we also look for matching\n\t\t    // braces.\n\t\t    if (trypos == NULL && terminated == ','\n\t\t\t\t\t      && find_last_paren(l, '{', '}'))\n\t\t\ttrypos = find_start_brace();\n\n\t\t    if (trypos != NULL)\n\t\t    {\n\t\t\t// Check if we are on a case label now.  This is\n\t\t\t// handled above.\n\t\t\t//     case xx:  if ( asdf &&\n\t\t\t//\t\t\tasdf)\n\t\t\tcurwin->w_cursor = *trypos;\n\t\t\tl = ml_get_curline();\n\t\t\tif (cin_iscase(l, FALSE) || cin_isscopedecl(l))\n\t\t\t{\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    curwin->w_cursor.col = 0;\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\n\t\t    // Skip over continuation lines to find the one to get the\n\t\t    // indent from\n\t\t    // char *usethis = \"bla{backslash}\n\t\t    //\t\t bla\",\n\t\t    //      here;\n\t\t    if (terminated == ',')\n\t\t    {\n\t\t\twhile (curwin->w_cursor.lnum > 1)\n\t\t\t{\n\t\t\t    l = ml_get(curwin->w_cursor.lnum - 1);\n\t\t\t    if (*l == NUL || l[STRLEN(l) - 1] != '\\\\')\n\t\t\t\tbreak;\n\t\t\t    --curwin->w_cursor.lnum;\n\t\t\t    curwin->w_cursor.col = 0;\n\t\t\t}\n\t\t    }\n\n\t\t    // Get indent and pointer to text for current line,\n\t\t    // ignoring any jump label.  XXX\n\t\t    if (curbuf->b_ind_js)\n\t\t\tcur_amount = get_indent();\n\t\t    else\n\t\t\tcur_amount = skip_label(curwin->w_cursor.lnum, &l);\n\t\t    // If this is just above the line we are indenting, and it\n\t\t    // starts with a '{', line it up with this line.\n\t\t    //\t\twhile (not)\n\t\t    // ->\t{\n\t\t    //\t\t}\n\t\t    if (terminated != ',' && lookfor != LOOKFOR_TERM\n\t\t\t\t\t\t\t && theline[0] == '{')\n\t\t    {\n\t\t\tamount = cur_amount;\n\t\t\t// Only add b_ind_open_extra when the current line\n\t\t\t// doesn't start with a '{', which must have a match\n\t\t\t// in the same line (scope is the same).  Probably:\n\t\t\t//\t{ 1, 2 },\n\t\t\t// ->\t{ 3, 4 }\n\t\t\tif (*skipwhite(l) != '{')\n\t\t\t    amount += curbuf->b_ind_open_extra;\n\n\t\t\tif (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js)\n\t\t\t{\n\t\t\t    // have to look back, whether it is a cpp base\n\t\t\t    // class declaration or initialization\n\t\t\t    lookfor = LOOKFOR_CPP_BASECLASS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\n\t\t    // Check if we are after an \"if\", \"while\", etc.\n\t\t    // Also allow \"   } else\".\n\t\t    if (cin_is_cinword(l) || cin_iselse(skipwhite(l)))\n\t\t    {\n\t\t\t// Found an unterminated line after an if (), line up\n\t\t\t// with the last one.\n\t\t\t//   if (cond)\n\t\t\t//\t    100 +\n\t\t\t// ->\t\there;\n\t\t\tif (lookfor == LOOKFOR_UNTERM\n\t\t\t\t\t   || lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t\t{\n\t\t\t    if (cont_amount > 0)\n\t\t\t\tamount = cont_amount;\n\t\t\t    else\n\t\t\t\tamount += ind_continuation;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t// If this is just above the line we are indenting, we\n\t\t\t// are finished.\n\t\t\t//\t    while (not)\n\t\t\t// ->\t\there;\n\t\t\t// Otherwise this indent can be used when the line\n\t\t\t// before this is terminated.\n\t\t\t//\tyyy;\n\t\t\t//\tif (stat)\n\t\t\t//\t    while (not)\n\t\t\t//\t\txxx;\n\t\t\t// ->\there;\n\t\t\tamount = cur_amount;\n\t\t\tif (theline[0] == '{')\n\t\t\t    amount += curbuf->b_ind_open_extra;\n\t\t\tif (lookfor != LOOKFOR_TERM)\n\t\t\t{\n\t\t\t    amount += curbuf->b_ind_level\n\t\t\t\t\t\t     + curbuf->b_ind_no_brace;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t// Special trick: when expecting the while () after a\n\t\t\t// do, line up with the while()\n\t\t\t//     do\n\t\t\t//\t    x = 1;\n\t\t\t// ->  here\n\t\t\tl = skipwhite(ml_get_curline());\n\t\t\tif (cin_isdo(l))\n\t\t\t{\n\t\t\t    if (whilelevel == 0)\n\t\t\t\tbreak;\n\t\t\t    --whilelevel;\n\t\t\t}\n\n\t\t\t// When searching for a terminated line, don't use the\n\t\t\t// one between the \"if\" and the matching \"else\".\n\t\t\t// Need to use the scope of this \"else\".  XXX\n\t\t\t// If whilelevel != 0 continue looking for a \"do {\".\n\t\t\tif (cin_iselse(l) && whilelevel == 0)\n\t\t\t{\n\t\t\t    // If we're looking at \"} else\", let's make sure we\n\t\t\t    // find the opening brace of the enclosing scope,\n\t\t\t    // not the one from \"if () {\".\n\t\t\t    if (*l == '}')\n\t\t\t\tcurwin->w_cursor.col =\n\t\t\t\t\t  (colnr_T)(l - ml_get_curline()) + 1;\n\n\t\t\t    if ((trypos = find_start_brace()) == NULL\n\t\t\t\t       || find_match(LOOKFOR_IF, trypos->lnum)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\n\t\t    // If we're below an unterminated line that is not an\n\t\t    // \"if\" or something, we may line up with this line or\n\t\t    // add something for a continuation line, depending on\n\t\t    // the line before this one.\n\t\t    else\n\t\t    {\n\t\t\t// Found two unterminated lines on a row, line up with\n\t\t\t// the last one.\n\t\t\t//   c = 99 +\n\t\t\t//\t    100 +\n\t\t\t// ->\t    here;\n\t\t\tif (lookfor == LOOKFOR_UNTERM)\n\t\t\t{\n\t\t\t    // When line ends in a comma add extra indent\n\t\t\t    if (terminated == ',')\n\t\t\t\tamount += ind_continuation;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\tif (lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t\t{\n\t\t\t    // Found two lines ending in ',', lineup with the\n\t\t\t    // lowest one, but check for cpp base class\n\t\t\t    // declaration/initialization, if it is an\n\t\t\t    // opening brace or we are looking just for\n\t\t\t    // enumerations/initializations.\n\t\t\t    if (terminated == ',')\n\t\t\t    {\n\t\t\t\tif (curbuf->b_ind_cpp_baseclass == 0)\n\t\t\t\t    break;\n\n\t\t\t\tlookfor = LOOKFOR_CPP_BASECLASS;\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\t    // Ignore unterminated lines in between, but\n\t\t\t    // reduce indent.\n\t\t\t    if (amount > cur_amount)\n\t\t\t\tamount = cur_amount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Found first unterminated line on a row, may\n\t\t\t    // line up with this line, remember its indent\n\t\t\t    //\t    100 +\n\t\t\t    // ->\t    here;\n\t\t\t    l = ml_get_curline();\n\t\t\t    amount = cur_amount;\n\n\t\t\t    n = (int)STRLEN(l);\n\t\t\t    if (terminated == ',' && (*skipwhite(l) == ']'\n\t\t\t\t\t|| (n >=2 && l[n - 2] == ']')))\n\t\t\t\tbreak;\n\n\t\t\t    // If previous line ends in ',', check whether we\n\t\t\t    // are in an initialization or enum\n\t\t\t    // struct xxx =\n\t\t\t    // {\n\t\t\t    //      sizeof a,\n\t\t\t    //      124 };\n\t\t\t    // or a normal possible continuation line.\n\t\t\t    // but only, of no other statement has been found\n\t\t\t    // yet.\n\t\t\t    if (lookfor == LOOKFOR_INITIAL && terminated == ',')\n\t\t\t    {\n\t\t\t\tif (curbuf->b_ind_js)\n\t\t\t\t{\n\t\t\t\t    // Search for a line ending in a comma\n\t\t\t\t    // and line up with the line below it\n\t\t\t\t    // (could be the current line).\n\t\t\t\t    // some = [\n\t\t\t\t    //     1,     <- line up here\n\t\t\t\t    //     2,\n\t\t\t\t    // some = [\n\t\t\t\t    //     3 +    <- line up here\n\t\t\t\t    //       4 *\n\t\t\t\t    //        5,\n\t\t\t\t    //     6,\n\t\t\t\t    if (cin_iscomment(skipwhite(l)))\n\t\t\t\t\tbreak;\n\t\t\t\t    lookfor = LOOKFOR_COMMA;\n\t\t\t\t    trypos = find_match_char('[',\n\t\t\t\t\t\t      curbuf->b_ind_maxparen);\n\t\t\t\t    if (trypos != NULL)\n\t\t\t\t    {\n\t\t\t\t\tif (trypos->lnum\n\t\t\t\t\t\t == curwin->w_cursor.lnum - 1)\n\t\t\t\t\t{\n\t\t\t\t\t    // Current line is first inside\n\t\t\t\t\t    // [], line up with it.\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\tourscope = trypos->lnum;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    lookfor = LOOKFOR_ENUM_OR_INIT;\n\t\t\t\t    cont_amount = cin_first_id_amount();\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (lookfor == LOOKFOR_INITIAL\n\t\t\t\t\t&& *l != NUL\n\t\t\t\t\t&& l[STRLEN(l) - 1] == '\\\\')\n\t\t\t\t\t\t\t\t// XXX\n\t\t\t\t    cont_amount = cin_get_equal_amount(\n\t\t\t\t\t\t       curwin->w_cursor.lnum);\n\t\t\t\tif (lookfor != LOOKFOR_TERM\n\t\t\t\t\t\t&& lookfor != LOOKFOR_JS_KEY\n\t\t\t\t\t\t&& lookfor != LOOKFOR_COMMA\n\t\t\t\t\t\t&& raw_string_start != curwin->w_cursor.lnum)\n\t\t\t\t    lookfor = LOOKFOR_UNTERM;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t// Check if we are after a while (cond);\n\t\t// If so: Ignore until the matching \"do\".\n\t\telse if (cin_iswhileofdo_end(terminated)) // XXX\n\t\t{\n\t\t    // Found an unterminated line after a while ();, line up\n\t\t    // with the last one.\n\t\t    //\t    while (cond);\n\t\t    //\t    100 +\t\t<- line up with this one\n\t\t    // ->\t    here;\n\t\t    if (lookfor == LOOKFOR_UNTERM\n\t\t\t\t\t   || lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    if (whilelevel == 0)\n\t\t    {\n\t\t\tlookfor = LOOKFOR_TERM;\n\t\t\tamount = get_indent();\t    // XXX\n\t\t\tif (theline[0] == '{')\n\t\t\t    amount += curbuf->b_ind_open_extra;\n\t\t    }\n\t\t    ++whilelevel;\n\t\t}\n\n\t\t// We are after a \"normal\" statement.\n\t\t// If we had another statement we can stop now and use the\n\t\t// indent of that other statement.\n\t\t// Otherwise the indent of the current statement may be used,\n\t\t// search backwards for the next \"normal\" statement.\n\t\telse\n\t\t{\n\t\t    // Skip single break line, if before a switch label. It\n\t\t    // may be lined up with the case label.\n\t\t    if (lookfor == LOOKFOR_NOBREAK\n\t\t\t\t  && cin_isbreak(skipwhite(ml_get_curline())))\n\t\t    {\n\t\t\tlookfor = LOOKFOR_ANY;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    // Handle \"do {\" line.\n\t\t    if (whilelevel > 0)\n\t\t    {\n\t\t\tl = cin_skipcomment(ml_get_curline());\n\t\t\tif (cin_isdo(l))\n\t\t\t{\n\t\t\t    amount = get_indent();\t// XXX\n\t\t\t    --whilelevel;\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\n\t\t    // Found a terminated line above an unterminated line. Add\n\t\t    // the amount for a continuation line.\n\t\t    //\t x = 1;\n\t\t    //\t y = foo +\n\t\t    // ->\there;\n\t\t    // or\n\t\t    //\t int x = 1;\n\t\t    //\t int foo,\n\t\t    // ->\there;\n\t\t    if (lookfor == LOOKFOR_UNTERM\n\t\t\t\t\t   || lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    // Found a terminated line above a terminated line or \"if\"\n\t\t    // etc. line. Use the amount of the line below us.\n\t\t    //\t x = 1;\t\t\t\tx = 1;\n\t\t    //\t if (asdf)\t\t    y = 2;\n\t\t    //\t     while (asdf)\t  ->here;\n\t\t    //\t\there;\n\t\t    // ->foo;\n\t\t    if (lookfor == LOOKFOR_TERM)\n\t\t    {\n\t\t\tif (!lookfor_break && whilelevel == 0)\n\t\t\t    break;\n\t\t    }\n\n\t\t    // First line above the one we're indenting is terminated.\n\t\t    // To know what needs to be done look further backward for\n\t\t    // a terminated line.\n\t\t    else\n\t\t    {\n\t\t\t// position the cursor over the rightmost paren, so\n\t\t\t// that matching it will take us back to the start of\n\t\t\t// the line.  Helps for:\n\t\t\t//     func(asdr,\n\t\t\t//\t      asdfasdf);\n\t\t\t//     here;\nterm_again:\n\t\t\tl = ml_get_curline();\n\t\t\tif (find_last_paren(l, '(', ')')\n\t\t\t\t&& (trypos = find_match_paren(\n\t\t\t\t\t   curbuf->b_ind_maxparen)) != NULL)\n\t\t\t{\n\t\t\t    // Check if we are on a case label now.  This is\n\t\t\t    // handled above.\n\t\t\t    //\t   case xx:  if ( asdf &&\n\t\t\t    //\t\t\t    asdf)\n\t\t\t    curwin->w_cursor = *trypos;\n\t\t\t    l = ml_get_curline();\n\t\t\t    if (cin_iscase(l, FALSE) || cin_isscopedecl(l))\n\t\t\t    {\n\t\t\t\t++curwin->w_cursor.lnum;\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// When aligning with the case statement, don't align\n\t\t\t// with a statement after it.\n\t\t\t//  case 1: {   <-- don't use this { position\n\t\t\t//\tstat;\n\t\t\t//  }\n\t\t\t//  case 2:\n\t\t\t//\tstat;\n\t\t\t// }\n\t\t\tiscase = (curbuf->b_ind_keep_case_label\n\t\t\t\t\t\t     && cin_iscase(l, FALSE));\n\n\t\t\t// Get indent and pointer to text for current line,\n\t\t\t// ignoring any jump label.\n\t\t\tamount = skip_label(curwin->w_cursor.lnum, &l);\n\n\t\t\tif (theline[0] == '{')\n\t\t\t    amount += curbuf->b_ind_open_extra;\n\t\t\t// See remark above: \"Only add b_ind_open_extra..\"\n\t\t\tl = skipwhite(l);\n\t\t\tif (*l == '{')\n\t\t\t    amount -= curbuf->b_ind_open_extra;\n\t\t\tlookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;\n\n\t\t\t// When a terminated line starts with \"else\" skip to\n\t\t\t// the matching \"if\":\n\t\t\t//       else 3;\n\t\t\t//\t     indent this;\n\t\t\t// Need to use the scope of this \"else\".  XXX\n\t\t\t// If whilelevel != 0 continue looking for a \"do {\".\n\t\t\tif (lookfor == LOOKFOR_TERM\n\t\t\t\t&& *l != '}'\n\t\t\t\t&& cin_iselse(l)\n\t\t\t\t&& whilelevel == 0)\n\t\t\t{\n\t\t\t    if ((trypos = find_start_brace()) == NULL\n\t\t\t\t       || find_match(LOOKFOR_IF, trypos->lnum)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t\tbreak;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// If we're at the end of a block, skip to the start of\n\t\t\t// that block.\n\t\t\tl = ml_get_curline();\n\t\t\tif (find_last_paren(l, '{', '}') // XXX\n\t\t\t\t     && (trypos = find_start_brace()) != NULL)\n\t\t\t{\n\t\t\t    curwin->w_cursor = *trypos;\n\t\t\t    // if not \"else {\" check for terminated again\n\t\t\t    // but skip block for \"} else {\"\n\t\t\t    l = cin_skipcomment(ml_get_curline());\n\t\t\t    if (*l == '}' || !cin_iselse(l))\n\t\t\t\tgoto term_again;\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    curwin->w_cursor.col = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n      }\n\n      // add extra indent for a comment\n      if (cin_iscomment(theline))\n\t  amount += curbuf->b_ind_comment;\n\n      // subtract extra left-shift for jump labels\n      if (curbuf->b_ind_jump_label > 0 && original_line_islabel)\n\t  amount -= curbuf->b_ind_jump_label;\n\n      goto theend;\n    }\n\n    // ok -- we're not inside any sort of structure at all!\n    //\n    // This means we're at the top level, and everything should\n    // basically just match where the previous line is, except\n    // for the lines immediately following a function declaration,\n    // which are K&R-style parameters and need to be indented.\n    //\n    // if our line starts with an open brace, forget about any\n    // prevailing indent and make sure it looks like the start\n    // of a function\n\n    if (theline[0] == '{')\n    {\n\tamount = curbuf->b_ind_first_open;\n\tgoto theend;\n    }\n\n    // If the NEXT line is a function declaration, the current\n    // line needs to be indented as a function type spec.\n    // Don't do this if the current line looks like a comment or if the\n    // current line is terminated, ie. ends in ';', or if the current line\n    // contains { or }: \"void f() {\\n if (1)\"\n    if (cur_curpos.lnum < curbuf->b_ml.ml_line_count\n\t    && !cin_nocode(theline)\n\t    && vim_strchr(theline, '{') == NULL\n\t    && vim_strchr(theline, '}') == NULL\n\t    && !cin_ends_in(theline, (char_u *)\":\", NULL)\n\t    && !cin_ends_in(theline, (char_u *)\",\", NULL)\n\t    && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,\n\t\t\t      cur_curpos.lnum + 1)\n\t    && !cin_isterminated(theline, FALSE, TRUE))\n    {\n\tamount = curbuf->b_ind_func_type;\n\tgoto theend;\n    }\n\n    // search backwards until we find something we recognize\n    amount = 0;\n    curwin->w_cursor = cur_curpos;\n    while (curwin->w_cursor.lnum > 1)\n    {\n\tcurwin->w_cursor.lnum--;\n\tcurwin->w_cursor.col = 0;\n\n\tl = ml_get_curline();\n\n\t// If we're in a comment or raw string now, skip to the start\n\t// of it.  XXX\n\tif ((trypos = ind_find_start_CORS(NULL)) != NULL)\n\t{\n\t    curwin->w_cursor.lnum = trypos->lnum + 1;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\n\t// Are we at the start of a cpp base class declaration or\n\t// constructor initialization?  XXX\n\tn = FALSE;\n\tif (curbuf->b_ind_cpp_baseclass != 0 && theline[0] != '{')\n\t{\n\t    n = cin_is_cpp_baseclass(&cache_cpp_baseclass);\n\t    l = ml_get_curline();\n\t}\n\tif (n)\n\t{\n\t\t\t\t\t\t\t     // XXX\n\t    amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);\n\t    break;\n\t}\n\n\t// Skip preprocessor directives and blank lines.\n\tif (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount))\n\t    continue;\n\n\tif (cin_nocode(l))\n\t    continue;\n\n\t// If the previous line ends in ',', use one level of\n\t// indentation:\n\t// int foo,\n\t//     bar;\n\t// do this before checking for '}' in case of eg.\n\t// enum foobar\n\t// {\n\t//   ...\n\t// } foo,\n\t//   bar;\n\tn = 0;\n\tif (cin_ends_in(l, (char_u *)\",\", NULL)\n\t\t     || (*l != NUL && (n = l[STRLEN(l) - 1]) == '\\\\'))\n\t{\n\t    // take us back to opening paren\n\t    if (find_last_paren(l, '(', ')')\n\t\t    && (trypos = find_match_paren(\n\t\t\t\t     curbuf->b_ind_maxparen)) != NULL)\n\t\tcurwin->w_cursor = *trypos;\n\n\t    // For a line ending in ',' that is a continuation line go\n\t    // back to the first line with a backslash:\n\t    // char *foo = \"bla{backslash}\n\t    //\t\t bla\",\n\t    //      here;\n\t    while (n == 0 && curwin->w_cursor.lnum > 1)\n\t    {\n\t\tl = ml_get(curwin->w_cursor.lnum - 1);\n\t\tif (*l == NUL || l[STRLEN(l) - 1] != '\\\\')\n\t\t    break;\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t    }\n\n\t    amount = get_indent();\t    // XXX\n\n\t    if (amount == 0)\n\t\tamount = cin_first_id_amount();\n\t    if (amount == 0)\n\t\tamount = ind_continuation;\n\t    break;\n\t}\n\n\t// If the line looks like a function declaration, and we're\n\t// not in a comment, put it the left margin.\n\tif (cin_isfuncdecl(NULL, cur_curpos.lnum, 0))  // XXX\n\t    break;\n\tl = ml_get_curline();\n\n\t// Finding the closing '}' of a previous function.  Put\n\t// current line at the left margin.  For when 'cino' has \"fs\".\n\tif (*skipwhite(l) == '}')\n\t    break;\n\n\t//\t\t\t    (matching {)\n\t// If the previous line ends on '};' (maybe followed by\n\t// comments) align at column 0.  For example:\n\t// char *string_array[] = { \"foo\",\n\t//     / * x * / \"b};ar\" }; / * foobar * /\n\tif (cin_ends_in(l, (char_u *)\"};\", NULL))\n\t    break;\n\n\t// If the previous line ends on '[' we are probably in an\n\t// array constant:\n\t// something = [\n\t//     234,  <- extra indent\n\tif (cin_ends_in(l, (char_u *)\"[\", NULL))\n\t{\n\t    amount = get_indent() + ind_continuation;\n\t    break;\n\t}\n\n\t// Find a line only has a semicolon that belongs to a previous\n\t// line ending in '}', e.g. before an #endif.  Don't increase\n\t// indent then.\n\tif (*(look = skipwhite(l)) == ';' && cin_nocode(look + 1))\n\t{\n\t    pos_T curpos_save = curwin->w_cursor;\n\n\t    while (curwin->w_cursor.lnum > 1)\n\t    {\n\t\tlook = ml_get(--curwin->w_cursor.lnum);\n\t\tif (!(cin_nocode(look) || cin_ispreproc_cont(\n\t\t\t\t      &look, &curwin->w_cursor.lnum, &amount)))\n\t\t    break;\n\t    }\n\t    if (curwin->w_cursor.lnum > 0\n\t\t\t    && cin_ends_in(look, (char_u *)\"}\", NULL))\n\t\tbreak;\n\n\t    curwin->w_cursor = curpos_save;\n\t}\n\n\t// If the PREVIOUS line is a function declaration, the current\n\t// line (and the ones that follow) needs to be indented as\n\t// parameters.\n\tif (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))\n\t{\n\t    amount = curbuf->b_ind_param;\n\t    break;\n\t}\n\n\t// If the previous line ends in ';' and the line before the\n\t// previous line ends in ',' or '\\', ident to column zero:\n\t// int foo,\n\t//     bar;\n\t// indent_to_0 here;\n\tif (cin_ends_in(l, (char_u *)\";\", NULL))\n\t{\n\t    l = ml_get(curwin->w_cursor.lnum - 1);\n\t    if (cin_ends_in(l, (char_u *)\",\", NULL)\n\t\t    || (*l != NUL && l[STRLEN(l) - 1] == '\\\\'))\n\t\tbreak;\n\t    l = ml_get_curline();\n\t}\n\n\t// Doesn't look like anything interesting -- so just\n\t// use the indent of this line.\n\t//\n\t// Position the cursor over the rightmost paren, so that\n\t// matching it will take us back to the start of the line.\n\tfind_last_paren(l, '(', ')');\n\n\tif ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)\n\t    curwin->w_cursor = *trypos;\n\tamount = get_indent();\t    // XXX\n\tbreak;\n    }\n\n    // add extra indent for a comment\n    if (cin_iscomment(theline))\n\tamount += curbuf->b_ind_comment;\n\n    // add extra indent if the previous line ended in a backslash:\n    //\t      \"asdfasdf{backslash}\n    //\t\t  here\";\n    //\t    char *foo = \"asdf{backslash}\n    //\t\t\t here\";\n    if (cur_curpos.lnum > 1)\n    {\n\tl = ml_get(cur_curpos.lnum - 1);\n\tif (*l != NUL && l[STRLEN(l) - 1] == '\\\\')\n\t{\n\t    cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);\n\t    if (cur_amount > 0)\n\t\tamount = cur_amount;\n\t    else if (cur_amount == 0)\n\t\tamount += ind_continuation;\n\t}\n    }\n\ntheend:\n    if (amount < 0)\n\tamount = 0;\n\nlaterend:\n    // put the cursor back where it belongs\n    curwin->w_cursor = cur_curpos;\n\n    vim_free(linecopy);\n\n    return amount;\n}\n\n/*\n * return TRUE if 'cinkeys' contains the key \"keytyped\",\n * when == '*':\t    Only if key is preceded with '*'\t(indent before insert)\n * when == '!':\t    Only if key is preceded with '!'\t(don't insert)\n * when == ' ':\t    Only if key is not preceded with '*'(indent afterwards)\n *\n * \"keytyped\" can have a few special values:\n * KEY_OPEN_FORW\n * KEY_OPEN_BACK\n * KEY_COMPLETE\t    just finished completion.\n *\n * If line_is_empty is TRUE accept keys with '0' before them.\n */\n    int\nin_cinkeys(\n    int\t\tkeytyped,\n    int\t\twhen,\n    int\t\tline_is_empty)\n{\n    char_u\t*look;\n    int\t\ttry_match;\n    int\t\ttry_match_word;\n    char_u\t*p;\n    char_u\t*line;\n    int\t\ticase;\n    int\t\ti;\n\n    if (keytyped == NUL)\n\t// Can happen with CTRL-Y and CTRL-E on a short line.\n\treturn FALSE;\n\n#ifdef FEAT_EVAL\n    if (*curbuf->b_p_inde != NUL)\n\tlook = curbuf->b_p_indk;\t// 'indentexpr' set: use 'indentkeys'\n    else\n#endif\n\tlook = curbuf->b_p_cink;\t// 'indentexpr' empty: use 'cinkeys'\n    while (*look)\n    {\n\t// Find out if we want to try a match with this key, depending on\n\t// 'when' and a '*' or '!' before the key.\n\tswitch (when)\n\t{\n\t    case '*': try_match = (*look == '*'); break;\n\t    case '!': try_match = (*look == '!'); break;\n\t     default: try_match = (*look != '*'); break;\n\t}\n\tif (*look == '*' || *look == '!')\n\t    ++look;\n\n\t// If there is a '0', only accept a match if the line is empty.\n\t// But may still match when typing last char of a word.\n\tif (*look == '0')\n\t{\n\t    try_match_word = try_match;\n\t    if (!line_is_empty)\n\t\ttry_match = FALSE;\n\t    ++look;\n\t}\n\telse\n\t    try_match_word = FALSE;\n\n\t// does it look like a control character?\n\tif (*look == '^'\n#ifdef EBCDIC\n\t\t&& (Ctrl_chr(look[1]) != 0)\n#else\n\t\t&& look[1] >= '?' && look[1] <= '_'\n#endif\n\t\t)\n\t{\n\t    if (try_match && keytyped == Ctrl_chr(look[1]))\n\t\treturn TRUE;\n\t    look += 2;\n\t}\n\t// 'o' means \"o\" command, open forward.\n\t// 'O' means \"O\" command, open backward.\n\telse if (*look == 'o')\n\t{\n\t    if (try_match && keytyped == KEY_OPEN_FORW)\n\t\treturn TRUE;\n\t    ++look;\n\t}\n\telse if (*look == 'O')\n\t{\n\t    if (try_match && keytyped == KEY_OPEN_BACK)\n\t\treturn TRUE;\n\t    ++look;\n\t}\n\n\t// 'e' means to check for \"else\" at start of line and just before the\n\t// cursor.\n\telse if (*look == 'e')\n\t{\n\t    if (try_match && keytyped == 'e' && curwin->w_cursor.col >= 4)\n\t    {\n\t\tp = ml_get_curline();\n\t\tif (skipwhite(p) == p + curwin->w_cursor.col - 4 &&\n\t\t\tSTRNCMP(p + curwin->w_cursor.col - 4, \"else\", 4) == 0)\n\t\t    return TRUE;\n\t    }\n\t    ++look;\n\t}\n\n\t// ':' only causes an indent if it is at the end of a label or case\n\t// statement, or when it was before typing the ':' (to fix\n\t// class::method for C++).\n\telse if (*look == ':')\n\t{\n\t    if (try_match && keytyped == ':')\n\t    {\n\t\tp = ml_get_curline();\n\t\tif (cin_iscase(p, FALSE) || cin_isscopedecl(p) || cin_islabel())\n\t\t    return TRUE;\n\t\t// Need to get the line again after cin_islabel().\n\t\tp = ml_get_curline();\n\t\tif (curwin->w_cursor.col > 2\n\t\t\t&& p[curwin->w_cursor.col - 1] == ':'\n\t\t\t&& p[curwin->w_cursor.col - 2] == ':')\n\t\t{\n\t\t    p[curwin->w_cursor.col - 1] = ' ';\n\t\t    i = (cin_iscase(p, FALSE) || cin_isscopedecl(p)\n\t\t\t\t\t\t\t    || cin_islabel());\n\t\t    p = ml_get_curline();\n\t\t    p[curwin->w_cursor.col - 1] = ':';\n\t\t    if (i)\n\t\t\treturn TRUE;\n\t\t}\n\t    }\n\t    ++look;\n\t}\n\n\n\t// Is it a key in <>, maybe?\n\telse if (*look == '<')\n\t{\n\t    if (try_match)\n\t    {\n\t\t// make up some named keys <o>, <O>, <e>, <0>, <>>, <<>, <*>,\n\t\t// <:> and <!> so that people can re-indent on o, O, e, 0, <,\n\t\t// >, *, : and ! keys if they really really want to.\n\t\tif (vim_strchr((char_u *)\"<>!*oOe0:\", look[1]) != NULL\n\t\t\t\t\t\t       && keytyped == look[1])\n\t\t    return TRUE;\n\n\t\tif (keytyped == get_special_key_code(look + 1))\n\t\t    return TRUE;\n\t    }\n\t    while (*look && *look != '>')\n\t\tlook++;\n\t    while (*look == '>')\n\t\tlook++;\n\t}\n\n\t// Is it a word: \"=word\"?\n\telse if (*look == '=' && look[1] != ',' && look[1] != NUL)\n\t{\n\t    ++look;\n\t    if (*look == '~')\n\t    {\n\t\ticase = TRUE;\n\t\t++look;\n\t    }\n\t    else\n\t\ticase = FALSE;\n\t    p = vim_strchr(look, ',');\n\t    if (p == NULL)\n\t\tp = look + STRLEN(look);\n\t    if ((try_match || try_match_word)\n\t\t    && curwin->w_cursor.col >= (colnr_T)(p - look))\n\t    {\n\t\tint\t\tmatch = FALSE;\n\n\t\tif (keytyped == KEY_COMPLETE)\n\t\t{\n\t\t    char_u\t*s;\n\n\t\t    // Just completed a word, check if it starts with \"look\".\n\t\t    // search back for the start of a word.\n\t\t    line = ml_get_curline();\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tchar_u\t*n;\n\n\t\t\tfor (s = line + curwin->w_cursor.col; s > line; s = n)\n\t\t\t{\n\t\t\t    n = mb_prevptr(line, s);\n\t\t\t    if (!vim_iswordp(n))\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfor (s = line + curwin->w_cursor.col; s > line; --s)\n\t\t\t    if (!vim_iswordc(s[-1]))\n\t\t\t\tbreak;\n\t\t    if (s + (p - look) <= line + curwin->w_cursor.col\n\t\t\t    && (icase\n\t\t\t\t? MB_STRNICMP(s, look, p - look)\n\t\t\t\t: STRNCMP(s, look, p - look)) == 0)\n\t\t\tmatch = TRUE;\n\t\t}\n\t\telse\n\t\t    // TODO: multi-byte\n\t\t    if (keytyped == (int)p[-1] || (icase && keytyped < 256\n\t\t\t && TOLOWER_LOC(keytyped) == TOLOWER_LOC((int)p[-1])))\n\t\t{\n\t\t    line = ml_get_cursor();\n\t\t    if ((curwin->w_cursor.col == (colnr_T)(p - look)\n\t\t\t\t|| !vim_iswordc(line[-(p - look) - 1]))\n\t\t\t    && (icase\n\t\t\t\t? MB_STRNICMP(line - (p - look), look, p - look)\n\t\t\t\t: STRNCMP(line - (p - look), look, p - look))\n\t\t\t\t\t\t\t\t\t == 0)\n\t\t\tmatch = TRUE;\n\t\t}\n\t\tif (match && try_match_word && !try_match)\n\t\t{\n\t\t    // \"0=word\": Check if there are only blanks before the\n\t\t    // word.\n\t\t    if (getwhitecols_curline() !=\n\t\t\t\t     (int)(curwin->w_cursor.col - (p - look)))\n\t\t\tmatch = FALSE;\n\t\t}\n\t\tif (match)\n\t\t    return TRUE;\n\t    }\n\t    look = p;\n\t}\n\n\t// ok, it's a boring generic character.\n\telse\n\t{\n\t    if (try_match && *look == keytyped)\n\t\treturn TRUE;\n\t    if (*look != NUL)\n\t\t++look;\n\t}\n\n\t// Skip over \", \".\n\tlook = skip_to_option_part(look);\n    }\n    return FALSE;\n}\n\n/*\n * Do C or expression indenting on the current line.\n */\n    void\ndo_c_expr_indent(void)\n{\n# ifdef FEAT_EVAL\n    if (*curbuf->b_p_inde != NUL)\n\tfixthisline(get_expr_indent);\n    else\n# endif\n\tfixthisline(get_c_indent);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"cindent(lnum)\" function\n */\n    void\nf_cindent(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# ifdef FEAT_CINDENT\n    pos_T\tpos;\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = curwin->w_cursor;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tcurwin->w_cursor.lnum = lnum;\n\trettv->vval.v_number = get_c_indent();\n\tcurwin->w_cursor = pos;\n    }\n    else\n# endif\n\trettv->vval.v_number = -1;\n}\n#endif\n", "\" Test for cinoptions and cindent\n\nfunc Test_cino_hash()\n  \" Test that curbuf->b_ind_hash_comment is correctly reset\n  new\n  setlocal cindent cinoptions=#1\n  setlocal cinoptions=\n  call setline(1, [\"#include <iostream>\"])\n  call cursor(1, 1)\n  norm! o#include\n  \"call feedkeys(\"o#include\\<esc>\", 't')\n  call assert_equal([\"#include <iostream>\", \"#include\"], getline(1,2))\n  bwipe!\nendfunc\n\nfunc Test_cino_extern_c()\n  \" Test for cino-E\n\n  let without_ind =<< trim [CODE]\n    #ifdef __cplusplus\n    extern \"C\" {\n    #endif\n    int func_a(void);\n    #ifdef __cplusplus\n    }\n    #endif\n  [CODE]\n\n  let with_ind =<< trim [CODE]\n    #ifdef __cplusplus\n    extern \"C\" {\n    #endif\n    \tint func_a(void);\n    #ifdef __cplusplus\n    }\n    #endif\n  [CODE]\n  new\n  setlocal cindent cinoptions=E0\n  call setline(1, without_ind)\n  call feedkeys(\"gg=G\", 'tx')\n  call assert_equal(with_ind, getline(1, '$'))\n\n  setlocal cinoptions=E-s\n  call setline(1, with_ind)\n  call feedkeys(\"gg=G\", 'tx')\n  call assert_equal(without_ind, getline(1, '$'))\n\n  setlocal cinoptions=Es\n  let tests = [\n        \\ ['recognized', ['extern \"C\" {'], \"\\t\\t;\"],\n        \\ ['recognized', ['extern \"C++\" {'], \"\\t\\t;\"],\n        \\ ['recognized', ['extern /* com */ \"C\"{'], \"\\t\\t;\"],\n        \\ ['recognized', ['extern\"C\"{'], \"\\t\\t;\"],\n        \\ ['recognized', ['extern \"C\"', '{'], \"\\t\\t;\"],\n        \\ ['not recognized', ['extern {'], \"\\t;\"],\n        \\ ['not recognized', ['extern /*\"C\"*/{'], \"\\t;\"],\n        \\ ['not recognized', ['extern \"C\" //{'], \";\"],\n        \\ ['not recognized', ['extern \"C\" /*{*/'], \";\"],\n        \\ ]\n\n  for pair in tests\n    let lines = pair[1]\n    call setline(1, lines)\n    call feedkeys(len(lines) . \"Go;\", 'tx')\n    call assert_equal(pair[2], getline(len(lines) + 1), 'Failed for \"' . string(lines) . '\"')\n  endfor\n\n  bwipe!\nendfunc\n\nfunc Test_cindent_rawstring()\n  new\n  setl cindent\n  call feedkeys(\"i\" .\n          \\ \"int main() {\\<CR>\" .\n          \\ \"R\\\"(\\<CR>\" .\n          \\ \")\\\";\\<CR>\" .\n          \\ \"statement;\\<Esc>\", \"x\")\n  call assert_equal(\"\\tstatement;\", getline(line('.')))\n  bw!\nendfunc\n\nfunc Test_cindent_expr()\n  new\n  func! MyIndentFunction()\n    return v:lnum == 1 ? shiftwidth() : 0\n  endfunc\n  setl expandtab sw=8 indentkeys+=; indentexpr=MyIndentFunction()\n  let testinput =<< trim [CODE]\n    var_a = something()\n    b = something()\n  [CODE]\n  call setline(1, testinput)\n  call cursor(1, 1)\n  call feedkeys(\"^\\<c-v>j$A;\\<esc>\", 'tnix')\n  let expected =<< [CODE]\n        var_a = something();\nb = something();\n[CODE]\n  call assert_equal(expected, getline(1, '$'))\n\n  %d\n  let testinput =<< [CODE]\n                var_a = something()\n                b = something()\n[CODE]\n  call setline(1, testinput)\n  call cursor(1, 1)\n  call feedkeys(\"^\\<c-v>j$A;\\<esc>\", 'tnix')\n  let expected =<< [CODE]\n        var_a = something();\n                b = something()\n[CODE]\n  call assert_equal(expected, getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_cindent_func()\n  new\n  setlocal cindent\n  call setline(1, ['int main(void)', '{', 'return 0;', '}'])\n  call assert_equal(-1, cindent(0))\n  call assert_equal(&sw, 3->cindent())\n  call assert_equal(-1, cindent(line('$')+1))\n  bwipe!\nendfunc\n\nfunc Test_cindent_1()\n  new\n  setl cindent ts=4 sw=4\n  setl cino& sts&\n\n  let code =<< trim [CODE]\n  /* start of AUTO matically checked vim: set ts=4 : */\n  {\n  \tif (test)\n  \t\tcmd1;\n  \tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t\tcmd1;\n  \telse\n  \t\tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\tcmd2;\n  \t}\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\telse\n  \t}\n  }\n\n  {\n  \twhile (this)\n  \t\tif (test)\n  \t\t\tcmd1;\n  \tcmd2;\n  }\n\n  {\n  \twhile (this)\n  \t\tif (test)\n  \t\t\tcmd1;\n  \t\telse\n  \t\t\tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd;\n  \t}\n\n  \tif (test)\n  \t\tcmd;\n  }\n\n  {\n  \tif (test) {\n  \t\tcmd;\n  \t}\n\n  \tif (test) cmd;\n  }\n\n  {\n  \tcmd1;\n  \tfor (blah)\n  \t\twhile (this)\n  \t\t\tif (test)\n  \t\t\t\tcmd2;\n  \tcmd3;\n  }\n\n  {\n  \tcmd1;\n  \tfor (blah)\n  \t\twhile (this)\n  \t\t\tif (test)\n  \t\t\t\tcmd2;\n  \tcmd3;\n\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\tcmd2;\n  \t\tcmd3;\n  \t}\n  }\n\n\n  /* Test for 'cindent' do/while mixed with if/else: */\n\n  {\n  \tdo\n  \t\tif (asdf)\n  \t\t\tasdfasd;\n  \twhile (cond);\n\n  \tdo\n  \t\tif (asdf)\n  \t\t\twhile (asdf)\n  \t\t\t\tasdf;\n  \twhile (asdf);\n  }\n\n  /* Test for 'cindent' with two ) on a continuation line */\n  {\n  \tif (asdfasdf;asldkfj asdlkfj as;ldkfj sal;d\n  \t\t\taal;sdkjf  ( ;asldfkja;sldfk\n  \t\t\t\t\tal;sdjfka ;slkdf ) sa;ldkjfsa dlk;)\n  \t\tline up here;\n  }\n\n\n  /* C++ tests: */\n\n  // foo()\t\tthese three lines should remain in column 0\n  // {\n  // }\n\n  /* Test for continuation and unterminated lines: */\n  {\n  \ti = 99 + 14325 +\n  \t\t21345 +\n  \t\t21345 +\n  \t\t21345 + ( 21345 +\n  \t\t\t\t21345) +\n  \t\t2345 +\n  \t\t1234;\n  \tc = 1;\n  }\n\n  /*\n     testje for indent with empty line\n\n     here */\n\n  {\n  \tif (testing &&\n  \t\t\tnot a joke ||\n  \t\t\tline up here)\n  \t\thay;\n  \tif (testing &&\n  \t\t\t(not a joke || testing\n  \t\t\t)line up here)\n  \t\thay;\n  \tif (testing &&\n  \t\t\t(not a joke || testing\n  \t\t\t line up here))\n  \t\thay;\n  }\n\n\n  {\n  \tswitch (c)\n  \t{\n  \t\tcase xx:\n  \t\t\tdo\n  \t\t\t\tif (asdf)\n  \t\t\t\t\tdo\n  \t\t\t\t\t\tasdfasdf;\n  \t\t\t\t\twhile (asdf);\n  \t\t\t\telse\n  \t\t\t\t\tasdfasdf;\n  \t\t\twhile (cond);\n  \t\tcase yy:\n  \t\tcase xx:\n  \t\tcase zz:\n  \t\t\ttesting;\n  \t}\n  }\n\n  {\n  \tif (cond) {\n  \t\tfoo;\n  \t}\n  \telse\n  \t{\n  \t\tbar;\n  \t}\n  }\n\n  {\n  \tif (alskdfj ;alsdkfjal;skdjf (;sadlkfsa ;dlkf j;alksdfj ;alskdjf\n  \t\t\talsdkfj (asldk;fj\n  \t\t\t\t\tawith cino=(0 ;lf this one goes to below the paren with ==\n  \t\t\t\t\t\t\t;laksjfd ;lsakdjf ;alskdf asd)\n  \t\t\t\t\tasdfasdf;)))\n  \t\tasdfasdf;\n  }\n\n  \tint\n  func(a, b)\n  \tint a;\n  \tint c;\n  {\n  \tif (c1 && (c2 ||\n  \t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3)\n  \t   )\n  }\n\n  {\n  \twhile (asd)\n  \t{\n  \t\tif (asdf)\n  \t\t\tif (test)\n  \t\t\t\tif (that)\n  \t\t\t\t{\n  \t\t\t\t\tif (asdf)\n  \t\t\t\t\t\tdo\n  \t\t\t\t\t\t\tcdasd;\n  \t\t\t\t\t\twhile (as\n  \t\t\t\t\t\t\t\tdf);\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t\tif (asdf)\n  \t\t\t\t\t\tasdf;\n  \t\t\t\t\telse\n  \t\t\t\t\t\tasdf;\n  \t\tasdf;\n  \t}\n  }\n\n  {\n  \ts = \"/*\"; b = ';'\n  \t\ts = \"/*\"; b = ';';\n  \ta = b;\n  }\n\n  {\n  \tswitch (a)\n  \t{\n  \t\tcase a:\n  \t\t\tswitch (t)\n  \t\t\t{\n  \t\t\t\tcase 1:\n  \t\t\t\t\tcmd;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase 2:\n  \t\t\t\t\tcmd;\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tcmd;\n  \t\t\tbreak;\n  \t\tcase b:\n  \t\t\t{\n  \t\t\t\tint i;\n  \t\t\t\tcmd;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase c: {\n  \t\t\t\t\tint i;\n  \t\t\t\t\tcmd;\n  \t\t\t\t}\n  \t\tcase d: if (cond &&\n  \t\t\t\t\t\ttest) {\t\t/* this line doesn't work right */\n  \t\t\t\t\tint i;\n  \t\t\t\t\tcmd;\n  \t\t\t\t}\n  \t\t\t\tbreak;\n  \t}\n  }\n\n  {\n  \tif (!(vim_strchr(p_cpo, CPO_BUFOPTGLOB) != NULL && entering) &&\n  \t\t\t(bp_to->b_p_initialized ||\n  \t\t\t (!entering && vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n  \t\treturn;\n  label :\n  \tasdf = asdf ?\n  \t\tasdf : asdf;\n  \tasdf = asdf ?\n  \t\tasdf: asdf;\n  }\n\n  /* Special Comments\t: This function has the added complexity (compared  */\n  /*\t\t\t\t\t: to addtolist) of having to check for a detail     */\n  /*\t\t\t\t\t: texture and add that to the list first.\t \t    */\n\n  char *(array[100]) = {\n  \t\"testje\",\n  \t\"foo\",\n  \t\"bar\",\n  }\n\n  enum soppie\n  {\n  yes = 0,\n  no,\n  maybe\n  };\n\n  typedef enum soppie\n  {\n  yes = 0,\n  no,\n  maybe\n  };\n\n  static enum\n  {\n  yes = 0,\n  no,\n  maybe\n  } soppie;\n\n  public static enum\n  {\n  yes = 0,\n  no,\n  maybe\n  } soppie;\n\n  static private enum\n  {\n  yes = 0,\n  no,\n  maybe\n  } soppie;\n\n  {\n  \tint a,\n  \t\tb;\n  }\n\n  {\n  \tstruct Type\n  \t{\n  \t\tint i;\n  \t\tchar *str;\n  \t} var[] =\n  \t{\n  \t\t0, \"zero\",\n  \t\t1, \"one\",\n  \t\t2, \"two\",\n  \t\t3, \"three\"\n  \t};\n\n  \tfloat matrix[3][3] =\n  \t{\n  \t\t{\n  \t\t\t0,\n  \t\t\t1,\n  \t\t\t2\n  \t\t},\n  \t\t{\n  \t\t\t3,\n  \t\t\t4,\n  \t\t\t5\n  \t\t},\n  \t\t{\n  \t\t\t6,\n  \t\t\t7,\n  \t\t\t8\n  \t\t}\n  \t};\n  }\n\n  {\n  \t/* blah ( blah */\n  \t/* where does this go? */\n\n  \t/* blah ( blah */\n  \tcmd;\n\n  \tfunc(arg1,\n  \t\t\t/* comment */\n  \t\t\targ2);\n  \ta;\n  \t{\n  \t\tb;\n  \t\t{\n  \t\t\tc; /* Hey, NOW it indents?! */\n  \t\t}\n  \t}\n\n  \t{\n  \t\tfunc(arg1,\n  \t\t\t\targ2,\n  \t\t\t\targ3);\n  \t\t/* Hey, what am I doing here?  Is this coz of the \",\"? */\n  \t}\n  }\n\n  main ()\n  {\n  \tif (cond)\n  \t{\n  \t\ta = b;\n  \t}\n  \tif (cond) {\n  \t\ta = c;\n  \t}\n  \tif (cond)\n  \t\ta = d;\n  \treturn;\n  }\n\n  {\n  \tcase 2: if (asdf &&\n  \t\t\t\t\tasdfasdf)\n  \t\t\t\taasdf;\n  \t\t\ta = 9;\n  \tcase 3: if (asdf)\n  \t\t\t\taasdf;\n  \t\t\ta = 9;\n  \tcase 4:    x = 1;\n  \t\t\t   y = 2;\n\n  label:\tif (asdf)\n  \t\t\there;\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf)\n  \t\t{\n  \t\t}\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf) {\n  \t\t\tthere;\n  \t\t}\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf)\n  \t\t\tthere;\n  }\n\n  {\n  \t/*\n  \t   hello with \":set comments= cino=c5\"\n  \t */\n\n  \t/*\n  \t   hello with \":set comments= cino=\"\n  \t */\n  }\n\n\n  {\n  \tif (a < b) {\n  \t\ta = a + 1;\n  \t} else\n  \t\ta = a + 2;\n\n  \tif (a)\n  \t\tdo {\n  \t\t\ttesting;\n  \t\t} while (asdfasdf);\n  \ta = b + 1;\n  \tasdfasdf\n  }\n\n  {\n  for ( int i = 0;\n  \ti < 10; i++ )\n  {\n  }\n  \ti = 0;\n  }\n\n  class bob\n  {\n  \tint foo() {return 1;}\n  \t\tint bar;\n  }\n\n  main()\n  {\n  while(1)\n  if (foo)\n  {\n  bar;\n  }\n  else {\n  asdf;\n  }\n  misplacedline;\n  }\n\n  {\n  \tif (clipboard.state == SELECT_DONE\n  \t&& ((row == clipboard.start.lnum\n  \t&& col >= clipboard.start.col)\n  \t|| row > clipboard.start.lnum))\n  }\n\n  {\n  if (1) {i += 4;}\n  where_am_i;\n  return 0;\n  }\n\n  {\n  {\n  } // sdf(asdf\n  if (asdf)\n  asd;\n  }\n\n  {\n  label1:\n  label2:\n  }\n\n  {\n  int fooRet = foo(pBar1, false /*fKB*/,\n  \ttrue /*fPTB*/, 3 /*nT*/, false /*fDF*/);\n  f() {\n  for ( i = 0;\n  \ti < m;\n  \t/* c */ i++ ) {\n  a = b;\n  }\n  }\n  }\n\n  {\n  \tf1(/*comment*/);\n  \tf2();\n  }\n\n  {\n  do {\n  if (foo) {\n  } else\n  ;\n  } while (foo);\n  foo();\t// was wrong\n  }\n\n  int x;\t    // no extra indent because of the ;\n  void func()\n  {\n  }\n\n  char *tab[] = {\"aaa\",\n  \t\"};\", /* }; */ NULL}\n  \tint indented;\n  {}\n\n  char *a[] = {\"aaa\", \"bbb\",\n  \t\"ccc\", NULL};\n  // here\n\n  char *tab[] = {\"aaa\",\n  \t\"xx\", /* xx */};    /* asdf */\n  int not_indented;\n\n  {\n  \tdo {\n  \t\tswitch (bla)\n  \t\t{\n  \t\t\tcase 1: if (foo)\n  \t\t\t\t\t\tbar;\n  \t\t}\n  \t} while (boo);\n  \t\t\t\t\twrong;\n  }\n\n  int\tfoo,\n  \tbar;\n  int foo;\n\n  #if defined(foo) \\\n  \t&& defined(bar)\n  char * xx = \"asdf\\\n  \tfoo\\\n  \tbor\";\n  int x;\n\n  char    *foo = \"asdf\\\n  \tasdf\\\n  \tasdf\",\n  \t*bar;\n\n  void f()\n  {\n  #if defined(foo) \\\n  \t&& defined(bar)\n  char    *foo = \"asdf\\\n  \tasdf\\\n  \tasdf\",\n  \t*bar;\n  \t{\n  \tint i;\n  char    *foo = \"asdf\\\n  \tasdf\\\n  \tasdf\",\n  \t*bar;\n  \t}\n  #endif\n  }\n  #endif\n\n  int y;\t\t// comment\n  \t\t// comment\n\n  \t// comment\n\n  {\n  \tConstructor(int a,\n  \t\t\tint b )  : BaseClass(a)\n  \t{\n  \t}\n  }\n\n  void foo()\n  {\n  \tchar one,\n  \ttwo;\n  \tstruct bla piet,\n  \tjan;\n  \tenum foo kees,\n  \tjannie;\n  \tstatic unsigned sdf,\n  \tkrap;\n  \tunsigned int piet,\n  \tjan;\n  \tint\n  \tkees,\n  \tjan;\n  }\n\n  {\n  \tt(int f,\n  \t\t\tint d);\t\t// )\n  \td();\n  }\n\n  Constructor::Constructor(int a,\n                           int b \n                          )  : \n     BaseClass(a,\n               b,\n               c),\n     mMember(b),\n  {\n  }\n\n  Constructor::Constructor(int a,\n                           int b )  : \n     BaseClass(a)\n  {\n  }\n\n  Constructor::Constructor(int a,\n                           int b ) /*x*/ : /*x*/ BaseClass(a),\n                                                 member(b)\n  {\n  }\n\n  A::A(int a, int b)\n  : aa(a),\n  bb(b),\n  cc(c)\n  {\n  }\n\n  class CAbc :\n     public BaseClass1,\n     protected BaseClass2\n  {\n     int Test() { return FALSE; }\n     int Test1() { return TRUE; }\n\n     CAbc(int a, int b )  : \n        BaseClass(a)\n     { \n        switch(xxx)\n        {\n           case abc:\n              asdf();\n              break;\n\n           case 999:\n              baer();\n              break;\n        }\n     }\n\n  public: // <-- this was incorrectly indented before!!\n     void testfall();\n  protected:\n     void testfall();\n  };\n\n  class CAbc : public BaseClass1,\n               protected BaseClass2\n  {\n  };\n\n  static struct\n  {\n      int a;\n      int b;\n  } variable[COUNT] =\n  {\n      {\n          123,\n          456\n      },\n  \t{\n          123,\n          456\n      }\n  };\n\n  static struct\n  {\n      int a;\n      int b;\n  } variable[COUNT] =\n  {\n      { 123, 456 },\n  \t{ 123, 456 }\n  };\n\n  void asdf()\t\t/* ind_maxparen may cause trouble here */\n  {\n  \tif ((0\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1)) break;\n  }\n\n  foo()\n  {\n  \ta = cond ? foo() : asdf\n  \t\t\t\t\t   + asdf;\n\n  \ta = cond ?\n  \t\tfoo() : asdf\n  \t\t\t\t+ asdf;\n  }\n\n  int  main(void)\n  {\n  \tif (a)\n  \t\tif (b)\n  \t\t\t2;\n  \t\telse 3;\n  \tnext_line_of_code();\n  }\n\n  barry()\n  {\n  \tFoo::Foo (int one,\n  \t\t\tint two)\n  \t\t: something(4)\n  \t{}\n  }\n\n  barry()\n  {\n  \tFoo::Foo (int one, int two)\n  \t\t: something(4)\n  \t{}\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b \n  \t\t)  : \n  \tBaseClass(a,\n  \t\t\tb,\n  \t\t\tc),\n  \tmMember(b)\n  {\n  }\n         int main ()\n         {\n  \t if (lala)\n  \t   do\n  \t     ++(*lolo);\n  \t   while (lili\n  \t\t  && lele);\n  \t   lulu;\n         }\n\n  int main ()\n  {\n  switch (c)\n  {\n  case 'c': if (cond)\n  {\n  }\n  }\n  }\n\n  main()\n  {\n  \t(void) MyFancyFuasdfadsfnction(\n  \t\t\targument);\n  }\n\n  main()\n  {\n  \tchar\tfoo[] = \"/*\";\n  \t/* as\n  \tdf */\n  \t\thello\n  }\n\n  /* valid namespaces with normal indent */\n  namespace\n  {\n  {\n    111111111111;\n  }\n  }\n  namespace /* test */\n  {\n    11111111111111111;\n  }\n  namespace // test\n  {\n    111111111111111111;\n  }\n  namespace\n  {\n    111111111111111111;\n  }\n  namespace test\n  {\n    111111111111111111;\n  }\n  namespace{\n    111111111111111111;\n  }\n  namespace test{\n    111111111111111111;\n  }\n  namespace {\n    111111111111111111;\n  }\n  namespace test {\n    111111111111111111;\n  namespace test2 {\n    22222222222222222;\n  }\n  }\n\n  /* invalid namespaces use block indent */\n  namespace test test2 {\n    111111111111111111111;\n  }\n  namespace11111111111 {\n    111111111111;\n  }\n  namespace() {\n    1111111111111;\n  }\n  namespace()\n  {\n    111111111111111111;\n  }\n  namespace test test2\n  {\n    1111111111111111111;\n  }\n  namespace111111111\n  {\n    111111111111111111;\n  }\n\n  void getstring() {\n  /* Raw strings */\n  const char* s = R\"(\n    test {\n      # comment\n      field: 123\n    }\n   )\";\n       }\n\n  void getstring() {\n  const char* s = R\"foo(\n    test {\n      # comment\n      field: 123\n    }\n      )foo\";\n       }\n\n  {\n  int a[4] = {\n  [0] = 0,\n  [1] = 1,\n  [2] = 2,\n  [3] = 3,\n  };\n  }\n\n  {\n  a = b[2]\n  + 3;\n  }\n\n  {\n  if (1)\n  /* aaaaa\n  * bbbbb\n  */\n  a = 1;\n  }\n\n  void func()\n  {\n  switch (foo)\n  {\n  case (bar):\n  if (baz())\n  quux();\n  break;\n  case (shmoo):\n  if (!bar)\n  {\n  }\n  case (foo1):\n  switch (bar)\n  {\n  case baz:\n  baz_f();\n  break;\n  }\n  break;\n  default:\n  baz();\n  baz();\n  break;\n  }\n  }\n\n  /* end of AUTO */\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('start of AUTO')\n  exe \"normal =/end of AUTO\\<CR>\"\n\n  let expected =<< trim [CODE]\n  /* start of AUTO matically checked vim: set ts=4 : */\n  {\n  \tif (test)\n  \t\tcmd1;\n  \tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t\tcmd1;\n  \telse\n  \t\tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\tcmd2;\n  \t}\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\telse\n  \t}\n  }\n\n  {\n  \twhile (this)\n  \t\tif (test)\n  \t\t\tcmd1;\n  \tcmd2;\n  }\n\n  {\n  \twhile (this)\n  \t\tif (test)\n  \t\t\tcmd1;\n  \t\telse\n  \t\t\tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd;\n  \t}\n\n  \tif (test)\n  \t\tcmd;\n  }\n\n  {\n  \tif (test) {\n  \t\tcmd;\n  \t}\n\n  \tif (test) cmd;\n  }\n\n  {\n  \tcmd1;\n  \tfor (blah)\n  \t\twhile (this)\n  \t\t\tif (test)\n  \t\t\t\tcmd2;\n  \tcmd3;\n  }\n\n  {\n  \tcmd1;\n  \tfor (blah)\n  \t\twhile (this)\n  \t\t\tif (test)\n  \t\t\t\tcmd2;\n  \tcmd3;\n\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\tcmd2;\n  \t\tcmd3;\n  \t}\n  }\n\n\n  /* Test for 'cindent' do/while mixed with if/else: */\n\n  {\n  \tdo\n  \t\tif (asdf)\n  \t\t\tasdfasd;\n  \twhile (cond);\n\n  \tdo\n  \t\tif (asdf)\n  \t\t\twhile (asdf)\n  \t\t\t\tasdf;\n  \twhile (asdf);\n  }\n\n  /* Test for 'cindent' with two ) on a continuation line */\n  {\n  \tif (asdfasdf;asldkfj asdlkfj as;ldkfj sal;d\n  \t\t\taal;sdkjf  ( ;asldfkja;sldfk\n  \t\t\t\tal;sdjfka ;slkdf ) sa;ldkjfsa dlk;)\n  \t\tline up here;\n  }\n\n\n  /* C++ tests: */\n\n  // foo()\t\tthese three lines should remain in column 0\n  // {\n  // }\n\n  /* Test for continuation and unterminated lines: */\n  {\n  \ti = 99 + 14325 +\n  \t\t21345 +\n  \t\t21345 +\n  \t\t21345 + ( 21345 +\n  \t\t\t\t21345) +\n  \t\t2345 +\n  \t\t1234;\n  \tc = 1;\n  }\n\n  /*\n     testje for indent with empty line\n\n     here */\n\n  {\n  \tif (testing &&\n  \t\t\tnot a joke ||\n  \t\t\tline up here)\n  \t\thay;\n  \tif (testing &&\n  \t\t\t(not a joke || testing\n  \t\t\t)line up here)\n  \t\thay;\n  \tif (testing &&\n  \t\t\t(not a joke || testing\n  \t\t\t line up here))\n  \t\thay;\n  }\n\n\n  {\n  \tswitch (c)\n  \t{\n  \t\tcase xx:\n  \t\t\tdo\n  \t\t\t\tif (asdf)\n  \t\t\t\t\tdo\n  \t\t\t\t\t\tasdfasdf;\n  \t\t\t\t\twhile (asdf);\n  \t\t\t\telse\n  \t\t\t\t\tasdfasdf;\n  \t\t\twhile (cond);\n  \t\tcase yy:\n  \t\tcase xx:\n  \t\tcase zz:\n  \t\t\ttesting;\n  \t}\n  }\n\n  {\n  \tif (cond) {\n  \t\tfoo;\n  \t}\n  \telse\n  \t{\n  \t\tbar;\n  \t}\n  }\n\n  {\n  \tif (alskdfj ;alsdkfjal;skdjf (;sadlkfsa ;dlkf j;alksdfj ;alskdjf\n  \t\t\t\talsdkfj (asldk;fj\n  \t\t\t\t\tawith cino=(0 ;lf this one goes to below the paren with ==\n  \t\t\t\t\t\t;laksjfd ;lsakdjf ;alskdf asd)\n  \t\t\t\t\tasdfasdf;)))\n  \t\tasdfasdf;\n  }\n\n  \tint\n  func(a, b)\n  \tint a;\n  \tint c;\n  {\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3)\n  \t   )\n  }\n\n  {\n  \twhile (asd)\n  \t{\n  \t\tif (asdf)\n  \t\t\tif (test)\n  \t\t\t\tif (that)\n  \t\t\t\t{\n  \t\t\t\t\tif (asdf)\n  \t\t\t\t\t\tdo\n  \t\t\t\t\t\t\tcdasd;\n  \t\t\t\t\t\twhile (as\n  \t\t\t\t\t\t\t\tdf);\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t\tif (asdf)\n  \t\t\t\t\t\tasdf;\n  \t\t\t\t\telse\n  \t\t\t\t\t\tasdf;\n  \t\tasdf;\n  \t}\n  }\n\n  {\n  \ts = \"/*\"; b = ';'\n  \t\ts = \"/*\"; b = ';';\n  \ta = b;\n  }\n\n  {\n  \tswitch (a)\n  \t{\n  \t\tcase a:\n  \t\t\tswitch (t)\n  \t\t\t{\n  \t\t\t\tcase 1:\n  \t\t\t\t\tcmd;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase 2:\n  \t\t\t\t\tcmd;\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tcmd;\n  \t\t\tbreak;\n  \t\tcase b:\n  \t\t\t{\n  \t\t\t\tint i;\n  \t\t\t\tcmd;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase c: {\n  \t\t\t\t\tint i;\n  \t\t\t\t\tcmd;\n  \t\t\t\t}\n  \t\tcase d: if (cond &&\n  \t\t\t\t\t\ttest) {\t\t/* this line doesn't work right */\n  \t\t\t\t\tint i;\n  \t\t\t\t\tcmd;\n  \t\t\t\t}\n  \t\t\t\tbreak;\n  \t}\n  }\n\n  {\n  \tif (!(vim_strchr(p_cpo, CPO_BUFOPTGLOB) != NULL && entering) &&\n  \t\t\t(bp_to->b_p_initialized ||\n  \t\t\t (!entering && vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n  \t\treturn;\n  label :\n  \tasdf = asdf ?\n  \t\tasdf : asdf;\n  \tasdf = asdf ?\n  \t\tasdf: asdf;\n  }\n\n  /* Special Comments\t: This function has the added complexity (compared  */\n  /*\t\t\t\t\t: to addtolist) of having to check for a detail     */\n  /*\t\t\t\t\t: texture and add that to the list first.\t \t    */\n\n  char *(array[100]) = {\n  \t\"testje\",\n  \t\"foo\",\n  \t\"bar\",\n  }\n\n  enum soppie\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  };\n\n  typedef enum soppie\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  };\n\n  static enum\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  } soppie;\n\n  public static enum\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  } soppie;\n\n  static private enum\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  } soppie;\n\n  {\n  \tint a,\n  \t\tb;\n  }\n\n  {\n  \tstruct Type\n  \t{\n  \t\tint i;\n  \t\tchar *str;\n  \t} var[] =\n  \t{\n  \t\t0, \"zero\",\n  \t\t1, \"one\",\n  \t\t2, \"two\",\n  \t\t3, \"three\"\n  \t};\n\n  \tfloat matrix[3][3] =\n  \t{\n  \t\t{\n  \t\t\t0,\n  \t\t\t1,\n  \t\t\t2\n  \t\t},\n  \t\t{\n  \t\t\t3,\n  \t\t\t4,\n  \t\t\t5\n  \t\t},\n  \t\t{\n  \t\t\t6,\n  \t\t\t7,\n  \t\t\t8\n  \t\t}\n  \t};\n  }\n\n  {\n  \t/* blah ( blah */\n  \t/* where does this go? */\n\n  \t/* blah ( blah */\n  \tcmd;\n\n  \tfunc(arg1,\n  \t\t\t/* comment */\n  \t\t\targ2);\n  \ta;\n  \t{\n  \t\tb;\n  \t\t{\n  \t\t\tc; /* Hey, NOW it indents?! */\n  \t\t}\n  \t}\n\n  \t{\n  \t\tfunc(arg1,\n  \t\t\t\targ2,\n  \t\t\t\targ3);\n  \t\t/* Hey, what am I doing here?  Is this coz of the \",\"? */\n  \t}\n  }\n\n  main ()\n  {\n  \tif (cond)\n  \t{\n  \t\ta = b;\n  \t}\n  \tif (cond) {\n  \t\ta = c;\n  \t}\n  \tif (cond)\n  \t\ta = d;\n  \treturn;\n  }\n\n  {\n  \tcase 2: if (asdf &&\n  \t\t\t\t\tasdfasdf)\n  \t\t\t\taasdf;\n  \t\t\ta = 9;\n  \tcase 3: if (asdf)\n  \t\t\t\taasdf;\n  \t\t\ta = 9;\n  \tcase 4:    x = 1;\n  \t\t\t   y = 2;\n\n  label:\tif (asdf)\n  \t\t\there;\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf)\n  \t\t{\n  \t\t}\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf) {\n  \t\t\tthere;\n  \t\t}\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf)\n  \t\t\tthere;\n  }\n\n  {\n  \t/*\n  \t   hello with \":set comments= cino=c5\"\n  \t */\n\n  \t/*\n  \t   hello with \":set comments= cino=\"\n  \t */\n  }\n\n\n  {\n  \tif (a < b) {\n  \t\ta = a + 1;\n  \t} else\n  \t\ta = a + 2;\n\n  \tif (a)\n  \t\tdo {\n  \t\t\ttesting;\n  \t\t} while (asdfasdf);\n  \ta = b + 1;\n  \tasdfasdf\n  }\n\n  {\n  \tfor ( int i = 0;\n  \t\t\ti < 10; i++ )\n  \t{\n  \t}\n  \ti = 0;\n  }\n\n  class bob\n  {\n  \tint foo() {return 1;}\n  \tint bar;\n  }\n\n  main()\n  {\n  \twhile(1)\n  \t\tif (foo)\n  \t\t{\n  \t\t\tbar;\n  \t\t}\n  \t\telse {\n  \t\t\tasdf;\n  \t\t}\n  \tmisplacedline;\n  }\n\n  {\n  \tif (clipboard.state == SELECT_DONE\n  \t\t\t&& ((row == clipboard.start.lnum\n  \t\t\t\t\t&& col >= clipboard.start.col)\n  \t\t\t\t|| row > clipboard.start.lnum))\n  }\n\n  {\n  \tif (1) {i += 4;}\n  \twhere_am_i;\n  \treturn 0;\n  }\n\n  {\n  \t{\n  \t} // sdf(asdf\n  \tif (asdf)\n  \t\tasd;\n  }\n\n  {\n  label1:\n  label2:\n  }\n\n  {\n  \tint fooRet = foo(pBar1, false /*fKB*/,\n  \t\t\ttrue /*fPTB*/, 3 /*nT*/, false /*fDF*/);\n  \tf() {\n  \t\tfor ( i = 0;\n  \t\t\t\ti < m;\n  \t\t\t\t/* c */ i++ ) {\n  \t\t\ta = b;\n  \t\t}\n  \t}\n  }\n\n  {\n  \tf1(/*comment*/);\n  \tf2();\n  }\n\n  {\n  \tdo {\n  \t\tif (foo) {\n  \t\t} else\n  \t\t\t;\n  \t} while (foo);\n  \tfoo();\t// was wrong\n  }\n\n  int x;\t    // no extra indent because of the ;\n  void func()\n  {\n  }\n\n  char *tab[] = {\"aaa\",\n  \t\"};\", /* }; */ NULL}\n  \tint indented;\n  {}\n\n  char *a[] = {\"aaa\", \"bbb\",\n  \t\"ccc\", NULL};\n  // here\n\n  char *tab[] = {\"aaa\",\n  \t\"xx\", /* xx */};    /* asdf */\n  int not_indented;\n\n  {\n  \tdo {\n  \t\tswitch (bla)\n  \t\t{\n  \t\t\tcase 1: if (foo)\n  \t\t\t\t\t\tbar;\n  \t\t}\n  \t} while (boo);\n  \twrong;\n  }\n\n  int\tfoo,\n  \tbar;\n  int foo;\n\n  #if defined(foo) \\\n  \t&& defined(bar)\n  char * xx = \"asdf\\\n  \t\t\t foo\\\n  \t\t\t bor\";\n  int x;\n\n  char    *foo = \"asdf\\\n  \t\t\t\tasdf\\\n  \t\t\t\tasdf\",\n  \t\t*bar;\n\n  void f()\n  {\n  #if defined(foo) \\\n  \t&& defined(bar)\n  \tchar    *foo = \"asdf\\\n  \t\t\t\t\tasdf\\\n  \t\t\t\t\tasdf\",\n  \t\t\t*bar;\n  \t{\n  \t\tint i;\n  \t\tchar    *foo = \"asdf\\\n  \t\t\t\t\t\tasdf\\\n  \t\t\t\t\t\tasdf\",\n  \t\t\t\t*bar;\n  \t}\n  #endif\n  }\n  #endif\n\n  int y;\t\t// comment\n  // comment\n\n  // comment\n\n  {\n  \tConstructor(int a,\n  \t\t\tint b )  : BaseClass(a)\n  \t{\n  \t}\n  }\n\n  void foo()\n  {\n  \tchar one,\n  \t\t two;\n  \tstruct bla piet,\n  \t\t\t   jan;\n  \tenum foo kees,\n  \t\t\t jannie;\n  \tstatic unsigned sdf,\n  \t\t\t\t\tkrap;\n  \tunsigned int piet,\n  \t\t\t\t jan;\n  \tint\n  \t\tkees,\n  \t\tjan;\n  }\n\n  {\n  \tt(int f,\n  \t\t\tint d);\t\t// )\n  \td();\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b \n  \t\t)  : \n  \tBaseClass(a,\n  \t\t\tb,\n  \t\t\tc),\n  \tmMember(b),\n  {\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b )  : \n  \tBaseClass(a)\n  {\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b ) /*x*/ : /*x*/ BaseClass(a),\n  \tmember(b)\n  {\n  }\n\n  A::A(int a, int b)\n  \t: aa(a),\n  \tbb(b),\n  \tcc(c)\n  {\n  }\n\n  class CAbc :\n  \tpublic BaseClass1,\n  \tprotected BaseClass2\n  {\n  \tint Test() { return FALSE; }\n  \tint Test1() { return TRUE; }\n\n  \tCAbc(int a, int b )  : \n  \t\tBaseClass(a)\n  \t{ \n  \t\tswitch(xxx)\n  \t\t{\n  \t\t\tcase abc:\n  \t\t\t\tasdf();\n  \t\t\t\tbreak;\n\n  \t\t\tcase 999:\n  \t\t\t\tbaer();\n  \t\t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tpublic: // <-- this was incorrectly indented before!!\n  \tvoid testfall();\n  \tprotected:\n  \tvoid testfall();\n  };\n\n  class CAbc : public BaseClass1,\n  \tprotected BaseClass2\n  {\n  };\n\n  static struct\n  {\n  \tint a;\n  \tint b;\n  } variable[COUNT] =\n  {\n  \t{\n  \t\t123,\n  \t\t456\n  \t},\n  \t{\n  \t\t123,\n  \t\t456\n  \t}\n  };\n\n  static struct\n  {\n  \tint a;\n  \tint b;\n  } variable[COUNT] =\n  {\n  \t{ 123, 456 },\n  \t{ 123, 456 }\n  };\n\n  void asdf()\t\t/* ind_maxparen may cause trouble here */\n  {\n  \tif ((0\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1)) break;\n  }\n\n  foo()\n  {\n  \ta = cond ? foo() : asdf\n  \t\t+ asdf;\n\n  \ta = cond ?\n  \t\tfoo() : asdf\n  \t\t+ asdf;\n  }\n\n  int  main(void)\n  {\n  \tif (a)\n  \t\tif (b)\n  \t\t\t2;\n  \t\telse 3;\n  \tnext_line_of_code();\n  }\n\n  barry()\n  {\n  \tFoo::Foo (int one,\n  \t\t\tint two)\n  \t\t: something(4)\n  \t{}\n  }\n\n  barry()\n  {\n  \tFoo::Foo (int one, int two)\n  \t\t: something(4)\n  \t{}\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b \n  \t\t)  : \n  \tBaseClass(a,\n  \t\t\tb,\n  \t\t\tc),\n  \tmMember(b)\n  {\n  }\n  int main ()\n  {\n  \tif (lala)\n  \t\tdo\n  \t\t\t++(*lolo);\n  \t\twhile (lili\n  \t\t\t\t&& lele);\n  \tlulu;\n  }\n\n  int main ()\n  {\n  \tswitch (c)\n  \t{\n  \t\tcase 'c': if (cond)\n  \t\t\t\t  {\n  \t\t\t\t  }\n  \t}\n  }\n\n  main()\n  {\n  \t(void) MyFancyFuasdfadsfnction(\n  \t\t\targument);\n  }\n\n  main()\n  {\n  \tchar\tfoo[] = \"/*\";\n  \t/* as\n  \t   df */\n  \thello\n  }\n\n  /* valid namespaces with normal indent */\n  namespace\n  {\n  \t{\n  \t\t111111111111;\n  \t}\n  }\n  namespace /* test */\n  {\n  \t11111111111111111;\n  }\n  namespace // test\n  {\n  \t111111111111111111;\n  }\n  namespace\n  {\n  \t111111111111111111;\n  }\n  namespace test\n  {\n  \t111111111111111111;\n  }\n  namespace{\n  \t111111111111111111;\n  }\n  namespace test{\n  \t111111111111111111;\n  }\n  namespace {\n  \t111111111111111111;\n  }\n  namespace test {\n  \t111111111111111111;\n  \tnamespace test2 {\n  \t\t22222222222222222;\n  \t}\n  }\n\n  /* invalid namespaces use block indent */\n  namespace test test2 {\n  \t111111111111111111111;\n  }\n  namespace11111111111 {\n  \t111111111111;\n  }\n  namespace() {\n  \t1111111111111;\n  }\n  namespace()\n  {\n  \t111111111111111111;\n  }\n  namespace test test2\n  {\n  \t1111111111111111111;\n  }\n  namespace111111111\n  {\n  \t111111111111111111;\n  }\n\n  void getstring() {\n  \t/* Raw strings */\n  \tconst char* s = R\"(\n    test {\n      # comment\n      field: 123\n    }\n   )\";\n  }\n\n  void getstring() {\n  \tconst char* s = R\"foo(\n    test {\n      # comment\n      field: 123\n    }\n      )foo\";\n  }\n\n  {\n  \tint a[4] = {\n  \t\t[0] = 0,\n  \t\t[1] = 1,\n  \t\t[2] = 2,\n  \t\t[3] = 3,\n  \t};\n  }\n\n  {\n  \ta = b[2]\n  \t\t+ 3;\n  }\n\n  {\n  \tif (1)\n  \t\t/* aaaaa\n  \t\t * bbbbb\n  \t\t */\n  \t\ta = 1;\n  }\n\n  void func()\n  {\n  \tswitch (foo)\n  \t{\n  \t\tcase (bar):\n  \t\t\tif (baz())\n  \t\t\t\tquux();\n  \t\t\tbreak;\n  \t\tcase (shmoo):\n  \t\t\tif (!bar)\n  \t\t\t{\n  \t\t\t}\n  \t\tcase (foo1):\n  \t\t\tswitch (bar)\n  \t\t\t{\n  \t\t\t\tcase baz:\n  \t\t\t\t\tbaz_f();\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\tbaz();\n  \t\t\tbaz();\n  \t\t\tbreak;\n  \t}\n  }\n\n  /* end of AUTO */\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_2()\n  new\n  setl cindent ts=4 sw=4\n  setl tw=0 noai fo=croq\n  let &wm = &columns - 20\n\n  let code =<< trim [CODE]\n    {\n  \n    /* this is\n     * a real serious important big\n     * comment\n     */\n    \t/* insert \" about life, the universe, and the rest\" after \"serious\" */\n    }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('serious', 'e')\n  normal a about life, the universe, and the rest\n\n  let expected =<< trim [CODE]\n  {\n\n  /* this is\n   * a real serious\n   * about life, the\n   * universe, and the\n   * rest important big\n   * comment\n   */\n  \t/* insert \" about life, the universe, and the rest\" after \"serious\" */\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  set wm&\n  enew! | close\nendfunc\n\nfunc Test_cindent_3()\n  new\n  setl nocindent ts=4 sw=4\n\n  let code =<< trim [CODE]\n  {\n  \t/*\n  \t * Testing for comments, without 'cin' set\n  \t */\n\n  /*\n  * what happens here?\n  */\n\n  \t/*\n  \t   the end of the comment, try inserting a line below */\n\n  \t\t/* how about\n  \t\t                this one */\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('comments')\n  normal joabout life\n  call search('happens')\n  normal jothere\n  call search('below')\n  normal oline\n  call search('this')\n  normal Ohello\n\n  let expected =<< trim [CODE]\n  {\n  \t/*\n  \t * Testing for comments, without 'cin' set\n  \t */\n  about life\n\n  /*\n  * what happens here?\n  */\n  there\n\n  \t/*\n  \t   the end of the comment, try inserting a line below */\n  line\n\n  \t\t/* how about\n  hello\n  \t\t                this one */\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_4()\n  new\n  setl cindent ts=4 sw=4\n\n  let code =<< trim [CODE]\n  {\n      var = this + that + vec[0] * vec[0]\n  \t\t\t\t      + vec[1] * vec[1]\n  \t\t\t\t\t  + vec2[2] * vec[2];\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('vec2')\n  normal ==\n\n  let expected =<< trim [CODE]\n  {\n      var = this + that + vec[0] * vec[0]\n  \t\t\t\t      + vec[1] * vec[1]\n  \t\t\t\t\t  + vec2[2] * vec[2];\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_5()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=}4\n\n  let code =<< trim [CODE]\n  {\n  \t\tasdf asdflkajds f;\n  \tif (tes & ting) {\n  \t\tasdf asdf asdf ;\n  \t\tasdfa sdf asdf;\n  \t\t}\n  \ttesting1;\n  \tif (tes & ting)\n  \t{\n  \t\tasdf asdf asdf ;\n  \t\tasdfa sdf asdf;\n  \t\t}\n  \ttesting2;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('testing1')\n  exe \"normal k2==/testing2\\<CR>\"\n  normal k2==\n\n  let expected =<< trim [CODE]\n  {\n  \t\tasdf asdflkajds f;\n  \tif (tes & ting) {\n  \t\tasdf asdf asdf ;\n  \t\tasdfa sdf asdf;\n  \t\t}\n  \ttesting1;\n  \tif (tes & ting)\n  \t{\n  \t\tasdf asdf asdf ;\n  \t\tasdfa sdf asdf;\n  \t\t}\n  \ttesting2;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_6()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,)20\n\n  let code =<< trim [CODE]\n  main ( int first_par, /*\n                         * Comment for\n                         * first par\n                         */\n            int second_par /*\n                         * Comment for\n                         * second par\n                         */\n       )\n  {\n  \tfunc( first_par, /*\n                        * Comment for\n                        * first par\n                        */\n      second_par /*\n                        * Comment for\n                        * second par\n                        */\n          );\n\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('main')\n  normal =][\n\n  let expected =<< trim [CODE]\n  main ( int first_par, /*\n  \t\t\t\t\t   * Comment for\n  \t\t\t\t\t   * first par\n  \t\t\t\t\t   */\n  \t   int second_par /*\n  \t\t\t\t\t   * Comment for\n  \t\t\t\t\t   * second par\n  \t\t\t\t\t   */\n  \t )\n  {\n  \tfunc( first_par, /*\n  \t\t\t\t\t  * Comment for\n  \t\t\t\t\t  * first par\n  \t\t\t\t\t  */\n  \t\t  second_par /*\n  \t\t\t\t\t  * Comment for\n  \t\t\t\t\t  * second par\n  \t\t\t\t\t  */\n  \t\t);\n\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_7()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=es,n0s\n\n  let code =<< trim [CODE]\n  main(void)\n  {\n  \t/* Make sure that cino=X0s is not parsed like cino=Xs. */\n  \tif (cond)\n  \t\tfoo();\n  \telse\n  \t{\n  \t\tbar();\n  \t}\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('main')\n  normal =][\n\n  let expected =<< trim [CODE]\n  main(void)\n  {\n  \t/* Make sure that cino=X0s is not parsed like cino=Xs. */\n  \tif (cond)\n  \t\tfoo();\n  \telse\n  \t{\n  \t\tbar();\n  \t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_8()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=\n\n  let code =<< trim [CODE]\n\n  {\n  \tdo\n  \t{\n  \t\tif ()\n  \t\t{\n  \t\t\tif ()\n  \t\t\t\tasdf;\n  \t\t\telse\n  \t\t\t\tasdf;\n  \t\t}\n  \t} while ();\n  \t\t\tcmd;\t\t/* this should go under the } */\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n\n  {\n  \tdo\n  \t{\n  \t\tif ()\n  \t\t{\n  \t\t\tif ()\n  \t\t\t\tasdf;\n  \t\t\telse\n  \t\t\t\tasdf;\n  \t\t}\n  \t} while ();\n  \tcmd;\t\t/* this should go under the } */\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_9()\n  new\n  setl cindent ts=4 sw=4\n\n  let code =<< trim [CODE]\n\n  void f()\n  {\n      if ( k() ) {\n          l();\n\n      } else { /* Start (two words) end */\n          m();\n      }\n\n      n();\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n\n  void f()\n  {\n  \tif ( k() ) {\n  \t\tl();\n\n  \t} else { /* Start (two words) end */\n  \t\tm();\n  \t}\n\n  \tn();\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_10()\n  new\n  setl cindent ts=4 sw=4\n  setl cino={s,e-s\n\n  let code =<< trim [CODE]\n\n  void f()\n  {\n      if ( k() )\n  \t{\n          l();\n      } else { /* Start (two words) end */\n          m();\n      }\n  \t\tn();\t/* should be under the if () */\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n\n  void f()\n  {\n  \tif ( k() )\n  \t\t{\n  \t\tl();\n  \t\t} else { /* Start (two words) end */\n  \t\tm();\n  \t\t}\n  \tn();\t/* should be under the if () */\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_11()\n  new\n  setl cindent ts=4 sw=4\n  setl cino={s,fs\n\n  let code =<< trim [CODE]\n  void bar(void)\n  {\n  \tstatic array[2][2] =\n  \t{\n  \t\t{ 1, 2 },\n  \t\t{ 3, 4 },\n  \t}\n\n  \twhile (a)\n  \t{\n  \t\tfoo(&a);\n  \t}\n\n  \t{\n  \t\tint a;\n  \t\t{\n  \t\t\ta = a + 1;\n  \t\t}\n  \t}\n  \tb = a;\n  \t}\n\n  void func(void)\n  \t{\n  \ta = 1;\n  \t{\n  \t\tb = 2;\n  \t}\n  \tc = 3;\n  \td = 4;\n  \t}\n  /* foo */\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  exe \"normal ]]=/ foo\\<CR>\"\n\n  let expected =<< trim [CODE]\n  void bar(void)\n  \t{\n  \tstatic array[2][2] =\n  \t\t{\n  \t\t\t{ 1, 2 },\n  \t\t\t{ 3, 4 },\n  \t\t}\n\n  \twhile (a)\n  \t\t{\n  \t\tfoo(&a);\n  \t\t}\n\n  \t\t{\n  \t\tint a;\n  \t\t\t{\n  \t\t\ta = a + 1;\n  \t\t\t}\n  \t\t}\n  \tb = a;\n  \t}\n\n  void func(void)\n  \t{\n  \ta = 1;\n  \t\t{\n  \t\tb = 2;\n  \t\t}\n  \tc = 3;\n  \td = 4;\n  \t}\n  /* foo */\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_12()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=\n\n  let code =<< trim [CODE]\n  a()\n  {\n    do {\n      a = a +\n        a;\n    } while ( a );\t\t/* add text under this line */\n      if ( a )\n        a;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('while')\n  normal ohere\n\n  let expected =<< trim [CODE]\n  a()\n  {\n    do {\n      a = a +\n        a;\n    } while ( a );\t\t/* add text under this line */\n    here\n      if ( a )\n        a;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_13()\n  new\n  setl cindent ts=4 sw=4\n  setl cino= com=\n\n  let code =<< trim [CODE]\n  a()\n  {\n  label1:\n              /* hmm */\n              // comment\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('comment')\n  exe \"normal olabel2: b();\\rlabel3 /* post */:\\r/* pre */ label4:\\r\" .\n        \\ \"f(/*com*/);\\rif (/*com*/)\\rcmd();\"\n\n  let expected =<< trim [CODE]\n  a()\n  {\n  label1:\n              /* hmm */\n              // comment\n  label2: b();\n  label3 /* post */:\n  /* pre */ label4:\n  \t\tf(/*com*/);\n  \t\tif (/*com*/)\n  \t\t\tcmd();\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_14()\n  new\n  setl cindent ts=4 sw=4\n  setl comments& comments^=s:/*,m:**,ex:*/\n\n  let code =<< trim [CODE]\n  /*\n    * A simple comment\n     */\n\n  /*\n    ** A different comment\n     */\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('simple')\n  normal =5j\n\n  let expected =<< trim [CODE]\n  /*\n   * A simple comment\n   */\n\n  /*\n  ** A different comment\n  */\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_15()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=c0\n  setl comments& comments-=s1:/* comments^=s0:/*\n\n  let code =<< trim [CODE]\n  void f()\n  {\n\n  \t/*********\n    A comment.\n  *********/\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n\n  \t/*********\n  \t  A comment.\n  \t*********/\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_16()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=c0,C1\n  setl comments& comments-=s1:/* comments^=s0:/*\n\n  let code =<< trim [CODE]\n  void f()\n  {\n\n  \t/*********\n    A comment.\n  *********/\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n\n  \t/*********\n  \tA comment.\n  \t*********/\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_17()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t(\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t\t(\n  \t\t c2 ||\n  \t\t c3\n  \t\t) && c4;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_18()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(s\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t(\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t\t(\n  \t\t c2 ||\n  \t\t c3\n  \t\t) && c4;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_19()\n  new\n  setl cindent ts=4 sw=4\n  set cino=(s,U1\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t(\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t\t(\n  \t\t\tc2 ||\n  \t\t\tc3\n  \t\t) && c4;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_20()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tif (   c1\n  \t&& (   c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tif (   c1\n  \t\t   && (   c2\n  \t\t\t\t  || c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_21()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,w1\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tif (   c1\n  \t&& (   c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tif (   c1\n  \t\t&& (   c2\n  \t\t\t|| c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_22()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(s\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 && (\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  \tif (\n  \tc1 && c2\n  \t)\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 && (\n  \t\tc2 ||\n  \t\tc3\n  \t\t) && c4;\n  \tif (\n  \t\tc1 && c2\n  \t   )\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_23()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(s,m1\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 && (\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  \tif (\n  \tc1 && c2\n  \t)\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 && (\n  \t\tc2 ||\n  \t\tc3\n  \t) && c4;\n  \tif (\n  \t\tc1 && c2\n  \t)\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_24()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=b1\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tswitch (x)\n  \t{\n  \t\tcase 1:\n  \t\t\ta = b;\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\ta = 0;\n  \t\t\tbreak;\n  \t}\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tswitch (x)\n  \t{\n  \t\tcase 1:\n  \t\t\ta = b;\n  \t\tbreak;\n  \t\tdefault:\n  \t\t\ta = 0;\n  \t\tbreak;\n  \t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_25()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,W5\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tinvokeme(\n  \targu,\n  \tment);\n  \tinvokeme(\n  \targu,\n  \tment\n  \t);\n  \tinvokeme(argu,\n  \tment\n  \t);\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tinvokeme(\n  \t\t argu,\n  \t\t ment);\n  \tinvokeme(\n  \t\t argu,\n  \t\t ment\n  \t\t );\n  \tinvokeme(argu,\n  \t\t\t ment\n  \t\t\t);\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_26()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=/6\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tstatement;\n  \t\t// comment 1\n  \t// comment 2\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tstatement;\n  \t\t  // comment 1\n  \t\t  // comment 2\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_27()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tstatement;\n  \t   // comment 1\n  \t// comment 2\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  exe \"normal ]]/comment 1/+1\\<CR>==\"\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tstatement;\n  \t   // comment 1\n  \t   // comment 2\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_28()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=g0\n\n  let code =<< trim [CODE]\n  class CAbc\n  {\n     int Test() { return FALSE; }\n\n  public: // comment\n     void testfall();\n  protected:\n     void testfall();\n  };\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  class CAbc\n  {\n  \tint Test() { return FALSE; }\n\n  public: // comment\n  \tvoid testfall();\n  protected:\n  \tvoid testfall();\n  };\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_29()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,gs,hs\n\n  let code =<< trim [CODE]\n  class Foo : public Bar\n  {\n  public:\n  virtual void method1(void) = 0;\n  virtual void method2(int arg1,\n  int arg2,\n  int arg3) = 0;\n  };\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  class Foo : public Bar\n  {\n  \tpublic:\n  \t\tvirtual void method1(void) = 0;\n  \t\tvirtual void method2(int arg1,\n  \t\t\t\t\t\t\t int arg2,\n  \t\t\t\t\t\t\t int arg3) = 0;\n  };\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_30()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=+20\n\n  let code =<< [CODE]\n\tvoid\nfoo()\n{\n\tif (a)\n\t{\n\t} else\n\t\tasdf;\n}\n[CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< [CODE]\n\tvoid\nfoo()\n{\n\tif (a)\n\t{\n\t} else\n\t\tasdf;\n}\n\n[CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_31()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,W2s\n\n  let code =<< trim [CODE]\n\n  {\n     averylongfunctionnamelongfunctionnameaverylongfunctionname()->asd(\n           asdasdf,\n           func(asdf,\n                asdfadsf),\n           asdfasdf\n           );\n\n     /* those are ugly, but consequent */\n\n     func()->asd(asdasdf,\n                 averylongfunctionname(\n                       abc,\n                       dec)->averylongfunctionname(\n                             asdfadsf,\n                             asdfasdf,\n                             asdfasdf,\n                             ),\n                 func(asdfadf,\n                      asdfasdf\n                     ),\n                 asdasdf\n                );\n\n     averylongfunctionnameaverylongfunctionnameavery()->asd(fasdf(\n                 abc,\n                 dec)->asdfasdfasdf(\n                       asdfadsf,\n                       asdfasdf,\n                       asdfasdf,\n                       ),\n           func(asdfadf,\n                asdfasdf),\n           asdasdf\n           );\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n\n  {\n  \taverylongfunctionnamelongfunctionnameaverylongfunctionname()->asd(\n  \t\t\tasdasdf,\n  \t\t\tfunc(asdf,\n  \t\t\t\t asdfadsf),\n  \t\t\tasdfasdf\n  \t\t\t);\n\n  \t/* those are ugly, but consequent */\n\n  \tfunc()->asd(asdasdf,\n  \t\t\t\taverylongfunctionname(\n  \t\t\t\t\t\tabc,\n  \t\t\t\t\t\tdec)->averylongfunctionname(\n  \t\t\t\t\t\t\t\tasdfadsf,\n  \t\t\t\t\t\t\t\tasdfasdf,\n  \t\t\t\t\t\t\t\tasdfasdf,\n  \t\t\t\t\t\t\t\t),\n  \t\t\t\tfunc(asdfadf,\n  \t\t\t\t\t asdfasdf\n  \t\t\t\t\t),\n  \t\t\t\tasdasdf\n  \t\t\t   );\n\n  \taverylongfunctionnameaverylongfunctionnameavery()->asd(fasdf(\n  \t\t\t\t\tabc,\n  \t\t\t\t\tdec)->asdfasdfasdf(\n  \t\t\t\t\t\t\tasdfadsf,\n  \t\t\t\t\t\t\tasdfasdf,\n  \t\t\t\t\t\t\tasdfasdf,\n  \t\t\t\t\t\t\t),\n  \t\t\tfunc(asdfadf,\n  \t\t\t\t asdfasdf),\n  \t\t\tasdasdf\n  \t\t\t);\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_32()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=M1\n\n  let code =<< trim [CODE]\n  int main ()\n  {\n  \tif (cond1 &&\n  \t\t\tcond2\n  \t\t\t)\n  \t\tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  int main ()\n  {\n  \tif (cond1 &&\n  \t\t\tcond2\n  \t\t\t)\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_33()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,ts\n\n  let code =<< trim [CODE]\n  void func(int a\n  #if defined(FOO)\n  \t\t  , int b\n  \t\t  , int c\n  #endif\n  \t\t )\n  {\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal 2j=][\n\n  let expected =<< trim [CODE]\n  void func(int a\n  #if defined(FOO)\n  \t\t  , int b\n  \t\t  , int c\n  #endif\n  \t\t )\n  {\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_34()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0\n\n  let code =<< trim [CODE]\n\n  void\n  func(int a\n  #if defined(FOO)\n  \t\t  , int b\n  \t\t  , int c\n  #endif\n  \t\t )\n  {\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal =][\n\n  let expected =<< trim [CODE]\n  \n  \tvoid\n  func(int a\n  #if defined(FOO)\n  \t , int b\n  \t , int c\n  #endif\n  \t)\n  {\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_35()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif(x==y)\n  \t\tif(y==z)\n  \t\t\tfoo=1;\n  \t\telse { bar=1;\n  \t\t\tbaz=2;\n  \t\t}\n  \tprintf(\"Foo!\\n\");\n  }\n\n  void func1(void)\n  {\n  \tchar* tab[] = {\"foo\", \"bar\",\n  \t\t\"baz\", \"quux\",\n  \t\t\t\"this line used\", \"to be indented incorrectly\"};\n  \tfoo();\n  }\n\n  void func2(void)\n  {\n  \tint tab[] =\n  \t{1, 2,\n  \t\t3, 4,\n  \t\t5, 6};\n\n  \t\tprintf(\"This line used to be indented incorrectly.\\n\");\n  }\n\n  int foo[]\n  #ifdef BAR\n\n  = { 1, 2, 3,\n  \t4, 5, 6 }\n\n  #endif\n  ;\n  \tint baz;\n\n  void func3(void)\n  {\n  \tint tab[] = {\n  \t1, 2,\n  \t3, 4,\n  \t5, 6};\n\n  printf(\"Don't you dare indent this line incorrectly!\\n\");\n  }\n\n  void\n  func4(a, b,\n  \t\tc)\n  int a;\n  int b;\n  int c;\n  {\n  }\n\n  void\n  func5(\n  \t\tint a,\n  \t\tint b)\n  {\n  }\n\n  void\n  func6(\n  \t\tint a)\n  {\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=7][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif(x==y)\n  \t\tif(y==z)\n  \t\t\tfoo=1;\n  \t\telse { bar=1;\n  \t\t\tbaz=2;\n  \t\t}\n  \tprintf(\"Foo!\\n\");\n  }\n\n  void func1(void)\n  {\n  \tchar* tab[] = {\"foo\", \"bar\",\n  \t\t\"baz\", \"quux\",\n  \t\t\"this line used\", \"to be indented incorrectly\"};\n  \tfoo();\n  }\n\n  void func2(void)\n  {\n  \tint tab[] =\n  \t{1, 2,\n  \t\t3, 4,\n  \t\t5, 6};\n\n  \tprintf(\"This line used to be indented incorrectly.\\n\");\n  }\n\n  int foo[]\n  #ifdef BAR\n\n  = { 1, 2, 3,\n  \t4, 5, 6 }\n\n  #endif\n  \t;\n  int baz;\n\n  void func3(void)\n  {\n  \tint tab[] = {\n  \t\t1, 2,\n  \t\t3, 4,\n  \t\t5, 6};\n\n  \tprintf(\"Don't you dare indent this line incorrectly!\\n\");\n  }\n\n  \tvoid\n  func4(a, b,\n  \t\tc)\n  \tint a;\n  \tint b;\n  \tint c;\n  {\n  }\n\n  \tvoid\n  func5(\n  \t\tint a,\n  \t\tint b)\n  {\n  }\n\n  \tvoid\n  func6(\n  \t\tint a)\n  {\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_36()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n  setl cino+=l1\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tint tab[] =\n  \t{\n  \t\t1, 2, 3,\n  \t\t4, 5, 6};\n\n  \tprintf(\"Indent this line correctly!\\n\");\n\n  \tswitch (foo)\n  \t{\n  \t\tcase bar:\n  \t\t\tprintf(\"bar\");\n  \t\t\tbreak;\n  \t\tcase baz: {\n  \t\t\tprintf(\"baz\");\n  \t\t\tbreak;\n  \t\t}\n  \t\tcase quux:\n  printf(\"But don't break the indentation of this instruction\\n\");\n  break;\n  \t}\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tint tab[] =\n  \t{\n  \t\t1, 2, 3,\n  \t\t4, 5, 6};\n\n  \tprintf(\"Indent this line correctly!\\n\");\n\n  \tswitch (foo)\n  \t{\n  \t\tcase bar:\n  \t\t\tprintf(\"bar\");\n  \t\t\tbreak;\n  \t\tcase baz: {\n  \t\t\tprintf(\"baz\");\n  \t\t\tbreak;\n  \t\t}\n  \t\tcase quux:\n  \t\t\tprintf(\"But don't break the indentation of this instruction\\n\");\n  \t\t\tbreak;\n  \t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_37()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tcout << \"a\"\n  \t<< \"b\"\n  \t<< \") :\"\n  \t<< \"c\";\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tcout << \"a\"\n  \t\t<< \"b\"\n  \t\t<< \") :\"\n  \t\t<< \"c\";\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_38()\n  new\n  setl cindent ts=4 sw=4\n  setl com=s1:/*,m:*,ex:*/\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \t/*\n  \t * This is a comment.\n  \t */\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]3jofoo();\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \t/*\n  \t * This is a comment.\n  \t */\n  \tfoo();\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_39()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tfor (int i = 0; i < 10; ++i)\n  \t\tif (i & 1) {\n  \t\t\tfoo(1);\n  \t\t} else\n  \t\t\tfoo(0);\n  baz();\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tfor (int i = 0; i < 10; ++i)\n  \t\tif (i & 1) {\n  \t\t\tfoo(1);\n  \t\t} else\n  \t\t\tfoo(0);\n  \tbaz();\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_40()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(0\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n\n  \tif (   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  \tfunc( c1\n  \t&& (     c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t\t && argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n\n  \tif (   c1\n  \t\t\t&& (      c2\n  \t\t\t\t\t  || c3))\n  \t\tfoo;\n  \tfunc( c1\n  \t\t  && (     c2\n  \t\t\t\t   || c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_41()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(s\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n\n  \tif (   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  \tfunc(   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n\n  \tif (   c1\n  \t\t\t&& (      c2\n  \t\t\t\t|| c3))\n  \t\tfoo;\n  \tfunc(   c1\n  \t\t&& (      c2\n  \t\t\t|| c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_42()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(s,U1\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t&& (c22345\n  \t|| c3))\n  \tprintf(\"foo\\n\");\n\n  \tc = c1 &&\n  \t(\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t\t\t&& (c22345\n  \t\t\t\t|| c3))\n  \t\tprintf(\"foo\\n\");\n\n  \tc = c1 &&\n  \t\t(\n  \t\t\tc2 ||\n  \t\t\tc3\n  \t\t) && c4;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_43()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(0,W4\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t&& (c22345\n  \t|| c3))\n  \tprintf(\"foo\\n\");\n\n  \tif (   c1\n  \t&& (   c2\n  \t|| c3))\n  \tfoo;\n\n  \ta_long_line(\n  \targument,\n  \targument);\n  \ta_short_line(argument,\n  \targument);\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t\t && argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t\t\t&& (c22345\n  \t\t\t\t|| c3))\n  \t\tprintf(\"foo\\n\");\n\n  \tif (   c1\n  \t\t\t&& (   c2\n  \t\t\t\t   || c3))\n  \t\tfoo;\n\n  \ta_long_line(\n  \t\targument,\n  \t\targument);\n  \ta_short_line(argument,\n  \t\t\t\t argument);\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_44()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,u2\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t&& (c22345\n  \t|| c3))\n  \tprintf(\"foo\\n\");\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t  c3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t\t\t&& (c22345\n  \t\t\t  || c3))\n  \t\tprintf(\"foo\\n\");\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_45()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(0,w1\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t&& (c22345\n  \t|| c3))\n  \tprintf(\"foo\\n\");\n\n  \tif (   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  \tfunc(   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t\t && argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t\t\t&& (c22345\n  \t\t\t\t|| c3))\n  \t\tprintf(\"foo\\n\");\n\n  \tif (   c1\n  \t\t\t&& (      c2\n  \t\t\t\t|| c3))\n  \t\tfoo;\n  \tfunc(   c1\n  \t\t && (      c2\n  \t\t\t || c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_46()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2,(s\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t  && condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t  c3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t  (c2 || c3))\n  \t{\n  \t}\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t  && condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t  c3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t  (c2 || c3))\n  \t{\n  \t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_47()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=N-s\n\n  let code =<< trim [CODE]\n  NAMESPACESTART\n  /* valid namespaces with normal indent */\n  namespace\n  {\n     {\n  \t111111111111;\n  }\n  }\n  namespace /* test */\n  {\n    11111111111111111;\n  }\n  namespace // test\n  {\n    111111111111111111;\n  }\n  namespace\n  {\n    111111111111111111;\n  }\n  namespace test\n  {\n    111111111111111111;\n  }\n  namespace test::cpp17\n  {\n    111111111111111111;\n  }\n  namespace ::incorrectcpp17\n  {\n    111111111111111111;\n  }\n  namespace test::incorrectcpp17::\n  {\n    111111111111111111;\n  }\n  namespace test:incorrectcpp17\n  {\n    111111111111111111;\n  }\n  namespace test:::incorrectcpp17\n  {\n    111111111111111111;\n  }\n  namespace{\n    111111111111111111;\n  }\n  namespace test{\n    111111111111111111;\n  }\n  namespace {\n    111111111111111111;\n  }\n  namespace test {\n    111111111111111111;\n  namespace test2 {\n    22222222222222222;\n  }\n  }\n\n  /* invalid namespaces use block indent */\n  namespace test test2 {\n    111111111111111111111;\n  }\n  namespace11111111111 {\n    111111111111;\n  }\n  namespace() {\n    1111111111111;\n  }\n  namespace()\n  {\n    111111111111111111;\n  }\n  namespace test test2\n  {\n    1111111111111111111;\n  }\n  namespace111111111\n  {\n    111111111111111111;\n  }\n  NAMESPACEEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^NAMESPACESTART')\n  exe \"normal =/^NAMESPACEEND\\n\"\n\n  let expected =<< trim [CODE]\n  NAMESPACESTART\n  /* valid namespaces with normal indent */\n  namespace\n  {\n  {\n  \t111111111111;\n  }\n  }\n  namespace /* test */\n  {\n  11111111111111111;\n  }\n  namespace // test\n  {\n  111111111111111111;\n  }\n  namespace\n  {\n  111111111111111111;\n  }\n  namespace test\n  {\n  111111111111111111;\n  }\n  namespace test::cpp17\n  {\n  111111111111111111;\n  }\n  namespace ::incorrectcpp17\n  {\n  \t111111111111111111;\n  }\n  namespace test::incorrectcpp17::\n  {\n  \t111111111111111111;\n  }\n  namespace test:incorrectcpp17\n  {\n  \t111111111111111111;\n  }\n  namespace test:::incorrectcpp17\n  {\n  \t111111111111111111;\n  }\n  namespace{\n  111111111111111111;\n  }\n  namespace test{\n  111111111111111111;\n  }\n  namespace {\n  111111111111111111;\n  }\n  namespace test {\n  111111111111111111;\n  namespace test2 {\n  22222222222222222;\n  }\n  }\n\n  /* invalid namespaces use block indent */\n  namespace test test2 {\n  \t111111111111111111111;\n  }\n  namespace11111111111 {\n  \t111111111111;\n  }\n  namespace() {\n  \t1111111111111;\n  }\n  namespace()\n  {\n  \t111111111111111111;\n  }\n  namespace test test2\n  {\n  \t1111111111111111111;\n  }\n  namespace111111111\n  {\n  \t111111111111111111;\n  }\n  NAMESPACEEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_48()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  var bar = {\n  foo: {\n  that: this,\n  some: ok,\n  },\n  \"bar\":{\n  a : 2,\n  b: \"123abc\",\n  x: 4,\n  \"y\": 5\n  }\n  }\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  var bar = {\n  \tfoo: {\n  \t\tthat: this,\n  \t\tsome: ok,\n  \t},\n  \t\"bar\":{\n  \t\ta : 2,\n  \t\tb: \"123abc\",\n  \t\tx: 4,\n  \t\t\"y\": 5\n  \t}\n  }\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_49()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  var foo = [\n  1,\n  2,\n  3\n  ];\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  var foo = [\n  \t1,\n  \t2,\n  \t3\n  ];\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_50()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  function bar() {\n  var foo = [\n  1,\n  2,\n  3\n  ];\n  }\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  function bar() {\n  \tvar foo = [\n  \t\t1,\n  \t\t2,\n  \t\t3\n  \t];\n  }\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_51()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  (function($){\n\n  if (cond &&\n  cond) {\n  stmt;\n  }\n  window.something.left =\n  (width - 50 + offset) + \"px\";\n  var class_name='myclass';\n\n  function private_method() {\n  }\n\n  var public_method={\n  method: function(options,args){\n  private_method();\n  }\n  }\n\n  function init(options) {\n\n  $(this).data(class_name+'_public',$.extend({},{\n  foo: 'bar',\n  bar: 2,\n  foobar: [\n  1,\n  2,\n  3\n  ],\n  callback: function(){\n  return true;\n  }\n  }, options||{}));\n  }\n\n  $.fn[class_name]=function() {\n\n  var _arguments=arguments;\n  return this.each(function(){\n\n  var options=$(this).data(class_name+'_public');\n  if (!options) {\n  init.apply(this,_arguments);\n\n  } else {\n  var method=public_method[_arguments[0]];\n\n  if (typeof(method)!='function') {\n  console.log(class_name+' has no method \"'+_arguments[0]+'\"');\n  return false;\n  }\n  _arguments[0]=options;\n  method.apply(this,_arguments);\n  }\n  });\n  }\n\n  })(jQuery);\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  (function($){\n\n  \tif (cond &&\n  \t\t\tcond) {\n  \t\tstmt;\n  \t}\n  \twindow.something.left =\n  \t\t(width - 50 + offset) + \"px\";\n  \tvar class_name='myclass';\n\n  \tfunction private_method() {\n  \t}\n\n  \tvar public_method={\n  \t\tmethod: function(options,args){\n  \t\t\tprivate_method();\n  \t\t}\n  \t}\n\n  \tfunction init(options) {\n\n  \t\t$(this).data(class_name+'_public',$.extend({},{\n  \t\t\tfoo: 'bar',\n  \t\t\tbar: 2,\n  \t\t\tfoobar: [\n  \t\t\t\t1,\n  \t\t\t\t2,\n  \t\t\t\t3\n  \t\t\t],\n  \t\t\tcallback: function(){\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}, options||{}));\n  \t}\n\n  \t$.fn[class_name]=function() {\n\n  \t\tvar _arguments=arguments;\n  \t\treturn this.each(function(){\n\n  \t\t\tvar options=$(this).data(class_name+'_public');\n  \t\t\tif (!options) {\n  \t\t\t\tinit.apply(this,_arguments);\n\n  \t\t\t} else {\n  \t\t\t\tvar method=public_method[_arguments[0]];\n\n  \t\t\t\tif (typeof(method)!='function') {\n  \t\t\t\t\tconsole.log(class_name+' has no method \"'+_arguments[0]+'\"');\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t\t_arguments[0]=options;\n  \t\t\t\tmethod.apply(this,_arguments);\n  \t\t\t}\n  \t\t});\n  \t}\n\n  })(jQuery);\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_52()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  function init(options) {\n  $(this).data(class_name+'_public',$.extend({},{\n  foo: 'bar',\n  bar: 2,\n  foobar: [\n  1,\n  2,\n  3\n  ],\n  callback: function(){\n  return true;\n  }\n  }, options||{}));\n  }\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  function init(options) {\n  \t$(this).data(class_name+'_public',$.extend({},{\n  \t\tfoo: 'bar',\n  \t\tbar: 2,\n  \t\tfoobar: [\n  \t\t\t1,\n  \t\t\t2,\n  \t\t\t3\n  \t\t],\n  \t\tcallback: function(){\n  \t\t\treturn true;\n  \t\t}\n  \t}, options||{}));\n  }\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_53()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  (function($){\n  function init(options) {\n  $(this).data(class_name+'_public',$.extend({},{\n  foo: 'bar',\n  bar: 2,\n  foobar: [\n  1,\n  2,\n  3\n  ],\n  callback: function(){\n  return true;\n  }\n  }, options||{}));\n  }\n  })(jQuery);\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  (function($){\n  \tfunction init(options) {\n  \t\t$(this).data(class_name+'_public',$.extend({},{\n  \t\t\tfoo: 'bar',\n  \t\t\tbar: 2,\n  \t\t\tfoobar: [\n  \t\t\t\t1,\n  \t\t\t\t2,\n  \t\t\t\t3\n  \t\t\t],\n  \t\t\tcallback: function(){\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}, options||{}));\n  \t}\n  })(jQuery);\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_54()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1,+2\n\n  let code =<< trim [CODE]\n  JSSTART\n  // Results of JavaScript indent\n  // 1\n  (function(){\n  var a = [\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i'\n  ];\n  }())\n\n  // 2\n  (function(){\n  var a = [\n  0 +\n  5 *\n  9 *\n  'a',\n  'b',\n  0 +\n  5 *\n  9 *\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i'\n  ];\n  }())\n\n  // 3\n  (function(){\n  var a = [\n  0 +\n  // comment 1\n  5 *\n  /* comment 2 */\n  9 *\n  'a',\n  'b',\n  0 +\n  5 *\n  9 *\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i'\n  ];\n  }())\n\n  // 4\n  {\n  var a = [\n  0,\n  1\n  ];\n  var b;\n  var c;\n  }\n\n  // 5\n  {\n  var a = [\n  [\n  0\n  ],\n  2,\n  3\n  ];\n  }\n\n  // 6\n  {\n  var a = [\n  [\n  0,\n  1\n  ],\n  2,\n  3\n  ];\n  }\n\n  // 7\n  {\n  var a = [\n  // [\n  0,\n  // 1\n  // ],\n  2,\n  3\n  ];\n  }\n\n  // 8\n  var x = [\n  (function(){\n  var a,\n  b,\n  c,\n  d,\n  e,\n  f,\n  g,\n  h,\n  i;\n  })\n  ];\n\n  // 9\n  var a = [\n  0 +\n  5 *\n  9 *\n  'a',\n  'b',\n  0 +\n  5 *\n  9 *\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i'\n  ];\n\n  // 10\n  var a,\n  b,\n  c,\n  d,\n  e,\n  f,\n  g,\n  h,\n  i;\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  // Results of JavaScript indent\n  // 1\n  (function(){\n  \tvar a = [\n  \t  'a',\n  \t  'b',\n  \t  'c',\n  \t  'd',\n  \t  'e',\n  \t  'f',\n  \t  'g',\n  \t  'h',\n  \t  'i'\n  \t];\n  }())\n\n  // 2\n  (function(){\n  \tvar a = [\n  \t  0 +\n  \t\t5 *\n  \t\t9 *\n  \t\t'a',\n  \t  'b',\n  \t  0 +\n  \t\t5 *\n  \t\t9 *\n  \t\t'c',\n  \t  'd',\n  \t  'e',\n  \t  'f',\n  \t  'g',\n  \t  'h',\n  \t  'i'\n  \t];\n  }())\n\n  // 3\n  (function(){\n  \tvar a = [\n  \t  0 +\n  \t\t// comment 1\n  \t\t5 *\n  \t\t/* comment 2 */\n  \t\t9 *\n  \t\t'a',\n  \t  'b',\n  \t  0 +\n  \t\t5 *\n  \t\t9 *\n  \t\t'c',\n  \t  'd',\n  \t  'e',\n  \t  'f',\n  \t  'g',\n  \t  'h',\n  \t  'i'\n  \t];\n  }())\n\n  // 4\n  {\n  \tvar a = [\n  \t  0,\n  \t  1\n  \t];\n  \tvar b;\n  \tvar c;\n  }\n\n  // 5\n  {\n  \tvar a = [\n  \t  [\n  \t\t0\n  \t  ],\n  \t  2,\n  \t  3\n  \t];\n  }\n\n  // 6\n  {\n  \tvar a = [\n  \t  [\n  \t\t0,\n  \t\t1\n  \t  ],\n  \t  2,\n  \t  3\n  \t];\n  }\n\n  // 7\n  {\n  \tvar a = [\n  \t  // [\n  \t  0,\n  \t  // 1\n  \t  // ],\n  \t  2,\n  \t  3\n  \t];\n  }\n\n  // 8\n  var x = [\n    (function(){\n  \t  var a,\n  \t  b,\n  \t  c,\n  \t  d,\n  \t  e,\n  \t  f,\n  \t  g,\n  \t  h,\n  \t  i;\n    })\n  ];\n\n  // 9\n  var a = [\n    0 +\n    5 *\n    9 *\n    'a',\n    'b',\n    0 +\n    5 *\n    9 *\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i'\n  ];\n\n  // 10\n  var a,\n  \tb,\n  \tc,\n  \td,\n  \te,\n  \tf,\n  \tg,\n  \th,\n  \ti;\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_55()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  /* start of define */\n  {\n  }\n  #define AAA \\\n  BBB\\\n  CCC\n\n  #define CNT \\\n  1 + \\\n  2 + \\\n  4\n  /* end of define */\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('start of define')\n  exe \"normal =/end of define\\n\"\n\n  let expected =<< trim [CODE]\n  /* start of define */\n  {\n  }\n  #define AAA \\\n  \tBBB\\\n  \tCCC\n\n  #define CNT \\\n  \t1 + \\\n  \t2 + \\\n  \t4\n  /* end of define */\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_56()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  {\n  \ta = second/*bug*/*line;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('a = second')\n  normal ox\n\n  let expected =<< trim [CODE]\n  {\n  \ta = second/*bug*/*line;\n  \tx\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\n\" this was going beyond the end of the line.\nfunc Test_cindent_case()\n  new\n  call setline(1, 'case x: // x')\n  set cindent\n  norm! f:a:\n  call assert_equal('case x:: // x', getline(1))\n  set cindent&\n  bwipe!\nendfunc\n\n\" Test for changing multiple lines (using c) with cindent\nfunc Test_cindent_change_multline()\n  new\n  setlocal cindent\n  call setline(1, ['if (a)', '{', '    i = 1;', '}'])\n  normal! jc3jm = 2;\n  call assert_equal(\"\\tm = 2;\", getline(2))\n  close!\nendfunc\n\nfunc Test_cindent_pragma()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=Ps\n\n  let code =<< trim [CODE]\n  {\n  #pragma omp parallel\n  {\n  #pragma omp task\n  foo();\n  # pragma omp taskwait\n  }\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal =G\n\n  let expected =<< trim [CODE]\n  {\n\t#pragma omp parallel\n\t{\n\t\t#pragma omp task\n\t\tfoo();\n\t\t# pragma omp taskwait\n\t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_backslash_at_end_of_line()\n  new\n  exe \"norm v>O'\\\\\\<C-m>-\"\n  exe \"norm \\<C-q>=\"\n  bwipe!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * cindent.c: C indentation related functions\n *\n * Many of C-indenting functions originally come from Eric Fischer.\n *\n * Below \"XXX\" means that this function may unlock the current line.\n */\n\n#include \"vim.h\"\n\n// values for the \"lookfor\" state\n#define LOOKFOR_INITIAL\t\t0\n#define LOOKFOR_IF\t\t1\n#define LOOKFOR_DO\t\t2\n#define LOOKFOR_CASE\t\t3\n#define LOOKFOR_ANY\t\t4\n#define LOOKFOR_TERM\t\t5\n#define LOOKFOR_UNTERM\t\t6\n#define LOOKFOR_SCOPEDECL\t7\n#define LOOKFOR_NOBREAK\t\t8\n#define LOOKFOR_CPP_BASECLASS\t9\n#define LOOKFOR_ENUM_OR_INIT\t10\n#define LOOKFOR_JS_KEY\t\t11\n#define LOOKFOR_COMMA\t\t12\n\n#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)\n/*\n * Return TRUE if the string \"line\" starts with a word from 'cinwords'.\n */\n    int\ncin_is_cinword(char_u *line)\n{\n    char_u\t*cinw;\n    char_u\t*cinw_buf;\n    int\t\tcinw_len;\n    int\t\tretval = FALSE;\n    int\t\tlen;\n\n    cinw_len = (int)STRLEN(curbuf->b_p_cinw) + 1;\n    cinw_buf = alloc(cinw_len);\n    if (cinw_buf != NULL)\n    {\n\tline = skipwhite(line);\n\tfor (cinw = curbuf->b_p_cinw; *cinw; )\n\t{\n\t    len = copy_option_part(&cinw, cinw_buf, cinw_len, \",\");\n\t    if (STRNCMP(line, cinw_buf, len) == 0\n\t\t    && (!vim_iswordc(line[len]) || !vim_iswordc(line[len - 1])))\n\t    {\n\t\tretval = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tvim_free(cinw_buf);\n    }\n    return retval;\n}\n#endif\n\n#if defined(FEAT_CINDENT) || defined(FEAT_SYN_HL)\n\n/*\n * Skip to the end of a \"string\" and a 'c' character.\n * If there is no string or character, return argument unmodified.\n */\n    static char_u *\nskip_string(char_u *p)\n{\n    int\t    i;\n\n    // We loop, because strings may be concatenated: \"date\"\"time\".\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    // 'c' or '\\n' or '\\000'\n\t{\n\t    if (p[1] == NUL)\t\t    // ' at end of line\n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    // '\\n' or '\\000'\n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   // '\\000'\n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    // check for trailing '\n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    // start of string\n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    // end of string\n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; // continue for another string\n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    // Raw string: R\"[delim](...)[delim]\"\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; // continue for another string\n\t    }\n\t}\n\tbreak;\t\t\t\t    // no string found\n    }\n    if (!*p)\n\t--p;\t\t\t\t    // backup from NUL\n    return p;\n}\n\n/*\n * Find the start of a comment, not knowing if we are in a comment right now.\n * Search starts at w_cursor.lnum and goes backwards.\n * Return NULL when not inside a comment.\n */\n    static pos_T *\nind_find_start_comment(void)\t    // XXX\n{\n    return find_start_comment(curbuf->b_ind_maxcomment);\n}\n\n    pos_T *\nfind_start_comment(int ind_maxcomment)\t// XXX\n{\n    pos_T\t*pos;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcur_maxcomment = ind_maxcomment;\n\n    for (;;)\n    {\n\tpos = findmatchlimit(NULL, '*', FM_BACKWARD, cur_maxcomment);\n\tif (pos == NULL)\n\t    break;\n\n\t// Check if the comment start we found is inside a string.\n\t// If it is then restrict the search to below this line and try again.\n\tline = ml_get(pos->lnum);\n\tfor (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)\n\t    p = skip_string(p);\n\tif ((colnr_T)(p - line) <= pos->col)\n\t    break;\n\tcur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;\n\tif (cur_maxcomment <= 0)\n\t{\n\t    pos = NULL;\n\t    break;\n\t}\n    }\n    return pos;\n}\n\n/*\n * Find the start of a raw string, not knowing if we are in one right now.\n * Search starts at w_cursor.lnum and goes backwards.\n * Return NULL when not inside a raw string.\n */\n    static pos_T *\nfind_start_rawstring(int ind_maxcomment)\t// XXX\n{\n    pos_T\t*pos;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcur_maxcomment = ind_maxcomment;\n\n    for (;;)\n    {\n\tpos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);\n\tif (pos == NULL)\n\t    break;\n\n\t// Check if the raw string start we found is inside a string.\n\t// If it is then restrict the search to below this line and try again.\n\tline = ml_get(pos->lnum);\n\tfor (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)\n\t    p = skip_string(p);\n\tif ((colnr_T)(p - line) <= pos->col)\n\t    break;\n\tcur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;\n\tif (cur_maxcomment <= 0)\n\t{\n\t    pos = NULL;\n\t    break;\n\t}\n    }\n    return pos;\n}\n\n/*\n * Find the start of a comment or raw string, not knowing if we are in a\n * comment or raw string right now.\n * Search starts at w_cursor.lnum and goes backwards.\n * If is_raw is given and returns start of raw_string, sets it to true.\n * Return NULL when not inside a comment or raw string.\n * \"CORS\" -> Comment Or Raw String\n */\n    static pos_T *\nind_find_start_CORS(linenr_T *is_raw)\t    // XXX\n{\n    static pos_T comment_pos_copy;\n    pos_T\t*comment_pos;\n    pos_T\t*rs_pos;\n\n    comment_pos = find_start_comment(curbuf->b_ind_maxcomment);\n    if (comment_pos != NULL)\n    {\n\t// Need to make a copy of the static pos in findmatchlimit(),\n\t// calling find_start_rawstring() may change it.\n\tcomment_pos_copy = *comment_pos;\n\tcomment_pos = &comment_pos_copy;\n    }\n    rs_pos = find_start_rawstring(curbuf->b_ind_maxcomment);\n\n    // If comment_pos is before rs_pos the raw string is inside the comment.\n    // If rs_pos is before comment_pos the comment is inside the raw string.\n    if (comment_pos == NULL || (rs_pos != NULL\n\t\t\t\t\t     && LT_POS(*rs_pos, *comment_pos)))\n    {\n\tif (is_raw != NULL && rs_pos != NULL)\n\t    *is_raw = rs_pos->lnum;\n\treturn rs_pos;\n    }\n    return comment_pos;\n}\n#endif // FEAT_CINDENT || FEAT_SYN_HL\n\n#if defined(FEAT_CINDENT) || defined(PROTO)\n\n/*\n * Return TRUE if C-indenting is on.\n */\n    int\ncindent_on(void)\n{\n    return (!p_paste && (curbuf->b_p_cin\n# ifdef FEAT_EVAL\n\t\t    || *curbuf->b_p_inde != NUL\n# endif\n\t\t    ));\n}\n\n// Find result cache for cpp_baseclass\ntypedef struct {\n    int\t    found;\n    lpos_T  lpos;\n} cpp_baseclass_cache_T;\n\n/*\n * Skip over white space and C comments within the line.\n * Also skip over Perl/shell comments if desired.\n */\n    static char_u *\ncin_skipcomment(char_u *s)\n{\n    while (*s)\n    {\n\tchar_u *prev_s = s;\n\n\ts = skipwhite(s);\n\n\t// Perl/shell # comment comment continues until eol.  Require a space\n\t// before # to avoid recognizing $#array.\n\tif (curbuf->b_ind_hash_comment != 0 && s != prev_s && *s == '#')\n\t{\n\t    s += STRLEN(s);\n\t    break;\n\t}\n\tif (*s != '/')\n\t    break;\n\t++s;\n\tif (*s == '/')\t\t// slash-slash comment continues till eol\n\t{\n\t    s += STRLEN(s);\n\t    break;\n\t}\n\tif (*s != '*')\n\t    break;\n\tfor (++s; *s; ++s)\t// skip slash-star comment\n\t    if (s[0] == '*' && s[1] == '/')\n\t    {\n\t\ts += 2;\n\t\tbreak;\n\t    }\n    }\n    return s;\n}\n\n/*\n * Return TRUE if there is no code at *s.  White space and comments are\n * not considered code.\n */\n    static int\ncin_nocode(char_u *s)\n{\n    return *cin_skipcomment(s) == NUL;\n}\n\n/*\n * Recognize the start of a C or C++ comment.\n */\n    static int\ncin_iscomment(char_u *p)\n{\n    return (p[0] == '/' && (p[1] == '*' || p[1] == '/'));\n}\n\n/*\n * Recognize the start of a \"//\" comment.\n */\n    static int\ncin_islinecomment(char_u *p)\n{\n    return (p[0] == '/' && p[1] == '/');\n}\n\n/*\n * Check previous lines for a \"//\" line comment, skipping over blank lines.\n */\n    static pos_T *\nfind_line_comment(void) // XXX\n{\n    static pos_T pos;\n    char_u\t *line;\n    char_u\t *p;\n\n    pos = curwin->w_cursor;\n    while (--pos.lnum > 0)\n    {\n\tline = ml_get(pos.lnum);\n\tp = skipwhite(line);\n\tif (cin_islinecomment(p))\n\t{\n\t    pos.col = (int)(p - line);\n\t    return &pos;\n\t}\n\tif (*p != NUL)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Return TRUE if \"text\" starts with \"key:\".\n */\n    static int\ncin_has_js_key(char_u *text)\n{\n    char_u *s = skipwhite(text);\n    int\t    quote = -1;\n\n    if (*s == '\\'' || *s == '\"')\n    {\n\t// can be 'key': or \"key\":\n\tquote = *s;\n\t++s;\n    }\n    if (!vim_isIDc(*s))\t    // need at least one ID character\n\treturn FALSE;\n\n    while (vim_isIDc(*s))\n\t++s;\n    if (*s == quote)\n\t++s;\n\n    s = cin_skipcomment(s);\n\n    // \"::\" is not a label, it's C++\n    return (*s == ':' && s[1] != ':');\n}\n\n/*\n * Check if string matches \"label:\"; move to character after ':' if true.\n * \"*s\" must point to the start of the label, if there is one.\n */\n    static int\ncin_islabel_skip(char_u **s)\n{\n    if (!vim_isIDc(**s))\t    // need at least one ID character\n\treturn FALSE;\n\n    while (vim_isIDc(**s))\n\t(*s)++;\n\n    *s = cin_skipcomment(*s);\n\n    // \"::\" is not a label, it's C++\n    return (**s == ':' && *++*s != ':');\n}\n\n/*\n * Recognize a \"public/private/protected\" scope declaration label.\n */\n    static int\ncin_isscopedecl(char_u *s)\n{\n    int\t\ti;\n\n    s = cin_skipcomment(s);\n    if (STRNCMP(s, \"public\", 6) == 0)\n\ti = 6;\n    else if (STRNCMP(s, \"protected\", 9) == 0)\n\ti = 9;\n    else if (STRNCMP(s, \"private\", 7) == 0)\n\ti = 7;\n    else\n\treturn FALSE;\n    return (*(s = cin_skipcomment(s + i)) == ':' && s[1] != ':');\n}\n\n/*\n * Recognize a preprocessor statement: Any line that starts with '#'.\n */\n    static int\ncin_ispreproc(char_u *s)\n{\n    if (*skipwhite(s) == '#')\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE if line \"*pp\" at \"*lnump\" is a preprocessor statement or a\n * continuation line of a preprocessor statement.  Decrease \"*lnump\" to the\n * start and return the line in \"*pp\".\n * Put the amount of indent in \"*amount\".\n */\n    static int\ncin_ispreproc_cont(char_u **pp, linenr_T *lnump, int *amount)\n{\n    char_u\t*line = *pp;\n    linenr_T\tlnum = *lnump;\n    int\t\tretval = FALSE;\n    int\t\tcandidate_amount = *amount;\n\n    if (*line != NUL && line[STRLEN(line) - 1] == '\\\\')\n\tcandidate_amount = get_indent_lnum(lnum);\n\n    for (;;)\n    {\n\tif (cin_ispreproc(line))\n\t{\n\t    retval = TRUE;\n\t    *lnump = lnum;\n\t    break;\n\t}\n\tif (lnum == 1)\n\t    break;\n\tline = ml_get(--lnum);\n\tif (*line == NUL || line[STRLEN(line) - 1] != '\\\\')\n\t    break;\n    }\n\n    if (lnum != *lnump)\n\t*pp = ml_get(*lnump);\n    if (retval)\n\t*amount = candidate_amount;\n    return retval;\n}\n\n    static int\ncin_iselse(\n    char_u  *p)\n{\n    if (*p == '}')\t    // accept \"} else\"\n\tp = cin_skipcomment(p + 1);\n    return (STRNCMP(p, \"else\", 4) == 0 && !vim_isIDc(p[4]));\n}\n\n/*\n * Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or\n * '}'.\n * Don't consider \"} else\" a terminated line.\n * If a line begins with an \"else\", only consider it terminated if no unmatched\n * opening braces follow (handle \"else { foo();\" correctly).\n * Return the character terminating the line (ending char's have precedence if\n * both apply in order to determine initializations).\n */\n    static int\ncin_isterminated(\n    char_u\t*s,\n    int\t\tincl_open,\t// include '{' at the end as terminator\n    int\t\tincl_comma)\t// recognize a trailing comma\n{\n    char_u\tfound_start = 0;\n    unsigned\tn_open = 0;\n    int\t\tis_else = FALSE;\n\n    s = cin_skipcomment(s);\n\n    if (*s == '{' || (*s == '}' && !cin_iselse(s)))\n\tfound_start = *s;\n\n    if (!found_start)\n\tis_else = cin_iselse(s);\n\n    while (*s)\n    {\n\t// skip over comments, \"\" strings and 'c'haracters\n\ts = skip_string(cin_skipcomment(s));\n\tif (*s == '}' && n_open > 0)\n\t    --n_open;\n\tif ((!is_else || n_open == 0)\n\t\t&& (*s == ';' || *s == '}' || (incl_comma && *s == ','))\n\t\t&& cin_nocode(s + 1))\n\t    return *s;\n\telse if (*s == '{')\n\t{\n\t    if (incl_open && cin_nocode(s + 1))\n\t\treturn *s;\n\t    else\n\t\t++n_open;\n\t}\n\n\tif (*s)\n\t    s++;\n    }\n    return found_start;\n}\n\n/*\n * Return TRUE when \"s\" starts with \"word\" and then a non-ID character.\n */\n    static int\ncin_starts_with(char_u *s, char *word)\n{\n    int l = (int)STRLEN(word);\n\n    return (STRNCMP(s, word, l) == 0 && !vim_isIDc(s[l]));\n}\n\n/*\n * Recognize a \"default\" switch label.\n */\n    static int\ncin_isdefault(char_u *s)\n{\n    return (STRNCMP(s, \"default\", 7) == 0\n\t    && *(s = cin_skipcomment(s + 7)) == ':'\n\t    && s[1] != ':');\n}\n\n/*\n * Recognize a switch label: \"case .*:\" or \"default:\".\n */\n     static int\ncin_iscase(\n    char_u *s,\n    int strict) // Allow relaxed check of case statement for JS\n{\n    s = cin_skipcomment(s);\n    if (cin_starts_with(s, \"case\"))\n    {\n\tfor (s += 4; *s; ++s)\n\t{\n\t    s = cin_skipcomment(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\t    if (*s == ':')\n\t    {\n\t\tif (s[1] == ':')\t// skip over \"::\" for C++\n\t\t    ++s;\n\t\telse\n\t\t    return TRUE;\n\t    }\n\t    if (*s == '\\'' && s[1] && s[2] == '\\'')\n\t\ts += 2;\t\t\t// skip over ':'\n\t    else if (*s == '/' && (s[1] == '*' || s[1] == '/'))\n\t\treturn FALSE;\t\t// stop at comment\n\t    else if (*s == '\"')\n\t    {\n\t\t// JS etc.\n\t\tif (strict)\n\t\t    return FALSE;\t\t// stop at string\n\t\telse\n\t\t    return TRUE;\n\t    }\n\t}\n\treturn FALSE;\n    }\n\n    if (cin_isdefault(s))\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Recognize a label: \"label:\".\n * Note: curwin->w_cursor must be where we are looking for the label.\n */\n    static int\ncin_islabel(void)\t\t// XXX\n{\n    char_u\t*s;\n\n    s = cin_skipcomment(ml_get_curline());\n\n    // Exclude \"default\" from labels, since it should be indented\n    // like a switch label.  Same for C++ scope declarations.\n    if (cin_isdefault(s))\n\treturn FALSE;\n    if (cin_isscopedecl(s))\n\treturn FALSE;\n\n    if (cin_islabel_skip(&s))\n    {\n\t// Only accept a label if the previous line is terminated or is a case\n\t// label.\n\tpos_T\tcursor_save;\n\tpos_T\t*trypos;\n\tchar_u\t*line;\n\n\tcursor_save = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1)\n\t{\n\t    --curwin->w_cursor.lnum;\n\n\t    // If we're in a comment or raw string now, skip to the start of\n\t    // it.\n\t    curwin->w_cursor.col = 0;\n\t    if ((trypos = ind_find_start_CORS(NULL)) != NULL) // XXX\n\t\tcurwin->w_cursor = *trypos;\n\n\t    line = ml_get_curline();\n\t    if (cin_ispreproc(line))\t// ignore #defines, #if, etc.\n\t\tcontinue;\n\t    if (*(line = cin_skipcomment(line)) == NUL)\n\t\tcontinue;\n\n\t    curwin->w_cursor = cursor_save;\n\t    if (cin_isterminated(line, TRUE, FALSE)\n\t\t    || cin_isscopedecl(line)\n\t\t    || cin_iscase(line, TRUE)\n\t\t    || (cin_islabel_skip(&line) && cin_nocode(line)))\n\t\treturn TRUE;\n\t    return FALSE;\n\t}\n\tcurwin->w_cursor = cursor_save;\n\treturn TRUE;\t\t// label at start of file???\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if string \"s\" ends with the string \"find\", possibly followed by\n * white space and comments.  Skip strings and comments.\n * Ignore \"ignore\" after \"find\" if it's not NULL.\n */\n    static int\ncin_ends_in(char_u *s, char_u *find, char_u *ignore)\n{\n    char_u\t*p = s;\n    char_u\t*r;\n    int\t\tlen = (int)STRLEN(find);\n\n    while (*p != NUL)\n    {\n\tp = cin_skipcomment(p);\n\tif (STRNCMP(p, find, len) == 0)\n\t{\n\t    r = skipwhite(p + len);\n\t    if (ignore != NULL && STRNCMP(r, ignore, STRLEN(ignore)) == 0)\n\t\tr = skipwhite(r + STRLEN(ignore));\n\t    if (cin_nocode(r))\n\t\treturn TRUE;\n\t}\n\tif (*p != NUL)\n\t    ++p;\n    }\n    return FALSE;\n}\n\n/*\n * Recognize structure initialization and enumerations:\n * \"[typedef] [static|public|protected|private] enum\"\n * \"[typedef] [static|public|protected|private] = {\"\n */\n    static int\ncin_isinit(void)\n{\n    char_u\t*s;\n    static char *skip[] = {\"static\", \"public\", \"protected\", \"private\"};\n\n    s = cin_skipcomment(ml_get_curline());\n\n    if (cin_starts_with(s, \"typedef\"))\n\ts = cin_skipcomment(s + 7);\n\n    for (;;)\n    {\n\tint i, l;\n\n\tfor (i = 0; i < (int)ARRAY_LENGTH(skip); ++i)\n\t{\n\t    l = (int)strlen(skip[i]);\n\t    if (cin_starts_with(s, skip[i]))\n\t    {\n\t\ts = cin_skipcomment(s + l);\n\t\tl = 0;\n\t\tbreak;\n\t    }\n\t}\n\tif (l != 0)\n\t    break;\n    }\n\n    if (cin_starts_with(s, \"enum\"))\n\treturn TRUE;\n\n    if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))\n\treturn TRUE;\n\n    return FALSE;\n}\n\n// Maximum number of lines to search back for a \"namespace\" line.\n#define FIND_NAMESPACE_LIM 20\n\n/*\n * Recognize a \"namespace\" scope declaration.\n */\n    static int\ncin_is_cpp_namespace(char_u *s)\n{\n    char_u\t*p;\n    int\t\thas_name = FALSE;\n    int\t\thas_name_start = FALSE;\n\n    s = cin_skipcomment(s);\n    if (STRNCMP(s, \"namespace\", 9) == 0 && (s[9] == NUL || !vim_iswordc(s[9])))\n    {\n\tp = cin_skipcomment(skipwhite(s + 9));\n\twhile (*p != NUL)\n\t{\n\t    if (VIM_ISWHITE(*p))\n\t    {\n\t\thas_name = TRUE; // found end of a name\n\t\tp = cin_skipcomment(skipwhite(p));\n\t    }\n\t    else if (*p == '{')\n\t    {\n\t\tbreak;\n\t    }\n\t    else if (vim_iswordc(*p))\n\t    {\n\t\thas_name_start = TRUE;\n\t\tif (has_name)\n\t\t    return FALSE; // word character after skipping past name\n\t\t++p;\n\t    }\n\t    else if (p[0] == ':' && p[1] == ':' && vim_iswordc(p[2]))\n\t    {\n\t\tif (!has_name_start || has_name)\n\t\t    return FALSE;\n\t\t// C++ 17 nested namespace\n\t\tp += 3;\n\t    }\n\t    else\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Recognize a `extern \"C\"` or `extern \"C++\"` linkage specifications.\n */\n    static int\ncin_is_cpp_extern_c(char_u *s)\n{\n    char_u\t*p;\n    int\t\thas_string_literal = FALSE;\n\n    s = cin_skipcomment(s);\n    if (STRNCMP(s, \"extern\", 6) == 0 && (s[6] == NUL || !vim_iswordc(s[6])))\n    {\n\tp = cin_skipcomment(skipwhite(s + 6));\n\twhile (*p != NUL)\n\t{\n\t    if (VIM_ISWHITE(*p))\n\t    {\n\t\tp = cin_skipcomment(skipwhite(p));\n\t    }\n\t    else if (*p == '{')\n\t    {\n\t\tbreak;\n\t    }\n\t    else if (p[0] == '\"' && p[1] == 'C' && p[2] == '\"')\n\t    {\n\t\tif (has_string_literal)\n\t\t    return FALSE;\n\t\thas_string_literal = TRUE;\n\t\tp += 3;\n\t    }\n\t    else if (p[0] == '\"' && p[1] == 'C' && p[2] == '+' && p[3] == '+'\n\t\t    && p[4] == '\"')\n\t    {\n\t\tif (has_string_literal)\n\t\t    return FALSE;\n\t\thas_string_literal = TRUE;\n\t\tp += 5;\n\t    }\n\t    else\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\treturn has_string_literal ? TRUE : FALSE;\n    }\n    return FALSE;\n}\n\n/*\n * Return a pointer to the first non-empty non-comment character after a ':'.\n * Return NULL if not found.\n *\t  case 234:    a = b;\n *\t\t       ^\n */\n    static char_u *\nafter_label(char_u *l)\n{\n    for ( ; *l; ++l)\n    {\n\tif (*l == ':')\n\t{\n\t    if (l[1] == ':')\t    // skip over \"::\" for C++\n\t\t++l;\n\t    else if (!cin_iscase(l + 1, FALSE))\n\t\tbreak;\n\t}\n\telse if (*l == '\\'' && l[1] && l[2] == '\\'')\n\t    l += 2;\t\t    // skip over 'x'\n    }\n    if (*l == NUL)\n\treturn NULL;\n    l = cin_skipcomment(l + 1);\n    if (*l == NUL)\n\treturn NULL;\n    return l;\n}\n\n/*\n * Get indent of line \"lnum\", skipping a label.\n * Return 0 if there is nothing after the label.\n */\n    static int\nget_indent_nolabel (linenr_T lnum)\t// XXX\n{\n    char_u\t*l;\n    pos_T\tfp;\n    colnr_T\tcol;\n    char_u\t*p;\n\n    l = ml_get(lnum);\n    p = after_label(l);\n    if (p == NULL)\n\treturn 0;\n\n    fp.col = (colnr_T)(p - l);\n    fp.lnum = lnum;\n    getvcol(curwin, &fp, &col, NULL, NULL);\n    return (int)col;\n}\n\n/*\n * Find indent for line \"lnum\", ignoring any case or jump label.\n * Also return a pointer to the text (after the label) in \"pp\".\n *   label:\tif (asdf && asdfasdf)\n *\t\t^\n */\n    static int\nskip_label(linenr_T lnum, char_u **pp)\n{\n    char_u\t*l;\n    int\t\tamount;\n    pos_T\tcursor_save;\n\n    cursor_save = curwin->w_cursor;\n    curwin->w_cursor.lnum = lnum;\n    l = ml_get_curline();\n\t\t\t\t    // XXX\n    if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel())\n    {\n\tamount = get_indent_nolabel(lnum);\n\tl = after_label(ml_get_curline());\n\tif (l == NULL)\t\t// just in case\n\t    l = ml_get_curline();\n    }\n    else\n    {\n\tamount = get_indent();\n\tl = ml_get_curline();\n    }\n    *pp = l;\n\n    curwin->w_cursor = cursor_save;\n    return amount;\n}\n\n/*\n * Return the indent of the first variable name after a type in a declaration.\n *  int\t    a,\t\t\tindent of \"a\"\n *  static struct foo    b,\tindent of \"b\"\n *  enum bla    c,\t\tindent of \"c\"\n * Returns zero when it doesn't look like a declaration.\n */\n    static int\ncin_first_id_amount(void)\n{\n    char_u\t*line, *p, *s;\n    int\t\tlen;\n    pos_T\tfp;\n    colnr_T\tcol;\n\n    line = ml_get_curline();\n    p = skipwhite(line);\n    len = (int)(skiptowhite(p) - p);\n    if (len == 6 && STRNCMP(p, \"static\", 6) == 0)\n    {\n\tp = skipwhite(p + 6);\n\tlen = (int)(skiptowhite(p) - p);\n    }\n    if (len == 6 && STRNCMP(p, \"struct\", 6) == 0)\n\tp = skipwhite(p + 6);\n    else if (len == 4 && STRNCMP(p, \"enum\", 4) == 0)\n\tp = skipwhite(p + 4);\n    else if ((len == 8 && STRNCMP(p, \"unsigned\", 8) == 0)\n\t    || (len == 6 && STRNCMP(p, \"signed\", 6) == 0))\n    {\n\ts = skipwhite(p + len);\n\tif ((STRNCMP(s, \"int\", 3) == 0 && VIM_ISWHITE(s[3]))\n\t\t|| (STRNCMP(s, \"long\", 4) == 0 && VIM_ISWHITE(s[4]))\n\t\t|| (STRNCMP(s, \"short\", 5) == 0 && VIM_ISWHITE(s[5]))\n\t\t|| (STRNCMP(s, \"char\", 4) == 0 && VIM_ISWHITE(s[4])))\n\t    p = s;\n    }\n    for (len = 0; vim_isIDc(p[len]); ++len)\n\t;\n    if (len == 0 || !VIM_ISWHITE(p[len]) || cin_nocode(p))\n\treturn 0;\n\n    p = skipwhite(p + len);\n    fp.lnum = curwin->w_cursor.lnum;\n    fp.col = (colnr_T)(p - line);\n    getvcol(curwin, &fp, &col, NULL, NULL);\n    return (int)col;\n}\n\n/*\n * Return the indent of the first non-blank after an equal sign.\n *       char *foo = \"here\";\n * Return zero if no (useful) equal sign found.\n * Return -1 if the line above \"lnum\" ends in a backslash.\n *      foo = \"asdf\\\n *\t       asdf\\\n *\t       here\";\n */\n    static int\ncin_get_equal_amount(linenr_T lnum)\n{\n    char_u\t*line;\n    char_u\t*s;\n    colnr_T\tcol;\n    pos_T\tfp;\n\n    if (lnum > 1)\n    {\n\tline = ml_get(lnum - 1);\n\tif (*line != NUL && line[STRLEN(line) - 1] == '\\\\')\n\t    return -1;\n    }\n\n    line = s = ml_get(lnum);\n    while (*s != NUL && vim_strchr((char_u *)\"=;{}\\\"'\", *s) == NULL)\n    {\n\tif (cin_iscomment(s))\t// ignore comments\n\t    s = cin_skipcomment(s);\n\telse\n\t    ++s;\n    }\n    if (*s != '=')\n\treturn 0;\n\n    s = skipwhite(s + 1);\n    if (cin_nocode(s))\n\treturn 0;\n\n    if (*s == '\"')\t// nice alignment for continued strings\n\t++s;\n\n    fp.lnum = lnum;\n    fp.col = (colnr_T)(s - line);\n    getvcol(curwin, &fp, &col, NULL, NULL);\n    return (int)col;\n}\n\n/*\n * Skip strings, chars and comments until at or past \"trypos\".\n * Return the column found.\n */\n    static int\ncin_skip2pos(pos_T *trypos)\n{\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*new_p;\n\n    p = line = ml_get(trypos->lnum);\n    while (*p && (colnr_T)(p - line) < trypos->col)\n    {\n\tif (cin_iscomment(p))\n\t    p = cin_skipcomment(p);\n\telse\n\t{\n\t    new_p = skip_string(p);\n\t    if (new_p == p)\n\t\t++p;\n\t    else\n\t\tp = new_p;\n\t}\n    }\n    return (int)(p - line);\n}\n\n    static pos_T *\nfind_match_char(int c, int ind_maxparen)\t// XXX\n{\n    pos_T\tcursor_save;\n    pos_T\t*trypos;\n    static pos_T pos_copy;\n    int\t\tind_maxp_wk;\n\n    cursor_save = curwin->w_cursor;\n    ind_maxp_wk = ind_maxparen;\nretry:\n    if ((trypos = findmatchlimit(NULL, c, 0, ind_maxp_wk)) != NULL)\n    {\n\t// check if the ( is in a // comment\n\tif ((colnr_T)cin_skip2pos(trypos) > trypos->col)\n\t{\n\t    ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos->lnum);\n\t    if (ind_maxp_wk > 0)\n\t    {\n\t\tcurwin->w_cursor = *trypos;\n\t\tcurwin->w_cursor.col = 0;\t// XXX\n\t\tgoto retry;\n\t    }\n\t    trypos = NULL;\n\t}\n\telse\n\t{\n\t    pos_T\t*trypos_wk;\n\n\t    pos_copy = *trypos;\t    // copy trypos, findmatch will change it\n\t    trypos = &pos_copy;\n\t    curwin->w_cursor = *trypos;\n\t    if ((trypos_wk = ind_find_start_CORS(NULL)) != NULL) // XXX\n\t    {\n\t\tind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum\n\t\t\t- trypos_wk->lnum);\n\t\tif (ind_maxp_wk > 0)\n\t\t{\n\t\t    curwin->w_cursor = *trypos_wk;\n\t\t    goto retry;\n\t\t}\n\t\ttrypos = NULL;\n\t    }\n\t}\n    }\n    curwin->w_cursor = cursor_save;\n    return trypos;\n}\n\n/*\n * Find the matching '(', ignoring it if it is in a comment.\n * Return NULL if no match found.\n */\n    static pos_T *\nfind_match_paren(int ind_maxparen)\t// XXX\n{\n    return find_match_char('(', ind_maxparen);\n}\n\n/*\n * Set w_cursor.col to the column number of the last unmatched ')' or '{' in\n * line \"l\".  \"l\" must point to the start of the line.\n */\n    static int\nfind_last_paren(char_u *l, int start, int end)\n{\n    int\t\ti;\n    int\t\tretval = FALSE;\n    int\t\topen_count = 0;\n\n    curwin->w_cursor.col = 0;\t\t    // default is start of line\n\n    for (i = 0; l[i] != NUL; i++)\n    {\n\ti = (int)(cin_skipcomment(l + i) - l); // ignore parens in comments\n\ti = (int)(skip_string(l + i) - l);    // ignore parens in quotes\n\tif (l[i] == start)\n\t    ++open_count;\n\telse if (l[i] == end)\n\t{\n\t    if (open_count > 0)\n\t\t--open_count;\n\t    else\n\t    {\n\t\tcurwin->w_cursor.col = i;\n\t\tretval = TRUE;\n\t    }\n\t}\n    }\n    return retval;\n}\n\n/*\n * Recognize the basic picture of a function declaration -- it needs to\n * have an open paren somewhere and a close paren at the end of the line and\n * no semicolons anywhere.\n * When a line ends in a comma we continue looking in the next line.\n * \"sp\" points to a string with the line.  When looking at other lines it must\n * be restored to the line.  When it's NULL fetch lines here.\n * \"first_lnum\" is where we start looking.\n * \"min_lnum\" is the line before which we will not be looking.\n */\n    static int\ncin_isfuncdecl(\n    char_u\t**sp,\n    linenr_T\tfirst_lnum,\n    linenr_T\tmin_lnum)\n{\n    char_u\t*s;\n    linenr_T\tlnum = first_lnum;\n    linenr_T\tsave_lnum = curwin->w_cursor.lnum;\n    int\t\tretval = FALSE;\n    pos_T\t*trypos;\n    int\t\tjust_started = TRUE;\n\n    if (sp == NULL)\n\ts = ml_get(lnum);\n    else\n\ts = *sp;\n\n    curwin->w_cursor.lnum = lnum;\n    if (find_last_paren(s, '(', ')')\n\t&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)\n    {\n\tlnum = trypos->lnum;\n\tif (lnum < min_lnum)\n\t{\n\t    curwin->w_cursor.lnum = save_lnum;\n\t    return FALSE;\n\t}\n\n\ts = ml_get(lnum);\n    }\n    curwin->w_cursor.lnum = save_lnum;\n\n    // Ignore line starting with #.\n    if (cin_ispreproc(s))\n\treturn FALSE;\n\n    while (*s && *s != '(' && *s != ';' && *s != '\\'' && *s != '\"')\n    {\n\tif (cin_iscomment(s))\t// ignore comments\n\t    s = cin_skipcomment(s);\n\telse if (*s == ':')\n\t{\n\t    if (*(s + 1) == ':')\n\t\ts += 2;\n\t    else\n\t\t// To avoid a mistake in the following situation:\n\t\t// A::A(int a, int b)\n\t\t//     : a(0)  // <--not a function decl\n\t\t//     , b(0)\n\t\t// {...\n\t\treturn FALSE;\n\t}\n\telse\n\t    ++s;\n    }\n    if (*s != '(')\n\treturn FALSE;\t\t// ';', ' or \"  before any () or no '('\n\n    while (*s && *s != ';' && *s != '\\'' && *s != '\"')\n    {\n\tif (*s == ')' && cin_nocode(s + 1))\n\t{\n\t    // ')' at the end: may have found a match\n\t    // Check for he previous line not to end in a backslash:\n\t    //       #if defined(x) && {backslash}\n\t    //\t\t defined(y)\n\t    lnum = first_lnum - 1;\n\t    s = ml_get(lnum);\n\t    if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')\n\t\tretval = TRUE;\n\t    goto done;\n\t}\n\tif ((*s == ',' && cin_nocode(s + 1)) || s[1] == NUL || cin_nocode(s))\n\t{\n\t    int comma = (*s == ',');\n\n\t    // ',' at the end: continue looking in the next line.\n\t    // At the end: check for ',' in the next line, for this style:\n\t    // func(arg1\n\t    //       , arg2)\n\t    for (;;)\n\t    {\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t\ts = ml_get(++lnum);\n\t\tif (!cin_ispreproc(s))\n\t\t    break;\n\t    }\n\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\tbreak;\n\t    // Require a comma at end of the line or a comma or ')' at the\n\t    // start of next line.\n\t    s = skipwhite(s);\n\t    if (!just_started && (!comma && *s != ',' && *s != ')'))\n\t\tbreak;\n\t    just_started = FALSE;\n\t}\n\telse if (cin_iscomment(s))\t// ignore comments\n\t    s = cin_skipcomment(s);\n\telse\n\t{\n\t    ++s;\n\t    just_started = FALSE;\n\t}\n    }\n\ndone:\n    if (lnum != first_lnum && sp != NULL)\n\t*sp = ml_get(first_lnum);\n\n    return retval;\n}\n\n    static int\ncin_isif(char_u *p)\n{\n return (STRNCMP(p, \"if\", 2) == 0 && !vim_isIDc(p[2]));\n}\n\n    static int\ncin_isdo(char_u *p)\n{\n    return (STRNCMP(p, \"do\", 2) == 0 && !vim_isIDc(p[2]));\n}\n\n/*\n * Check if this is a \"while\" that should have a matching \"do\".\n * We only accept a \"while (condition) ;\", with only white space between the\n * ')' and ';'. The condition may be spread over several lines.\n */\n    static int\ncin_iswhileofdo (char_u *p, linenr_T lnum)\t// XXX\n{\n    pos_T\tcursor_save;\n    pos_T\t*trypos;\n    int\t\tretval = FALSE;\n\n    p = cin_skipcomment(p);\n    if (*p == '}')\t\t// accept \"} while (cond);\"\n\tp = cin_skipcomment(p + 1);\n    if (cin_starts_with(p, \"while\"))\n    {\n\tcursor_save = curwin->w_cursor;\n\tcurwin->w_cursor.lnum = lnum;\n\tcurwin->w_cursor.col = 0;\n\tp = ml_get_curline();\n\twhile (*p && *p != 'w')\t// skip any '}', until the 'w' of the \"while\"\n\t{\n\t    ++p;\n\t    ++curwin->w_cursor.col;\n\t}\n\tif ((trypos = findmatchlimit(NULL, 0, 0,\n\t\t\t\t\t      curbuf->b_ind_maxparen)) != NULL\n\t\t&& *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')\n\t    retval = TRUE;\n\tcurwin->w_cursor = cursor_save;\n    }\n    return retval;\n}\n\n/*\n * Check whether in \"p\" there is an \"if\", \"for\" or \"while\" before \"*poffset\".\n * Return 0 if there is none.\n * Otherwise return !0 and update \"*poffset\" to point to the place where the\n * string was found.\n */\n    static int\ncin_is_if_for_while_before_offset(char_u *line, int *poffset)\n{\n    int offset = *poffset;\n\n    if (offset-- < 2)\n\treturn 0;\n    while (offset > 2 && VIM_ISWHITE(line[offset]))\n\t--offset;\n\n    offset -= 1;\n    if (!STRNCMP(line + offset, \"if\", 2))\n\tgoto probablyFound;\n\n    if (offset >= 1)\n    {\n\toffset -= 1;\n\tif (!STRNCMP(line + offset, \"for\", 3))\n\t    goto probablyFound;\n\n\tif (offset >= 2)\n\t{\n\t    offset -= 2;\n\t    if (!STRNCMP(line + offset, \"while\", 5))\n\t\tgoto probablyFound;\n\t}\n    }\n    return 0;\n\nprobablyFound:\n    if (!offset || !vim_isIDc(line[offset - 1]))\n    {\n\t*poffset = offset;\n\treturn 1;\n    }\n    return 0;\n}\n\n/*\n * Return TRUE if we are at the end of a do-while.\n *    do\n *       nothing;\n *    while (foo\n *\t       && bar);  <-- here\n * Adjust the cursor to the line with \"while\".\n */\n    static int\ncin_iswhileofdo_end(int terminated)\n{\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*s;\n    pos_T\t*trypos;\n    int\t\ti;\n\n    if (terminated != ';')\t// there must be a ';' at the end\n\treturn FALSE;\n\n    p = line = ml_get_curline();\n    while (*p != NUL)\n    {\n\tp = cin_skipcomment(p);\n\tif (*p == ')')\n\t{\n\t    s = skipwhite(p + 1);\n\t    if (*s == ';' && cin_nocode(s + 1))\n\t    {\n\t\t// Found \");\" at end of the line, now check there is \"while\"\n\t\t// before the matching '('.  XXX\n\t\ti = (int)(p - line);\n\t\tcurwin->w_cursor.col = i;\n\t\ttrypos = find_match_paren(curbuf->b_ind_maxparen);\n\t\tif (trypos != NULL)\n\t\t{\n\t\t    s = cin_skipcomment(ml_get(trypos->lnum));\n\t\t    if (*s == '}')\t\t// accept \"} while (cond);\"\n\t\t\ts = cin_skipcomment(s + 1);\n\t\t    if (cin_starts_with(s, \"while\"))\n\t\t    {\n\t\t\tcurwin->w_cursor.lnum = trypos->lnum;\n\t\t\treturn TRUE;\n\t\t    }\n\t\t}\n\n\t\t// Searching may have made \"line\" invalid, get it again.\n\t\tline = ml_get_curline();\n\t\tp = line + i;\n\t    }\n\t}\n\tif (*p != NUL)\n\t    ++p;\n    }\n    return FALSE;\n}\n\n    static int\ncin_isbreak(char_u *p)\n{\n    return (STRNCMP(p, \"break\", 5) == 0 && !vim_isIDc(p[5]));\n}\n\n/*\n * Find the position of a C++ base-class declaration or\n * constructor-initialization. eg:\n *\n * class MyClass :\n *\tbaseClass\t\t<-- here\n * class MyClass : public baseClass,\n *\tanotherBaseClass\t<-- here (should probably lineup ??)\n * MyClass::MyClass(...) :\n *\tbaseClass(...)\t\t<-- here (constructor-initialization)\n *\n * This is a lot of guessing.  Watch out for \"cond ? func() : foo\".\n */\n    static int\ncin_is_cpp_baseclass(\n    cpp_baseclass_cache_T *cached) // input and output\n{\n    lpos_T\t*pos = &cached->lpos;\t    // find position\n    char_u\t*s;\n    int\t\tclass_or_struct, lookfor_ctor_init, cpp_base_class;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    char_u\t*line = ml_get_curline();\n\n    if (pos->lnum <= lnum)\n\treturn cached->found;\t// Use the cached result\n\n    pos->col = 0;\n\n    s = skipwhite(line);\n    if (*s == '#')\t\t// skip #define FOO x ? (x) : x\n\treturn FALSE;\n    s = cin_skipcomment(s);\n    if (*s == NUL)\n\treturn FALSE;\n\n    cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;\n\n    // Search for a line starting with '#', empty, ending in ';' or containing\n    // '{' or '}' and start below it.  This handles the following situations:\n    //\ta = cond ?\n    //\t      func() :\n    //\t\t   asdf;\n    //\tfunc::foo()\n    //\t      : something\n    //\t{}\n    //\tFoo::Foo (int one, int two)\n    //\t\t: something(4),\n    //\t\tsomethingelse(3)\n    //\t{}\n    while (lnum > 1)\n    {\n\tline = ml_get(lnum - 1);\n\ts = skipwhite(line);\n\tif (*s == '#' || *s == NUL)\n\t    break;\n\twhile (*s != NUL)\n\t{\n\t    s = cin_skipcomment(s);\n\t    if (*s == '{' || *s == '}'\n\t\t    || (*s == ';' && cin_nocode(s + 1)))\n\t\tbreak;\n\t    if (*s != NUL)\n\t\t++s;\n\t}\n\tif (*s != NUL)\n\t    break;\n\t--lnum;\n    }\n\n    pos->lnum = lnum;\n    line = ml_get(lnum);\n    s = line;\n    for (;;)\n    {\n\tif (*s == NUL)\n\t{\n\t    if (lnum == curwin->w_cursor.lnum)\n\t\tbreak;\n\t    // Continue in the cursor line.\n\t    line = ml_get(++lnum);\n\t    s = line;\n\t}\n\tif (s == line)\n\t{\n\t    // don't recognize \"case (foo):\" as a baseclass\n\t    if (cin_iscase(s, FALSE))\n\t\tbreak;\n\t    s = cin_skipcomment(line);\n\t    if (*s == NUL)\n\t\tcontinue;\n\t}\n\n\tif (s[0] == '\"' || (s[0] == 'R' && s[1] == '\"'))\n\t    s = skip_string(s) + 1;\n\telse if (s[0] == ':')\n\t{\n\t    if (s[1] == ':')\n\t    {\n\t\t// skip double colon. It can't be a constructor\n\t\t// initialization any more\n\t\tlookfor_ctor_init = FALSE;\n\t\ts = cin_skipcomment(s + 2);\n\t    }\n\t    else if (lookfor_ctor_init || class_or_struct)\n\t    {\n\t\t// we have something found, that looks like the start of\n\t\t// cpp-base-class-declaration or constructor-initialization\n\t\tcpp_base_class = TRUE;\n\t\tlookfor_ctor_init = class_or_struct = FALSE;\n\t\tpos->col = 0;\n\t\ts = cin_skipcomment(s + 1);\n\t    }\n\t    else\n\t\ts = cin_skipcomment(s + 1);\n\t}\n\telse if ((STRNCMP(s, \"class\", 5) == 0 && !vim_isIDc(s[5]))\n\t\t|| (STRNCMP(s, \"struct\", 6) == 0 && !vim_isIDc(s[6])))\n\t{\n\t    class_or_struct = TRUE;\n\t    lookfor_ctor_init = FALSE;\n\n\t    if (*s == 'c')\n\t\ts = cin_skipcomment(s + 5);\n\t    else\n\t\ts = cin_skipcomment(s + 6);\n\t}\n\telse\n\t{\n\t    if (s[0] == '{' || s[0] == '}' || s[0] == ';')\n\t    {\n\t\tcpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;\n\t    }\n\t    else if (s[0] == ')')\n\t    {\n\t\t// Constructor-initialization is assumed if we come across\n\t\t// something like \"):\"\n\t\tclass_or_struct = FALSE;\n\t\tlookfor_ctor_init = TRUE;\n\t    }\n\t    else if (s[0] == '?')\n\t    {\n\t\t// Avoid seeing '() :' after '?' as constructor init.\n\t\treturn FALSE;\n\t    }\n\t    else if (!vim_isIDc(s[0]))\n\t    {\n\t\t// if it is not an identifier, we are wrong\n\t\tclass_or_struct = FALSE;\n\t\tlookfor_ctor_init = FALSE;\n\t    }\n\t    else if (pos->col == 0)\n\t    {\n\t\t// it can't be a constructor-initialization any more\n\t\tlookfor_ctor_init = FALSE;\n\n\t\t// the first statement starts here: lineup with this one...\n\t\tif (cpp_base_class)\n\t\t    pos->col = (colnr_T)(s - line);\n\t    }\n\n\t    // When the line ends in a comma don't align with it.\n\t    if (lnum == curwin->w_cursor.lnum && *s == ',' && cin_nocode(s + 1))\n\t\tpos->col = 0;\n\n\t    s = cin_skipcomment(s + 1);\n\t}\n    }\n\n    cached->found = cpp_base_class;\n    if (cpp_base_class)\n\tpos->lnum = lnum;\n    return cpp_base_class;\n}\n\n    static int\nget_baseclass_amount(int col)\n{\n    int\t\tamount;\n    colnr_T\tvcol;\n    pos_T\t*trypos;\n\n    if (col == 0)\n    {\n\tamount = get_indent();\n\tif (find_last_paren(ml_get_curline(), '(', ')')\n\t\t&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)\n\t    amount = get_indent_lnum(trypos->lnum); // XXX\n\tif (!cin_ends_in(ml_get_curline(), (char_u *)\",\", NULL))\n\t    amount += curbuf->b_ind_cpp_baseclass;\n    }\n    else\n    {\n\tcurwin->w_cursor.col = col;\n\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\tamount = (int)vcol;\n    }\n    if (amount < curbuf->b_ind_cpp_baseclass)\n\tamount = curbuf->b_ind_cpp_baseclass;\n    return amount;\n}\n\n/*\n * Find the '{' at the start of the block we are in.\n * Return NULL if no match found.\n * Ignore a '{' that is in a comment, makes indenting the next three lines\n * work.\n */\n// foo()\n// {\n// }\n\n    static pos_T *\nfind_start_brace(void)\t    // XXX\n{\n    pos_T\t    cursor_save;\n    pos_T\t    *trypos;\n    pos_T\t    *pos;\n    static pos_T    pos_copy;\n\n    cursor_save = curwin->w_cursor;\n    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)\n    {\n\tpos_copy = *trypos;\t// copy pos_T, next findmatch will change it\n\ttrypos = &pos_copy;\n\tcurwin->w_cursor = *trypos;\n\tpos = NULL;\n\t// ignore the { if it's in a // or / *  * / comment\n\tif ((colnr_T)cin_skip2pos(trypos) == trypos->col\n\t\t       && (pos = ind_find_start_CORS(NULL)) == NULL) // XXX\n\t    break;\n\tif (pos != NULL)\n\t    curwin->w_cursor = *pos;\n    }\n    curwin->w_cursor = cursor_save;\n    return trypos;\n}\n\n/*\n * Find the matching '(', ignoring it if it is in a comment or before an\n * unmatched {.\n * Return NULL if no match found.\n */\n    static pos_T *\nfind_match_paren_after_brace (int ind_maxparen)\t    // XXX\n{\n    pos_T\t*trypos = find_match_paren(ind_maxparen);\n\n    if (trypos != NULL)\n    {\n\tpos_T\t*tryposBrace = find_start_brace();\n\n\t// If both an unmatched '(' and '{' is found.  Ignore the '('\n\t// position if the '{' is further down.\n\tif (tryposBrace != NULL\n\t\t&& (trypos->lnum != tryposBrace->lnum\n\t\t    ? trypos->lnum < tryposBrace->lnum\n\t\t    : trypos->col < tryposBrace->col))\n\t    trypos = NULL;\n    }\n    return trypos;\n}\n\n/*\n * Return ind_maxparen corrected for the difference in line number between the\n * cursor position and \"startpos\".  This makes sure that searching for a\n * matching paren above the cursor line doesn't find a match because of\n * looking a few lines further.\n */\n    static int\ncorr_ind_maxparen(pos_T *startpos)\n{\n    long\tn = (long)startpos->lnum - (long)curwin->w_cursor.lnum;\n\n    if (n > 0 && n < curbuf->b_ind_maxparen / 2)\n\treturn curbuf->b_ind_maxparen - (int)n;\n    return curbuf->b_ind_maxparen;\n}\n\n/*\n * Parse 'cinoptions' and set the values in \"curbuf\".\n * Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.\n */\n    void\nparse_cino(buf_T *buf)\n{\n    char_u\t*p;\n    char_u\t*l;\n    char_u\t*digits;\n    int\t\tn;\n    int\t\tdivider;\n    int\t\tfraction = 0;\n    int\t\tsw = (int)get_sw_value(buf);\n\n    // Set the default values.\n\n    // Spaces from a block's opening brace the prevailing indent for that\n    // block should be.\n    buf->b_ind_level = sw;\n\n    // Spaces from the edge of the line an open brace that's at the end of a\n    // line is imagined to be.\n    buf->b_ind_open_imag = 0;\n\n    // Spaces from the prevailing indent for a line that is not preceded by\n    // an opening brace.\n    buf->b_ind_no_brace = 0;\n\n    // Column where the first { of a function should be located }.\n    buf->b_ind_first_open = 0;\n\n    // Spaces from the prevailing indent a leftmost open brace should be\n    // located.\n    buf->b_ind_open_extra = 0;\n\n    // Spaces from the matching open brace (real location for one at the left\n    // edge; imaginary location from one that ends a line) the matching close\n    // brace should be located.\n    buf->b_ind_close_extra = 0;\n\n    // Spaces from the edge of the line an open brace sitting in the leftmost\n    // column is imagined to be.\n    buf->b_ind_open_left_imag = 0;\n\n    // Spaces jump labels should be shifted to the left if N is non-negative,\n    // otherwise the jump label will be put to column 1.\n    buf->b_ind_jump_label = -1;\n\n    // Spaces from the switch() indent a \"case xx\" label should be located.\n    buf->b_ind_case = sw;\n\n    // Spaces from the \"case xx:\" code after a switch() should be located.\n    buf->b_ind_case_code = sw;\n\n    // Lineup break at end of case in switch() with case label.\n    buf->b_ind_case_break = 0;\n\n    // Spaces from the class declaration indent a scope declaration label\n    // should be located.\n    buf->b_ind_scopedecl = sw;\n\n    // Spaces from the scope declaration label code should be located.\n    buf->b_ind_scopedecl_code = sw;\n\n    // Amount K&R-style parameters should be indented.\n    buf->b_ind_param = sw;\n\n    // Amount a function type spec should be indented.\n    buf->b_ind_func_type = sw;\n\n    // Amount a cpp base class declaration or constructor initialization\n    // should be indented.\n    buf->b_ind_cpp_baseclass = sw;\n\n    // additional spaces beyond the prevailing indent a continuation line\n    // should be located.\n    buf->b_ind_continuation = sw;\n\n    // Spaces from the indent of the line with an unclosed parenthesis.\n    buf->b_ind_unclosed = sw * 2;\n\n    // Spaces from the indent of the line with an unclosed parenthesis, which\n    // itself is also unclosed.\n    buf->b_ind_unclosed2 = sw;\n\n    // Suppress ignoring spaces from the indent of a line starting with an\n    // unclosed parentheses.\n    buf->b_ind_unclosed_noignore = 0;\n\n    // If the opening paren is the last nonwhite character on the line, and\n    // b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer\n    // context (for very long lines).\n    buf->b_ind_unclosed_wrapped = 0;\n\n    // Suppress ignoring white space when lining up with the character after\n    // an unclosed parenthesis.\n    buf->b_ind_unclosed_whiteok = 0;\n\n    // Indent a closing parentheses under the line start of the matching\n    // opening parentheses.\n    buf->b_ind_matching_paren = 0;\n\n    // Indent a closing parentheses under the previous line.\n    buf->b_ind_paren_prev = 0;\n\n    // Extra indent for comments.\n    buf->b_ind_comment = 0;\n\n    // Spaces from the comment opener when there is nothing after it.\n    buf->b_ind_in_comment = 3;\n\n    // Boolean: if non-zero, use b_ind_in_comment even if there is something\n    // after the comment opener.\n    buf->b_ind_in_comment2 = 0;\n\n    // Max lines to search for an open paren.\n    buf->b_ind_maxparen = 20;\n\n    // Max lines to search for an open comment.\n    buf->b_ind_maxcomment = 70;\n\n    // Handle braces for java code.\n    buf->b_ind_java = 0;\n\n    // Not to confuse JS object properties with labels.\n    buf->b_ind_js = 0;\n\n    // Handle blocked cases correctly.\n    buf->b_ind_keep_case_label = 0;\n\n    // Handle C++ namespace.\n    buf->b_ind_cpp_namespace = 0;\n\n    // Handle continuation lines containing conditions of if(), for() and\n    // while().\n    buf->b_ind_if_for_while = 0;\n\n    // indentation for # comments\n    buf->b_ind_hash_comment = 0;\n\n    // Handle C++ extern \"C\" or \"C++\"\n    buf->b_ind_cpp_extern_c = 0;\n\n    // Handle C #pragma directives\n    buf->b_ind_pragma = 0;\n\n    for (p = buf->b_p_cino; *p; )\n    {\n\tl = p++;\n\tif (*p == '-')\n\t    ++p;\n\tdigits = p;\t    // remember where the digits start\n\tn = getdigits(&p);\n\tdivider = 0;\n\tif (*p == '.')\t    // \".5s\" means a fraction\n\t{\n\t    fraction = atol((char *)++p);\n\t    while (VIM_ISDIGIT(*p))\n\t    {\n\t\t++p;\n\t\tif (divider)\n\t\t    divider *= 10;\n\t\telse\n\t\t    divider = 10;\n\t    }\n\t}\n\tif (*p == 's')\t    // \"2s\" means two times 'shiftwidth'\n\t{\n\t    if (p == digits)\n\t\tn = sw;\t// just \"s\" is one 'shiftwidth'\n\t    else\n\t    {\n\t\tn *= sw;\n\t\tif (divider)\n\t\t    n += (sw * fraction + divider / 2) / divider;\n\t    }\n\t    ++p;\n\t}\n\tif (l[1] == '-')\n\t    n = -n;\n\n\t// When adding an entry here, also update the default 'cinoptions' in\n\t// doc/indent.txt, and add explanation for it!\n\tswitch (*l)\n\t{\n\t    case '>': buf->b_ind_level = n; break;\n\t    case 'e': buf->b_ind_open_imag = n; break;\n\t    case 'n': buf->b_ind_no_brace = n; break;\n\t    case 'f': buf->b_ind_first_open = n; break;\n\t    case '{': buf->b_ind_open_extra = n; break;\n\t    case '}': buf->b_ind_close_extra = n; break;\n\t    case '^': buf->b_ind_open_left_imag = n; break;\n\t    case 'L': buf->b_ind_jump_label = n; break;\n\t    case ':': buf->b_ind_case = n; break;\n\t    case '=': buf->b_ind_case_code = n; break;\n\t    case 'b': buf->b_ind_case_break = n; break;\n\t    case 'p': buf->b_ind_param = n; break;\n\t    case 't': buf->b_ind_func_type = n; break;\n\t    case '/': buf->b_ind_comment = n; break;\n\t    case 'c': buf->b_ind_in_comment = n; break;\n\t    case 'C': buf->b_ind_in_comment2 = n; break;\n\t    case 'i': buf->b_ind_cpp_baseclass = n; break;\n\t    case '+': buf->b_ind_continuation = n; break;\n\t    case '(': buf->b_ind_unclosed = n; break;\n\t    case 'u': buf->b_ind_unclosed2 = n; break;\n\t    case 'U': buf->b_ind_unclosed_noignore = n; break;\n\t    case 'W': buf->b_ind_unclosed_wrapped = n; break;\n\t    case 'w': buf->b_ind_unclosed_whiteok = n; break;\n\t    case 'm': buf->b_ind_matching_paren = n; break;\n\t    case 'M': buf->b_ind_paren_prev = n; break;\n\t    case ')': buf->b_ind_maxparen = n; break;\n\t    case '*': buf->b_ind_maxcomment = n; break;\n\t    case 'g': buf->b_ind_scopedecl = n; break;\n\t    case 'h': buf->b_ind_scopedecl_code = n; break;\n\t    case 'j': buf->b_ind_java = n; break;\n\t    case 'J': buf->b_ind_js = n; break;\n\t    case 'l': buf->b_ind_keep_case_label = n; break;\n\t    case '#': buf->b_ind_hash_comment = n; break;\n\t    case 'N': buf->b_ind_cpp_namespace = n; break;\n\t    case 'k': buf->b_ind_if_for_while = n; break;\n\t    case 'E': buf->b_ind_cpp_extern_c = n; break;\n\t    case 'P': buf->b_ind_pragma = n; break;\n\t}\n\tif (*p == ',')\n\t    ++p;\n    }\n}\n\n    static int\nfind_match(int lookfor, linenr_T ourscope)\n{\n    char_u\t*look;\n    pos_T\t*theirscope;\n    char_u\t*mightbeif;\n    int\t\telselevel;\n    int\t\twhilelevel;\n\n    if (lookfor == LOOKFOR_IF)\n    {\n\telselevel = 1;\n\twhilelevel = 0;\n    }\n    else\n    {\n\telselevel = 0;\n\twhilelevel = 1;\n    }\n\n    curwin->w_cursor.col = 0;\n\n    while (curwin->w_cursor.lnum > ourscope + 1)\n    {\n\tcurwin->w_cursor.lnum--;\n\tcurwin->w_cursor.col = 0;\n\n\tlook = cin_skipcomment(ml_get_curline());\n\tif (cin_iselse(look)\n\t\t|| cin_isif(look)\n\t\t|| cin_isdo(look)\t\t\t    // XXX\n\t\t|| cin_iswhileofdo(look, curwin->w_cursor.lnum))\n\t{\n\t    // if we've gone outside the braces entirely,\n\t    // we must be out of scope...\n\t    theirscope = find_start_brace();  // XXX\n\t    if (theirscope == NULL)\n\t\tbreak;\n\n\t    // and if the brace enclosing this is further\n\t    // back than the one enclosing the else, we're\n\t    // out of luck too.\n\t    if (theirscope->lnum < ourscope)\n\t\tbreak;\n\n\t    // and if they're enclosed in a *deeper* brace,\n\t    // then we can ignore it because it's in a\n\t    // different scope...\n\t    if (theirscope->lnum > ourscope)\n\t\tcontinue;\n\n\t    // if it was an \"else\" (that's not an \"else if\")\n\t    // then we need to go back to another if, so\n\t    // increment elselevel\n\t    look = cin_skipcomment(ml_get_curline());\n\t    if (cin_iselse(look))\n\t    {\n\t\tmightbeif = cin_skipcomment(look + 4);\n\t\tif (!cin_isif(mightbeif))\n\t\t    ++elselevel;\n\t\tcontinue;\n\t    }\n\n\t    // if it was a \"while\" then we need to go back to\n\t    // another \"do\", so increment whilelevel.  XXX\n\t    if (cin_iswhileofdo(look, curwin->w_cursor.lnum))\n\t    {\n\t\t++whilelevel;\n\t\tcontinue;\n\t    }\n\n\t    // If it's an \"if\" decrement elselevel\n\t    look = cin_skipcomment(ml_get_curline());\n\t    if (cin_isif(look))\n\t    {\n\t\telselevel--;\n\t\t// When looking for an \"if\" ignore \"while\"s that\n\t\t// get in the way.\n\t\tif (elselevel == 0 && lookfor == LOOKFOR_IF)\n\t\t    whilelevel = 0;\n\t    }\n\n\t    // If it's a \"do\" decrement whilelevel\n\t    if (cin_isdo(look))\n\t\twhilelevel--;\n\n\t    // if we've used up all the elses, then\n\t    // this must be the if that we want!\n\t    // match the indent level of that if.\n\t    if (elselevel <= 0 && whilelevel <= 0)\n\t\treturn OK;\n\t}\n    }\n    return FAIL;\n}\n\n/*\n * Return the desired indent for C code.\n * Return -1 if the indent should be left alone (inside a raw string).\n */\n    int\nget_c_indent(void)\n{\n    pos_T\tcur_curpos;\n    int\t\tamount;\n    int\t\tscope_amount;\n    int\t\tcur_amount = MAXCOL;\n    colnr_T\tcol;\n    char_u\t*theline;\n    char_u\t*linecopy;\n    pos_T\t*trypos;\n    pos_T\t*comment_pos;\n    pos_T\t*tryposBrace = NULL;\n    pos_T\ttryposCopy;\n    pos_T\tour_paren_pos;\n    char_u\t*start;\n    int\t\tstart_brace;\n#define BRACE_IN_COL0\t\t1\t    // '{' is in column 0\n#define BRACE_AT_START\t\t2\t    // '{' is at start of line\n#define BRACE_AT_END\t\t3\t    // '{' is at end of line\n    linenr_T\tourscope;\n    char_u\t*l;\n    char_u\t*look;\n    char_u\tterminated;\n    int\t\tlookfor;\n    int\t\twhilelevel;\n    linenr_T\tlnum;\n    int\t\tn;\n    int\t\tiscase;\n    int\t\tlookfor_break;\n    int\t\tlookfor_cpp_namespace = FALSE;\n    int\t\tcont_amount = 0;    // amount for continuation line\n    int\t\toriginal_line_islabel;\n    int\t\tadded_to_amount = 0;\n    int\t\tjs_cur_has_key = 0;\n    linenr_T\traw_string_start = 0;\n    cpp_baseclass_cache_T cache_cpp_baseclass = { FALSE, { MAXLNUM, 0 } };\n\n    // make a copy, value is changed below\n    int\t\tind_continuation = curbuf->b_ind_continuation;\n\n    // remember where the cursor was when we started\n    cur_curpos = curwin->w_cursor;\n\n    // if we are at line 1 zero indent is fine, right?\n    if (cur_curpos.lnum == 1)\n\treturn 0;\n\n    // Get a copy of the current contents of the line.\n    // This is required, because only the most recent line obtained with\n    // ml_get is valid!\n    linecopy = vim_strsave(ml_get(cur_curpos.lnum));\n    if (linecopy == NULL)\n\treturn 0;\n\n    // In insert mode and the cursor is on a ')' truncate the line at the\n    // cursor position.  We don't want to line up with the matching '(' when\n    // inserting new stuff.\n    // For unknown reasons the cursor might be past the end of the line, thus\n    // check for that.\n    if ((State & INSERT)\n\t    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)\n\t    && linecopy[curwin->w_cursor.col] == ')')\n\tlinecopy[curwin->w_cursor.col] = NUL;\n\n    theline = skipwhite(linecopy);\n\n    // move the cursor to the start of the line\n\n    curwin->w_cursor.col = 0;\n\n    original_line_islabel = cin_islabel();  // XXX\n\n    // If we are inside a raw string don't change the indent.\n    // Ignore a raw string inside a comment.\n    comment_pos = ind_find_start_comment();\n    if (comment_pos != NULL)\n    {\n\t// findmatchlimit() static pos is overwritten, make a copy\n\ttryposCopy = *comment_pos;\n\tcomment_pos = &tryposCopy;\n    }\n    trypos = find_start_rawstring(curbuf->b_ind_maxcomment);\n    if (trypos != NULL && (comment_pos == NULL\n\t\t\t\t\t     || LT_POS(*trypos, *comment_pos)))\n    {\n\tamount = -1;\n\tgoto laterend;\n    }\n\n    // #defines and so on go at the left when included in 'cinkeys',\n    // excluding pragmas when customized in 'cinoptions'\n    if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))\n    {\n\tchar_u *directive = skipwhite(theline + 1);\n\tif (curbuf->b_ind_pragma == 0 || STRNCMP(directive, \"pragma\", 6) != 0)\n\t{\n\t    amount = curbuf->b_ind_hash_comment;\n\t    goto theend;\n\t}\n    }\n\n    // Is it a non-case label?\tThen that goes at the left margin too unless:\n    //  - JS flag is set.\n    //  - 'L' item has a positive value.\n    if (original_line_islabel && !curbuf->b_ind_js\n\t\t\t\t\t      && curbuf->b_ind_jump_label < 0)\n    {\n\tamount = 0;\n\tgoto theend;\n    }\n\n    // If we're inside a \"//\" comment and there is a \"//\" comment in a\n    // previous line, lineup with that one.\n    if (cin_islinecomment(theline)\n\t    && (trypos = find_line_comment()) != NULL) // XXX\n    {\n\t// find how indented the line beginning the comment is\n\tgetvcol(curwin, trypos, &col, NULL, NULL);\n\tamount = col;\n\tgoto theend;\n    }\n\n    // If we're inside a comment and not looking at the start of the\n    // comment, try using the 'comments' option.\n    if (!cin_iscomment(theline) && comment_pos != NULL) // XXX\n    {\n\tint\tlead_start_len = 2;\n\tint\tlead_middle_len = 1;\n\tchar_u\tlead_start[COM_MAX_LEN];\t// start-comment string\n\tchar_u\tlead_middle[COM_MAX_LEN];\t// middle-comment string\n\tchar_u\tlead_end[COM_MAX_LEN];\t\t// end-comment string\n\tchar_u\t*p;\n\tint\tstart_align = 0;\n\tint\tstart_off = 0;\n\tint\tdone = FALSE;\n\n\t// find how indented the line beginning the comment is\n\tgetvcol(curwin, comment_pos, &col, NULL, NULL);\n\tamount = col;\n\t*lead_start = NUL;\n\t*lead_middle = NUL;\n\n\tp = curbuf->b_p_com;\n\twhile (*p != NUL)\n\t{\n\t    int\talign = 0;\n\t    int\toff = 0;\n\t    int what = 0;\n\n\t    while (*p != NUL && *p != ':')\n\t    {\n\t\tif (*p == COM_START || *p == COM_END || *p == COM_MIDDLE)\n\t\t    what = *p++;\n\t\telse if (*p == COM_LEFT || *p == COM_RIGHT)\n\t\t    align = *p++;\n\t\telse if (VIM_ISDIGIT(*p) || *p == '-')\n\t\t    off = getdigits(&p);\n\t\telse\n\t\t    ++p;\n\t    }\n\n\t    if (*p == ':')\n\t\t++p;\n\t    (void)copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\t    if (what == COM_START)\n\t    {\n\t\tSTRCPY(lead_start, lead_end);\n\t\tlead_start_len = (int)STRLEN(lead_start);\n\t\tstart_off = off;\n\t\tstart_align = align;\n\t    }\n\t    else if (what == COM_MIDDLE)\n\t    {\n\t\tSTRCPY(lead_middle, lead_end);\n\t\tlead_middle_len = (int)STRLEN(lead_middle);\n\t    }\n\t    else if (what == COM_END)\n\t    {\n\t\t// If our line starts with the middle comment string, line it\n\t\t// up with the comment opener per the 'comments' option.\n\t\tif (STRNCMP(theline, lead_middle, lead_middle_len) == 0\n\t\t\t&& STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0)\n\t\t{\n\t\t    done = TRUE;\n\t\t    if (curwin->w_cursor.lnum > 1)\n\t\t    {\n\t\t\t// If the start comment string matches in the previous\n\t\t\t// line, use the indent of that line plus offset.  If\n\t\t\t// the middle comment string matches in the previous\n\t\t\t// line, use the indent of that line.  XXX\n\t\t\tlook = skipwhite(ml_get(curwin->w_cursor.lnum - 1));\n\t\t\tif (STRNCMP(look, lead_start, lead_start_len) == 0)\n\t\t\t    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);\n\t\t\telse if (STRNCMP(look, lead_middle,\n\t\t\t\t\t\t\tlead_middle_len) == 0)\n\t\t\t{\n\t\t\t    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);\n\t\t\t    break;\n\t\t\t}\n\t\t\t// If the start comment string doesn't match with the\n\t\t\t// start of the comment, skip this entry.  XXX\n\t\t\telse if (STRNCMP(ml_get(comment_pos->lnum) + comment_pos->col,\n\t\t\t\t\t     lead_start, lead_start_len) != 0)\n\t\t\t    continue;\n\t\t    }\n\t\t    if (start_off != 0)\n\t\t\tamount += start_off;\n\t\t    else if (start_align == COM_RIGHT)\n\t\t\tamount += vim_strsize(lead_start)\n\t\t\t\t\t\t   - vim_strsize(lead_middle);\n\t\t    break;\n\t\t}\n\n\t\t// If our line starts with the end comment string, line it up\n\t\t// with the middle comment\n\t\tif (STRNCMP(theline, lead_middle, lead_middle_len) != 0\n\t\t\t&& STRNCMP(theline, lead_end, STRLEN(lead_end)) == 0)\n\t\t{\n\t\t    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);\n\t\t\t\t\t\t\t\t     // XXX\n\t\t    if (off != 0)\n\t\t\tamount += off;\n\t\t    else if (align == COM_RIGHT)\n\t\t\tamount += vim_strsize(lead_start)\n\t\t\t\t\t\t   - vim_strsize(lead_middle);\n\t\t    done = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t// If our line starts with an asterisk, line up with the\n\t// asterisk in the comment opener; otherwise, line up\n\t// with the first character of the comment text.\n\tif (done)\n\t    ;\n\telse if (theline[0] == '*')\n\t    amount += 1;\n\telse\n\t{\n\t    // If we are more than one line away from the comment opener, take\n\t    // the indent of the previous non-empty line.  If 'cino' has \"CO\"\n\t    // and we are just below the comment opener and there are any\n\t    // white characters after it line up with the text after it;\n\t    // otherwise, add the amount specified by \"c\" in 'cino'\n\t    amount = -1;\n\t    for (lnum = cur_curpos.lnum - 1; lnum > comment_pos->lnum; --lnum)\n\t    {\n\t\tif (linewhite(lnum))\t\t    // skip blank lines\n\t\t    continue;\n\t\tamount = get_indent_lnum(lnum);\t    // XXX\n\t\tbreak;\n\t    }\n\t    if (amount == -1)\t\t\t    // use the comment opener\n\t    {\n\t\tif (!curbuf->b_ind_in_comment2)\n\t\t{\n\t\t    start = ml_get(comment_pos->lnum);\n\t\t    look = start + comment_pos->col + 2; // skip / and *\n\t\t    if (*look != NUL)\t\t    // if something after it\n\t\t\tcomment_pos->col = (colnr_T)(skipwhite(look) - start);\n\t\t}\n\t\tgetvcol(curwin, comment_pos, &col, NULL, NULL);\n\t\tamount = col;\n\t\tif (curbuf->b_ind_in_comment2 || *look == NUL)\n\t\t    amount += curbuf->b_ind_in_comment;\n\t    }\n\t}\n\tgoto theend;\n    }\n\n    // Are we looking at a ']' that has a match?\n    if (*skipwhite(theline) == ']'\n\t    && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL)\n    {\n\t// align with the line containing the '['.\n\tamount = get_indent_lnum(trypos->lnum);\n\tgoto theend;\n    }\n\n    // Are we inside parentheses or braces?  XXX\n    if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL\n\t\t&& curbuf->b_ind_java == 0)\n\t    || (tryposBrace = find_start_brace()) != NULL\n\t    || trypos != NULL)\n    {\n      if (trypos != NULL && tryposBrace != NULL)\n      {\n\t  // Both an unmatched '(' and '{' is found.  Use the one which is\n\t  // closer to the current cursor position, set the other to NULL.\n\t  if (trypos->lnum != tryposBrace->lnum\n\t\t  ? trypos->lnum < tryposBrace->lnum\n\t\t  : trypos->col < tryposBrace->col)\n\t      trypos = NULL;\n\t  else\n\t      tryposBrace = NULL;\n      }\n\n      if (trypos != NULL)\n      {\n\t// If the matching paren is more than one line away, use the indent of\n\t// a previous non-empty line that matches the same paren.\n\tif (theline[0] == ')' && curbuf->b_ind_paren_prev)\n\t{\n\t    // Line up with the start of the matching paren line.\n\t    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);  // XXX\n\t}\n\telse\n\t{\n\t    amount = -1;\n\t    our_paren_pos = *trypos;\n\t    for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum)\n\t    {\n\t\tl = skipwhite(ml_get(lnum));\n\t\tif (cin_nocode(l))\t\t// skip comment lines\n\t\t    continue;\n\t\tif (cin_ispreproc_cont(&l, &lnum, &amount))\n\t\t    continue;\t\t\t// ignore #define, #if, etc.\n\t\tcurwin->w_cursor.lnum = lnum;\n\n\t\t// Skip a comment or raw string.  XXX\n\t\tif ((trypos = ind_find_start_CORS(NULL)) != NULL)\n\t\t{\n\t\t    lnum = trypos->lnum + 1;\n\t\t    continue;\n\t\t}\n\n\t\t// XXX\n\t\tif ((trypos = find_match_paren(\n\t\t\tcorr_ind_maxparen(&cur_curpos))) != NULL\n\t\t\t&& trypos->lnum == our_paren_pos.lnum\n\t\t\t&& trypos->col == our_paren_pos.col)\n\t\t{\n\t\t\tamount = get_indent_lnum(lnum);\t// XXX\n\n\t\t\tif (theline[0] == ')')\n\t\t\t{\n\t\t\t    if (our_paren_pos.lnum != lnum\n\t\t\t\t\t\t       && cur_amount > amount)\n\t\t\t\tcur_amount = amount;\n\t\t\t    amount = -1;\n\t\t\t}\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t// Line up with line where the matching paren is. XXX\n\t// If the line starts with a '(' or the indent for unclosed\n\t// parentheses is zero, line up with the unclosed parentheses.\n\tif (amount == -1)\n\t{\n\t    int\t    ignore_paren_col = 0;\n\t    int\t    is_if_for_while = 0;\n\n\t    if (curbuf->b_ind_if_for_while)\n\t    {\n\t\t// Look for the outermost opening parenthesis on this line\n\t\t// and check whether it belongs to an \"if\", \"for\" or \"while\".\n\n\t\tpos_T\t    cursor_save = curwin->w_cursor;\n\t\tpos_T\t    outermost;\n\t\tchar_u\t    *line;\n\n\t\ttrypos = &our_paren_pos;\n\t\tdo {\n\t\t    outermost = *trypos;\n\t\t    curwin->w_cursor.lnum = outermost.lnum;\n\t\t    curwin->w_cursor.col = outermost.col;\n\n\t\t    trypos = find_match_paren(curbuf->b_ind_maxparen);\n\t\t} while (trypos && trypos->lnum == outermost.lnum);\n\n\t\tcurwin->w_cursor = cursor_save;\n\n\t\tline = ml_get(outermost.lnum);\n\n\t\tis_if_for_while =\n\t\t    cin_is_if_for_while_before_offset(line, &outermost.col);\n\t    }\n\n\t    amount = skip_label(our_paren_pos.lnum, &look);\n\t    look = skipwhite(look);\n\t    if (*look == '(')\n\t    {\n\t\tlinenr_T    save_lnum = curwin->w_cursor.lnum;\n\t\tchar_u\t    *line;\n\t\tint\t    look_col;\n\n\t\t// Ignore a '(' in front of the line that has a match before\n\t\t// our matching '('.\n\t\tcurwin->w_cursor.lnum = our_paren_pos.lnum;\n\t\tline = ml_get_curline();\n\t\tlook_col = (int)(look - line);\n\t\tcurwin->w_cursor.col = look_col + 1;\n\t\tif ((trypos = findmatchlimit(NULL, ')', 0,\n\t\t\t\t\t\t      curbuf->b_ind_maxparen))\n\t\t\t\t\t\t\t\t      != NULL\n\t\t\t  && trypos->lnum == our_paren_pos.lnum\n\t\t\t  && trypos->col < our_paren_pos.col)\n\t\t    ignore_paren_col = trypos->col + 1;\n\n\t\tcurwin->w_cursor.lnum = save_lnum;\n\t\tlook = ml_get(our_paren_pos.lnum) + look_col;\n\t    }\n\t    if (theline[0] == ')' || (curbuf->b_ind_unclosed == 0\n\t\t\t\t\t\t      && is_if_for_while == 0)\n\t\t    || (!curbuf->b_ind_unclosed_noignore && *look == '('\n\t\t\t\t\t\t    && ignore_paren_col == 0))\n\t    {\n\t\t// If we're looking at a close paren, line up right there;\n\t\t// otherwise, line up with the next (non-white) character.\n\t\t// When b_ind_unclosed_wrapped is set and the matching paren is\n\t\t// the last nonwhite character of the line, use either the\n\t\t// indent of the current line or the indentation of the next\n\t\t// outer paren and add b_ind_unclosed_wrapped (for very long\n\t\t// lines).\n\t\tif (theline[0] != ')')\n\t\t{\n\t\t    cur_amount = MAXCOL;\n\t\t    l = ml_get(our_paren_pos.lnum);\n\t\t    if (curbuf->b_ind_unclosed_wrapped\n\t\t\t\t       && cin_ends_in(l, (char_u *)\"(\", NULL))\n\t\t    {\n\t\t\t// look for opening unmatched paren, indent one level\n\t\t\t// for each additional level\n\t\t\tn = 1;\n\t\t\tfor (col = 0; col < our_paren_pos.col; ++col)\n\t\t\t{\n\t\t\t    switch (l[col])\n\t\t\t    {\n\t\t\t\tcase '(':\n\t\t\t\tcase '{': ++n;\n\t\t\t\t\t  break;\n\n\t\t\t\tcase ')':\n\t\t\t\tcase '}': if (n > 1)\n\t\t\t\t\t      --n;\n\t\t\t\t\t  break;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tour_paren_pos.col = 0;\n\t\t\tamount += n * curbuf->b_ind_unclosed_wrapped;\n\t\t    }\n\t\t    else if (curbuf->b_ind_unclosed_whiteok)\n\t\t\tour_paren_pos.col++;\n\t\t    else\n\t\t    {\n\t\t\tcol = our_paren_pos.col + 1;\n\t\t\twhile (VIM_ISWHITE(l[col]))\n\t\t\t    col++;\n\t\t\tif (l[col] != NUL)\t// In case of trailing space\n\t\t\t    our_paren_pos.col = col;\n\t\t\telse\n\t\t\t    our_paren_pos.col++;\n\t\t    }\n\t\t}\n\n\t\t// Find how indented the paren is, or the character after it\n\t\t// if we did the above \"if\".\n\t\tif (our_paren_pos.col > 0)\n\t\t{\n\t\t    getvcol(curwin, &our_paren_pos, &col, NULL, NULL);\n\t\t    if (cur_amount > (int)col)\n\t\t\tcur_amount = col;\n\t\t}\n\t    }\n\n\t    if (theline[0] == ')' && curbuf->b_ind_matching_paren)\n\t    {\n\t\t// Line up with the start of the matching paren line.\n\t    }\n\t    else if ((curbuf->b_ind_unclosed == 0 && is_if_for_while == 0)\n\t\t     || (!curbuf->b_ind_unclosed_noignore\n\t\t\t\t    && *look == '(' && ignore_paren_col == 0))\n\t    {\n\t\tif (cur_amount != MAXCOL)\n\t\t    amount = cur_amount;\n\t    }\n\t    else\n\t    {\n\t\t// Add b_ind_unclosed2 for each '(' before our matching one,\n\t\t// but ignore (void) before the line (ignore_paren_col).\n\t\tcol = our_paren_pos.col;\n\t\twhile ((int)our_paren_pos.col > ignore_paren_col)\n\t\t{\n\t\t    --our_paren_pos.col;\n\t\t    switch (*ml_get_pos(&our_paren_pos))\n\t\t    {\n\t\t\tcase '(': amount += curbuf->b_ind_unclosed2;\n\t\t\t\t  col = our_paren_pos.col;\n\t\t\t\t  break;\n\t\t\tcase ')': amount -= curbuf->b_ind_unclosed2;\n\t\t\t\t  col = MAXCOL;\n\t\t\t\t  break;\n\t\t    }\n\t\t}\n\n\t\t// Use b_ind_unclosed once, when the first '(' is not inside\n\t\t// braces\n\t\tif (col == MAXCOL)\n\t\t    amount += curbuf->b_ind_unclosed;\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = our_paren_pos.lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    if (find_match_paren_after_brace(curbuf->b_ind_maxparen)\n\t\t\t\t\t\t\t\t      != NULL)\n\t\t\tamount += curbuf->b_ind_unclosed2;\n\t\t    else\n\t\t    {\n\t\t\tif (is_if_for_while)\n\t\t\t    amount += curbuf->b_ind_if_for_while;\n\t\t\telse\n\t\t\t    amount += curbuf->b_ind_unclosed;\n\t\t    }\n\t\t}\n\t\t// For a line starting with ')' use the minimum of the two\n\t\t// positions, to avoid giving it more indent than the previous\n\t\t// lines:\n\t\t//  func_long_name(\t\t    if (x\n\t\t//\targ\t\t\t\t    && yy\n\t\t//\t)\t  ^ not here\t       )    ^ not here\n\t\tif (cur_amount < amount)\n\t\t    amount = cur_amount;\n\t    }\n\t}\n\n\t// add extra indent for a comment\n\tif (cin_iscomment(theline))\n\t    amount += curbuf->b_ind_comment;\n      }\n      else\n      {\n\t// We are inside braces, there is a { before this line at the position\n\t// stored in tryposBrace.\n\t// Make a copy of tryposBrace, it may point to pos_copy inside\n\t// find_start_brace(), which may be changed somewhere.\n\ttryposCopy = *tryposBrace;\n\ttryposBrace = &tryposCopy;\n\ttrypos = tryposBrace;\n\tourscope = trypos->lnum;\n\tstart = ml_get(ourscope);\n\n\t// Now figure out how indented the line is in general.\n\t// If the brace was at the start of the line, we use that;\n\t// otherwise, check out the indentation of the line as\n\t// a whole and then add the \"imaginary indent\" to that.\n\tlook = skipwhite(start);\n\tif (*look == '{')\n\t{\n\t    getvcol(curwin, trypos, &col, NULL, NULL);\n\t    amount = col;\n\t    if (*start == '{')\n\t\tstart_brace = BRACE_IN_COL0;\n\t    else\n\t\tstart_brace = BRACE_AT_START;\n\t}\n\telse\n\t{\n\t    // That opening brace might have been on a continuation\n\t    // line.  if so, find the start of the line.\n\t    curwin->w_cursor.lnum = ourscope;\n\n\t    // Position the cursor over the rightmost paren, so that\n\t    // matching it will take us back to the start of the line.\n\t    lnum = ourscope;\n\t    if (find_last_paren(start, '(', ')')\n\t\t\t&& (trypos = find_match_paren(curbuf->b_ind_maxparen))\n\t\t\t\t\t\t\t\t      != NULL)\n\t\tlnum = trypos->lnum;\n\n\t    // It could have been something like\n\t    //\t   case 1: if (asdf &&\n\t    //\t\t\tldfd) {\n\t    //\t\t    }\n\t    if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)\n\t\t\t   && cin_iscase(skipwhite(ml_get_curline()), FALSE))\n\t\tamount = get_indent();\n\t    else if (curbuf->b_ind_js)\n\t\tamount = get_indent_lnum(lnum);\n\t    else\n\t\tamount = skip_label(lnum, &l);\n\n\t    start_brace = BRACE_AT_END;\n\t}\n\n\t// For Javascript check if the line starts with \"key:\".\n\tif (curbuf->b_ind_js)\n\t    js_cur_has_key = cin_has_js_key(theline);\n\n\t// If we're looking at a closing brace, that's where\n\t// we want to be.  otherwise, add the amount of room\n\t// that an indent is supposed to be.\n\tif (theline[0] == '}')\n\t{\n\t    // they may want closing braces to line up with something\n\t    // other than the open brace.  indulge them, if so.\n\t    amount += curbuf->b_ind_close_extra;\n\t}\n\telse\n\t{\n\t    // If we're looking at an \"else\", try to find an \"if\"\n\t    // to match it with.\n\t    // If we're looking at a \"while\", try to find a \"do\"\n\t    // to match it with.\n\t    lookfor = LOOKFOR_INITIAL;\n\t    if (cin_iselse(theline))\n\t\tlookfor = LOOKFOR_IF;\n\t    else if (cin_iswhileofdo(theline, cur_curpos.lnum)) // XXX\n\t\tlookfor = LOOKFOR_DO;\n\t    if (lookfor != LOOKFOR_INITIAL)\n\t    {\n\t\tcurwin->w_cursor.lnum = cur_curpos.lnum;\n\t\tif (find_match(lookfor, ourscope) == OK)\n\t\t{\n\t\t    amount = get_indent();\t// XXX\n\t\t    goto theend;\n\t\t}\n\t    }\n\n\t    // We get here if we are not on an \"while-of-do\" or \"else\" (or\n\t    // failed to find a matching \"if\").\n\t    // Search backwards for something to line up with.\n\t    // First set amount for when we don't find anything.\n\n\t    // if the '{' is  _really_ at the left margin, use the imaginary\n\t    // location of a left-margin brace.  Otherwise, correct the\n\t    // location for b_ind_open_extra.\n\n\t    if (start_brace == BRACE_IN_COL0)\t    // '{' is in column 0\n\t    {\n\t\tamount = curbuf->b_ind_open_left_imag;\n\t\tlookfor_cpp_namespace = TRUE;\n\t    }\n\t    else if (start_brace == BRACE_AT_START &&\n\t\t    lookfor_cpp_namespace)\t  // '{' is at start\n\t    {\n\n\t\tlookfor_cpp_namespace = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (start_brace == BRACE_AT_END)    // '{' is at end of line\n\t\t{\n\t\t    amount += curbuf->b_ind_open_imag;\n\n\t\t    l = skipwhite(ml_get_curline());\n\t\t    if (cin_is_cpp_namespace(l))\n\t\t\tamount += curbuf->b_ind_cpp_namespace;\n\t\t    else if (cin_is_cpp_extern_c(l))\n\t\t\tamount += curbuf->b_ind_cpp_extern_c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Compensate for adding b_ind_open_extra later.\n\t\t    amount -= curbuf->b_ind_open_extra;\n\t\t    if (amount < 0)\n\t\t\tamount = 0;\n\t\t}\n\t    }\n\n\t    lookfor_break = FALSE;\n\n\t    if (cin_iscase(theline, FALSE))\t// it's a switch() label\n\t    {\n\t\tlookfor = LOOKFOR_CASE;\t// find a previous switch() label\n\t\tamount += curbuf->b_ind_case;\n\t    }\n\t    else if (cin_isscopedecl(theline))\t// private:, ...\n\t    {\n\t\tlookfor = LOOKFOR_SCOPEDECL;\t// class decl is this block\n\t\tamount += curbuf->b_ind_scopedecl;\n\t    }\n\t    else\n\t    {\n\t\tif (curbuf->b_ind_case_break && cin_isbreak(theline))\n\t\t    // break; ...\n\t\t    lookfor_break = TRUE;\n\n\t\tlookfor = LOOKFOR_INITIAL;\n\t\t// b_ind_level from start of block\n\t\tamount += curbuf->b_ind_level;\n\t    }\n\t    scope_amount = amount;\n\t    whilelevel = 0;\n\n\t    // Search backwards.  If we find something we recognize, line up\n\t    // with that.\n\t    //\n\t    // If we're looking at an open brace, indent\n\t    // the usual amount relative to the conditional\n\t    // that opens the block.\n\t    curwin->w_cursor = cur_curpos;\n\t    for (;;)\n\t    {\n\t\tcurwin->w_cursor.lnum--;\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// If we went all the way back to the start of our scope, line\n\t\t// up with it.\n\t\tif (curwin->w_cursor.lnum <= ourscope)\n\t\t{\n\t\t    // We reached end of scope:\n\t\t    // If looking for an enum or structure initialization\n\t\t    // go further back:\n\t\t    // If it is an initializer (enum xxx or xxx =), then\n\t\t    // don't add ind_continuation, otherwise it is a variable\n\t\t    // declaration:\n\t\t    // int x,\n\t\t    //     here; <-- add ind_continuation\n\t\t    if (lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t    {\n\t\t\tif (curwin->w_cursor.lnum == 0\n\t\t\t\t|| curwin->w_cursor.lnum\n\t\t\t\t\t  < ourscope - curbuf->b_ind_maxparen)\n\t\t\t{\n\t\t\t    // nothing found (abuse curbuf->b_ind_maxparen as\n\t\t\t    // limit) assume terminated line (i.e. a variable\n\t\t\t    // initialization)\n\t\t\t    if (cont_amount > 0)\n\t\t\t\tamount = cont_amount;\n\t\t\t    else if (!curbuf->b_ind_js)\n\t\t\t\tamount += ind_continuation;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\tl = ml_get_curline();\n\n\t\t\t// If we're in a comment or raw string now, skip to\n\t\t\t// the start of it.\n\t\t\ttrypos = ind_find_start_CORS(NULL);\n\t\t\tif (trypos != NULL)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t\t    curwin->w_cursor.col = 0;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// Skip preprocessor directives and blank lines.\n\t\t\tif (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t    &amount))\n\t\t\t    continue;\n\n\t\t\tif (cin_nocode(l))\n\t\t\t    continue;\n\n\t\t\tterminated = cin_isterminated(l, FALSE, TRUE);\n\n\t\t\t// If we are at top level and the line looks like a\n\t\t\t// function declaration, we are done\n\t\t\t// (it's a variable declaration).\n\t\t\tif (start_brace != BRACE_IN_COL0\n\t\t\t     || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))\n\t\t\t{\n\t\t\t    // if the line is terminated with another ','\n\t\t\t    // it is a continued variable initialization.\n\t\t\t    // don't add extra indent.\n\t\t\t    // TODO: does not work, if  a function\n\t\t\t    // declaration is split over multiple lines:\n\t\t\t    // cin_isfuncdecl returns FALSE then.\n\t\t\t    if (terminated == ',')\n\t\t\t\tbreak;\n\n\t\t\t    // if it is an enum declaration or an assignment,\n\t\t\t    // we are done.\n\t\t\t    if (terminated != ';' && cin_isinit())\n\t\t\t\tbreak;\n\n\t\t\t    // nothing useful found\n\t\t\t    if (terminated == 0 || terminated == '{')\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (terminated != ';')\n\t\t\t{\n\t\t\t    // Skip parens and braces. Position the cursor\n\t\t\t    // over the rightmost paren, so that matching it\n\t\t\t    // will take us back to the start of the line.\n\t\t\t    // XXX\n\t\t\t    trypos = NULL;\n\t\t\t    if (find_last_paren(l, '(', ')'))\n\t\t\t\ttrypos = find_match_paren(\n\t\t\t\t\t\t      curbuf->b_ind_maxparen);\n\n\t\t\t    if (trypos == NULL && find_last_paren(l, '{', '}'))\n\t\t\t\ttrypos = find_start_brace();\n\n\t\t\t    if (trypos != NULL)\n\t\t\t    {\n\t\t\t\tcurwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// it's a variable declaration, add indentation\n\t\t\t// like in\n\t\t\t// int a,\n\t\t\t//    b;\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t    }\n\t\t    else if (lookfor == LOOKFOR_UNTERM)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (lookfor != LOOKFOR_TERM\n\t\t\t\t\t&& lookfor != LOOKFOR_CPP_BASECLASS\n\t\t\t\t\t&& lookfor != LOOKFOR_COMMA)\n\t\t\t{\n\t\t\t    amount = scope_amount;\n\t\t\t    if (theline[0] == '{')\n\t\t\t    {\n\t\t\t\tamount += curbuf->b_ind_open_extra;\n\t\t\t\tadded_to_amount = curbuf->b_ind_open_extra;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (lookfor_cpp_namespace)\n\t\t\t{\n\t\t\t    // Looking for C++ namespace, need to look further\n\t\t\t    // back.\n\t\t\t    if (curwin->w_cursor.lnum == ourscope)\n\t\t\t\tcontinue;\n\n\t\t\t    if (curwin->w_cursor.lnum == 0\n\t\t\t\t    || curwin->w_cursor.lnum\n\t\t\t\t\t      < ourscope - FIND_NAMESPACE_LIM)\n\t\t\t\tbreak;\n\n\t\t\t    l = ml_get_curline();\n\n\t\t\t    // If we're in a comment or raw string now, skip\n\t\t\t    // to the start of it.\n\t\t\t    trypos = ind_find_start_CORS(NULL);\n\t\t\t    if (trypos != NULL)\n\t\t\t    {\n\t\t\t\tcurwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\t    // Skip preprocessor directives and blank lines.\n\t\t\t    if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t    &amount))\n\t\t\t\tcontinue;\n\n\t\t\t    // Finally the actual check for \"namespace\".\n\t\t\t    if (cin_is_cpp_namespace(l))\n\t\t\t    {\n\t\t\t\tamount += curbuf->b_ind_cpp_namespace\n\t\t\t\t\t\t\t    - added_to_amount;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else if (cin_is_cpp_extern_c(l))\n\t\t\t    {\n\t\t\t\tamount += curbuf->b_ind_cpp_extern_c\n\t\t\t\t\t\t\t    - added_to_amount;\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\t    if (cin_nocode(l))\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t\t// If we're in a comment or raw string now, skip to the start\n\t\t// of it.  XXX\n\t\tif ((trypos = ind_find_start_CORS(&raw_string_start)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    continue;\n\t\t}\n\n\t\tl = ml_get_curline();\n\n\t\t// If this is a switch() label, may line up relative to that.\n\t\t// If this is a C++ scope declaration, do the same.\n\t\tiscase = cin_iscase(l, FALSE);\n\t\tif (iscase || cin_isscopedecl(l))\n\t\t{\n\t\t    // we are only looking for cpp base class\n\t\t    // declaration/initialization any longer\n\t\t    if (lookfor == LOOKFOR_CPP_BASECLASS)\n\t\t\tbreak;\n\n\t\t    // When looking for a \"do\" we are not interested in\n\t\t    // labels.\n\t\t    if (whilelevel > 0)\n\t\t\tcontinue;\n\n\t\t    //\tcase xx:\n\t\t    //\t    c = 99 +\t    <- this indent plus continuation\n\t\t    //->\t   here;\n\t\t    if (lookfor == LOOKFOR_UNTERM\n\t\t\t\t\t   || lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    //\tcase xx:\t<- line up with this case\n\t\t    //\t    x = 333;\n\t\t    //\tcase yy:\n\t\t    if (       (iscase && lookfor == LOOKFOR_CASE)\n\t\t\t    || (iscase && lookfor_break)\n\t\t\t    || (!iscase && lookfor == LOOKFOR_SCOPEDECL))\n\t\t    {\n\t\t\t// Check that this case label is not for another\n\t\t\t// switch()\t\t    XXX\n\t\t\tif ((trypos = find_start_brace()) == NULL\n\t\t\t\t\t\t  || trypos->lnum == ourscope)\n\t\t\t{\n\t\t\t    amount = get_indent();\t// XXX\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    n = get_indent_nolabel(curwin->w_cursor.lnum);  // XXX\n\n\t\t    //\t case xx: if (cond)\t    <- line up with this if\n\t\t    //\t\t      y = y + 1;\n\t\t    // ->\t  s = 99;\n\t\t    //\n\t\t    //\t case xx:\n\t\t    //\t     if (cond)\t\t<- line up with this line\n\t\t    //\t\t y = y + 1;\n\t\t    // ->    s = 99;\n\t\t    if (lookfor == LOOKFOR_TERM)\n\t\t    {\n\t\t\tif (n)\n\t\t\t    amount = n;\n\n\t\t\tif (!lookfor_break)\n\t\t\t    break;\n\t\t    }\n\n\t\t    //\t case xx: x = x + 1;\t    <- line up with this x\n\t\t    // ->\t  y = y + 1;\n\t\t    //\n\t\t    //\t case xx: if (cond)\t    <- line up with this if\n\t\t    // ->\t       y = y + 1;\n\t\t    if (n)\n\t\t    {\n\t\t\tamount = n;\n\t\t\tl = after_label(ml_get_curline());\n\t\t\tif (l != NULL && cin_is_cinword(l))\n\t\t\t{\n\t\t\t    if (theline[0] == '{')\n\t\t\t\tamount += curbuf->b_ind_open_extra;\n\t\t\t    else\n\t\t\t\tamount += curbuf->b_ind_level\n\t\t\t\t\t\t     + curbuf->b_ind_no_brace;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\n\t\t    // Try to get the indent of a statement before the switch\n\t\t    // label.  If nothing is found, line up relative to the\n\t\t    // switch label.\n\t\t    //\t    break;\t\t<- may line up with this line\n\t\t    //\t case xx:\n\t\t    // ->   y = 1;\n\t\t    scope_amount = get_indent() + (iscase    // XXX\n\t\t\t\t\t? curbuf->b_ind_case_code\n\t\t\t\t\t: curbuf->b_ind_scopedecl_code);\n\t\t    lookfor = curbuf->b_ind_case_break\n\t\t\t\t\t      ? LOOKFOR_NOBREAK : LOOKFOR_ANY;\n\t\t    continue;\n\t\t}\n\n\t\t// Looking for a switch() label or C++ scope declaration,\n\t\t// ignore other lines, skip {}-blocks.\n\t\tif (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)\n\t\t{\n\t\t    if (find_last_paren(l, '{', '}')\n\t\t\t\t     && (trypos = find_start_brace()) != NULL)\n\t\t    {\n\t\t\tcurwin->w_cursor.lnum = trypos->lnum + 1;\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    }\n\t\t    continue;\n\t\t}\n\n\t\t// Ignore jump labels with nothing after them.\n\t\tif (!curbuf->b_ind_js && cin_islabel())\n\t\t{\n\t\t    l = after_label(ml_get_curline());\n\t\t    if (l == NULL || cin_nocode(l))\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore #defines, #if, etc.\n\t\t// Ignore comment and empty lines.\n\t\t// (need to get the line again, cin_islabel() may have\n\t\t// unlocked it)\n\t\tl = ml_get_curline();\n\t\tif (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount)\n\t\t\t\t\t\t\t     || cin_nocode(l))\n\t\t    continue;\n\n\t\t// Are we at the start of a cpp base class declaration or\n\t\t// constructor initialization?  XXX\n\t\tn = FALSE;\n\t\tif (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0)\n\t\t{\n\t\t    n = cin_is_cpp_baseclass(&cache_cpp_baseclass);\n\t\t    l = ml_get_curline();\n\t\t}\n\t\tif (n)\n\t\t{\n\t\t    if (lookfor == LOOKFOR_UNTERM)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t    }\n\t\t    else if (theline[0] == '{')\n\t\t    {\n\t\t\t// Need to find start of the declaration.\n\t\t\tlookfor = LOOKFOR_UNTERM;\n\t\t\tind_continuation = 0;\n\t\t\tcontinue;\n\t\t    }\n\t\t    else\n\t\t\t// XXX\n\t\t\tamount = get_baseclass_amount(\n\t\t\t\t\t\tcache_cpp_baseclass.lpos.col);\n\t\t    break;\n\t\t}\n\t\telse if (lookfor == LOOKFOR_CPP_BASECLASS)\n\t\t{\n\t\t    // only look, whether there is a cpp base class\n\t\t    // declaration or initialization before the opening brace.\n\t\t    if (cin_isterminated(l, TRUE, FALSE))\n\t\t\tbreak;\n\t\t    else\n\t\t\tcontinue;\n\t\t}\n\n\t\t// What happens next depends on the line being terminated.\n\t\t// If terminated with a ',' only consider it terminating if\n\t\t// there is another unterminated statement behind, eg:\n\t\t//   123,\n\t\t//   sizeof\n\t\t//\t  here\n\t\t// Otherwise check whether it is an enumeration or structure\n\t\t// initialisation (not indented) or a variable declaration\n\t\t// (indented).\n\t\tterminated = cin_isterminated(l, FALSE, TRUE);\n\n\t\tif (js_cur_has_key)\n\t\t{\n\t\t    js_cur_has_key = 0; // only check the first line\n\t\t    if (curbuf->b_ind_js && terminated == ',')\n\t\t    {\n\t\t\t// For Javascript we might be inside an object:\n\t\t\t//   key: something,  <- align with this\n\t\t\t//   key: something\n\t\t\t// or:\n\t\t\t//   key: something +  <- align with this\n\t\t\t//       something,\n\t\t\t//   key: something\n\t\t\tlookfor = LOOKFOR_JS_KEY;\n\t\t    }\n\t\t}\n\t\tif (lookfor == LOOKFOR_JS_KEY && cin_has_js_key(l))\n\t\t{\n\t\t    amount = get_indent();\n\t\t    break;\n\t\t}\n\t\tif (lookfor == LOOKFOR_COMMA)\n\t\t{\n\t\t    if (tryposBrace != NULL && tryposBrace->lnum\n\t\t\t\t\t\t    >= curwin->w_cursor.lnum)\n\t\t\tbreak;\n\t\t    if (terminated == ',')\n\t\t\t// line below current line is the one that starts a\n\t\t\t// (possibly broken) line ending in a comma.\n\t\t\tbreak;\n\t\t    else\n\t\t    {\n\t\t\tamount = get_indent();\n\t\t\tif (curwin->w_cursor.lnum - 1 == ourscope)\n\t\t\t    // line above is start of the scope, thus current\n\t\t\t    // line is the one that stars a (possibly broken)\n\t\t\t    // line ending in a comma.\n\t\t\t    break;\n\t\t    }\n\t\t}\n\n\t\tif (terminated == 0 || (lookfor != LOOKFOR_UNTERM\n\t\t\t\t\t\t\t&& terminated == ','))\n\t\t{\n\t\t    if (lookfor != LOOKFOR_ENUM_OR_INIT &&\n\t\t\t    (*skipwhite(l) == '[' || l[STRLEN(l) - 1] == '['))\n\t\t\tamount += ind_continuation;\n\t\t    // if we're in the middle of a paren thing,\n\t\t    // go back to the line that starts it so\n\t\t    // we can get the right prevailing indent\n\t\t    //\t   if ( foo &&\n\t\t    //\t\t    bar )\n\n\t\t    // Position the cursor over the rightmost paren, so that\n\t\t    // matching it will take us back to the start of the line.\n\t\t    // Ignore a match before the start of the block.\n\t\t    (void)find_last_paren(l, '(', ')');\n\t\t    trypos = find_match_paren(corr_ind_maxparen(&cur_curpos));\n\t\t    if (trypos != NULL && (trypos->lnum < tryposBrace->lnum\n\t\t\t\t|| (trypos->lnum == tryposBrace->lnum\n\t\t\t\t    && trypos->col < tryposBrace->col)))\n\t\t\ttrypos = NULL;\n\n\t\t    // If we are looking for ',', we also look for matching\n\t\t    // braces.\n\t\t    if (trypos == NULL && terminated == ','\n\t\t\t\t\t      && find_last_paren(l, '{', '}'))\n\t\t\ttrypos = find_start_brace();\n\n\t\t    if (trypos != NULL)\n\t\t    {\n\t\t\t// Check if we are on a case label now.  This is\n\t\t\t// handled above.\n\t\t\t//     case xx:  if ( asdf &&\n\t\t\t//\t\t\tasdf)\n\t\t\tcurwin->w_cursor = *trypos;\n\t\t\tl = ml_get_curline();\n\t\t\tif (cin_iscase(l, FALSE) || cin_isscopedecl(l))\n\t\t\t{\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    curwin->w_cursor.col = 0;\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\n\t\t    // Skip over continuation lines to find the one to get the\n\t\t    // indent from\n\t\t    // char *usethis = \"bla{backslash}\n\t\t    //\t\t bla\",\n\t\t    //      here;\n\t\t    if (terminated == ',')\n\t\t    {\n\t\t\twhile (curwin->w_cursor.lnum > 1)\n\t\t\t{\n\t\t\t    l = ml_get(curwin->w_cursor.lnum - 1);\n\t\t\t    if (*l == NUL || l[STRLEN(l) - 1] != '\\\\')\n\t\t\t\tbreak;\n\t\t\t    --curwin->w_cursor.lnum;\n\t\t\t    curwin->w_cursor.col = 0;\n\t\t\t}\n\t\t    }\n\n\t\t    // Get indent and pointer to text for current line,\n\t\t    // ignoring any jump label.  XXX\n\t\t    if (curbuf->b_ind_js)\n\t\t\tcur_amount = get_indent();\n\t\t    else\n\t\t\tcur_amount = skip_label(curwin->w_cursor.lnum, &l);\n\t\t    // If this is just above the line we are indenting, and it\n\t\t    // starts with a '{', line it up with this line.\n\t\t    //\t\twhile (not)\n\t\t    // ->\t{\n\t\t    //\t\t}\n\t\t    if (terminated != ',' && lookfor != LOOKFOR_TERM\n\t\t\t\t\t\t\t && theline[0] == '{')\n\t\t    {\n\t\t\tamount = cur_amount;\n\t\t\t// Only add b_ind_open_extra when the current line\n\t\t\t// doesn't start with a '{', which must have a match\n\t\t\t// in the same line (scope is the same).  Probably:\n\t\t\t//\t{ 1, 2 },\n\t\t\t// ->\t{ 3, 4 }\n\t\t\tif (*skipwhite(l) != '{')\n\t\t\t    amount += curbuf->b_ind_open_extra;\n\n\t\t\tif (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js)\n\t\t\t{\n\t\t\t    // have to look back, whether it is a cpp base\n\t\t\t    // class declaration or initialization\n\t\t\t    lookfor = LOOKFOR_CPP_BASECLASS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\n\t\t    // Check if we are after an \"if\", \"while\", etc.\n\t\t    // Also allow \"   } else\".\n\t\t    if (cin_is_cinword(l) || cin_iselse(skipwhite(l)))\n\t\t    {\n\t\t\t// Found an unterminated line after an if (), line up\n\t\t\t// with the last one.\n\t\t\t//   if (cond)\n\t\t\t//\t    100 +\n\t\t\t// ->\t\there;\n\t\t\tif (lookfor == LOOKFOR_UNTERM\n\t\t\t\t\t   || lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t\t{\n\t\t\t    if (cont_amount > 0)\n\t\t\t\tamount = cont_amount;\n\t\t\t    else\n\t\t\t\tamount += ind_continuation;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t// If this is just above the line we are indenting, we\n\t\t\t// are finished.\n\t\t\t//\t    while (not)\n\t\t\t// ->\t\there;\n\t\t\t// Otherwise this indent can be used when the line\n\t\t\t// before this is terminated.\n\t\t\t//\tyyy;\n\t\t\t//\tif (stat)\n\t\t\t//\t    while (not)\n\t\t\t//\t\txxx;\n\t\t\t// ->\there;\n\t\t\tamount = cur_amount;\n\t\t\tif (theline[0] == '{')\n\t\t\t    amount += curbuf->b_ind_open_extra;\n\t\t\tif (lookfor != LOOKFOR_TERM)\n\t\t\t{\n\t\t\t    amount += curbuf->b_ind_level\n\t\t\t\t\t\t     + curbuf->b_ind_no_brace;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t// Special trick: when expecting the while () after a\n\t\t\t// do, line up with the while()\n\t\t\t//     do\n\t\t\t//\t    x = 1;\n\t\t\t// ->  here\n\t\t\tl = skipwhite(ml_get_curline());\n\t\t\tif (cin_isdo(l))\n\t\t\t{\n\t\t\t    if (whilelevel == 0)\n\t\t\t\tbreak;\n\t\t\t    --whilelevel;\n\t\t\t}\n\n\t\t\t// When searching for a terminated line, don't use the\n\t\t\t// one between the \"if\" and the matching \"else\".\n\t\t\t// Need to use the scope of this \"else\".  XXX\n\t\t\t// If whilelevel != 0 continue looking for a \"do {\".\n\t\t\tif (cin_iselse(l) && whilelevel == 0)\n\t\t\t{\n\t\t\t    // If we're looking at \"} else\", let's make sure we\n\t\t\t    // find the opening brace of the enclosing scope,\n\t\t\t    // not the one from \"if () {\".\n\t\t\t    if (*l == '}')\n\t\t\t\tcurwin->w_cursor.col =\n\t\t\t\t\t  (colnr_T)(l - ml_get_curline()) + 1;\n\n\t\t\t    if ((trypos = find_start_brace()) == NULL\n\t\t\t\t       || find_match(LOOKFOR_IF, trypos->lnum)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\n\t\t    // If we're below an unterminated line that is not an\n\t\t    // \"if\" or something, we may line up with this line or\n\t\t    // add something for a continuation line, depending on\n\t\t    // the line before this one.\n\t\t    else\n\t\t    {\n\t\t\t// Found two unterminated lines on a row, line up with\n\t\t\t// the last one.\n\t\t\t//   c = 99 +\n\t\t\t//\t    100 +\n\t\t\t// ->\t    here;\n\t\t\tif (lookfor == LOOKFOR_UNTERM)\n\t\t\t{\n\t\t\t    // When line ends in a comma add extra indent\n\t\t\t    if (terminated == ',')\n\t\t\t\tamount += ind_continuation;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\tif (lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t\t{\n\t\t\t    // Found two lines ending in ',', lineup with the\n\t\t\t    // lowest one, but check for cpp base class\n\t\t\t    // declaration/initialization, if it is an\n\t\t\t    // opening brace or we are looking just for\n\t\t\t    // enumerations/initializations.\n\t\t\t    if (terminated == ',')\n\t\t\t    {\n\t\t\t\tif (curbuf->b_ind_cpp_baseclass == 0)\n\t\t\t\t    break;\n\n\t\t\t\tlookfor = LOOKFOR_CPP_BASECLASS;\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\t    // Ignore unterminated lines in between, but\n\t\t\t    // reduce indent.\n\t\t\t    if (amount > cur_amount)\n\t\t\t\tamount = cur_amount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Found first unterminated line on a row, may\n\t\t\t    // line up with this line, remember its indent\n\t\t\t    //\t    100 +\n\t\t\t    // ->\t    here;\n\t\t\t    l = ml_get_curline();\n\t\t\t    amount = cur_amount;\n\n\t\t\t    n = (int)STRLEN(l);\n\t\t\t    if (terminated == ',' && (*skipwhite(l) == ']'\n\t\t\t\t\t|| (n >=2 && l[n - 2] == ']')))\n\t\t\t\tbreak;\n\n\t\t\t    // If previous line ends in ',', check whether we\n\t\t\t    // are in an initialization or enum\n\t\t\t    // struct xxx =\n\t\t\t    // {\n\t\t\t    //      sizeof a,\n\t\t\t    //      124 };\n\t\t\t    // or a normal possible continuation line.\n\t\t\t    // but only, of no other statement has been found\n\t\t\t    // yet.\n\t\t\t    if (lookfor == LOOKFOR_INITIAL && terminated == ',')\n\t\t\t    {\n\t\t\t\tif (curbuf->b_ind_js)\n\t\t\t\t{\n\t\t\t\t    // Search for a line ending in a comma\n\t\t\t\t    // and line up with the line below it\n\t\t\t\t    // (could be the current line).\n\t\t\t\t    // some = [\n\t\t\t\t    //     1,     <- line up here\n\t\t\t\t    //     2,\n\t\t\t\t    // some = [\n\t\t\t\t    //     3 +    <- line up here\n\t\t\t\t    //       4 *\n\t\t\t\t    //        5,\n\t\t\t\t    //     6,\n\t\t\t\t    if (cin_iscomment(skipwhite(l)))\n\t\t\t\t\tbreak;\n\t\t\t\t    lookfor = LOOKFOR_COMMA;\n\t\t\t\t    trypos = find_match_char('[',\n\t\t\t\t\t\t      curbuf->b_ind_maxparen);\n\t\t\t\t    if (trypos != NULL)\n\t\t\t\t    {\n\t\t\t\t\tif (trypos->lnum\n\t\t\t\t\t\t == curwin->w_cursor.lnum - 1)\n\t\t\t\t\t{\n\t\t\t\t\t    // Current line is first inside\n\t\t\t\t\t    // [], line up with it.\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\tourscope = trypos->lnum;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    lookfor = LOOKFOR_ENUM_OR_INIT;\n\t\t\t\t    cont_amount = cin_first_id_amount();\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (lookfor == LOOKFOR_INITIAL\n\t\t\t\t\t&& *l != NUL\n\t\t\t\t\t&& l[STRLEN(l) - 1] == '\\\\')\n\t\t\t\t\t\t\t\t// XXX\n\t\t\t\t    cont_amount = cin_get_equal_amount(\n\t\t\t\t\t\t       curwin->w_cursor.lnum);\n\t\t\t\tif (lookfor != LOOKFOR_TERM\n\t\t\t\t\t\t&& lookfor != LOOKFOR_JS_KEY\n\t\t\t\t\t\t&& lookfor != LOOKFOR_COMMA\n\t\t\t\t\t\t&& raw_string_start != curwin->w_cursor.lnum)\n\t\t\t\t    lookfor = LOOKFOR_UNTERM;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t// Check if we are after a while (cond);\n\t\t// If so: Ignore until the matching \"do\".\n\t\telse if (cin_iswhileofdo_end(terminated)) // XXX\n\t\t{\n\t\t    // Found an unterminated line after a while ();, line up\n\t\t    // with the last one.\n\t\t    //\t    while (cond);\n\t\t    //\t    100 +\t\t<- line up with this one\n\t\t    // ->\t    here;\n\t\t    if (lookfor == LOOKFOR_UNTERM\n\t\t\t\t\t   || lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    if (whilelevel == 0)\n\t\t    {\n\t\t\tlookfor = LOOKFOR_TERM;\n\t\t\tamount = get_indent();\t    // XXX\n\t\t\tif (theline[0] == '{')\n\t\t\t    amount += curbuf->b_ind_open_extra;\n\t\t    }\n\t\t    ++whilelevel;\n\t\t}\n\n\t\t// We are after a \"normal\" statement.\n\t\t// If we had another statement we can stop now and use the\n\t\t// indent of that other statement.\n\t\t// Otherwise the indent of the current statement may be used,\n\t\t// search backwards for the next \"normal\" statement.\n\t\telse\n\t\t{\n\t\t    // Skip single break line, if before a switch label. It\n\t\t    // may be lined up with the case label.\n\t\t    if (lookfor == LOOKFOR_NOBREAK\n\t\t\t\t  && cin_isbreak(skipwhite(ml_get_curline())))\n\t\t    {\n\t\t\tlookfor = LOOKFOR_ANY;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    // Handle \"do {\" line.\n\t\t    if (whilelevel > 0)\n\t\t    {\n\t\t\tl = cin_skipcomment(ml_get_curline());\n\t\t\tif (cin_isdo(l))\n\t\t\t{\n\t\t\t    amount = get_indent();\t// XXX\n\t\t\t    --whilelevel;\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\n\t\t    // Found a terminated line above an unterminated line. Add\n\t\t    // the amount for a continuation line.\n\t\t    //\t x = 1;\n\t\t    //\t y = foo +\n\t\t    // ->\there;\n\t\t    // or\n\t\t    //\t int x = 1;\n\t\t    //\t int foo,\n\t\t    // ->\there;\n\t\t    if (lookfor == LOOKFOR_UNTERM\n\t\t\t\t\t   || lookfor == LOOKFOR_ENUM_OR_INIT)\n\t\t    {\n\t\t\tif (cont_amount > 0)\n\t\t\t    amount = cont_amount;\n\t\t\telse\n\t\t\t    amount += ind_continuation;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    // Found a terminated line above a terminated line or \"if\"\n\t\t    // etc. line. Use the amount of the line below us.\n\t\t    //\t x = 1;\t\t\t\tx = 1;\n\t\t    //\t if (asdf)\t\t    y = 2;\n\t\t    //\t     while (asdf)\t  ->here;\n\t\t    //\t\there;\n\t\t    // ->foo;\n\t\t    if (lookfor == LOOKFOR_TERM)\n\t\t    {\n\t\t\tif (!lookfor_break && whilelevel == 0)\n\t\t\t    break;\n\t\t    }\n\n\t\t    // First line above the one we're indenting is terminated.\n\t\t    // To know what needs to be done look further backward for\n\t\t    // a terminated line.\n\t\t    else\n\t\t    {\n\t\t\t// position the cursor over the rightmost paren, so\n\t\t\t// that matching it will take us back to the start of\n\t\t\t// the line.  Helps for:\n\t\t\t//     func(asdr,\n\t\t\t//\t      asdfasdf);\n\t\t\t//     here;\nterm_again:\n\t\t\tl = ml_get_curline();\n\t\t\tif (find_last_paren(l, '(', ')')\n\t\t\t\t&& (trypos = find_match_paren(\n\t\t\t\t\t   curbuf->b_ind_maxparen)) != NULL)\n\t\t\t{\n\t\t\t    // Check if we are on a case label now.  This is\n\t\t\t    // handled above.\n\t\t\t    //\t   case xx:  if ( asdf &&\n\t\t\t    //\t\t\t    asdf)\n\t\t\t    curwin->w_cursor = *trypos;\n\t\t\t    l = ml_get_curline();\n\t\t\t    if (cin_iscase(l, FALSE) || cin_isscopedecl(l))\n\t\t\t    {\n\t\t\t\t++curwin->w_cursor.lnum;\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// When aligning with the case statement, don't align\n\t\t\t// with a statement after it.\n\t\t\t//  case 1: {   <-- don't use this { position\n\t\t\t//\tstat;\n\t\t\t//  }\n\t\t\t//  case 2:\n\t\t\t//\tstat;\n\t\t\t// }\n\t\t\tiscase = (curbuf->b_ind_keep_case_label\n\t\t\t\t\t\t     && cin_iscase(l, FALSE));\n\n\t\t\t// Get indent and pointer to text for current line,\n\t\t\t// ignoring any jump label.\n\t\t\tamount = skip_label(curwin->w_cursor.lnum, &l);\n\n\t\t\tif (theline[0] == '{')\n\t\t\t    amount += curbuf->b_ind_open_extra;\n\t\t\t// See remark above: \"Only add b_ind_open_extra..\"\n\t\t\tl = skipwhite(l);\n\t\t\tif (*l == '{')\n\t\t\t    amount -= curbuf->b_ind_open_extra;\n\t\t\tlookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;\n\n\t\t\t// When a terminated line starts with \"else\" skip to\n\t\t\t// the matching \"if\":\n\t\t\t//       else 3;\n\t\t\t//\t     indent this;\n\t\t\t// Need to use the scope of this \"else\".  XXX\n\t\t\t// If whilelevel != 0 continue looking for a \"do {\".\n\t\t\tif (lookfor == LOOKFOR_TERM\n\t\t\t\t&& *l != '}'\n\t\t\t\t&& cin_iselse(l)\n\t\t\t\t&& whilelevel == 0)\n\t\t\t{\n\t\t\t    if ((trypos = find_start_brace()) == NULL\n\t\t\t\t       || find_match(LOOKFOR_IF, trypos->lnum)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t\tbreak;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// If we're at the end of a block, skip to the start of\n\t\t\t// that block.\n\t\t\tl = ml_get_curline();\n\t\t\tif (find_last_paren(l, '{', '}') // XXX\n\t\t\t\t     && (trypos = find_start_brace()) != NULL)\n\t\t\t{\n\t\t\t    curwin->w_cursor = *trypos;\n\t\t\t    // if not \"else {\" check for terminated again\n\t\t\t    // but skip block for \"} else {\"\n\t\t\t    l = cin_skipcomment(ml_get_curline());\n\t\t\t    if (*l == '}' || !cin_iselse(l))\n\t\t\t\tgoto term_again;\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    curwin->w_cursor.col = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n      }\n\n      // add extra indent for a comment\n      if (cin_iscomment(theline))\n\t  amount += curbuf->b_ind_comment;\n\n      // subtract extra left-shift for jump labels\n      if (curbuf->b_ind_jump_label > 0 && original_line_islabel)\n\t  amount -= curbuf->b_ind_jump_label;\n\n      goto theend;\n    }\n\n    // ok -- we're not inside any sort of structure at all!\n    //\n    // This means we're at the top level, and everything should\n    // basically just match where the previous line is, except\n    // for the lines immediately following a function declaration,\n    // which are K&R-style parameters and need to be indented.\n    //\n    // if our line starts with an open brace, forget about any\n    // prevailing indent and make sure it looks like the start\n    // of a function\n\n    if (theline[0] == '{')\n    {\n\tamount = curbuf->b_ind_first_open;\n\tgoto theend;\n    }\n\n    // If the NEXT line is a function declaration, the current\n    // line needs to be indented as a function type spec.\n    // Don't do this if the current line looks like a comment or if the\n    // current line is terminated, ie. ends in ';', or if the current line\n    // contains { or }: \"void f() {\\n if (1)\"\n    if (cur_curpos.lnum < curbuf->b_ml.ml_line_count\n\t    && !cin_nocode(theline)\n\t    && vim_strchr(theline, '{') == NULL\n\t    && vim_strchr(theline, '}') == NULL\n\t    && !cin_ends_in(theline, (char_u *)\":\", NULL)\n\t    && !cin_ends_in(theline, (char_u *)\",\", NULL)\n\t    && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,\n\t\t\t      cur_curpos.lnum + 1)\n\t    && !cin_isterminated(theline, FALSE, TRUE))\n    {\n\tamount = curbuf->b_ind_func_type;\n\tgoto theend;\n    }\n\n    // search backwards until we find something we recognize\n    amount = 0;\n    curwin->w_cursor = cur_curpos;\n    while (curwin->w_cursor.lnum > 1)\n    {\n\tcurwin->w_cursor.lnum--;\n\tcurwin->w_cursor.col = 0;\n\n\tl = ml_get_curline();\n\n\t// If we're in a comment or raw string now, skip to the start\n\t// of it.  XXX\n\tif ((trypos = ind_find_start_CORS(NULL)) != NULL)\n\t{\n\t    curwin->w_cursor.lnum = trypos->lnum + 1;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\n\t// Are we at the start of a cpp base class declaration or\n\t// constructor initialization?  XXX\n\tn = FALSE;\n\tif (curbuf->b_ind_cpp_baseclass != 0 && theline[0] != '{')\n\t{\n\t    n = cin_is_cpp_baseclass(&cache_cpp_baseclass);\n\t    l = ml_get_curline();\n\t}\n\tif (n)\n\t{\n\t\t\t\t\t\t\t     // XXX\n\t    amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);\n\t    break;\n\t}\n\n\t// Skip preprocessor directives and blank lines.\n\tif (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount))\n\t    continue;\n\n\tif (cin_nocode(l))\n\t    continue;\n\n\t// If the previous line ends in ',', use one level of\n\t// indentation:\n\t// int foo,\n\t//     bar;\n\t// do this before checking for '}' in case of eg.\n\t// enum foobar\n\t// {\n\t//   ...\n\t// } foo,\n\t//   bar;\n\tn = 0;\n\tif (cin_ends_in(l, (char_u *)\",\", NULL)\n\t\t     || (*l != NUL && (n = l[STRLEN(l) - 1]) == '\\\\'))\n\t{\n\t    // take us back to opening paren\n\t    if (find_last_paren(l, '(', ')')\n\t\t    && (trypos = find_match_paren(\n\t\t\t\t     curbuf->b_ind_maxparen)) != NULL)\n\t\tcurwin->w_cursor = *trypos;\n\n\t    // For a line ending in ',' that is a continuation line go\n\t    // back to the first line with a backslash:\n\t    // char *foo = \"bla{backslash}\n\t    //\t\t bla\",\n\t    //      here;\n\t    while (n == 0 && curwin->w_cursor.lnum > 1)\n\t    {\n\t\tl = ml_get(curwin->w_cursor.lnum - 1);\n\t\tif (*l == NUL || l[STRLEN(l) - 1] != '\\\\')\n\t\t    break;\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t    }\n\n\t    amount = get_indent();\t    // XXX\n\n\t    if (amount == 0)\n\t\tamount = cin_first_id_amount();\n\t    if (amount == 0)\n\t\tamount = ind_continuation;\n\t    break;\n\t}\n\n\t// If the line looks like a function declaration, and we're\n\t// not in a comment, put it the left margin.\n\tif (cin_isfuncdecl(NULL, cur_curpos.lnum, 0))  // XXX\n\t    break;\n\tl = ml_get_curline();\n\n\t// Finding the closing '}' of a previous function.  Put\n\t// current line at the left margin.  For when 'cino' has \"fs\".\n\tif (*skipwhite(l) == '}')\n\t    break;\n\n\t//\t\t\t    (matching {)\n\t// If the previous line ends on '};' (maybe followed by\n\t// comments) align at column 0.  For example:\n\t// char *string_array[] = { \"foo\",\n\t//     / * x * / \"b};ar\" }; / * foobar * /\n\tif (cin_ends_in(l, (char_u *)\"};\", NULL))\n\t    break;\n\n\t// If the previous line ends on '[' we are probably in an\n\t// array constant:\n\t// something = [\n\t//     234,  <- extra indent\n\tif (cin_ends_in(l, (char_u *)\"[\", NULL))\n\t{\n\t    amount = get_indent() + ind_continuation;\n\t    break;\n\t}\n\n\t// Find a line only has a semicolon that belongs to a previous\n\t// line ending in '}', e.g. before an #endif.  Don't increase\n\t// indent then.\n\tif (*(look = skipwhite(l)) == ';' && cin_nocode(look + 1))\n\t{\n\t    pos_T curpos_save = curwin->w_cursor;\n\n\t    while (curwin->w_cursor.lnum > 1)\n\t    {\n\t\tlook = ml_get(--curwin->w_cursor.lnum);\n\t\tif (!(cin_nocode(look) || cin_ispreproc_cont(\n\t\t\t\t      &look, &curwin->w_cursor.lnum, &amount)))\n\t\t    break;\n\t    }\n\t    if (curwin->w_cursor.lnum > 0\n\t\t\t    && cin_ends_in(look, (char_u *)\"}\", NULL))\n\t\tbreak;\n\n\t    curwin->w_cursor = curpos_save;\n\t}\n\n\t// If the PREVIOUS line is a function declaration, the current\n\t// line (and the ones that follow) needs to be indented as\n\t// parameters.\n\tif (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))\n\t{\n\t    amount = curbuf->b_ind_param;\n\t    break;\n\t}\n\n\t// If the previous line ends in ';' and the line before the\n\t// previous line ends in ',' or '\\', ident to column zero:\n\t// int foo,\n\t//     bar;\n\t// indent_to_0 here;\n\tif (cin_ends_in(l, (char_u *)\";\", NULL))\n\t{\n\t    l = ml_get(curwin->w_cursor.lnum - 1);\n\t    if (cin_ends_in(l, (char_u *)\",\", NULL)\n\t\t    || (*l != NUL && l[STRLEN(l) - 1] == '\\\\'))\n\t\tbreak;\n\t    l = ml_get_curline();\n\t}\n\n\t// Doesn't look like anything interesting -- so just\n\t// use the indent of this line.\n\t//\n\t// Position the cursor over the rightmost paren, so that\n\t// matching it will take us back to the start of the line.\n\tfind_last_paren(l, '(', ')');\n\n\tif ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)\n\t    curwin->w_cursor = *trypos;\n\tamount = get_indent();\t    // XXX\n\tbreak;\n    }\n\n    // add extra indent for a comment\n    if (cin_iscomment(theline))\n\tamount += curbuf->b_ind_comment;\n\n    // add extra indent if the previous line ended in a backslash:\n    //\t      \"asdfasdf{backslash}\n    //\t\t  here\";\n    //\t    char *foo = \"asdf{backslash}\n    //\t\t\t here\";\n    if (cur_curpos.lnum > 1)\n    {\n\tl = ml_get(cur_curpos.lnum - 1);\n\tif (*l != NUL && l[STRLEN(l) - 1] == '\\\\')\n\t{\n\t    cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);\n\t    if (cur_amount > 0)\n\t\tamount = cur_amount;\n\t    else if (cur_amount == 0)\n\t\tamount += ind_continuation;\n\t}\n    }\n\ntheend:\n    if (amount < 0)\n\tamount = 0;\n\nlaterend:\n    // put the cursor back where it belongs\n    curwin->w_cursor = cur_curpos;\n\n    vim_free(linecopy);\n\n    return amount;\n}\n\n/*\n * return TRUE if 'cinkeys' contains the key \"keytyped\",\n * when == '*':\t    Only if key is preceded with '*'\t(indent before insert)\n * when == '!':\t    Only if key is preceded with '!'\t(don't insert)\n * when == ' ':\t    Only if key is not preceded with '*'(indent afterwards)\n *\n * \"keytyped\" can have a few special values:\n * KEY_OPEN_FORW\n * KEY_OPEN_BACK\n * KEY_COMPLETE\t    just finished completion.\n *\n * If line_is_empty is TRUE accept keys with '0' before them.\n */\n    int\nin_cinkeys(\n    int\t\tkeytyped,\n    int\t\twhen,\n    int\t\tline_is_empty)\n{\n    char_u\t*look;\n    int\t\ttry_match;\n    int\t\ttry_match_word;\n    char_u\t*p;\n    char_u\t*line;\n    int\t\ticase;\n    int\t\ti;\n\n    if (keytyped == NUL)\n\t// Can happen with CTRL-Y and CTRL-E on a short line.\n\treturn FALSE;\n\n#ifdef FEAT_EVAL\n    if (*curbuf->b_p_inde != NUL)\n\tlook = curbuf->b_p_indk;\t// 'indentexpr' set: use 'indentkeys'\n    else\n#endif\n\tlook = curbuf->b_p_cink;\t// 'indentexpr' empty: use 'cinkeys'\n    while (*look)\n    {\n\t// Find out if we want to try a match with this key, depending on\n\t// 'when' and a '*' or '!' before the key.\n\tswitch (when)\n\t{\n\t    case '*': try_match = (*look == '*'); break;\n\t    case '!': try_match = (*look == '!'); break;\n\t     default: try_match = (*look != '*'); break;\n\t}\n\tif (*look == '*' || *look == '!')\n\t    ++look;\n\n\t// If there is a '0', only accept a match if the line is empty.\n\t// But may still match when typing last char of a word.\n\tif (*look == '0')\n\t{\n\t    try_match_word = try_match;\n\t    if (!line_is_empty)\n\t\ttry_match = FALSE;\n\t    ++look;\n\t}\n\telse\n\t    try_match_word = FALSE;\n\n\t// does it look like a control character?\n\tif (*look == '^'\n#ifdef EBCDIC\n\t\t&& (Ctrl_chr(look[1]) != 0)\n#else\n\t\t&& look[1] >= '?' && look[1] <= '_'\n#endif\n\t\t)\n\t{\n\t    if (try_match && keytyped == Ctrl_chr(look[1]))\n\t\treturn TRUE;\n\t    look += 2;\n\t}\n\t// 'o' means \"o\" command, open forward.\n\t// 'O' means \"O\" command, open backward.\n\telse if (*look == 'o')\n\t{\n\t    if (try_match && keytyped == KEY_OPEN_FORW)\n\t\treturn TRUE;\n\t    ++look;\n\t}\n\telse if (*look == 'O')\n\t{\n\t    if (try_match && keytyped == KEY_OPEN_BACK)\n\t\treturn TRUE;\n\t    ++look;\n\t}\n\n\t// 'e' means to check for \"else\" at start of line and just before the\n\t// cursor.\n\telse if (*look == 'e')\n\t{\n\t    if (try_match && keytyped == 'e' && curwin->w_cursor.col >= 4)\n\t    {\n\t\tp = ml_get_curline();\n\t\tif (skipwhite(p) == p + curwin->w_cursor.col - 4 &&\n\t\t\tSTRNCMP(p + curwin->w_cursor.col - 4, \"else\", 4) == 0)\n\t\t    return TRUE;\n\t    }\n\t    ++look;\n\t}\n\n\t// ':' only causes an indent if it is at the end of a label or case\n\t// statement, or when it was before typing the ':' (to fix\n\t// class::method for C++).\n\telse if (*look == ':')\n\t{\n\t    if (try_match && keytyped == ':')\n\t    {\n\t\tp = ml_get_curline();\n\t\tif (cin_iscase(p, FALSE) || cin_isscopedecl(p) || cin_islabel())\n\t\t    return TRUE;\n\t\t// Need to get the line again after cin_islabel().\n\t\tp = ml_get_curline();\n\t\tif (curwin->w_cursor.col > 2\n\t\t\t&& p[curwin->w_cursor.col - 1] == ':'\n\t\t\t&& p[curwin->w_cursor.col - 2] == ':')\n\t\t{\n\t\t    p[curwin->w_cursor.col - 1] = ' ';\n\t\t    i = (cin_iscase(p, FALSE) || cin_isscopedecl(p)\n\t\t\t\t\t\t\t    || cin_islabel());\n\t\t    p = ml_get_curline();\n\t\t    p[curwin->w_cursor.col - 1] = ':';\n\t\t    if (i)\n\t\t\treturn TRUE;\n\t\t}\n\t    }\n\t    ++look;\n\t}\n\n\n\t// Is it a key in <>, maybe?\n\telse if (*look == '<')\n\t{\n\t    if (try_match)\n\t    {\n\t\t// make up some named keys <o>, <O>, <e>, <0>, <>>, <<>, <*>,\n\t\t// <:> and <!> so that people can re-indent on o, O, e, 0, <,\n\t\t// >, *, : and ! keys if they really really want to.\n\t\tif (vim_strchr((char_u *)\"<>!*oOe0:\", look[1]) != NULL\n\t\t\t\t\t\t       && keytyped == look[1])\n\t\t    return TRUE;\n\n\t\tif (keytyped == get_special_key_code(look + 1))\n\t\t    return TRUE;\n\t    }\n\t    while (*look && *look != '>')\n\t\tlook++;\n\t    while (*look == '>')\n\t\tlook++;\n\t}\n\n\t// Is it a word: \"=word\"?\n\telse if (*look == '=' && look[1] != ',' && look[1] != NUL)\n\t{\n\t    ++look;\n\t    if (*look == '~')\n\t    {\n\t\ticase = TRUE;\n\t\t++look;\n\t    }\n\t    else\n\t\ticase = FALSE;\n\t    p = vim_strchr(look, ',');\n\t    if (p == NULL)\n\t\tp = look + STRLEN(look);\n\t    if ((try_match || try_match_word)\n\t\t    && curwin->w_cursor.col >= (colnr_T)(p - look))\n\t    {\n\t\tint\t\tmatch = FALSE;\n\n\t\tif (keytyped == KEY_COMPLETE)\n\t\t{\n\t\t    char_u\t*s;\n\n\t\t    // Just completed a word, check if it starts with \"look\".\n\t\t    // search back for the start of a word.\n\t\t    line = ml_get_curline();\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tchar_u\t*n;\n\n\t\t\tfor (s = line + curwin->w_cursor.col; s > line; s = n)\n\t\t\t{\n\t\t\t    n = mb_prevptr(line, s);\n\t\t\t    if (!vim_iswordp(n))\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfor (s = line + curwin->w_cursor.col; s > line; --s)\n\t\t\t    if (!vim_iswordc(s[-1]))\n\t\t\t\tbreak;\n\t\t    if (s + (p - look) <= line + curwin->w_cursor.col\n\t\t\t    && (icase\n\t\t\t\t? MB_STRNICMP(s, look, p - look)\n\t\t\t\t: STRNCMP(s, look, p - look)) == 0)\n\t\t\tmatch = TRUE;\n\t\t}\n\t\telse\n\t\t    // TODO: multi-byte\n\t\t    if (keytyped == (int)p[-1] || (icase && keytyped < 256\n\t\t\t && TOLOWER_LOC(keytyped) == TOLOWER_LOC((int)p[-1])))\n\t\t{\n\t\t    line = ml_get_cursor();\n\t\t    if ((curwin->w_cursor.col == (colnr_T)(p - look)\n\t\t\t\t|| !vim_iswordc(line[-(p - look) - 1]))\n\t\t\t    && (icase\n\t\t\t\t? MB_STRNICMP(line - (p - look), look, p - look)\n\t\t\t\t: STRNCMP(line - (p - look), look, p - look))\n\t\t\t\t\t\t\t\t\t == 0)\n\t\t\tmatch = TRUE;\n\t\t}\n\t\tif (match && try_match_word && !try_match)\n\t\t{\n\t\t    // \"0=word\": Check if there are only blanks before the\n\t\t    // word.\n\t\t    if (getwhitecols_curline() !=\n\t\t\t\t     (int)(curwin->w_cursor.col - (p - look)))\n\t\t\tmatch = FALSE;\n\t\t}\n\t\tif (match)\n\t\t    return TRUE;\n\t    }\n\t    look = p;\n\t}\n\n\t// ok, it's a boring generic character.\n\telse\n\t{\n\t    if (try_match && *look == keytyped)\n\t\treturn TRUE;\n\t    if (*look != NUL)\n\t\t++look;\n\t}\n\n\t// Skip over \", \".\n\tlook = skip_to_option_part(look);\n    }\n    return FALSE;\n}\n\n/*\n * Do C or expression indenting on the current line.\n */\n    void\ndo_c_expr_indent(void)\n{\n# ifdef FEAT_EVAL\n    if (*curbuf->b_p_inde != NUL)\n\tfixthisline(get_expr_indent);\n    else\n# endif\n\tfixthisline(get_c_indent);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"cindent(lnum)\" function\n */\n    void\nf_cindent(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# ifdef FEAT_CINDENT\n    pos_T\tpos;\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = curwin->w_cursor;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tcurwin->w_cursor.lnum = lnum;\n\trettv->vval.v_number = get_c_indent();\n\tcurwin->w_cursor = pos;\n    }\n    else\n# endif\n\trettv->vval.v_number = -1;\n}\n#endif\n", "\" Test for cinoptions and cindent\n\nfunc Test_cino_hash()\n  \" Test that curbuf->b_ind_hash_comment is correctly reset\n  new\n  setlocal cindent cinoptions=#1\n  setlocal cinoptions=\n  call setline(1, [\"#include <iostream>\"])\n  call cursor(1, 1)\n  norm! o#include\n  \"call feedkeys(\"o#include\\<esc>\", 't')\n  call assert_equal([\"#include <iostream>\", \"#include\"], getline(1,2))\n  bwipe!\nendfunc\n\nfunc Test_cino_extern_c()\n  \" Test for cino-E\n\n  let without_ind =<< trim [CODE]\n    #ifdef __cplusplus\n    extern \"C\" {\n    #endif\n    int func_a(void);\n    #ifdef __cplusplus\n    }\n    #endif\n  [CODE]\n\n  let with_ind =<< trim [CODE]\n    #ifdef __cplusplus\n    extern \"C\" {\n    #endif\n    \tint func_a(void);\n    #ifdef __cplusplus\n    }\n    #endif\n  [CODE]\n  new\n  setlocal cindent cinoptions=E0\n  call setline(1, without_ind)\n  call feedkeys(\"gg=G\", 'tx')\n  call assert_equal(with_ind, getline(1, '$'))\n\n  setlocal cinoptions=E-s\n  call setline(1, with_ind)\n  call feedkeys(\"gg=G\", 'tx')\n  call assert_equal(without_ind, getline(1, '$'))\n\n  setlocal cinoptions=Es\n  let tests = [\n        \\ ['recognized', ['extern \"C\" {'], \"\\t\\t;\"],\n        \\ ['recognized', ['extern \"C++\" {'], \"\\t\\t;\"],\n        \\ ['recognized', ['extern /* com */ \"C\"{'], \"\\t\\t;\"],\n        \\ ['recognized', ['extern\"C\"{'], \"\\t\\t;\"],\n        \\ ['recognized', ['extern \"C\"', '{'], \"\\t\\t;\"],\n        \\ ['not recognized', ['extern {'], \"\\t;\"],\n        \\ ['not recognized', ['extern /*\"C\"*/{'], \"\\t;\"],\n        \\ ['not recognized', ['extern \"C\" //{'], \";\"],\n        \\ ['not recognized', ['extern \"C\" /*{*/'], \";\"],\n        \\ ]\n\n  for pair in tests\n    let lines = pair[1]\n    call setline(1, lines)\n    call feedkeys(len(lines) . \"Go;\", 'tx')\n    call assert_equal(pair[2], getline(len(lines) + 1), 'Failed for \"' . string(lines) . '\"')\n  endfor\n\n  bwipe!\nendfunc\n\nfunc Test_cindent_rawstring()\n  new\n  setl cindent\n  call feedkeys(\"i\" .\n          \\ \"int main() {\\<CR>\" .\n          \\ \"R\\\"(\\<CR>\" .\n          \\ \")\\\";\\<CR>\" .\n          \\ \"statement;\\<Esc>\", \"x\")\n  call assert_equal(\"\\tstatement;\", getline(line('.')))\n  bw!\nendfunc\n\nfunc Test_cindent_expr()\n  new\n  func! MyIndentFunction()\n    return v:lnum == 1 ? shiftwidth() : 0\n  endfunc\n  setl expandtab sw=8 indentkeys+=; indentexpr=MyIndentFunction()\n  let testinput =<< trim [CODE]\n    var_a = something()\n    b = something()\n  [CODE]\n  call setline(1, testinput)\n  call cursor(1, 1)\n  call feedkeys(\"^\\<c-v>j$A;\\<esc>\", 'tnix')\n  let expected =<< [CODE]\n        var_a = something();\nb = something();\n[CODE]\n  call assert_equal(expected, getline(1, '$'))\n\n  %d\n  let testinput =<< [CODE]\n                var_a = something()\n                b = something()\n[CODE]\n  call setline(1, testinput)\n  call cursor(1, 1)\n  call feedkeys(\"^\\<c-v>j$A;\\<esc>\", 'tnix')\n  let expected =<< [CODE]\n        var_a = something();\n                b = something()\n[CODE]\n  call assert_equal(expected, getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_cindent_func()\n  new\n  setlocal cindent\n  call setline(1, ['int main(void)', '{', 'return 0;', '}'])\n  call assert_equal(-1, cindent(0))\n  call assert_equal(&sw, 3->cindent())\n  call assert_equal(-1, cindent(line('$')+1))\n  bwipe!\nendfunc\n\nfunc Test_cindent_1()\n  new\n  setl cindent ts=4 sw=4\n  setl cino& sts&\n\n  let code =<< trim [CODE]\n  /* start of AUTO matically checked vim: set ts=4 : */\n  {\n  \tif (test)\n  \t\tcmd1;\n  \tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t\tcmd1;\n  \telse\n  \t\tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\tcmd2;\n  \t}\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\telse\n  \t}\n  }\n\n  {\n  \twhile (this)\n  \t\tif (test)\n  \t\t\tcmd1;\n  \tcmd2;\n  }\n\n  {\n  \twhile (this)\n  \t\tif (test)\n  \t\t\tcmd1;\n  \t\telse\n  \t\t\tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd;\n  \t}\n\n  \tif (test)\n  \t\tcmd;\n  }\n\n  {\n  \tif (test) {\n  \t\tcmd;\n  \t}\n\n  \tif (test) cmd;\n  }\n\n  {\n  \tcmd1;\n  \tfor (blah)\n  \t\twhile (this)\n  \t\t\tif (test)\n  \t\t\t\tcmd2;\n  \tcmd3;\n  }\n\n  {\n  \tcmd1;\n  \tfor (blah)\n  \t\twhile (this)\n  \t\t\tif (test)\n  \t\t\t\tcmd2;\n  \tcmd3;\n\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\tcmd2;\n  \t\tcmd3;\n  \t}\n  }\n\n\n  /* Test for 'cindent' do/while mixed with if/else: */\n\n  {\n  \tdo\n  \t\tif (asdf)\n  \t\t\tasdfasd;\n  \twhile (cond);\n\n  \tdo\n  \t\tif (asdf)\n  \t\t\twhile (asdf)\n  \t\t\t\tasdf;\n  \twhile (asdf);\n  }\n\n  /* Test for 'cindent' with two ) on a continuation line */\n  {\n  \tif (asdfasdf;asldkfj asdlkfj as;ldkfj sal;d\n  \t\t\taal;sdkjf  ( ;asldfkja;sldfk\n  \t\t\t\t\tal;sdjfka ;slkdf ) sa;ldkjfsa dlk;)\n  \t\tline up here;\n  }\n\n\n  /* C++ tests: */\n\n  // foo()\t\tthese three lines should remain in column 0\n  // {\n  // }\n\n  /* Test for continuation and unterminated lines: */\n  {\n  \ti = 99 + 14325 +\n  \t\t21345 +\n  \t\t21345 +\n  \t\t21345 + ( 21345 +\n  \t\t\t\t21345) +\n  \t\t2345 +\n  \t\t1234;\n  \tc = 1;\n  }\n\n  /*\n     testje for indent with empty line\n\n     here */\n\n  {\n  \tif (testing &&\n  \t\t\tnot a joke ||\n  \t\t\tline up here)\n  \t\thay;\n  \tif (testing &&\n  \t\t\t(not a joke || testing\n  \t\t\t)line up here)\n  \t\thay;\n  \tif (testing &&\n  \t\t\t(not a joke || testing\n  \t\t\t line up here))\n  \t\thay;\n  }\n\n\n  {\n  \tswitch (c)\n  \t{\n  \t\tcase xx:\n  \t\t\tdo\n  \t\t\t\tif (asdf)\n  \t\t\t\t\tdo\n  \t\t\t\t\t\tasdfasdf;\n  \t\t\t\t\twhile (asdf);\n  \t\t\t\telse\n  \t\t\t\t\tasdfasdf;\n  \t\t\twhile (cond);\n  \t\tcase yy:\n  \t\tcase xx:\n  \t\tcase zz:\n  \t\t\ttesting;\n  \t}\n  }\n\n  {\n  \tif (cond) {\n  \t\tfoo;\n  \t}\n  \telse\n  \t{\n  \t\tbar;\n  \t}\n  }\n\n  {\n  \tif (alskdfj ;alsdkfjal;skdjf (;sadlkfsa ;dlkf j;alksdfj ;alskdjf\n  \t\t\talsdkfj (asldk;fj\n  \t\t\t\t\tawith cino=(0 ;lf this one goes to below the paren with ==\n  \t\t\t\t\t\t\t;laksjfd ;lsakdjf ;alskdf asd)\n  \t\t\t\t\tasdfasdf;)))\n  \t\tasdfasdf;\n  }\n\n  \tint\n  func(a, b)\n  \tint a;\n  \tint c;\n  {\n  \tif (c1 && (c2 ||\n  \t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3)\n  \t   )\n  }\n\n  {\n  \twhile (asd)\n  \t{\n  \t\tif (asdf)\n  \t\t\tif (test)\n  \t\t\t\tif (that)\n  \t\t\t\t{\n  \t\t\t\t\tif (asdf)\n  \t\t\t\t\t\tdo\n  \t\t\t\t\t\t\tcdasd;\n  \t\t\t\t\t\twhile (as\n  \t\t\t\t\t\t\t\tdf);\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t\tif (asdf)\n  \t\t\t\t\t\tasdf;\n  \t\t\t\t\telse\n  \t\t\t\t\t\tasdf;\n  \t\tasdf;\n  \t}\n  }\n\n  {\n  \ts = \"/*\"; b = ';'\n  \t\ts = \"/*\"; b = ';';\n  \ta = b;\n  }\n\n  {\n  \tswitch (a)\n  \t{\n  \t\tcase a:\n  \t\t\tswitch (t)\n  \t\t\t{\n  \t\t\t\tcase 1:\n  \t\t\t\t\tcmd;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase 2:\n  \t\t\t\t\tcmd;\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tcmd;\n  \t\t\tbreak;\n  \t\tcase b:\n  \t\t\t{\n  \t\t\t\tint i;\n  \t\t\t\tcmd;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase c: {\n  \t\t\t\t\tint i;\n  \t\t\t\t\tcmd;\n  \t\t\t\t}\n  \t\tcase d: if (cond &&\n  \t\t\t\t\t\ttest) {\t\t/* this line doesn't work right */\n  \t\t\t\t\tint i;\n  \t\t\t\t\tcmd;\n  \t\t\t\t}\n  \t\t\t\tbreak;\n  \t}\n  }\n\n  {\n  \tif (!(vim_strchr(p_cpo, CPO_BUFOPTGLOB) != NULL && entering) &&\n  \t\t\t(bp_to->b_p_initialized ||\n  \t\t\t (!entering && vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n  \t\treturn;\n  label :\n  \tasdf = asdf ?\n  \t\tasdf : asdf;\n  \tasdf = asdf ?\n  \t\tasdf: asdf;\n  }\n\n  /* Special Comments\t: This function has the added complexity (compared  */\n  /*\t\t\t\t\t: to addtolist) of having to check for a detail     */\n  /*\t\t\t\t\t: texture and add that to the list first.\t \t    */\n\n  char *(array[100]) = {\n  \t\"testje\",\n  \t\"foo\",\n  \t\"bar\",\n  }\n\n  enum soppie\n  {\n  yes = 0,\n  no,\n  maybe\n  };\n\n  typedef enum soppie\n  {\n  yes = 0,\n  no,\n  maybe\n  };\n\n  static enum\n  {\n  yes = 0,\n  no,\n  maybe\n  } soppie;\n\n  public static enum\n  {\n  yes = 0,\n  no,\n  maybe\n  } soppie;\n\n  static private enum\n  {\n  yes = 0,\n  no,\n  maybe\n  } soppie;\n\n  {\n  \tint a,\n  \t\tb;\n  }\n\n  {\n  \tstruct Type\n  \t{\n  \t\tint i;\n  \t\tchar *str;\n  \t} var[] =\n  \t{\n  \t\t0, \"zero\",\n  \t\t1, \"one\",\n  \t\t2, \"two\",\n  \t\t3, \"three\"\n  \t};\n\n  \tfloat matrix[3][3] =\n  \t{\n  \t\t{\n  \t\t\t0,\n  \t\t\t1,\n  \t\t\t2\n  \t\t},\n  \t\t{\n  \t\t\t3,\n  \t\t\t4,\n  \t\t\t5\n  \t\t},\n  \t\t{\n  \t\t\t6,\n  \t\t\t7,\n  \t\t\t8\n  \t\t}\n  \t};\n  }\n\n  {\n  \t/* blah ( blah */\n  \t/* where does this go? */\n\n  \t/* blah ( blah */\n  \tcmd;\n\n  \tfunc(arg1,\n  \t\t\t/* comment */\n  \t\t\targ2);\n  \ta;\n  \t{\n  \t\tb;\n  \t\t{\n  \t\t\tc; /* Hey, NOW it indents?! */\n  \t\t}\n  \t}\n\n  \t{\n  \t\tfunc(arg1,\n  \t\t\t\targ2,\n  \t\t\t\targ3);\n  \t\t/* Hey, what am I doing here?  Is this coz of the \",\"? */\n  \t}\n  }\n\n  main ()\n  {\n  \tif (cond)\n  \t{\n  \t\ta = b;\n  \t}\n  \tif (cond) {\n  \t\ta = c;\n  \t}\n  \tif (cond)\n  \t\ta = d;\n  \treturn;\n  }\n\n  {\n  \tcase 2: if (asdf &&\n  \t\t\t\t\tasdfasdf)\n  \t\t\t\taasdf;\n  \t\t\ta = 9;\n  \tcase 3: if (asdf)\n  \t\t\t\taasdf;\n  \t\t\ta = 9;\n  \tcase 4:    x = 1;\n  \t\t\t   y = 2;\n\n  label:\tif (asdf)\n  \t\t\there;\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf)\n  \t\t{\n  \t\t}\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf) {\n  \t\t\tthere;\n  \t\t}\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf)\n  \t\t\tthere;\n  }\n\n  {\n  \t/*\n  \t   hello with \":set comments= cino=c5\"\n  \t */\n\n  \t/*\n  \t   hello with \":set comments= cino=\"\n  \t */\n  }\n\n\n  {\n  \tif (a < b) {\n  \t\ta = a + 1;\n  \t} else\n  \t\ta = a + 2;\n\n  \tif (a)\n  \t\tdo {\n  \t\t\ttesting;\n  \t\t} while (asdfasdf);\n  \ta = b + 1;\n  \tasdfasdf\n  }\n\n  {\n  for ( int i = 0;\n  \ti < 10; i++ )\n  {\n  }\n  \ti = 0;\n  }\n\n  class bob\n  {\n  \tint foo() {return 1;}\n  \t\tint bar;\n  }\n\n  main()\n  {\n  while(1)\n  if (foo)\n  {\n  bar;\n  }\n  else {\n  asdf;\n  }\n  misplacedline;\n  }\n\n  {\n  \tif (clipboard.state == SELECT_DONE\n  \t&& ((row == clipboard.start.lnum\n  \t&& col >= clipboard.start.col)\n  \t|| row > clipboard.start.lnum))\n  }\n\n  {\n  if (1) {i += 4;}\n  where_am_i;\n  return 0;\n  }\n\n  {\n  {\n  } // sdf(asdf\n  if (asdf)\n  asd;\n  }\n\n  {\n  label1:\n  label2:\n  }\n\n  {\n  int fooRet = foo(pBar1, false /*fKB*/,\n  \ttrue /*fPTB*/, 3 /*nT*/, false /*fDF*/);\n  f() {\n  for ( i = 0;\n  \ti < m;\n  \t/* c */ i++ ) {\n  a = b;\n  }\n  }\n  }\n\n  {\n  \tf1(/*comment*/);\n  \tf2();\n  }\n\n  {\n  do {\n  if (foo) {\n  } else\n  ;\n  } while (foo);\n  foo();\t// was wrong\n  }\n\n  int x;\t    // no extra indent because of the ;\n  void func()\n  {\n  }\n\n  char *tab[] = {\"aaa\",\n  \t\"};\", /* }; */ NULL}\n  \tint indented;\n  {}\n\n  char *a[] = {\"aaa\", \"bbb\",\n  \t\"ccc\", NULL};\n  // here\n\n  char *tab[] = {\"aaa\",\n  \t\"xx\", /* xx */};    /* asdf */\n  int not_indented;\n\n  {\n  \tdo {\n  \t\tswitch (bla)\n  \t\t{\n  \t\t\tcase 1: if (foo)\n  \t\t\t\t\t\tbar;\n  \t\t}\n  \t} while (boo);\n  \t\t\t\t\twrong;\n  }\n\n  int\tfoo,\n  \tbar;\n  int foo;\n\n  #if defined(foo) \\\n  \t&& defined(bar)\n  char * xx = \"asdf\\\n  \tfoo\\\n  \tbor\";\n  int x;\n\n  char    *foo = \"asdf\\\n  \tasdf\\\n  \tasdf\",\n  \t*bar;\n\n  void f()\n  {\n  #if defined(foo) \\\n  \t&& defined(bar)\n  char    *foo = \"asdf\\\n  \tasdf\\\n  \tasdf\",\n  \t*bar;\n  \t{\n  \tint i;\n  char    *foo = \"asdf\\\n  \tasdf\\\n  \tasdf\",\n  \t*bar;\n  \t}\n  #endif\n  }\n  #endif\n\n  int y;\t\t// comment\n  \t\t// comment\n\n  \t// comment\n\n  {\n  \tConstructor(int a,\n  \t\t\tint b )  : BaseClass(a)\n  \t{\n  \t}\n  }\n\n  void foo()\n  {\n  \tchar one,\n  \ttwo;\n  \tstruct bla piet,\n  \tjan;\n  \tenum foo kees,\n  \tjannie;\n  \tstatic unsigned sdf,\n  \tkrap;\n  \tunsigned int piet,\n  \tjan;\n  \tint\n  \tkees,\n  \tjan;\n  }\n\n  {\n  \tt(int f,\n  \t\t\tint d);\t\t// )\n  \td();\n  }\n\n  Constructor::Constructor(int a,\n                           int b \n                          )  : \n     BaseClass(a,\n               b,\n               c),\n     mMember(b),\n  {\n  }\n\n  Constructor::Constructor(int a,\n                           int b )  : \n     BaseClass(a)\n  {\n  }\n\n  Constructor::Constructor(int a,\n                           int b ) /*x*/ : /*x*/ BaseClass(a),\n                                                 member(b)\n  {\n  }\n\n  A::A(int a, int b)\n  : aa(a),\n  bb(b),\n  cc(c)\n  {\n  }\n\n  class CAbc :\n     public BaseClass1,\n     protected BaseClass2\n  {\n     int Test() { return FALSE; }\n     int Test1() { return TRUE; }\n\n     CAbc(int a, int b )  : \n        BaseClass(a)\n     { \n        switch(xxx)\n        {\n           case abc:\n              asdf();\n              break;\n\n           case 999:\n              baer();\n              break;\n        }\n     }\n\n  public: // <-- this was incorrectly indented before!!\n     void testfall();\n  protected:\n     void testfall();\n  };\n\n  class CAbc : public BaseClass1,\n               protected BaseClass2\n  {\n  };\n\n  static struct\n  {\n      int a;\n      int b;\n  } variable[COUNT] =\n  {\n      {\n          123,\n          456\n      },\n  \t{\n          123,\n          456\n      }\n  };\n\n  static struct\n  {\n      int a;\n      int b;\n  } variable[COUNT] =\n  {\n      { 123, 456 },\n  \t{ 123, 456 }\n  };\n\n  void asdf()\t\t/* ind_maxparen may cause trouble here */\n  {\n  \tif ((0\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1)) break;\n  }\n\n  foo()\n  {\n  \ta = cond ? foo() : asdf\n  \t\t\t\t\t   + asdf;\n\n  \ta = cond ?\n  \t\tfoo() : asdf\n  \t\t\t\t+ asdf;\n  }\n\n  int  main(void)\n  {\n  \tif (a)\n  \t\tif (b)\n  \t\t\t2;\n  \t\telse 3;\n  \tnext_line_of_code();\n  }\n\n  barry()\n  {\n  \tFoo::Foo (int one,\n  \t\t\tint two)\n  \t\t: something(4)\n  \t{}\n  }\n\n  barry()\n  {\n  \tFoo::Foo (int one, int two)\n  \t\t: something(4)\n  \t{}\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b \n  \t\t)  : \n  \tBaseClass(a,\n  \t\t\tb,\n  \t\t\tc),\n  \tmMember(b)\n  {\n  }\n         int main ()\n         {\n  \t if (lala)\n  \t   do\n  \t     ++(*lolo);\n  \t   while (lili\n  \t\t  && lele);\n  \t   lulu;\n         }\n\n  int main ()\n  {\n  switch (c)\n  {\n  case 'c': if (cond)\n  {\n  }\n  }\n  }\n\n  main()\n  {\n  \t(void) MyFancyFuasdfadsfnction(\n  \t\t\targument);\n  }\n\n  main()\n  {\n  \tchar\tfoo[] = \"/*\";\n  \t/* as\n  \tdf */\n  \t\thello\n  }\n\n  /* valid namespaces with normal indent */\n  namespace\n  {\n  {\n    111111111111;\n  }\n  }\n  namespace /* test */\n  {\n    11111111111111111;\n  }\n  namespace // test\n  {\n    111111111111111111;\n  }\n  namespace\n  {\n    111111111111111111;\n  }\n  namespace test\n  {\n    111111111111111111;\n  }\n  namespace{\n    111111111111111111;\n  }\n  namespace test{\n    111111111111111111;\n  }\n  namespace {\n    111111111111111111;\n  }\n  namespace test {\n    111111111111111111;\n  namespace test2 {\n    22222222222222222;\n  }\n  }\n\n  /* invalid namespaces use block indent */\n  namespace test test2 {\n    111111111111111111111;\n  }\n  namespace11111111111 {\n    111111111111;\n  }\n  namespace() {\n    1111111111111;\n  }\n  namespace()\n  {\n    111111111111111111;\n  }\n  namespace test test2\n  {\n    1111111111111111111;\n  }\n  namespace111111111\n  {\n    111111111111111111;\n  }\n\n  void getstring() {\n  /* Raw strings */\n  const char* s = R\"(\n    test {\n      # comment\n      field: 123\n    }\n   )\";\n       }\n\n  void getstring() {\n  const char* s = R\"foo(\n    test {\n      # comment\n      field: 123\n    }\n      )foo\";\n       }\n\n  {\n  int a[4] = {\n  [0] = 0,\n  [1] = 1,\n  [2] = 2,\n  [3] = 3,\n  };\n  }\n\n  {\n  a = b[2]\n  + 3;\n  }\n\n  {\n  if (1)\n  /* aaaaa\n  * bbbbb\n  */\n  a = 1;\n  }\n\n  void func()\n  {\n  switch (foo)\n  {\n  case (bar):\n  if (baz())\n  quux();\n  break;\n  case (shmoo):\n  if (!bar)\n  {\n  }\n  case (foo1):\n  switch (bar)\n  {\n  case baz:\n  baz_f();\n  break;\n  }\n  break;\n  default:\n  baz();\n  baz();\n  break;\n  }\n  }\n\n  /* end of AUTO */\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('start of AUTO')\n  exe \"normal =/end of AUTO\\<CR>\"\n\n  let expected =<< trim [CODE]\n  /* start of AUTO matically checked vim: set ts=4 : */\n  {\n  \tif (test)\n  \t\tcmd1;\n  \tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t\tcmd1;\n  \telse\n  \t\tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\tcmd2;\n  \t}\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\telse\n  \t}\n  }\n\n  {\n  \twhile (this)\n  \t\tif (test)\n  \t\t\tcmd1;\n  \tcmd2;\n  }\n\n  {\n  \twhile (this)\n  \t\tif (test)\n  \t\t\tcmd1;\n  \t\telse\n  \t\t\tcmd2;\n  }\n\n  {\n  \tif (test)\n  \t{\n  \t\tcmd;\n  \t}\n\n  \tif (test)\n  \t\tcmd;\n  }\n\n  {\n  \tif (test) {\n  \t\tcmd;\n  \t}\n\n  \tif (test) cmd;\n  }\n\n  {\n  \tcmd1;\n  \tfor (blah)\n  \t\twhile (this)\n  \t\t\tif (test)\n  \t\t\t\tcmd2;\n  \tcmd3;\n  }\n\n  {\n  \tcmd1;\n  \tfor (blah)\n  \t\twhile (this)\n  \t\t\tif (test)\n  \t\t\t\tcmd2;\n  \tcmd3;\n\n  \tif (test)\n  \t{\n  \t\tcmd1;\n  \t\tcmd2;\n  \t\tcmd3;\n  \t}\n  }\n\n\n  /* Test for 'cindent' do/while mixed with if/else: */\n\n  {\n  \tdo\n  \t\tif (asdf)\n  \t\t\tasdfasd;\n  \twhile (cond);\n\n  \tdo\n  \t\tif (asdf)\n  \t\t\twhile (asdf)\n  \t\t\t\tasdf;\n  \twhile (asdf);\n  }\n\n  /* Test for 'cindent' with two ) on a continuation line */\n  {\n  \tif (asdfasdf;asldkfj asdlkfj as;ldkfj sal;d\n  \t\t\taal;sdkjf  ( ;asldfkja;sldfk\n  \t\t\t\tal;sdjfka ;slkdf ) sa;ldkjfsa dlk;)\n  \t\tline up here;\n  }\n\n\n  /* C++ tests: */\n\n  // foo()\t\tthese three lines should remain in column 0\n  // {\n  // }\n\n  /* Test for continuation and unterminated lines: */\n  {\n  \ti = 99 + 14325 +\n  \t\t21345 +\n  \t\t21345 +\n  \t\t21345 + ( 21345 +\n  \t\t\t\t21345) +\n  \t\t2345 +\n  \t\t1234;\n  \tc = 1;\n  }\n\n  /*\n     testje for indent with empty line\n\n     here */\n\n  {\n  \tif (testing &&\n  \t\t\tnot a joke ||\n  \t\t\tline up here)\n  \t\thay;\n  \tif (testing &&\n  \t\t\t(not a joke || testing\n  \t\t\t)line up here)\n  \t\thay;\n  \tif (testing &&\n  \t\t\t(not a joke || testing\n  \t\t\t line up here))\n  \t\thay;\n  }\n\n\n  {\n  \tswitch (c)\n  \t{\n  \t\tcase xx:\n  \t\t\tdo\n  \t\t\t\tif (asdf)\n  \t\t\t\t\tdo\n  \t\t\t\t\t\tasdfasdf;\n  \t\t\t\t\twhile (asdf);\n  \t\t\t\telse\n  \t\t\t\t\tasdfasdf;\n  \t\t\twhile (cond);\n  \t\tcase yy:\n  \t\tcase xx:\n  \t\tcase zz:\n  \t\t\ttesting;\n  \t}\n  }\n\n  {\n  \tif (cond) {\n  \t\tfoo;\n  \t}\n  \telse\n  \t{\n  \t\tbar;\n  \t}\n  }\n\n  {\n  \tif (alskdfj ;alsdkfjal;skdjf (;sadlkfsa ;dlkf j;alksdfj ;alskdjf\n  \t\t\t\talsdkfj (asldk;fj\n  \t\t\t\t\tawith cino=(0 ;lf this one goes to below the paren with ==\n  \t\t\t\t\t\t;laksjfd ;lsakdjf ;alskdf asd)\n  \t\t\t\t\tasdfasdf;)))\n  \t\tasdfasdf;\n  }\n\n  \tint\n  func(a, b)\n  \tint a;\n  \tint c;\n  {\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3)\n  \t   )\n  }\n\n  {\n  \twhile (asd)\n  \t{\n  \t\tif (asdf)\n  \t\t\tif (test)\n  \t\t\t\tif (that)\n  \t\t\t\t{\n  \t\t\t\t\tif (asdf)\n  \t\t\t\t\t\tdo\n  \t\t\t\t\t\t\tcdasd;\n  \t\t\t\t\t\twhile (as\n  \t\t\t\t\t\t\t\tdf);\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t\tif (asdf)\n  \t\t\t\t\t\tasdf;\n  \t\t\t\t\telse\n  \t\t\t\t\t\tasdf;\n  \t\tasdf;\n  \t}\n  }\n\n  {\n  \ts = \"/*\"; b = ';'\n  \t\ts = \"/*\"; b = ';';\n  \ta = b;\n  }\n\n  {\n  \tswitch (a)\n  \t{\n  \t\tcase a:\n  \t\t\tswitch (t)\n  \t\t\t{\n  \t\t\t\tcase 1:\n  \t\t\t\t\tcmd;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase 2:\n  \t\t\t\t\tcmd;\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tcmd;\n  \t\t\tbreak;\n  \t\tcase b:\n  \t\t\t{\n  \t\t\t\tint i;\n  \t\t\t\tcmd;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase c: {\n  \t\t\t\t\tint i;\n  \t\t\t\t\tcmd;\n  \t\t\t\t}\n  \t\tcase d: if (cond &&\n  \t\t\t\t\t\ttest) {\t\t/* this line doesn't work right */\n  \t\t\t\t\tint i;\n  \t\t\t\t\tcmd;\n  \t\t\t\t}\n  \t\t\t\tbreak;\n  \t}\n  }\n\n  {\n  \tif (!(vim_strchr(p_cpo, CPO_BUFOPTGLOB) != NULL && entering) &&\n  \t\t\t(bp_to->b_p_initialized ||\n  \t\t\t (!entering && vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n  \t\treturn;\n  label :\n  \tasdf = asdf ?\n  \t\tasdf : asdf;\n  \tasdf = asdf ?\n  \t\tasdf: asdf;\n  }\n\n  /* Special Comments\t: This function has the added complexity (compared  */\n  /*\t\t\t\t\t: to addtolist) of having to check for a detail     */\n  /*\t\t\t\t\t: texture and add that to the list first.\t \t    */\n\n  char *(array[100]) = {\n  \t\"testje\",\n  \t\"foo\",\n  \t\"bar\",\n  }\n\n  enum soppie\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  };\n\n  typedef enum soppie\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  };\n\n  static enum\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  } soppie;\n\n  public static enum\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  } soppie;\n\n  static private enum\n  {\n  \tyes = 0,\n  \tno,\n  \tmaybe\n  } soppie;\n\n  {\n  \tint a,\n  \t\tb;\n  }\n\n  {\n  \tstruct Type\n  \t{\n  \t\tint i;\n  \t\tchar *str;\n  \t} var[] =\n  \t{\n  \t\t0, \"zero\",\n  \t\t1, \"one\",\n  \t\t2, \"two\",\n  \t\t3, \"three\"\n  \t};\n\n  \tfloat matrix[3][3] =\n  \t{\n  \t\t{\n  \t\t\t0,\n  \t\t\t1,\n  \t\t\t2\n  \t\t},\n  \t\t{\n  \t\t\t3,\n  \t\t\t4,\n  \t\t\t5\n  \t\t},\n  \t\t{\n  \t\t\t6,\n  \t\t\t7,\n  \t\t\t8\n  \t\t}\n  \t};\n  }\n\n  {\n  \t/* blah ( blah */\n  \t/* where does this go? */\n\n  \t/* blah ( blah */\n  \tcmd;\n\n  \tfunc(arg1,\n  \t\t\t/* comment */\n  \t\t\targ2);\n  \ta;\n  \t{\n  \t\tb;\n  \t\t{\n  \t\t\tc; /* Hey, NOW it indents?! */\n  \t\t}\n  \t}\n\n  \t{\n  \t\tfunc(arg1,\n  \t\t\t\targ2,\n  \t\t\t\targ3);\n  \t\t/* Hey, what am I doing here?  Is this coz of the \",\"? */\n  \t}\n  }\n\n  main ()\n  {\n  \tif (cond)\n  \t{\n  \t\ta = b;\n  \t}\n  \tif (cond) {\n  \t\ta = c;\n  \t}\n  \tif (cond)\n  \t\ta = d;\n  \treturn;\n  }\n\n  {\n  \tcase 2: if (asdf &&\n  \t\t\t\t\tasdfasdf)\n  \t\t\t\taasdf;\n  \t\t\ta = 9;\n  \tcase 3: if (asdf)\n  \t\t\t\taasdf;\n  \t\t\ta = 9;\n  \tcase 4:    x = 1;\n  \t\t\t   y = 2;\n\n  label:\tif (asdf)\n  \t\t\there;\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf)\n  \t\t{\n  \t\t}\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf) {\n  \t\t\tthere;\n  \t\t}\n\n  label:  if (asdf &&\n  \t\t\t\tasdfasdf)\n  \t\t\tthere;\n  }\n\n  {\n  \t/*\n  \t   hello with \":set comments= cino=c5\"\n  \t */\n\n  \t/*\n  \t   hello with \":set comments= cino=\"\n  \t */\n  }\n\n\n  {\n  \tif (a < b) {\n  \t\ta = a + 1;\n  \t} else\n  \t\ta = a + 2;\n\n  \tif (a)\n  \t\tdo {\n  \t\t\ttesting;\n  \t\t} while (asdfasdf);\n  \ta = b + 1;\n  \tasdfasdf\n  }\n\n  {\n  \tfor ( int i = 0;\n  \t\t\ti < 10; i++ )\n  \t{\n  \t}\n  \ti = 0;\n  }\n\n  class bob\n  {\n  \tint foo() {return 1;}\n  \tint bar;\n  }\n\n  main()\n  {\n  \twhile(1)\n  \t\tif (foo)\n  \t\t{\n  \t\t\tbar;\n  \t\t}\n  \t\telse {\n  \t\t\tasdf;\n  \t\t}\n  \tmisplacedline;\n  }\n\n  {\n  \tif (clipboard.state == SELECT_DONE\n  \t\t\t&& ((row == clipboard.start.lnum\n  \t\t\t\t\t&& col >= clipboard.start.col)\n  \t\t\t\t|| row > clipboard.start.lnum))\n  }\n\n  {\n  \tif (1) {i += 4;}\n  \twhere_am_i;\n  \treturn 0;\n  }\n\n  {\n  \t{\n  \t} // sdf(asdf\n  \tif (asdf)\n  \t\tasd;\n  }\n\n  {\n  label1:\n  label2:\n  }\n\n  {\n  \tint fooRet = foo(pBar1, false /*fKB*/,\n  \t\t\ttrue /*fPTB*/, 3 /*nT*/, false /*fDF*/);\n  \tf() {\n  \t\tfor ( i = 0;\n  \t\t\t\ti < m;\n  \t\t\t\t/* c */ i++ ) {\n  \t\t\ta = b;\n  \t\t}\n  \t}\n  }\n\n  {\n  \tf1(/*comment*/);\n  \tf2();\n  }\n\n  {\n  \tdo {\n  \t\tif (foo) {\n  \t\t} else\n  \t\t\t;\n  \t} while (foo);\n  \tfoo();\t// was wrong\n  }\n\n  int x;\t    // no extra indent because of the ;\n  void func()\n  {\n  }\n\n  char *tab[] = {\"aaa\",\n  \t\"};\", /* }; */ NULL}\n  \tint indented;\n  {}\n\n  char *a[] = {\"aaa\", \"bbb\",\n  \t\"ccc\", NULL};\n  // here\n\n  char *tab[] = {\"aaa\",\n  \t\"xx\", /* xx */};    /* asdf */\n  int not_indented;\n\n  {\n  \tdo {\n  \t\tswitch (bla)\n  \t\t{\n  \t\t\tcase 1: if (foo)\n  \t\t\t\t\t\tbar;\n  \t\t}\n  \t} while (boo);\n  \twrong;\n  }\n\n  int\tfoo,\n  \tbar;\n  int foo;\n\n  #if defined(foo) \\\n  \t&& defined(bar)\n  char * xx = \"asdf\\\n  \t\t\t foo\\\n  \t\t\t bor\";\n  int x;\n\n  char    *foo = \"asdf\\\n  \t\t\t\tasdf\\\n  \t\t\t\tasdf\",\n  \t\t*bar;\n\n  void f()\n  {\n  #if defined(foo) \\\n  \t&& defined(bar)\n  \tchar    *foo = \"asdf\\\n  \t\t\t\t\tasdf\\\n  \t\t\t\t\tasdf\",\n  \t\t\t*bar;\n  \t{\n  \t\tint i;\n  \t\tchar    *foo = \"asdf\\\n  \t\t\t\t\t\tasdf\\\n  \t\t\t\t\t\tasdf\",\n  \t\t\t\t*bar;\n  \t}\n  #endif\n  }\n  #endif\n\n  int y;\t\t// comment\n  // comment\n\n  // comment\n\n  {\n  \tConstructor(int a,\n  \t\t\tint b )  : BaseClass(a)\n  \t{\n  \t}\n  }\n\n  void foo()\n  {\n  \tchar one,\n  \t\t two;\n  \tstruct bla piet,\n  \t\t\t   jan;\n  \tenum foo kees,\n  \t\t\t jannie;\n  \tstatic unsigned sdf,\n  \t\t\t\t\tkrap;\n  \tunsigned int piet,\n  \t\t\t\t jan;\n  \tint\n  \t\tkees,\n  \t\tjan;\n  }\n\n  {\n  \tt(int f,\n  \t\t\tint d);\t\t// )\n  \td();\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b \n  \t\t)  : \n  \tBaseClass(a,\n  \t\t\tb,\n  \t\t\tc),\n  \tmMember(b),\n  {\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b )  : \n  \tBaseClass(a)\n  {\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b ) /*x*/ : /*x*/ BaseClass(a),\n  \tmember(b)\n  {\n  }\n\n  A::A(int a, int b)\n  \t: aa(a),\n  \tbb(b),\n  \tcc(c)\n  {\n  }\n\n  class CAbc :\n  \tpublic BaseClass1,\n  \tprotected BaseClass2\n  {\n  \tint Test() { return FALSE; }\n  \tint Test1() { return TRUE; }\n\n  \tCAbc(int a, int b )  : \n  \t\tBaseClass(a)\n  \t{ \n  \t\tswitch(xxx)\n  \t\t{\n  \t\t\tcase abc:\n  \t\t\t\tasdf();\n  \t\t\t\tbreak;\n\n  \t\t\tcase 999:\n  \t\t\t\tbaer();\n  \t\t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tpublic: // <-- this was incorrectly indented before!!\n  \tvoid testfall();\n  \tprotected:\n  \tvoid testfall();\n  };\n\n  class CAbc : public BaseClass1,\n  \tprotected BaseClass2\n  {\n  };\n\n  static struct\n  {\n  \tint a;\n  \tint b;\n  } variable[COUNT] =\n  {\n  \t{\n  \t\t123,\n  \t\t456\n  \t},\n  \t{\n  \t\t123,\n  \t\t456\n  \t}\n  };\n\n  static struct\n  {\n  \tint a;\n  \tint b;\n  } variable[COUNT] =\n  {\n  \t{ 123, 456 },\n  \t{ 123, 456 }\n  };\n\n  void asdf()\t\t/* ind_maxparen may cause trouble here */\n  {\n  \tif ((0\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1\n  \t\t\t\t&& 1)) break;\n  }\n\n  foo()\n  {\n  \ta = cond ? foo() : asdf\n  \t\t+ asdf;\n\n  \ta = cond ?\n  \t\tfoo() : asdf\n  \t\t+ asdf;\n  }\n\n  int  main(void)\n  {\n  \tif (a)\n  \t\tif (b)\n  \t\t\t2;\n  \t\telse 3;\n  \tnext_line_of_code();\n  }\n\n  barry()\n  {\n  \tFoo::Foo (int one,\n  \t\t\tint two)\n  \t\t: something(4)\n  \t{}\n  }\n\n  barry()\n  {\n  \tFoo::Foo (int one, int two)\n  \t\t: something(4)\n  \t{}\n  }\n\n  Constructor::Constructor(int a,\n  \t\tint b \n  \t\t)  : \n  \tBaseClass(a,\n  \t\t\tb,\n  \t\t\tc),\n  \tmMember(b)\n  {\n  }\n  int main ()\n  {\n  \tif (lala)\n  \t\tdo\n  \t\t\t++(*lolo);\n  \t\twhile (lili\n  \t\t\t\t&& lele);\n  \tlulu;\n  }\n\n  int main ()\n  {\n  \tswitch (c)\n  \t{\n  \t\tcase 'c': if (cond)\n  \t\t\t\t  {\n  \t\t\t\t  }\n  \t}\n  }\n\n  main()\n  {\n  \t(void) MyFancyFuasdfadsfnction(\n  \t\t\targument);\n  }\n\n  main()\n  {\n  \tchar\tfoo[] = \"/*\";\n  \t/* as\n  \t   df */\n  \thello\n  }\n\n  /* valid namespaces with normal indent */\n  namespace\n  {\n  \t{\n  \t\t111111111111;\n  \t}\n  }\n  namespace /* test */\n  {\n  \t11111111111111111;\n  }\n  namespace // test\n  {\n  \t111111111111111111;\n  }\n  namespace\n  {\n  \t111111111111111111;\n  }\n  namespace test\n  {\n  \t111111111111111111;\n  }\n  namespace{\n  \t111111111111111111;\n  }\n  namespace test{\n  \t111111111111111111;\n  }\n  namespace {\n  \t111111111111111111;\n  }\n  namespace test {\n  \t111111111111111111;\n  \tnamespace test2 {\n  \t\t22222222222222222;\n  \t}\n  }\n\n  /* invalid namespaces use block indent */\n  namespace test test2 {\n  \t111111111111111111111;\n  }\n  namespace11111111111 {\n  \t111111111111;\n  }\n  namespace() {\n  \t1111111111111;\n  }\n  namespace()\n  {\n  \t111111111111111111;\n  }\n  namespace test test2\n  {\n  \t1111111111111111111;\n  }\n  namespace111111111\n  {\n  \t111111111111111111;\n  }\n\n  void getstring() {\n  \t/* Raw strings */\n  \tconst char* s = R\"(\n    test {\n      # comment\n      field: 123\n    }\n   )\";\n  }\n\n  void getstring() {\n  \tconst char* s = R\"foo(\n    test {\n      # comment\n      field: 123\n    }\n      )foo\";\n  }\n\n  {\n  \tint a[4] = {\n  \t\t[0] = 0,\n  \t\t[1] = 1,\n  \t\t[2] = 2,\n  \t\t[3] = 3,\n  \t};\n  }\n\n  {\n  \ta = b[2]\n  \t\t+ 3;\n  }\n\n  {\n  \tif (1)\n  \t\t/* aaaaa\n  \t\t * bbbbb\n  \t\t */\n  \t\ta = 1;\n  }\n\n  void func()\n  {\n  \tswitch (foo)\n  \t{\n  \t\tcase (bar):\n  \t\t\tif (baz())\n  \t\t\t\tquux();\n  \t\t\tbreak;\n  \t\tcase (shmoo):\n  \t\t\tif (!bar)\n  \t\t\t{\n  \t\t\t}\n  \t\tcase (foo1):\n  \t\t\tswitch (bar)\n  \t\t\t{\n  \t\t\t\tcase baz:\n  \t\t\t\t\tbaz_f();\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\tbaz();\n  \t\t\tbaz();\n  \t\t\tbreak;\n  \t}\n  }\n\n  /* end of AUTO */\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_2()\n  new\n  setl cindent ts=4 sw=4\n  setl tw=0 noai fo=croq\n  let &wm = &columns - 20\n\n  let code =<< trim [CODE]\n    {\n  \n    /* this is\n     * a real serious important big\n     * comment\n     */\n    \t/* insert \" about life, the universe, and the rest\" after \"serious\" */\n    }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('serious', 'e')\n  normal a about life, the universe, and the rest\n\n  let expected =<< trim [CODE]\n  {\n\n  /* this is\n   * a real serious\n   * about life, the\n   * universe, and the\n   * rest important big\n   * comment\n   */\n  \t/* insert \" about life, the universe, and the rest\" after \"serious\" */\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  set wm&\n  enew! | close\nendfunc\n\nfunc Test_cindent_3()\n  new\n  setl nocindent ts=4 sw=4\n\n  let code =<< trim [CODE]\n  {\n  \t/*\n  \t * Testing for comments, without 'cin' set\n  \t */\n\n  /*\n  * what happens here?\n  */\n\n  \t/*\n  \t   the end of the comment, try inserting a line below */\n\n  \t\t/* how about\n  \t\t                this one */\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('comments')\n  normal joabout life\n  call search('happens')\n  normal jothere\n  call search('below')\n  normal oline\n  call search('this')\n  normal Ohello\n\n  let expected =<< trim [CODE]\n  {\n  \t/*\n  \t * Testing for comments, without 'cin' set\n  \t */\n  about life\n\n  /*\n  * what happens here?\n  */\n  there\n\n  \t/*\n  \t   the end of the comment, try inserting a line below */\n  line\n\n  \t\t/* how about\n  hello\n  \t\t                this one */\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_4()\n  new\n  setl cindent ts=4 sw=4\n\n  let code =<< trim [CODE]\n  {\n      var = this + that + vec[0] * vec[0]\n  \t\t\t\t      + vec[1] * vec[1]\n  \t\t\t\t\t  + vec2[2] * vec[2];\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('vec2')\n  normal ==\n\n  let expected =<< trim [CODE]\n  {\n      var = this + that + vec[0] * vec[0]\n  \t\t\t\t      + vec[1] * vec[1]\n  \t\t\t\t\t  + vec2[2] * vec[2];\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_5()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=}4\n\n  let code =<< trim [CODE]\n  {\n  \t\tasdf asdflkajds f;\n  \tif (tes & ting) {\n  \t\tasdf asdf asdf ;\n  \t\tasdfa sdf asdf;\n  \t\t}\n  \ttesting1;\n  \tif (tes & ting)\n  \t{\n  \t\tasdf asdf asdf ;\n  \t\tasdfa sdf asdf;\n  \t\t}\n  \ttesting2;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('testing1')\n  exe \"normal k2==/testing2\\<CR>\"\n  normal k2==\n\n  let expected =<< trim [CODE]\n  {\n  \t\tasdf asdflkajds f;\n  \tif (tes & ting) {\n  \t\tasdf asdf asdf ;\n  \t\tasdfa sdf asdf;\n  \t\t}\n  \ttesting1;\n  \tif (tes & ting)\n  \t{\n  \t\tasdf asdf asdf ;\n  \t\tasdfa sdf asdf;\n  \t\t}\n  \ttesting2;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_6()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,)20\n\n  let code =<< trim [CODE]\n  main ( int first_par, /*\n                         * Comment for\n                         * first par\n                         */\n            int second_par /*\n                         * Comment for\n                         * second par\n                         */\n       )\n  {\n  \tfunc( first_par, /*\n                        * Comment for\n                        * first par\n                        */\n      second_par /*\n                        * Comment for\n                        * second par\n                        */\n          );\n\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('main')\n  normal =][\n\n  let expected =<< trim [CODE]\n  main ( int first_par, /*\n  \t\t\t\t\t   * Comment for\n  \t\t\t\t\t   * first par\n  \t\t\t\t\t   */\n  \t   int second_par /*\n  \t\t\t\t\t   * Comment for\n  \t\t\t\t\t   * second par\n  \t\t\t\t\t   */\n  \t )\n  {\n  \tfunc( first_par, /*\n  \t\t\t\t\t  * Comment for\n  \t\t\t\t\t  * first par\n  \t\t\t\t\t  */\n  \t\t  second_par /*\n  \t\t\t\t\t  * Comment for\n  \t\t\t\t\t  * second par\n  \t\t\t\t\t  */\n  \t\t);\n\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_7()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=es,n0s\n\n  let code =<< trim [CODE]\n  main(void)\n  {\n  \t/* Make sure that cino=X0s is not parsed like cino=Xs. */\n  \tif (cond)\n  \t\tfoo();\n  \telse\n  \t{\n  \t\tbar();\n  \t}\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('main')\n  normal =][\n\n  let expected =<< trim [CODE]\n  main(void)\n  {\n  \t/* Make sure that cino=X0s is not parsed like cino=Xs. */\n  \tif (cond)\n  \t\tfoo();\n  \telse\n  \t{\n  \t\tbar();\n  \t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_8()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=\n\n  let code =<< trim [CODE]\n\n  {\n  \tdo\n  \t{\n  \t\tif ()\n  \t\t{\n  \t\t\tif ()\n  \t\t\t\tasdf;\n  \t\t\telse\n  \t\t\t\tasdf;\n  \t\t}\n  \t} while ();\n  \t\t\tcmd;\t\t/* this should go under the } */\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n\n  {\n  \tdo\n  \t{\n  \t\tif ()\n  \t\t{\n  \t\t\tif ()\n  \t\t\t\tasdf;\n  \t\t\telse\n  \t\t\t\tasdf;\n  \t\t}\n  \t} while ();\n  \tcmd;\t\t/* this should go under the } */\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_9()\n  new\n  setl cindent ts=4 sw=4\n\n  let code =<< trim [CODE]\n\n  void f()\n  {\n      if ( k() ) {\n          l();\n\n      } else { /* Start (two words) end */\n          m();\n      }\n\n      n();\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n\n  void f()\n  {\n  \tif ( k() ) {\n  \t\tl();\n\n  \t} else { /* Start (two words) end */\n  \t\tm();\n  \t}\n\n  \tn();\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_10()\n  new\n  setl cindent ts=4 sw=4\n  setl cino={s,e-s\n\n  let code =<< trim [CODE]\n\n  void f()\n  {\n      if ( k() )\n  \t{\n          l();\n      } else { /* Start (two words) end */\n          m();\n      }\n  \t\tn();\t/* should be under the if () */\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n\n  void f()\n  {\n  \tif ( k() )\n  \t\t{\n  \t\tl();\n  \t\t} else { /* Start (two words) end */\n  \t\tm();\n  \t\t}\n  \tn();\t/* should be under the if () */\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_11()\n  new\n  setl cindent ts=4 sw=4\n  setl cino={s,fs\n\n  let code =<< trim [CODE]\n  void bar(void)\n  {\n  \tstatic array[2][2] =\n  \t{\n  \t\t{ 1, 2 },\n  \t\t{ 3, 4 },\n  \t}\n\n  \twhile (a)\n  \t{\n  \t\tfoo(&a);\n  \t}\n\n  \t{\n  \t\tint a;\n  \t\t{\n  \t\t\ta = a + 1;\n  \t\t}\n  \t}\n  \tb = a;\n  \t}\n\n  void func(void)\n  \t{\n  \ta = 1;\n  \t{\n  \t\tb = 2;\n  \t}\n  \tc = 3;\n  \td = 4;\n  \t}\n  /* foo */\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  exe \"normal ]]=/ foo\\<CR>\"\n\n  let expected =<< trim [CODE]\n  void bar(void)\n  \t{\n  \tstatic array[2][2] =\n  \t\t{\n  \t\t\t{ 1, 2 },\n  \t\t\t{ 3, 4 },\n  \t\t}\n\n  \twhile (a)\n  \t\t{\n  \t\tfoo(&a);\n  \t\t}\n\n  \t\t{\n  \t\tint a;\n  \t\t\t{\n  \t\t\ta = a + 1;\n  \t\t\t}\n  \t\t}\n  \tb = a;\n  \t}\n\n  void func(void)\n  \t{\n  \ta = 1;\n  \t\t{\n  \t\tb = 2;\n  \t\t}\n  \tc = 3;\n  \td = 4;\n  \t}\n  /* foo */\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_12()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=\n\n  let code =<< trim [CODE]\n  a()\n  {\n    do {\n      a = a +\n        a;\n    } while ( a );\t\t/* add text under this line */\n      if ( a )\n        a;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('while')\n  normal ohere\n\n  let expected =<< trim [CODE]\n  a()\n  {\n    do {\n      a = a +\n        a;\n    } while ( a );\t\t/* add text under this line */\n    here\n      if ( a )\n        a;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_13()\n  new\n  setl cindent ts=4 sw=4\n  setl cino= com=\n\n  let code =<< trim [CODE]\n  a()\n  {\n  label1:\n              /* hmm */\n              // comment\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('comment')\n  exe \"normal olabel2: b();\\rlabel3 /* post */:\\r/* pre */ label4:\\r\" .\n        \\ \"f(/*com*/);\\rif (/*com*/)\\rcmd();\"\n\n  let expected =<< trim [CODE]\n  a()\n  {\n  label1:\n              /* hmm */\n              // comment\n  label2: b();\n  label3 /* post */:\n  /* pre */ label4:\n  \t\tf(/*com*/);\n  \t\tif (/*com*/)\n  \t\t\tcmd();\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_14()\n  new\n  setl cindent ts=4 sw=4\n  setl comments& comments^=s:/*,m:**,ex:*/\n\n  let code =<< trim [CODE]\n  /*\n    * A simple comment\n     */\n\n  /*\n    ** A different comment\n     */\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('simple')\n  normal =5j\n\n  let expected =<< trim [CODE]\n  /*\n   * A simple comment\n   */\n\n  /*\n  ** A different comment\n  */\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_15()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=c0\n  setl comments& comments-=s1:/* comments^=s0:/*\n\n  let code =<< trim [CODE]\n  void f()\n  {\n\n  \t/*********\n    A comment.\n  *********/\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n\n  \t/*********\n  \t  A comment.\n  \t*********/\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_16()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=c0,C1\n  setl comments& comments-=s1:/* comments^=s0:/*\n\n  let code =<< trim [CODE]\n  void f()\n  {\n\n  \t/*********\n    A comment.\n  *********/\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n\n  \t/*********\n  \tA comment.\n  \t*********/\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_17()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t(\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t\t(\n  \t\t c2 ||\n  \t\t c3\n  \t\t) && c4;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_18()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(s\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t(\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t\t(\n  \t\t c2 ||\n  \t\t c3\n  \t\t) && c4;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_19()\n  new\n  setl cindent ts=4 sw=4\n  set cino=(s,U1\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t(\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 &&\n  \t\t(\n  \t\t\tc2 ||\n  \t\t\tc3\n  \t\t) && c4;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_20()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tif (   c1\n  \t&& (   c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tif (   c1\n  \t\t   && (   c2\n  \t\t\t\t  || c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_21()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,w1\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tif (   c1\n  \t&& (   c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tif (   c1\n  \t\t&& (   c2\n  \t\t\t|| c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_22()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(s\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 && (\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  \tif (\n  \tc1 && c2\n  \t)\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 && (\n  \t\tc2 ||\n  \t\tc3\n  \t\t) && c4;\n  \tif (\n  \t\tc1 && c2\n  \t   )\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_23()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(s,m1\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 && (\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  \tif (\n  \tc1 && c2\n  \t)\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tc = c1 && (\n  \t\tc2 ||\n  \t\tc3\n  \t) && c4;\n  \tif (\n  \t\tc1 && c2\n  \t)\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_24()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=b1\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tswitch (x)\n  \t{\n  \t\tcase 1:\n  \t\t\ta = b;\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\ta = 0;\n  \t\t\tbreak;\n  \t}\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tswitch (x)\n  \t{\n  \t\tcase 1:\n  \t\t\ta = b;\n  \t\tbreak;\n  \t\tdefault:\n  \t\t\ta = 0;\n  \t\tbreak;\n  \t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_25()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,W5\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tinvokeme(\n  \targu,\n  \tment);\n  \tinvokeme(\n  \targu,\n  \tment\n  \t);\n  \tinvokeme(argu,\n  \tment\n  \t);\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tinvokeme(\n  \t\t argu,\n  \t\t ment);\n  \tinvokeme(\n  \t\t argu,\n  \t\t ment\n  \t\t );\n  \tinvokeme(argu,\n  \t\t\t ment\n  \t\t\t);\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_26()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=/6\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tstatement;\n  \t\t// comment 1\n  \t// comment 2\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tstatement;\n  \t\t  // comment 1\n  \t\t  // comment 2\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_27()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=\n\n  let code =<< trim [CODE]\n  void f()\n  {\n  \tstatement;\n  \t   // comment 1\n  \t// comment 2\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  exe \"normal ]]/comment 1/+1\\<CR>==\"\n\n  let expected =<< trim [CODE]\n  void f()\n  {\n  \tstatement;\n  \t   // comment 1\n  \t   // comment 2\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_28()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=g0\n\n  let code =<< trim [CODE]\n  class CAbc\n  {\n     int Test() { return FALSE; }\n\n  public: // comment\n     void testfall();\n  protected:\n     void testfall();\n  };\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  class CAbc\n  {\n  \tint Test() { return FALSE; }\n\n  public: // comment\n  \tvoid testfall();\n  protected:\n  \tvoid testfall();\n  };\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_29()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,gs,hs\n\n  let code =<< trim [CODE]\n  class Foo : public Bar\n  {\n  public:\n  virtual void method1(void) = 0;\n  virtual void method2(int arg1,\n  int arg2,\n  int arg3) = 0;\n  };\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  class Foo : public Bar\n  {\n  \tpublic:\n  \t\tvirtual void method1(void) = 0;\n  \t\tvirtual void method2(int arg1,\n  \t\t\t\t\t\t\t int arg2,\n  \t\t\t\t\t\t\t int arg3) = 0;\n  };\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_30()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=+20\n\n  let code =<< [CODE]\n\tvoid\nfoo()\n{\n\tif (a)\n\t{\n\t} else\n\t\tasdf;\n}\n[CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< [CODE]\n\tvoid\nfoo()\n{\n\tif (a)\n\t{\n\t} else\n\t\tasdf;\n}\n\n[CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_31()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,W2s\n\n  let code =<< trim [CODE]\n\n  {\n     averylongfunctionnamelongfunctionnameaverylongfunctionname()->asd(\n           asdasdf,\n           func(asdf,\n                asdfadsf),\n           asdfasdf\n           );\n\n     /* those are ugly, but consequent */\n\n     func()->asd(asdasdf,\n                 averylongfunctionname(\n                       abc,\n                       dec)->averylongfunctionname(\n                             asdfadsf,\n                             asdfasdf,\n                             asdfasdf,\n                             ),\n                 func(asdfadf,\n                      asdfasdf\n                     ),\n                 asdasdf\n                );\n\n     averylongfunctionnameaverylongfunctionnameavery()->asd(fasdf(\n                 abc,\n                 dec)->asdfasdfasdf(\n                       asdfadsf,\n                       asdfasdf,\n                       asdfasdf,\n                       ),\n           func(asdfadf,\n                asdfasdf),\n           asdasdf\n           );\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n\n  {\n  \taverylongfunctionnamelongfunctionnameaverylongfunctionname()->asd(\n  \t\t\tasdasdf,\n  \t\t\tfunc(asdf,\n  \t\t\t\t asdfadsf),\n  \t\t\tasdfasdf\n  \t\t\t);\n\n  \t/* those are ugly, but consequent */\n\n  \tfunc()->asd(asdasdf,\n  \t\t\t\taverylongfunctionname(\n  \t\t\t\t\t\tabc,\n  \t\t\t\t\t\tdec)->averylongfunctionname(\n  \t\t\t\t\t\t\t\tasdfadsf,\n  \t\t\t\t\t\t\t\tasdfasdf,\n  \t\t\t\t\t\t\t\tasdfasdf,\n  \t\t\t\t\t\t\t\t),\n  \t\t\t\tfunc(asdfadf,\n  \t\t\t\t\t asdfasdf\n  \t\t\t\t\t),\n  \t\t\t\tasdasdf\n  \t\t\t   );\n\n  \taverylongfunctionnameaverylongfunctionnameavery()->asd(fasdf(\n  \t\t\t\t\tabc,\n  \t\t\t\t\tdec)->asdfasdfasdf(\n  \t\t\t\t\t\t\tasdfadsf,\n  \t\t\t\t\t\t\tasdfasdf,\n  \t\t\t\t\t\t\tasdfasdf,\n  \t\t\t\t\t\t\t),\n  \t\t\tfunc(asdfadf,\n  \t\t\t\t asdfasdf),\n  \t\t\tasdasdf\n  \t\t\t);\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_32()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=M1\n\n  let code =<< trim [CODE]\n  int main ()\n  {\n  \tif (cond1 &&\n  \t\t\tcond2\n  \t\t\t)\n  \t\tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  int main ()\n  {\n  \tif (cond1 &&\n  \t\t\tcond2\n  \t\t\t)\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_33()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0,ts\n\n  let code =<< trim [CODE]\n  void func(int a\n  #if defined(FOO)\n  \t\t  , int b\n  \t\t  , int c\n  #endif\n  \t\t )\n  {\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal 2j=][\n\n  let expected =<< trim [CODE]\n  void func(int a\n  #if defined(FOO)\n  \t\t  , int b\n  \t\t  , int c\n  #endif\n  \t\t )\n  {\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_34()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=(0\n\n  let code =<< trim [CODE]\n\n  void\n  func(int a\n  #if defined(FOO)\n  \t\t  , int b\n  \t\t  , int c\n  #endif\n  \t\t )\n  {\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal =][\n\n  let expected =<< trim [CODE]\n  \n  \tvoid\n  func(int a\n  #if defined(FOO)\n  \t , int b\n  \t , int c\n  #endif\n  \t)\n  {\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_35()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif(x==y)\n  \t\tif(y==z)\n  \t\t\tfoo=1;\n  \t\telse { bar=1;\n  \t\t\tbaz=2;\n  \t\t}\n  \tprintf(\"Foo!\\n\");\n  }\n\n  void func1(void)\n  {\n  \tchar* tab[] = {\"foo\", \"bar\",\n  \t\t\"baz\", \"quux\",\n  \t\t\t\"this line used\", \"to be indented incorrectly\"};\n  \tfoo();\n  }\n\n  void func2(void)\n  {\n  \tint tab[] =\n  \t{1, 2,\n  \t\t3, 4,\n  \t\t5, 6};\n\n  \t\tprintf(\"This line used to be indented incorrectly.\\n\");\n  }\n\n  int foo[]\n  #ifdef BAR\n\n  = { 1, 2, 3,\n  \t4, 5, 6 }\n\n  #endif\n  ;\n  \tint baz;\n\n  void func3(void)\n  {\n  \tint tab[] = {\n  \t1, 2,\n  \t3, 4,\n  \t5, 6};\n\n  printf(\"Don't you dare indent this line incorrectly!\\n\");\n  }\n\n  void\n  func4(a, b,\n  \t\tc)\n  int a;\n  int b;\n  int c;\n  {\n  }\n\n  void\n  func5(\n  \t\tint a,\n  \t\tint b)\n  {\n  }\n\n  void\n  func6(\n  \t\tint a)\n  {\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=7][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif(x==y)\n  \t\tif(y==z)\n  \t\t\tfoo=1;\n  \t\telse { bar=1;\n  \t\t\tbaz=2;\n  \t\t}\n  \tprintf(\"Foo!\\n\");\n  }\n\n  void func1(void)\n  {\n  \tchar* tab[] = {\"foo\", \"bar\",\n  \t\t\"baz\", \"quux\",\n  \t\t\"this line used\", \"to be indented incorrectly\"};\n  \tfoo();\n  }\n\n  void func2(void)\n  {\n  \tint tab[] =\n  \t{1, 2,\n  \t\t3, 4,\n  \t\t5, 6};\n\n  \tprintf(\"This line used to be indented incorrectly.\\n\");\n  }\n\n  int foo[]\n  #ifdef BAR\n\n  = { 1, 2, 3,\n  \t4, 5, 6 }\n\n  #endif\n  \t;\n  int baz;\n\n  void func3(void)\n  {\n  \tint tab[] = {\n  \t\t1, 2,\n  \t\t3, 4,\n  \t\t5, 6};\n\n  \tprintf(\"Don't you dare indent this line incorrectly!\\n\");\n  }\n\n  \tvoid\n  func4(a, b,\n  \t\tc)\n  \tint a;\n  \tint b;\n  \tint c;\n  {\n  }\n\n  \tvoid\n  func5(\n  \t\tint a,\n  \t\tint b)\n  {\n  }\n\n  \tvoid\n  func6(\n  \t\tint a)\n  {\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_36()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n  setl cino+=l1\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tint tab[] =\n  \t{\n  \t\t1, 2, 3,\n  \t\t4, 5, 6};\n\n  \tprintf(\"Indent this line correctly!\\n\");\n\n  \tswitch (foo)\n  \t{\n  \t\tcase bar:\n  \t\t\tprintf(\"bar\");\n  \t\t\tbreak;\n  \t\tcase baz: {\n  \t\t\tprintf(\"baz\");\n  \t\t\tbreak;\n  \t\t}\n  \t\tcase quux:\n  printf(\"But don't break the indentation of this instruction\\n\");\n  break;\n  \t}\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tint tab[] =\n  \t{\n  \t\t1, 2, 3,\n  \t\t4, 5, 6};\n\n  \tprintf(\"Indent this line correctly!\\n\");\n\n  \tswitch (foo)\n  \t{\n  \t\tcase bar:\n  \t\t\tprintf(\"bar\");\n  \t\t\tbreak;\n  \t\tcase baz: {\n  \t\t\tprintf(\"baz\");\n  \t\t\tbreak;\n  \t\t}\n  \t\tcase quux:\n  \t\t\tprintf(\"But don't break the indentation of this instruction\\n\");\n  \t\t\tbreak;\n  \t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_37()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tcout << \"a\"\n  \t<< \"b\"\n  \t<< \") :\"\n  \t<< \"c\";\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tcout << \"a\"\n  \t\t<< \"b\"\n  \t\t<< \") :\"\n  \t\t<< \"c\";\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_38()\n  new\n  setl cindent ts=4 sw=4\n  setl com=s1:/*,m:*,ex:*/\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \t/*\n  \t * This is a comment.\n  \t */\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]3jofoo();\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \t/*\n  \t * This is a comment.\n  \t */\n  \tfoo();\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_39()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tfor (int i = 0; i < 10; ++i)\n  \t\tif (i & 1) {\n  \t\t\tfoo(1);\n  \t\t} else\n  \t\t\tfoo(0);\n  baz();\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tfor (int i = 0; i < 10; ++i)\n  \t\tif (i & 1) {\n  \t\t\tfoo(1);\n  \t\t} else\n  \t\t\tfoo(0);\n  \tbaz();\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_40()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(0\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n\n  \tif (   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  \tfunc( c1\n  \t&& (     c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t\t && argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n\n  \tif (   c1\n  \t\t\t&& (      c2\n  \t\t\t\t\t  || c3))\n  \t\tfoo;\n  \tfunc( c1\n  \t\t  && (     c2\n  \t\t\t\t   || c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_41()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(s\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n\n  \tif (   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  \tfunc(   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n\n  \tif (   c1\n  \t\t\t&& (      c2\n  \t\t\t\t|| c3))\n  \t\tfoo;\n  \tfunc(   c1\n  \t\t&& (      c2\n  \t\t\t|| c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_42()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(s,U1\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t&& (c22345\n  \t|| c3))\n  \tprintf(\"foo\\n\");\n\n  \tc = c1 &&\n  \t(\n  \tc2 ||\n  \tc3\n  \t) && c4;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t\t\t&& (c22345\n  \t\t\t\t|| c3))\n  \t\tprintf(\"foo\\n\");\n\n  \tc = c1 &&\n  \t\t(\n  \t\t\tc2 ||\n  \t\t\tc3\n  \t\t) && c4;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_43()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(0,W4\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t&& (c22345\n  \t|| c3))\n  \tprintf(\"foo\\n\");\n\n  \tif (   c1\n  \t&& (   c2\n  \t|| c3))\n  \tfoo;\n\n  \ta_long_line(\n  \targument,\n  \targument);\n  \ta_short_line(argument,\n  \targument);\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t\t && argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t\t\t&& (c22345\n  \t\t\t\t|| c3))\n  \t\tprintf(\"foo\\n\");\n\n  \tif (   c1\n  \t\t\t&& (   c2\n  \t\t\t\t   || c3))\n  \t\tfoo;\n\n  \ta_long_line(\n  \t\targument,\n  \t\targument);\n  \ta_short_line(argument,\n  \t\t\t\t argument);\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_44()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,u2\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t&& (c22345\n  \t|| c3))\n  \tprintf(\"foo\\n\");\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t  c3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t\t\t&& (c22345\n  \t\t\t  || c3))\n  \t\tprintf(\"foo\\n\");\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_45()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2s,(0,w1\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t&& condition2)\n  \taction();\n  \tfunction(argument1\n  \t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \tc3))\n  \tfoo;\n  \tif (c1 &&\n  \t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t&& (c22345\n  \t|| c3))\n  \tprintf(\"foo\\n\");\n\n  \tif (   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  \tfunc(   c1\n  \t&& (      c2\n  \t|| c3))\n  \tfoo;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t\t\t&& condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t\t && argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t\t\tc3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t\t\t(c2 || c3))\n  \t{\n  \t}\n  \tif (c123456789\n  \t\t\t&& (c22345\n  \t\t\t\t|| c3))\n  \t\tprintf(\"foo\\n\");\n\n  \tif (   c1\n  \t\t\t&& (      c2\n  \t\t\t\t|| c3))\n  \t\tfoo;\n  \tfunc(   c1\n  \t\t && (      c2\n  \t\t\t || c3))\n  \t\tfoo;\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_46()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=k2,(s\n\n  let code =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t  && condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t  c3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t  (c2 || c3))\n  \t{\n  \t}\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal ]]=][\n\n  let expected =<< trim [CODE]\n  void func(void)\n  {\n  \tif (condition1\n  \t  && condition2)\n  \t\taction();\n  \tfunction(argument1\n  \t\t&& argument2);\n\n  \tif (c1 && (c2 ||\n  \t\t  c3))\n  \t\tfoo;\n  \tif (c1 &&\n  \t  (c2 || c3))\n  \t{\n  \t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_47()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=N-s\n\n  let code =<< trim [CODE]\n  NAMESPACESTART\n  /* valid namespaces with normal indent */\n  namespace\n  {\n     {\n  \t111111111111;\n  }\n  }\n  namespace /* test */\n  {\n    11111111111111111;\n  }\n  namespace // test\n  {\n    111111111111111111;\n  }\n  namespace\n  {\n    111111111111111111;\n  }\n  namespace test\n  {\n    111111111111111111;\n  }\n  namespace test::cpp17\n  {\n    111111111111111111;\n  }\n  namespace ::incorrectcpp17\n  {\n    111111111111111111;\n  }\n  namespace test::incorrectcpp17::\n  {\n    111111111111111111;\n  }\n  namespace test:incorrectcpp17\n  {\n    111111111111111111;\n  }\n  namespace test:::incorrectcpp17\n  {\n    111111111111111111;\n  }\n  namespace{\n    111111111111111111;\n  }\n  namespace test{\n    111111111111111111;\n  }\n  namespace {\n    111111111111111111;\n  }\n  namespace test {\n    111111111111111111;\n  namespace test2 {\n    22222222222222222;\n  }\n  }\n\n  /* invalid namespaces use block indent */\n  namespace test test2 {\n    111111111111111111111;\n  }\n  namespace11111111111 {\n    111111111111;\n  }\n  namespace() {\n    1111111111111;\n  }\n  namespace()\n  {\n    111111111111111111;\n  }\n  namespace test test2\n  {\n    1111111111111111111;\n  }\n  namespace111111111\n  {\n    111111111111111111;\n  }\n  NAMESPACEEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^NAMESPACESTART')\n  exe \"normal =/^NAMESPACEEND\\n\"\n\n  let expected =<< trim [CODE]\n  NAMESPACESTART\n  /* valid namespaces with normal indent */\n  namespace\n  {\n  {\n  \t111111111111;\n  }\n  }\n  namespace /* test */\n  {\n  11111111111111111;\n  }\n  namespace // test\n  {\n  111111111111111111;\n  }\n  namespace\n  {\n  111111111111111111;\n  }\n  namespace test\n  {\n  111111111111111111;\n  }\n  namespace test::cpp17\n  {\n  111111111111111111;\n  }\n  namespace ::incorrectcpp17\n  {\n  \t111111111111111111;\n  }\n  namespace test::incorrectcpp17::\n  {\n  \t111111111111111111;\n  }\n  namespace test:incorrectcpp17\n  {\n  \t111111111111111111;\n  }\n  namespace test:::incorrectcpp17\n  {\n  \t111111111111111111;\n  }\n  namespace{\n  111111111111111111;\n  }\n  namespace test{\n  111111111111111111;\n  }\n  namespace {\n  111111111111111111;\n  }\n  namespace test {\n  111111111111111111;\n  namespace test2 {\n  22222222222222222;\n  }\n  }\n\n  /* invalid namespaces use block indent */\n  namespace test test2 {\n  \t111111111111111111111;\n  }\n  namespace11111111111 {\n  \t111111111111;\n  }\n  namespace() {\n  \t1111111111111;\n  }\n  namespace()\n  {\n  \t111111111111111111;\n  }\n  namespace test test2\n  {\n  \t1111111111111111111;\n  }\n  namespace111111111\n  {\n  \t111111111111111111;\n  }\n  NAMESPACEEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_48()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  var bar = {\n  foo: {\n  that: this,\n  some: ok,\n  },\n  \"bar\":{\n  a : 2,\n  b: \"123abc\",\n  x: 4,\n  \"y\": 5\n  }\n  }\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  var bar = {\n  \tfoo: {\n  \t\tthat: this,\n  \t\tsome: ok,\n  \t},\n  \t\"bar\":{\n  \t\ta : 2,\n  \t\tb: \"123abc\",\n  \t\tx: 4,\n  \t\t\"y\": 5\n  \t}\n  }\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_49()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  var foo = [\n  1,\n  2,\n  3\n  ];\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  var foo = [\n  \t1,\n  \t2,\n  \t3\n  ];\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_50()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  function bar() {\n  var foo = [\n  1,\n  2,\n  3\n  ];\n  }\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  function bar() {\n  \tvar foo = [\n  \t\t1,\n  \t\t2,\n  \t\t3\n  \t];\n  }\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_51()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  (function($){\n\n  if (cond &&\n  cond) {\n  stmt;\n  }\n  window.something.left =\n  (width - 50 + offset) + \"px\";\n  var class_name='myclass';\n\n  function private_method() {\n  }\n\n  var public_method={\n  method: function(options,args){\n  private_method();\n  }\n  }\n\n  function init(options) {\n\n  $(this).data(class_name+'_public',$.extend({},{\n  foo: 'bar',\n  bar: 2,\n  foobar: [\n  1,\n  2,\n  3\n  ],\n  callback: function(){\n  return true;\n  }\n  }, options||{}));\n  }\n\n  $.fn[class_name]=function() {\n\n  var _arguments=arguments;\n  return this.each(function(){\n\n  var options=$(this).data(class_name+'_public');\n  if (!options) {\n  init.apply(this,_arguments);\n\n  } else {\n  var method=public_method[_arguments[0]];\n\n  if (typeof(method)!='function') {\n  console.log(class_name+' has no method \"'+_arguments[0]+'\"');\n  return false;\n  }\n  _arguments[0]=options;\n  method.apply(this,_arguments);\n  }\n  });\n  }\n\n  })(jQuery);\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  (function($){\n\n  \tif (cond &&\n  \t\t\tcond) {\n  \t\tstmt;\n  \t}\n  \twindow.something.left =\n  \t\t(width - 50 + offset) + \"px\";\n  \tvar class_name='myclass';\n\n  \tfunction private_method() {\n  \t}\n\n  \tvar public_method={\n  \t\tmethod: function(options,args){\n  \t\t\tprivate_method();\n  \t\t}\n  \t}\n\n  \tfunction init(options) {\n\n  \t\t$(this).data(class_name+'_public',$.extend({},{\n  \t\t\tfoo: 'bar',\n  \t\t\tbar: 2,\n  \t\t\tfoobar: [\n  \t\t\t\t1,\n  \t\t\t\t2,\n  \t\t\t\t3\n  \t\t\t],\n  \t\t\tcallback: function(){\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}, options||{}));\n  \t}\n\n  \t$.fn[class_name]=function() {\n\n  \t\tvar _arguments=arguments;\n  \t\treturn this.each(function(){\n\n  \t\t\tvar options=$(this).data(class_name+'_public');\n  \t\t\tif (!options) {\n  \t\t\t\tinit.apply(this,_arguments);\n\n  \t\t\t} else {\n  \t\t\t\tvar method=public_method[_arguments[0]];\n\n  \t\t\t\tif (typeof(method)!='function') {\n  \t\t\t\t\tconsole.log(class_name+' has no method \"'+_arguments[0]+'\"');\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t\t_arguments[0]=options;\n  \t\t\t\tmethod.apply(this,_arguments);\n  \t\t\t}\n  \t\t});\n  \t}\n\n  })(jQuery);\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_52()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  function init(options) {\n  $(this).data(class_name+'_public',$.extend({},{\n  foo: 'bar',\n  bar: 2,\n  foobar: [\n  1,\n  2,\n  3\n  ],\n  callback: function(){\n  return true;\n  }\n  }, options||{}));\n  }\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  function init(options) {\n  \t$(this).data(class_name+'_public',$.extend({},{\n  \t\tfoo: 'bar',\n  \t\tbar: 2,\n  \t\tfoobar: [\n  \t\t\t1,\n  \t\t\t2,\n  \t\t\t3\n  \t\t],\n  \t\tcallback: function(){\n  \t\t\treturn true;\n  \t\t}\n  \t}, options||{}));\n  }\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_53()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1\n\n  let code =<< trim [CODE]\n  JSSTART\n  (function($){\n  function init(options) {\n  $(this).data(class_name+'_public',$.extend({},{\n  foo: 'bar',\n  bar: 2,\n  foobar: [\n  1,\n  2,\n  3\n  ],\n  callback: function(){\n  return true;\n  }\n  }, options||{}));\n  }\n  })(jQuery);\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  (function($){\n  \tfunction init(options) {\n  \t\t$(this).data(class_name+'_public',$.extend({},{\n  \t\t\tfoo: 'bar',\n  \t\t\tbar: 2,\n  \t\t\tfoobar: [\n  \t\t\t\t1,\n  \t\t\t\t2,\n  \t\t\t\t3\n  \t\t\t],\n  \t\t\tcallback: function(){\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}, options||{}));\n  \t}\n  })(jQuery);\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_54()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=j1,J1,+2\n\n  let code =<< trim [CODE]\n  JSSTART\n  // Results of JavaScript indent\n  // 1\n  (function(){\n  var a = [\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i'\n  ];\n  }())\n\n  // 2\n  (function(){\n  var a = [\n  0 +\n  5 *\n  9 *\n  'a',\n  'b',\n  0 +\n  5 *\n  9 *\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i'\n  ];\n  }())\n\n  // 3\n  (function(){\n  var a = [\n  0 +\n  // comment 1\n  5 *\n  /* comment 2 */\n  9 *\n  'a',\n  'b',\n  0 +\n  5 *\n  9 *\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i'\n  ];\n  }())\n\n  // 4\n  {\n  var a = [\n  0,\n  1\n  ];\n  var b;\n  var c;\n  }\n\n  // 5\n  {\n  var a = [\n  [\n  0\n  ],\n  2,\n  3\n  ];\n  }\n\n  // 6\n  {\n  var a = [\n  [\n  0,\n  1\n  ],\n  2,\n  3\n  ];\n  }\n\n  // 7\n  {\n  var a = [\n  // [\n  0,\n  // 1\n  // ],\n  2,\n  3\n  ];\n  }\n\n  // 8\n  var x = [\n  (function(){\n  var a,\n  b,\n  c,\n  d,\n  e,\n  f,\n  g,\n  h,\n  i;\n  })\n  ];\n\n  // 9\n  var a = [\n  0 +\n  5 *\n  9 *\n  'a',\n  'b',\n  0 +\n  5 *\n  9 *\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i'\n  ];\n\n  // 10\n  var a,\n  b,\n  c,\n  d,\n  e,\n  f,\n  g,\n  h,\n  i;\n  JSEND\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('^JSSTART')\n  exe \"normal =/^JSEND\\n\"\n\n  let expected =<< trim [CODE]\n  JSSTART\n  // Results of JavaScript indent\n  // 1\n  (function(){\n  \tvar a = [\n  \t  'a',\n  \t  'b',\n  \t  'c',\n  \t  'd',\n  \t  'e',\n  \t  'f',\n  \t  'g',\n  \t  'h',\n  \t  'i'\n  \t];\n  }())\n\n  // 2\n  (function(){\n  \tvar a = [\n  \t  0 +\n  \t\t5 *\n  \t\t9 *\n  \t\t'a',\n  \t  'b',\n  \t  0 +\n  \t\t5 *\n  \t\t9 *\n  \t\t'c',\n  \t  'd',\n  \t  'e',\n  \t  'f',\n  \t  'g',\n  \t  'h',\n  \t  'i'\n  \t];\n  }())\n\n  // 3\n  (function(){\n  \tvar a = [\n  \t  0 +\n  \t\t// comment 1\n  \t\t5 *\n  \t\t/* comment 2 */\n  \t\t9 *\n  \t\t'a',\n  \t  'b',\n  \t  0 +\n  \t\t5 *\n  \t\t9 *\n  \t\t'c',\n  \t  'd',\n  \t  'e',\n  \t  'f',\n  \t  'g',\n  \t  'h',\n  \t  'i'\n  \t];\n  }())\n\n  // 4\n  {\n  \tvar a = [\n  \t  0,\n  \t  1\n  \t];\n  \tvar b;\n  \tvar c;\n  }\n\n  // 5\n  {\n  \tvar a = [\n  \t  [\n  \t\t0\n  \t  ],\n  \t  2,\n  \t  3\n  \t];\n  }\n\n  // 6\n  {\n  \tvar a = [\n  \t  [\n  \t\t0,\n  \t\t1\n  \t  ],\n  \t  2,\n  \t  3\n  \t];\n  }\n\n  // 7\n  {\n  \tvar a = [\n  \t  // [\n  \t  0,\n  \t  // 1\n  \t  // ],\n  \t  2,\n  \t  3\n  \t];\n  }\n\n  // 8\n  var x = [\n    (function(){\n  \t  var a,\n  \t  b,\n  \t  c,\n  \t  d,\n  \t  e,\n  \t  f,\n  \t  g,\n  \t  h,\n  \t  i;\n    })\n  ];\n\n  // 9\n  var a = [\n    0 +\n    5 *\n    9 *\n    'a',\n    'b',\n    0 +\n    5 *\n    9 *\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i'\n  ];\n\n  // 10\n  var a,\n  \tb,\n  \tc,\n  \td,\n  \te,\n  \tf,\n  \tg,\n  \th,\n  \ti;\n  JSEND\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_55()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  /* start of define */\n  {\n  }\n  #define AAA \\\n  BBB\\\n  CCC\n\n  #define CNT \\\n  1 + \\\n  2 + \\\n  4\n  /* end of define */\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('start of define')\n  exe \"normal =/end of define\\n\"\n\n  let expected =<< trim [CODE]\n  /* start of define */\n  {\n  }\n  #define AAA \\\n  \tBBB\\\n  \tCCC\n\n  #define CNT \\\n  \t1 + \\\n  \t2 + \\\n  \t4\n  /* end of define */\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_cindent_56()\n  new\n  setl cindent ts=4 sw=4\n  setl cino&\n\n  let code =<< trim [CODE]\n  {\n  \ta = second/*bug*/*line;\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  call search('a = second')\n  normal ox\n\n  let expected =<< trim [CODE]\n  {\n  \ta = second/*bug*/*line;\n  \tx\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\n\" this was going beyond the end of the line.\nfunc Test_cindent_case()\n  new\n  call setline(1, 'case x: // x')\n  set cindent\n  norm! f:a:\n  call assert_equal('case x:: // x', getline(1))\n  set cindent&\n  bwipe!\nendfunc\n\n\" Test for changing multiple lines (using c) with cindent\nfunc Test_cindent_change_multline()\n  new\n  setlocal cindent\n  call setline(1, ['if (a)', '{', '    i = 1;', '}'])\n  normal! jc3jm = 2;\n  call assert_equal(\"\\tm = 2;\", getline(2))\n  close!\nendfunc\n\nfunc Test_cindent_pragma()\n  new\n  setl cindent ts=4 sw=4\n  setl cino=Ps\n\n  let code =<< trim [CODE]\n  {\n  #pragma omp parallel\n  {\n  #pragma omp task\n  foo();\n  # pragma omp taskwait\n  }\n  }\n  [CODE]\n\n  call append(0, code)\n  normal gg\n  normal =G\n\n  let expected =<< trim [CODE]\n  {\n\t#pragma omp parallel\n\t{\n\t\t#pragma omp task\n\t\tfoo();\n\t\t# pragma omp taskwait\n\t}\n  }\n\n  [CODE]\n\n  call assert_equal(expected, getline(1, '$'))\n  enew! | close\nendfunc\n\nfunc Test_backslash_at_end_of_line()\n  new\n  exe \"norm v>O'\\\\\\<C-m>-\"\n  exe \"norm \\<C-q>=\"\n  bwipe!\nendfunc\n\nfunc Test_find_brace_backwards()\n  \" this was looking beyond the end of the line\n  new\n  norm R/*\n  norm o0{\n  norm o//\n  norm V{=\n  call assert_equal(['/*', '   0{', '//'], getline(1, 3))\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/cindent.c", "src/testdir/test_cindent.vim", "src/version.c"], "buggy_code_start_loc": [1640, 5316, 759], "buggy_code_end_loc": [1658, 5316, 759], "fixing_code_start_loc": [1640, 5317, 760], "fixing_code_end_loc": [1658, 5329, 762], "type": "CWE-122", "message": "vim is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2021-3984", "sourceIdentifier": "security@huntr.dev", "published": "2021-12-01T11:15:07.797", "lastModified": "2022-11-09T03:12:30.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "vim es vulnerable a un Desbordamiento del B\u00fafer en la regi\u00f3n Heap de la Memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.3625", "matchCriteriaId": "9C1A195C-3CB1-4AC1-A0B8-64088A27726F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/2de9b7c7c8791da8853a9a7ca9c467867465b655", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b114b5a2-18e2-49f0-b350-15994d71426a", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html", "source": "security@huntr.dev", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNXY7T5OORA7UJIMGSJBGHFMU6UZWS6P/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/2de9b7c7c8791da8853a9a7ca9c467867465b655"}}