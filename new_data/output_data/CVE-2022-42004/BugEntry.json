{"buggy_code": ["Project: jackson-databind\n\n------------------------------------------------------------------------\n=== Releases === \n------------------------------------------------------------------------\n\n2.13.4 (not yet released)\n\n#3275: JDK 16 Illegal reflective access for `Throwable.setCause()` with\n  `PropertyNamingStrategy.UPPER_CAMEL_CASE`\n (reported by Jason H)\n (fix suggested by gsinghlulu@github)\n#3565: `Arrays.asList()` value deserialization has changed from mutable to\n  immutable in 2.13\n (reported by JonasWilms@github)\n\n2.13.3 (14-May-2022)\n\n#3412: Version 2.13.2 uses `Method.getParameterCount()` which is not supported on\n  Android before API 26\n#3419: Improve performance of `UnresolvedForwardReference` for forward\n reference resolution\n(contributed by Gary M)\n#3446: `java.lang.StringBuffer` cannot be deserialized\n (reported by Lolf1010@github)\n#3450: DeserializationProblemHandler is not working with wrapper type\n  when returning null\n (reported by LJeanneau@github)\n\n2.13.2.2 (28-Mar-2022)\n\nNo changes since 2.13.2.1 but fixed Gradle Module Metadata (\"module.json\")\n\n2.13.2.1 (24-Mar-2022)\n\n#2816: Optimize UntypedObjectDeserializer wrt recursion\n (contributed by Taylor S, Spence N)\n#3412: Version 2.13.2 uses `Method.getParameterCount()` which is not\n  supported on Android before API 26\n (reported by Matthew F)\n\n2.13.2 (06-Mar-2022)\n\n#3293: Use Method.getParameterCount() where possible\n (suggested by Christoph D)\n#3344: `Set.of()` (Java 9) cannot be deserialized with polymorphic handling\n (reported by Sam K)\n#3368: `SnakeCaseStrategy` causes unexpected `MismatchedInputException` during\n  deserialization\n (reported by sszuev@github)\n#3369: Deserialization ignores other Object fields when Object or Array\n  value used for enum\n (reported by Krishna G)\n#3380: `module-info.java` is in `META-INF/versions/11` instead of `META-INF/versions/9`\n\n2.13.1 (19-Dec-2021)\n\n#3006: Argument type mismatch for `enum` with `@JsonCreator` that takes String,\n  gets JSON Number\n (reported by GrozaAnton@github)\n#3299: Do not automatically trim trailing whitespace from `java.util.regex.Pattern` values\n (reported by Joel B)\n#3305: ObjectMapper serializes `CharSequence` subtypes as POJO instead of\n  as String (JDK 15+)\n (reported by stevenupton@github; fix suggested by Sergey C)\n#3308: `ObjectMapper.valueToTree()` fails when\n `DeserializationFeature.FAIL_ON_TRAILING_TOKENS` is enabled\n (fix contributed by raphaelNguyen@github)\n#3328: Possible DoS if using JDK serialization to serialize JsonNode\n\n2.13.0 (30-Sep-2021)\n\n#1850: `@JsonValue` with integer for enum does not deserialize correctly\n (reported by tgolden-andplus@github)\n (fix contributed by limengning@github)\n#1988: MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUM does not work for Enum keys of Map\n (reported by Myp3ik@github)\n#2509: `AnnotatedMethod.getValue()/setValue()` doesn't have useful exception message\n (reported by henryptung@github)\n (fix contributed by Stephan S)\n#2828: Add `DatabindException` as intermediate subtype of `JsonMappingException`\n#2900: Jackson does not support deserializing new Java 9 unmodifiable collections\n (reported by Daniel H)\n#2989: Allocate TokenBuffer instance via context objects (to allow format-specific\n  buffer types)\n#3001: Add mechanism for setting default `ContextAttributes` for `ObjectMapper`\n#3002: Add `DeserializationContext.readTreeAsValue()` methods for more convenient\n  conversions for deserializers to use\n#3011: Clean up support of typed \"unmodifiable\", \"singleton\" Maps/Sets/Collections\n#3033: Extend internal bitfield of `MapperFeature` to be `long`\n#3035: Add `removeMixIn()` method in `MapperBuilder`\n#3036: Backport `MapperBuilder` lambda-taking methods: `withConfigOverride()`,\n  `withCoercionConfig()`, `withCoercionConfigDefaults()`\n#3080: configOverrides(boolean.class) silently ignored, whereas .configOverride(Boolean.class)\n  works for both primitives and boxed boolean values\n (reported by Asaf R)\n#3082: Dont track unknown props in buffer if `ignoreAllUnknown` is true\n (contributed by David H)\n#3091: Should allow deserialization of java.time types via opaque\n   `JsonToken.VALUE_EMBEDDED_OBJECT`\n#3099: Optimize \"AnnotatedConstructor.call()\" case by passing explicit null\n#3101: Add AnnotationIntrospector.XmlExtensions interface for decoupling javax dependencies\n#3110: Custom SimpleModule not included in list returned by ObjectMapper.getRegisteredModuleIds()\n  after registration\n (reported by dkindler@github)\n#3117: Use more limiting default visibility settings for JDK types (java.*, javax.*)\n#3122: Deep merge for `JsonNode` using `ObjectReader.readTree()`\n (reported by Eric S)\n#3125: IllegalArgumentException: Conflicting setter definitions for property\n  with more than 2 setters\n (reported by mistyzyq@github)\n#3130: Serializing java.lang.Thread fails on JDK 11 and above (should suppress\n  serialization of ClassLoader)\n#3143: String-based `Map` key deserializer is not deterministic when there is no\n  single arg constructor\n (reported by Halil \u0130brahim \u015e)\n#3154: Add ArrayNode#set(int index, primitive_type value)\n (contributed by Tarekk Mohamed A)\n#3160: JsonStreamContext \"currentValue\" wrongly references to @JsonTypeInfo\n  annotated object\n (reported by Aritz B)\n#3174: DOM `Node` serialization omits the default namespace declaration\n (contributed by Morten A-G)\n#3177: Support `suppressed` property when deserializing `Throwable`\n (contributed by Klaas D)\n#3187: `AnnotatedMember.equals()` does not work reliably\n (contributed by Klaas D)\n#3193: Add `MapperFeature.APPLY_DEFAULT_VALUES`, initially for Scala module\n (suggested by Nick B)\n#3214: For an absent property Jackson injects `NullNode` instead of `null` to a\n  JsonNode-typed constructor argument of a `@ConstructorProperties`-annotated constructor\n (reported by robvarga@github)\n#3217: `XMLGregorianCalendar` doesn't work with default typing\n (reported by Xinzhe Y)\n#3227: Content `null` handling not working for root values\n (reported by Jo\u00e3o G)\n (fix contributed by proost@github)\n#3234: StdDeserializer rejects blank (all-whitespace) strings for ints\n (reported by Peter B)\n (fix proposed by qthegreat3@github)\n#3235: `USE_BASE_TYPE_AS_DEFAULT_IMPL` not working with `DefaultTypeResolverBuilder`\n (reported, fix contributed by silas.u / sialais@github)\n#3238: Add PropertyNamingStrategies.UpperSnakeCaseStrategy (and UPPER_SNAKE_CASE constant)\n (requested by Kenneth J)\n (contributed by Tanvesh)\n#3244: StackOverflowError when serializing JsonProcessingException\n (reported by saneksanek@github)\n#3259: Support for BCP 47 `java.util.Locale` serialization/deserialization\n (contributed by Abishek R)\n#3271: String property deserializes null as \"null\" for JsonTypeInfo.As.EXISTING_PROPERTY\n (reported by jonc2@github)\n#3280: Can not deserialize json to enum value with Object-/Array-valued input,\n  `@JsonCreator`\n (reported by peteryuanpan@github)\n#3397: Optimize `JsonNodeDeserialization` wrt recursion\n- Fix to avoid problem with `BigDecimalNode`, scale of `Integer.MIN_VALUE` (see\n  [dataformats-binary#264] for details)\n- Extend handling of `FAIL_ON_NULL_FOR_PRIMITIVES` to cover coercion from (Empty) String\n  via `AsNull`\n- Add `mvnw` wrapper\n\n2.12.7 (26-May-2022)\n\n#2816: Optimize UntypedObjectDeserializer wrt recursion [CVE-2020-36518]\n\n2.12.6 (15-Dec-2021)\n\n#3280: Can not deserialize json to enum value with Object-/Array-valued input,\n  `@JsonCreator`\n (reported by peteryuanpan@github)\n#3305: ObjectMapper serializes `CharSequence` subtypes as POJO instead of\n  as String (JDK 15+)\n (reported by stevenupton@github; fix suggested by Sergey C)\n#3328: Possible DoS if using JDK serialization to serialize JsonNode\n\n2.12.5 (27-Aug-2021)\n\n#3220: (regression) Factory method generic type resolution does not use\n  Class-bound type parameter\n (reported by Marcos P)\n\n2.12.4 (06-Jul-2021)\n\n#3139: Deserialization of \"empty\" subtype with DEDUCTION failed\n (reported by JoeWoo; fix provided by drekbour@github)\n#3146: Merge findInjectableValues() results in AnnotationIntrospectorPair\n (contributed by Joe B)\n#3171: READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE doesn't work with empty strings\n (reported by unintended@github)\n\n2.12.3 (12-Apr-2021)\n\n#3108: `TypeFactory` cannot convert `Collection` sub-type without type parameters\n  to canonical form and back\n (reported by lbilger@github)\n- Fix for [modules-java8#207]: prevent fail on secondary Java 8 date/time types\n\n2.12.2 (03-Mar-2021)\n\n#754: EXTERNAL_PROPERTY does not work well with `@JsonCreator` and\n   `FAIL_ON_UNKNOWN_PROPERTIES`\n (reported by Vassil D)\n#3008: String property deserializes null as \"null\" for\n   `JsonTypeInfo.As.EXTERNAL_PROPERTY`\n#3022: Property ignorals cause `BeanDeserializer `to forget how to read\n  from arrays (not copying `_arrayDelegateDeserializer`)\n (reported by Gian M)\n#3025: UntypedObjectDeserializer` mixes multiple unwrapped\n  collections (related to #2733)\n (fix contributed by Migwel@github)\n#3038: Two cases of incorrect error reporting about DeserializationFeature\n (reported by Jelle V)\n#3045: Bug in polymorphic deserialization with `@JsonCreator`, `@JsonAnySetter`,\n  `JsonTypeInfo.As.EXTERNAL_PROPERTY`\n (reported by martineaus83@github)\n#3055: Polymorphic subtype deduction ignores `defaultImpl` attribute\n (contributed by drekbour@github)\n#3056: MismatchedInputException: Cannot deserialize instance of\n  `com.fasterxml.jackson.databind.node.ObjectNode` out of VALUE_NULL token\n (reported by Stexxen@github)\n#3060: Missing override for `hasAsKey()` in `AnnotationIntrospectorPair`\n#3062: Creator lookup fails with `InvalidDefinitionException` for conflict\n  between single-double/single-Double arg constructor\n#3068: `MapDeserializer` forcing `JsonMappingException` wrapping even if\n  WRAP_EXCEPTIONS set to false\n (reported by perkss@github)\n\n2.12.1 (08-Jan-2021)\n\n#2962: Auto-detection of constructor-based creator method skipped if there is\n   an annotated factory-based creator method (regression from 2.11)\n (reported by Halil I-S)\n#2972: `ObjectMapper.treeToValue()` no longer invokes `JsonDeserializer.getNullValue()`\n (reported by andpal@github)\n#2973: DeserializationProblemHandler is not invoked when trying to deserializing String\n (reported by zigzago@github)\n#2978: Fix failing `double` JsonCreators in jackson 2.12.0\n (contributed by Carter K)\n#2979: Conflicting in POJOPropertiesCollector when having namingStrategy\n (reported, fix suggested by SunYiJun)\n#2990: Breaking API change in `BasicClassIntrospector` (2.12.0)\n (reported, fix contributed by Faron D)\n#3005: `JsonNode.requiredAt()` does NOT fail on some path expressions\n#3009: Exception thrown when `Collections.synchronizedList()` is serialized\n  with type info, deserialized\n (reported by pcloves@github)\n\n2.12.0 (29-Nov-2020)\n\n#43: Add option to resolve type from multiple existing properties,\n  `@JsonTypeInfo(use=DEDUCTION)`\n (contributed by drekbour@github)\n#426: `@JsonIgnoreProperties` does not prevent Exception Conflicting getter/setter\n  definitions for property\n (reported by gmkll@github)\n#921: Deserialization Not Working Right with Generic Types and Builders\n (reported by Mike G; fix contributed by Ville K)\n#1296: Add `@JsonIncludeProperties(propertyNames)` (reverse of `@JsonIgnoreProperties`)\n (contributed Baptiste P)\n#1458: `@JsonAnyGetter` should be allowed on a field\n (contributed by Dominik K)\n#1498: Allow handling of single-arg constructor as property based by default\n (requested by Lovro P)\n#1852: Allow case insensitive deserialization of String value into\n  `boolean`/`Boolean` (esp for Excel)\n (requested by Patrick J)\n#1886: Allow use of `@JsonFormat(with=JsonFormat.Feature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)`\n  on Class\n#1919: Abstract class included as part of known type ids for error message\n  when using JsonSubTypes\n (reported by Incara@github)\n#2066: Distinguish null from empty string for UUID deserialization\n (requested by leonshaw@github)\n#2091: `ReferenceType` does not expose valid containedType\n (reported by Nate B)\n#2113: Add `CoercionConfig[s]` mechanism for configuring allowed coercions\n#2118: `JsonProperty.Access.READ_ONLY` does not work with \"getter-as-setter\" `Collection`s\n (reported by Xiang Z)\n#2215: Support `BigInteger` and `BigDecimal` creators in `StdValueInstantiator`\n (requested by David N, implementation contributed by Tiago M)\n#2283: `JsonProperty.Access.READ_ONLY` fails with collections when a property name is specified\n (reported by Yona A)\n#2644: `BigDecimal` precision not retained for polymorphic deserialization\n (reported by rost5000@github)\n#2675: Support use of `Void` valued properties (`MapperFeature.ALLOW_VOID_VALUED_PROPERTIES`)\n#2683: Explicitly fail (de)serialization of `java.time.*` types in absence of\n  registered custom (de)serializers\n#2707: Improve description included in by `DeserializationContext.handleUnexpectedToken()`\n#2709: Support for JDK 14 record types (`java.lang.Record`)\n (contributed by Youri B)\n#2715: `PropertyNamingStrategy` class initialization depends on its subclass, this can\n  lead to class loading deadlock\n (reported by fangwentong@github)\n#2719: `FAIL_ON_IGNORED_PROPERTIES` does not throw on `READONLY` properties with\n  an explicit name\n (reported, fix contributed by David B)\n#2726: Add Gradle Module Metadata for version alignment with Gradle 6\n (contributed by Jendrik J)\n#2732: Allow `JsonNode` auto-convert into `ArrayNode` if duplicates found (for XML)\n#2733: Allow values of \"untyped\" auto-convert into `List` if duplicates found (for XML)\n#2751: Add `ValueInstantiator.createContextual(...)\n#2761: Support multiple names in `JsonSubType.Type`\n (contributed by Swayam R)\n#2775: Disabling `FAIL_ON_INVALID_SUBTYPE` breaks polymorphic deserialization of Enums\n (reported by holgerknoche@github)\n#2776: Explicitly fail (de)serialization of `org.joda.time.*` types in absence of registered\n  custom (de)serializers\n#2784: Trailing zeros are stripped when deserializing BigDecimal values inside a\n  @JsonUnwrapped property\n (reported by mjustin@github)\n#2800: Extract getter/setter/field name mangling from `BeanUtil` into\n  pluggable `AccessorNamingStrategy`\n#2804: Throw `InvalidFormatException` instead of `MismatchedInputException`\n   for ACCEPT_FLOAT_AS_INT coercion failures\n (requested by mjustin@github)\n#2871: Add `@JsonKey` annotation (similar to `@JsonValue`) for customizable\n  serialization of Map keys\n (requested by CidTori@github; implementation contributed by Kevin B)\n#2873: `MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS` should work for enum as keys\n (fix contributed by Ilya G)\n#2879: Add support for disabling special handling of \"Creator properties\" wrt\n  alphabetic property ordering\n (contributed by Sergiy Y)\n#2885: Add `JsonNode.canConvertToExactIntegral()` to indicate whether floating-point/BigDecimal\n  values could be converted to integers losslessly\n (requested by Oguzhan U; implementation contributed by Siavash S)\n#2895: Improve static factory method generic type resolution logic\n (contributed by Carter K)\n#2903: Allow preventing \"Enum from integer\" coercion using new `CoercionConfig` system\n#2909: `@JsonValue` not considered when evaluating inclusion\n (reported by chrylis@github)\n#2910: Make some java platform modules optional\n (contributed by XakepSDK@github)\n#2925: Add support for serializing `java.sql.Blob`\n (contributed by M Rizky S)\n#2928: `AnnotatedCreatorCollector` should avoid processing synthetic static\n  (factory) methods\n (contributed by Carter K)\n#2931: Add errorprone static analysis profile to detect bugs at build time\n (contributed by Carter K)\n#2932: Problem with implicit creator name detection for constructor detection\n- Add `BeanDeserializerBase.isCaseInsensitive()`\n- Some refactoring of `CollectionDeserializer` to solve CSV array handling issues\n- Full \"LICENSE\" included in jar for easier access by compliancy tools\n\n2.11.4 (12-Dec-2020)\n\n#2894: Fix type resolution for static methods (regression in 2.11.3 due to #2821 fix)\n (reported by \u0141ukasz W)\n#2944: `@JsonCreator` on constructor not compatible with `@JsonIdentityInfo`,\n  `PropertyGenerator`\n (reported by Lucian H)\n- Add debug improvements wrt #2807 (`ClassUtil.getClassMethods()`)\n\n2.11.3 (02-Oct-2020)\n\n#2795: Cannot detect creator arguments of mixins for JDK types\n (reported by Marcos P)\n#2815: Add `JsonFormat.Shape` awareness for UUID serialization (`UUIDSerializer`)\n#2821: Json serialization fails or a specific case that contains generics and\n  static methods with generic parameters (2.11.1 -> 2.11.2 regression)\n (reported by Lari H)\n#2822: Using JsonValue and JsonFormat on one field does not work as expected\n (reported by Nils-Christian E)\n#2840: `ObjectMapper.activateDefaultTypingAsProperty()` is not using\n  parameter `PolymorphicTypeValidator`\n (reported by Daniel W)\n#2846: Problem deserialization \"raw generic\" fields (like `Map`) in 2.11.2\n- Fix issues with `MapLikeType.isTrueMapType()`,\n  `CollectionLikeType.isTrueCollectionType()`\n\n2.11.2 (02-Aug-2020)\n\n#2783: Parser/Generator features not set when using `ObjectMapper.createParser()`,\n  `createGenerator()`\n#2785: Polymorphic subtypes not registering on copied ObjectMapper (2.11.1)\n (reported, fix contributed by Joshua S)\n#2789: Failure to read AnnotatedField value in Jackson 2.11\n (reported by isaki@github)\n#2796: `TypeFactory.constructType()` does not take `TypeBindings` correctly\n (reported by Daniel H)\n\n2.11.1 (25-Jun-2020)\n\n#2486: Builder Deserialization with JsonCreator Value vs Array\n (reported by Ville K)\n#2725: JsonCreator on static method in Enum and Enum used as key in map\n  fails randomly\n (reported by Michael C)\n#2755: `StdSubtypeResolver` is not thread safe (possibly due to copy\n  not being made with `ObjectMapper.copy()`)\n (reported by tjwilson90@github)\n#2757: \"Conflicting setter definitions for property\" exception for `Map`\n  subtype during deserialization\n (reported by Frank S)\n#2758: Fail to deserialize local Records\n (reported by Johannes K)\n#2759: Rearranging of props when property-based generator is in use leads\n  to incorrect output\n (reported by Oleg C)\n#2760: Jackson doesn't respect `CAN_OVERRIDE_ACCESS_MODIFIERS=false` for\n  deserializer properties\n (reported by Johannes K)\n#2767: `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS` don't support `Map`\n  type field\n (reported by abomb4@github)\n#2770: JsonParser from MismatchedInputException cannot getText() for\n  floating-point value\n (reported by Jo\u00e3o G)\n\n2.11.0 (26-Apr-2020)\n\n#953: i-I case conversion problem in Turkish locale with case-insensitive deserialization\n (reported by M\u00e1t\u00e9 R)\n#962: `@JsonInject` fails on trying to find deserializer even if inject-only\n (reported by David B)\n#1983: Polymorphic deserialization should handle case-insensitive Type Id property name\n  if `MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES` is enabled\n (reported by soundvibe@github, fix contributed by Oleksandr P)\n#2049: TreeTraversingParser and UTF8StreamJsonParser create contexts differently\n (reported by Antonio P)\n#2352: Support use of `@JsonAlias` for enum values\n (contributed by Robert D)\n#2365: `declaringClass` of \"enum-as-POJO\" not removed for `ObjectMapper` with\n  a naming strategy\n (reported by Tynakuh@github)\n#2480: Fix `JavaType.isEnumType()` to support sub-classes\n#2487: BeanDeserializerBuilder Protected Factory Method for Extension\n (contributed by Ville K)\n#2503: Support `@JsonSerialize(keyUsing)` and `@JsonDeserialize(keyUsing)` on Key class\n#2511: Add `SerializationFeature.WRITE_SELF_REFERENCES_AS_NULL`\n (contributed by Joongsoo P)\n#2515: `ObjectMapper.registerSubtypes(NamedType...)` doesn't allow registering\n  same POJO for two different type ids\n (contributed by Joseph K)\n#2522: `DeserializationContext.handleMissingInstantiator()` throws\n  `MismatchedInputException` for non-static inner classes\n#2525: Incorrect `JsonStreamContext` for `TokenBuffer` and `TreeTraversingParser`\n#2527: Add `AnnotationIntrospector.findRenameByField()` to support Kotlin's\n  \"is-getter\" naming convention\n#2555: Use `@JsonProperty(index)` for sorting properties on serialization\n#2565: Java 8 `Optional` not working with `@JsonUnwrapped` on unwrappable type\n (reported by Haowei W)\n#2587: Add `MapperFeature.BLOCK_UNSAFE_POLYMORPHIC_BASE_TYPES` to allow blocking\n  use of unsafe base type for polymorphic deserialization\n#2589: `DOMDeserializer`: setExpandEntityReferences(false) may not prevent\n  external entity expansion in all cases [CVE-2020-25649]\n (reported by Bartosz B)\n#2592: `ObjectMapper.setSerializationInclusion()` is ignored for `JsonAnyGetter`\n (reported by Oleksii K)\n#2608: `ValueInstantiationException` when deserializing using a builder and\n  `UNWRAP_SINGLE_VALUE_ARRAYS`\n (reported by cadrake@github)\n#2627: JsonIgnoreProperties(ignoreUnknown = true) does not work on field and method level\n (reported by robotmrv@github)\n#2632: Failure to resolve generic type parameters on serialization\n (reported by Simone D)\n#2635: JsonParser cannot getText() for input stream on MismatchedInputException\n (reported by Jo\u00e3o G)\n#2636: ObjectReader readValue lacks Class<T> argument\n (contributed by Robin R)\n#2643: Change default textual serialization of `java.util.Date`/`Calendar`\n  to include colon in timezone offset\n#2647: Add `ObjectMapper.createParser()` and `createGenerator()` methods\n#2657: Allow serialization of `Properties` with non-String values\n#2663: Add new factory method for creating custom `EnumValues` to pass to `EnumDeserializer\n (requested by Rafal K)\n#2668: `IllegalArgumentException` thrown for mismatched subclass deserialization\n (reported by nbruno@github)\n#2693: Add convenience methods for creating `List`, `Map` valued `ObjectReader`s\n  (ObjectMapper.readerForListOf())\n- Add `SerializerProvider.findContentValueSerializer()` methods\n\n2.10.5.1 (02-Dec-2020)\n\n#2589: (see desc on 2.11.0 -- backported)\n\n2.10.5 (21-Jul-2020)\n\n#2787 (partial fix): NPE after add mixin for enum\n (reported by Denis K)\n\n2.10.4 (03-May-2020)\n\n#2679: `ObjectMapper.readValue(\"123\", Void.TYPE)` throws \"should never occur\"\n (reported by Endre S)\n\n2.10.3 (03-Mar-2020)\n\n#2482: `JSONMappingException` `Location` column number is one line Behind the actual\n  location\n (reported by Kamal A, fixed by Ivo S)\n#2599: NoClassDefFoundError at DeserializationContext.<init> on Android 4.1.2\n  and Jackson 2.10.0\n (reported by Tobias P)\n#2602: ByteBufferSerializer produces unexpected results with a duplicated ByteBuffer\n  and a position > 0\n (reported by Eduard T)\n#2605: Failure to deserializer polymorphic subtypes of base type `Enum`\n (reported by uewle@github)\n#2610: `EXTERNAL_PROPERTY` doesn't work with `@JsonIgnoreProperties`\n (reported, fix suggested by Alexander S)\n\n2.10.2 (05-Jan-2020)\n\n#2101: `FAIL_ON_NULL_FOR_PRIMITIVES` failure does not indicate field name in exception message\n (reported by raderio@github)\n\n2.10.1 (09-Nov-2019)\n\n#2457: Extended enum values are not handled as enums when used as Map keys\n (reported by Andrey K)\n#2473: Array index missing in path of `JsonMappingException` for `Collection<String>`,\n  with custom deserializer\n (reported by Jo\u00e3o G)\n#2475: `StringCollectionSerializer` calls `JsonGenerator.setCurrentValue(value)`,\n  which messes up current value for sibling properties\n (reported by Ryan B)\n#2485: Add `uses` for `Module` in module-info\n (contributed by Marc M)\n#2513: BigDecimalAsStringSerializer in NumberSerializer throws IllegalStateException in 2.10\n (reported by Johan H)\n#2519: Serializing `BigDecimal` values inside containers ignores shape override\n (reported by Richard W)\n#2520: Sub-optimal exception message when failing to deserialize non-static inner classes\n (reported by Mark S)\n#2529: Add tests to ensure `EnumSet` and `EnumMap` work correctly with \"null-as-empty\"\n#2534: Add `BasicPolymorphicTypeValidator.Builder.allowIfSubTypeIsArray()`\n#2535: Allow String-to-byte[] coercion for String-value collections\n\n2.10.0 (26-Sep-2019)\n\n#18: Make `JsonNode` serializable\n#1093: Default typing does not work with `writerFor(Object.class)`\n (reported by hoomanv@github)\n#1675: Remove \"impossible\" `IOException` in `readTree()` and `readValue()` `ObjectMapper`\n  methods which accept Strings\n (requested by matthew-pwnieexpress@github)\n#1954: Add Builder pattern for creating configured `ObjectMapper` instances\n#1995: Limit size of `DeserializerCache`, auto-flush on exceeding\n#2059: Remove `final` modifier for `TypeFactory`\n (requested by Thibaut R)\n#2077: `JsonTypeInfo` with a subtype having `JsonFormat.Shape.ARRAY` and\n  no fields generates `{}` not `[]`\n (reported by Sadayuki F)\n#2115: Support naive deserialization of `Serializable` values as \"untyped\", same\n  as `java.lang.Object`\n (requested by Christopher S)\n#2116: Make NumberSerializers.Base public and its inherited classes not final\n (requested by \u00c9douard M)\n#2126: `DeserializationContext.instantiationException()` throws `InvalidDefinitionException`\n#2129: Add `SerializationFeature.WRITE_ENUM_KEYS_USING_INDEX`, separate from value setting\n (suggested by renzihui@github)\n#2133: Improve `DeserializationProblemHandler.handleUnexpectedToken()` to allow handling of\n  Collection problems\n (contributed by Semyon L)\n#2149: Add `MapperFeature.ACCEPT_CASE_INSENSITIVE_VALUES`\n (suggested by Craig P)\n#2153: Add `JsonMapper` to replace generic `ObjectMapper` usage\n#2164: `FactoryBasedEnumDeserializer` does not respect\n  `DeserializationFeature.WRAP_EXCEPTIONS`\n (reported by Yiqiu H)\n#2187: Make `JsonNode.toString()` use shared `ObjectMapper` to produce valid json\n#2189: `TreeTraversingParser` does not check int bounds\n (reported by Alexander S)\n#2195: Add abstraction `PolymorphicTypeValidator`, for limiting subtypes allowed by\n  default typing, `@JsonTypeInfo`\n#2196: Type safety for `readValue()` with `TypeReference`\n (suggested by nguyenfilip@github)\n#2204: Add `JsonNode.isEmpty()` as convenience alias\n#2211: Change of behavior (2.8 -> 2.9) with `ObjectMapper.readTree(input)` with no content\n#2217: Suboptimal memory allocation in `TextNode.getBinaryValue()`\n (reported by Christoph B)\n#2220: Force serialization always for `convertValue()`; avoid short-cuts\n#2223: Add `missingNode()` method in `JsonNodeFactory`\n#2227: Minor cleanup of exception message for `Enum` binding failure\n (reported by RightHandedMonkey@github)\n#2230: `WRITE_BIGDECIMAL_AS_PLAIN` is ignored if `@JsonFormat` is used\n (reported by Pavel C)\n#2236: Type id not provided on `Double.NaN`, `Infinity` with `@JsonTypeInfo`\n (reported by C-B-B@github)\n#2237: Add \"required\" methods in `JsonNode`: `required(String | int)`,\n  `requiredAt(JsonPointer)`\n#2241: Add `PropertyNamingStrategy.LOWER_DOT_CASE` for dot-delimited names\n (contributed by zenglian@github.com)\n#2251: Getter that returns an abstract collection breaks a delegating `@JsonCreator`\n#2265: Inconsistent handling of Collections$UnmodifiableList vs Collections$UnmodifiableRandomAccessList\n#2273: Add basic Java 9+ module info\n#2280: JsonMerge not work with constructor args\n (reported by Deblock T)\n#2309: READ_ENUMS_USING_TO_STRING doesn't support null values\n (reported, fix suggested by Ben A)\n#2311: Unnecessary MultiView creation for property writers\n (suggested by Manuel H)\n#2331: `JsonMappingException` through nested getter with generic wildcard return type\n (reported by sunchezz89@github)\n#2336: `MapDeserializer` can not merge `Map`s with polymorphic values\n (reported by Robert G)\n#2338: Suboptimal return type for `JsonNode.withArray()`\n (reported by Victor N)\n#2339: Suboptimal return type for `ObjectNode.set()`\n (reported by Victor N)\n#2348: Add sanity checks for `ObjectMapper.readXXX()` methods\n (requested by ebundy@github)\n#2349: Add option `DefaultTyping.EVERYTHING` to support Kotlin data classes\n#2357: Lack of path on MismatchedInputException\n (suggested by TheEin@github)\n#2378: `@JsonAlias` doesn't work with AutoValue\n (reported by David H)\n#2390: `Iterable` serialization breaks when adding `@JsonFilter` annotation\n (reported by Chris M)\n#2392: `BeanDeserializerModifier.modifyDeserializer()` not applied to custom bean deserializers\n (reported by andreasbaus@github)\n#2393: `TreeTraversingParser.getLongValue()` incorrectly checks `canConvertToInt()`\n (reported by RabbidDog@github)\n#2398: Replace recursion in `TokenBuffer.copyCurrentStructure()` with iteration\n (reported by Sam S)\n#2415: Builder-based POJO deserializer should pass builder instance, not type,\n  to `handleUnknownVanilla()`\n (proposed by Vladimir T, follow up to #822)\n#2416: Optimize `ValueInstantiator` construction for default `Collection`, `Map` types\n#2422: `scala.collection.immutable.ListMap` fails to serialize since 2.9.3\n (reported by dejanlokar1@github)\n#2424: Add global config override setting for `@JsonFormat.lenient()`\n#2428: Use \"activateDefaultTyping\" over \"enableDefaultTyping\" in 2.10 with new methods\n#2430: Change `ObjectMapper.valueToTree()` to convert `null` to `NullNode`\n#2432: Add support for module bundles\n (contributed by Marcos P)\n#2433: Improve `NullNode.equals()`\n (suggested by David B)\n#2442: `ArrayNode.addAll()` adds raw `null` values which cause NPE on `deepCopy()`\n  and `toString()`\n (reported, fix contributed by Hesham M)\n#2446: Java 11: Unable to load JDK7 types (annotations, java.nio.file.Path): no Java7 support added\n (reported by David C)\n#2451: Add new `JsonValueFormat` value, `UUID`\n#2453: Add `DeserializationContext.readTree(JsonParser)` convenience method\n#2458: `Nulls` property metadata ignored for creators\n (reported  by XakepSDK@github)\n#2466: Didn't find class \"java.nio.file.Path\" below Android api 26\n (reported by KevynBct@github)\n#2467: Accept `JsonTypeInfo.As.WRAPPER_ARRAY` with no second argument to\n  deserialize as \"null value\"\n (contributed by Martin C)\n\n[2.9.10.x micro-patches omitted]\n\n2.9.10 (21-Sep-2019)\n\n#2331: `JsonMappingException` through nested getter with generic wildcard return type\n#2334: Block one more gadget type (CVE-2019-12384)\n#2341: Block one more gadget type (CVE-2019-12814)\n#2374: `ObjectMapper. getRegisteredModuleIds()` throws NPE if no modules registered\n#2387: Block yet another deserialization gadget (CVE-2019-14379)\n#2389: Block yet another deserialization gadget (CVE-2019-14439)\n (reported by xiexq)\n#2404: FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY setting ignored when\n  creator properties are buffered\n (contributed by Joe B)\n#2410: Block one more gadget type (HikariCP, CVE-2019-14540)\n  (reported by iSafeBlue@github / blue@ixsec.org)\n#2420: Block one more gadget type (cxf-jax-rs, no CVE allocated yet)\n  (reported by crazylirui@gmail.com)\n#2449: Block one more gadget type (HikariCP, CVE-2019-14439 / CVE-2019-16335)\n  (reported by kingkk)\n#2460: Block one more gadget type (ehcache, CVE-2019-17267)\n  (reported by Fei Lu)\n#2462: Block two more gadget types (commons-configuration/-2)\n#2469: Block one more gadget type (xalan2)\n\n2.9.9 (16-May-2019)\n\n#1408: Call to `TypeVariable.getBounds()` without synchronization unsafe on some platforms\n (reported by Thomas K)\n#2221: `DeserializationProblemHandler.handleUnknownTypeId()` returning `Void.class`,\n  enableDefaultTyping causing NPE\n (reported by MeyerNils@github)\n#2251: Getter that returns an abstract collection breaks a delegating `@JsonCreator`\n#2265: Inconsistent handling of Collections$UnmodifiableList vs Collections$UnmodifiableRandomAccessList\n (reported by Joffrey B)\n#2299: Fix for using jackson-databind in an OSGi environment under Android\n (contributed by Christoph F)\n#2303: Deserialize null, when java type is \"TypeRef of TypeRef of T\", does not provide \"Type(Type(null))\"\n (reported by Cyril M)\n#2324: `StringCollectionDeserializer` fails with custom collection\n (reported byb Daniil B)\n#2326: Block one more gadget type (CVE-2019-12086)\n- Prevent String coercion of `null` in `WritableObjectId` when calling `JsonGenerator.writeObjectId()`,\n  mostly relevant for formats like YAML that have native Object Ids\n\n2.9.8 (15-Dec-2018)\n\n#1662: `ByteBuffer` serialization is broken if offset is not 0\n (reported by j-baker@github)\n#2155: Type parameters are checked for equality while isAssignableFrom expected\n (reported by frankfiedler@github)\n#2167: Large ISO-8601 Dates are formatted/serialized incorrectly\n#2181: Don't re-use dynamic serializers for property-updating copy constructors\n (suggested by Pavel N)\n#2183: Base64 JsonMappingException: Unexpected end-of-input\n (reported by ViToni@github)\n#2186: Block more classes from polymorphic deserialization (CVE-2018-19360,\n  CVE-2018-19361, CVE-2018-19362)\n (reported by Guixiong Wu)\n#2197: Illegal reflective access operation warning when using `java.lang.Void`\n  as value type\n (reported by Ren\u00e9 K)\n#2202: StdKeyDeserializer Class method _getToStringResolver is slow causing Thread Block\n (reported by sushobhitrajan@github)\n\n2.9.7 (19-Sep-2018)\n\n#2060: `UnwrappingBeanPropertyWriter` incorrectly assumes the found serializer is\n  of type `UnwrappingBeanSerializer`\n (reported by Petar T)\n#2064: Cannot set custom format for `SqlDateSerializer` globally\n (reported by Brandon K)\n#2079: NPE when visiting StaticListSerializerBase\n (reported by WorldSEnder@github)\n#2082: `FactoryBasedEnumDeserializer` should be cachable\n#2088: `@JsonUnwrapped` fields are skipped when using `PropertyBasedCreator` if\n  they appear after the last creator property\n (reported, fix contributed by 6bangs@github)\n#2096: `TreeTraversingParser` does not take base64 variant into account\n (reported by tangiel@github)\n#2097: Block more classes from polymorphic deserialization (CVE-2018-14718\n  - CVE-2018-14721)\n#2109: Canonical string for reference type is built incorrectly\n (reported by svarzee@github)\n#2120: `NioPathDeserializer` improvement\n (contributed by Semyon L)\n#2128: Location information included twice for some `JsonMappingException`s\n\n2.9.6 (12-Jun-2018)\n\n#955: Add `MapperFeature.USE_BASE_TYPE_AS_DEFAULT_IMPL` to use declared base type\n   as `defaultImpl` for polymorphic deserialization\n  (contributed by mikeldpl@github)\n#1328: External property polymorphic deserialization does not work with enums\n#1565: Deserialization failure with Polymorphism using JsonTypeInfo `defaultImpl`,\n  subtype as target\n#1964: Failed to specialize `Map` type during serialization where key type\n  incompatibility overidden via \"raw\" types\n (reported by ptirador@github)\n#1990: MixIn `@JsonProperty` for `Object.hashCode()` is ignored\n (reported by Freddy B)\n#1991: Context attributes are not passed/available to custom serializer if object is in POJO\n (reported by dletin@github)\n#1998: Removing \"type\" attribute with Mixin not taken in account if\n  using ObjectMapper.copy()\n (reported by SBKila@github)\n#1999: \"Duplicate property\" issue should mention which class it complains about\n (reported by Ondrej Z)\n#2001: Deserialization issue with `@JsonIgnore` and `@JsonCreator` + `@JsonProperty`\n  for same property name\n (reported, fix contributed by Jakub S)\n#2015: `@Jsonsetter with Nulls.SKIP` collides with\n  `DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL` when parsing enum\n (reported by ndori@github)\n#2016: Delegating JsonCreator disregards JsonDeserialize info\n (reported by Carter K)\n#2019: Abstract Type mapping in 2.9 fails when multiple modules are registered\n (reported by asger82@github)\n#2021: Delegating JsonCreator disregards `JsonDeserialize.using` annotation\n#2023: `JsonFormat.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` not working\n  with `null` coercion with `@JsonSetter`\n#2027: Concurrency error causes `IllegalStateException` on `BeanPropertyMap`\n (reported by franboragina@github)\n#2032: CVE-2018-11307: Potential information exfiltration with default typing, serialization gadget from MyBatis\n (reported by Guixiong Wu)\n#2034: Serialization problem with type specialization of nested generic types\n (reported by Reinhard P)\n#2038: JDK Serializing and using Deserialized `ObjectMapper` loses linkage\n  back from `JsonParser.getCodec()`\n (reported by Chetan N)\n#2051: Implicit constructor property names are not renamed properly with\n  `PropertyNamingStrategy`\n#2052: CVE-2018-12022: Block polymorphic deserialization of types from Jodd-db library\n (reported by Guixiong Wu)\n#2058: CVE-2018-12023: Block polymorphic deserialization of types from Oracle JDBC driver\n (reported by Guixiong Wu)\n\n2.9.5 (26-Mar-2018)\n\n#1911: Allow serialization of `BigDecimal` as String, using\n  `@JsonFormat(shape=Shape.String)`, config overrides\n (suggested by cen1@github)\n#1912: `BeanDeserializerModifier.updateBuilder()` not work to set custom\n  deserializer on a property (since 2.9.0)\n (contributed by Deblock T)\n#1931: Two more `c3p0` gadgets to exploit default typing issue\n (reported by lilei@venusgroup.com.cn)\n#1932: `EnumMap` cannot deserialize with type inclusion as property\n#1940: `Float` values with integer value beyond `int` lose precision if\n  bound to `long`\n (reported by Aniruddha M)\n#1941: `TypeFactory.constructFromCanonical()` throws NPE for Unparameterized\n  generic canonical strings\n (reported by ayushgp@github)\n#1947: `MapperFeature.AUTO_DETECT_XXX` do not work if all disabled\n (reported by Timur S)\n#1977: Serializing an Iterator with multiple sub-types fails after upgrading to 2.9.x\n (reported by ssivanand@github)\n#1978: Using @JsonUnwrapped annotation in builderdeserializer hangs in infinite loop\n (reported by roeltje25@github)\n\n2.9.4 (24-Jan-2018)\n\n#1382: `@JsonProperty(access=READ_ONLY)` unxepected behaviour with `Collections`\n (reported by hexfaker@github)\n#1673: Serialising generic value classes via Reference Types (like Optional) fails\n  to include type information\n (reported by Pier-Luc W)\n#1729: Integer bounds verification when calling `TokenBuffer.getIntValue()`\n (reported by Kevin G)\n#1853: Deserialise from Object (using Creator methods) returns field name instead of value\n (reported by Alexander S)\n#1854: NPE deserializing collection with `@JsonCreator` and `ACCEPT_CASE_INSENSITIVE_PROPERTIES`\n (reported by rue-jw@github)\n#1855: Blacklist for more serialization gadgets (dbcp/tomcat, spring, CVE-2017-17485)\n#1859: Issue handling unknown/unmapped Enum keys\n (reported by remya11@github)\n#1868: Class name handling for JDK unmodifiable Collection types changed\n  (reported by Rob W)\n#1870: Remove `final` on inherited methods in `BuilderBasedDeserializer` to allow\n  overriding by subclasses\n  (requested by Ville K)\n#1878: `@JsonBackReference` property is always ignored when deserializing since 2.9.0\n (reported by reda-alaoui@github)\n#1895: Per-type config override \"JsonFormat.Shape.OBJECT\" for Map.Entry not working\n (reported by mcortella@github)\n#1899: Another two gadgets to exploit default typing issue in jackson-databind\n (reported by OneSourceCat@github)\n#1906: Add string format specifier for error message in `PropertyValueBuffer`\n (reported by Joe S)\n#1907: Remove `getClass()` from `_valueType` argument for error reporting\n (reported by Joe S)\n\n2.9.3 (09-Dec-2017)\n\n#1604: Nested type arguments doesn't work with polymorphic types\n#1794: `StackTraceElementDeserializer` not working if field visibility changed\n (reported by dsingley@github)\n#1799: Allow creation of custom sub-types of `NullNode`, `BooleanNode`, `MissingNode`\n#1804: `ValueInstantiator.canInstantiate()` ignores `canCreateUsingArrayDelegate()`\n (reported byb henryptung@github)\n#1807: Jackson-databind caches plain map deserializer and use it even map has `@JsonDeserializer`\n (reported by lexas2509@github)\n#1823: ClassNameIdResolver doesn't handle resolve Collections$SingletonMap & Collections$SingletonSet\n (reported by Peter J)\n#1831: `ObjectReader.readValue(JsonNode)` does not work correctly with polymorphic types,\n  value to update\n (reported by basmastr@github)\n#1835: ValueInjector break from 2.8.x to 2.9.x\n (repoted by kinigitbyday@github)\n#1842: `null` String for `Exception`s deserialized as String \"null\" instead of `null`\n (reported by ZeleniJure@github)\n#1843: Include name of unsettable property in exception from `SetterlessProperty.set()`\n (suggested by andreh7@github)\n#1844: Map \"deep\" merge only adds new items, but not override existing values\n (reported by alinakovalenko@github)\n\n2.9.2 (14-Oct-2017)\n\n(possibly) #1756: Deserialization error with custom `AnnotationIntrospector`\n (reported by Daniel N)\n#1705: Non-generic interface method hides type resolution info from generic base class\n  (reported by Tim B)\n NOTE: was originally reported fixed in 2.9.1 -- turns out it wasn't.\n#1767: Allow `DeserializationProblemHandler` to respond to primitive types\n (reported by nhtzr@github)\n#1768: Improve `TypeFactory.constructFromCanonical()` to work with\n  `java.lang.reflect.Type.getTypeName()' format\n (suggested by Lu\u00eds C)\n#1771: Pass missing argument for string formatting in `ObjectMapper`\n (reported by Nils B)\n#1788: `StdDateFormat._parseAsISO8601()` does not parse \"fractional\" timezone correctly\n#1793: `java.lang.NullPointerException` in `ObjectArraySerializer.acceptJsonFormatVisitor()`\n  for array value with `@JsonValue`\n (reported by Vincent D)\n\n2.9.1 (07-Sep-2017)\n\n#1725: `NPE` In `TypeFactory. constructParametricType(...)`\n (reported by ctytgat@github)\n#1730: InvalidFormatException` for `JsonToken.VALUE_EMBEDDED_OBJECT`\n (reported by zigzago@github)\n#1744: StdDateFormat: add option to serialize timezone offset with a colon\n (contributed by Bertrand R)\n#1745: StdDateFormat: accept and truncate millis larger than 3 digits\n (suggested by Bertrand R)\n#1749: StdDateFormat: performance improvement of '_format(..)' method \n (contributed by Bertrand R)\n#1759: Reuse `Calendar` instance during parsing by `StdDateFormat`\n (contributed by Bertrand R)\n- Fix `DelegatingDeserializer` constructor to pass `handledType()` (and\n  not type of deserializer being delegated to!)\n- Add `Automatic-Module-Name` (\"com.fasterxml.jackson.databind\") for JDK 9 module system\n\n2.9.0 (30-Jul-2017)\n\n#219: SqlDateSerializer does not obey SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS\n (reported by BrentDouglas@github)\n#265: Add descriptive exception for attempts to use `@JsonWrapped` via Creator parameter\n#291: @JsonTypeInfo with As.EXTERNAL_PROPERTY doesn't work if external type property\n  is referenced more than once\n (reported by Starkom@github)\n#357: StackOverflowError with contentConverter that returns array type\n (reported by Florian S)\n#383: Recursive `@JsonUnwrapped` (`child` with same type) fail: \"No _valueDeserializer assigned\"\n (reported by tdavis@github)\n#403: Make FAIL_ON_NULL_FOR_PRIMITIVES apply to primitive arrays and other types that wrap primitives\n (reported by Harleen S)\n#476: Allow \"Serialize as POJO\" using `@JsonFormat(shape=Shape.OBJECT)` class annotation\n#507: Support for default `@JsonView` for a class\n (suggested by Mark W)\n#687: Exception deserializing a collection @JsonIdentityInfo and a property based creator\n#865: `JsonFormat.Shape.OBJECT` ignored when class implements `Map.Entry`\n#888: Allow specifying custom exclusion comparator via `@JsonInclude`,\n  using `JsonInclude.Include.CUSTOM`\n#994: `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS` only works for POJOs, Maps\n#1029: Add a way to define property name aliases\n#1035: `@JsonAnySetter` assumes key of `String`, does not consider declared type.\n (reported by Michael F)\n#1060: Allow use of `@JsonIgnoreProperties` for POJO-valued arrays, `Collection`s\n#1106: Add `MapperFeature.ALLOW_COERCION_OF_SCALARS` for enabling/disabling coercions\n#1284: Make `StdKeySerializers` use new `JsonGenerator.writeFieldId()` for `int`/`long` keys\n#1320: Add `ObjectNode.put(String, BigInteger)`\n (proposed by Jan L)\n#1341: `DeserializationFeature.FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY`\n (contributed by Connor K)\n#1347: Extend `ObjectMapper.configOverrides()` to allow changing visibility rules\n#1356: Differentiate between input and code exceptions on deserialization\n (suggested by Nick B)\n#1369: Improve `@JsonCreator` detection via `AnnotationIntrospector`\n by passing `MappingConfig`\n#1371: Add `MapperFeature.INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES` to allow\n disabling use of `@CreatorProperties` as explicit `@JsonCreator` equivalent\n#1376: Add ability to disable JsonAnySetter/JsonAnyGetter via mixin\n (suggested by brentryan@github)\n#1399: Add support for `@JsonMerge` to allow \"deep update\"\n#1402: Use `@JsonSetter(nulls=...)` to specify handling of `null` values during deserialization\n#1406: `ObjectMapper.readTree()` methods do not return `null` on end-of-input\n (reported by Fabrizio C)\n#1407: `@JsonFormat.pattern` is ignored for `java.sql.Date` valued properties\n (reported by sangpire@github)\n#1415: Creating CollectionType for non generic collection class broken\n#1428: Allow `@JsonValue` on a field, not just getter\n#1434: Explicitly pass null on invoke calls with no arguments\n (contributed by Emiliano C)\n#1433: `ObjectMapper.convertValue()` with null does not consider null conversions\n  (`JsonDeserializer.getNullValue()`)\n (contributed by jdmichal@github)\n#1440: Wrong `JsonStreamContext` in `DeserializationProblemHandler` when reading\n  `TokenBuffer` content\n (reported by Patrick G)\n#1444: Change `ObjectMapper.setSerializationInclusion()` to apply to content inclusion too\n#1450: `SimpleModule.addKeyDeserializer()' should throw `IllegalArgumentException` if `null`\n  reference of `KeyDeserializer` passed\n (suggested by PawelJagus@github)\n#1454: Support `@JsonFormat.lenient` for `java.util.Date`, `java.util.Calendar`\n#1474: Replace use of `Class.newInstance()` (deprecated in Java 9) with call via Constructor\n#1480: Add support for serializing `boolean`/`Boolean` as number (0 or 1)\n (suggested by jwilmoth@github)\n#1520: Case insensitive enum deserialization with `MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS`\n (contributed by Ana-Eliza B)\n#1522: Global `@JsonInclude(Include.NON_NULL)` for all properties with a specific type\n (contributed by Carsten W)\n#1544: EnumMapDeserializer assumes a pure EnumMap and does not support EnumMap derived classes\n (reported by Lyor G)\n#1550: Unexpected behavior with `@JsonInclude(JsonInclude.Include.NON_EMPTY)` and\n `java.util.Date` serialization\n#1551: `JsonMappingException` with polymorphic type and `JsonIdentityInfo` when basic type is abstract\n (reported by acm073@github)\n#1552: Map key converted to byte array is not serialized as base64 string\n (reported by nmatt@github)\n#1554: Support deserialization of `Shape.OBJECT` (\"as POJO\") for `Map`s (and map-like types)\n#1556: Add `ObjectMapper.updateValue()` method to update instance with given overrides\n (suggested by syncer@github)\n#1583: Add a `DeserializationFeature.FAIL_ON_TRAILING_TOKENS` to force reading of the\n  whole input as single value\n#1592: Add support for handling primitive/discrepancy problem with type refinements\n#1605: Allow serialization of `InetAddress` as simple numeric host address\n (requested by Jared J)\n#1616: Extraneous type id mapping added for base type itself\n#1619: By-pass annotation introspection for array types\n#1637: `ObjectReader.at()` with `JsonPointer` stops after first collection\n (reported by Chris P)\n#1653: Convenience overload(s) for ObjectMapper#registerSubtypes\n#1655: `@JsonAnyGetter` uses different `bean` parameter in `SimpleBeanPropertyFilter`\n (reported by georgeflugq@github)\n#1678: Rewrite `StdDateFormat` ISO-8601 handling functionality\n#1684: Rewrite handling of type ids to let `JsonGenerator` handle (more of) details\n#1688: Deserialization fails for `java.nio.file.Path` implementations when default typing\n  enabled\n (reported by Christian B)\n#1690: Prevent use of quoted number (index) for Enum deserialization via\n  `MapperFeature.ALLOW_COERCION_OF_SCALARS`\n (requested by magdel@github)\n\n2.8.11.4 (25-Jul-2019)\n\n#2334: Block one more gadget type (CVE-2019-12384)\n#2341: Block one more gadget type (CVE-2019-12814)\n#2387: Block one more gadget type (CVE-2019-14379)\n#2389: Block one more gadget type (CVE-2019-14439)\n (reported by xiexq)\n\n2.8.11.3 (23-Nov-2018)\n\n#2326: Block one more gadget type (CVE-2019-12086)\n (contributed by MaximilianTews@github)\n\n2.8.11.2 (08-Jun-2018)\n\n#1941: `TypeFactory.constructFromCanonical()` throws NPE for Unparameterized\n  generic canonical strings\n (reported by ayushgp@github)\n#2032: CVE-2018-11307: Potential information exfiltration with default typing, serialization gadget from MyBatis\n (reported by Guixiong Wu)\n#2052: CVE-2018-12022: Block polymorphic deserialization of types from Jodd-db library\n (reported by Guixiong Wu)\n#2058: CVE-2018-12023: Block polymorphic deserialization of types from Oracle JDBC driver\n (reported by Guixiong Wu)\n\n2.8.11.1 (11-Feb-2018)\n\n#1872: `NullPointerException` in `SubTypeValidator.validateSubType` when\n  validating Spring interface\n (reported by Rob W)\n#1899: Another two gadgets to exploit default typing issue (CVE-2018-5968)\n (reported by OneSourceCat@github)\n#1931: Two more `c3p0` gadgets to exploit default typing issue (c3p0, CVE-2018-7489)\n\n2.8.11 (24-Dec-2017)\n\n#1604: Nested type arguments doesn't work with polymorphic types\n#1680: Blacklist couple more types for deserialization\n#1767: Allow `DeserializationProblemHandler` to respond to primitive types\n (reported by nhtzr@github)\n#1768: Improve `TypeFactory.constructFromCanonical()` to work with\n  `java.lang.reflect.Type.getTypeName()` format\n#1804: `ValueInstantiator.canInstantiate()` ignores `canCreateUsingArrayDelegate()`\n (reported by henryptung@github)\n#1807: Jackson-databind caches plain map deserializer and use it even map has `@JsonDeserializer`\n (reported by lexas2509@github)\n#1855: Blacklist for more serialization gadgets (dbcp/tomcat, spring / CVE-2017-17485)\n\n2.8.10 (24-Aug-2017)\n\n#1657: `StdDateFormat` deserializes dates with no tz/offset as UTC instead of\n  configured timezone\n (reported by Bertrand R)\n#1680: Blacklist couple more types for deserialization\n#1658: Infinite recursion when deserializing a class extending a Map,\n  with a recursive value type\n (reported by Kevin G)\n#1679: `StackOverflowError` in Dynamic `StdKeySerializer`\n#1711: Delegating creator fails to work for binary data (`byte[]`) with\n binary formats (CBOR, Smile)\n#1735: Missing type checks when using polymorphic type ids\n (reported by Lukas Euler)\n#1737: Block more JDK types from polymorphic deserialization (CVE 2017-15095)\n\n2.8.9 (12-Jun-2017)\n\n#1595: `JsonIgnoreProperties.allowSetters` is not working in Jackson 2.8\n (reported by Javy L)\n#1597: Escape JSONP breaking characters\n (contributed by Marco C)\n#1629: `FromStringDeserializer` ignores registered `DeserializationProblemHandler`\n  for `java.util.UUID`\n (reported by Andrew J)\n#1642: Support `READ_UNKNOWN_ENUM_VALUES_AS_NULL` with `@JsonCreator`\n (contributed by Joe L)\n#1647: Missing properties from base class when recursive types are involved\n (reported by Slobodan P)\n#1648: `DateTimeSerializerBase` ignores configured date format when creating contextual\n (reported by Bertrand R)\n#1651: `StdDateFormat` fails to parse 'zulu' date when TimeZone other than UTC\n (reported by Bertrand R)\n\n2.8.8.1 (19-Apr-2017)\n\n#1585: Invoke ServiceLoader.load() inside of a privileged block when loading\n  modules using `ObjectMapper.findModules()`\n (contributed by Ivo S)\n#1599: Jackson Deserializer security vulnerability (CVE-2017-7525)\n (reported by ayound@github)\n#1607: @JsonIdentityReference not used when setup on class only\n (reported by vboulaye@github)\n\n2.8.8 (05-Apr-2017)\n\n(partial) #994: `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS` only works for POJOs, Maps\n#1345: `@JsonProperty(access = READ_ONLY)` together with generated constructor (Lombok) causes\n exception: \"Could not find creator property with name ...\"\n (reported by Raniz85@github)\n#1533: `AsPropertyTypeDeserializer` ignores `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT`\n#1543: JsonFormat.Shape.NUMBER_INT does not work when defined on enum type in 2.8\n (reported by Alex P)\n#1570: `Enum` key for `Map` ignores `SerializationFeature.WRITE_ENUMS_USING_INDEX`\n (reported by SolaKun@github)\n#1573: Missing properties when deserializing using a builder class with a non-default\n  constructor and a mutator annotated with `@JsonUnwrapped`\n (reported by Joshua J)\n#1575: Problem with `@JsonIgnoreProperties` on recursive property (regression in 2.8)\n (reported by anujkumar04@github)\n- Minor fix to creation of `PropertyMetadata`, had one path that could lead to NPE\n\n2.8.7 (21-Feb-2017)\n\n#935: `@JsonProperty(access = Access.READ_ONLY)` - unexpected behaviour\n#1317: '@JsonIgnore' annotation not working with creator properties, serialization\n\n2.8.6 (12-Jan-2017)\n\n#349: @JsonAnySetter with @JsonUnwrapped: deserialization fails with arrays\n (reported by hdave@github)\n#1388: `@JsonIdentityInfo`: id has to be the first key in deserialization when\n  deserializing with `@JsonCreator`\n (reported by moodysalem@github)\n#1425: `JsonNode.binaryValue()` ignores illegal character if it's the last one\n (reported by binoternary@github)\n#1453: `UntypedObjectDeserializer` does not retain `float` type (over `double`)\n#1456: `TypeFactory` type resolution broken in 2.7 for generic types\n   when using `constructType` with context\n#1473: Add explicit deserializer for `StringBuilder` due to Java 9 changes\n#1493: `ACCEPT_CASE_INSENSITIVE_PROPERTIES` fails with `@JsonUnwrapped`\n\n2.8.5 (14-Nov-2016)\n\n#1417: Further issues with `@JsonInclude` with `NON_DEFAULT`\n#1421: ACCEPT_SINGLE_VALUE_AS_ARRAY partially broken in 2.7.x, 2.8.x\n#1429: `StdKeyDeserializer` can erroneously use a static factory method\n  with more than one argument\n#1432: Off by 1 bug in PropertyValueBuffer\n (reported by Kevin D)\n#1438: `ACCEPT_CASE_INSENSITIVE_PROPERTIES` is not respected for creator properties\n (reported by Jayson M)\n#1439: NPE when using with filter id, serializing `java.util.Map` types\n#1441: Failure with custom Enum key deserializer, polymorphic types\n (reported by Nathanial O)\n#1445: Map key deserializerModifiers ignored\n (reported by alfonsobonso@github)\n- Improvements to #1411 fix to ensure consistent `null` key handling\n\n2.8.4 (14-Oct-2016)\n\n#466: Jackson ignores Type information when raw return type is BigDecimal or BigInteger \n#1001: Parameter names module gets confused with delegate creator which is a static method\n#1324: Boolean parsing with `StdDeserializer` is too slow with huge integer value\n (reported by pavankumar-parankusam@github)\n#1383: Problem with `@JsonCreator` with 1-arg factory-method, implicit param names\n#1384: `@JsonDeserialize(keyUsing = ...)` does not work correctly together with\n  DefaultTyping.NON_FINAL\n (reported by Oleg Z)\n#1385: Polymorphic type lost when using `@JsonValue`\n (reported by TomMarkuske@github)\n#1389 Problem with handling of multi-argument creator with Enums\n (fix contributed by Pavel P)\n#1392: Custom UnmodifiableSetMixin Fails in Jackson 2.7+ but works in Jackson 2.6\n (reported by Rob W)\n#1395: Problems deserializing primitive `long` field while using `TypeResolverBuilder`\n (reported by UghZan3@github)\n#1403: Reference-chain hints use incorrect class-name for inner classes\n (reported by Josh G)\n#1411: MapSerializer._orderEntries should check for null keys\n (reported by J\u00f6rn H)\n\n2.8.3 (17-Sep-2016)\n\n#1351: `@JsonInclude(NON_DEFAULT)` doesn't omit null fields\n (reported by Gili T)\n#1353: Improve error-handling for `java.net.URL` deserialization\n#1361: Change `TokenBuffer` to use new `writeEmbeddedObject()` if possible\n\n2.8.2 (30-Aug-2016)\n\n#1315: Binding numeric values can BigDecimal lose precision\n (reported by Andrew S)\n#1327: Class level `@JsonInclude(JsonInclude.Include.NON_EMPTY)` is ignored\n (reported by elruwen@github)\n#1335: Unconditionally call `TypeIdResolver.getDescForKnownTypeIds`\n (contributed by Chris J-Y)\n\n2.8.1 (20-Jul-2016)\n\n#1256: `Optional.empty()` not excluded if property declared with type `Object`\n#1288: Type id not exposed for `JsonTypeInfo.As.EXTERNAL_PROPERTY` even when `visible` set to `true`\n (reported by libetl@github)\n#1289: Optimize construction of `ArrayList`, `LinkedHashMap` instances\n#1291: Backward-incompatible behaviour of 2.8: deserializing enum types\n   with two static factory methods fail by default\n#1297: Deserialization of generic type with Map.class\n (reported by Arek G)\n#1302: NPE for `ResolvedRecursiveType` in 2.8.0 due to caching\n\n2.8.0 (04-Jul-2016)\n\n#621: Allow definition of \"ignorable types\" without annotation (using\n  `Mapper.configOverride(type).setIsIgnoredType(true)`\n#867: Support `SerializationFeature.WRITE_EMPTY_JSON_ARRAYS ` for `JsonNode`\n#903: Add `JsonGenerator` reference to `SerializerProvider`\n#931: Add new method in `Deserializers.Base` to support `ReferenceType`\n#960: `@JsonCreator` not working on a factory with no arguments for an enum type\n (reported by Artur J)\n#990: Allow failing on `null` values for creator (add \n  `DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES`)\n (contributed by mkokho@github)\n#999: External property is not deserialized\n (reported by Aleksandr O)\n#1017: Add new mapping exception type ('InvalidTypeIdException') for subtype resolution errors\n (suggested by natnan@github)\n#1028: Ignore USE_BIG_DECIMAL_FOR_FLOATS for NaN/Infinity\n (reported by Vladimir K, lightoze@github)\n#1047: Allow use of `@JsonAnySetter` on a Map-valued field, no need for setter\n#1082: Can not use static Creator factory methods for `Enum`s, with JsonCreator.Mode.PROPERTIES\n (contributed by Lokesh K)\n#1084: Change `TypeDeserializerBase` to take `JavaType` for `defaultImpl`, NOT `Class`\n#1126: Allow deserialization of unknown Enums using a predefined value\n (contributed by Alejandro R)\n#1136: Implement `TokenBuffer.writeEmbeddedObject(Object)`\n (suggested by Gregoire C, gcxRun@github)\n#1165: CoreXMLDeserializers does not handle time-only XMLGregorianCalendars\n (reported, contributed fix by Ross G)\n#1181: Add the ability to specify the initial capacity of the ArrayNode\n (suggested by Matt V, mveitas@github)\n#1184: Allow overriding of `transient` with explicit inclusion with `@JsonProperty`\n (suggested by Maarten B)\n#1187: Refactor `AtomicReferenceDeserializer` into `ReferenceTypeDeserializer`\n#1204: Add a convenience accessor `JavaType.hasContentType()` (true for container or reference type)\n#1206: Add \"anchor type\" member for `ReferenceType`\n#1211: Change `JsonValueSerializer` to get `AnnotatedMethod`, not \"raw\" method\n#1217: `@JsonIgnoreProperties` on Pojo fields not working for deserialization\n (reported by Lokesh K)\n#1221: Use `Throwable.addSuppressed()` directly and/or via try-with-resources\n#1232: Add support for `JsonFormat.Feature.ACCEPT_CASE_INSENSITIVE_PROPERTIES`\n#1233: Add support for `JsonFormat.Feature.WRITE_SORTED_MAP_ENTRIES`\n#1235: `java.nio.file.Path` support incomplete\n (reported by, fix contributed by Benson M)\n#1261: JsonIdentityInfo broken deserialization involving forward references and/or cycles\n (reported by, fix contributed by Ari F)\n#1270: Generic type returned from type id resolver seems to be ignored\n (reported by Benson M)\n#1277: Add caching of resolved generic types for `TypeFactory`\n (requested by Andriy P)\n\n2.7.9.5 (23-Nov-2018)\n\n#2097: Block more classes from polymorphic deserialization (CVE-2018-14718\n  - CVE-2018-14721)\n (reported by Guixiong Wu)\n#2109: Canonical string for reference type is built incorrectly\n (reported by svarzee@github)\n#2186: Block more classes from polymorphic deserialization (CVE-2018-19360,\n  CVE-2018-19361, CVE-2018-19362)\n (reported by Guixiong Wu)\n\n2.7.9 (04-Feb-2017)\n\n#1367: No Object Id found for an instance when using `@ConstructorProperties`\n#1505: @JsonEnumDefaultValue should take precedence over FAIL_ON_NUMBERS_FOR_ENUMS\n (suggested by Stephan S)\n#1506: Missing `KeyDeserializer` for `CharSequence`\n#1513: `MapSerializer._orderEntries()` throws NPE when operating on `ConcurrentHashMap`\n (reported by Sovietaced@github)\n- Simplified processing of class annotations (for `AnnotatedClass`) to try to\n  solve rare concurrency problems with \"root name\" annotations.\n\n2.7.8 (26-Sep-2016)\n\n#877: @JsonIgnoreProperties`: ignoring the \"cause\" property of `Throwable` on GAE\n#1359: Improve `JsonNode` deserializer to create `FloatNode` if parser supports\n#1362: ObjectReader.readValues()` ignores offset and length when reading an array\n (reported by wastevenson@github)\n#1363: The static field ClassUtil.sCached can cause a class loader leak\n (reported by Stuart D)\n#1368: Problem serializing `JsonMappingException` due to addition of non-ignored\n  `processor` property (added in 2.7)\n (reported, suggesed fix by Josh C)\n#1383: Problem with `@JsonCreator` with 1-arg factory-method, implicit param names\n\n2.7.7 (27-Aug-2016)\n\n#1322: EnumMap keys not using enum's `@JsonProperty` values unlike Enum values\n (reported by MichaelChambers@github)\n#1332: Fixed ArrayIndexOutOfBoundException for enum by index deser\n (reported by Max D)\n#1344: Deserializing locale assumes JDK separator (underscore), does not\n  accept RFC specified (hyphen)\n (reported by Jim M)\n\n2.7.6 (23-Jul-2016)\n\n#1215: Problem with type specialization for Maps with `@JsonDeserialize(as=subtype)`\n (reported by brentryan@github)\n#1279: Ensure DOM parsing defaults to not expanding external entities\n#1288: Type id not exposed for `JsonTypeInfo.As.EXTERNAL_PROPERTY` even when `visible` set to `true`\n#1299: Timestamp deserialization error\n (reported by liyuj@github)\n#1301: Problem with `JavaType.toString()` for recursive (self-referential) types\n (reported by Brian P)\n#1307: `TypeWrappedDeserializer` doesn't delegate the `getNullValue()` method to `_deserializer`\n (reported by vfries@github)\n\n2.7.5 (11-Jun-2016)\n\n#1098: DeserializationFeature.FAIL_ON_INVALID_SUBTYPE does not work with\n  `JsonTypeInfo.Id.CLASS`\n (reported by szaccaria@github)\n#1223: `BasicClassIntrospector.forSerialization(...).findProperties` should\n  respect MapperFeature.AUTO_DETECT_GETTERS/SETTERS?\n (reported by William H)\n#1225: `JsonMappingException` should override getProcessor()\n (reported by Nick B)\n\n2.6.7.1 (11-Jul-2017)\n\n#1383: Problem with `@JsonCreator` with 1-arg factory-method, implicit param names\n#1599: Backport the extra safety checks for polymorphic deserialization\n\n2.6.7 (05-Jun-2016)\n\n#1194: Incorrect signature for generic type via `JavaType.getGenericSignature\n#1228: @JsonAnySetter does not deserialize null to Deserializer's NullValue\n (contributed by Eric S)\n#1231: `@JsonSerialize(as=superType)` behavior disallowed in 2.7.4\n (reported by Mark W)\n#1248: `Annotated` returns raw type in place of Generic Type in 2.7.x\n (reported by Andrew J, apjoseph@github)\n#1253: Problem with context handling for `TokenBuffer`, field name\n#1260: `NullPointerException` in `JsonNodeDeserializer`\n (reported by Eric S)\n\n2.7.4 (29-Apr-2016)\n\n#1122: Jackson 2.7 and Lombok: 'Conflicting/ambiguous property name definitions'\n#1178: `@JsonSerialize(contentAs=superType)` behavior disallowed in 2.7\n#1186: SimpleAbstractTypeResolver breaks generic parameters\n (reported by tobiash@github)\n#1189: Converter called twice results in ClassCastException\n (reported by carrino@github)\n#1191: Non-matching quotes used in error message for date parsing\n#1194: Incorrect signature for generic type via `JavaType.getGenericSignature\n#1195: `JsonMappingException` not Serializable due to 2.7 reference to source (parser)\n (reported by mjustin@github)\n#1197: `SNAKE_CASE` doesn't work when using Lombok's `@AllArgsConstructor`\n#1198: Problem with `@JsonTypeInfo.As.EXTERNAL_PROPERTY`, `defaultImpl`, missing type id, NPE\n#1203: `@JsonTypeInfo` does not work correctly for ReferenceTypes like `AtomicReference`\n#1208: treeToValue doesn't handle POJONodes that contain exactly the requested value type\n  (reported by Tom M)\n- Improve handling of custom content (de)serializers for `AtomicReference`\n\n2.7.3 (16-Mar-2016)\n\n#1125: Problem with polymorphic types, losing properties from base type(s)\n#1150: Problem with Object id handling, explicit `null` token\n (reported by Xavi T)\n#1154: @JsonFormat.pattern on dates is now ignored if shape is not explicitely provided\n (reported by Yoann R)\n#1161: `DeserializationFeature.READ_ENUMS_USING_TO_STRING` not dynamically\n  changeable with 2.7\n (reported by asa-git@github)\n- Minor fixes to `AnnotationIntrospector.findEnumValues()` to correct problems with\n  merging of explicit enum value names.\n\n2.7.2 (26-Feb-2016)\n\n#1124: JsonAnyGetter ignores JsonSerialize(contentUsing=...)\n (reported by Jiri M)\n#1128: UnrecognizedPropertyException in 2.7.1 for properties that work with version 2.6.5\n (reported by Roleek@github)\n#1129: When applying type modifiers, don't ignore container types.\n#1130: NPE in `StdDateFormat` hashCode and equals\n (reported by Kazuki S, kazuki43zoo@github)\n#1134: Jackson 2.7 doesn't work with jdk6 due to use of `Collections.emptyIterator()`\n (reported by Timur S, saladinkzn@github)\n\n2.7.1-1 (03-Feb-2016)\n\nSpecial one-off \"micro patch\" for:\n\n#1115: Problems with deprecated `TypeFactory.constructType(type, ctxt)` methods if `ctxt` is `null`\n\n2.7.1 (02-Feb-2016)\n\n#1079: Add back `TypeFactory.constructType(Type, Class)` as \"deprecated\" in 2.7.1\n#1083: Field in base class is not recognized, when using `@JsonType.defaultImpl`\n (reported by Julian H)\n#1095: Prevent coercion of `int` from empty String to `null` if\n  `DeserializationFeature .FAIL_ON_NULL_FOR_PRIMITIVES` is `true`\n (reported by yzmyyff@github)\n#1102: Handling of deprecated `SimpleType.construct()` too minimalistic\n (reported by Thibault K)\n#1109: @JsonFormat is ignored by the DateSerializer unless either a custom pattern\n  or a timezone are specified\n (contributed by Aleks S)\n\n2.7.0 (10-Jan-2016)\n\n#76: Problem handling datatypes Recursive type parameters\n (reported by Aram K)\n#357: StackOverflowError with contentConverter that returns array type\n (reported by Florian S)\n#432: `StdValueInstantiator` unwraps exceptions, losing context\n (reported by Miles K)\n#497: Add new JsonInclude.Include feature to exclude maps after exclusion removes all elements\n#803: Allow use of `StdDateFormat.setLenient()`\n (suggested by raj-ghodke@github)\n#819: Add support for setting `FormatFeature` via `ObjectReader`, `ObjectWriter`\n#857: Add support for java.beans.Transient (requires Java 7)\n (suggested by Thomas M)\n#898: Add `ObjectMapper.getSerializerProviderInstance()`\n#905: Add support for `@ConstructorProperties` (requires Java 7)\n (requested by Jonas K)\n#909: Rename PropertyNamingStrategy CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES as SNAKE_CASE,\n   PASCAL_CASE_TO_CAMEL_CASE as UPPER_CAMEL_CASE\n (suggested by marcottedan@github)\n#915: ObjectMapper default timezone is GMT, should be UTC\n (suggested by Infrag@github)\n#918: Add `MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING`\n (contributed by David H)\n#924: `SequenceWriter.writeAll()` could accept `Iterable`\n (suggested by Jiri-Kremser@github(\n#932: Rewrite ser/deser for `AtomicReference`, based on \"optional\" ser/desers\n#933: Close some gaps to allow using the `tryToResolveUnresolved` flows\n#936: Deserialization into List subtype with JsonCreator no longer works\n (reported by adamjoeldavis@github)\n#948: Support leap seconds, any number of millisecond digits for ISO-8601 Dates.\n (contributed by Jesse W)\n#952: Revert non-empty handling of primitive numbers wrt `NON_EMPTY`; make\n  `NON_DEFAULT` use extended criteria\n#957: Merge `datatype-jdk7` stuff in (java.nio.file.Path handling)\n#959: Schema generation: consider active view, discard non-included properties\n#963: Add PropertyNameStrategy `KEBAB_CASE`\n (requested by Daniel M)\n#978: ObjectMapper#canSerialize(Object.class) returns false even though FAIL_ON_EMPTY_BEANS is disabled\n (reported by Shumpei A)\n#997: Add `MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS`\n#998: Allow use of `NON_DEFAULT` for POJOs without default constructor\n#1000: Add new mapping exception type for enums and UUIDs\n (suggesed by natnan@github)\n#1010: Support for array delegator\n (contributed by Hugo W)\n#1011: Change ObjectWriter::withAttributes() to take a Map with some kind of wildcard types\n (suggested by David B)\n#1043: @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY) does not work on fields\n (reported by fabiolaa@github)\n#1044: Add `AnnotationIntrospector.resolveSetterConflict(...)` to allow custom setter conflict resolution\n (suggested by clydebarrow@github)\n- Make `JsonValueFormat` (self-)serializable, deserializable, to/from valid external\n  value (as per JSON Schema spec)\n\nINCOMPATIBILITIES:\n\n- While unlikely to be problematic, #959 above required an addition of `SerializerProvider`\n  argument for `depositSchemaProperty()` method `BeanProperty` and `PropertyWriter` interfaces\n- JDK baseline now Java 7 (JDK 1.7), from Java 6/JDK 1.6\n\n2.6.6 (05-Apr-2016)\n\n#1088: NPE possibility in SimpleMixinResolver\n (reported by Laird N)\n#1099: Fix custom comparator container node traversal\n (contributed by Daniel N)\n#1108: Jackson not continue to parse after DeserializationFeature.FAIL_ON_INVALID_SUBTYPE error\n (reported by jefferyyuan@github)\n#1112: Detailed error message from custom key deserializer is discarded\n (contributed by Benson M)\n#1120: String value omitted from weirdStringException\n (reported by Benson M)\n#1123: Serializing and Deserializing Locale.ROOT\n (reported by hookumsnivy@github)\n\n2.6.5 (19-Jan-2016)\n\n#1052: Don't generate a spurious NullNode after parsing an embedded object\n (reported by philipa@github)\n#1061: Problem with Object Id and Type Id as Wrapper Object (regression in 2.5.1)\n#1073: Add try-catch around `java.sql` type serializers\n (suggested by claudemt@github)\n#1078: ObjectMapper.copy() still does not preserve _registeredModuleTypes\n (reported by ajonkisz@github)\n\n2.6.4 (07-Dec-2015)\n\n#984: JsonStreamContexts are not build the same way for write.. and convert methods\n (reported by Antibrumm@github)\n#989: Deserialization from \"{}\" to java.lang.Object causes \"out of END_OBJECT token\" error\n (reported by Ievgen P)\n#1003: JsonTypeInfo.As.EXTERNAL_PROPERTY does not work with a Delegate\n (reported by alexwen@github)\n#1005: Synthetic constructors confusing Jackson data binding\n (reported by Jayson M)\n#1013: `@JsonUnwrapped` is not treated as assuming `@JsonProperty(\"\")`\n (reported by David B)\n#1036: Problem with case-insensitive deserialization\n (repoted by Dmitry R)\n- Fix a minor problem with `@JsonNaming` not recognizing default value\n\n2.6.3 (12-Oct-2015)\n\n#749: `EnumMap` serialization ignores `SerializationFeature.WRITE_ENUMS_USING_TO_STRING`\n (reported by scubasau@github)\n#938: Regression: `StackOverflowError` with recursive types that contain `Map.Entry`\n (reported by jloisel@github)\n#939: Regression: DateConversionError in 2.6.x \n (reported by Andreas P, anpieber@github)\n#940: Add missing `hashCode()` implementations for `JsonNode` types that did not have them\n (contributed by Sergio M)\n#941: Deserialization from \"{}\" to ObjectNode field causes \"out of END_OBJECT token\" error\n (reported by Sadayuki F)\n#942: Handle null type id for polymorphic values that use external type id\n (reported by Warren B, stormboy@github)\n#943: Incorrect serialization of enum map key\n (reported by Benson M)\n#944: Failure to use custom deserializer for key deserializer\n (contributed by Benson M)\n#949: Report the offending substring when number parsing fails\n (contributed by Jesse W)\n#965: BigDecimal values via @JsonTypeInfo/@JsonSubTypes get rounded\n (reported by gmjabs@github)\n\n2.6.2 (14-Sep-2015)\n\n#894: When using withFactory on ObjectMapper, the created Factory has a TypeParser\n  which still has the original Factory\n (reported by lufe66@github)\n#899: Problem serializing `ObjectReader` (and possibly `ObjectMapper`)\n#913: ObjectMapper.copy does not preserve MappingJsonFactory features\n (reported, fixed by Daniel W)\n#922: ObjectMapper.copy() does not preserve _registeredModuleTypes\n#928: Problem deserializing External Type Id if type id comes before POJO\n\n2.6.1 (09-Aug-2015)\n\n#873: Add missing OSGi import\n#881: BeanDeserializerBase having issues with non-CreatorProperty properties.\n (reported by dharaburda@github)\n#884: ArrayIndexOutOfBoundException for `BeanPropertyMap` (with ObjectId)\n (reported by alterGauner@github)\n#889: Configuring an ObjectMapper's DateFormat changes time zone\n (reported by Andy W, wilkinsona@github)\n#890: Exception deserializing a byte[] when the target type comes from an annotation\n (reported by gmjabs@github)\n\n2.6.0 (19-Jul-2015)\n\n#77: Allow injection of 'transient' fields\n#95: Allow read-only properties with `@JsonIgnoreProperties(allowGetters=true)`\n#222: EXTERNAL_PROPERTY adds property multiple times and in multiple places\n (reported by Rob E, thatsnotright@github)\n#296: Serialization of transient fields with public getters (add\n    MapperFeature.PROPAGATE_TRANSIENT_MARKER)\n (suggested by Michal L)\n#312: Support Type Id mappings where two ids map to same Class\n#348: ObjectMapper.valueToTree does not work with @JsonRawValue\n (reported by Chris P, pimlottc@github)\n#504: Add `DeserializationFeature.USE_LONG_FOR_INTS`\n (suggested by Jeff S)\n#624: Allow setting external `ClassLoader` to use, via `TypeFactory`\n#649: Make `BeanDeserializer` use new `parser.nextFieldName()` and `.hasTokenId()` methods\n#664: Add `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to prevent coercion of floating point\n numbers int `int`/`long`/`Integer`/`Long`\n (requested by wenzis@github)\n#677: Specifying `Enum` value serialization using `@JsonProperty`\n (requested by Allen C, allenchen1154@github)\n#679: Add `isEmpty()` implementation for `JsonNode` serializers\n#688: Provide a means for an ObjectMapper to discover mixin annotation classes on demand\n (requested by Laird N)\n#689: Add `ObjectMapper.setDefaultPrettyPrinter(PrettyPrinter)`\n (requested by derknorton@github)\n#696: Copy constructor does not preserve `_injectableValues`\n (reported by Charles A)\n#698: Add support for referential types (ReferenceType)\n#700: Cannot Change Default Abstract Type Mapper from LinkedHashMap\n (reported by wealdtech@github)\n#725: Auto-detect multi-argument constructor with implicit names if it is the only visible creator\n#727: Improve `ObjectWriter.forType()` to avoid forcing base type for container types\n#734: Add basic error-recovery for `ObjectReader.readValues()`\n#737: Add support for writing raw values in TokenBuffer\n (suggested by Guillaume S, gsmet@github)\n#740: Ensure proper `null` (as empty) handling for `AtomicReference`\n#741: Pass `DeserializationContext' argument for `JsonDeserializer` methods \"getNullValue()\"\n and \"getEmptyValue()\"\n#743: Add `RawValue` helper type, for piping raw values through `TokenBuffer`\n#756: Disabling SerializationFeature.FAIL_ON_EMPTY_BEANS does not affect `canSerialize()`\n (reported by nickwongdev@github)\n#762: Add `ObjectWriter.withoutRootName()`, `ObjectReader.withoutRootName()`\n#765: `SimpleType.withStaticTyping()` impl incorrect\n#769: Fix `JacksonAnnotationIntrospector.findDeserializer` to return `Object` (as per\n  `AnnotationIntrospector`); similarly for other `findXxx(De)Serializer(...)` methods\n#777: Allow missing build method if its name is empty (\"\")\n (suggested by galdosd@github)\n#781: Support handling of `@JsonProperty.required` for Creator methods\n#787: Add `ObjectMapper setFilterProvider(FilterProvider)` to allow chaining\n (suggested by rgoldberg@githin)\n#790: Add `JsonNode.equals(Comparator<JsonNode>, JsonNode)` to support\n  configurable/external equality comparison\n#794: Add `SerializationFeature.WRITE_DATES_WITH_ZONE_ID` to allow inclusion/exclusion of\n  timezone id for date/time values (as opposed to timezone offset)\n#795: Converter annotation not honored for abstract types\n (reported by myrosia@github)\n#797: `JsonNodeFactory` method `numberNode(long)` produces `IntNode` for small numbers\n#810: Force value coercion for `java.util.Properties`, so that values are `String`s\n#811: Add new option, `JsonInclude.Include.NON_ABSENT` (to support exclusion of\n  JDK8/Guava Optionals)\n#812: Java 8 breaks Class-value annotation properties, wrt generics: need to work around\n#813: Add support for new property of `@JsonProperty.access` to support\n  read-only/write-only use cases\n#820: Add new method for `ObjectReader`, to bind from JSON Pointer position\n (contributed by Jerry Y, islanderman@github)\n#824: Contextual `TimeZone` changes don't take effect wrt `java.util.Date`,\n  `java.util.Calendar` serialization\n#826: Replaced synchronized HashMap with ConcurrentHashMap in TypeDeserializerBase._findDeserializer\n (contributed by Lars P)\n#827: Fix for polymorphic custom map key serializer\n (reported by mjr6140@gitgub)\n#828: Respect DeserializationFeatures.WRAP_EXCEPTIONS in CollectionDeserializer\n (contributed by Steve G, thezerobit@github)\n#840: Change semantics of `@JsonPropertyOrder(alphabetic)` to only count `true` value\n#848: Custom serializer not used if POJO has `@JsonValue`\n#849: Possible problem with `NON_EMPTY` exclusion, `int`s, `Strings`\n#868: Annotations are lost in the case of duplicate methods\n- Remove old cglib compatibility tests; cause problems in Eclipse\n- Add `withFilterId()` method in `JsonSerializer` (demote from `BeanSerializer`)\n\n2.5.5 (07-Dec-2015)\n\n#844: Using JsonCreator still causes invalid path references in JsonMappingException\n (reported by Ian B)\n#852: Accept scientific number notation for quoted numbers too\n#878: serializeWithType on BeanSerializer does not setCurrentValue\n (reported by Chi K, chikim79@github)\n\n2.5.4 (09-Jun-2015)\n\n#676: Deserialization of class with generic collection inside depends on\n  how is was deserialized first time\n (reported by lunaticare@github)\n#771: Annotation bundles ignored when added to Mixin\n (reported by Andrew D)\n#774: NPE from SqlDateSerializer as _useTimestamp is not checked for being null\n (reported by mrowkow@github)\n#785: Add handlings for classes which are available in `Thread.currentThread().getContextClassLoader()`\n (contributed by Charles A)\n#792: Ensure Constructor Parameter annotations are linked with those of Field, Getter, or Setter\n#793: `ObjectMapper.readTree()` does not work with defaultTyping enabled\n (reported by gracefulgopher@github)\n#801: Using `@JsonCreator` cause generating invalid path reference in `JsonMappingException`\n (contributed by Kamil B)\n#815: Presence of PropertyNamingStrategy Makes Deserialization fail\n#816: Allow date-only ISO strings to have no time zone\n (contributed by Andrew G)\n- Fix handling of Enums wrt JSON Schema, when 'toString()' used for serialization\n\n2.5.3 (24-Apr-2015)\n\n#731: XmlAdapter result marshaling error in case of ValueType=Object\n (reported, debugged by Dmitry S)\n#742: Allow deserialization of `null` Object Id (missing already allowed)\n#744: Custom deserializer with parent object update failing\n (reported by migel@github)\n#745: EnumDeserializer.deserializerForCreator fails when used to deserialize a Map key\n (contributed by John M)\n#761: Builder deserializer: in-compatible type exception when return type is super type\n (contributed by Alexey G)\n#766: Fix Infinite recursion (StackOverflowError) when serializing a SOAP object\n (contributed by Alain G)\n\n2.5.2 (29-Mar-2015)\n\n#609: Problem resolving locally declared generic type\n (repoted by Hal H)\n#691: NullSerializer for MapProperty failing when using polymorphic handling\n (reported by Antibrumm@github)\n#703: Multiple calls to ObjectMapper#canSerialize(Object.class) returns different values\n (reported by flexfrank@github)\n#705: JsonAnyGetter doesn't work with JsonSerialize (except with keyUsing)\n (reported by natnan@github)\n#728: TypeFactory#_fromVariable returns unknownType() even though it has enough information\n  to provide a more specific type\n (reported by jkochaniak@github)\n#733: MappingIterator should move past errors or not return hasNext() == true\n (reported by Lorrin N, lorrin@github)\n#738: @JsonTypeInfo non-deterministically ignored in 2.5.1 (concurrency issue)\n (reported by Dylan S, dylanscott@github)\n- Improvement to handling of custom `ValueInstantiator` for delegating mode; no more NPE\n  if `getDelegateCreator()` returns null\n- Refactor `TypedKey` into separate util class\n\n2.5.1 (06-Feb-2015)\n\n#667: Problem with bogus conflict between single-arg-String vs `CharSequence` constructor\n#669: JSOG usage of @JsonTypeInfo and @JsonIdentityInfo(generator=JSOGGenerator.class) fails\n (reported by ericali78@github)\n#671: Adding `java.util.Currency` deserialization support for maps\n (contributed by Alexandre S-C)\n#674: Spring CGLIB proxies not handled as intended\n (reported by Zoltan F)\n#682: Class<?>-valued Map keys not serialized properly\n (reported by Ludevik@github)\n#684: FAIL_ON_NUMBERS_FOR_ENUMS does not fail when integer value is quoted\n (reported by kllp@github)\n#696: Copy constructor does not preserve `_injectableValues`\n (reported by Charles A)\n- Add a work-around in `ISO8601DateFormat` to allow omission of ':' from timezone\n- Bit more work to complete #633\n\n2.5.0 (01-Jan-2015)\n\n#47: Support `@JsonValue` for (Map) key serialization \n#113: Problem deserializing polymorphic types with @JsonCreator\n#165: Add `DeserializationContext.getContextualType()` to let deserializer\n  known the expected type.\n#299: Add `DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS` to allow missing\n  Object Ids (as global default)\n#408: External type id does not allow use of 'visible=true'\n#421: @JsonCreator not used in case of multiple creators with parameter names\n (reported by Lovro P, lpandzic@github)\n#427: Make array and Collection serializers call `JsonGenerator.writeStartArray(int)`\n#521: Keep bundle annotations, prevent problems with recursive annotation types\n (reported by tea-dragon@github)\n#527: Add support for `@JsonInclude(content=Include.NON_NULL)` (and others) for Maps\n#528: Add support for `JsonType.As.EXISTING_PROPERTY`\n (reported by heapifyman@github; implemented by fleebytes@github)\n#539: Problem with post-procesing of \"empty bean\" serializer; was not calling\n  'BeanSerializerModifier.modifySerializer()` for empty beans\n (reported by Fabien R, fabienrenaud@github)\n#540: Support deserializing `[]` as null or empty collection when the java type\n  is a not an object, `DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT`\n (requested by Fabien R, fabienrenaud@github)\n#543: Problem resolving self-referential recursive types\n (reported by ahgittin@github)\n#550: Minor optimization: prune introspection of \"well-known\" JDK types\n#552: Improved handling for ISO-8601 (date) format\n (contributed by Jerome G, geronimo-iia@github)\n#559: Add `getDateFormat()`, `getPropertyNamingStrategy()` in `ObjectMapper`\n#560: @JsonCreator to deserialize BigInteger to Enum\n (requested by gisupp@github)\n#565: Add support for handling `Map.Entry`\n#566: Add support for case-insensitive deserialization (`MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES`)\n (contributed by Michael R)\n#571: Add support in ObjectMapper for custom `ObjectReader`, `ObjectWriter` (sub-classes)\n#572: Override default serialization of Enums\n (requested by herau@github)\n#576: Add fluent API for adding mixins\n (contributed by Adam S, adstro@github)\n#594: `@JsonValue` on enum not used when enum value is a Map key\n (reported by chrylis@github)\n#596: Add support for `@JsonProperty.defaultValue`, exposed via `BeanProperty.getMetadata().getDefaultValue()`\n#597: Improve error messaging for cases where JSON Creator returns null (which\n  is illegal)\n (contributed by Aurelien L)\n#599: Add a simple mechanism for avoiding multiple registrations of the same module\n#607: Allow (re)config of `JsonParser.Feature`s via `ObjectReader`\n#608: Allow (re)config of `JsonGenerator.Feature`s via `ObjectWriter`\n#614: Add a mechanism for using `@JsonCreator.mode` for resolving possible ambiguity between\n  delegating- and property-based creators\n#616: Add `SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS`\n#622: Support for non-scalar ObjectId Reference deserialiazation (like JSOG)\n#623: Add `StdNodeBasedDeserializer`\n#630: Add `KeyDeserializer` for `Class`\n#631: Update `current value` of `JsonParser`, `JsonGenerator` from standard serializers,\n deserializers\n (suggested by Antibrumm@github)\n#633: Allow returning null value from IdResolver to make type information optional\n (requested by Antibrumm@github)\n#634: Add `typeFromId(DatabindContext,String)` in `TypeIdDeserializer`\n#636: `ClassNotFoundException` for classes not (yet) needed during serialization\n (contributed by mspiegel@github)\n#638: Add annotation-based method(s) for injecting properties during serialization\n (using @JsonAppend, VirtualBeanPropertyWriter)\n#647: Deserialization fails when @JsonUnwrapped property contains an object with same property name\n (reported by Konstantin L)\n#653: Jackson doesn't follow JavaBean naming convention (added `MapperFeature.USE_STD_BEAN_NAMING`)\n#654: Add support for (re)configuring `JsonGenerator.setRootValueSeparator()` via `ObjectWriter`\n#655: Add `ObjectWriter.writeValues()` for writing value sequences\n#660: `@JsonCreator`-annotated factory method is ignored if constructor exists\n- Allow use of `Shape.ARRAY` for Enums, as an alias to 'use index'\n- Start using `JsonGenerator.writeStartArray(int)` to help data formats\n  that benefit from knowing number of elements in arrays (and would otherwise\n  need to buffer values to know length)\n- Added new overload for `JsonSerializer.isEmpty()`, to eventually solve #588\n- Improve error messaging (related to [jaxb-annotations#38]) to include known subtype ids.\n\n2.4.6 (23-Apr-2015)\n\n#735: (complete fix) @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n (reported by blackfyre512@github) (regression due to #604)\n$744: Custom deserializer with parent object update fails\n\n2.4.5.1 (26-Mar-2015)\n\nSpecial one-off \"micro patch\" for:\n\n#706: Add support for `@JsonUnwrapped` via JSON Schema module\n#707: Error in getting string representation of an ObjectNode with a float number value\n (reported by @navidqar)\n#735: (partial) @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n\n2.4.5 (13-Jan-2015)\n\n#635: Reduce cachability of `Map` deserializers, to avoid problems with per-property config changes\n    (regression due to #604)\n#656: `defaultImpl` configuration is ignored for `WRAPPER_OBJECT`\n- Solve potential cyclic-resolution problem for `UntypedObjectDeserializer`\n\n2.4.4 (24-Nov-2014)\n\n(jackson-core)#158: Setter confusion on assignable types\n (reported by tsquared2763@github)\n#245: Calls to ObjectMapper.addMixInAnnotations() on an instance returned by ObjectMapper.copy()\n don't work\n (reported by Erik D)\n#580: delegate deserializers choke on a (single) abstract/polymorphic parameter\n (reported by Ian B, tea-dragon@github)\n#590: Binding invalid Currency gives nonsense at end of the message\n (reported by Jerbell@github)\n#592: Wrong `TokenBuffer` delegate deserialization using `@JsonCreator`\n (reported by Eugene L)\n#601: ClassCastException for a custom serializer for enum key in `EnumMap`\n (reported by Benson M)\n#604: `Map` deserializers not being cached, causing performance problems\n#610: Fix forward reference in hierarchies\n (contributed by zeito@github)\n#619: Off by one error in AnnotatedWithParams\n (reported by stevetodd@github)\n- Minor fix to `EnumSerializer` regarding detection \"serialize using index\"\n- Minor fix to number serializers, to call proper callback for schema generation\n\n2.4.3 (02-Oct-2014)\n\n#496: Wrong result with `new TextNode(\"false\").asBoolean(true)`\n (reported by Ivar R, ivarru@github)\n#511: DeserializationFeature.FAIL_ON_INVALID_SUBTYPE does not work\n (reported by sbelikov@github)\n#523: MapDeserializer and friends do not report the field/key name for mapping exceptions\n (reported by Ian B, tea-dragon@github)\n#524: @JsonIdentityReference(alwaysAsId = true) Custom resolver is reset to SimpleObjectIdResolver\n (reported by pkokorev@github)\n#541: @JsonProperty in @JsonCreator is conflicting with POJOs getters/attributes\n (reported by fabienrenaud@github)\n#543: Problem resolving self-referential generic types\n#570: Add Support for Parsing All Compliant ISO-8601 Date Formats\n (requested by pfconrey@github)\n- Fixed a problem with `acceptJsonFormatVisitor` with Collection/array types that\n  are marked with `@JsonValue`; could cause NPE in JSON Schema generator module.\n\n2.4.2 (14-Aug-2014)\n\n#515: Mixin annotations lost when using a mixin class hierarchy with non-mixin interfaces\n (reported by 'stevebread@github')\n- Fixed a problem related to [jackson-dataformat-smile#19].\n\n2.4.1.2 (12-Jul-2014)\n\nSpecial one-off \"micro patch\" for:\n\n#503: Concurrency issue inside com.fasterxml.jackson.databind.util.LRUMap.get(Object)\n (reported by fjtc@github)\n\n2.4.1.1 (18-Jun-2014)\n\nSpecial one-off \"micro patch\" for:\n\n#491: Temporary work-around for issue #490 (full fix for 2.5 needs to be\n  in `jackson-annotations`)\n#506: Index is never set for Collection and Array in InvalidFormatException.Reference\n (reported by Fabrice D, fabdouglas@github)\n- Fixed a problem related to [jackson-dataformat-smile#19].\n\n2.4.1 (17-Jun-2014)\n\n#479: NPE on trying to deserialize a `String[]` that contains null\n (reported by huxi@github)\n#482: Make date parsing error behavior consistent with JDK\n (suggested by Steve S, sanbeg@github)\n#489 (partial): TypeFactory cache prevents garbage collection of custom ClassLoader\n (reported by sftwrengnr@github)\n\n2.4.0 (02-Jun-2014)\n\n#81: Allow use of @JsonUnwrapped with typed (@JsonTypeInfo) classes, provided\n  that (new) feature `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS`\n  is disabled\n (constributed by Ben F, UnquietCode@github)\n#88: Prevent use of type information for `JsonNode` via default typing\n (reported by electricmonk@github)\n#149: Allow use of \"stringified\" indexes for Enum values\n (requested by chenboxiang@github)\n#176: Allow use external Object Id resolver (to use with @JsonIdentityInfo etc)\n (implemented by Pascal G)\n#193: Conflicting property name definitions\n (reported by Stuart J, sgjohnston@github)\n#323: Serialization of the field with deserialization config\n (reported by metanet@github)\n#327: Should not consider explicitly differing renames a fail, as long as all are explicit\n#335: Allow use of `@JsonPropertyOrder(alphabetic=true)` for Map properties\n#351: ObjectId does not properly handle forward references during deserialization\n (contributed by pgelinas)\n#352 Add `ObjectMapper.setConfig()` for overriding `SerializationConfig`/`DeserializationConfig`\n#353: Problems with polymorphic types, `JsonNode` (related to #88)\n (reported by cemo@github)\n#359: Converted object not using explicitly annotated serializer\n (reported by Florian S [fschopp@github])\n#369: Incorrect comparison for renaming in `POJOPropertyBuilder`\n#375: Add `readValue()`/`readPropertyValue()` methods in `DeserializationContext`\n#376: Add support for `@JsonFormat(shape=STRING)` for number serializers\n#381: Allow inlining/unwrapping of value from single-component JSON array\n (contributed by yinzara@github)\n#390: Change order in which managed/back references are resolved (now back-ref\n first, then forward)\n (requested by zAlbee@github)\n#407: Properly use null handlers for value types when serializer Collection\n and array types\n (contributed by Will P)\n#425: Add support for using `Void.class` as \"no class\", instead of `NoClass.class`\n#428: `PropertyNamingStrategy` will rename even explicit name from `@JsonProperty`\n (reported by turskip@github)\n#435: Performance bottleneck in TypeFactory._fromClass\n (reported by Sean D, sdonovanuk@github)\n#434: Ensure that DecimalNodes with mathematically equal values are equal\n (contributed by Francis G)\n#435: Performance bottleneck in TypeFactory._fromClass\n (reported by sdonovanuk@github)\n#438: Add support for accessing `@JsonProperty(index=N)` annotations\n#442: Make `@JsonUnwrapped` indicate property inclusion\n (suggested by Ben F)\n#447: ArrayNode#addAll should accept Collection<? extends JsonNode>\n (suggested by alias@github)\n#461: Add new standard naming strategy, `PropertyNamingStrategy.LowerCaseStrategy`\n#463: Add 'JsonNode.asText(String defaultValue)`\n (suggested by Chris C)\n#464: Include `JsonLocation` in more mapping exceptions\n (contributed by Andy C (q3aiml@github))\n#465: Make it easier to support serialization of custom subtypes of `Number`\n#467: Unwanted POJO's embedded in tree via serialization to tree\n (reported by Benson M)\n- Slightly improve `SqlDateSerializer` to support `@JsonFormat`\n- Improve handling of native type ids (YAML, CBOR) to use non-native type ids\n  as fallback\n\n2.3.5 (13-Jan-2015)\n\n#496: Wrong result for TextNode(\"false\").asBoolean(true)\n (reported by Ivar R, ivarru@github)\n#543: Problems resolving self-referential generic types.\n#656: defaultImpl configuration is ignored for WRAPPER_OBJECT\n\n2.3.4 (17-Jul-2014)\n\n#459: BeanDeserializerBuilder copy constructor not copying `_injectables`\n#462: Annotation-provided Deserializers are not contextualized inside CreatorProperties\n (reported by aarondav@github)\n\n2.3.3 (10-Apr-2014)\n\n#420: Remove 'final' modifier from `BeanDeserializerBase.deserializeWithType`\n (requested by Ghoughpteighbteau@github)\n#422: Allow use of \"True\" and \"False\" as aliases for booleans when coercing from\n  JSON String\n#423: Fix `CalendarSerializer` to work with custom format\n (reported by sergeymetallic@github)\n#433: `ObjectMapper`'s `.valueToTree()` wraps `JsonSerializable` objects into a POJONode\n (reported by Francis G)\n- Fix null-handling for `CollectionSerializer`\n\n2.3.2 (01-Mar-2014)\n\n#378: Fix a problem with custom enum deserializer construction\n (reported by BokoEnos@github)\n#379: Fix a problem with (re)naming of Creator properties; needed to make\n Paranamer module work with NamingStrategy.\n (reported by Chris P, cpilsworth@github)\n#398: Should deserialize empty (not null) URI from empty String\n (reported by pgieser@github)\n#406: @JsonTypeIdResolver not working with external type ids\n (reported by Martin T)\n#411: NumberDeserializers throws exception with NaN and +/- Infinity\n (reported by clarkbreyman@github)\n#412: ObjectMapper.writerWithType() does not change root name being used\n (repoted by jhalterman@github)\n- Added `BeanSerializerBase._serializeObjectId()` needed by modules that\n  override standard BeanSerializer; specifically, XML module.\n\n2.3.1 (28-Dec-2013)\n\n#346: Fix problem deserializing `ObjectNode`, with @JsonCreator, empty\n  JSON Object\n (reported by gaff78@github)\n#358: `IterableSerializer` ignoring annotated content serializer\n (reported by Florian S)\n#361: Reduce sync overhead for SerializerCache by using volatile, double-locking\n (contributed by stuartwdouglas@github)\n#362: UUID output as Base64 String with ObjectMapper.convertValue()\n (reported by jknack@github)\n#367: Make `TypeNameIdResolver` call `TypeResolver` for resolving base type\n (suggested by Ben F)\n#370: Fail to add Object Id for POJO with no properties\n (reported by jh3141@github)\n- Fix for [jackson-module-afterburner#38]: need to remove @JacksonStdImpl from\n  `RawSerializer`, to avoid accidental removal of proper handling.\n\n2.3.0 (13-Nov-2013)\n\n#48: Add support for `InetSocketAddress`\n (contributed by Nick T)\n#152: Add support for traversing `JsonNode` with (new!) `JsonPointer` implementation\n (suggested by fge@github)\n#208: Accept \"fromString()\" as an implicit Creator (factory) method (alias for \"valueOf()\")\n (requested by David P)\n#215: Allow registering custom `CharacterEscapes` to use for serialization,\n via `ObjectWriter.with(CharacterEscapes)` (and `ObjectMapper.writer(CharacterEscapes)`)\n#227: Allow \"generic\" Enum serializers, deserializers, via `SimpleModule`\n#234: Incorrect type information for deeply nested Maps\n (reported by Andrei P)\n#237: Add `DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY` to optionally\n  throw `JsonMappingException` on duplicate keys, tree model (`JsonNode`)\n#238: Allow existence of overlapping getter, is-getter (choose 'regular' getter)\n#239: Support `ByteBuffer`\n (suggested by mckamey@github)\n#240: Make sure `@JsonSerialize.include` does not accidentally override\n  class inclusion settings\n (requested by thierryhenrio@github)\n#253: `DelegatingDeserializer` causes problems for Managed/BackReferences\n (reported by bfelaco@github)\n#257: Make `UntypedObjectDeserializer` support overides for `List`, `Map` etc\n#268: Add new variant of `ObjectMapper.canSerialize()` that can return `Throwable`\n that caused false to be returned (if any)\n#269: Add support for new `@JsonPropertyDescription` via `AnnotationIntrospector`\n as well as `BeanProperty.getMedata().getDescription()`\n#270: Add `SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID` to allow use of equality\n (instead of identity) for figuring out when to use Object Id\n (requested by beku8@github)\n#271: Support handling of `@JsonUnwrapped` for in-built JSON Schema generation\n#277: Make `TokenBuffer` support new native type and object ids\n#302: Add `setNamingStrategy` in `Module.SetupContext`\n (suggested by Miguel C)\n#305: Add support for accessing `TypeFactory` via `TypeIdResolverBase`\n (not yet via `TypeIdResolver` interface), other configuration\n#306: Allow use of `@JsonFilter` for properties, not just classes \n#307: Allow use of `@JsonFilter` for Maps in addition to POJOs\n#308: Improve serialization and deserialization speed of `java.util.UUID` by 4x\n (suggested by David P)\n#310: Improve `java.util.UUID` serialization with binary codecs, to use \"raw\" form.\n#311: Make sure that \"creator properties\" are alphabetically ordered too, if\n  so requested.\n#315: Allow per-property definition of null serializer to use, using\n new `@JsonSerialize(nullsUsing=xxx)` annotation property\n#317: Fix `JsonNode` support for nulls bound to `ObjectNode`, `ArrayNode`\n (contributed by Seth P)\n#318: Problems with `ObjectMapper.updateValue()`, creator property-backed accessors\n#319: Add support for per-call (\"contextual\") attributes, with defaulting,\n to allow keeping track of state during (de)serialization\n#324: Make sure to throw `JsonMappingException` from `EnumDeserializer` creator,\n  not `IllegalArgumentException`\n (reported by beverku@github)\n#326: Support `@JsonFilter` for \"any getter\" properties\n#334: Make `ArrayNode`, `ObjectNode` non-final again\n#337: `AnySetter` does not support polymorphic types\n (reported by askvortsov@github)\n#340: AtomicReference not working with polymorphic types\n#342: Add `DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES` to make `ObjectMapper`\n  throw exception when encountering explicitly ignored properties\n (requested by Ruslan M)\n[JACKSON-890]: Support managed/back-references for polymorphic (abstract) types\n- Add 'BeanPropertyWriter.isUnwrapping()' for future needs (by Afterburner)\n- Add coercions from String \"null\" (as if null token was parsed) for primitives/Wrappers.\n- Add `JsonDeserializer.handledType()`\n\n2.2.4 (10-Jun-2014)\n\n#292: Problems with abstract `Map`s, `Collection`s, polymorphic deserialization\n#324: EnumDeserializer should throw JsonMappingException, not IllegalArgumentException\n#346: Problems deserializing `ObjectNode` from empty JSON Object, with @JsonCreator\n\n2.2.3 (22-Aug-2013)\n\n#234: Problems with serializing types for deeply nested generic Maps, default typing \n#251: SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN ignored with JsonNode\n  serialization\n (reported by fge@github)\n#259: Fix a problem with JSON Schema generation for `@JsonValue`\n (reported by Lior L)\n#267: Handle negative, stringified timestamps\n (reported by Drecth@github)\n#281: Make `NullNode` use configured null-value serializer\n#287: Fix problems with converters, Maps with Object values\n (reported by antubis@github)\n#288: Fix problem with serialization converters assigned with annotations\n (reported by cemo@github)\n\n2.2.2 (26-May-2013)\n\n#216: Problems with Android, 1.6-only types\n#217: JsonProcessingExceptions not all wrapped as expected\n (reported by karldmoore@github)\n#220: ContainerNode missing 'createNumber(BigInteger)'\n (reported by Pascal G)\n#223: Duplicated nulls with @JsonFormat(shape=Shape.ARRAY)\n (reported by lukegh@github)\n#226: Field mapping fail on deserialization to common referenced object when\n  @JsonUnwrapped is used\n (reported by ikvia@github)\n#232: Converting bound BigDecimal value to tree fails with WRITE_BIGDECIMAL_AS_PLAIN\n (reported by celkings@github)\n- Minor fix to handle primitive types for key deserializer lookups\n- Add convenience method `MappingIterator.getCurrentLocation()`\n (suggested by Tomdz@github)\n\n2.2.1 (03-May-2013)\n\n#214: Problem with LICENSE, NOTICE, Android packaging\n (reported by thierryd@github)\n\n2.2.0 (22-Apr-2013)\n\nFixes:\n\n#23: Fixing typing of root-level collections\n#118: JsonTypeInfo.as.EXTERNAL_PROPERTY not working correctly\n with missing type id, scalar types\n#130: TimeZone not set for GregorianCalendar, even if configured\n#144: MissingNode.isValueNode() should return 'false'\n (reported by 'fge@github')\n#146: Creator properties were not being renamed as expected\n (contributed by Christoper C)\n#188: Problem with ObjectId serialization, 'alwaysAsId' references\n\nImprovements:\n\n#116: JavaType implements `java.lang.reflect.Type` (as does `TypeReference`)\n#147: Defer reporting of problems with missing creator parameters\n (contributed by Christoper C)\n#155: Make `ObjectNode` and `ArrayNode` final (other node types already were)\n (requested by fge@github)\n#161: Add deserializer for java.util.concurrent.ArrayBlockingQueue\n#173: Add 'JsonNode.traverse(ObjectCodec)' for convenience\n#181: Improve error reporting for missing '_valueDeserializer'\n#194: Add `FloatNode` type in tree model (JsonNode)\n (requested by msteiger@github)\n#199: Allow deserializing `Iterable` instances (as basic `Collection`s)\n (requested by electrum@github)\n#206: Make 'ObjectMapper.createDeserializationContext()' overridable\n (requested by noter@github)\n#207: Add explicit support for `short` datatypes, for tree model\n (contributed by msteiger@github)\n\nNew features:\n\n#120: Extend BeanDeserializerModifier to work with non-POJO deserializers\n#121: Extend BeanSerializerModifier to work with non-POJO serializers\n#124: Add support for serialization converters (@JsonSerializer(converter=...))\n#124: Add support for deserialization converters (@JsonDeserializer(converter=...))\n#140: Add 'SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN' to allow forcing\n  of non-scientific notation when serializing BigDecimals.\n (suggested by phedny@github)\n#148: Add 'DeserializationFeature.FAIL_ON_INVALID_SUBTYPE`, which allows mapping\n  entries with missing or invalid type id into null references (instead of failing).\n  Also allows use of '@JsonTypeInfo.defaultImpl = NoClass.class' as alternative.\n#159: Add more accessors in 'MappingIterator': getParser(), getParserSchema(),\n  readAll()\n (suggested by Tom D)\n#190: Add 'MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS' (default: true) for\n pruning out final fields (to avoid using as mutators)\n (requested by Eric T)\n#195: Add 'MapperFeature.INFER_PROPERTY_MUTATORS' (default: enabled) for finer\n  control of what mutators are auto-detected.\n (requested by Dain S)\n#198: Add SPI metadata, handling in ObjectMapper (findModules()), for\n  automatic registration of auto-detected extension modules\n (suggested by 'beamerblvd@github')\n#203: Added new features to support advanced date/time handling:\n  - SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS\n  - DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS\n  - DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE\n\nOther:\n\n#126: Update JDK baseline to 1.6\n* API under 'com.fasterxml.jackson.databind.jsonFormatVisitors' changed significantly\n  based on experiences with external JSON Schema generator.\n* Version information accessed via code-generated access class, instead of reading\n  VERSION.txt\n* Added 2 methods in Converter interface: getInputType(), getOutputType(),\n  to allow programmatic overrides (needed by JAXB annotation module)\n\n2.1.4 (26-Feb-2013)\n\n* [JACKSON-887]: StackOverflow with parameterized sub-class field\n (reported by Alexander M)\n* [#130]: TimeZone not set for GregorianCalendar, when deserializing\n* [#157]: NPE when registering module twice\n* [#162]: JsonNodeFactory: work around an old bug with BigDecimal and zero\n (submitted by fge@github)\n* [#166]: Incorrect optimization for `ObjectMapper.convertValue(Class)`\n (reported by Eric T)\n* [#167]: Problems with @JsonValue, polymorphic types (regression from 1.x)\n (reported by Eric T)\n* [#170]: Problems deserializing `java.io.File` if creator auto-discovery disabled\n (reported by Eric T)\n* [#175]: NPE for JsonMappingException, if no path is specified\n (reported by bramp@github)\n\n2.1.3 (19-Jan-2013)\n\n* [Issue#141]: ACCEPT_EMPTY_STRING_AS_NULL_OBJECT not working for enums\n* [Issue#142]: Serialization of class containing EnumMap with polymorphic enum\n  fails to generate class type data\n (reported by kidavis4@github)\n\n2.1.2 (04-Dec-2012)\n\n* [Issue#106]: NPE in ObjectArraySerializer.createContextual(...)\n* [Issue#117]: HandlerInstantiator defaulting not working\n (reported by Alexander B)\n* [Issue#118]: Problems with JsonTypeInfo.As.EXTERNAL_PROPERTY, scalar values\n (reported by Adva11@github)\n* [Issue#119]: Problems with @JsonValue, JsonTypeInfo.As.EXTERNAL_PROPERTY\n (reported by Adva11@github)\n* [Issue#122]: ObjectMapper.copy() was not copying underlying mix-in map\n (reported by rzlo@github)\n\n2.1.1 (11-Nov-2012)\n\nFixes:\n\n* [JACKSON-875]: Enum values not found if Feature.USE_ANNOTATIONS disabled\n (reported by Laurent P)\n* [Issue#93]: ObjectNode.setAll() broken; would not add anything for\n  empty ObjectNodes.\n (reported by Francis G)\n* Making things implement java.io.Serializable:\n  - Issues: #94, #99, #100, #102\n    (reported by Sean B)\n* [Issue#96]: Problem with JsonTypeInfo.As.EXTERNAL_PROPERTY, defaultImpl\n (reported by Adva11@github)\n\n2.1.0 (08-Oct-2012)\n\n  New minor version for 2.x series. Major improvements in multiple areas,\n  including:\n\n  - Dataformat auto-detection\n  - More `@JsonFormat.shape` variant to serialize Collections as\n    JSON Objects, POJOs as JSON Arrays (csv-like).\n  - Much more configuration accessible via ObjectReader, ObjectWriter\n  - New mechanism for JSON Schema generation, other uses (in future)\n\nFixes:\n\n* [JACKSON-830]/[Issue#19]: Change OSGi bundle name to be fully-qualified\n* ]JACKSON-847]: Make @JsonIdentityInfo work with property-based creator\n* [JACKSON-851]: State corruption with ObjectWriter, DefaultPrettyPrinter\n (reported by Duncan A)\n* [Issue#75]: Too aggressive KeySerializer caching\n* Minor fix wrt [Issue#11], coercion needed extra checks\n\nImprovements:\n\n* [JACKSON-758]: Remove 'IOException' from throws clauses of \"writeValueAsString\"\n  and \"writeValueAsBytes\" of ObjectMapper/ObjectWriter\n (suggested by G-T Chen)\n* [JACKSON-839]: Allow \"upgrade\" of integer number types for\n  UntypedObjectDeserializer, even with default typing enabled.\n* [JACKSON-850]: Allow use of zero-arg factory methods as \"default creator\"\n  (suggested by Razvan D)\n* [Issue#9]: Implement 'required' JSON Schema attribute for bean properties\n* [Issue#20]: Add new exception type, InvalidFormatException (sub-type of\n  JsonMappingException) to indicate data format problems\n (suggested by HolySamosa@github)\n* [Issue#30]: ObjectReader and ObjectWriter now try to pre-fetch root\n  (de)serializer if possible; minor performance improvement (2% for small POJOs).\n* [Issue#33]: Simplified/clarified definition of 'ObjectReader.readValues()';\n  minor change in behavior for JSON Array \"wrapped\" sequences\n* [Issue#60]: Add 'JsonNode.hasNonNull(...)' method(s)\n (suggested by Jeff S on mailing list) \n* [Issue#64]: Add new \"standard\" PropertyNamingStrategy, PascalCaseStrategy\n  (PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)\n (contributed by Sean B)\n* [Issue#65]: Add getters to `ObjectMapper`, DeserializationContext/-Factory.\n (contributed by Dmitry K)\n* [Issue#69]: Add `PropertyName` abstraction, new methods in AnnotationIntrospector\n* [Issue#80]: Make `DecimalNode` normalize input, to make \"1.0\" and \"1.00\"equal\n (reported by fge@github)\n\nNew features:\n\n* [Issue#15]: Support data format auto-detection via ObjectReader (added\n  'withFormatDetection(...)' fluent factories)\n* [Issue#21]: Add 'ObjectNode.set(...)' method (and related) to improve\n  chaining, semantic consistency of Tree Model API\n (suggested by fge@Github)\n* [Issue#22]: Add 'ObjectMapper.setAnnotationIntrospectors()' which allows\n  defining different introspectors for serialization, deserialization\n* [Issue#24]: Allow serialization of Enums as JSON Objects\n (suggested by rveloso@github)\n* [Issue#28]: Add 'ObjectMapper.copy()', to create non-linked copy of\n  mapper, with same configuration settings\n* [Issue#29]: Allow serializing, deserializing POJOs as JSON Arrays\n  by using `@JsonFormat(shape=Shape.ARRAY)`\n* [Issue#40]: Allow serialization of Collections as JSON Objects\n  (and deserialization from)\n (suggested by 'rveloso@github')\n* [Issue#42]: Allow specifying Base64 variant to use for Base64-encoded data\n  using ObjectReader.with(Base64Variant), ObjectWriter.with(Base64Variant).\n (suggested by 'mpfau@github')\n* [Issue#45]: Add '@JsonNaming' annotation to define per-class PropertyNamingStrategy\n (suggested by Mark W)\n* [Pull#58]: Make 'MappingIterator' implement 'Closable'\n (contributed by Pascal G)\n* [Issue#72]: Add 'MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME' to use\n  wrapper name annotations for renaming properties\n* [Issue#87]: Add 'StdDelegatingSerializer', 'StdDelegatingDeserializer' to\n  simplify writing of two-step handlers\n* (issue #4 of jackson-annotations): Add `@JsonIdentityReference(alwaysAsId=true)`\n  to force ALL references to an object written as Object Id, even the first one.\n* Added 'ObjectReader#withHandler' to allow for reconfiguring deserialization\n  problem handler\n (suggested by 'electricmonk')\n\nOther changes:\n\n* New variant of AnnotationIntrospector.getFormat(), to support class\n  annotations\n* It is now possible to serialize instances of plain old Object, iff\n  'FAIL_ON_EMPTY_BEANS' is disabled.\n* Trying to remove reference to \"JSON\" in datatype conversion errors\n (since databinding is format-agnostic)\n\nINCOMPATIBILITIES: (rats!)\n\n* Note that [Issue#33] (see above) is, technically speaking, backwards\n  imcompatible change. It is estimated that it should NOT affect most\n  users, as changes are to edge cases (and undocumented ones at that).\n  However, it can potentially cause problems with upgrade.\n* Implementation of `JsonFormatVisitable` resulting in 2 new methods\n  being added in `BeanPropertyFilter` interface -- this is unfortunate,\n  but was required to support full traversability.\n\n2.0.4 (26-Jun-2012)\n\n* [Issue#6]: element count for PrettyPrinter, endObject wrong\n   (reported by \"thebluemountain\")\n* [JACKSON-838]: Utf8StreamParser._reportInvalidToken() skips letters\n    from reported token name\n   (reported by L\u00f3r\u00e1nt Pint\u00e9r)\n* [JACKSON-841] Data is doubled in SegmentedStringWriter output\n   (reported by Scott S)\n* [JACKSON-842] ArrayIndexOutOfBoundsException when skipping C-style comments\n   (reported by Sebastien R)\n\n2.0.3: no version 2.0.3 released -- only used for extension modules\n\n2.0.2 [14-May-2012]\n\nFixes:\n\n* [Issue#14]: Annotations were not included from parent classes of\n  mix-in classes\n (reported by @guillaup)\n* [JACKSON-824]: Combination of JSON Views, ObjectMapper.readerForUpdating()\n  was not working\n (reported by Nir S)\n(and all fixes from 1.9.7)\n\nImprovements:\n\n* [Issue#11]: Improve ObjectMapper.convertValue()/.treeToValue() to use\n  cast if possible\n\n2.0.1 [23-Apr-2012]\n\nFixes:\n\n* [JACKSON-827] Ensure core packages work on JDK 1.5\n (reported by Pascal g)\n* [JACKSON-829] Custom serializers not working for List<String> properties,\n  @JsonSerialize(contentUsing)\n (reported by James R)\n\nImprovements:\n\n* [Issue#5]: Add support for maps with java.util.Locale keys to the set of\n  StdKeyDeserializers\n (contributed by Ryan G)\n\n2.0.0 [25-Mar-2012]\n\nFixes:\n\n* [JACKSON-368]: Problems with managed references, abstract types\n* [JACKSON-711]: Delegating @JsonCreator did not work with Injectable values\n* [JACKSON-798]: Problem with external type id, creators\n  (reported by Casey L)\n(and all fixes up until and including 1.9.6)\n\nImprovements:\n\n* [JACKSON-546]: Indicate end-of-input with JsonMappingException instead\n  of EOFException, when there is no parsing exception\n* [JACKSON-664]: Reduce overhead of type resolution by adding caching\n  in TypeFactory\n* [JACKSON-690]: Pass DeserializationContext through ValueInstantiator\n* [JACKSON-695]: Add 'isEmpty(value)' in JsonSerializer to allow\n  customizing handling of serialization of empty values\n* [JACKSON-710]: 'ObjectMapper.convertValue()' should ignore root value\n  wrapping/unwrapping settings\n* [JACKSON-730] Split various features (JsonParser, JsonGenerator,\n  SerializationConfig, DeserializationConfig) into per-factory\n  features (MapperFeature, JsonFactory.Feature) an per\n  instance features (existing ones)\n* [JACKSON-732]: Allow 'AnnotationIntrospector.findContentDeserializer()'\n  (and similar) to return instance, not just Class<?> for instance\n (requested by James R)\n* [JACKSON-736]: Add (more) access to array, container and map serializers\n* [JACKSON-737]: Allow accessing of \"creator properties\" for BeanDeserializer\n* [JACKSON-748]: Add 'registerSubtypes' to 'Module.setupContext' (and SimpleModule)\n* [JACKSON-749]: Make @JsonValue work for Enum deserialization\n* [JACKSON-769]: ObjectNode/ArrayNode: change 'put', 'insert', 'add' to return\n  'this node' (unless already returning something)\n* [JACKSON-770]: Simplify method naming for JsonNode, drop unnecessary 'get' prefix\n  from methods like 'getTextValue()' (becomes 'textValue()')\n* [JACKSON-777]: Rename 'SerializationConfig.Feature' as 'SerializationFeature',\n  'DeserializationConfig.Feature' as 'DeserializationFeature'\n* [JACKSON-780]: MissingNode, NullNode should return 'defaultValue' from 'asXxx' methods,\n  (not 0 for numbers), as they are not numeric types\n* [JACKSON-787]: Allow use of @JsonIgnoreProperties for properties (fields, getters, setters)\n* [JACKSON-795]: @JsonValue was not working for Maps, Collections\n* [JACKSON-800]: Add 'Module.SetupContext#addDeserializationProblemHandler'\n (suggested by James R)\n\nNew features:\n\n* [JACKSON-107]: Add support for Object Identity (to handled cycles, shared refs),\n  with @JsonIdentityInfo\n* [JACKSON-435]: Allow per-property Date formatting using @JsonFormat.\n* [JACKSON-437]: Allow injecting of type id as POJO property, by setting\n  new '@JsonTypeInfo.visible' property to true.\n* [JACKSON-469]: Support \"Builder pattern\" for deserialiation; that is, allow\n  use of separate Builder object for data binding, creating actual value\n* [JACKSON-608]: Allow use of JSON Views for deserialization\n* [JACKSON-636]: Add 'SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS' to allow\n  forced sorting of Maps during serialization\n  (suggested by Joern H)\n* [JACKSON-669]: Allow prefix/suffix for @JsonUnwrapped properties\n (requested by Aner P)\n* [JACKSON-707]: Add 'JsonNode.deepCopy()', to create safe deep copies\n  of ObjectNodes, ArrayNodes.\n* [JACKSON-714]: Add general-purpose @JsonFormat annotation\n* [JACKSON-718]: Added 'JsonNode.canConvertToInt()', 'JsonNode.canConvertToLong()'\n* [JACKSON-747]: Allow changing of 'SerializationFeature' for ObjectWriter,\n  'DeserializationFeature' for ObjectReader.\n* [JACKSON-752]: Add @JsonInclude (replacement of @JsonSerialize.include)\n* [JACKSON-754]: Add @JacksonAnnotationsInside for creating \"annotation\n  bundles\" (also: AnnotationIntrospector.isAnnotationBundle())\n* [JACKSON-762]: Allow using @JsonTypeId to specify property to use as\n  type id, instead of using separate type id resolver.\n* [JACKSON-764]: Allow specifying \"root name\" to use for root wrapping\n  via ObjectReader, ObjectWriter.\n* [JACKSON-772]: Add 'JsonNode.withArray()' to use for traversing Array nodes.\n* [JACKSON-793]: Add support for configurable Locale, TimeZone to use\n  (via SerializationConfig, DeserializationConfig)\n* [JACKSON-805]: Add 'SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED'\n  to improve interoperability with BadgerFish/Jettison\n* [JACKSON-810]: Deserialization Feature: Allow unknown Enum values via\n  'DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL'\n  (suggested by Raymond R)\n* [JACKSON-813]: Add '@JsonSerializableSchema.id' attribute, to indicate\n  'id' value to add to generated JSON Schemas.\n\n[entries for versions 1.x and earlier not retained; refer to earlier releases)\n", "package com.fasterxml.jackson.databind;\n\nimport com.fasterxml.jackson.databind.cfg.ConfigFeature;\nimport com.fasterxml.jackson.databind.exc.InvalidNullException;\n\n/**\n * Enumeration that defines simple on/off features that affect\n * the way Java objects are deserialized from JSON\n *<p>\n * Note that features can be set both through\n * {@link ObjectMapper} (as sort of defaults) and through\n * {@link ObjectReader}.\n * In first case these defaults must follow \"config-then-use\" patterns\n * (i.e. defined once, not changed afterwards); all per-call\n * changes must be done using {@link ObjectReader}.\n *<p>\n * Note that features that do not indicate version of inclusion\n * were available in Jackson 2.0 (or earlier); only later additions\n * indicate version of inclusion.\n */\npublic enum DeserializationFeature implements ConfigFeature\n{\n    /*\n    /******************************************************\n    /* Value (mostly scalar) conversion features\n    /******************************************************\n     */\n\n    /**\n     * Feature that determines whether JSON floating point numbers\n     * are to be deserialized into {@link java.math.BigDecimal}s\n     * if only generic type description (either {@link Object} or\n     * {@link Number}, or within untyped {@link java.util.Map}\n     * or {@link java.util.Collection} context) is available.\n     * If enabled such values will be deserialized as {@link java.math.BigDecimal}s;\n     * if disabled, will be deserialized as {@link Double}s.\n     *<p>\n     * NOTE: one aspect of {@link java.math.BigDecimal} handling that may need\n     * configuring is whether trailing zeroes are trimmed:\n     * {@link com.fasterxml.jackson.databind.node.JsonNodeFactory} has\n     * {@link com.fasterxml.jackson.databind.node.JsonNodeFactory#withExactBigDecimals} for\n     * changing default behavior (default is for trailing zeroes to be trimmed).\n     *<p>\n     * Feature is disabled by default, meaning that \"untyped\" floating\n     * point numbers will by default be deserialized as {@link Double}s\n     * (choice is for performance reason -- BigDecimals are slower than\n     * Doubles).\n     */\n    USE_BIG_DECIMAL_FOR_FLOATS(false),\n\n    /**\n     * Feature that determines whether JSON integral (non-floating-point)\n     * numbers are to be deserialized into {@link java.math.BigInteger}s\n     * if only generic type description (either {@link Object} or\n     * {@link Number}, or within untyped {@link java.util.Map}\n     * or {@link java.util.Collection} context) is available.\n     * If enabled such values will be deserialized as\n     * {@link java.math.BigInteger}s;\n     * if disabled, will be deserialized as \"smallest\" available type,\n     * which is either {@link Integer}, {@link Long} or\n     * {@link java.math.BigInteger}, depending on number of digits.\n     * <p>\n     * Feature is disabled by default, meaning that \"untyped\" integral\n     * numbers will by default be deserialized using whatever\n     * is the most compact integral type, to optimize efficiency.\n     */\n    USE_BIG_INTEGER_FOR_INTS(false),\n\n    /**\n     * Feature that determines how \"small\" JSON integral (non-floating-point)\n     * numbers -- ones that fit in 32-bit signed integer (`int`) -- are bound\n     * when target type is loosely typed as {@link Object} or {@link Number}\n     * (or within untyped {@link java.util.Map} or {@link java.util.Collection} context).\n     * If enabled, such values will be deserialized as {@link java.lang.Long};\n     * if disabled, they will be deserialized as \"smallest\" available type,\n     * {@link Integer}.\n     *<p>\n     * Note: if {@link #USE_BIG_INTEGER_FOR_INTS} is enabled, it has precedence\n     * over this setting, forcing use of {@link java.math.BigInteger} for all\n     * integral values.\n     *<p>\n     * Feature is disabled by default, meaning that \"untyped\" integral\n     * numbers will by default be deserialized using {@link java.lang.Integer}\n     * if value fits.\n     * \n     * @since 2.6\n     */\n    USE_LONG_FOR_INTS(false),\n    \n    /**\n     * Feature that determines whether JSON Array is mapped to\n     * <code>Object[]</code> or {@code List<Object>} when binding\n     * \"untyped\" objects (ones with nominal type of <code>java.lang.Object</code>).\n     * If true, binds as <code>Object[]</code>; if false, as {@code List<Object>}.\n     *<p>\n     * Feature is disabled by default, meaning that JSON arrays are bound as\n     * {@link java.util.List}s.\n     */\n    USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n\n    /*\n    /******************************************************\n    /* Error handling features\n    /******************************************************\n     */\n\n    /**\n     * Feature that determines whether encountering of unknown\n     * properties (ones that do not map to a property, and there is\n     * no \"any setter\" or handler that can handle it)\n     * should result in a failure (by throwing a\n     * {@link JsonMappingException}) or not.\n     * This setting only takes effect after all other handling\n     * methods for unknown properties have been tried, and\n     * property remains unhandled.\n     *<p>\n     * Feature is enabled by default (meaning that a\n     * {@link JsonMappingException} will be thrown if an unknown property\n     * is encountered).\n     */\n    FAIL_ON_UNKNOWN_PROPERTIES(true),\n\n    /**\n     * Feature that determines whether encountering of JSON null\n     * is an error when deserializing into Java primitive types\n     * (like 'int' or 'double'). If it is, a {@link InvalidNullException}\n     * is thrown to indicate this; if not, default value is used\n     * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n     *<p>\n     * Feature is disabled by default.\n     */\n    FAIL_ON_NULL_FOR_PRIMITIVES(false),\n\n    /**\n     * Feature that determines whether JSON integer numbers are valid\n     * values to be used for deserializing Java enum values.\n     * If set to 'false' numbers are acceptable and are used to map to\n     * ordinal() of matching enumeration value; if 'true', numbers are\n     * not allowed and a {@link JsonMappingException} will be thrown.\n     * Latter behavior makes sense if there is concern that accidental\n     * mapping from integer values to enums might happen (and when enums\n     * are always serialized as JSON Strings)\n     *<p>\n     * Feature is disabled by default.\n     */\n    FAIL_ON_NUMBERS_FOR_ENUMS(false),\n\n    /**\n     * Feature that determines what happens when type of a polymorphic\n     * value (indicated for example by {@link com.fasterxml.jackson.annotation.JsonTypeInfo})\n     * cannot be found (missing) or resolved (invalid class name, non-mappable id);\n     * if enabled, an exception is thrown; if false, null value is used instead.\n     *<p>\n     * Feature is enabled by default so that exception is thrown for missing or invalid\n     * type information.\n     * \n     * @since 2.2\n     */\n    FAIL_ON_INVALID_SUBTYPE(true),\n\n    /**\n     * Feature that determines what happens when reading JSON content into tree\n     * ({@link com.fasterxml.jackson.core.TreeNode}) and a duplicate key\n     * is encountered (property name that was already seen for the JSON Object).\n     * If enabled, {@link JsonMappingException} will be thrown; if disabled, no exception\n     * is thrown and the new (later) value overwrites the earlier value.\n     *<p>\n     * Note that this property does NOT affect other aspects of data-binding; that is,\n     * no detection is done with respect to POJO properties or {@link java.util.Map}\n     * keys. New features may be added to control additional cases.\n     *<p>\n     * Feature is disabled by default so that no exception is thrown.\n     * \n     * @since 2.3\n     */\n    FAIL_ON_READING_DUP_TREE_KEY(false),\n\n    /**\n     * Feature that determines what happens when a property that has been explicitly\n     * marked as ignorable is encountered in input: if feature is enabled,\n     * {@link JsonMappingException} is thrown; if false, property is quietly skipped.\n     *<p>\n     * Feature is disabled by default so that no exception is thrown.\n     *\n     * @since 2.3\n     */\n    FAIL_ON_IGNORED_PROPERTIES(false),\n\n    /**\n     * Feature that determines what happens if an Object Id reference is encountered\n     * that does not refer to an actual Object with that id (\"unresolved Object Id\"):\n     * either an exception is thrown (<code>true</code>), or a null object is used\n     * instead (<code>false</code>).\n     * Note that if this is set to <code>false</code>, no further processing is done;\n     * specifically, if reference is defined via setter method, that method will NOT\n     * be called.\n     *<p>\n     * Feature is enabled by default, so that unknown Object Ids will result in an\n     * exception being thrown, at the end of deserialization.\n     * \n     * @since 2.5\n     */\n    FAIL_ON_UNRESOLVED_OBJECT_IDS(true),\n\n    /**\n     * Feature that determines what happens if one or more Creator properties (properties\n     * bound to parameters of Creator method (constructor or static factory method))\n     * are missing value to bind to from content.\n     * If enabled, such missing values result in a {@link JsonMappingException} being\n     * thrown with information on the first one (by index) of missing properties.\n     * If disabled, and if property is NOT marked as required,\n     * missing Creator properties are filled\n     * with <code>null values</code> provided by deserializer for the type of parameter\n     * (usually null for Object types, and default value for primitives; but redefinable\n     * via custom deserializers).\n     *<p>\n     * Note that having an injectable value counts as \"not missing\".\n     *<p>\n     * Feature is disabled by default, so that no exception is thrown for missing creator\n     * property values, unless they are explicitly marked as `required`.\n     * \n     * @since 2.6\n     */\n    FAIL_ON_MISSING_CREATOR_PROPERTIES(false),\n\n    /**\n      * Feature that determines what happens if one or more Creator properties (properties\n      * bound to parameters of Creator method (constructor or static factory method))\n      * are bound to null values - either from the JSON or as a default value. This\n      * is useful if you want to avoid nulls in your codebase, and particularly useful\n      * if you are using Java or Scala optionals for non-mandatory fields.\n      * Feature is disabled by default, so that no exception is thrown for missing creator\n      * property values, unless they are explicitly marked as `required`.\n      *\n      * @since 2.8\n      */\n    FAIL_ON_NULL_CREATOR_PROPERTIES(false),\n\n    /**\n     * Feature that determines what happens when a property annotated with\n     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY} is missing,\n     * but associated type id is available. If enabled, {@link JsonMappingException} is always\n     * thrown when property value is missing (if type id does exist);\n     * if disabled, exception is only thrown if property is marked as `required`.\n     *<p>\n     * Feature is enabled by default, so that exception is thrown when a subtype property is\n     * missing.\n     *\n     * @since 2.9\n     */\n    FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY(true),\n\n    /**\n     * Feature that determines behaviour for data-binding after binding the root value.\n     * If feature is enabled, one more call to\n     * {@link com.fasterxml.jackson.core.JsonParser#nextToken} is made to ensure that\n     * no more tokens are found (and if any is found,\n     * {@link com.fasterxml.jackson.databind.exc.MismatchedInputException} is thrown); if\n     * disabled, no further checks are made.\n     *<p>\n     * Feature could alternatively be called <code>READ_FULL_STREAM</code>, since it\n     * effectively verifies that input stream contains only as much data as is needed\n     * for binding the full value, and nothing more (except for possible ignorable\n     * white space or comments, if supported by data format).\n     *<p>\n     * Feature is disabled by default (so that no check is made for possible trailing\n     * token(s)) for backwards compatibility reasons.\n     *\n     * @since 2.9\n     */\n    FAIL_ON_TRAILING_TOKENS(false),\n    \n    /**\n     * Feature that determines whether Jackson code should catch\n     * and wrap {@link Exception}s (but never {@link Error}s!)\n     * to add additional information about\n     * location (within input) of problem or not. If enabled,\n     * most exceptions will be caught and re-thrown (exception\n     * specifically being that {@link java.io.IOException}s may be passed\n     * as is, since they are declared as throwable); this can be\n     * convenient both in that all exceptions will be checked and\n     * declared, and so there is more contextual information.\n     * However, sometimes calling application may just want \"raw\"\n     * unchecked exceptions passed as is.\n     *<p>\n     * NOTE: most of the time exceptions that may or may not be wrapped are of\n     * type {@link RuntimeException}: as mentioned earlier, various\n     * {@link java.io.IOException}s (and in particular\n     * {@link com.fasterxml.jackson.core.JacksonException}s) will\n     * always be passed as-is.\n     *<p>\n     * Feature is enabled by default.\n     */\n    WRAP_EXCEPTIONS(true),\n\n    /*\n    /******************************************************\n    /* Structural conversion features\n    /******************************************************\n     */\n\n    /**\n     * Feature that determines whether it is acceptable to coerce non-array\n     * (in JSON) values to work with Java collection (arrays, java.util.Collection)\n     * types. If enabled, collection deserializers will try to handle non-array\n     * values as if they had \"implicit\" surrounding JSON array.\n     * This feature is meant to be used for compatibility/interoperability reasons,\n     * to work with packages (such as XML-to-JSON converters) that leave out JSON\n     * array in cases where there is just a single element in array.\n     *<p>\n     * Feature is disabled by default.\n     */\n    ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n    \n    /**\n     * Feature that determines whether it is acceptable to coerce single value array (in JSON)\n     * values to the corresponding value type.  This is basically the opposite of the {@link #ACCEPT_SINGLE_VALUE_AS_ARRAY}\n     * feature.  If more than one value is found in the array, a JsonMappingException is thrown.\n     * <p>\n     * \n     * Feature is disabled by default\n     * @since 2.4\n     */\n    UNWRAP_SINGLE_VALUE_ARRAYS(false),\n\n    /**\n     * Feature to allow \"unwrapping\" root-level JSON value, to match setting of\n     * {@link SerializationFeature#WRAP_ROOT_VALUE} used for serialization.\n     * Will verify that the root JSON value is a JSON Object, and that it has\n     * a single property with expected root name. If not, a\n     * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n     * will be deserialized as if it was the root value.\n     *<p>\n     * Feature is disabled by default.\n     */\n    UNWRAP_ROOT_VALUE(false),\n\n    /*\n    /******************************************************\n    /* Value conversion features\n    /******************************************************\n     */\n    \n    /**\n     * Feature that can be enabled to allow JSON empty String\n     * value (\"\") to be bound as `null` for POJOs and other structured\n     * values ({@link java.util.Map}s, {@link java.util.Collection}s).\n     * If disabled, standard POJOs can only be bound from JSON `null` or\n     * JSON Object (standard meaning that no custom deserializers or\n     * constructors are defined; both of which can add support for other\n     * kinds of JSON values); if enabled, empty JSON String can be taken\n     * to be equivalent of JSON null.\n     *<p>\n     * NOTE: this does NOT apply to scalar values such as booleans and numbers;\n     * whether they can be coerced depends on\n     * {@link MapperFeature#ALLOW_COERCION_OF_SCALARS}.\n     *<p>\n     * Feature is disabled by default.\n     */\n    ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false),\n\n    /**\n     * Feature that can be enabled to allow empty JSON Array\n     * value (that is, <code>[ ]</code>) to be bound to POJOs (and\n     * with 2.9, other values too) as `null`.\n     * If disabled, standard POJOs can only be bound from JSON `null` or\n     * JSON Object (standard meaning that no custom deserializers or\n     * constructors are defined; both of which can add support for other\n     * kinds of JSON values); if enabled, empty JSON Array will be taken\n     * to be equivalent of JSON null.\n     *<p>\n     * Feature is disabled by default.\n     * \n     * @since 2.5\n     */\n    ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT(false),\n\n    /**\n     * Feature that determines whether coercion from JSON floating point\n     * number (anything with command (`.`) or exponent portion (`e` / `E'))\n     * to an expected integral number (`int`, `long`, `java.lang.Integer`, `java.lang.Long`,\n     * `java.math.BigDecimal`) is allowed or not.\n     * If enabled, coercion truncates value; if disabled, a {@link JsonMappingException}\n     * will be thrown.\n     *<p>\n     * Feature is enabled by default.\n     * \n     * @since 2.6\n     */\n    ACCEPT_FLOAT_AS_INT(true),\n\n    /**\n     * Feature that determines standard deserialization mechanism used for\n     * Enum values: if enabled, Enums are assumed to have been serialized  using\n     * return value of <code>Enum.toString()</code>;\n     * if disabled, return value of <code>Enum.name()</code> is assumed to have been used.\n     *<p>\n     * Note: this feature should usually have same value\n     * as {@link SerializationFeature#WRITE_ENUMS_USING_TO_STRING}.\n     *<p>\n     * Feature is disabled by default.\n     */\n    READ_ENUMS_USING_TO_STRING(false),\n\n    /**\n     * Feature that allows unknown Enum values to be parsed as null values. \n     * If disabled, unknown Enum values will throw exceptions.\n     *<p>\n     * Note that in some cases this will basically ignore unknown Enum values;\n     * this is the keys for keys of {@link java.util.EnumMap} and values\n     * of {@link java.util.EnumSet} (because nulls are not accepted in these\n     * cases).\n     *<p>\n     * Feature is disabled by default.\n     * \n     * @since 2.0\n     */\n    READ_UNKNOWN_ENUM_VALUES_AS_NULL(false),\n\n    /**\n     * Feature that allows unknown Enum values to be ignored and a predefined value specified through\n     * {@link com.fasterxml.jackson.annotation.JsonEnumDefaultValue @JsonEnumDefaultValue} annotation.\n     * If disabled, unknown Enum values will throw exceptions.\n     * If enabled, but no predefined default Enum value is specified, an exception will be thrown as well.\n     *<p>\n     * Feature is disabled by default.\n     *\n     * @since 2.8\n     */\n    READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE(false),\n\n    /**\n     * Feature that controls whether numeric timestamp values are expected\n     * to be written using nanosecond timestamps (enabled) or not (disabled),\n     * <b>if and only if</b> datatype supports such resolution.\n     * Only newer datatypes (such as Java8 Date/Time) support such resolution --\n     * older types (pre-Java8 <b>java.util.Date</b> etc) and Joda do not --\n     * and this setting <b>has no effect</b> on such types.\n     *<p>\n     * If disabled, standard millisecond timestamps are assumed.\n     * This is the counterpart to {@link SerializationFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.\n     *<p>\n     * Feature is enabled by default, to support most accurate time values possible.\n     * \n     * @since 2.2\n     */\n    READ_DATE_TIMESTAMPS_AS_NANOSECONDS(true),\n\n    /**\n     * Feature that specifies whether context provided {@link java.util.TimeZone}\n     * ({@link DeserializationContext#getTimeZone()} should be used to adjust Date/Time\n     * values on deserialization, even if value itself contains timezone information.\n     * If enabled, contextual <code>TimeZone</code> will essentially override any other\n     * TimeZone information; if disabled, it will only be used if value itself does not\n     * contain any TimeZone information.\n     *<p>\n     * Note that exact behavior depends on date/time types in question; and specifically\n     * JDK type of {@link java.util.Date} does NOT have in-built timezone information\n     * so this setting has no effect.\n     * Further, while {@link java.util.Calendar} does have this information basic\n     * JDK {@link java.text.SimpleDateFormat} is unable to retain parsed zone information,\n     * and as a result, {@link java.util.Calendar} will always get context timezone\n     * adjustment regardless of this setting.\n     *<p>\n     *<p>\n     * Taking above into account, this feature is supported only by extension modules for\n     * Joda and Java 8 date/time datatypes.\n     * \n     * @since 2.2\n     */\n    ADJUST_DATES_TO_CONTEXT_TIME_ZONE(true),\n\n    /*\n    /******************************************************\n    /* Other\n    /******************************************************\n     */\n\n    /**\n     * Feature that determines whether {@link ObjectReader} should\n     * try to eagerly fetch necessary {@link JsonDeserializer} when\n     * possible. This improves performance in cases where similarly\n     * configured {@link ObjectReader} instance is used multiple\n     * times; and should not significantly affect single-use cases.\n     *<p>\n     * Note that there should not be any need to normally disable this\n     * feature: only consider that if there are actual perceived problems.\n     *<p>\n     * Feature is enabled by default.\n     * \n     * @since 2.1\n     */\n    EAGER_DESERIALIZER_FETCH(true)\n    \n    ;\n\n    private final boolean _defaultState;\n    private final int _mask;\n    \n    private DeserializationFeature(boolean defaultState) {\n        _defaultState = defaultState;\n        _mask = (1 << ordinal());\n    }\n\n    @Override\n    public boolean enabledByDefault() { return _defaultState; }\n\n    @Override\n    public int getMask() { return _mask; }\n\n    @Override\n    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n}\n", "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.CoercionAction;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.util.IgnorePropertiesUtil;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Lazily constructed exception used as root cause if reporting problem\n     * with creator method that returns <code>null</code> (which is not allowed)\n     *\n     * @since 2.8\n     */\n    protected transient Exception _nullFromCreator;\n\n    /**\n     * State marker we need in order to avoid infinite recursion for some cases\n     * (not very clean, alas, but has to do for now)\n     *\n     * @since 2.9\n     */\n    private volatile transient NameTransformer _currentlyTransforming;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     *\n     * @deprecated in 2.12, remove from 3.0\n     */\n    @Deprecated\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n        super(builder, beanDesc, properties, backRefs,\n                ignorableProps, ignoreAllUnknown, null, hasViews);\n    }\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     *\n     * @since 2.12\n     */\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n                            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n                            HashSet<String> ignorableProps, boolean ignoreAllUnknown, Set<String> includableProps,\n                            boolean hasViews)\n    {\n        super(builder, beanDesc, properties, backRefs,\n                ignorableProps, ignoreAllUnknown, includableProps, hasViews);\n    }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write style copying of settings of an existing instance.\n     */\n    protected BeanDeserializer(BeanDeserializerBase src) {\n        super(src, src._ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown) {\n        super(src, ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {\n        super(src, unwrapper);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {\n        super(src, oir);\n    }\n\n    /**\n     * @deprecated in 2.12, remove from 3.0\n     */\n    @Deprecated\n    public BeanDeserializer(BeanDeserializerBase src, Set<String> ignorableProps) {\n        super(src, ignorableProps);\n    }\n\n    /**\n     * @since 2.12\n     */\n    public BeanDeserializer(BeanDeserializerBase src, Set<String> ignorableProps, Set<String> includableProps) {\n        super(src, ignorableProps, includableProps);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, BeanPropertyMap props) {\n        super(src, props);\n    }\n\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer transformer)\n    {\n        // bit kludgy but we don't want to accidentally change type; sub-classes\n        // MUST override this method to support unwrapped properties...\n        if (getClass() != BeanDeserializer.class) {\n            return this;\n        }\n        // 25-Mar-2017, tatu: Not clean at all, but for [databind#383] we do need\n        //   to keep track of accidental recursion...\n        if (_currentlyTransforming == transformer) {\n            return this;\n        }\n        _currentlyTransforming = transformer;\n        try {\n            return new BeanDeserializer(this, transformer);\n        } finally { _currentlyTransforming = null; }\n    }\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }\n\n    @Override\n    public BeanDeserializer withByNameInclusion(Set<String> ignorableProps,\n            Set<String> includableProps) {\n        return new BeanDeserializer(this, ignorableProps, includableProps);\n    }\n\n    @Override\n    public BeanDeserializerBase withIgnoreAllUnknown(boolean ignoreUnknown) {\n        return new BeanDeserializer(this, ignoreUnknown);\n    }\n\n    @Override\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BeanDeserializer(this, props);\n    }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            // 23-Sep-2015, tatu: This is wrong at some many levels, but for now... it is\n            //    what it is, including \"expected behavior\".\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        return _deserializeOther(p, ctxt, p.currentToken());\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        if (t != null) {\n            switch (t) {\n            case VALUE_STRING:\n                return deserializeFromString(p, ctxt);\n            case VALUE_NUMBER_INT:\n                return deserializeFromNumber(p, ctxt);\n            case VALUE_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case VALUE_EMBEDDED_OBJECT:\n                return deserializeFromEmbedded(p, ctxt);\n            case VALUE_TRUE:\n            case VALUE_FALSE:\n                return deserializeFromBoolean(p, ctxt);\n            case VALUE_NULL:\n                return deserializeFromNull(p, ctxt);\n            case START_ARRAY:\n                // these only work if there's a (delegating) creator, or UNWRAP_SINGLE_ARRAY\n                return _deserializeFromArray(p, ctxt);\n            case FIELD_NAME:\n            case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n                if (_vanillaProcessing) {\n                    return vanillaDeserialize(p, ctxt, t);\n                }\n                if (_objectIdReader != null) {\n                    return deserializeWithObjectId(p, ctxt);\n                }\n                return deserializeFromObject(p, ctxt);\n            default:\n            }\n        }\n        return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.currentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.currentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * General version used when handling needs more advanced features.\n     */\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [databind#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if ((_objectIdReader != null) && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.currentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.currentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        TokenBuffer unknown = null;\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n        JsonToken t = p.currentToken();\n        List<BeanReferring> referrings = null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            p.nextToken(); // to point to value\n            final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            // Object Id property?\n            if (buffer.readIdProperty(propName) && creatorProp == null) {\n                continue;\n            }\n            // creator property?\n            if (creatorProp != null) {\n                // Last creator property to set?\n                Object value;\n                if ((activeView != null) && !creatorProp.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                value = _deserializeWithErrorWrapping(p, ctxt, creatorProp);\n                if (buffer.assignParameter(creatorProp, value)) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    if (bean == null) {\n                        return ctxt.handleInstantiationProblem(handledType(), null,\n                                _creatorReturnedNullException());\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                try {\n                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                } catch (UnresolvedForwardReference reference) {\n                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                    //    handling of forward references here. Not exactly sure why existing\n                    //    facilities did not cover, but this does appear to solve the problem\n                    BeanReferring referring = handleUnresolvedReference(ctxt,\n                            prop, buffer, reference);\n                    if (referrings == null) {\n                        referrings = new ArrayList<BeanReferring>();\n                    }\n                    referrings.add(referring);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n\n            // 29-Mar-2021, tatu: [databind#3082] May skip collection if we know\n            //    they'd just get ignored (note: any-setter handled above; unwrapped\n            //    properties also separately handled)\n            if (_ignoreAllUnknown) {\n                // 22-Aug-2021, tatu: [databind#3252] must ensure we do skip the whole value\n                p.skipChildren();\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = ctxt.bufferForInputBuffering(p);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        // 13-Apr-2020, tatu: [databind#2678] need to handle injection here\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n\n        if (referrings != null) {\n            for (BeanReferring referring : referrings) {\n               referring.setBean(bean);\n            }\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) { // lgtm [java/dereferenced-value-may-be-null]\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }\n\n    /**\n     * @since 2.8\n     */\n    private BeanReferring handleUnresolvedReference(DeserializationContext ctxt,\n            SettableBeanProperty prop, PropertyValueBuffer buffer,\n            UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        BeanReferring referring = new BeanReferring(ctxt, reference,\n                prop.getType(), buffer, prop);\n        reference.getRoid().appendReferring(referring);\n        return referring;\n    }\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException\n    {\n        try {\n            return prop.deserialize(p, ctxt);\n        } catch (Exception e) {\n            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);\n            // never gets here, unless caller declines to throw an exception\n            return null;\n        }\n    }\n\n    /**\n     * Helper method called for rare case of pointing to {@link JsonToken#VALUE_NULL}\n     * token. While this is most often an erroneous condition, there is one specific\n     * case with XML handling where polymorphic type with no properties is exposed\n     * as such, and should be handled same as empty Object.\n     *\n     * @since 2.7\n     */\n    protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic\n        //   \"empty\" POJOs deserialized from XML, where empty XML tag synthesizes a\n        //   `VALUE_NULL` token.\n        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tb = ctxt.bufferForInputBuffering(p);\n            tb.writeEndObject();\n            JsonParser p2 = tb.asParser(p);\n            p2.nextToken(); // to point to END_OBJECT\n            // note: don't have ObjectId to consider at this point, so:\n            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)\n                    : deserializeFromObject(p2, ctxt);\n            p2.close();\n            return ob;\n        }\n        return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    }\n\n    @Override\n    protected Object _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // note: cannot call `_delegateDeserializer()` since order reversed here:\n        JsonDeserializer<Object> delegateDeser = _arrayDelegateDeserializer;\n        // fallback to non-array delegate\n        if ((delegateDeser != null) || ((delegateDeser = _delegateDeserializer) != null)) {\n            Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt,\n                    delegateDeser.deserialize(p, ctxt));\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            return bean;\n        }\n        final CoercionAction act = _findCoercionFromEmptyArray(ctxt);\n        final boolean unwrap = ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS);\n\n        if (unwrap || (act != CoercionAction.Fail)) {\n            JsonToken t = p.nextToken();\n            if (t == JsonToken.END_ARRAY) {\n                switch (act) {\n                case AsEmpty:\n                    return getEmptyValue(ctxt);\n                case AsNull:\n                case TryConvert:\n                    return getNullValue(ctxt);\n                default:\n                }\n                return ctxt.handleUnexpectedToken(getValueType(ctxt), JsonToken.START_ARRAY, p, null);\n            }\n            if (unwrap) {\n                final Object value = deserialize(p, ctxt);\n                if (p.nextToken() != JsonToken.END_ARRAY) {\n                    handleMissingEndArrayForSingle(p, ctxt);\n                }\n                return value;\n            }\n        }\n        return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializing when we have to consider an active View\n    /**********************************************************\n     */\n\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException\n    {\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.currentName();\n            do {\n                p.nextToken();\n                // TODO: 06-Jan-2015, tatu: try streamlining call sequences here as well\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    if (!prop.visibleInView(activeView)) {\n                        p.skipChildren();\n                        continue;\n                    }\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n    \n    /*\n    /**********************************************************\n    /* Handling for cases where we have \"unwrapped\" values\n    /**********************************************************\n     */\n\n    /**\n     * Method called when there are declared \"unwrapped\" properties\n     * which need special handling\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n        }\n        TokenBuffer tokens = ctxt.bufferForInputBuffering(p);\n        tokens.writeStartObject();\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        String propName = p.hasTokenId(JsonTokenId.ID_FIELD_NAME) ? p.currentName() : null;\n\n        for (; propName != null; propName = p.nextFieldName()) {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                if ((activeView != null) && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n                continue;\n            }\n            // Need to copy to a separate buffer first\n            TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);\n            tokens.writeFieldName(propName);\n            tokens.append(b2);\n            try {\n                _anySetter.deserializeAndSet(b2.asParserOnFirstToken(), ctxt, bean, propName);\n            } catch (Exception e) {\n                wrapAndThrow(e, bean, propName, ctxt);\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        JsonToken t = p.currentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        TokenBuffer tokens = ctxt.bufferForInputBuffering(p);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    _anySetter.deserializeAndSet(b2.asParserOnFirstToken(), ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n        //    Ok however to pass via setter or field.\n        \n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = ctxt.bufferForInputBuffering(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.currentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            // Object Id property?\n            if (buffer.readIdProperty(propName) && creatorProp == null) {\n                continue;\n            }\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                    //    problems if we maintain invariants\n                    if (t != JsonToken.END_OBJECT) {\n                        ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \n                                \"Attempted to unwrap '%s' value\",\n                                handledType().getName());\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        ctxt.reportInputMismatch(creatorProp,\n                                \"Cannot create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName,\n                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have property/-ies with\n    /* external type id\n    /**********************************************************\n     */\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            /* 24-Nov-2015, tatu: Use of delegating creator needs to have precedence, and basically\n             *   external type id handling just has to be ignored, as they would relate to target\n             *   type and not delegate type. Whether this works as expected is another story, but\n             *   there's no other way to really mix these conflicting features.\n             */\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        return _deserializeWithExternalTypeId(p, ctxt, bean,\n                _externalTypeIdHandler.start());\n    }\n\n    protected Object _deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean, ExternalTypeHandler ext)\n        throws IOException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (JsonToken t = p.currentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                // [JACKSON-831]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                }\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n        JsonToken t = p.currentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            t = p.nextToken(); // to point to value\n            // creator property?\n            final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            // Object Id property?\n            if (buffer.readIdProperty(propName) && creatorProp == null) {\n                continue;\n            }\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp,\n                            _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            return ctxt.reportBadDefinition(_beanType, String.format(\n                                    \"Cannot create polymorphic instances with external type ids (%s -> %s)\",\n                                    _beanType, bean.getClass()));\n                        }\n                        return _deserializeWithExternalTypeId(p, ctxt, bean, ext);\n                    }\n                }\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                // [databind#3045]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, null);\n                }\n                // 19-Feb-2021, tatu: Should probably consider view too?\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                } else {\n                    buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                }\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName,\n                        _anySetter.deserialize(p, ctxt));\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, _valueClass, propName);\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n    }\n\n    /**\n     * Helper method for getting a lazily construct exception to be reported\n     * to {@link DeserializationContext#handleInstantiationProblem(Class, Object, Throwable)}.\n     *\n     * @since 2.8\n     */\n    protected Exception _creatorReturnedNullException() {\n        if (_nullFromCreator == null) {\n            _nullFromCreator = new NullPointerException(\"JSON Creator returned null\");\n        }\n        return _nullFromCreator;\n    }\n\n    /**\n     * @since 2.8\n     */\n    static class BeanReferring extends Referring\n    {\n        private final DeserializationContext _context;\n        private final SettableBeanProperty _prop;\n        private Object _bean;\n\n        BeanReferring(DeserializationContext ctxt, UnresolvedForwardReference ref,\n                JavaType valueType, PropertyValueBuffer buffer, SettableBeanProperty prop)\n        {\n            super(ref, valueType);\n            _context = ctxt;\n            _prop = prop;\n        }\n\n        public void setBean(Object bean) {\n            _bean = bean;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n        {\n            if (_bean == null) {\n                _context.reportInputMismatch(_prop,\n\"Cannot resolve ObjectId forward reference using property '%s' (of type %s): Bean not yet resolved\",\n_prop.getName(), _prop.getDeclaringClass().getName());\n        }\n            _prop.set(_bean, value);\n        }\n    }\n}\n", "package com.fasterxml.jackson.databind.deser.dos;\n\nimport com.fasterxml.jackson.databind.*;\n\npublic class DeepArrayWrappingForDeser3582Test extends BaseMapTest\n{\n    // 23-Aug-2022, tatu: Before fix, fails with 5000\n    //    (but passes with 2000)\n//    private final static int TOO_DEEP_NESTING = 4999;\n    private final static int TOO_DEEP_NESTING = 999;\n\n    private final ObjectMapper MAPPER = jsonMapperBuilder()\n            .enable(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)\n            .build();\n\n    public void testArrayWrapping() throws Exception\n    {\n        final String doc = _nestedDoc(TOO_DEEP_NESTING, \"[ \", \"] \", \"{}\");\n        Point p = MAPPER.readValue(doc, Point.class);\n        assertNotNull(p);\n    }\n\n    private String _nestedDoc(int nesting, String open, String close, String content) {\n        StringBuilder sb = new StringBuilder(nesting * (open.length() + close.length()));\n        for (int i = 0; i < nesting; ++i) {\n            sb.append(open);\n            if ((i & 31) == 0) {\n                sb.append(\"\\n\");\n            }\n        }\n        sb.append(\"\\n\").append(content).append(\"\\n\");\n        for (int i = 0; i < nesting; ++i) {\n            sb.append(close);\n            if ((i & 31) == 0) {\n                sb.append(\"\\n\");\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"], "fixing_code": ["Project: jackson-databind\n\n------------------------------------------------------------------------\n=== Releases === \n------------------------------------------------------------------------\n\n2.13.4 (not yet released)\n\n#3275: JDK 16 Illegal reflective access for `Throwable.setCause()` with\n  `PropertyNamingStrategy.UPPER_CAMEL_CASE`\n (reported by Jason H)\n (fix suggested by gsinghlulu@github)\n#3565: `Arrays.asList()` value deserialization has changed from mutable to\n  immutable in 2.13\n (reported by JonasWilms@github)\n#3582: Add check in `BeanDeserializer._deserializeFromArray()` to prevent\n  use of deeply nested arrays\n\n2.13.3 (14-May-2022)\n\n#3412: Version 2.13.2 uses `Method.getParameterCount()` which is not supported on\n  Android before API 26\n#3419: Improve performance of `UnresolvedForwardReference` for forward\n reference resolution\n(contributed by Gary M)\n#3446: `java.lang.StringBuffer` cannot be deserialized\n (reported by Lolf1010@github)\n#3450: DeserializationProblemHandler is not working with wrapper type\n  when returning null\n (reported by LJeanneau@github)\n\n2.13.2.2 (28-Mar-2022)\n\nNo changes since 2.13.2.1 but fixed Gradle Module Metadata (\"module.json\")\n\n2.13.2.1 (24-Mar-2022)\n\n#2816: Optimize UntypedObjectDeserializer wrt recursion\n (contributed by Taylor S, Spence N)\n#3412: Version 2.13.2 uses `Method.getParameterCount()` which is not\n  supported on Android before API 26\n (reported by Matthew F)\n\n2.13.2 (06-Mar-2022)\n\n#3293: Use Method.getParameterCount() where possible\n (suggested by Christoph D)\n#3344: `Set.of()` (Java 9) cannot be deserialized with polymorphic handling\n (reported by Sam K)\n#3368: `SnakeCaseStrategy` causes unexpected `MismatchedInputException` during\n  deserialization\n (reported by sszuev@github)\n#3369: Deserialization ignores other Object fields when Object or Array\n  value used for enum\n (reported by Krishna G)\n#3380: `module-info.java` is in `META-INF/versions/11` instead of `META-INF/versions/9`\n\n2.13.1 (19-Dec-2021)\n\n#3006: Argument type mismatch for `enum` with `@JsonCreator` that takes String,\n  gets JSON Number\n (reported by GrozaAnton@github)\n#3299: Do not automatically trim trailing whitespace from `java.util.regex.Pattern` values\n (reported by Joel B)\n#3305: ObjectMapper serializes `CharSequence` subtypes as POJO instead of\n  as String (JDK 15+)\n (reported by stevenupton@github; fix suggested by Sergey C)\n#3308: `ObjectMapper.valueToTree()` fails when\n `DeserializationFeature.FAIL_ON_TRAILING_TOKENS` is enabled\n (fix contributed by raphaelNguyen@github)\n#3328: Possible DoS if using JDK serialization to serialize JsonNode\n\n2.13.0 (30-Sep-2021)\n\n#1850: `@JsonValue` with integer for enum does not deserialize correctly\n (reported by tgolden-andplus@github)\n (fix contributed by limengning@github)\n#1988: MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUM does not work for Enum keys of Map\n (reported by Myp3ik@github)\n#2509: `AnnotatedMethod.getValue()/setValue()` doesn't have useful exception message\n (reported by henryptung@github)\n (fix contributed by Stephan S)\n#2828: Add `DatabindException` as intermediate subtype of `JsonMappingException`\n#2900: Jackson does not support deserializing new Java 9 unmodifiable collections\n (reported by Daniel H)\n#2989: Allocate TokenBuffer instance via context objects (to allow format-specific\n  buffer types)\n#3001: Add mechanism for setting default `ContextAttributes` for `ObjectMapper`\n#3002: Add `DeserializationContext.readTreeAsValue()` methods for more convenient\n  conversions for deserializers to use\n#3011: Clean up support of typed \"unmodifiable\", \"singleton\" Maps/Sets/Collections\n#3033: Extend internal bitfield of `MapperFeature` to be `long`\n#3035: Add `removeMixIn()` method in `MapperBuilder`\n#3036: Backport `MapperBuilder` lambda-taking methods: `withConfigOverride()`,\n  `withCoercionConfig()`, `withCoercionConfigDefaults()`\n#3080: configOverrides(boolean.class) silently ignored, whereas .configOverride(Boolean.class)\n  works for both primitives and boxed boolean values\n (reported by Asaf R)\n#3082: Dont track unknown props in buffer if `ignoreAllUnknown` is true\n (contributed by David H)\n#3091: Should allow deserialization of java.time types via opaque\n   `JsonToken.VALUE_EMBEDDED_OBJECT`\n#3099: Optimize \"AnnotatedConstructor.call()\" case by passing explicit null\n#3101: Add AnnotationIntrospector.XmlExtensions interface for decoupling javax dependencies\n#3110: Custom SimpleModule not included in list returned by ObjectMapper.getRegisteredModuleIds()\n  after registration\n (reported by dkindler@github)\n#3117: Use more limiting default visibility settings for JDK types (java.*, javax.*)\n#3122: Deep merge for `JsonNode` using `ObjectReader.readTree()`\n (reported by Eric S)\n#3125: IllegalArgumentException: Conflicting setter definitions for property\n  with more than 2 setters\n (reported by mistyzyq@github)\n#3130: Serializing java.lang.Thread fails on JDK 11 and above (should suppress\n  serialization of ClassLoader)\n#3143: String-based `Map` key deserializer is not deterministic when there is no\n  single arg constructor\n (reported by Halil \u0130brahim \u015e)\n#3154: Add ArrayNode#set(int index, primitive_type value)\n (contributed by Tarekk Mohamed A)\n#3160: JsonStreamContext \"currentValue\" wrongly references to @JsonTypeInfo\n  annotated object\n (reported by Aritz B)\n#3174: DOM `Node` serialization omits the default namespace declaration\n (contributed by Morten A-G)\n#3177: Support `suppressed` property when deserializing `Throwable`\n (contributed by Klaas D)\n#3187: `AnnotatedMember.equals()` does not work reliably\n (contributed by Klaas D)\n#3193: Add `MapperFeature.APPLY_DEFAULT_VALUES`, initially for Scala module\n (suggested by Nick B)\n#3214: For an absent property Jackson injects `NullNode` instead of `null` to a\n  JsonNode-typed constructor argument of a `@ConstructorProperties`-annotated constructor\n (reported by robvarga@github)\n#3217: `XMLGregorianCalendar` doesn't work with default typing\n (reported by Xinzhe Y)\n#3227: Content `null` handling not working for root values\n (reported by Jo\u00e3o G)\n (fix contributed by proost@github)\n#3234: StdDeserializer rejects blank (all-whitespace) strings for ints\n (reported by Peter B)\n (fix proposed by qthegreat3@github)\n#3235: `USE_BASE_TYPE_AS_DEFAULT_IMPL` not working with `DefaultTypeResolverBuilder`\n (reported, fix contributed by silas.u / sialais@github)\n#3238: Add PropertyNamingStrategies.UpperSnakeCaseStrategy (and UPPER_SNAKE_CASE constant)\n (requested by Kenneth J)\n (contributed by Tanvesh)\n#3244: StackOverflowError when serializing JsonProcessingException\n (reported by saneksanek@github)\n#3259: Support for BCP 47 `java.util.Locale` serialization/deserialization\n (contributed by Abishek R)\n#3271: String property deserializes null as \"null\" for JsonTypeInfo.As.EXISTING_PROPERTY\n (reported by jonc2@github)\n#3280: Can not deserialize json to enum value with Object-/Array-valued input,\n  `@JsonCreator`\n (reported by peteryuanpan@github)\n#3397: Optimize `JsonNodeDeserialization` wrt recursion\n- Fix to avoid problem with `BigDecimalNode`, scale of `Integer.MIN_VALUE` (see\n  [dataformats-binary#264] for details)\n- Extend handling of `FAIL_ON_NULL_FOR_PRIMITIVES` to cover coercion from (Empty) String\n  via `AsNull`\n- Add `mvnw` wrapper\n\n2.12.7 (26-May-2022)\n\n#2816: Optimize UntypedObjectDeserializer wrt recursion [CVE-2020-36518]\n\n2.12.6 (15-Dec-2021)\n\n#3280: Can not deserialize json to enum value with Object-/Array-valued input,\n  `@JsonCreator`\n (reported by peteryuanpan@github)\n#3305: ObjectMapper serializes `CharSequence` subtypes as POJO instead of\n  as String (JDK 15+)\n (reported by stevenupton@github; fix suggested by Sergey C)\n#3328: Possible DoS if using JDK serialization to serialize JsonNode\n\n2.12.5 (27-Aug-2021)\n\n#3220: (regression) Factory method generic type resolution does not use\n  Class-bound type parameter\n (reported by Marcos P)\n\n2.12.4 (06-Jul-2021)\n\n#3139: Deserialization of \"empty\" subtype with DEDUCTION failed\n (reported by JoeWoo; fix provided by drekbour@github)\n#3146: Merge findInjectableValues() results in AnnotationIntrospectorPair\n (contributed by Joe B)\n#3171: READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE doesn't work with empty strings\n (reported by unintended@github)\n\n2.12.3 (12-Apr-2021)\n\n#3108: `TypeFactory` cannot convert `Collection` sub-type without type parameters\n  to canonical form and back\n (reported by lbilger@github)\n- Fix for [modules-java8#207]: prevent fail on secondary Java 8 date/time types\n\n2.12.2 (03-Mar-2021)\n\n#754: EXTERNAL_PROPERTY does not work well with `@JsonCreator` and\n   `FAIL_ON_UNKNOWN_PROPERTIES`\n (reported by Vassil D)\n#3008: String property deserializes null as \"null\" for\n   `JsonTypeInfo.As.EXTERNAL_PROPERTY`\n#3022: Property ignorals cause `BeanDeserializer `to forget how to read\n  from arrays (not copying `_arrayDelegateDeserializer`)\n (reported by Gian M)\n#3025: UntypedObjectDeserializer` mixes multiple unwrapped\n  collections (related to #2733)\n (fix contributed by Migwel@github)\n#3038: Two cases of incorrect error reporting about DeserializationFeature\n (reported by Jelle V)\n#3045: Bug in polymorphic deserialization with `@JsonCreator`, `@JsonAnySetter`,\n  `JsonTypeInfo.As.EXTERNAL_PROPERTY`\n (reported by martineaus83@github)\n#3055: Polymorphic subtype deduction ignores `defaultImpl` attribute\n (contributed by drekbour@github)\n#3056: MismatchedInputException: Cannot deserialize instance of\n  `com.fasterxml.jackson.databind.node.ObjectNode` out of VALUE_NULL token\n (reported by Stexxen@github)\n#3060: Missing override for `hasAsKey()` in `AnnotationIntrospectorPair`\n#3062: Creator lookup fails with `InvalidDefinitionException` for conflict\n  between single-double/single-Double arg constructor\n#3068: `MapDeserializer` forcing `JsonMappingException` wrapping even if\n  WRAP_EXCEPTIONS set to false\n (reported by perkss@github)\n\n2.12.1 (08-Jan-2021)\n\n#2962: Auto-detection of constructor-based creator method skipped if there is\n   an annotated factory-based creator method (regression from 2.11)\n (reported by Halil I-S)\n#2972: `ObjectMapper.treeToValue()` no longer invokes `JsonDeserializer.getNullValue()`\n (reported by andpal@github)\n#2973: DeserializationProblemHandler is not invoked when trying to deserializing String\n (reported by zigzago@github)\n#2978: Fix failing `double` JsonCreators in jackson 2.12.0\n (contributed by Carter K)\n#2979: Conflicting in POJOPropertiesCollector when having namingStrategy\n (reported, fix suggested by SunYiJun)\n#2990: Breaking API change in `BasicClassIntrospector` (2.12.0)\n (reported, fix contributed by Faron D)\n#3005: `JsonNode.requiredAt()` does NOT fail on some path expressions\n#3009: Exception thrown when `Collections.synchronizedList()` is serialized\n  with type info, deserialized\n (reported by pcloves@github)\n\n2.12.0 (29-Nov-2020)\n\n#43: Add option to resolve type from multiple existing properties,\n  `@JsonTypeInfo(use=DEDUCTION)`\n (contributed by drekbour@github)\n#426: `@JsonIgnoreProperties` does not prevent Exception Conflicting getter/setter\n  definitions for property\n (reported by gmkll@github)\n#921: Deserialization Not Working Right with Generic Types and Builders\n (reported by Mike G; fix contributed by Ville K)\n#1296: Add `@JsonIncludeProperties(propertyNames)` (reverse of `@JsonIgnoreProperties`)\n (contributed Baptiste P)\n#1458: `@JsonAnyGetter` should be allowed on a field\n (contributed by Dominik K)\n#1498: Allow handling of single-arg constructor as property based by default\n (requested by Lovro P)\n#1852: Allow case insensitive deserialization of String value into\n  `boolean`/`Boolean` (esp for Excel)\n (requested by Patrick J)\n#1886: Allow use of `@JsonFormat(with=JsonFormat.Feature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)`\n  on Class\n#1919: Abstract class included as part of known type ids for error message\n  when using JsonSubTypes\n (reported by Incara@github)\n#2066: Distinguish null from empty string for UUID deserialization\n (requested by leonshaw@github)\n#2091: `ReferenceType` does not expose valid containedType\n (reported by Nate B)\n#2113: Add `CoercionConfig[s]` mechanism for configuring allowed coercions\n#2118: `JsonProperty.Access.READ_ONLY` does not work with \"getter-as-setter\" `Collection`s\n (reported by Xiang Z)\n#2215: Support `BigInteger` and `BigDecimal` creators in `StdValueInstantiator`\n (requested by David N, implementation contributed by Tiago M)\n#2283: `JsonProperty.Access.READ_ONLY` fails with collections when a property name is specified\n (reported by Yona A)\n#2644: `BigDecimal` precision not retained for polymorphic deserialization\n (reported by rost5000@github)\n#2675: Support use of `Void` valued properties (`MapperFeature.ALLOW_VOID_VALUED_PROPERTIES`)\n#2683: Explicitly fail (de)serialization of `java.time.*` types in absence of\n  registered custom (de)serializers\n#2707: Improve description included in by `DeserializationContext.handleUnexpectedToken()`\n#2709: Support for JDK 14 record types (`java.lang.Record`)\n (contributed by Youri B)\n#2715: `PropertyNamingStrategy` class initialization depends on its subclass, this can\n  lead to class loading deadlock\n (reported by fangwentong@github)\n#2719: `FAIL_ON_IGNORED_PROPERTIES` does not throw on `READONLY` properties with\n  an explicit name\n (reported, fix contributed by David B)\n#2726: Add Gradle Module Metadata for version alignment with Gradle 6\n (contributed by Jendrik J)\n#2732: Allow `JsonNode` auto-convert into `ArrayNode` if duplicates found (for XML)\n#2733: Allow values of \"untyped\" auto-convert into `List` if duplicates found (for XML)\n#2751: Add `ValueInstantiator.createContextual(...)\n#2761: Support multiple names in `JsonSubType.Type`\n (contributed by Swayam R)\n#2775: Disabling `FAIL_ON_INVALID_SUBTYPE` breaks polymorphic deserialization of Enums\n (reported by holgerknoche@github)\n#2776: Explicitly fail (de)serialization of `org.joda.time.*` types in absence of registered\n  custom (de)serializers\n#2784: Trailing zeros are stripped when deserializing BigDecimal values inside a\n  @JsonUnwrapped property\n (reported by mjustin@github)\n#2800: Extract getter/setter/field name mangling from `BeanUtil` into\n  pluggable `AccessorNamingStrategy`\n#2804: Throw `InvalidFormatException` instead of `MismatchedInputException`\n   for ACCEPT_FLOAT_AS_INT coercion failures\n (requested by mjustin@github)\n#2871: Add `@JsonKey` annotation (similar to `@JsonValue`) for customizable\n  serialization of Map keys\n (requested by CidTori@github; implementation contributed by Kevin B)\n#2873: `MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS` should work for enum as keys\n (fix contributed by Ilya G)\n#2879: Add support for disabling special handling of \"Creator properties\" wrt\n  alphabetic property ordering\n (contributed by Sergiy Y)\n#2885: Add `JsonNode.canConvertToExactIntegral()` to indicate whether floating-point/BigDecimal\n  values could be converted to integers losslessly\n (requested by Oguzhan U; implementation contributed by Siavash S)\n#2895: Improve static factory method generic type resolution logic\n (contributed by Carter K)\n#2903: Allow preventing \"Enum from integer\" coercion using new `CoercionConfig` system\n#2909: `@JsonValue` not considered when evaluating inclusion\n (reported by chrylis@github)\n#2910: Make some java platform modules optional\n (contributed by XakepSDK@github)\n#2925: Add support for serializing `java.sql.Blob`\n (contributed by M Rizky S)\n#2928: `AnnotatedCreatorCollector` should avoid processing synthetic static\n  (factory) methods\n (contributed by Carter K)\n#2931: Add errorprone static analysis profile to detect bugs at build time\n (contributed by Carter K)\n#2932: Problem with implicit creator name detection for constructor detection\n- Add `BeanDeserializerBase.isCaseInsensitive()`\n- Some refactoring of `CollectionDeserializer` to solve CSV array handling issues\n- Full \"LICENSE\" included in jar for easier access by compliancy tools\n\n2.11.4 (12-Dec-2020)\n\n#2894: Fix type resolution for static methods (regression in 2.11.3 due to #2821 fix)\n (reported by \u0141ukasz W)\n#2944: `@JsonCreator` on constructor not compatible with `@JsonIdentityInfo`,\n  `PropertyGenerator`\n (reported by Lucian H)\n- Add debug improvements wrt #2807 (`ClassUtil.getClassMethods()`)\n\n2.11.3 (02-Oct-2020)\n\n#2795: Cannot detect creator arguments of mixins for JDK types\n (reported by Marcos P)\n#2815: Add `JsonFormat.Shape` awareness for UUID serialization (`UUIDSerializer`)\n#2821: Json serialization fails or a specific case that contains generics and\n  static methods with generic parameters (2.11.1 -> 2.11.2 regression)\n (reported by Lari H)\n#2822: Using JsonValue and JsonFormat on one field does not work as expected\n (reported by Nils-Christian E)\n#2840: `ObjectMapper.activateDefaultTypingAsProperty()` is not using\n  parameter `PolymorphicTypeValidator`\n (reported by Daniel W)\n#2846: Problem deserialization \"raw generic\" fields (like `Map`) in 2.11.2\n- Fix issues with `MapLikeType.isTrueMapType()`,\n  `CollectionLikeType.isTrueCollectionType()`\n\n2.11.2 (02-Aug-2020)\n\n#2783: Parser/Generator features not set when using `ObjectMapper.createParser()`,\n  `createGenerator()`\n#2785: Polymorphic subtypes not registering on copied ObjectMapper (2.11.1)\n (reported, fix contributed by Joshua S)\n#2789: Failure to read AnnotatedField value in Jackson 2.11\n (reported by isaki@github)\n#2796: `TypeFactory.constructType()` does not take `TypeBindings` correctly\n (reported by Daniel H)\n\n2.11.1 (25-Jun-2020)\n\n#2486: Builder Deserialization with JsonCreator Value vs Array\n (reported by Ville K)\n#2725: JsonCreator on static method in Enum and Enum used as key in map\n  fails randomly\n (reported by Michael C)\n#2755: `StdSubtypeResolver` is not thread safe (possibly due to copy\n  not being made with `ObjectMapper.copy()`)\n (reported by tjwilson90@github)\n#2757: \"Conflicting setter definitions for property\" exception for `Map`\n  subtype during deserialization\n (reported by Frank S)\n#2758: Fail to deserialize local Records\n (reported by Johannes K)\n#2759: Rearranging of props when property-based generator is in use leads\n  to incorrect output\n (reported by Oleg C)\n#2760: Jackson doesn't respect `CAN_OVERRIDE_ACCESS_MODIFIERS=false` for\n  deserializer properties\n (reported by Johannes K)\n#2767: `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS` don't support `Map`\n  type field\n (reported by abomb4@github)\n#2770: JsonParser from MismatchedInputException cannot getText() for\n  floating-point value\n (reported by Jo\u00e3o G)\n\n2.11.0 (26-Apr-2020)\n\n#953: i-I case conversion problem in Turkish locale with case-insensitive deserialization\n (reported by M\u00e1t\u00e9 R)\n#962: `@JsonInject` fails on trying to find deserializer even if inject-only\n (reported by David B)\n#1983: Polymorphic deserialization should handle case-insensitive Type Id property name\n  if `MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES` is enabled\n (reported by soundvibe@github, fix contributed by Oleksandr P)\n#2049: TreeTraversingParser and UTF8StreamJsonParser create contexts differently\n (reported by Antonio P)\n#2352: Support use of `@JsonAlias` for enum values\n (contributed by Robert D)\n#2365: `declaringClass` of \"enum-as-POJO\" not removed for `ObjectMapper` with\n  a naming strategy\n (reported by Tynakuh@github)\n#2480: Fix `JavaType.isEnumType()` to support sub-classes\n#2487: BeanDeserializerBuilder Protected Factory Method for Extension\n (contributed by Ville K)\n#2503: Support `@JsonSerialize(keyUsing)` and `@JsonDeserialize(keyUsing)` on Key class\n#2511: Add `SerializationFeature.WRITE_SELF_REFERENCES_AS_NULL`\n (contributed by Joongsoo P)\n#2515: `ObjectMapper.registerSubtypes(NamedType...)` doesn't allow registering\n  same POJO for two different type ids\n (contributed by Joseph K)\n#2522: `DeserializationContext.handleMissingInstantiator()` throws\n  `MismatchedInputException` for non-static inner classes\n#2525: Incorrect `JsonStreamContext` for `TokenBuffer` and `TreeTraversingParser`\n#2527: Add `AnnotationIntrospector.findRenameByField()` to support Kotlin's\n  \"is-getter\" naming convention\n#2555: Use `@JsonProperty(index)` for sorting properties on serialization\n#2565: Java 8 `Optional` not working with `@JsonUnwrapped` on unwrappable type\n (reported by Haowei W)\n#2587: Add `MapperFeature.BLOCK_UNSAFE_POLYMORPHIC_BASE_TYPES` to allow blocking\n  use of unsafe base type for polymorphic deserialization\n#2589: `DOMDeserializer`: setExpandEntityReferences(false) may not prevent\n  external entity expansion in all cases [CVE-2020-25649]\n (reported by Bartosz B)\n#2592: `ObjectMapper.setSerializationInclusion()` is ignored for `JsonAnyGetter`\n (reported by Oleksii K)\n#2608: `ValueInstantiationException` when deserializing using a builder and\n  `UNWRAP_SINGLE_VALUE_ARRAYS`\n (reported by cadrake@github)\n#2627: JsonIgnoreProperties(ignoreUnknown = true) does not work on field and method level\n (reported by robotmrv@github)\n#2632: Failure to resolve generic type parameters on serialization\n (reported by Simone D)\n#2635: JsonParser cannot getText() for input stream on MismatchedInputException\n (reported by Jo\u00e3o G)\n#2636: ObjectReader readValue lacks Class<T> argument\n (contributed by Robin R)\n#2643: Change default textual serialization of `java.util.Date`/`Calendar`\n  to include colon in timezone offset\n#2647: Add `ObjectMapper.createParser()` and `createGenerator()` methods\n#2657: Allow serialization of `Properties` with non-String values\n#2663: Add new factory method for creating custom `EnumValues` to pass to `EnumDeserializer\n (requested by Rafal K)\n#2668: `IllegalArgumentException` thrown for mismatched subclass deserialization\n (reported by nbruno@github)\n#2693: Add convenience methods for creating `List`, `Map` valued `ObjectReader`s\n  (ObjectMapper.readerForListOf())\n- Add `SerializerProvider.findContentValueSerializer()` methods\n\n2.10.5.1 (02-Dec-2020)\n\n#2589: (see desc on 2.11.0 -- backported)\n\n2.10.5 (21-Jul-2020)\n\n#2787 (partial fix): NPE after add mixin for enum\n (reported by Denis K)\n\n2.10.4 (03-May-2020)\n\n#2679: `ObjectMapper.readValue(\"123\", Void.TYPE)` throws \"should never occur\"\n (reported by Endre S)\n\n2.10.3 (03-Mar-2020)\n\n#2482: `JSONMappingException` `Location` column number is one line Behind the actual\n  location\n (reported by Kamal A, fixed by Ivo S)\n#2599: NoClassDefFoundError at DeserializationContext.<init> on Android 4.1.2\n  and Jackson 2.10.0\n (reported by Tobias P)\n#2602: ByteBufferSerializer produces unexpected results with a duplicated ByteBuffer\n  and a position > 0\n (reported by Eduard T)\n#2605: Failure to deserializer polymorphic subtypes of base type `Enum`\n (reported by uewle@github)\n#2610: `EXTERNAL_PROPERTY` doesn't work with `@JsonIgnoreProperties`\n (reported, fix suggested by Alexander S)\n\n2.10.2 (05-Jan-2020)\n\n#2101: `FAIL_ON_NULL_FOR_PRIMITIVES` failure does not indicate field name in exception message\n (reported by raderio@github)\n\n2.10.1 (09-Nov-2019)\n\n#2457: Extended enum values are not handled as enums when used as Map keys\n (reported by Andrey K)\n#2473: Array index missing in path of `JsonMappingException` for `Collection<String>`,\n  with custom deserializer\n (reported by Jo\u00e3o G)\n#2475: `StringCollectionSerializer` calls `JsonGenerator.setCurrentValue(value)`,\n  which messes up current value for sibling properties\n (reported by Ryan B)\n#2485: Add `uses` for `Module` in module-info\n (contributed by Marc M)\n#2513: BigDecimalAsStringSerializer in NumberSerializer throws IllegalStateException in 2.10\n (reported by Johan H)\n#2519: Serializing `BigDecimal` values inside containers ignores shape override\n (reported by Richard W)\n#2520: Sub-optimal exception message when failing to deserialize non-static inner classes\n (reported by Mark S)\n#2529: Add tests to ensure `EnumSet` and `EnumMap` work correctly with \"null-as-empty\"\n#2534: Add `BasicPolymorphicTypeValidator.Builder.allowIfSubTypeIsArray()`\n#2535: Allow String-to-byte[] coercion for String-value collections\n\n2.10.0 (26-Sep-2019)\n\n#18: Make `JsonNode` serializable\n#1093: Default typing does not work with `writerFor(Object.class)`\n (reported by hoomanv@github)\n#1675: Remove \"impossible\" `IOException` in `readTree()` and `readValue()` `ObjectMapper`\n  methods which accept Strings\n (requested by matthew-pwnieexpress@github)\n#1954: Add Builder pattern for creating configured `ObjectMapper` instances\n#1995: Limit size of `DeserializerCache`, auto-flush on exceeding\n#2059: Remove `final` modifier for `TypeFactory`\n (requested by Thibaut R)\n#2077: `JsonTypeInfo` with a subtype having `JsonFormat.Shape.ARRAY` and\n  no fields generates `{}` not `[]`\n (reported by Sadayuki F)\n#2115: Support naive deserialization of `Serializable` values as \"untyped\", same\n  as `java.lang.Object`\n (requested by Christopher S)\n#2116: Make NumberSerializers.Base public and its inherited classes not final\n (requested by \u00c9douard M)\n#2126: `DeserializationContext.instantiationException()` throws `InvalidDefinitionException`\n#2129: Add `SerializationFeature.WRITE_ENUM_KEYS_USING_INDEX`, separate from value setting\n (suggested by renzihui@github)\n#2133: Improve `DeserializationProblemHandler.handleUnexpectedToken()` to allow handling of\n  Collection problems\n (contributed by Semyon L)\n#2149: Add `MapperFeature.ACCEPT_CASE_INSENSITIVE_VALUES`\n (suggested by Craig P)\n#2153: Add `JsonMapper` to replace generic `ObjectMapper` usage\n#2164: `FactoryBasedEnumDeserializer` does not respect\n  `DeserializationFeature.WRAP_EXCEPTIONS`\n (reported by Yiqiu H)\n#2187: Make `JsonNode.toString()` use shared `ObjectMapper` to produce valid json\n#2189: `TreeTraversingParser` does not check int bounds\n (reported by Alexander S)\n#2195: Add abstraction `PolymorphicTypeValidator`, for limiting subtypes allowed by\n  default typing, `@JsonTypeInfo`\n#2196: Type safety for `readValue()` with `TypeReference`\n (suggested by nguyenfilip@github)\n#2204: Add `JsonNode.isEmpty()` as convenience alias\n#2211: Change of behavior (2.8 -> 2.9) with `ObjectMapper.readTree(input)` with no content\n#2217: Suboptimal memory allocation in `TextNode.getBinaryValue()`\n (reported by Christoph B)\n#2220: Force serialization always for `convertValue()`; avoid short-cuts\n#2223: Add `missingNode()` method in `JsonNodeFactory`\n#2227: Minor cleanup of exception message for `Enum` binding failure\n (reported by RightHandedMonkey@github)\n#2230: `WRITE_BIGDECIMAL_AS_PLAIN` is ignored if `@JsonFormat` is used\n (reported by Pavel C)\n#2236: Type id not provided on `Double.NaN`, `Infinity` with `@JsonTypeInfo`\n (reported by C-B-B@github)\n#2237: Add \"required\" methods in `JsonNode`: `required(String | int)`,\n  `requiredAt(JsonPointer)`\n#2241: Add `PropertyNamingStrategy.LOWER_DOT_CASE` for dot-delimited names\n (contributed by zenglian@github.com)\n#2251: Getter that returns an abstract collection breaks a delegating `@JsonCreator`\n#2265: Inconsistent handling of Collections$UnmodifiableList vs Collections$UnmodifiableRandomAccessList\n#2273: Add basic Java 9+ module info\n#2280: JsonMerge not work with constructor args\n (reported by Deblock T)\n#2309: READ_ENUMS_USING_TO_STRING doesn't support null values\n (reported, fix suggested by Ben A)\n#2311: Unnecessary MultiView creation for property writers\n (suggested by Manuel H)\n#2331: `JsonMappingException` through nested getter with generic wildcard return type\n (reported by sunchezz89@github)\n#2336: `MapDeserializer` can not merge `Map`s with polymorphic values\n (reported by Robert G)\n#2338: Suboptimal return type for `JsonNode.withArray()`\n (reported by Victor N)\n#2339: Suboptimal return type for `ObjectNode.set()`\n (reported by Victor N)\n#2348: Add sanity checks for `ObjectMapper.readXXX()` methods\n (requested by ebundy@github)\n#2349: Add option `DefaultTyping.EVERYTHING` to support Kotlin data classes\n#2357: Lack of path on MismatchedInputException\n (suggested by TheEin@github)\n#2378: `@JsonAlias` doesn't work with AutoValue\n (reported by David H)\n#2390: `Iterable` serialization breaks when adding `@JsonFilter` annotation\n (reported by Chris M)\n#2392: `BeanDeserializerModifier.modifyDeserializer()` not applied to custom bean deserializers\n (reported by andreasbaus@github)\n#2393: `TreeTraversingParser.getLongValue()` incorrectly checks `canConvertToInt()`\n (reported by RabbidDog@github)\n#2398: Replace recursion in `TokenBuffer.copyCurrentStructure()` with iteration\n (reported by Sam S)\n#2415: Builder-based POJO deserializer should pass builder instance, not type,\n  to `handleUnknownVanilla()`\n (proposed by Vladimir T, follow up to #822)\n#2416: Optimize `ValueInstantiator` construction for default `Collection`, `Map` types\n#2422: `scala.collection.immutable.ListMap` fails to serialize since 2.9.3\n (reported by dejanlokar1@github)\n#2424: Add global config override setting for `@JsonFormat.lenient()`\n#2428: Use \"activateDefaultTyping\" over \"enableDefaultTyping\" in 2.10 with new methods\n#2430: Change `ObjectMapper.valueToTree()` to convert `null` to `NullNode`\n#2432: Add support for module bundles\n (contributed by Marcos P)\n#2433: Improve `NullNode.equals()`\n (suggested by David B)\n#2442: `ArrayNode.addAll()` adds raw `null` values which cause NPE on `deepCopy()`\n  and `toString()`\n (reported, fix contributed by Hesham M)\n#2446: Java 11: Unable to load JDK7 types (annotations, java.nio.file.Path): no Java7 support added\n (reported by David C)\n#2451: Add new `JsonValueFormat` value, `UUID`\n#2453: Add `DeserializationContext.readTree(JsonParser)` convenience method\n#2458: `Nulls` property metadata ignored for creators\n (reported  by XakepSDK@github)\n#2466: Didn't find class \"java.nio.file.Path\" below Android api 26\n (reported by KevynBct@github)\n#2467: Accept `JsonTypeInfo.As.WRAPPER_ARRAY` with no second argument to\n  deserialize as \"null value\"\n (contributed by Martin C)\n\n[2.9.10.x micro-patches omitted]\n\n2.9.10 (21-Sep-2019)\n\n#2331: `JsonMappingException` through nested getter with generic wildcard return type\n#2334: Block one more gadget type (CVE-2019-12384)\n#2341: Block one more gadget type (CVE-2019-12814)\n#2374: `ObjectMapper. getRegisteredModuleIds()` throws NPE if no modules registered\n#2387: Block yet another deserialization gadget (CVE-2019-14379)\n#2389: Block yet another deserialization gadget (CVE-2019-14439)\n (reported by xiexq)\n#2404: FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY setting ignored when\n  creator properties are buffered\n (contributed by Joe B)\n#2410: Block one more gadget type (HikariCP, CVE-2019-14540)\n  (reported by iSafeBlue@github / blue@ixsec.org)\n#2420: Block one more gadget type (cxf-jax-rs, no CVE allocated yet)\n  (reported by crazylirui@gmail.com)\n#2449: Block one more gadget type (HikariCP, CVE-2019-14439 / CVE-2019-16335)\n  (reported by kingkk)\n#2460: Block one more gadget type (ehcache, CVE-2019-17267)\n  (reported by Fei Lu)\n#2462: Block two more gadget types (commons-configuration/-2)\n#2469: Block one more gadget type (xalan2)\n\n2.9.9 (16-May-2019)\n\n#1408: Call to `TypeVariable.getBounds()` without synchronization unsafe on some platforms\n (reported by Thomas K)\n#2221: `DeserializationProblemHandler.handleUnknownTypeId()` returning `Void.class`,\n  enableDefaultTyping causing NPE\n (reported by MeyerNils@github)\n#2251: Getter that returns an abstract collection breaks a delegating `@JsonCreator`\n#2265: Inconsistent handling of Collections$UnmodifiableList vs Collections$UnmodifiableRandomAccessList\n (reported by Joffrey B)\n#2299: Fix for using jackson-databind in an OSGi environment under Android\n (contributed by Christoph F)\n#2303: Deserialize null, when java type is \"TypeRef of TypeRef of T\", does not provide \"Type(Type(null))\"\n (reported by Cyril M)\n#2324: `StringCollectionDeserializer` fails with custom collection\n (reported byb Daniil B)\n#2326: Block one more gadget type (CVE-2019-12086)\n- Prevent String coercion of `null` in `WritableObjectId` when calling `JsonGenerator.writeObjectId()`,\n  mostly relevant for formats like YAML that have native Object Ids\n\n2.9.8 (15-Dec-2018)\n\n#1662: `ByteBuffer` serialization is broken if offset is not 0\n (reported by j-baker@github)\n#2155: Type parameters are checked for equality while isAssignableFrom expected\n (reported by frankfiedler@github)\n#2167: Large ISO-8601 Dates are formatted/serialized incorrectly\n#2181: Don't re-use dynamic serializers for property-updating copy constructors\n (suggested by Pavel N)\n#2183: Base64 JsonMappingException: Unexpected end-of-input\n (reported by ViToni@github)\n#2186: Block more classes from polymorphic deserialization (CVE-2018-19360,\n  CVE-2018-19361, CVE-2018-19362)\n (reported by Guixiong Wu)\n#2197: Illegal reflective access operation warning when using `java.lang.Void`\n  as value type\n (reported by Ren\u00e9 K)\n#2202: StdKeyDeserializer Class method _getToStringResolver is slow causing Thread Block\n (reported by sushobhitrajan@github)\n\n2.9.7 (19-Sep-2018)\n\n#2060: `UnwrappingBeanPropertyWriter` incorrectly assumes the found serializer is\n  of type `UnwrappingBeanSerializer`\n (reported by Petar T)\n#2064: Cannot set custom format for `SqlDateSerializer` globally\n (reported by Brandon K)\n#2079: NPE when visiting StaticListSerializerBase\n (reported by WorldSEnder@github)\n#2082: `FactoryBasedEnumDeserializer` should be cachable\n#2088: `@JsonUnwrapped` fields are skipped when using `PropertyBasedCreator` if\n  they appear after the last creator property\n (reported, fix contributed by 6bangs@github)\n#2096: `TreeTraversingParser` does not take base64 variant into account\n (reported by tangiel@github)\n#2097: Block more classes from polymorphic deserialization (CVE-2018-14718\n  - CVE-2018-14721)\n#2109: Canonical string for reference type is built incorrectly\n (reported by svarzee@github)\n#2120: `NioPathDeserializer` improvement\n (contributed by Semyon L)\n#2128: Location information included twice for some `JsonMappingException`s\n\n2.9.6 (12-Jun-2018)\n\n#955: Add `MapperFeature.USE_BASE_TYPE_AS_DEFAULT_IMPL` to use declared base type\n   as `defaultImpl` for polymorphic deserialization\n  (contributed by mikeldpl@github)\n#1328: External property polymorphic deserialization does not work with enums\n#1565: Deserialization failure with Polymorphism using JsonTypeInfo `defaultImpl`,\n  subtype as target\n#1964: Failed to specialize `Map` type during serialization where key type\n  incompatibility overidden via \"raw\" types\n (reported by ptirador@github)\n#1990: MixIn `@JsonProperty` for `Object.hashCode()` is ignored\n (reported by Freddy B)\n#1991: Context attributes are not passed/available to custom serializer if object is in POJO\n (reported by dletin@github)\n#1998: Removing \"type\" attribute with Mixin not taken in account if\n  using ObjectMapper.copy()\n (reported by SBKila@github)\n#1999: \"Duplicate property\" issue should mention which class it complains about\n (reported by Ondrej Z)\n#2001: Deserialization issue with `@JsonIgnore` and `@JsonCreator` + `@JsonProperty`\n  for same property name\n (reported, fix contributed by Jakub S)\n#2015: `@Jsonsetter with Nulls.SKIP` collides with\n  `DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL` when parsing enum\n (reported by ndori@github)\n#2016: Delegating JsonCreator disregards JsonDeserialize info\n (reported by Carter K)\n#2019: Abstract Type mapping in 2.9 fails when multiple modules are registered\n (reported by asger82@github)\n#2021: Delegating JsonCreator disregards `JsonDeserialize.using` annotation\n#2023: `JsonFormat.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` not working\n  with `null` coercion with `@JsonSetter`\n#2027: Concurrency error causes `IllegalStateException` on `BeanPropertyMap`\n (reported by franboragina@github)\n#2032: CVE-2018-11307: Potential information exfiltration with default typing, serialization gadget from MyBatis\n (reported by Guixiong Wu)\n#2034: Serialization problem with type specialization of nested generic types\n (reported by Reinhard P)\n#2038: JDK Serializing and using Deserialized `ObjectMapper` loses linkage\n  back from `JsonParser.getCodec()`\n (reported by Chetan N)\n#2051: Implicit constructor property names are not renamed properly with\n  `PropertyNamingStrategy`\n#2052: CVE-2018-12022: Block polymorphic deserialization of types from Jodd-db library\n (reported by Guixiong Wu)\n#2058: CVE-2018-12023: Block polymorphic deserialization of types from Oracle JDBC driver\n (reported by Guixiong Wu)\n\n2.9.5 (26-Mar-2018)\n\n#1911: Allow serialization of `BigDecimal` as String, using\n  `@JsonFormat(shape=Shape.String)`, config overrides\n (suggested by cen1@github)\n#1912: `BeanDeserializerModifier.updateBuilder()` not work to set custom\n  deserializer on a property (since 2.9.0)\n (contributed by Deblock T)\n#1931: Two more `c3p0` gadgets to exploit default typing issue\n (reported by lilei@venusgroup.com.cn)\n#1932: `EnumMap` cannot deserialize with type inclusion as property\n#1940: `Float` values with integer value beyond `int` lose precision if\n  bound to `long`\n (reported by Aniruddha M)\n#1941: `TypeFactory.constructFromCanonical()` throws NPE for Unparameterized\n  generic canonical strings\n (reported by ayushgp@github)\n#1947: `MapperFeature.AUTO_DETECT_XXX` do not work if all disabled\n (reported by Timur S)\n#1977: Serializing an Iterator with multiple sub-types fails after upgrading to 2.9.x\n (reported by ssivanand@github)\n#1978: Using @JsonUnwrapped annotation in builderdeserializer hangs in infinite loop\n (reported by roeltje25@github)\n\n2.9.4 (24-Jan-2018)\n\n#1382: `@JsonProperty(access=READ_ONLY)` unxepected behaviour with `Collections`\n (reported by hexfaker@github)\n#1673: Serialising generic value classes via Reference Types (like Optional) fails\n  to include type information\n (reported by Pier-Luc W)\n#1729: Integer bounds verification when calling `TokenBuffer.getIntValue()`\n (reported by Kevin G)\n#1853: Deserialise from Object (using Creator methods) returns field name instead of value\n (reported by Alexander S)\n#1854: NPE deserializing collection with `@JsonCreator` and `ACCEPT_CASE_INSENSITIVE_PROPERTIES`\n (reported by rue-jw@github)\n#1855: Blacklist for more serialization gadgets (dbcp/tomcat, spring, CVE-2017-17485)\n#1859: Issue handling unknown/unmapped Enum keys\n (reported by remya11@github)\n#1868: Class name handling for JDK unmodifiable Collection types changed\n  (reported by Rob W)\n#1870: Remove `final` on inherited methods in `BuilderBasedDeserializer` to allow\n  overriding by subclasses\n  (requested by Ville K)\n#1878: `@JsonBackReference` property is always ignored when deserializing since 2.9.0\n (reported by reda-alaoui@github)\n#1895: Per-type config override \"JsonFormat.Shape.OBJECT\" for Map.Entry not working\n (reported by mcortella@github)\n#1899: Another two gadgets to exploit default typing issue in jackson-databind\n (reported by OneSourceCat@github)\n#1906: Add string format specifier for error message in `PropertyValueBuffer`\n (reported by Joe S)\n#1907: Remove `getClass()` from `_valueType` argument for error reporting\n (reported by Joe S)\n\n2.9.3 (09-Dec-2017)\n\n#1604: Nested type arguments doesn't work with polymorphic types\n#1794: `StackTraceElementDeserializer` not working if field visibility changed\n (reported by dsingley@github)\n#1799: Allow creation of custom sub-types of `NullNode`, `BooleanNode`, `MissingNode`\n#1804: `ValueInstantiator.canInstantiate()` ignores `canCreateUsingArrayDelegate()`\n (reported byb henryptung@github)\n#1807: Jackson-databind caches plain map deserializer and use it even map has `@JsonDeserializer`\n (reported by lexas2509@github)\n#1823: ClassNameIdResolver doesn't handle resolve Collections$SingletonMap & Collections$SingletonSet\n (reported by Peter J)\n#1831: `ObjectReader.readValue(JsonNode)` does not work correctly with polymorphic types,\n  value to update\n (reported by basmastr@github)\n#1835: ValueInjector break from 2.8.x to 2.9.x\n (repoted by kinigitbyday@github)\n#1842: `null` String for `Exception`s deserialized as String \"null\" instead of `null`\n (reported by ZeleniJure@github)\n#1843: Include name of unsettable property in exception from `SetterlessProperty.set()`\n (suggested by andreh7@github)\n#1844: Map \"deep\" merge only adds new items, but not override existing values\n (reported by alinakovalenko@github)\n\n2.9.2 (14-Oct-2017)\n\n(possibly) #1756: Deserialization error with custom `AnnotationIntrospector`\n (reported by Daniel N)\n#1705: Non-generic interface method hides type resolution info from generic base class\n  (reported by Tim B)\n NOTE: was originally reported fixed in 2.9.1 -- turns out it wasn't.\n#1767: Allow `DeserializationProblemHandler` to respond to primitive types\n (reported by nhtzr@github)\n#1768: Improve `TypeFactory.constructFromCanonical()` to work with\n  `java.lang.reflect.Type.getTypeName()' format\n (suggested by Lu\u00eds C)\n#1771: Pass missing argument for string formatting in `ObjectMapper`\n (reported by Nils B)\n#1788: `StdDateFormat._parseAsISO8601()` does not parse \"fractional\" timezone correctly\n#1793: `java.lang.NullPointerException` in `ObjectArraySerializer.acceptJsonFormatVisitor()`\n  for array value with `@JsonValue`\n (reported by Vincent D)\n\n2.9.1 (07-Sep-2017)\n\n#1725: `NPE` In `TypeFactory. constructParametricType(...)`\n (reported by ctytgat@github)\n#1730: InvalidFormatException` for `JsonToken.VALUE_EMBEDDED_OBJECT`\n (reported by zigzago@github)\n#1744: StdDateFormat: add option to serialize timezone offset with a colon\n (contributed by Bertrand R)\n#1745: StdDateFormat: accept and truncate millis larger than 3 digits\n (suggested by Bertrand R)\n#1749: StdDateFormat: performance improvement of '_format(..)' method \n (contributed by Bertrand R)\n#1759: Reuse `Calendar` instance during parsing by `StdDateFormat`\n (contributed by Bertrand R)\n- Fix `DelegatingDeserializer` constructor to pass `handledType()` (and\n  not type of deserializer being delegated to!)\n- Add `Automatic-Module-Name` (\"com.fasterxml.jackson.databind\") for JDK 9 module system\n\n2.9.0 (30-Jul-2017)\n\n#219: SqlDateSerializer does not obey SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS\n (reported by BrentDouglas@github)\n#265: Add descriptive exception for attempts to use `@JsonWrapped` via Creator parameter\n#291: @JsonTypeInfo with As.EXTERNAL_PROPERTY doesn't work if external type property\n  is referenced more than once\n (reported by Starkom@github)\n#357: StackOverflowError with contentConverter that returns array type\n (reported by Florian S)\n#383: Recursive `@JsonUnwrapped` (`child` with same type) fail: \"No _valueDeserializer assigned\"\n (reported by tdavis@github)\n#403: Make FAIL_ON_NULL_FOR_PRIMITIVES apply to primitive arrays and other types that wrap primitives\n (reported by Harleen S)\n#476: Allow \"Serialize as POJO\" using `@JsonFormat(shape=Shape.OBJECT)` class annotation\n#507: Support for default `@JsonView` for a class\n (suggested by Mark W)\n#687: Exception deserializing a collection @JsonIdentityInfo and a property based creator\n#865: `JsonFormat.Shape.OBJECT` ignored when class implements `Map.Entry`\n#888: Allow specifying custom exclusion comparator via `@JsonInclude`,\n  using `JsonInclude.Include.CUSTOM`\n#994: `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS` only works for POJOs, Maps\n#1029: Add a way to define property name aliases\n#1035: `@JsonAnySetter` assumes key of `String`, does not consider declared type.\n (reported by Michael F)\n#1060: Allow use of `@JsonIgnoreProperties` for POJO-valued arrays, `Collection`s\n#1106: Add `MapperFeature.ALLOW_COERCION_OF_SCALARS` for enabling/disabling coercions\n#1284: Make `StdKeySerializers` use new `JsonGenerator.writeFieldId()` for `int`/`long` keys\n#1320: Add `ObjectNode.put(String, BigInteger)`\n (proposed by Jan L)\n#1341: `DeserializationFeature.FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY`\n (contributed by Connor K)\n#1347: Extend `ObjectMapper.configOverrides()` to allow changing visibility rules\n#1356: Differentiate between input and code exceptions on deserialization\n (suggested by Nick B)\n#1369: Improve `@JsonCreator` detection via `AnnotationIntrospector`\n by passing `MappingConfig`\n#1371: Add `MapperFeature.INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES` to allow\n disabling use of `@CreatorProperties` as explicit `@JsonCreator` equivalent\n#1376: Add ability to disable JsonAnySetter/JsonAnyGetter via mixin\n (suggested by brentryan@github)\n#1399: Add support for `@JsonMerge` to allow \"deep update\"\n#1402: Use `@JsonSetter(nulls=...)` to specify handling of `null` values during deserialization\n#1406: `ObjectMapper.readTree()` methods do not return `null` on end-of-input\n (reported by Fabrizio C)\n#1407: `@JsonFormat.pattern` is ignored for `java.sql.Date` valued properties\n (reported by sangpire@github)\n#1415: Creating CollectionType for non generic collection class broken\n#1428: Allow `@JsonValue` on a field, not just getter\n#1434: Explicitly pass null on invoke calls with no arguments\n (contributed by Emiliano C)\n#1433: `ObjectMapper.convertValue()` with null does not consider null conversions\n  (`JsonDeserializer.getNullValue()`)\n (contributed by jdmichal@github)\n#1440: Wrong `JsonStreamContext` in `DeserializationProblemHandler` when reading\n  `TokenBuffer` content\n (reported by Patrick G)\n#1444: Change `ObjectMapper.setSerializationInclusion()` to apply to content inclusion too\n#1450: `SimpleModule.addKeyDeserializer()' should throw `IllegalArgumentException` if `null`\n  reference of `KeyDeserializer` passed\n (suggested by PawelJagus@github)\n#1454: Support `@JsonFormat.lenient` for `java.util.Date`, `java.util.Calendar`\n#1474: Replace use of `Class.newInstance()` (deprecated in Java 9) with call via Constructor\n#1480: Add support for serializing `boolean`/`Boolean` as number (0 or 1)\n (suggested by jwilmoth@github)\n#1520: Case insensitive enum deserialization with `MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS`\n (contributed by Ana-Eliza B)\n#1522: Global `@JsonInclude(Include.NON_NULL)` for all properties with a specific type\n (contributed by Carsten W)\n#1544: EnumMapDeserializer assumes a pure EnumMap and does not support EnumMap derived classes\n (reported by Lyor G)\n#1550: Unexpected behavior with `@JsonInclude(JsonInclude.Include.NON_EMPTY)` and\n `java.util.Date` serialization\n#1551: `JsonMappingException` with polymorphic type and `JsonIdentityInfo` when basic type is abstract\n (reported by acm073@github)\n#1552: Map key converted to byte array is not serialized as base64 string\n (reported by nmatt@github)\n#1554: Support deserialization of `Shape.OBJECT` (\"as POJO\") for `Map`s (and map-like types)\n#1556: Add `ObjectMapper.updateValue()` method to update instance with given overrides\n (suggested by syncer@github)\n#1583: Add a `DeserializationFeature.FAIL_ON_TRAILING_TOKENS` to force reading of the\n  whole input as single value\n#1592: Add support for handling primitive/discrepancy problem with type refinements\n#1605: Allow serialization of `InetAddress` as simple numeric host address\n (requested by Jared J)\n#1616: Extraneous type id mapping added for base type itself\n#1619: By-pass annotation introspection for array types\n#1637: `ObjectReader.at()` with `JsonPointer` stops after first collection\n (reported by Chris P)\n#1653: Convenience overload(s) for ObjectMapper#registerSubtypes\n#1655: `@JsonAnyGetter` uses different `bean` parameter in `SimpleBeanPropertyFilter`\n (reported by georgeflugq@github)\n#1678: Rewrite `StdDateFormat` ISO-8601 handling functionality\n#1684: Rewrite handling of type ids to let `JsonGenerator` handle (more of) details\n#1688: Deserialization fails for `java.nio.file.Path` implementations when default typing\n  enabled\n (reported by Christian B)\n#1690: Prevent use of quoted number (index) for Enum deserialization via\n  `MapperFeature.ALLOW_COERCION_OF_SCALARS`\n (requested by magdel@github)\n\n2.8.11.4 (25-Jul-2019)\n\n#2334: Block one more gadget type (CVE-2019-12384)\n#2341: Block one more gadget type (CVE-2019-12814)\n#2387: Block one more gadget type (CVE-2019-14379)\n#2389: Block one more gadget type (CVE-2019-14439)\n (reported by xiexq)\n\n2.8.11.3 (23-Nov-2018)\n\n#2326: Block one more gadget type (CVE-2019-12086)\n (contributed by MaximilianTews@github)\n\n2.8.11.2 (08-Jun-2018)\n\n#1941: `TypeFactory.constructFromCanonical()` throws NPE for Unparameterized\n  generic canonical strings\n (reported by ayushgp@github)\n#2032: CVE-2018-11307: Potential information exfiltration with default typing, serialization gadget from MyBatis\n (reported by Guixiong Wu)\n#2052: CVE-2018-12022: Block polymorphic deserialization of types from Jodd-db library\n (reported by Guixiong Wu)\n#2058: CVE-2018-12023: Block polymorphic deserialization of types from Oracle JDBC driver\n (reported by Guixiong Wu)\n\n2.8.11.1 (11-Feb-2018)\n\n#1872: `NullPointerException` in `SubTypeValidator.validateSubType` when\n  validating Spring interface\n (reported by Rob W)\n#1899: Another two gadgets to exploit default typing issue (CVE-2018-5968)\n (reported by OneSourceCat@github)\n#1931: Two more `c3p0` gadgets to exploit default typing issue (c3p0, CVE-2018-7489)\n\n2.8.11 (24-Dec-2017)\n\n#1604: Nested type arguments doesn't work with polymorphic types\n#1680: Blacklist couple more types for deserialization\n#1767: Allow `DeserializationProblemHandler` to respond to primitive types\n (reported by nhtzr@github)\n#1768: Improve `TypeFactory.constructFromCanonical()` to work with\n  `java.lang.reflect.Type.getTypeName()` format\n#1804: `ValueInstantiator.canInstantiate()` ignores `canCreateUsingArrayDelegate()`\n (reported by henryptung@github)\n#1807: Jackson-databind caches plain map deserializer and use it even map has `@JsonDeserializer`\n (reported by lexas2509@github)\n#1855: Blacklist for more serialization gadgets (dbcp/tomcat, spring / CVE-2017-17485)\n\n2.8.10 (24-Aug-2017)\n\n#1657: `StdDateFormat` deserializes dates with no tz/offset as UTC instead of\n  configured timezone\n (reported by Bertrand R)\n#1680: Blacklist couple more types for deserialization\n#1658: Infinite recursion when deserializing a class extending a Map,\n  with a recursive value type\n (reported by Kevin G)\n#1679: `StackOverflowError` in Dynamic `StdKeySerializer`\n#1711: Delegating creator fails to work for binary data (`byte[]`) with\n binary formats (CBOR, Smile)\n#1735: Missing type checks when using polymorphic type ids\n (reported by Lukas Euler)\n#1737: Block more JDK types from polymorphic deserialization (CVE 2017-15095)\n\n2.8.9 (12-Jun-2017)\n\n#1595: `JsonIgnoreProperties.allowSetters` is not working in Jackson 2.8\n (reported by Javy L)\n#1597: Escape JSONP breaking characters\n (contributed by Marco C)\n#1629: `FromStringDeserializer` ignores registered `DeserializationProblemHandler`\n  for `java.util.UUID`\n (reported by Andrew J)\n#1642: Support `READ_UNKNOWN_ENUM_VALUES_AS_NULL` with `@JsonCreator`\n (contributed by Joe L)\n#1647: Missing properties from base class when recursive types are involved\n (reported by Slobodan P)\n#1648: `DateTimeSerializerBase` ignores configured date format when creating contextual\n (reported by Bertrand R)\n#1651: `StdDateFormat` fails to parse 'zulu' date when TimeZone other than UTC\n (reported by Bertrand R)\n\n2.8.8.1 (19-Apr-2017)\n\n#1585: Invoke ServiceLoader.load() inside of a privileged block when loading\n  modules using `ObjectMapper.findModules()`\n (contributed by Ivo S)\n#1599: Jackson Deserializer security vulnerability (CVE-2017-7525)\n (reported by ayound@github)\n#1607: @JsonIdentityReference not used when setup on class only\n (reported by vboulaye@github)\n\n2.8.8 (05-Apr-2017)\n\n(partial) #994: `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS` only works for POJOs, Maps\n#1345: `@JsonProperty(access = READ_ONLY)` together with generated constructor (Lombok) causes\n exception: \"Could not find creator property with name ...\"\n (reported by Raniz85@github)\n#1533: `AsPropertyTypeDeserializer` ignores `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT`\n#1543: JsonFormat.Shape.NUMBER_INT does not work when defined on enum type in 2.8\n (reported by Alex P)\n#1570: `Enum` key for `Map` ignores `SerializationFeature.WRITE_ENUMS_USING_INDEX`\n (reported by SolaKun@github)\n#1573: Missing properties when deserializing using a builder class with a non-default\n  constructor and a mutator annotated with `@JsonUnwrapped`\n (reported by Joshua J)\n#1575: Problem with `@JsonIgnoreProperties` on recursive property (regression in 2.8)\n (reported by anujkumar04@github)\n- Minor fix to creation of `PropertyMetadata`, had one path that could lead to NPE\n\n2.8.7 (21-Feb-2017)\n\n#935: `@JsonProperty(access = Access.READ_ONLY)` - unexpected behaviour\n#1317: '@JsonIgnore' annotation not working with creator properties, serialization\n\n2.8.6 (12-Jan-2017)\n\n#349: @JsonAnySetter with @JsonUnwrapped: deserialization fails with arrays\n (reported by hdave@github)\n#1388: `@JsonIdentityInfo`: id has to be the first key in deserialization when\n  deserializing with `@JsonCreator`\n (reported by moodysalem@github)\n#1425: `JsonNode.binaryValue()` ignores illegal character if it's the last one\n (reported by binoternary@github)\n#1453: `UntypedObjectDeserializer` does not retain `float` type (over `double`)\n#1456: `TypeFactory` type resolution broken in 2.7 for generic types\n   when using `constructType` with context\n#1473: Add explicit deserializer for `StringBuilder` due to Java 9 changes\n#1493: `ACCEPT_CASE_INSENSITIVE_PROPERTIES` fails with `@JsonUnwrapped`\n\n2.8.5 (14-Nov-2016)\n\n#1417: Further issues with `@JsonInclude` with `NON_DEFAULT`\n#1421: ACCEPT_SINGLE_VALUE_AS_ARRAY partially broken in 2.7.x, 2.8.x\n#1429: `StdKeyDeserializer` can erroneously use a static factory method\n  with more than one argument\n#1432: Off by 1 bug in PropertyValueBuffer\n (reported by Kevin D)\n#1438: `ACCEPT_CASE_INSENSITIVE_PROPERTIES` is not respected for creator properties\n (reported by Jayson M)\n#1439: NPE when using with filter id, serializing `java.util.Map` types\n#1441: Failure with custom Enum key deserializer, polymorphic types\n (reported by Nathanial O)\n#1445: Map key deserializerModifiers ignored\n (reported by alfonsobonso@github)\n- Improvements to #1411 fix to ensure consistent `null` key handling\n\n2.8.4 (14-Oct-2016)\n\n#466: Jackson ignores Type information when raw return type is BigDecimal or BigInteger \n#1001: Parameter names module gets confused with delegate creator which is a static method\n#1324: Boolean parsing with `StdDeserializer` is too slow with huge integer value\n (reported by pavankumar-parankusam@github)\n#1383: Problem with `@JsonCreator` with 1-arg factory-method, implicit param names\n#1384: `@JsonDeserialize(keyUsing = ...)` does not work correctly together with\n  DefaultTyping.NON_FINAL\n (reported by Oleg Z)\n#1385: Polymorphic type lost when using `@JsonValue`\n (reported by TomMarkuske@github)\n#1389 Problem with handling of multi-argument creator with Enums\n (fix contributed by Pavel P)\n#1392: Custom UnmodifiableSetMixin Fails in Jackson 2.7+ but works in Jackson 2.6\n (reported by Rob W)\n#1395: Problems deserializing primitive `long` field while using `TypeResolverBuilder`\n (reported by UghZan3@github)\n#1403: Reference-chain hints use incorrect class-name for inner classes\n (reported by Josh G)\n#1411: MapSerializer._orderEntries should check for null keys\n (reported by J\u00f6rn H)\n\n2.8.3 (17-Sep-2016)\n\n#1351: `@JsonInclude(NON_DEFAULT)` doesn't omit null fields\n (reported by Gili T)\n#1353: Improve error-handling for `java.net.URL` deserialization\n#1361: Change `TokenBuffer` to use new `writeEmbeddedObject()` if possible\n\n2.8.2 (30-Aug-2016)\n\n#1315: Binding numeric values can BigDecimal lose precision\n (reported by Andrew S)\n#1327: Class level `@JsonInclude(JsonInclude.Include.NON_EMPTY)` is ignored\n (reported by elruwen@github)\n#1335: Unconditionally call `TypeIdResolver.getDescForKnownTypeIds`\n (contributed by Chris J-Y)\n\n2.8.1 (20-Jul-2016)\n\n#1256: `Optional.empty()` not excluded if property declared with type `Object`\n#1288: Type id not exposed for `JsonTypeInfo.As.EXTERNAL_PROPERTY` even when `visible` set to `true`\n (reported by libetl@github)\n#1289: Optimize construction of `ArrayList`, `LinkedHashMap` instances\n#1291: Backward-incompatible behaviour of 2.8: deserializing enum types\n   with two static factory methods fail by default\n#1297: Deserialization of generic type with Map.class\n (reported by Arek G)\n#1302: NPE for `ResolvedRecursiveType` in 2.8.0 due to caching\n\n2.8.0 (04-Jul-2016)\n\n#621: Allow definition of \"ignorable types\" without annotation (using\n  `Mapper.configOverride(type).setIsIgnoredType(true)`\n#867: Support `SerializationFeature.WRITE_EMPTY_JSON_ARRAYS ` for `JsonNode`\n#903: Add `JsonGenerator` reference to `SerializerProvider`\n#931: Add new method in `Deserializers.Base` to support `ReferenceType`\n#960: `@JsonCreator` not working on a factory with no arguments for an enum type\n (reported by Artur J)\n#990: Allow failing on `null` values for creator (add \n  `DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES`)\n (contributed by mkokho@github)\n#999: External property is not deserialized\n (reported by Aleksandr O)\n#1017: Add new mapping exception type ('InvalidTypeIdException') for subtype resolution errors\n (suggested by natnan@github)\n#1028: Ignore USE_BIG_DECIMAL_FOR_FLOATS for NaN/Infinity\n (reported by Vladimir K, lightoze@github)\n#1047: Allow use of `@JsonAnySetter` on a Map-valued field, no need for setter\n#1082: Can not use static Creator factory methods for `Enum`s, with JsonCreator.Mode.PROPERTIES\n (contributed by Lokesh K)\n#1084: Change `TypeDeserializerBase` to take `JavaType` for `defaultImpl`, NOT `Class`\n#1126: Allow deserialization of unknown Enums using a predefined value\n (contributed by Alejandro R)\n#1136: Implement `TokenBuffer.writeEmbeddedObject(Object)`\n (suggested by Gregoire C, gcxRun@github)\n#1165: CoreXMLDeserializers does not handle time-only XMLGregorianCalendars\n (reported, contributed fix by Ross G)\n#1181: Add the ability to specify the initial capacity of the ArrayNode\n (suggested by Matt V, mveitas@github)\n#1184: Allow overriding of `transient` with explicit inclusion with `@JsonProperty`\n (suggested by Maarten B)\n#1187: Refactor `AtomicReferenceDeserializer` into `ReferenceTypeDeserializer`\n#1204: Add a convenience accessor `JavaType.hasContentType()` (true for container or reference type)\n#1206: Add \"anchor type\" member for `ReferenceType`\n#1211: Change `JsonValueSerializer` to get `AnnotatedMethod`, not \"raw\" method\n#1217: `@JsonIgnoreProperties` on Pojo fields not working for deserialization\n (reported by Lokesh K)\n#1221: Use `Throwable.addSuppressed()` directly and/or via try-with-resources\n#1232: Add support for `JsonFormat.Feature.ACCEPT_CASE_INSENSITIVE_PROPERTIES`\n#1233: Add support for `JsonFormat.Feature.WRITE_SORTED_MAP_ENTRIES`\n#1235: `java.nio.file.Path` support incomplete\n (reported by, fix contributed by Benson M)\n#1261: JsonIdentityInfo broken deserialization involving forward references and/or cycles\n (reported by, fix contributed by Ari F)\n#1270: Generic type returned from type id resolver seems to be ignored\n (reported by Benson M)\n#1277: Add caching of resolved generic types for `TypeFactory`\n (requested by Andriy P)\n\n2.7.9.5 (23-Nov-2018)\n\n#2097: Block more classes from polymorphic deserialization (CVE-2018-14718\n  - CVE-2018-14721)\n (reported by Guixiong Wu)\n#2109: Canonical string for reference type is built incorrectly\n (reported by svarzee@github)\n#2186: Block more classes from polymorphic deserialization (CVE-2018-19360,\n  CVE-2018-19361, CVE-2018-19362)\n (reported by Guixiong Wu)\n\n2.7.9 (04-Feb-2017)\n\n#1367: No Object Id found for an instance when using `@ConstructorProperties`\n#1505: @JsonEnumDefaultValue should take precedence over FAIL_ON_NUMBERS_FOR_ENUMS\n (suggested by Stephan S)\n#1506: Missing `KeyDeserializer` for `CharSequence`\n#1513: `MapSerializer._orderEntries()` throws NPE when operating on `ConcurrentHashMap`\n (reported by Sovietaced@github)\n- Simplified processing of class annotations (for `AnnotatedClass`) to try to\n  solve rare concurrency problems with \"root name\" annotations.\n\n2.7.8 (26-Sep-2016)\n\n#877: @JsonIgnoreProperties`: ignoring the \"cause\" property of `Throwable` on GAE\n#1359: Improve `JsonNode` deserializer to create `FloatNode` if parser supports\n#1362: ObjectReader.readValues()` ignores offset and length when reading an array\n (reported by wastevenson@github)\n#1363: The static field ClassUtil.sCached can cause a class loader leak\n (reported by Stuart D)\n#1368: Problem serializing `JsonMappingException` due to addition of non-ignored\n  `processor` property (added in 2.7)\n (reported, suggesed fix by Josh C)\n#1383: Problem with `@JsonCreator` with 1-arg factory-method, implicit param names\n\n2.7.7 (27-Aug-2016)\n\n#1322: EnumMap keys not using enum's `@JsonProperty` values unlike Enum values\n (reported by MichaelChambers@github)\n#1332: Fixed ArrayIndexOutOfBoundException for enum by index deser\n (reported by Max D)\n#1344: Deserializing locale assumes JDK separator (underscore), does not\n  accept RFC specified (hyphen)\n (reported by Jim M)\n\n2.7.6 (23-Jul-2016)\n\n#1215: Problem with type specialization for Maps with `@JsonDeserialize(as=subtype)`\n (reported by brentryan@github)\n#1279: Ensure DOM parsing defaults to not expanding external entities\n#1288: Type id not exposed for `JsonTypeInfo.As.EXTERNAL_PROPERTY` even when `visible` set to `true`\n#1299: Timestamp deserialization error\n (reported by liyuj@github)\n#1301: Problem with `JavaType.toString()` for recursive (self-referential) types\n (reported by Brian P)\n#1307: `TypeWrappedDeserializer` doesn't delegate the `getNullValue()` method to `_deserializer`\n (reported by vfries@github)\n\n2.7.5 (11-Jun-2016)\n\n#1098: DeserializationFeature.FAIL_ON_INVALID_SUBTYPE does not work with\n  `JsonTypeInfo.Id.CLASS`\n (reported by szaccaria@github)\n#1223: `BasicClassIntrospector.forSerialization(...).findProperties` should\n  respect MapperFeature.AUTO_DETECT_GETTERS/SETTERS?\n (reported by William H)\n#1225: `JsonMappingException` should override getProcessor()\n (reported by Nick B)\n\n2.6.7.1 (11-Jul-2017)\n\n#1383: Problem with `@JsonCreator` with 1-arg factory-method, implicit param names\n#1599: Backport the extra safety checks for polymorphic deserialization\n\n2.6.7 (05-Jun-2016)\n\n#1194: Incorrect signature for generic type via `JavaType.getGenericSignature\n#1228: @JsonAnySetter does not deserialize null to Deserializer's NullValue\n (contributed by Eric S)\n#1231: `@JsonSerialize(as=superType)` behavior disallowed in 2.7.4\n (reported by Mark W)\n#1248: `Annotated` returns raw type in place of Generic Type in 2.7.x\n (reported by Andrew J, apjoseph@github)\n#1253: Problem with context handling for `TokenBuffer`, field name\n#1260: `NullPointerException` in `JsonNodeDeserializer`\n (reported by Eric S)\n\n2.7.4 (29-Apr-2016)\n\n#1122: Jackson 2.7 and Lombok: 'Conflicting/ambiguous property name definitions'\n#1178: `@JsonSerialize(contentAs=superType)` behavior disallowed in 2.7\n#1186: SimpleAbstractTypeResolver breaks generic parameters\n (reported by tobiash@github)\n#1189: Converter called twice results in ClassCastException\n (reported by carrino@github)\n#1191: Non-matching quotes used in error message for date parsing\n#1194: Incorrect signature for generic type via `JavaType.getGenericSignature\n#1195: `JsonMappingException` not Serializable due to 2.7 reference to source (parser)\n (reported by mjustin@github)\n#1197: `SNAKE_CASE` doesn't work when using Lombok's `@AllArgsConstructor`\n#1198: Problem with `@JsonTypeInfo.As.EXTERNAL_PROPERTY`, `defaultImpl`, missing type id, NPE\n#1203: `@JsonTypeInfo` does not work correctly for ReferenceTypes like `AtomicReference`\n#1208: treeToValue doesn't handle POJONodes that contain exactly the requested value type\n  (reported by Tom M)\n- Improve handling of custom content (de)serializers for `AtomicReference`\n\n2.7.3 (16-Mar-2016)\n\n#1125: Problem with polymorphic types, losing properties from base type(s)\n#1150: Problem with Object id handling, explicit `null` token\n (reported by Xavi T)\n#1154: @JsonFormat.pattern on dates is now ignored if shape is not explicitely provided\n (reported by Yoann R)\n#1161: `DeserializationFeature.READ_ENUMS_USING_TO_STRING` not dynamically\n  changeable with 2.7\n (reported by asa-git@github)\n- Minor fixes to `AnnotationIntrospector.findEnumValues()` to correct problems with\n  merging of explicit enum value names.\n\n2.7.2 (26-Feb-2016)\n\n#1124: JsonAnyGetter ignores JsonSerialize(contentUsing=...)\n (reported by Jiri M)\n#1128: UnrecognizedPropertyException in 2.7.1 for properties that work with version 2.6.5\n (reported by Roleek@github)\n#1129: When applying type modifiers, don't ignore container types.\n#1130: NPE in `StdDateFormat` hashCode and equals\n (reported by Kazuki S, kazuki43zoo@github)\n#1134: Jackson 2.7 doesn't work with jdk6 due to use of `Collections.emptyIterator()`\n (reported by Timur S, saladinkzn@github)\n\n2.7.1-1 (03-Feb-2016)\n\nSpecial one-off \"micro patch\" for:\n\n#1115: Problems with deprecated `TypeFactory.constructType(type, ctxt)` methods if `ctxt` is `null`\n\n2.7.1 (02-Feb-2016)\n\n#1079: Add back `TypeFactory.constructType(Type, Class)` as \"deprecated\" in 2.7.1\n#1083: Field in base class is not recognized, when using `@JsonType.defaultImpl`\n (reported by Julian H)\n#1095: Prevent coercion of `int` from empty String to `null` if\n  `DeserializationFeature .FAIL_ON_NULL_FOR_PRIMITIVES` is `true`\n (reported by yzmyyff@github)\n#1102: Handling of deprecated `SimpleType.construct()` too minimalistic\n (reported by Thibault K)\n#1109: @JsonFormat is ignored by the DateSerializer unless either a custom pattern\n  or a timezone are specified\n (contributed by Aleks S)\n\n2.7.0 (10-Jan-2016)\n\n#76: Problem handling datatypes Recursive type parameters\n (reported by Aram K)\n#357: StackOverflowError with contentConverter that returns array type\n (reported by Florian S)\n#432: `StdValueInstantiator` unwraps exceptions, losing context\n (reported by Miles K)\n#497: Add new JsonInclude.Include feature to exclude maps after exclusion removes all elements\n#803: Allow use of `StdDateFormat.setLenient()`\n (suggested by raj-ghodke@github)\n#819: Add support for setting `FormatFeature` via `ObjectReader`, `ObjectWriter`\n#857: Add support for java.beans.Transient (requires Java 7)\n (suggested by Thomas M)\n#898: Add `ObjectMapper.getSerializerProviderInstance()`\n#905: Add support for `@ConstructorProperties` (requires Java 7)\n (requested by Jonas K)\n#909: Rename PropertyNamingStrategy CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES as SNAKE_CASE,\n   PASCAL_CASE_TO_CAMEL_CASE as UPPER_CAMEL_CASE\n (suggested by marcottedan@github)\n#915: ObjectMapper default timezone is GMT, should be UTC\n (suggested by Infrag@github)\n#918: Add `MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING`\n (contributed by David H)\n#924: `SequenceWriter.writeAll()` could accept `Iterable`\n (suggested by Jiri-Kremser@github(\n#932: Rewrite ser/deser for `AtomicReference`, based on \"optional\" ser/desers\n#933: Close some gaps to allow using the `tryToResolveUnresolved` flows\n#936: Deserialization into List subtype with JsonCreator no longer works\n (reported by adamjoeldavis@github)\n#948: Support leap seconds, any number of millisecond digits for ISO-8601 Dates.\n (contributed by Jesse W)\n#952: Revert non-empty handling of primitive numbers wrt `NON_EMPTY`; make\n  `NON_DEFAULT` use extended criteria\n#957: Merge `datatype-jdk7` stuff in (java.nio.file.Path handling)\n#959: Schema generation: consider active view, discard non-included properties\n#963: Add PropertyNameStrategy `KEBAB_CASE`\n (requested by Daniel M)\n#978: ObjectMapper#canSerialize(Object.class) returns false even though FAIL_ON_EMPTY_BEANS is disabled\n (reported by Shumpei A)\n#997: Add `MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS`\n#998: Allow use of `NON_DEFAULT` for POJOs without default constructor\n#1000: Add new mapping exception type for enums and UUIDs\n (suggesed by natnan@github)\n#1010: Support for array delegator\n (contributed by Hugo W)\n#1011: Change ObjectWriter::withAttributes() to take a Map with some kind of wildcard types\n (suggested by David B)\n#1043: @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY) does not work on fields\n (reported by fabiolaa@github)\n#1044: Add `AnnotationIntrospector.resolveSetterConflict(...)` to allow custom setter conflict resolution\n (suggested by clydebarrow@github)\n- Make `JsonValueFormat` (self-)serializable, deserializable, to/from valid external\n  value (as per JSON Schema spec)\n\nINCOMPATIBILITIES:\n\n- While unlikely to be problematic, #959 above required an addition of `SerializerProvider`\n  argument for `depositSchemaProperty()` method `BeanProperty` and `PropertyWriter` interfaces\n- JDK baseline now Java 7 (JDK 1.7), from Java 6/JDK 1.6\n\n2.6.6 (05-Apr-2016)\n\n#1088: NPE possibility in SimpleMixinResolver\n (reported by Laird N)\n#1099: Fix custom comparator container node traversal\n (contributed by Daniel N)\n#1108: Jackson not continue to parse after DeserializationFeature.FAIL_ON_INVALID_SUBTYPE error\n (reported by jefferyyuan@github)\n#1112: Detailed error message from custom key deserializer is discarded\n (contributed by Benson M)\n#1120: String value omitted from weirdStringException\n (reported by Benson M)\n#1123: Serializing and Deserializing Locale.ROOT\n (reported by hookumsnivy@github)\n\n2.6.5 (19-Jan-2016)\n\n#1052: Don't generate a spurious NullNode after parsing an embedded object\n (reported by philipa@github)\n#1061: Problem with Object Id and Type Id as Wrapper Object (regression in 2.5.1)\n#1073: Add try-catch around `java.sql` type serializers\n (suggested by claudemt@github)\n#1078: ObjectMapper.copy() still does not preserve _registeredModuleTypes\n (reported by ajonkisz@github)\n\n2.6.4 (07-Dec-2015)\n\n#984: JsonStreamContexts are not build the same way for write.. and convert methods\n (reported by Antibrumm@github)\n#989: Deserialization from \"{}\" to java.lang.Object causes \"out of END_OBJECT token\" error\n (reported by Ievgen P)\n#1003: JsonTypeInfo.As.EXTERNAL_PROPERTY does not work with a Delegate\n (reported by alexwen@github)\n#1005: Synthetic constructors confusing Jackson data binding\n (reported by Jayson M)\n#1013: `@JsonUnwrapped` is not treated as assuming `@JsonProperty(\"\")`\n (reported by David B)\n#1036: Problem with case-insensitive deserialization\n (repoted by Dmitry R)\n- Fix a minor problem with `@JsonNaming` not recognizing default value\n\n2.6.3 (12-Oct-2015)\n\n#749: `EnumMap` serialization ignores `SerializationFeature.WRITE_ENUMS_USING_TO_STRING`\n (reported by scubasau@github)\n#938: Regression: `StackOverflowError` with recursive types that contain `Map.Entry`\n (reported by jloisel@github)\n#939: Regression: DateConversionError in 2.6.x \n (reported by Andreas P, anpieber@github)\n#940: Add missing `hashCode()` implementations for `JsonNode` types that did not have them\n (contributed by Sergio M)\n#941: Deserialization from \"{}\" to ObjectNode field causes \"out of END_OBJECT token\" error\n (reported by Sadayuki F)\n#942: Handle null type id for polymorphic values that use external type id\n (reported by Warren B, stormboy@github)\n#943: Incorrect serialization of enum map key\n (reported by Benson M)\n#944: Failure to use custom deserializer for key deserializer\n (contributed by Benson M)\n#949: Report the offending substring when number parsing fails\n (contributed by Jesse W)\n#965: BigDecimal values via @JsonTypeInfo/@JsonSubTypes get rounded\n (reported by gmjabs@github)\n\n2.6.2 (14-Sep-2015)\n\n#894: When using withFactory on ObjectMapper, the created Factory has a TypeParser\n  which still has the original Factory\n (reported by lufe66@github)\n#899: Problem serializing `ObjectReader` (and possibly `ObjectMapper`)\n#913: ObjectMapper.copy does not preserve MappingJsonFactory features\n (reported, fixed by Daniel W)\n#922: ObjectMapper.copy() does not preserve _registeredModuleTypes\n#928: Problem deserializing External Type Id if type id comes before POJO\n\n2.6.1 (09-Aug-2015)\n\n#873: Add missing OSGi import\n#881: BeanDeserializerBase having issues with non-CreatorProperty properties.\n (reported by dharaburda@github)\n#884: ArrayIndexOutOfBoundException for `BeanPropertyMap` (with ObjectId)\n (reported by alterGauner@github)\n#889: Configuring an ObjectMapper's DateFormat changes time zone\n (reported by Andy W, wilkinsona@github)\n#890: Exception deserializing a byte[] when the target type comes from an annotation\n (reported by gmjabs@github)\n\n2.6.0 (19-Jul-2015)\n\n#77: Allow injection of 'transient' fields\n#95: Allow read-only properties with `@JsonIgnoreProperties(allowGetters=true)`\n#222: EXTERNAL_PROPERTY adds property multiple times and in multiple places\n (reported by Rob E, thatsnotright@github)\n#296: Serialization of transient fields with public getters (add\n    MapperFeature.PROPAGATE_TRANSIENT_MARKER)\n (suggested by Michal L)\n#312: Support Type Id mappings where two ids map to same Class\n#348: ObjectMapper.valueToTree does not work with @JsonRawValue\n (reported by Chris P, pimlottc@github)\n#504: Add `DeserializationFeature.USE_LONG_FOR_INTS`\n (suggested by Jeff S)\n#624: Allow setting external `ClassLoader` to use, via `TypeFactory`\n#649: Make `BeanDeserializer` use new `parser.nextFieldName()` and `.hasTokenId()` methods\n#664: Add `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to prevent coercion of floating point\n numbers int `int`/`long`/`Integer`/`Long`\n (requested by wenzis@github)\n#677: Specifying `Enum` value serialization using `@JsonProperty`\n (requested by Allen C, allenchen1154@github)\n#679: Add `isEmpty()` implementation for `JsonNode` serializers\n#688: Provide a means for an ObjectMapper to discover mixin annotation classes on demand\n (requested by Laird N)\n#689: Add `ObjectMapper.setDefaultPrettyPrinter(PrettyPrinter)`\n (requested by derknorton@github)\n#696: Copy constructor does not preserve `_injectableValues`\n (reported by Charles A)\n#698: Add support for referential types (ReferenceType)\n#700: Cannot Change Default Abstract Type Mapper from LinkedHashMap\n (reported by wealdtech@github)\n#725: Auto-detect multi-argument constructor with implicit names if it is the only visible creator\n#727: Improve `ObjectWriter.forType()` to avoid forcing base type for container types\n#734: Add basic error-recovery for `ObjectReader.readValues()`\n#737: Add support for writing raw values in TokenBuffer\n (suggested by Guillaume S, gsmet@github)\n#740: Ensure proper `null` (as empty) handling for `AtomicReference`\n#741: Pass `DeserializationContext' argument for `JsonDeserializer` methods \"getNullValue()\"\n and \"getEmptyValue()\"\n#743: Add `RawValue` helper type, for piping raw values through `TokenBuffer`\n#756: Disabling SerializationFeature.FAIL_ON_EMPTY_BEANS does not affect `canSerialize()`\n (reported by nickwongdev@github)\n#762: Add `ObjectWriter.withoutRootName()`, `ObjectReader.withoutRootName()`\n#765: `SimpleType.withStaticTyping()` impl incorrect\n#769: Fix `JacksonAnnotationIntrospector.findDeserializer` to return `Object` (as per\n  `AnnotationIntrospector`); similarly for other `findXxx(De)Serializer(...)` methods\n#777: Allow missing build method if its name is empty (\"\")\n (suggested by galdosd@github)\n#781: Support handling of `@JsonProperty.required` for Creator methods\n#787: Add `ObjectMapper setFilterProvider(FilterProvider)` to allow chaining\n (suggested by rgoldberg@githin)\n#790: Add `JsonNode.equals(Comparator<JsonNode>, JsonNode)` to support\n  configurable/external equality comparison\n#794: Add `SerializationFeature.WRITE_DATES_WITH_ZONE_ID` to allow inclusion/exclusion of\n  timezone id for date/time values (as opposed to timezone offset)\n#795: Converter annotation not honored for abstract types\n (reported by myrosia@github)\n#797: `JsonNodeFactory` method `numberNode(long)` produces `IntNode` for small numbers\n#810: Force value coercion for `java.util.Properties`, so that values are `String`s\n#811: Add new option, `JsonInclude.Include.NON_ABSENT` (to support exclusion of\n  JDK8/Guava Optionals)\n#812: Java 8 breaks Class-value annotation properties, wrt generics: need to work around\n#813: Add support for new property of `@JsonProperty.access` to support\n  read-only/write-only use cases\n#820: Add new method for `ObjectReader`, to bind from JSON Pointer position\n (contributed by Jerry Y, islanderman@github)\n#824: Contextual `TimeZone` changes don't take effect wrt `java.util.Date`,\n  `java.util.Calendar` serialization\n#826: Replaced synchronized HashMap with ConcurrentHashMap in TypeDeserializerBase._findDeserializer\n (contributed by Lars P)\n#827: Fix for polymorphic custom map key serializer\n (reported by mjr6140@gitgub)\n#828: Respect DeserializationFeatures.WRAP_EXCEPTIONS in CollectionDeserializer\n (contributed by Steve G, thezerobit@github)\n#840: Change semantics of `@JsonPropertyOrder(alphabetic)` to only count `true` value\n#848: Custom serializer not used if POJO has `@JsonValue`\n#849: Possible problem with `NON_EMPTY` exclusion, `int`s, `Strings`\n#868: Annotations are lost in the case of duplicate methods\n- Remove old cglib compatibility tests; cause problems in Eclipse\n- Add `withFilterId()` method in `JsonSerializer` (demote from `BeanSerializer`)\n\n2.5.5 (07-Dec-2015)\n\n#844: Using JsonCreator still causes invalid path references in JsonMappingException\n (reported by Ian B)\n#852: Accept scientific number notation for quoted numbers too\n#878: serializeWithType on BeanSerializer does not setCurrentValue\n (reported by Chi K, chikim79@github)\n\n2.5.4 (09-Jun-2015)\n\n#676: Deserialization of class with generic collection inside depends on\n  how is was deserialized first time\n (reported by lunaticare@github)\n#771: Annotation bundles ignored when added to Mixin\n (reported by Andrew D)\n#774: NPE from SqlDateSerializer as _useTimestamp is not checked for being null\n (reported by mrowkow@github)\n#785: Add handlings for classes which are available in `Thread.currentThread().getContextClassLoader()`\n (contributed by Charles A)\n#792: Ensure Constructor Parameter annotations are linked with those of Field, Getter, or Setter\n#793: `ObjectMapper.readTree()` does not work with defaultTyping enabled\n (reported by gracefulgopher@github)\n#801: Using `@JsonCreator` cause generating invalid path reference in `JsonMappingException`\n (contributed by Kamil B)\n#815: Presence of PropertyNamingStrategy Makes Deserialization fail\n#816: Allow date-only ISO strings to have no time zone\n (contributed by Andrew G)\n- Fix handling of Enums wrt JSON Schema, when 'toString()' used for serialization\n\n2.5.3 (24-Apr-2015)\n\n#731: XmlAdapter result marshaling error in case of ValueType=Object\n (reported, debugged by Dmitry S)\n#742: Allow deserialization of `null` Object Id (missing already allowed)\n#744: Custom deserializer with parent object update failing\n (reported by migel@github)\n#745: EnumDeserializer.deserializerForCreator fails when used to deserialize a Map key\n (contributed by John M)\n#761: Builder deserializer: in-compatible type exception when return type is super type\n (contributed by Alexey G)\n#766: Fix Infinite recursion (StackOverflowError) when serializing a SOAP object\n (contributed by Alain G)\n\n2.5.2 (29-Mar-2015)\n\n#609: Problem resolving locally declared generic type\n (repoted by Hal H)\n#691: NullSerializer for MapProperty failing when using polymorphic handling\n (reported by Antibrumm@github)\n#703: Multiple calls to ObjectMapper#canSerialize(Object.class) returns different values\n (reported by flexfrank@github)\n#705: JsonAnyGetter doesn't work with JsonSerialize (except with keyUsing)\n (reported by natnan@github)\n#728: TypeFactory#_fromVariable returns unknownType() even though it has enough information\n  to provide a more specific type\n (reported by jkochaniak@github)\n#733: MappingIterator should move past errors or not return hasNext() == true\n (reported by Lorrin N, lorrin@github)\n#738: @JsonTypeInfo non-deterministically ignored in 2.5.1 (concurrency issue)\n (reported by Dylan S, dylanscott@github)\n- Improvement to handling of custom `ValueInstantiator` for delegating mode; no more NPE\n  if `getDelegateCreator()` returns null\n- Refactor `TypedKey` into separate util class\n\n2.5.1 (06-Feb-2015)\n\n#667: Problem with bogus conflict between single-arg-String vs `CharSequence` constructor\n#669: JSOG usage of @JsonTypeInfo and @JsonIdentityInfo(generator=JSOGGenerator.class) fails\n (reported by ericali78@github)\n#671: Adding `java.util.Currency` deserialization support for maps\n (contributed by Alexandre S-C)\n#674: Spring CGLIB proxies not handled as intended\n (reported by Zoltan F)\n#682: Class<?>-valued Map keys not serialized properly\n (reported by Ludevik@github)\n#684: FAIL_ON_NUMBERS_FOR_ENUMS does not fail when integer value is quoted\n (reported by kllp@github)\n#696: Copy constructor does not preserve `_injectableValues`\n (reported by Charles A)\n- Add a work-around in `ISO8601DateFormat` to allow omission of ':' from timezone\n- Bit more work to complete #633\n\n2.5.0 (01-Jan-2015)\n\n#47: Support `@JsonValue` for (Map) key serialization \n#113: Problem deserializing polymorphic types with @JsonCreator\n#165: Add `DeserializationContext.getContextualType()` to let deserializer\n  known the expected type.\n#299: Add `DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS` to allow missing\n  Object Ids (as global default)\n#408: External type id does not allow use of 'visible=true'\n#421: @JsonCreator not used in case of multiple creators with parameter names\n (reported by Lovro P, lpandzic@github)\n#427: Make array and Collection serializers call `JsonGenerator.writeStartArray(int)`\n#521: Keep bundle annotations, prevent problems with recursive annotation types\n (reported by tea-dragon@github)\n#527: Add support for `@JsonInclude(content=Include.NON_NULL)` (and others) for Maps\n#528: Add support for `JsonType.As.EXISTING_PROPERTY`\n (reported by heapifyman@github; implemented by fleebytes@github)\n#539: Problem with post-procesing of \"empty bean\" serializer; was not calling\n  'BeanSerializerModifier.modifySerializer()` for empty beans\n (reported by Fabien R, fabienrenaud@github)\n#540: Support deserializing `[]` as null or empty collection when the java type\n  is a not an object, `DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT`\n (requested by Fabien R, fabienrenaud@github)\n#543: Problem resolving self-referential recursive types\n (reported by ahgittin@github)\n#550: Minor optimization: prune introspection of \"well-known\" JDK types\n#552: Improved handling for ISO-8601 (date) format\n (contributed by Jerome G, geronimo-iia@github)\n#559: Add `getDateFormat()`, `getPropertyNamingStrategy()` in `ObjectMapper`\n#560: @JsonCreator to deserialize BigInteger to Enum\n (requested by gisupp@github)\n#565: Add support for handling `Map.Entry`\n#566: Add support for case-insensitive deserialization (`MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES`)\n (contributed by Michael R)\n#571: Add support in ObjectMapper for custom `ObjectReader`, `ObjectWriter` (sub-classes)\n#572: Override default serialization of Enums\n (requested by herau@github)\n#576: Add fluent API for adding mixins\n (contributed by Adam S, adstro@github)\n#594: `@JsonValue` on enum not used when enum value is a Map key\n (reported by chrylis@github)\n#596: Add support for `@JsonProperty.defaultValue`, exposed via `BeanProperty.getMetadata().getDefaultValue()`\n#597: Improve error messaging for cases where JSON Creator returns null (which\n  is illegal)\n (contributed by Aurelien L)\n#599: Add a simple mechanism for avoiding multiple registrations of the same module\n#607: Allow (re)config of `JsonParser.Feature`s via `ObjectReader`\n#608: Allow (re)config of `JsonGenerator.Feature`s via `ObjectWriter`\n#614: Add a mechanism for using `@JsonCreator.mode` for resolving possible ambiguity between\n  delegating- and property-based creators\n#616: Add `SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS`\n#622: Support for non-scalar ObjectId Reference deserialiazation (like JSOG)\n#623: Add `StdNodeBasedDeserializer`\n#630: Add `KeyDeserializer` for `Class`\n#631: Update `current value` of `JsonParser`, `JsonGenerator` from standard serializers,\n deserializers\n (suggested by Antibrumm@github)\n#633: Allow returning null value from IdResolver to make type information optional\n (requested by Antibrumm@github)\n#634: Add `typeFromId(DatabindContext,String)` in `TypeIdDeserializer`\n#636: `ClassNotFoundException` for classes not (yet) needed during serialization\n (contributed by mspiegel@github)\n#638: Add annotation-based method(s) for injecting properties during serialization\n (using @JsonAppend, VirtualBeanPropertyWriter)\n#647: Deserialization fails when @JsonUnwrapped property contains an object with same property name\n (reported by Konstantin L)\n#653: Jackson doesn't follow JavaBean naming convention (added `MapperFeature.USE_STD_BEAN_NAMING`)\n#654: Add support for (re)configuring `JsonGenerator.setRootValueSeparator()` via `ObjectWriter`\n#655: Add `ObjectWriter.writeValues()` for writing value sequences\n#660: `@JsonCreator`-annotated factory method is ignored if constructor exists\n- Allow use of `Shape.ARRAY` for Enums, as an alias to 'use index'\n- Start using `JsonGenerator.writeStartArray(int)` to help data formats\n  that benefit from knowing number of elements in arrays (and would otherwise\n  need to buffer values to know length)\n- Added new overload for `JsonSerializer.isEmpty()`, to eventually solve #588\n- Improve error messaging (related to [jaxb-annotations#38]) to include known subtype ids.\n\n2.4.6 (23-Apr-2015)\n\n#735: (complete fix) @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n (reported by blackfyre512@github) (regression due to #604)\n$744: Custom deserializer with parent object update fails\n\n2.4.5.1 (26-Mar-2015)\n\nSpecial one-off \"micro patch\" for:\n\n#706: Add support for `@JsonUnwrapped` via JSON Schema module\n#707: Error in getting string representation of an ObjectNode with a float number value\n (reported by @navidqar)\n#735: (partial) @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n\n2.4.5 (13-Jan-2015)\n\n#635: Reduce cachability of `Map` deserializers, to avoid problems with per-property config changes\n    (regression due to #604)\n#656: `defaultImpl` configuration is ignored for `WRAPPER_OBJECT`\n- Solve potential cyclic-resolution problem for `UntypedObjectDeserializer`\n\n2.4.4 (24-Nov-2014)\n\n(jackson-core)#158: Setter confusion on assignable types\n (reported by tsquared2763@github)\n#245: Calls to ObjectMapper.addMixInAnnotations() on an instance returned by ObjectMapper.copy()\n don't work\n (reported by Erik D)\n#580: delegate deserializers choke on a (single) abstract/polymorphic parameter\n (reported by Ian B, tea-dragon@github)\n#590: Binding invalid Currency gives nonsense at end of the message\n (reported by Jerbell@github)\n#592: Wrong `TokenBuffer` delegate deserialization using `@JsonCreator`\n (reported by Eugene L)\n#601: ClassCastException for a custom serializer for enum key in `EnumMap`\n (reported by Benson M)\n#604: `Map` deserializers not being cached, causing performance problems\n#610: Fix forward reference in hierarchies\n (contributed by zeito@github)\n#619: Off by one error in AnnotatedWithParams\n (reported by stevetodd@github)\n- Minor fix to `EnumSerializer` regarding detection \"serialize using index\"\n- Minor fix to number serializers, to call proper callback for schema generation\n\n2.4.3 (02-Oct-2014)\n\n#496: Wrong result with `new TextNode(\"false\").asBoolean(true)`\n (reported by Ivar R, ivarru@github)\n#511: DeserializationFeature.FAIL_ON_INVALID_SUBTYPE does not work\n (reported by sbelikov@github)\n#523: MapDeserializer and friends do not report the field/key name for mapping exceptions\n (reported by Ian B, tea-dragon@github)\n#524: @JsonIdentityReference(alwaysAsId = true) Custom resolver is reset to SimpleObjectIdResolver\n (reported by pkokorev@github)\n#541: @JsonProperty in @JsonCreator is conflicting with POJOs getters/attributes\n (reported by fabienrenaud@github)\n#543: Problem resolving self-referential generic types\n#570: Add Support for Parsing All Compliant ISO-8601 Date Formats\n (requested by pfconrey@github)\n- Fixed a problem with `acceptJsonFormatVisitor` with Collection/array types that\n  are marked with `@JsonValue`; could cause NPE in JSON Schema generator module.\n\n2.4.2 (14-Aug-2014)\n\n#515: Mixin annotations lost when using a mixin class hierarchy with non-mixin interfaces\n (reported by 'stevebread@github')\n- Fixed a problem related to [jackson-dataformat-smile#19].\n\n2.4.1.2 (12-Jul-2014)\n\nSpecial one-off \"micro patch\" for:\n\n#503: Concurrency issue inside com.fasterxml.jackson.databind.util.LRUMap.get(Object)\n (reported by fjtc@github)\n\n2.4.1.1 (18-Jun-2014)\n\nSpecial one-off \"micro patch\" for:\n\n#491: Temporary work-around for issue #490 (full fix for 2.5 needs to be\n  in `jackson-annotations`)\n#506: Index is never set for Collection and Array in InvalidFormatException.Reference\n (reported by Fabrice D, fabdouglas@github)\n- Fixed a problem related to [jackson-dataformat-smile#19].\n\n2.4.1 (17-Jun-2014)\n\n#479: NPE on trying to deserialize a `String[]` that contains null\n (reported by huxi@github)\n#482: Make date parsing error behavior consistent with JDK\n (suggested by Steve S, sanbeg@github)\n#489 (partial): TypeFactory cache prevents garbage collection of custom ClassLoader\n (reported by sftwrengnr@github)\n\n2.4.0 (02-Jun-2014)\n\n#81: Allow use of @JsonUnwrapped with typed (@JsonTypeInfo) classes, provided\n  that (new) feature `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS`\n  is disabled\n (constributed by Ben F, UnquietCode@github)\n#88: Prevent use of type information for `JsonNode` via default typing\n (reported by electricmonk@github)\n#149: Allow use of \"stringified\" indexes for Enum values\n (requested by chenboxiang@github)\n#176: Allow use external Object Id resolver (to use with @JsonIdentityInfo etc)\n (implemented by Pascal G)\n#193: Conflicting property name definitions\n (reported by Stuart J, sgjohnston@github)\n#323: Serialization of the field with deserialization config\n (reported by metanet@github)\n#327: Should not consider explicitly differing renames a fail, as long as all are explicit\n#335: Allow use of `@JsonPropertyOrder(alphabetic=true)` for Map properties\n#351: ObjectId does not properly handle forward references during deserialization\n (contributed by pgelinas)\n#352 Add `ObjectMapper.setConfig()` for overriding `SerializationConfig`/`DeserializationConfig`\n#353: Problems with polymorphic types, `JsonNode` (related to #88)\n (reported by cemo@github)\n#359: Converted object not using explicitly annotated serializer\n (reported by Florian S [fschopp@github])\n#369: Incorrect comparison for renaming in `POJOPropertyBuilder`\n#375: Add `readValue()`/`readPropertyValue()` methods in `DeserializationContext`\n#376: Add support for `@JsonFormat(shape=STRING)` for number serializers\n#381: Allow inlining/unwrapping of value from single-component JSON array\n (contributed by yinzara@github)\n#390: Change order in which managed/back references are resolved (now back-ref\n first, then forward)\n (requested by zAlbee@github)\n#407: Properly use null handlers for value types when serializer Collection\n and array types\n (contributed by Will P)\n#425: Add support for using `Void.class` as \"no class\", instead of `NoClass.class`\n#428: `PropertyNamingStrategy` will rename even explicit name from `@JsonProperty`\n (reported by turskip@github)\n#435: Performance bottleneck in TypeFactory._fromClass\n (reported by Sean D, sdonovanuk@github)\n#434: Ensure that DecimalNodes with mathematically equal values are equal\n (contributed by Francis G)\n#435: Performance bottleneck in TypeFactory._fromClass\n (reported by sdonovanuk@github)\n#438: Add support for accessing `@JsonProperty(index=N)` annotations\n#442: Make `@JsonUnwrapped` indicate property inclusion\n (suggested by Ben F)\n#447: ArrayNode#addAll should accept Collection<? extends JsonNode>\n (suggested by alias@github)\n#461: Add new standard naming strategy, `PropertyNamingStrategy.LowerCaseStrategy`\n#463: Add 'JsonNode.asText(String defaultValue)`\n (suggested by Chris C)\n#464: Include `JsonLocation` in more mapping exceptions\n (contributed by Andy C (q3aiml@github))\n#465: Make it easier to support serialization of custom subtypes of `Number`\n#467: Unwanted POJO's embedded in tree via serialization to tree\n (reported by Benson M)\n- Slightly improve `SqlDateSerializer` to support `@JsonFormat`\n- Improve handling of native type ids (YAML, CBOR) to use non-native type ids\n  as fallback\n\n2.3.5 (13-Jan-2015)\n\n#496: Wrong result for TextNode(\"false\").asBoolean(true)\n (reported by Ivar R, ivarru@github)\n#543: Problems resolving self-referential generic types.\n#656: defaultImpl configuration is ignored for WRAPPER_OBJECT\n\n2.3.4 (17-Jul-2014)\n\n#459: BeanDeserializerBuilder copy constructor not copying `_injectables`\n#462: Annotation-provided Deserializers are not contextualized inside CreatorProperties\n (reported by aarondav@github)\n\n2.3.3 (10-Apr-2014)\n\n#420: Remove 'final' modifier from `BeanDeserializerBase.deserializeWithType`\n (requested by Ghoughpteighbteau@github)\n#422: Allow use of \"True\" and \"False\" as aliases for booleans when coercing from\n  JSON String\n#423: Fix `CalendarSerializer` to work with custom format\n (reported by sergeymetallic@github)\n#433: `ObjectMapper`'s `.valueToTree()` wraps `JsonSerializable` objects into a POJONode\n (reported by Francis G)\n- Fix null-handling for `CollectionSerializer`\n\n2.3.2 (01-Mar-2014)\n\n#378: Fix a problem with custom enum deserializer construction\n (reported by BokoEnos@github)\n#379: Fix a problem with (re)naming of Creator properties; needed to make\n Paranamer module work with NamingStrategy.\n (reported by Chris P, cpilsworth@github)\n#398: Should deserialize empty (not null) URI from empty String\n (reported by pgieser@github)\n#406: @JsonTypeIdResolver not working with external type ids\n (reported by Martin T)\n#411: NumberDeserializers throws exception with NaN and +/- Infinity\n (reported by clarkbreyman@github)\n#412: ObjectMapper.writerWithType() does not change root name being used\n (repoted by jhalterman@github)\n- Added `BeanSerializerBase._serializeObjectId()` needed by modules that\n  override standard BeanSerializer; specifically, XML module.\n\n2.3.1 (28-Dec-2013)\n\n#346: Fix problem deserializing `ObjectNode`, with @JsonCreator, empty\n  JSON Object\n (reported by gaff78@github)\n#358: `IterableSerializer` ignoring annotated content serializer\n (reported by Florian S)\n#361: Reduce sync overhead for SerializerCache by using volatile, double-locking\n (contributed by stuartwdouglas@github)\n#362: UUID output as Base64 String with ObjectMapper.convertValue()\n (reported by jknack@github)\n#367: Make `TypeNameIdResolver` call `TypeResolver` for resolving base type\n (suggested by Ben F)\n#370: Fail to add Object Id for POJO with no properties\n (reported by jh3141@github)\n- Fix for [jackson-module-afterburner#38]: need to remove @JacksonStdImpl from\n  `RawSerializer`, to avoid accidental removal of proper handling.\n\n2.3.0 (13-Nov-2013)\n\n#48: Add support for `InetSocketAddress`\n (contributed by Nick T)\n#152: Add support for traversing `JsonNode` with (new!) `JsonPointer` implementation\n (suggested by fge@github)\n#208: Accept \"fromString()\" as an implicit Creator (factory) method (alias for \"valueOf()\")\n (requested by David P)\n#215: Allow registering custom `CharacterEscapes` to use for serialization,\n via `ObjectWriter.with(CharacterEscapes)` (and `ObjectMapper.writer(CharacterEscapes)`)\n#227: Allow \"generic\" Enum serializers, deserializers, via `SimpleModule`\n#234: Incorrect type information for deeply nested Maps\n (reported by Andrei P)\n#237: Add `DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY` to optionally\n  throw `JsonMappingException` on duplicate keys, tree model (`JsonNode`)\n#238: Allow existence of overlapping getter, is-getter (choose 'regular' getter)\n#239: Support `ByteBuffer`\n (suggested by mckamey@github)\n#240: Make sure `@JsonSerialize.include` does not accidentally override\n  class inclusion settings\n (requested by thierryhenrio@github)\n#253: `DelegatingDeserializer` causes problems for Managed/BackReferences\n (reported by bfelaco@github)\n#257: Make `UntypedObjectDeserializer` support overides for `List`, `Map` etc\n#268: Add new variant of `ObjectMapper.canSerialize()` that can return `Throwable`\n that caused false to be returned (if any)\n#269: Add support for new `@JsonPropertyDescription` via `AnnotationIntrospector`\n as well as `BeanProperty.getMedata().getDescription()`\n#270: Add `SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID` to allow use of equality\n (instead of identity) for figuring out when to use Object Id\n (requested by beku8@github)\n#271: Support handling of `@JsonUnwrapped` for in-built JSON Schema generation\n#277: Make `TokenBuffer` support new native type and object ids\n#302: Add `setNamingStrategy` in `Module.SetupContext`\n (suggested by Miguel C)\n#305: Add support for accessing `TypeFactory` via `TypeIdResolverBase`\n (not yet via `TypeIdResolver` interface), other configuration\n#306: Allow use of `@JsonFilter` for properties, not just classes \n#307: Allow use of `@JsonFilter` for Maps in addition to POJOs\n#308: Improve serialization and deserialization speed of `java.util.UUID` by 4x\n (suggested by David P)\n#310: Improve `java.util.UUID` serialization with binary codecs, to use \"raw\" form.\n#311: Make sure that \"creator properties\" are alphabetically ordered too, if\n  so requested.\n#315: Allow per-property definition of null serializer to use, using\n new `@JsonSerialize(nullsUsing=xxx)` annotation property\n#317: Fix `JsonNode` support for nulls bound to `ObjectNode`, `ArrayNode`\n (contributed by Seth P)\n#318: Problems with `ObjectMapper.updateValue()`, creator property-backed accessors\n#319: Add support for per-call (\"contextual\") attributes, with defaulting,\n to allow keeping track of state during (de)serialization\n#324: Make sure to throw `JsonMappingException` from `EnumDeserializer` creator,\n  not `IllegalArgumentException`\n (reported by beverku@github)\n#326: Support `@JsonFilter` for \"any getter\" properties\n#334: Make `ArrayNode`, `ObjectNode` non-final again\n#337: `AnySetter` does not support polymorphic types\n (reported by askvortsov@github)\n#340: AtomicReference not working with polymorphic types\n#342: Add `DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES` to make `ObjectMapper`\n  throw exception when encountering explicitly ignored properties\n (requested by Ruslan M)\n[JACKSON-890]: Support managed/back-references for polymorphic (abstract) types\n- Add 'BeanPropertyWriter.isUnwrapping()' for future needs (by Afterburner)\n- Add coercions from String \"null\" (as if null token was parsed) for primitives/Wrappers.\n- Add `JsonDeserializer.handledType()`\n\n2.2.4 (10-Jun-2014)\n\n#292: Problems with abstract `Map`s, `Collection`s, polymorphic deserialization\n#324: EnumDeserializer should throw JsonMappingException, not IllegalArgumentException\n#346: Problems deserializing `ObjectNode` from empty JSON Object, with @JsonCreator\n\n2.2.3 (22-Aug-2013)\n\n#234: Problems with serializing types for deeply nested generic Maps, default typing \n#251: SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN ignored with JsonNode\n  serialization\n (reported by fge@github)\n#259: Fix a problem with JSON Schema generation for `@JsonValue`\n (reported by Lior L)\n#267: Handle negative, stringified timestamps\n (reported by Drecth@github)\n#281: Make `NullNode` use configured null-value serializer\n#287: Fix problems with converters, Maps with Object values\n (reported by antubis@github)\n#288: Fix problem with serialization converters assigned with annotations\n (reported by cemo@github)\n\n2.2.2 (26-May-2013)\n\n#216: Problems with Android, 1.6-only types\n#217: JsonProcessingExceptions not all wrapped as expected\n (reported by karldmoore@github)\n#220: ContainerNode missing 'createNumber(BigInteger)'\n (reported by Pascal G)\n#223: Duplicated nulls with @JsonFormat(shape=Shape.ARRAY)\n (reported by lukegh@github)\n#226: Field mapping fail on deserialization to common referenced object when\n  @JsonUnwrapped is used\n (reported by ikvia@github)\n#232: Converting bound BigDecimal value to tree fails with WRITE_BIGDECIMAL_AS_PLAIN\n (reported by celkings@github)\n- Minor fix to handle primitive types for key deserializer lookups\n- Add convenience method `MappingIterator.getCurrentLocation()`\n (suggested by Tomdz@github)\n\n2.2.1 (03-May-2013)\n\n#214: Problem with LICENSE, NOTICE, Android packaging\n (reported by thierryd@github)\n\n2.2.0 (22-Apr-2013)\n\nFixes:\n\n#23: Fixing typing of root-level collections\n#118: JsonTypeInfo.as.EXTERNAL_PROPERTY not working correctly\n with missing type id, scalar types\n#130: TimeZone not set for GregorianCalendar, even if configured\n#144: MissingNode.isValueNode() should return 'false'\n (reported by 'fge@github')\n#146: Creator properties were not being renamed as expected\n (contributed by Christoper C)\n#188: Problem with ObjectId serialization, 'alwaysAsId' references\n\nImprovements:\n\n#116: JavaType implements `java.lang.reflect.Type` (as does `TypeReference`)\n#147: Defer reporting of problems with missing creator parameters\n (contributed by Christoper C)\n#155: Make `ObjectNode` and `ArrayNode` final (other node types already were)\n (requested by fge@github)\n#161: Add deserializer for java.util.concurrent.ArrayBlockingQueue\n#173: Add 'JsonNode.traverse(ObjectCodec)' for convenience\n#181: Improve error reporting for missing '_valueDeserializer'\n#194: Add `FloatNode` type in tree model (JsonNode)\n (requested by msteiger@github)\n#199: Allow deserializing `Iterable` instances (as basic `Collection`s)\n (requested by electrum@github)\n#206: Make 'ObjectMapper.createDeserializationContext()' overridable\n (requested by noter@github)\n#207: Add explicit support for `short` datatypes, for tree model\n (contributed by msteiger@github)\n\nNew features:\n\n#120: Extend BeanDeserializerModifier to work with non-POJO deserializers\n#121: Extend BeanSerializerModifier to work with non-POJO serializers\n#124: Add support for serialization converters (@JsonSerializer(converter=...))\n#124: Add support for deserialization converters (@JsonDeserializer(converter=...))\n#140: Add 'SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN' to allow forcing\n  of non-scientific notation when serializing BigDecimals.\n (suggested by phedny@github)\n#148: Add 'DeserializationFeature.FAIL_ON_INVALID_SUBTYPE`, which allows mapping\n  entries with missing or invalid type id into null references (instead of failing).\n  Also allows use of '@JsonTypeInfo.defaultImpl = NoClass.class' as alternative.\n#159: Add more accessors in 'MappingIterator': getParser(), getParserSchema(),\n  readAll()\n (suggested by Tom D)\n#190: Add 'MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS' (default: true) for\n pruning out final fields (to avoid using as mutators)\n (requested by Eric T)\n#195: Add 'MapperFeature.INFER_PROPERTY_MUTATORS' (default: enabled) for finer\n  control of what mutators are auto-detected.\n (requested by Dain S)\n#198: Add SPI metadata, handling in ObjectMapper (findModules()), for\n  automatic registration of auto-detected extension modules\n (suggested by 'beamerblvd@github')\n#203: Added new features to support advanced date/time handling:\n  - SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS\n  - DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS\n  - DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE\n\nOther:\n\n#126: Update JDK baseline to 1.6\n* API under 'com.fasterxml.jackson.databind.jsonFormatVisitors' changed significantly\n  based on experiences with external JSON Schema generator.\n* Version information accessed via code-generated access class, instead of reading\n  VERSION.txt\n* Added 2 methods in Converter interface: getInputType(), getOutputType(),\n  to allow programmatic overrides (needed by JAXB annotation module)\n\n2.1.4 (26-Feb-2013)\n\n* [JACKSON-887]: StackOverflow with parameterized sub-class field\n (reported by Alexander M)\n* [#130]: TimeZone not set for GregorianCalendar, when deserializing\n* [#157]: NPE when registering module twice\n* [#162]: JsonNodeFactory: work around an old bug with BigDecimal and zero\n (submitted by fge@github)\n* [#166]: Incorrect optimization for `ObjectMapper.convertValue(Class)`\n (reported by Eric T)\n* [#167]: Problems with @JsonValue, polymorphic types (regression from 1.x)\n (reported by Eric T)\n* [#170]: Problems deserializing `java.io.File` if creator auto-discovery disabled\n (reported by Eric T)\n* [#175]: NPE for JsonMappingException, if no path is specified\n (reported by bramp@github)\n\n2.1.3 (19-Jan-2013)\n\n* [Issue#141]: ACCEPT_EMPTY_STRING_AS_NULL_OBJECT not working for enums\n* [Issue#142]: Serialization of class containing EnumMap with polymorphic enum\n  fails to generate class type data\n (reported by kidavis4@github)\n\n2.1.2 (04-Dec-2012)\n\n* [Issue#106]: NPE in ObjectArraySerializer.createContextual(...)\n* [Issue#117]: HandlerInstantiator defaulting not working\n (reported by Alexander B)\n* [Issue#118]: Problems with JsonTypeInfo.As.EXTERNAL_PROPERTY, scalar values\n (reported by Adva11@github)\n* [Issue#119]: Problems with @JsonValue, JsonTypeInfo.As.EXTERNAL_PROPERTY\n (reported by Adva11@github)\n* [Issue#122]: ObjectMapper.copy() was not copying underlying mix-in map\n (reported by rzlo@github)\n\n2.1.1 (11-Nov-2012)\n\nFixes:\n\n* [JACKSON-875]: Enum values not found if Feature.USE_ANNOTATIONS disabled\n (reported by Laurent P)\n* [Issue#93]: ObjectNode.setAll() broken; would not add anything for\n  empty ObjectNodes.\n (reported by Francis G)\n* Making things implement java.io.Serializable:\n  - Issues: #94, #99, #100, #102\n    (reported by Sean B)\n* [Issue#96]: Problem with JsonTypeInfo.As.EXTERNAL_PROPERTY, defaultImpl\n (reported by Adva11@github)\n\n2.1.0 (08-Oct-2012)\n\n  New minor version for 2.x series. Major improvements in multiple areas,\n  including:\n\n  - Dataformat auto-detection\n  - More `@JsonFormat.shape` variant to serialize Collections as\n    JSON Objects, POJOs as JSON Arrays (csv-like).\n  - Much more configuration accessible via ObjectReader, ObjectWriter\n  - New mechanism for JSON Schema generation, other uses (in future)\n\nFixes:\n\n* [JACKSON-830]/[Issue#19]: Change OSGi bundle name to be fully-qualified\n* ]JACKSON-847]: Make @JsonIdentityInfo work with property-based creator\n* [JACKSON-851]: State corruption with ObjectWriter, DefaultPrettyPrinter\n (reported by Duncan A)\n* [Issue#75]: Too aggressive KeySerializer caching\n* Minor fix wrt [Issue#11], coercion needed extra checks\n\nImprovements:\n\n* [JACKSON-758]: Remove 'IOException' from throws clauses of \"writeValueAsString\"\n  and \"writeValueAsBytes\" of ObjectMapper/ObjectWriter\n (suggested by G-T Chen)\n* [JACKSON-839]: Allow \"upgrade\" of integer number types for\n  UntypedObjectDeserializer, even with default typing enabled.\n* [JACKSON-850]: Allow use of zero-arg factory methods as \"default creator\"\n  (suggested by Razvan D)\n* [Issue#9]: Implement 'required' JSON Schema attribute for bean properties\n* [Issue#20]: Add new exception type, InvalidFormatException (sub-type of\n  JsonMappingException) to indicate data format problems\n (suggested by HolySamosa@github)\n* [Issue#30]: ObjectReader and ObjectWriter now try to pre-fetch root\n  (de)serializer if possible; minor performance improvement (2% for small POJOs).\n* [Issue#33]: Simplified/clarified definition of 'ObjectReader.readValues()';\n  minor change in behavior for JSON Array \"wrapped\" sequences\n* [Issue#60]: Add 'JsonNode.hasNonNull(...)' method(s)\n (suggested by Jeff S on mailing list) \n* [Issue#64]: Add new \"standard\" PropertyNamingStrategy, PascalCaseStrategy\n  (PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)\n (contributed by Sean B)\n* [Issue#65]: Add getters to `ObjectMapper`, DeserializationContext/-Factory.\n (contributed by Dmitry K)\n* [Issue#69]: Add `PropertyName` abstraction, new methods in AnnotationIntrospector\n* [Issue#80]: Make `DecimalNode` normalize input, to make \"1.0\" and \"1.00\"equal\n (reported by fge@github)\n\nNew features:\n\n* [Issue#15]: Support data format auto-detection via ObjectReader (added\n  'withFormatDetection(...)' fluent factories)\n* [Issue#21]: Add 'ObjectNode.set(...)' method (and related) to improve\n  chaining, semantic consistency of Tree Model API\n (suggested by fge@Github)\n* [Issue#22]: Add 'ObjectMapper.setAnnotationIntrospectors()' which allows\n  defining different introspectors for serialization, deserialization\n* [Issue#24]: Allow serialization of Enums as JSON Objects\n (suggested by rveloso@github)\n* [Issue#28]: Add 'ObjectMapper.copy()', to create non-linked copy of\n  mapper, with same configuration settings\n* [Issue#29]: Allow serializing, deserializing POJOs as JSON Arrays\n  by using `@JsonFormat(shape=Shape.ARRAY)`\n* [Issue#40]: Allow serialization of Collections as JSON Objects\n  (and deserialization from)\n (suggested by 'rveloso@github')\n* [Issue#42]: Allow specifying Base64 variant to use for Base64-encoded data\n  using ObjectReader.with(Base64Variant), ObjectWriter.with(Base64Variant).\n (suggested by 'mpfau@github')\n* [Issue#45]: Add '@JsonNaming' annotation to define per-class PropertyNamingStrategy\n (suggested by Mark W)\n* [Pull#58]: Make 'MappingIterator' implement 'Closable'\n (contributed by Pascal G)\n* [Issue#72]: Add 'MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME' to use\n  wrapper name annotations for renaming properties\n* [Issue#87]: Add 'StdDelegatingSerializer', 'StdDelegatingDeserializer' to\n  simplify writing of two-step handlers\n* (issue #4 of jackson-annotations): Add `@JsonIdentityReference(alwaysAsId=true)`\n  to force ALL references to an object written as Object Id, even the first one.\n* Added 'ObjectReader#withHandler' to allow for reconfiguring deserialization\n  problem handler\n (suggested by 'electricmonk')\n\nOther changes:\n\n* New variant of AnnotationIntrospector.getFormat(), to support class\n  annotations\n* It is now possible to serialize instances of plain old Object, iff\n  'FAIL_ON_EMPTY_BEANS' is disabled.\n* Trying to remove reference to \"JSON\" in datatype conversion errors\n (since databinding is format-agnostic)\n\nINCOMPATIBILITIES: (rats!)\n\n* Note that [Issue#33] (see above) is, technically speaking, backwards\n  imcompatible change. It is estimated that it should NOT affect most\n  users, as changes are to edge cases (and undocumented ones at that).\n  However, it can potentially cause problems with upgrade.\n* Implementation of `JsonFormatVisitable` resulting in 2 new methods\n  being added in `BeanPropertyFilter` interface -- this is unfortunate,\n  but was required to support full traversability.\n\n2.0.4 (26-Jun-2012)\n\n* [Issue#6]: element count for PrettyPrinter, endObject wrong\n   (reported by \"thebluemountain\")\n* [JACKSON-838]: Utf8StreamParser._reportInvalidToken() skips letters\n    from reported token name\n   (reported by L\u00f3r\u00e1nt Pint\u00e9r)\n* [JACKSON-841] Data is doubled in SegmentedStringWriter output\n   (reported by Scott S)\n* [JACKSON-842] ArrayIndexOutOfBoundsException when skipping C-style comments\n   (reported by Sebastien R)\n\n2.0.3: no version 2.0.3 released -- only used for extension modules\n\n2.0.2 [14-May-2012]\n\nFixes:\n\n* [Issue#14]: Annotations were not included from parent classes of\n  mix-in classes\n (reported by @guillaup)\n* [JACKSON-824]: Combination of JSON Views, ObjectMapper.readerForUpdating()\n  was not working\n (reported by Nir S)\n(and all fixes from 1.9.7)\n\nImprovements:\n\n* [Issue#11]: Improve ObjectMapper.convertValue()/.treeToValue() to use\n  cast if possible\n\n2.0.1 [23-Apr-2012]\n\nFixes:\n\n* [JACKSON-827] Ensure core packages work on JDK 1.5\n (reported by Pascal g)\n* [JACKSON-829] Custom serializers not working for List<String> properties,\n  @JsonSerialize(contentUsing)\n (reported by James R)\n\nImprovements:\n\n* [Issue#5]: Add support for maps with java.util.Locale keys to the set of\n  StdKeyDeserializers\n (contributed by Ryan G)\n\n2.0.0 [25-Mar-2012]\n\nFixes:\n\n* [JACKSON-368]: Problems with managed references, abstract types\n* [JACKSON-711]: Delegating @JsonCreator did not work with Injectable values\n* [JACKSON-798]: Problem with external type id, creators\n  (reported by Casey L)\n(and all fixes up until and including 1.9.6)\n\nImprovements:\n\n* [JACKSON-546]: Indicate end-of-input with JsonMappingException instead\n  of EOFException, when there is no parsing exception\n* [JACKSON-664]: Reduce overhead of type resolution by adding caching\n  in TypeFactory\n* [JACKSON-690]: Pass DeserializationContext through ValueInstantiator\n* [JACKSON-695]: Add 'isEmpty(value)' in JsonSerializer to allow\n  customizing handling of serialization of empty values\n* [JACKSON-710]: 'ObjectMapper.convertValue()' should ignore root value\n  wrapping/unwrapping settings\n* [JACKSON-730] Split various features (JsonParser, JsonGenerator,\n  SerializationConfig, DeserializationConfig) into per-factory\n  features (MapperFeature, JsonFactory.Feature) an per\n  instance features (existing ones)\n* [JACKSON-732]: Allow 'AnnotationIntrospector.findContentDeserializer()'\n  (and similar) to return instance, not just Class<?> for instance\n (requested by James R)\n* [JACKSON-736]: Add (more) access to array, container and map serializers\n* [JACKSON-737]: Allow accessing of \"creator properties\" for BeanDeserializer\n* [JACKSON-748]: Add 'registerSubtypes' to 'Module.setupContext' (and SimpleModule)\n* [JACKSON-749]: Make @JsonValue work for Enum deserialization\n* [JACKSON-769]: ObjectNode/ArrayNode: change 'put', 'insert', 'add' to return\n  'this node' (unless already returning something)\n* [JACKSON-770]: Simplify method naming for JsonNode, drop unnecessary 'get' prefix\n  from methods like 'getTextValue()' (becomes 'textValue()')\n* [JACKSON-777]: Rename 'SerializationConfig.Feature' as 'SerializationFeature',\n  'DeserializationConfig.Feature' as 'DeserializationFeature'\n* [JACKSON-780]: MissingNode, NullNode should return 'defaultValue' from 'asXxx' methods,\n  (not 0 for numbers), as they are not numeric types\n* [JACKSON-787]: Allow use of @JsonIgnoreProperties for properties (fields, getters, setters)\n* [JACKSON-795]: @JsonValue was not working for Maps, Collections\n* [JACKSON-800]: Add 'Module.SetupContext#addDeserializationProblemHandler'\n (suggested by James R)\n\nNew features:\n\n* [JACKSON-107]: Add support for Object Identity (to handled cycles, shared refs),\n  with @JsonIdentityInfo\n* [JACKSON-435]: Allow per-property Date formatting using @JsonFormat.\n* [JACKSON-437]: Allow injecting of type id as POJO property, by setting\n  new '@JsonTypeInfo.visible' property to true.\n* [JACKSON-469]: Support \"Builder pattern\" for deserialiation; that is, allow\n  use of separate Builder object for data binding, creating actual value\n* [JACKSON-608]: Allow use of JSON Views for deserialization\n* [JACKSON-636]: Add 'SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS' to allow\n  forced sorting of Maps during serialization\n  (suggested by Joern H)\n* [JACKSON-669]: Allow prefix/suffix for @JsonUnwrapped properties\n (requested by Aner P)\n* [JACKSON-707]: Add 'JsonNode.deepCopy()', to create safe deep copies\n  of ObjectNodes, ArrayNodes.\n* [JACKSON-714]: Add general-purpose @JsonFormat annotation\n* [JACKSON-718]: Added 'JsonNode.canConvertToInt()', 'JsonNode.canConvertToLong()'\n* [JACKSON-747]: Allow changing of 'SerializationFeature' for ObjectWriter,\n  'DeserializationFeature' for ObjectReader.\n* [JACKSON-752]: Add @JsonInclude (replacement of @JsonSerialize.include)\n* [JACKSON-754]: Add @JacksonAnnotationsInside for creating \"annotation\n  bundles\" (also: AnnotationIntrospector.isAnnotationBundle())\n* [JACKSON-762]: Allow using @JsonTypeId to specify property to use as\n  type id, instead of using separate type id resolver.\n* [JACKSON-764]: Allow specifying \"root name\" to use for root wrapping\n  via ObjectReader, ObjectWriter.\n* [JACKSON-772]: Add 'JsonNode.withArray()' to use for traversing Array nodes.\n* [JACKSON-793]: Add support for configurable Locale, TimeZone to use\n  (via SerializationConfig, DeserializationConfig)\n* [JACKSON-805]: Add 'SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED'\n  to improve interoperability with BadgerFish/Jettison\n* [JACKSON-810]: Deserialization Feature: Allow unknown Enum values via\n  'DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL'\n  (suggested by Raymond R)\n* [JACKSON-813]: Add '@JsonSerializableSchema.id' attribute, to indicate\n  'id' value to add to generated JSON Schemas.\n\n[entries for versions 1.x and earlier not retained; refer to earlier releases)\n", "package com.fasterxml.jackson.databind;\n\nimport com.fasterxml.jackson.databind.cfg.ConfigFeature;\nimport com.fasterxml.jackson.databind.exc.InvalidNullException;\n\n/**\n * Enumeration that defines simple on/off features that affect\n * the way Java objects are deserialized from JSON\n *<p>\n * Note that features can be set both through\n * {@link ObjectMapper} (as sort of defaults) and through\n * {@link ObjectReader}.\n * In first case these defaults must follow \"config-then-use\" patterns\n * (i.e. defined once, not changed afterwards); all per-call\n * changes must be done using {@link ObjectReader}.\n *<p>\n * Note that features that do not indicate version of inclusion\n * were available in Jackson 2.0 (or earlier); only later additions\n * indicate version of inclusion.\n */\npublic enum DeserializationFeature implements ConfigFeature\n{\n    /*\n    /******************************************************\n    /* Value (mostly scalar) conversion features\n    /******************************************************\n     */\n\n    /**\n     * Feature that determines whether JSON floating point numbers\n     * are to be deserialized into {@link java.math.BigDecimal}s\n     * if only generic type description (either {@link Object} or\n     * {@link Number}, or within untyped {@link java.util.Map}\n     * or {@link java.util.Collection} context) is available.\n     * If enabled such values will be deserialized as {@link java.math.BigDecimal}s;\n     * if disabled, will be deserialized as {@link Double}s.\n     *<p>\n     * NOTE: one aspect of {@link java.math.BigDecimal} handling that may need\n     * configuring is whether trailing zeroes are trimmed:\n     * {@link com.fasterxml.jackson.databind.node.JsonNodeFactory} has\n     * {@link com.fasterxml.jackson.databind.node.JsonNodeFactory#withExactBigDecimals} for\n     * changing default behavior (default is for trailing zeroes to be trimmed).\n     *<p>\n     * Feature is disabled by default, meaning that \"untyped\" floating\n     * point numbers will by default be deserialized as {@link Double}s\n     * (choice is for performance reason -- BigDecimals are slower than\n     * Doubles).\n     */\n    USE_BIG_DECIMAL_FOR_FLOATS(false),\n\n    /**\n     * Feature that determines whether JSON integral (non-floating-point)\n     * numbers are to be deserialized into {@link java.math.BigInteger}s\n     * if only generic type description (either {@link Object} or\n     * {@link Number}, or within untyped {@link java.util.Map}\n     * or {@link java.util.Collection} context) is available.\n     * If enabled such values will be deserialized as\n     * {@link java.math.BigInteger}s;\n     * if disabled, will be deserialized as \"smallest\" available type,\n     * which is either {@link Integer}, {@link Long} or\n     * {@link java.math.BigInteger}, depending on number of digits.\n     * <p>\n     * Feature is disabled by default, meaning that \"untyped\" integral\n     * numbers will by default be deserialized using whatever\n     * is the most compact integral type, to optimize efficiency.\n     */\n    USE_BIG_INTEGER_FOR_INTS(false),\n\n    /**\n     * Feature that determines how \"small\" JSON integral (non-floating-point)\n     * numbers -- ones that fit in 32-bit signed integer (`int`) -- are bound\n     * when target type is loosely typed as {@link Object} or {@link Number}\n     * (or within untyped {@link java.util.Map} or {@link java.util.Collection} context).\n     * If enabled, such values will be deserialized as {@link java.lang.Long};\n     * if disabled, they will be deserialized as \"smallest\" available type,\n     * {@link Integer}.\n     *<p>\n     * Note: if {@link #USE_BIG_INTEGER_FOR_INTS} is enabled, it has precedence\n     * over this setting, forcing use of {@link java.math.BigInteger} for all\n     * integral values.\n     *<p>\n     * Feature is disabled by default, meaning that \"untyped\" integral\n     * numbers will by default be deserialized using {@link java.lang.Integer}\n     * if value fits.\n     * \n     * @since 2.6\n     */\n    USE_LONG_FOR_INTS(false),\n    \n    /**\n     * Feature that determines whether JSON Array is mapped to\n     * <code>Object[]</code> or {@code List<Object>} when binding\n     * \"untyped\" objects (ones with nominal type of <code>java.lang.Object</code>).\n     * If true, binds as <code>Object[]</code>; if false, as {@code List<Object>}.\n     *<p>\n     * Feature is disabled by default, meaning that JSON arrays are bound as\n     * {@link java.util.List}s.\n     */\n    USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n\n    /*\n    /******************************************************\n    /* Error handling features\n    /******************************************************\n     */\n\n    /**\n     * Feature that determines whether encountering of unknown\n     * properties (ones that do not map to a property, and there is\n     * no \"any setter\" or handler that can handle it)\n     * should result in a failure (by throwing a\n     * {@link JsonMappingException}) or not.\n     * This setting only takes effect after all other handling\n     * methods for unknown properties have been tried, and\n     * property remains unhandled.\n     *<p>\n     * Feature is enabled by default (meaning that a\n     * {@link JsonMappingException} will be thrown if an unknown property\n     * is encountered).\n     */\n    FAIL_ON_UNKNOWN_PROPERTIES(true),\n\n    /**\n     * Feature that determines whether encountering of JSON null\n     * is an error when deserializing into Java primitive types\n     * (like 'int' or 'double'). If it is, a {@link InvalidNullException}\n     * is thrown to indicate this; if not, default value is used\n     * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n     *<p>\n     * Feature is disabled by default.\n     */\n    FAIL_ON_NULL_FOR_PRIMITIVES(false),\n\n    /**\n     * Feature that determines whether JSON integer numbers are valid\n     * values to be used for deserializing Java enum values.\n     * If set to 'false' numbers are acceptable and are used to map to\n     * ordinal() of matching enumeration value; if 'true', numbers are\n     * not allowed and a {@link JsonMappingException} will be thrown.\n     * Latter behavior makes sense if there is concern that accidental\n     * mapping from integer values to enums might happen (and when enums\n     * are always serialized as JSON Strings)\n     *<p>\n     * Feature is disabled by default.\n     */\n    FAIL_ON_NUMBERS_FOR_ENUMS(false),\n\n    /**\n     * Feature that determines what happens when type of a polymorphic\n     * value (indicated for example by {@link com.fasterxml.jackson.annotation.JsonTypeInfo})\n     * cannot be found (missing) or resolved (invalid class name, non-mappable id);\n     * if enabled, an exception is thrown; if false, null value is used instead.\n     *<p>\n     * Feature is enabled by default so that exception is thrown for missing or invalid\n     * type information.\n     * \n     * @since 2.2\n     */\n    FAIL_ON_INVALID_SUBTYPE(true),\n\n    /**\n     * Feature that determines what happens when reading JSON content into tree\n     * ({@link com.fasterxml.jackson.core.TreeNode}) and a duplicate key\n     * is encountered (property name that was already seen for the JSON Object).\n     * If enabled, {@link JsonMappingException} will be thrown; if disabled, no exception\n     * is thrown and the new (later) value overwrites the earlier value.\n     *<p>\n     * Note that this property does NOT affect other aspects of data-binding; that is,\n     * no detection is done with respect to POJO properties or {@link java.util.Map}\n     * keys. New features may be added to control additional cases.\n     *<p>\n     * Feature is disabled by default so that no exception is thrown.\n     * \n     * @since 2.3\n     */\n    FAIL_ON_READING_DUP_TREE_KEY(false),\n\n    /**\n     * Feature that determines what happens when a property that has been explicitly\n     * marked as ignorable is encountered in input: if feature is enabled,\n     * {@link JsonMappingException} is thrown; if false, property is quietly skipped.\n     *<p>\n     * Feature is disabled by default so that no exception is thrown.\n     *\n     * @since 2.3\n     */\n    FAIL_ON_IGNORED_PROPERTIES(false),\n\n    /**\n     * Feature that determines what happens if an Object Id reference is encountered\n     * that does not refer to an actual Object with that id (\"unresolved Object Id\"):\n     * either an exception is thrown (<code>true</code>), or a null object is used\n     * instead (<code>false</code>).\n     * Note that if this is set to <code>false</code>, no further processing is done;\n     * specifically, if reference is defined via setter method, that method will NOT\n     * be called.\n     *<p>\n     * Feature is enabled by default, so that unknown Object Ids will result in an\n     * exception being thrown, at the end of deserialization.\n     * \n     * @since 2.5\n     */\n    FAIL_ON_UNRESOLVED_OBJECT_IDS(true),\n\n    /**\n     * Feature that determines what happens if one or more Creator properties (properties\n     * bound to parameters of Creator method (constructor or static factory method))\n     * are missing value to bind to from content.\n     * If enabled, such missing values result in a {@link JsonMappingException} being\n     * thrown with information on the first one (by index) of missing properties.\n     * If disabled, and if property is NOT marked as required,\n     * missing Creator properties are filled\n     * with <code>null values</code> provided by deserializer for the type of parameter\n     * (usually null for Object types, and default value for primitives; but redefinable\n     * via custom deserializers).\n     *<p>\n     * Note that having an injectable value counts as \"not missing\".\n     *<p>\n     * Feature is disabled by default, so that no exception is thrown for missing creator\n     * property values, unless they are explicitly marked as `required`.\n     * \n     * @since 2.6\n     */\n    FAIL_ON_MISSING_CREATOR_PROPERTIES(false),\n\n    /**\n      * Feature that determines what happens if one or more Creator properties (properties\n      * bound to parameters of Creator method (constructor or static factory method))\n      * are bound to null values - either from the JSON or as a default value. This\n      * is useful if you want to avoid nulls in your codebase, and particularly useful\n      * if you are using Java or Scala optionals for non-mandatory fields.\n      * Feature is disabled by default, so that no exception is thrown for missing creator\n      * property values, unless they are explicitly marked as `required`.\n      *\n      * @since 2.8\n      */\n    FAIL_ON_NULL_CREATOR_PROPERTIES(false),\n\n    /**\n     * Feature that determines what happens when a property annotated with\n     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY} is missing,\n     * but associated type id is available. If enabled, {@link JsonMappingException} is always\n     * thrown when property value is missing (if type id does exist);\n     * if disabled, exception is only thrown if property is marked as `required`.\n     *<p>\n     * Feature is enabled by default, so that exception is thrown when a subtype property is\n     * missing.\n     *\n     * @since 2.9\n     */\n    FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY(true),\n\n    /**\n     * Feature that determines behaviour for data-binding after binding the root value.\n     * If feature is enabled, one more call to\n     * {@link com.fasterxml.jackson.core.JsonParser#nextToken} is made to ensure that\n     * no more tokens are found (and if any is found,\n     * {@link com.fasterxml.jackson.databind.exc.MismatchedInputException} is thrown); if\n     * disabled, no further checks are made.\n     *<p>\n     * Feature could alternatively be called <code>READ_FULL_STREAM</code>, since it\n     * effectively verifies that input stream contains only as much data as is needed\n     * for binding the full value, and nothing more (except for possible ignorable\n     * white space or comments, if supported by data format).\n     *<p>\n     * Feature is disabled by default (so that no check is made for possible trailing\n     * token(s)) for backwards compatibility reasons.\n     *\n     * @since 2.9\n     */\n    FAIL_ON_TRAILING_TOKENS(false),\n    \n    /**\n     * Feature that determines whether Jackson code should catch\n     * and wrap {@link Exception}s (but never {@link Error}s!)\n     * to add additional information about\n     * location (within input) of problem or not. If enabled,\n     * most exceptions will be caught and re-thrown (exception\n     * specifically being that {@link java.io.IOException}s may be passed\n     * as is, since they are declared as throwable); this can be\n     * convenient both in that all exceptions will be checked and\n     * declared, and so there is more contextual information.\n     * However, sometimes calling application may just want \"raw\"\n     * unchecked exceptions passed as is.\n     *<p>\n     * NOTE: most of the time exceptions that may or may not be wrapped are of\n     * type {@link RuntimeException}: as mentioned earlier, various\n     * {@link java.io.IOException}s (and in particular\n     * {@link com.fasterxml.jackson.core.JacksonException}s) will\n     * always be passed as-is.\n     *<p>\n     * Feature is enabled by default.\n     */\n    WRAP_EXCEPTIONS(true),\n\n    /*\n    /******************************************************\n    /* Structural conversion features\n    /******************************************************\n     */\n\n    /**\n     * Feature that determines whether it is acceptable to coerce non-array\n     * (in JSON) values to work with Java collection (arrays, java.util.Collection)\n     * types. If enabled, collection deserializers will try to handle non-array\n     * values as if they had \"implicit\" surrounding JSON array.\n     * This feature is meant to be used for compatibility/interoperability reasons,\n     * to work with packages (such as XML-to-JSON converters) that leave out JSON\n     * array in cases where there is just a single element in array.\n     *<p>\n     * Feature is disabled by default.\n     */\n    ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n    \n    /**\n     * Feature that determines whether it is acceptable to coerce single value array (in JSON)\n     * values to the corresponding value type.  This is basically the opposite of the {@link #ACCEPT_SINGLE_VALUE_AS_ARRAY}\n     * feature.  If more than one value is found in the array, a JsonMappingException is thrown.\n     * <p>\n     * NOTE: only <b>single</b> wrapper Array is allowed: if multiple attempted, exception\n     * will be thrown.\n     * \n     * Feature is disabled by default.\n     * @since 2.4\n     */\n    UNWRAP_SINGLE_VALUE_ARRAYS(false),\n\n    /**\n     * Feature to allow \"unwrapping\" root-level JSON value, to match setting of\n     * {@link SerializationFeature#WRAP_ROOT_VALUE} used for serialization.\n     * Will verify that the root JSON value is a JSON Object, and that it has\n     * a single property with expected root name. If not, a\n     * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n     * will be deserialized as if it was the root value.\n     *<p>\n     * Feature is disabled by default.\n     */\n    UNWRAP_ROOT_VALUE(false),\n\n    /*\n    /******************************************************\n    /* Value conversion features\n    /******************************************************\n     */\n    \n    /**\n     * Feature that can be enabled to allow JSON empty String\n     * value (\"\") to be bound as `null` for POJOs and other structured\n     * values ({@link java.util.Map}s, {@link java.util.Collection}s).\n     * If disabled, standard POJOs can only be bound from JSON `null` or\n     * JSON Object (standard meaning that no custom deserializers or\n     * constructors are defined; both of which can add support for other\n     * kinds of JSON values); if enabled, empty JSON String can be taken\n     * to be equivalent of JSON null.\n     *<p>\n     * NOTE: this does NOT apply to scalar values such as booleans and numbers;\n     * whether they can be coerced depends on\n     * {@link MapperFeature#ALLOW_COERCION_OF_SCALARS}.\n     *<p>\n     * Feature is disabled by default.\n     */\n    ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false),\n\n    /**\n     * Feature that can be enabled to allow empty JSON Array\n     * value (that is, <code>[ ]</code>) to be bound to POJOs (and\n     * with 2.9, other values too) as `null`.\n     * If disabled, standard POJOs can only be bound from JSON `null` or\n     * JSON Object (standard meaning that no custom deserializers or\n     * constructors are defined; both of which can add support for other\n     * kinds of JSON values); if enabled, empty JSON Array will be taken\n     * to be equivalent of JSON null.\n     *<p>\n     * Feature is disabled by default.\n     * \n     * @since 2.5\n     */\n    ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT(false),\n\n    /**\n     * Feature that determines whether coercion from JSON floating point\n     * number (anything with command (`.`) or exponent portion (`e` / `E'))\n     * to an expected integral number (`int`, `long`, `java.lang.Integer`, `java.lang.Long`,\n     * `java.math.BigDecimal`) is allowed or not.\n     * If enabled, coercion truncates value; if disabled, a {@link JsonMappingException}\n     * will be thrown.\n     *<p>\n     * Feature is enabled by default.\n     * \n     * @since 2.6\n     */\n    ACCEPT_FLOAT_AS_INT(true),\n\n    /**\n     * Feature that determines standard deserialization mechanism used for\n     * Enum values: if enabled, Enums are assumed to have been serialized  using\n     * return value of <code>Enum.toString()</code>;\n     * if disabled, return value of <code>Enum.name()</code> is assumed to have been used.\n     *<p>\n     * Note: this feature should usually have same value\n     * as {@link SerializationFeature#WRITE_ENUMS_USING_TO_STRING}.\n     *<p>\n     * Feature is disabled by default.\n     */\n    READ_ENUMS_USING_TO_STRING(false),\n\n    /**\n     * Feature that allows unknown Enum values to be parsed as null values. \n     * If disabled, unknown Enum values will throw exceptions.\n     *<p>\n     * Note that in some cases this will basically ignore unknown Enum values;\n     * this is the keys for keys of {@link java.util.EnumMap} and values\n     * of {@link java.util.EnumSet} (because nulls are not accepted in these\n     * cases).\n     *<p>\n     * Feature is disabled by default.\n     * \n     * @since 2.0\n     */\n    READ_UNKNOWN_ENUM_VALUES_AS_NULL(false),\n\n    /**\n     * Feature that allows unknown Enum values to be ignored and a predefined value specified through\n     * {@link com.fasterxml.jackson.annotation.JsonEnumDefaultValue @JsonEnumDefaultValue} annotation.\n     * If disabled, unknown Enum values will throw exceptions.\n     * If enabled, but no predefined default Enum value is specified, an exception will be thrown as well.\n     *<p>\n     * Feature is disabled by default.\n     *\n     * @since 2.8\n     */\n    READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE(false),\n\n    /**\n     * Feature that controls whether numeric timestamp values are expected\n     * to be written using nanosecond timestamps (enabled) or not (disabled),\n     * <b>if and only if</b> datatype supports such resolution.\n     * Only newer datatypes (such as Java8 Date/Time) support such resolution --\n     * older types (pre-Java8 <b>java.util.Date</b> etc) and Joda do not --\n     * and this setting <b>has no effect</b> on such types.\n     *<p>\n     * If disabled, standard millisecond timestamps are assumed.\n     * This is the counterpart to {@link SerializationFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.\n     *<p>\n     * Feature is enabled by default, to support most accurate time values possible.\n     * \n     * @since 2.2\n     */\n    READ_DATE_TIMESTAMPS_AS_NANOSECONDS(true),\n\n    /**\n     * Feature that specifies whether context provided {@link java.util.TimeZone}\n     * ({@link DeserializationContext#getTimeZone()} should be used to adjust Date/Time\n     * values on deserialization, even if value itself contains timezone information.\n     * If enabled, contextual <code>TimeZone</code> will essentially override any other\n     * TimeZone information; if disabled, it will only be used if value itself does not\n     * contain any TimeZone information.\n     *<p>\n     * Note that exact behavior depends on date/time types in question; and specifically\n     * JDK type of {@link java.util.Date} does NOT have in-built timezone information\n     * so this setting has no effect.\n     * Further, while {@link java.util.Calendar} does have this information basic\n     * JDK {@link java.text.SimpleDateFormat} is unable to retain parsed zone information,\n     * and as a result, {@link java.util.Calendar} will always get context timezone\n     * adjustment regardless of this setting.\n     *<p>\n     *<p>\n     * Taking above into account, this feature is supported only by extension modules for\n     * Joda and Java 8 date/time datatypes.\n     * \n     * @since 2.2\n     */\n    ADJUST_DATES_TO_CONTEXT_TIME_ZONE(true),\n\n    /*\n    /******************************************************\n    /* Other\n    /******************************************************\n     */\n\n    /**\n     * Feature that determines whether {@link ObjectReader} should\n     * try to eagerly fetch necessary {@link JsonDeserializer} when\n     * possible. This improves performance in cases where similarly\n     * configured {@link ObjectReader} instance is used multiple\n     * times; and should not significantly affect single-use cases.\n     *<p>\n     * Note that there should not be any need to normally disable this\n     * feature: only consider that if there are actual perceived problems.\n     *<p>\n     * Feature is enabled by default.\n     * \n     * @since 2.1\n     */\n    EAGER_DESERIALIZER_FETCH(true)\n    \n    ;\n\n    private final boolean _defaultState;\n    private final int _mask;\n    \n    private DeserializationFeature(boolean defaultState) {\n        _defaultState = defaultState;\n        _mask = (1 << ordinal());\n    }\n\n    @Override\n    public boolean enabledByDefault() { return _defaultState; }\n\n    @Override\n    public int getMask() { return _mask; }\n\n    @Override\n    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n}\n", "package com.fasterxml.jackson.databind.deser;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.CoercionAction;\nimport com.fasterxml.jackson.databind.deser.impl.*;\nimport com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.IgnorePropertiesUtil;\nimport com.fasterxml.jackson.databind.util.NameTransformer;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\n\n/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Lazily constructed exception used as root cause if reporting problem\n     * with creator method that returns <code>null</code> (which is not allowed)\n     *\n     * @since 2.8\n     */\n    protected transient Exception _nullFromCreator;\n\n    /**\n     * State marker we need in order to avoid infinite recursion for some cases\n     * (not very clean, alas, but has to do for now)\n     *\n     * @since 2.9\n     */\n    private volatile transient NameTransformer _currentlyTransforming;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     *\n     * @deprecated in 2.12, remove from 3.0\n     */\n    @Deprecated\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n        super(builder, beanDesc, properties, backRefs,\n                ignorableProps, ignoreAllUnknown, null, hasViews);\n    }\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     *\n     * @since 2.12\n     */\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n                            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n                            HashSet<String> ignorableProps, boolean ignoreAllUnknown, Set<String> includableProps,\n                            boolean hasViews)\n    {\n        super(builder, beanDesc, properties, backRefs,\n                ignorableProps, ignoreAllUnknown, includableProps, hasViews);\n    }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write style copying of settings of an existing instance.\n     */\n    protected BeanDeserializer(BeanDeserializerBase src) {\n        super(src, src._ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown) {\n        super(src, ignoreAllUnknown);\n    }\n\n    protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {\n        super(src, unwrapper);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {\n        super(src, oir);\n    }\n\n    /**\n     * @deprecated in 2.12, remove from 3.0\n     */\n    @Deprecated\n    public BeanDeserializer(BeanDeserializerBase src, Set<String> ignorableProps) {\n        super(src, ignorableProps);\n    }\n\n    /**\n     * @since 2.12\n     */\n    public BeanDeserializer(BeanDeserializerBase src, Set<String> ignorableProps, Set<String> includableProps) {\n        super(src, ignorableProps, includableProps);\n    }\n\n    public BeanDeserializer(BeanDeserializerBase src, BeanPropertyMap props) {\n        super(src, props);\n    }\n\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer transformer)\n    {\n        // bit kludgy but we don't want to accidentally change type; sub-classes\n        // MUST override this method to support unwrapped properties...\n        if (getClass() != BeanDeserializer.class) {\n            return this;\n        }\n        // 25-Mar-2017, tatu: Not clean at all, but for [databind#383] we do need\n        //   to keep track of accidental recursion...\n        if (_currentlyTransforming == transformer) {\n            return this;\n        }\n        _currentlyTransforming = transformer;\n        try {\n            return new BeanDeserializer(this, transformer);\n        } finally { _currentlyTransforming = null; }\n    }\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }\n\n    @Override\n    public BeanDeserializer withByNameInclusion(Set<String> ignorableProps,\n            Set<String> includableProps) {\n        return new BeanDeserializer(this, ignorableProps, includableProps);\n    }\n\n    @Override\n    public BeanDeserializerBase withIgnoreAllUnknown(boolean ignoreUnknown) {\n        return new BeanDeserializer(this, ignoreUnknown);\n    }\n\n    @Override\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BeanDeserializer(this, props);\n    }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            // 23-Sep-2015, tatu: This is wrong at some many levels, but for now... it is\n            //    what it is, including \"expected behavior\".\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        return _deserializeOther(p, ctxt, p.currentToken());\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        if (t != null) {\n            switch (t) {\n            case VALUE_STRING:\n                return deserializeFromString(p, ctxt);\n            case VALUE_NUMBER_INT:\n                return deserializeFromNumber(p, ctxt);\n            case VALUE_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case VALUE_EMBEDDED_OBJECT:\n                return deserializeFromEmbedded(p, ctxt);\n            case VALUE_TRUE:\n            case VALUE_FALSE:\n                return deserializeFromBoolean(p, ctxt);\n            case VALUE_NULL:\n                return deserializeFromNull(p, ctxt);\n            case START_ARRAY:\n                // these only work if there's a (delegating) creator, or UNWRAP_SINGLE_ARRAY\n                return _deserializeFromArray(p, ctxt);\n            case FIELD_NAME:\n            case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n                if (_vanillaProcessing) {\n                    return vanillaDeserialize(p, ctxt, t);\n                }\n                if (_objectIdReader != null) {\n                    return deserializeWithObjectId(p, ctxt);\n                }\n                return deserializeFromObject(p, ctxt);\n            default:\n            }\n        }\n        return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.currentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.currentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * General version used when handling needs more advanced features.\n     */\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [databind#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if ((_objectIdReader != null) && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.currentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.currentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        TokenBuffer unknown = null;\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n        JsonToken t = p.currentToken();\n        List<BeanReferring> referrings = null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            p.nextToken(); // to point to value\n            final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            // Object Id property?\n            if (buffer.readIdProperty(propName) && creatorProp == null) {\n                continue;\n            }\n            // creator property?\n            if (creatorProp != null) {\n                // Last creator property to set?\n                Object value;\n                if ((activeView != null) && !creatorProp.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                value = _deserializeWithErrorWrapping(p, ctxt, creatorProp);\n                if (buffer.assignParameter(creatorProp, value)) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    if (bean == null) {\n                        return ctxt.handleInstantiationProblem(handledType(), null,\n                                _creatorReturnedNullException());\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                try {\n                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                } catch (UnresolvedForwardReference reference) {\n                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                    //    handling of forward references here. Not exactly sure why existing\n                    //    facilities did not cover, but this does appear to solve the problem\n                    BeanReferring referring = handleUnresolvedReference(ctxt,\n                            prop, buffer, reference);\n                    if (referrings == null) {\n                        referrings = new ArrayList<BeanReferring>();\n                    }\n                    referrings.add(referring);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n\n            // 29-Mar-2021, tatu: [databind#3082] May skip collection if we know\n            //    they'd just get ignored (note: any-setter handled above; unwrapped\n            //    properties also separately handled)\n            if (_ignoreAllUnknown) {\n                // 22-Aug-2021, tatu: [databind#3252] must ensure we do skip the whole value\n                p.skipChildren();\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = ctxt.bufferForInputBuffering(p);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        // 13-Apr-2020, tatu: [databind#2678] need to handle injection here\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n\n        if (referrings != null) {\n            for (BeanReferring referring : referrings) {\n               referring.setBean(bean);\n            }\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) { // lgtm [java/dereferenced-value-may-be-null]\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }\n\n    /**\n     * @since 2.8\n     */\n    private BeanReferring handleUnresolvedReference(DeserializationContext ctxt,\n            SettableBeanProperty prop, PropertyValueBuffer buffer,\n            UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        BeanReferring referring = new BeanReferring(ctxt, reference,\n                prop.getType(), buffer, prop);\n        reference.getRoid().appendReferring(referring);\n        return referring;\n    }\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException\n    {\n        try {\n            return prop.deserialize(p, ctxt);\n        } catch (Exception e) {\n            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);\n            // never gets here, unless caller declines to throw an exception\n            return null;\n        }\n    }\n\n    /**\n     * Helper method called for rare case of pointing to {@link JsonToken#VALUE_NULL}\n     * token. While this is most often an erroneous condition, there is one specific\n     * case with XML handling where polymorphic type with no properties is exposed\n     * as such, and should be handled same as empty Object.\n     *\n     * @since 2.7\n     */\n    protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic\n        //   \"empty\" POJOs deserialized from XML, where empty XML tag synthesizes a\n        //   `VALUE_NULL` token.\n        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tb = ctxt.bufferForInputBuffering(p);\n            tb.writeEndObject();\n            JsonParser p2 = tb.asParser(p);\n            p2.nextToken(); // to point to END_OBJECT\n            // note: don't have ObjectId to consider at this point, so:\n            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)\n                    : deserializeFromObject(p2, ctxt);\n            p2.close();\n            return ob;\n        }\n        return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    }\n\n    @Override\n    protected Object _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // note: cannot call `_delegateDeserializer()` since order reversed here:\n        JsonDeserializer<Object> delegateDeser = _arrayDelegateDeserializer;\n        // fallback to non-array delegate\n        if ((delegateDeser != null) || ((delegateDeser = _delegateDeserializer) != null)) {\n            Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt,\n                    delegateDeser.deserialize(p, ctxt));\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            return bean;\n        }\n        final CoercionAction act = _findCoercionFromEmptyArray(ctxt);\n        final boolean unwrap = ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS);\n\n        if (unwrap || (act != CoercionAction.Fail)) {\n            JsonToken t = p.nextToken();\n            if (t == JsonToken.END_ARRAY) {\n                switch (act) {\n                case AsEmpty:\n                    return getEmptyValue(ctxt);\n                case AsNull:\n                case TryConvert:\n                    return getNullValue(ctxt);\n                default:\n                }\n                return ctxt.handleUnexpectedToken(getValueType(ctxt), JsonToken.START_ARRAY, p, null);\n            }\n            if (unwrap) {\n                // 23-Aug-2022, tatu: To prevent unbounded nested arrays, we better\n                //   check there is NOT another START_ARRAY lurking there..\n                if (p.nextToken() == JsonToken.START_ARRAY) {\n                    JavaType targetType = getValueType(ctxt);\n                    return ctxt.handleUnexpectedToken(targetType, JsonToken.START_ARRAY, p,\n\"Cannot deserialize value of type %s from deeply-nested JSON Array: only single wrapper allowed with `%s`\",\n                            ClassUtil.getTypeDescription(targetType),\n                                    \"DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS\");\n                }\n                final Object value = deserialize(p, ctxt);\n                if (p.nextToken() != JsonToken.END_ARRAY) {\n                    handleMissingEndArrayForSingle(p, ctxt);\n                }\n                return value;\n            }\n        }\n        return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializing when we have to consider an active View\n    /**********************************************************\n     */\n\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException\n    {\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.currentName();\n            do {\n                p.nextToken();\n                // TODO: 06-Jan-2015, tatu: try streamlining call sequences here as well\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    if (!prop.visibleInView(activeView)) {\n                        p.skipChildren();\n                        continue;\n                    }\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n    \n    /*\n    /**********************************************************\n    /* Handling for cases where we have \"unwrapped\" values\n    /**********************************************************\n     */\n\n    /**\n     * Method called when there are declared \"unwrapped\" properties\n     * which need special handling\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n        }\n        TokenBuffer tokens = ctxt.bufferForInputBuffering(p);\n        tokens.writeStartObject();\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        String propName = p.hasTokenId(JsonTokenId.ID_FIELD_NAME) ? p.currentName() : null;\n\n        for (; propName != null; propName = p.nextFieldName()) {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                if ((activeView != null) && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n                continue;\n            }\n            // Need to copy to a separate buffer first\n            TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);\n            tokens.writeFieldName(propName);\n            tokens.append(b2);\n            try {\n                _anySetter.deserializeAndSet(b2.asParserOnFirstToken(), ctxt, bean, propName);\n            } catch (Exception e) {\n                wrapAndThrow(e, bean, propName, ctxt);\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        JsonToken t = p.currentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        TokenBuffer tokens = ctxt.bufferForInputBuffering(p);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    _anySetter.deserializeAndSet(b2.asParserOnFirstToken(), ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n        //    Ok however to pass via setter or field.\n        \n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = ctxt.bufferForInputBuffering(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.currentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            // Object Id property?\n            if (buffer.readIdProperty(propName) && creatorProp == null) {\n                continue;\n            }\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                    //    problems if we maintain invariants\n                    if (t != JsonToken.END_OBJECT) {\n                        ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \n                                \"Attempted to unwrap '%s' value\",\n                                handledType().getName());\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        ctxt.reportInputMismatch(creatorProp,\n                                \"Cannot create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName,\n                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have property/-ies with\n    /* external type id\n    /**********************************************************\n     */\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            /* 24-Nov-2015, tatu: Use of delegating creator needs to have precedence, and basically\n             *   external type id handling just has to be ignored, as they would relate to target\n             *   type and not delegate type. Whether this works as expected is another story, but\n             *   there's no other way to really mix these conflicting features.\n             */\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        return _deserializeWithExternalTypeId(p, ctxt, bean,\n                _externalTypeIdHandler.start());\n    }\n\n    protected Object _deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean, ExternalTypeHandler ext)\n        throws IOException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (JsonToken t = p.currentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                // [JACKSON-831]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                }\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n        JsonToken t = p.currentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            t = p.nextToken(); // to point to value\n            // creator property?\n            final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            // Object Id property?\n            if (buffer.readIdProperty(propName) && creatorProp == null) {\n                continue;\n            }\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp,\n                            _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            return ctxt.reportBadDefinition(_beanType, String.format(\n                                    \"Cannot create polymorphic instances with external type ids (%s -> %s)\",\n                                    _beanType, bean.getClass()));\n                        }\n                        return _deserializeWithExternalTypeId(p, ctxt, bean, ext);\n                    }\n                }\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                // [databind#3045]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, null);\n                }\n                // 19-Feb-2021, tatu: Should probably consider view too?\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                } else {\n                    buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                }\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName,\n                        _anySetter.deserialize(p, ctxt));\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, _valueClass, propName);\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n    }\n\n    /**\n     * Helper method for getting a lazily construct exception to be reported\n     * to {@link DeserializationContext#handleInstantiationProblem(Class, Object, Throwable)}.\n     *\n     * @since 2.8\n     */\n    protected Exception _creatorReturnedNullException() {\n        if (_nullFromCreator == null) {\n            _nullFromCreator = new NullPointerException(\"JSON Creator returned null\");\n        }\n        return _nullFromCreator;\n    }\n\n    /**\n     * @since 2.8\n     */\n    static class BeanReferring extends Referring\n    {\n        private final DeserializationContext _context;\n        private final SettableBeanProperty _prop;\n        private Object _bean;\n\n        BeanReferring(DeserializationContext ctxt, UnresolvedForwardReference ref,\n                JavaType valueType, PropertyValueBuffer buffer, SettableBeanProperty prop)\n        {\n            super(ref, valueType);\n            _context = ctxt;\n            _prop = prop;\n        }\n\n        public void setBean(Object bean) {\n            _bean = bean;\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n        {\n            if (_bean == null) {\n                _context.reportInputMismatch(_prop,\n\"Cannot resolve ObjectId forward reference using property '%s' (of type %s): Bean not yet resolved\",\n_prop.getName(), _prop.getDeclaringClass().getName());\n        }\n            _prop.set(_bean, value);\n        }\n    }\n}\n", "package com.fasterxml.jackson.databind.deser.dos;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.exc.MismatchedInputException;\n\npublic class DeepArrayWrappingForDeser3582Test extends BaseMapTest\n{\n    // 23-Aug-2022, tatu: Before fix, failed with 5000\n    private final static int TOO_DEEP_NESTING = 9999;\n\n    private final ObjectMapper MAPPER = jsonMapperBuilder()\n            .enable(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)\n            .build();\n\n    public void testArrayWrapping() throws Exception\n    {\n        final String doc = _nestedDoc(TOO_DEEP_NESTING, \"[ \", \"] \", \"{}\");\n        try {\n            MAPPER.readValue(doc, Point.class);\n            fail(\"Should not pass\");\n        } catch (MismatchedInputException e) {\n            verifyException(e, \"Cannot deserialize\");\n            verifyException(e, \"nested JSON Array\");\n            verifyException(e, \"only single\");\n        }\n    }\n\n    private String _nestedDoc(int nesting, String open, String close, String content) {\n        StringBuilder sb = new StringBuilder(nesting * (open.length() + close.length()));\n        for (int i = 0; i < nesting; ++i) {\n            sb.append(open);\n            if ((i & 31) == 0) {\n                sb.append(\"\\n\");\n            }\n        }\n        sb.append(\"\\n\").append(content).append(\"\\n\");\n        for (int i = 0; i < nesting; ++i) {\n            sb.append(close);\n            if ((i & 31) == 0) {\n                sb.append(\"\\n\");\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"], "filenames": ["release-notes/VERSION-2.x", "src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java", "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java", "src/test/java/com/fasterxml/jackson/databind/deser/dos/DeepArrayWrappingForDeser3582Test.java"], "buggy_code_start_loc": [15, 320, 10, 3], "buggy_code_end_loc": [15, 322, 630, 21], "fixing_code_start_loc": [16, 320, 11, 4], "fixing_code_end_loc": [18, 324, 641, 26], "type": "CWE-502", "message": "In FasterXML jackson-databind before 2.13.4, resource exhaustion can occur because of a lack of a check in BeanDeserializer._deserializeFromArray to prevent use of deeply nested arrays. An application is vulnerable only with certain customized choices for deserialization.", "other": {"cve": {"id": "CVE-2022-42004", "sourceIdentifier": "cve@mitre.org", "published": "2022-10-02T05:15:09.237", "lastModified": "2022-12-02T15:10:05.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FasterXML jackson-databind before 2.13.4, resource exhaustion can occur because of a lack of a check in BeanDeserializer._deserializeFromArray to prevent use of deeply nested arrays. An application is vulnerable only with certain customized choices for deserialization."}, {"lang": "es", "value": "En FasterXML jackson-databind versiones anteriores a 2.13.4, el agotamiento de los recursos puede ocurrir debido a una falta de comprobaci\u00f3n en BeanDeserializer._deserializeFromArray para impedir el uso de arrays profundamente anidados. Una aplicaci\u00f3n es vulnerable s\u00f3lo con determinadas opciones personalizadas para la deserializaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.12.7.1", "matchCriteriaId": "0848F177-1977-4C9C-B91A-7374FF25F335"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fasterxml:jackson-databind:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.13.0", "versionEndExcluding": "2.13.4", "matchCriteriaId": "2BB48E8E-EB2F-46D1-BD98-982FB3528273"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quarkus:quarkus:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.13.0", "matchCriteriaId": "5CA36870-3A63-428D-BC49-4924FF75FAAD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=50490", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FasterXML/jackson-databind/commit/063183589218fec19a9293ed2f17ec53ea80ba88", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FasterXML/jackson-databind/issues/3582", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-21", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221118-0008/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5283", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FasterXML/jackson-databind/commit/063183589218fec19a9293ed2f17ec53ea80ba88"}}