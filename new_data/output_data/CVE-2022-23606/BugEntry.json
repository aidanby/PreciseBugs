{"buggy_code": ["1.22.0 (pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\n* tls: set TLS v1.2 as the default minimal version for servers. Users can still explicitly opt-in to 1.0 and 1.1 using :ref:`tls_minimum_protocol_version <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsParameters.tls_minimum_protocol_version>`.\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\n* dynamic_forward_proxy: if a DNS resolution fails, failing immediately with a specific resolution error, rather than finishing up all local filters and failing to select an upstream host.\n* ext_authz: added requested server name in ext_authz network filter for auth review.\n* file: changed disk based files to truncate files which are not being appended to. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.append_or_truncate`` to false.\n* grpc: flip runtime guard ``envoy.reloadable_features.enable_grpc_async_client_cache`` to be default enabled. async grpc client created through getOrCreateRawAsyncClient will be cached by default.\n* http: avoiding delay-close for HTTP/1.0 responses framed by connection: close as well as HTTP/1.1 if the request is fully read. This means for responses to such requests, the FIN will be sent immediately after the response. This behavior can be temporarily reverted by setting ``envoy.reloadable_features.skip_delay_close`` to false.  If clients are are seen to be receiving sporadic partial responses and flipping this flag fixes it, please notify the project immediately.\n* http: now the max concurrent streams of http2 connection can not only be adjusted down according to the SETTINGS frame but also can be adjusted up, of course, it can not exceed the configured upper bounds. This fix is guarded by ``envoy.reloadable_features.http2_allow_capacity_increase_by_settings``.\n* http: when writing custom filters, `injectEncodedDataToFilterChain` and `injectDecodedDataToFilterChain` now trigger sending of headers if they were not yet sent due to `StopIteration`. Previously, calling one of the inject functions in that state would trigger an assertion. See issue #19891 for more details.\n* perf: ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret update.\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n* access_log: fix memory leak when reopening an access log fails. Access logs will now try to be reopened on each subsequent flush attempt after a failure.\n* data plane: fixing error handling where writing to a socket failed while under the stack of processing. This should genreally affect HTTP/3. This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.\n* eds: fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.\n* tls: fix a bug while matching a certificate SAN with an exact value in ``match_typed_subject_alt_names`` of a listener where wildcard ``*`` character is not the only character of the dns label. Example, ``baz*.example.net`` and ``*baz.example.net`` and ``b*z.example.net`` will match ``baz1.example.net`` and ``foobaz.example.net`` and ``buzz.example.net``, respectively.\n* xray: fix the AWS X-Ray tracer extension to not sample the trace if ``sampled=`` keyword is not present in the header ``x-amzn-trace-id``.\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n* access_log: removed ``envoy.reloadable_features.unquote_log_string_values`` and legacy code paths.\n* grpc_bridge_filter: removed ``envoy.reloadable_features.grpc_bridge_stats_disabled`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.hash_multiple_header_values`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.no_chunked_encoding_header_for_304`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.preserve_downstream_scheme`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.require_strict_1xx_and_204_response_headers`` and ``envoy.reloadable_features.send_strict_1xx_and_204_response_headers`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.strip_port_from_connect`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.use_observable_cluster_name`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http_transport_failure_reason_in_body`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.allow_response_for_timeout`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http2_consume_stream_refused_errors`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.internal_redirects_with_body`` and legacy code paths.\n* udp: removed ``envoy.reloadable_features.udp_per_event_loop_read_limit`` and legacy code paths.\n* upstream: removed ``envoy.reloadable_features.health_check.graceful_goaway_handling`` and legacy code paths.\n* xds: removed ``envoy.reloadable_features.vhds_heartbeats`` and legacy code paths.\n\n\nNew Features\n------------\n* access_log: make consistent access_log format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* admin: :http:post:`/logging` now accepts ``/logging?paths=name1:level1,name2:level2,...`` to change multiple log levels at once.\n* config: added new file based xDS configuration via :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`.\n  :ref:`watched_directory <envoy_v3_api_field_config.core.v3.PathConfigSource.watched_directory>` can\n  be used to setup an independent watch for when to reload the file path, for example when using\n  Kubernetes ConfigMaps to deliver configuration. See the linked documentation for more information.\n* cors: add dynamic support for headers ``access-control-allow-methods`` and ``access-control-allow-headers`` in cors.\n* http: added random_value_specifier in :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` to allow random value to be specified from configuration proto.\n* http: added support for :ref:`proxy_status_config <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.proxy_status_config>` for configuring `Proxy-Status <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08>`_ HTTP response header fields.\n* http: make consistent custom header format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* http3: downstream HTTP/3 support is now GA! Upstream HTTP/3 also GA for specific deployments. See :ref:`here <arch_overview_http3>` for details.\n* http3: supports upstream HTTP/3 retries. Automatically retry `0-RTT safe requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ if they are rejected because they are sent `too early <https://datatracker.ietf.org/doc/html/rfc8470#section-5.2>`_. And automatically retry 0-RTT safe requests if connect attempt fails later on and the cluster is configured with TCP fallback. And add retry on ``http3-post-connect-failure`` policy which allows retry of failed HTTP/3 requests with TCP fallback even after handshake if the cluster is configured with TCP fallback. This feature is guarded by ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3``.\n* matching: the matching API can now express a match tree that will always match by omitting a matcher at the top level.\n* outlier_detection: :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` configuration added to allow adding a random value to the ejection time to prevent 'thundering herd' scenarios. Defaults to 0 so as to not break or change the behavior of existing deployments.\n\nDeprecated\n----------\n\n* config: deprecated :ref:`path <envoy_v3_api_field_config.core.v3.ConfigSource.path>` in favor of\n  :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`\n* http: removing support for long-deprecated old style filter names, e.g. envoy.router, envoy.lua.\n* re2: removed undocumented histograms ``re2.program_size`` and ``re2.exceeded_warn_level``.\n", "load(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_library\",\n    \"envoy_package\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_package()\n\nenvoy_cc_library(\n    name = \"conn_pool_base_lib\",\n    srcs = [\"conn_pool_base.cc\"],\n    hdrs = [\"conn_pool_base.h\"],\n    deps = [\n        \"//envoy/stats:timespan_interface\",\n        \"//source/common/common:linked_object\",\n        \"//source/common/stats:timespan_lib\",\n        \"//source/common/upstream:upstream_lib\",\n    ],\n)\n", "#include \"source/common/conn_pool/conn_pool_base.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/network/transport_socket_options_impl.h\"\n#include \"source/common/runtime/runtime_features.h\"\n#include \"source/common/stats/timespan_impl.h\"\n#include \"source/common/upstream/upstream_impl.h\"\n\nnamespace Envoy {\nnamespace ConnectionPool {\nnamespace {\n[[maybe_unused]] ssize_t connectingCapacity(const std::list<ActiveClientPtr>& connecting_clients) {\n  ssize_t ret = 0;\n  for (const auto& client : connecting_clients) {\n    ret += client->effectiveConcurrentStreamLimit();\n  }\n  return ret;\n}\n} // namespace\n\nConnPoolImplBase::ConnPoolImplBase(\n    Upstream::HostConstSharedPtr host, Upstream::ResourcePriority priority,\n    Event::Dispatcher& dispatcher, const Network::ConnectionSocket::OptionsSharedPtr& options,\n    const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n    Upstream::ClusterConnectivityState& state)\n    : state_(state), host_(host), priority_(priority), dispatcher_(dispatcher),\n      socket_options_(options), transport_socket_options_(transport_socket_options),\n      upstream_ready_cb_(dispatcher_.createSchedulableCallback([this]() { onUpstreamReady(); })) {}\n\nConnPoolImplBase::~ConnPoolImplBase() {\n  ASSERT(isIdleImpl());\n  ASSERT(connecting_stream_capacity_ == 0);\n}\n\nvoid ConnPoolImplBase::deleteIsPendingImpl() {\n  deferred_deleting_ = true;\n  ASSERT(isIdleImpl());\n  ASSERT(connecting_stream_capacity_ == 0);\n}\n\nvoid ConnPoolImplBase::destructAllConnections() {\n  for (auto* list : {&ready_clients_, &busy_clients_, &connecting_clients_}) {\n    while (!list->empty()) {\n      list->front()->close();\n    }\n  }\n\n  // Make sure all clients are destroyed before we are destroyed.\n  dispatcher_.clearDeferredDeleteList();\n}\n\nbool ConnPoolImplBase::shouldConnect(size_t pending_streams, size_t active_streams,\n                                     int64_t connecting_and_connected_capacity,\n                                     float preconnect_ratio, bool anticipate_incoming_stream) {\n  // This is set to true any time global preconnect is being calculated.\n  // ClusterManagerImpl::maybePreconnect is called directly before a stream is created, so the\n  // stream must be anticipated.\n  //\n  // Also without this, we would never pre-establish a connection as the first\n  // connection in a pool because pending/active streams could both be 0.\n  int anticipated_streams = anticipate_incoming_stream ? 1 : 0;\n\n  // The number of streams we want to be provisioned for is the number of\n  // pending, active, and anticipated streams times the preconnect ratio.\n  // The number of streams we are (theoretically) provisioned for is the\n  // connecting stream capacity plus the number of active streams.\n  //\n  // If preconnect ratio is not set, it defaults to 1, and this simplifies to the\n  // legacy value of pending_streams_.size() > connecting_stream_capacity_\n  return (pending_streams + active_streams + anticipated_streams) * preconnect_ratio >\n         connecting_and_connected_capacity + active_streams;\n}\n\nbool ConnPoolImplBase::shouldCreateNewConnection(float global_preconnect_ratio) const {\n  // If the host is not healthy, don't make it do extra work, especially as\n  // upstream selection logic may result in bypassing this upstream entirely.\n  // If an Envoy user wants preconnecting for degraded upstreams this could be\n  // added later via extending the preconnect config.\n  if (host_->health() != Upstream::Host::Health::Healthy) {\n    return pending_streams_.size() > connecting_stream_capacity_;\n  }\n\n  // Determine if we are trying to prefetch for global preconnect or local preconnect.\n  if (global_preconnect_ratio != 0) {\n    // If global preconnecting is on, and this connection is within the global\n    // preconnect limit, preconnect.\n    // For global preconnect, we anticipate an incoming stream to this pool, since it is\n    // prefetching for the next upcoming stream, which will likely be assigned to this pool.\n    // We may eventually want to track preconnect_attempts to allow more preconnecting for\n    // heavily weighted upstreams or sticky picks.\n    return shouldConnect(pending_streams_.size(), num_active_streams_, connecting_stream_capacity_,\n                         global_preconnect_ratio, true);\n  } else {\n    // Ensure this local pool has adequate connections for the given load.\n    //\n    // Local preconnect does not need to anticipate a stream. It is called as\n    // new streams are established or torn down and simply attempts to maintain\n    // the correct ratio of streams and anticipated capacity.\n    return shouldConnect(pending_streams_.size(), num_active_streams_, connecting_stream_capacity_,\n                         perUpstreamPreconnectRatio());\n  }\n}\n\nfloat ConnPoolImplBase::perUpstreamPreconnectRatio() const {\n  return host_->cluster().perUpstreamPreconnectRatio();\n}\n\nConnPoolImplBase::ConnectionResult ConnPoolImplBase::tryCreateNewConnections() {\n  ASSERT(!is_draining_for_deletion_);\n  ConnPoolImplBase::ConnectionResult result;\n  // Somewhat arbitrarily cap the number of connections preconnected due to new\n  // incoming connections. The preconnect ratio is capped at 3, so in steady\n  // state, no more than 3 connections should be preconnected. If hosts go\n  // unhealthy, and connections are not immediately preconnected, it could be that\n  // many connections are desired when the host becomes healthy again, but\n  // overwhelming it with connections is not desirable.\n  for (int i = 0; i < 3; ++i) {\n    result = tryCreateNewConnection();\n    if (result != ConnectionResult::CreatedNewConnection) {\n      break;\n    }\n  }\n  return result;\n}\n\nConnPoolImplBase::ConnectionResult\nConnPoolImplBase::tryCreateNewConnection(float global_preconnect_ratio) {\n  // There are already enough CONNECTING connections for the number of queued streams.\n  if (!shouldCreateNewConnection(global_preconnect_ratio)) {\n    ENVOY_LOG(trace, \"not creating a new connection, shouldCreateNewConnection returned false.\");\n    return ConnectionResult::ShouldNotConnect;\n  }\n\n  const bool can_create_connection =\n      host_->cluster().resourceManager(priority_).connections().canCreate();\n  if (!can_create_connection) {\n    host_->cluster().stats().upstream_cx_overflow_.inc();\n  }\n  // If we are at the connection circuit-breaker limit due to other upstreams having\n  // too many open connections, and this upstream has no connections, always create one, to\n  // prevent pending streams being queued to this upstream with no way to be processed.\n  if (can_create_connection ||\n      (ready_clients_.empty() && busy_clients_.empty() && connecting_clients_.empty())) {\n    ENVOY_LOG(debug, \"creating a new connection\");\n    ActiveClientPtr client = instantiateActiveClient();\n    if (client.get() == nullptr) {\n      ENVOY_LOG(trace, \"connection creation failed\");\n      return ConnectionResult::FailedToCreateConnection;\n    }\n    ASSERT(client->state() == ActiveClient::State::CONNECTING);\n    ASSERT(std::numeric_limits<uint64_t>::max() - connecting_stream_capacity_ >=\n           client->effectiveConcurrentStreamLimit());\n    ASSERT(client->real_host_description_);\n    // Increase the connecting capacity to reflect the streams this connection can serve.\n    state_.incrConnectingAndConnectedStreamCapacity(client->effectiveConcurrentStreamLimit());\n    connecting_stream_capacity_ += client->effectiveConcurrentStreamLimit();\n    LinkedList::moveIntoList(std::move(client), owningList(client->state()));\n    return can_create_connection ? ConnectionResult::CreatedNewConnection\n                                 : ConnectionResult::CreatedButRateLimited;\n  } else {\n    ENVOY_LOG(trace, \"not creating a new connection: connection constrained\");\n    return ConnectionResult::NoConnectionRateLimited;\n  }\n}\n\nvoid ConnPoolImplBase::attachStreamToClient(Envoy::ConnectionPool::ActiveClient& client,\n                                            AttachContext& context) {\n  ASSERT(client.state() == Envoy::ConnectionPool::ActiveClient::State::READY);\n\n  if (enforceMaxRequests() && !host_->cluster().resourceManager(priority_).requests().canCreate()) {\n    ENVOY_LOG(debug, \"max streams overflow\");\n    onPoolFailure(client.real_host_description_, absl::string_view(),\n                  ConnectionPool::PoolFailureReason::Overflow, context);\n    host_->cluster().stats().upstream_rq_pending_overflow_.inc();\n    return;\n  }\n  ENVOY_CONN_LOG(debug, \"creating stream\", client);\n\n  // Latch capacity before updating remaining streams.\n  uint64_t capacity = client.currentUnusedCapacity();\n  client.remaining_streams_--;\n  if (client.remaining_streams_ == 0) {\n    ENVOY_CONN_LOG(debug, \"maximum streams per connection, DRAINING\", client);\n    host_->cluster().stats().upstream_cx_max_requests_.inc();\n    transitionActiveClientState(client, Envoy::ConnectionPool::ActiveClient::State::DRAINING);\n  } else if (capacity == 1) {\n    // As soon as the new stream is created, the client will be maxed out.\n    transitionActiveClientState(client, Envoy::ConnectionPool::ActiveClient::State::BUSY);\n  }\n\n  // Decrement the capacity, as there's one less stream available for serving.\n  // For HTTP/3, the capacity is updated in newStreamEncoder.\n  if (trackStreamCapacity()) {\n    state_.decrConnectingAndConnectedStreamCapacity(1);\n  }\n  // Track the new active stream.\n  state_.incrActiveStreams(1);\n  num_active_streams_++;\n  host_->stats().rq_total_.inc();\n  host_->stats().rq_active_.inc();\n  host_->cluster().stats().upstream_rq_total_.inc();\n  host_->cluster().stats().upstream_rq_active_.inc();\n  host_->cluster().resourceManager(priority_).requests().inc();\n\n  onPoolReady(client, context);\n}\n\nvoid ConnPoolImplBase::onStreamClosed(Envoy::ConnectionPool::ActiveClient& client,\n                                      bool delay_attaching_stream) {\n  ENVOY_CONN_LOG(debug, \"destroying stream: {} remaining\", client, client.numActiveStreams());\n  ASSERT(num_active_streams_ > 0);\n  state_.decrActiveStreams(1);\n  num_active_streams_--;\n  host_->stats().rq_active_.dec();\n  host_->cluster().stats().upstream_rq_active_.dec();\n  host_->cluster().resourceManager(priority_).requests().dec();\n  // We don't update the capacity for HTTP/3 as the stream count should only\n  // increase when a MAX_STREAMS frame is received.\n  if (trackStreamCapacity()) {\n    // If the effective client capacity was limited by concurrency, increase connecting capacity.\n    bool limited_by_concurrency =\n        client.remaining_streams_ > client.concurrent_stream_limit_ - client.numActiveStreams() - 1;\n    // The capacity calculated by concurrency could be negative if a SETTINGS frame lowered the\n    // number of allowed streams. In this case, effective client capacity was still limited by\n    // concurrency, compare client.concurrent_stream_limit_ and client.numActiveStreams() directly\n    // to avoid overflow.\n    bool negative_capacity = client.concurrent_stream_limit_ < client.numActiveStreams() + 1;\n    if (negative_capacity || limited_by_concurrency) {\n      state_.incrConnectingAndConnectedStreamCapacity(1);\n    }\n  }\n  if (client.state() == ActiveClient::State::DRAINING && client.numActiveStreams() == 0) {\n    // Close out the draining client if we no longer have active streams.\n    client.close();\n  } else if (client.state() == ActiveClient::State::BUSY && client.currentUnusedCapacity() > 0) {\n    transitionActiveClientState(client, ActiveClient::State::READY);\n    if (!delay_attaching_stream) {\n      onUpstreamReady();\n    }\n  }\n}\n\nConnectionPool::Cancellable* ConnPoolImplBase::newStreamImpl(AttachContext& context,\n                                                             bool can_send_early_data) {\n  ASSERT(!is_draining_for_deletion_);\n  ASSERT(!deferred_deleting_);\n\n  ASSERT(static_cast<ssize_t>(connecting_stream_capacity_) ==\n         connectingCapacity(connecting_clients_)); // O(n) debug check.\n  if (!ready_clients_.empty()) {\n    ActiveClient& client = *ready_clients_.front();\n    ENVOY_CONN_LOG(debug, \"using existing connection\", client);\n    attachStreamToClient(client, context);\n    // Even if there's a ready client, we may want to preconnect to handle the next incoming stream.\n    tryCreateNewConnections();\n    return nullptr;\n  }\n\n  if (!host_->cluster().resourceManager(priority_).pendingRequests().canCreate()) {\n    ENVOY_LOG(debug, \"max pending streams overflow\");\n    onPoolFailure(nullptr, absl::string_view(), ConnectionPool::PoolFailureReason::Overflow,\n                  context);\n    host_->cluster().stats().upstream_rq_pending_overflow_.inc();\n    return nullptr;\n  }\n\n  ConnectionPool::Cancellable* pending = newPendingStream(context, can_send_early_data);\n  ENVOY_LOG(debug, \"trying to create new connection\");\n  ENVOY_LOG(trace, fmt::format(\"{}\", *this));\n\n  auto old_capacity = connecting_stream_capacity_;\n  // This must come after newPendingStream() because this function uses the\n  // length of pending_streams_ to determine if a new connection is needed.\n  const ConnectionResult result = tryCreateNewConnections();\n  // If there is not enough connecting capacity, the only reason to not\n  // increase capacity is if the connection limits are exceeded.\n  ENVOY_BUG(pending_streams_.size() <= connecting_stream_capacity_ ||\n                connecting_stream_capacity_ > old_capacity ||\n                (result == ConnectionResult::NoConnectionRateLimited ||\n                 result == ConnectionResult::FailedToCreateConnection),\n            fmt::format(\"Failed to create expected connection: {}\", *this));\n  if (result == ConnectionResult::FailedToCreateConnection) {\n    // This currently only happens for HTTP/3 if secrets aren't yet loaded.\n    // Trigger connection failure.\n    pending->cancel(Envoy::ConnectionPool::CancelPolicy::CloseExcess);\n    onPoolFailure(nullptr, absl::string_view(), ConnectionPool::PoolFailureReason::Overflow,\n                  context);\n    return nullptr;\n  }\n\n  return pending;\n}\n\nbool ConnPoolImplBase::maybePreconnectImpl(float global_preconnect_ratio) {\n  ASSERT(!deferred_deleting_);\n  return tryCreateNewConnection(global_preconnect_ratio) == ConnectionResult::CreatedNewConnection;\n}\n\nvoid ConnPoolImplBase::scheduleOnUpstreamReady() {\n  upstream_ready_cb_->scheduleCallbackCurrentIteration();\n}\n\nvoid ConnPoolImplBase::onUpstreamReady() {\n  while (!pending_streams_.empty() && !ready_clients_.empty()) {\n    ActiveClientPtr& client = ready_clients_.front();\n    ENVOY_CONN_LOG(debug, \"attaching to next stream\", *client);\n    // Pending streams are pushed onto the front, so pull from the back.\n    attachStreamToClient(*client, pending_streams_.back()->context());\n    state_.decrPendingStreams(1);\n    pending_streams_.pop_back();\n  }\n  if (!pending_streams_.empty()) {\n    tryCreateNewConnections();\n  }\n}\n\nstd::list<ActiveClientPtr>& ConnPoolImplBase::owningList(ActiveClient::State state) {\n  switch (state) {\n  case ActiveClient::State::CONNECTING:\n    return connecting_clients_;\n  case ActiveClient::State::READY:\n    return ready_clients_;\n  case ActiveClient::State::BUSY:\n    return busy_clients_;\n  case ActiveClient::State::DRAINING:\n    return busy_clients_;\n  case ActiveClient::State::CLOSED:\n    break; // Fall through to PANIC.\n  }\n  PANIC(\"unexpected\");\n}\n\nvoid ConnPoolImplBase::transitionActiveClientState(ActiveClient& client,\n                                                   ActiveClient::State new_state) {\n  auto& old_list = owningList(client.state());\n  auto& new_list = owningList(new_state);\n  client.setState(new_state);\n\n  // old_list and new_list can be equal when transitioning from BUSY to DRAINING.\n  //\n  // The documentation for list.splice() (which is what moveBetweenLists() calls) is\n  // unclear whether it is allowed for src and dst to be the same, so check here\n  // since it is a no-op anyways.\n  if (&old_list != &new_list) {\n    client.moveBetweenLists(old_list, new_list);\n  }\n}\n\nvoid ConnPoolImplBase::addIdleCallbackImpl(Instance::IdleCb cb) { idle_callbacks_.push_back(cb); }\n\nvoid ConnPoolImplBase::closeIdleConnectionsForDrainingPool() {\n  // Create a separate list of elements to close to avoid mutate-while-iterating problems.\n  std::list<ActiveClient*> to_close;\n\n  for (auto& client : ready_clients_) {\n    if (client->numActiveStreams() == 0) {\n      to_close.push_back(client.get());\n    }\n  }\n\n  if (pending_streams_.empty()) {\n    for (auto& client : connecting_clients_) {\n      to_close.push_back(client.get());\n    }\n  }\n\n  for (auto& entry : to_close) {\n    ENVOY_LOG_EVENT(debug, \"closing_idle_client\", \"closing idle client {} for cluster {}\",\n                    entry->id(), host_->cluster().name());\n    entry->close();\n  }\n}\n\nvoid ConnPoolImplBase::drainConnectionsImpl(DrainBehavior drain_behavior) {\n  if (drain_behavior == Envoy::ConnectionPool::DrainBehavior::DrainAndDelete) {\n    is_draining_for_deletion_ = true;\n    checkForIdleAndCloseIdleConnsIfDraining();\n    return;\n  }\n  closeIdleConnectionsForDrainingPool();\n\n  // closeIdleConnections() closes all connections in ready_clients_ with no active streams,\n  // so all remaining entries in ready_clients_ are serving streams. Move them and all entries\n  // in busy_clients_ to draining.\n  while (!ready_clients_.empty()) {\n    ENVOY_LOG_EVENT(debug, \"draining_ready_client\", \"draining active client {} for cluster {}\",\n                    ready_clients_.front()->id(), host_->cluster().name());\n    transitionActiveClientState(*ready_clients_.front(), ActiveClient::State::DRAINING);\n  }\n\n  // Changing busy_clients_ to DRAINING does not move them between lists,\n  // so use a for-loop since the list is not mutated.\n  ASSERT(&owningList(ActiveClient::State::DRAINING) == &busy_clients_);\n  for (auto& busy_client : busy_clients_) {\n    ENVOY_LOG_EVENT(debug, \"draining_busy_client\", \"draining busy client {} for cluster {}\",\n                    busy_client->id(), host_->cluster().name());\n    transitionActiveClientState(*busy_client, ActiveClient::State::DRAINING);\n  }\n}\n\nbool ConnPoolImplBase::isIdleImpl() const {\n  return pending_streams_.empty() && ready_clients_.empty() && busy_clients_.empty() &&\n         connecting_clients_.empty();\n}\n\nvoid ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}\n\nvoid ConnPoolImplBase::onConnectionEvent(ActiveClient& client, absl::string_view failure_reason,\n                                         Network::ConnectionEvent event) {\n  if (client.state() == ActiveClient::State::CONNECTING) {\n    ASSERT(connecting_stream_capacity_ >= client.effectiveConcurrentStreamLimit());\n    connecting_stream_capacity_ -= client.effectiveConcurrentStreamLimit();\n  }\n\n  if (client.connect_timer_) {\n    client.connect_timer_->disableTimer();\n    client.connect_timer_.reset();\n  }\n\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    state_.decrConnectingAndConnectedStreamCapacity(client.currentUnusedCapacity());\n    // Make sure that onStreamClosed won't double count.\n    client.remaining_streams_ = 0;\n    // The client died.\n    ENVOY_CONN_LOG(debug, \"client disconnected, failure reason: {}\", client, failure_reason);\n\n    Envoy::Upstream::reportUpstreamCxDestroy(host_, event);\n    const bool incomplete_stream = client.closingWithIncompleteStream();\n    if (incomplete_stream) {\n      Envoy::Upstream::reportUpstreamCxDestroyActiveRequest(host_, event);\n    }\n\n    if (client.state() == ActiveClient::State::CONNECTING) {\n      host_->cluster().stats().upstream_cx_connect_fail_.inc();\n      host_->stats().cx_connect_fail_.inc();\n\n      ConnectionPool::PoolFailureReason reason;\n      if (client.timed_out_) {\n        reason = ConnectionPool::PoolFailureReason::Timeout;\n      } else if (event == Network::ConnectionEvent::RemoteClose) {\n        reason = ConnectionPool::PoolFailureReason::RemoteConnectionFailure;\n      } else {\n        reason = ConnectionPool::PoolFailureReason::LocalConnectionFailure;\n      }\n\n      // Raw connect failures should never happen under normal circumstances. If we have an upstream\n      // that is behaving badly, streams can get stuck here in the pending state. If we see a\n      // connect failure, we purge all pending streams so that calling code can determine what to\n      // do with the stream.\n      // NOTE: We move the existing pending streams to a temporary list. This is done so that\n      //       if retry logic submits a new stream to the pool, we don't fail it inline.\n      purgePendingStreams(client.real_host_description_, failure_reason, reason);\n      // See if we should preconnect based on active connections.\n      if (!is_draining_for_deletion_) {\n        tryCreateNewConnections();\n      }\n    }\n\n    // We need to release our resourceManager() resources before checking below for\n    // whether we can create a new connection. Normally this would happen when\n    // client's destructor runs, but this object needs to be deferredDelete'd(), so\n    // this forces part of its cleanup to happen now.\n    client.releaseResources();\n\n    // Again, since we know this object is going to be deferredDelete'd(), we take\n    // this opportunity to disable and reset the connection duration timer so that\n    // it doesn't trigger while on the deferred delete list. In theory it is safe\n    // to handle the CLOSED state in onConnectionDurationTimeout, but we handle\n    // it here for simplicity and safety anyway.\n    if (client.connection_duration_timer_) {\n      client.connection_duration_timer_->disableTimer();\n      client.connection_duration_timer_.reset();\n    }\n\n    dispatcher_.deferredDelete(client.removeFromList(owningList(client.state())));\n\n    checkForIdleAndCloseIdleConnsIfDraining();\n\n    client.setState(ActiveClient::State::CLOSED);\n\n    // If we have pending streams and we just lost a connection we should make a new one.\n    if (!pending_streams_.empty()) {\n      tryCreateNewConnections();\n    }\n  } else if (event == Network::ConnectionEvent::Connected) {\n    client.conn_connect_ms_->complete();\n    client.conn_connect_ms_.reset();\n    ASSERT(client.state() == ActiveClient::State::CONNECTING);\n    bool streams_available = client.currentUnusedCapacity() > 0;\n    transitionActiveClientState(client, streams_available ? ActiveClient::State::READY\n                                                          : ActiveClient::State::BUSY);\n\n    // Now that the active client is ready, set up a timer for max connection duration.\n    const absl::optional<std::chrono::milliseconds> max_connection_duration =\n        client.parent_.host()->cluster().maxConnectionDuration();\n    if (max_connection_duration.has_value()) {\n      client.connection_duration_timer_ = client.parent_.dispatcher().createTimer(\n          [&client]() { client.onConnectionDurationTimeout(); });\n      client.connection_duration_timer_->enableTimer(max_connection_duration.value());\n    }\n\n    // At this point, for the mixed ALPN pool, the client may be deleted. Do not\n    // refer to client after this point.\n    onConnected(client);\n    if (streams_available) {\n      onUpstreamReady();\n    }\n    checkForIdleAndCloseIdleConnsIfDraining();\n  }\n}\n\nPendingStream::PendingStream(ConnPoolImplBase& parent, bool can_send_early_data)\n    : parent_(parent), can_send_early_data_(can_send_early_data) {\n  parent_.host()->cluster().stats().upstream_rq_pending_total_.inc();\n  parent_.host()->cluster().stats().upstream_rq_pending_active_.inc();\n  parent_.host()->cluster().resourceManager(parent_.priority()).pendingRequests().inc();\n}\n\nPendingStream::~PendingStream() {\n  parent_.host()->cluster().stats().upstream_rq_pending_active_.dec();\n  parent_.host()->cluster().resourceManager(parent_.priority()).pendingRequests().dec();\n}\n\nvoid PendingStream::cancel(Envoy::ConnectionPool::CancelPolicy policy) {\n  parent_.onPendingStreamCancel(*this, policy);\n}\n\nvoid ConnPoolImplBase::purgePendingStreams(\n    const Upstream::HostDescriptionConstSharedPtr& host_description,\n    absl::string_view failure_reason, ConnectionPool::PoolFailureReason reason) {\n  // NOTE: We move the existing pending streams to a temporary list. This is done so that\n  //       if retry logic submits a new stream to the pool, we don't fail it inline.\n  state_.decrPendingStreams(pending_streams_.size());\n  pending_streams_to_purge_ = std::move(pending_streams_);\n  while (!pending_streams_to_purge_.empty()) {\n    PendingStreamPtr stream =\n        pending_streams_to_purge_.front()->removeFromList(pending_streams_to_purge_);\n    host_->cluster().stats().upstream_rq_pending_failure_eject_.inc();\n    onPoolFailure(host_description, failure_reason, reason, stream->context());\n  }\n}\n\nbool ConnPoolImplBase::connectingConnectionIsExcess() const {\n  ASSERT(connecting_stream_capacity_ >=\n         connecting_clients_.front()->effectiveConcurrentStreamLimit());\n  // If perUpstreamPreconnectRatio is one, this simplifies to checking if there would still be\n  // sufficient connecting stream capacity to serve all pending streams if the most recent client\n  // were removed from the picture.\n  //\n  // If preconnect ratio is set, it also factors in the anticipated load based on both queued\n  // streams and active streams, and makes sure the connecting capacity would still be sufficient to\n  // serve that even with the most recent client removed.\n  return (pending_streams_.size() + num_active_streams_) * perUpstreamPreconnectRatio() <=\n         (connecting_stream_capacity_ -\n          connecting_clients_.front()->effectiveConcurrentStreamLimit() + num_active_streams_);\n}\n\nvoid ConnPoolImplBase::onPendingStreamCancel(PendingStream& stream,\n                                             Envoy::ConnectionPool::CancelPolicy policy) {\n  ENVOY_LOG(debug, \"cancelling pending stream\");\n  if (!pending_streams_to_purge_.empty()) {\n    // If pending_streams_to_purge_ is not empty, it means that we are called from\n    // with-in a onPoolFailure callback invoked in purgePendingStreams (i.e. purgePendingStreams\n    // is down in the call stack). Remove this stream from the list as it is cancelled,\n    // and there is no need to call its onPoolFailure callback.\n    stream.removeFromList(pending_streams_to_purge_);\n  } else {\n    state_.decrPendingStreams(1);\n    stream.removeFromList(pending_streams_);\n  }\n  if (policy == Envoy::ConnectionPool::CancelPolicy::CloseExcess && !connecting_clients_.empty() &&\n      connectingConnectionIsExcess()) {\n    auto& client = *connecting_clients_.front();\n    transitionActiveClientState(client, ActiveClient::State::DRAINING);\n    client.close();\n  }\n\n  host_->cluster().stats().upstream_rq_cancelled_.inc();\n  checkForIdleAndCloseIdleConnsIfDraining();\n}\n\nnamespace {\n// Translate zero to UINT64_MAX so that the zero/unlimited case doesn't\n// have to be handled specially.\nuint32_t translateZeroToUnlimited(uint32_t limit) {\n  return (limit != 0) ? limit : std::numeric_limits<uint32_t>::max();\n}\n} // namespace\n\nActiveClient::ActiveClient(ConnPoolImplBase& parent, uint32_t lifetime_stream_limit,\n                           uint32_t concurrent_stream_limit)\n    : parent_(parent), remaining_streams_(translateZeroToUnlimited(lifetime_stream_limit)),\n      configured_stream_limit_(translateZeroToUnlimited(concurrent_stream_limit)),\n      concurrent_stream_limit_(translateZeroToUnlimited(concurrent_stream_limit)),\n      connect_timer_(parent_.dispatcher().createTimer([this]() { onConnectTimeout(); })) {\n  conn_connect_ms_ = std::make_unique<Stats::HistogramCompletableTimespanImpl>(\n      parent_.host()->cluster().stats().upstream_cx_connect_ms_, parent_.dispatcher().timeSource());\n  conn_length_ = std::make_unique<Stats::HistogramCompletableTimespanImpl>(\n      parent_.host()->cluster().stats().upstream_cx_length_ms_, parent_.dispatcher().timeSource());\n  connect_timer_->enableTimer(parent_.host()->cluster().connectTimeout());\n  parent_.host()->stats().cx_total_.inc();\n  parent_.host()->stats().cx_active_.inc();\n  parent_.host()->cluster().stats().upstream_cx_total_.inc();\n  parent_.host()->cluster().stats().upstream_cx_active_.inc();\n  parent_.host()->cluster().resourceManager(parent_.priority()).connections().inc();\n}\n\nActiveClient::~ActiveClient() { releaseResourcesBase(); }\n\nvoid ActiveClient::releaseResourcesBase() {\n  if (!resources_released_) {\n    resources_released_ = true;\n\n    conn_length_->complete();\n\n    parent_.host()->cluster().stats().upstream_cx_active_.dec();\n    parent_.host()->stats().cx_active_.dec();\n    parent_.host()->cluster().resourceManager(parent_.priority()).connections().dec();\n  }\n}\n\nvoid ActiveClient::onConnectTimeout() {\n  ENVOY_CONN_LOG(debug, \"connect timeout\", *this);\n  parent_.host()->cluster().stats().upstream_cx_connect_timeout_.inc();\n  timed_out_ = true;\n  close();\n}\n\nvoid ActiveClient::onConnectionDurationTimeout() {\n  // The connection duration timer should only have started after we left the CONNECTING state.\n  ENVOY_BUG(state_ != ActiveClient::State::CONNECTING,\n            \"max connection duration reached while connecting\");\n\n  // The connection duration timer should have been disabled and reset in onConnectionEvent\n  // for closing connections.\n  ENVOY_BUG(state_ != ActiveClient::State::CLOSED, \"max connection duration reached while closed\");\n\n  // There's nothing to do if the client is connecting, closed or draining.\n  // Two of these cases are bugs (see above), but it is safe to no-op either way.\n  if (state_ == ActiveClient::State::CONNECTING || state_ == ActiveClient::State::CLOSED ||\n      state_ == ActiveClient::State::DRAINING) {\n    return;\n  }\n\n  ENVOY_CONN_LOG(debug, \"max connection duration reached, DRAINING\", *this);\n  parent_.host()->cluster().stats().upstream_cx_max_duration_reached_.inc();\n  parent_.transitionActiveClientState(*this, Envoy::ConnectionPool::ActiveClient::State::DRAINING);\n\n  // Close out the draining client if we no longer have active streams.\n  // We have to do this here because there won't be an onStreamClosed (because there are\n  // no active streams) to do it for us later.\n  if (numActiveStreams() == 0) {\n    close();\n  }\n}\n\nvoid ActiveClient::drain() {\n  if (currentUnusedCapacity() <= 0) {\n    return;\n  }\n  if (state() == ActiveClient::State::CONNECTING) {\n    // If connecting, update both the cluster capacity and the local connecting\n    // capacity.\n    parent_.decrConnectingAndConnectedStreamCapacity(currentUnusedCapacity());\n  } else {\n    parent_.state().decrConnectingAndConnectedStreamCapacity(currentUnusedCapacity());\n  }\n\n  remaining_streams_ = 0;\n}\n\n} // namespace ConnectionPool\n} // namespace Envoy\n", "#pragma once\n\n#include \"envoy/common/conn_pool.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/connection.h\"\n#include \"envoy/stats/timespan.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n\n#include \"source/common/common/dump_state_utils.h\"\n#include \"source/common/common/linked_object.h\"\n\n#include \"absl/strings/string_view.h\"\n\nnamespace Envoy {\nnamespace ConnectionPool {\n\nclass ConnPoolImplBase;\n\n// A placeholder struct for whatever data a given connection pool needs to\n// successfully attach an upstream connection to a downstream connection.\nstruct AttachContext {\n  // Add a virtual destructor to allow for the dynamic_cast ASSERT in typedContext.\n  virtual ~AttachContext() = default;\n};\n\n// ActiveClient provides a base class for connection pool clients that handles connection timings\n// as well as managing the connection timeout.\nclass ActiveClient : public LinkedObject<ActiveClient>,\n                     public Network::ConnectionCallbacks,\n                     public Event::DeferredDeletable,\n                     protected Logger::Loggable<Logger::Id::pool> {\npublic:\n  ActiveClient(ConnPoolImplBase& parent, uint32_t lifetime_stream_limit,\n               uint32_t concurrent_stream_limit);\n  ~ActiveClient() override;\n\n  virtual void releaseResources() { releaseResourcesBase(); }\n  void releaseResourcesBase();\n\n  // Network::ConnectionCallbacks\n  void onAboveWriteBufferHighWatermark() override {}\n  void onBelowWriteBufferLowWatermark() override {}\n\n  // Called if the connection does not complete within the cluster's connectTimeout()\n  void onConnectTimeout();\n\n  // Called if the maximum connection duration is reached.\n  void onConnectionDurationTimeout();\n\n  // Returns the concurrent stream limit, accounting for if the total stream limit\n  // is less than the concurrent stream limit.\n  virtual uint32_t effectiveConcurrentStreamLimit() const {\n    return std::min(remaining_streams_, concurrent_stream_limit_);\n  }\n\n  // Returns the application protocol, or absl::nullopt for TCP.\n  virtual absl::optional<Http::Protocol> protocol() const PURE;\n\n  virtual int64_t currentUnusedCapacity() const {\n    int64_t remaining_concurrent_streams =\n        static_cast<int64_t>(concurrent_stream_limit_) - numActiveStreams();\n\n    return std::min<int64_t>(remaining_streams_, remaining_concurrent_streams);\n  }\n\n  // Closes the underlying connection.\n  virtual void close() PURE;\n  // Returns the ID of the underlying connection.\n  virtual uint64_t id() const PURE;\n  // Returns true if this closed with an incomplete stream, for stats tracking/ purposes.\n  virtual bool closingWithIncompleteStream() const PURE;\n  // Returns the number of active streams on this connection.\n  virtual uint32_t numActiveStreams() const PURE;\n\n  // This function is called onStreamClosed to see if there was a negative delta\n  // and (if necessary) update associated bookkeeping.\n  // HTTP/1 and TCP pools can not have negative delta so the default implementation simply returns\n  // false. The HTTP/2 connection pool can have this state, so overrides this function.\n  virtual bool hadNegativeDeltaOnStreamClosed() { return false; }\n\n  enum class State {\n    CONNECTING, // Connection is not yet established.\n    READY,      // Additional streams may be immediately dispatched to this connection.\n    BUSY,       // Connection is at its concurrent stream limit.\n    DRAINING,   // No more streams can be dispatched to this connection, and it will be closed\n    // when all streams complete.\n    CLOSED // Connection is closed and object is queued for destruction.\n  };\n\n  State state() const { return state_; }\n\n  void setState(State state) {\n    // If the client is transitioning to draining, update the remaining\n    // streams and pool and cluster capacity.\n    if (state == State::DRAINING) {\n      drain();\n    }\n    state_ = state;\n  }\n\n  // Sets the remaining streams to 0, and updates pool and cluster capacity.\n  virtual void drain();\n\n  ConnPoolImplBase& parent_;\n  // The count of remaining streams allowed for this connection.\n  // This will start out as the total number of streams per connection if capped\n  // by configuration, or it will be set to std::numeric_limits<uint32_t>::max() to be\n  // (functionally) unlimited.\n  // TODO: this could be moved to an optional to make it actually unlimited.\n  uint32_t remaining_streams_;\n  // The will start out as the upper limit of max concurrent streams for this connection\n  // if capped by configuration, or it will be set to std::numeric_limits<uint32_t>::max()\n  // to be (functionally) unlimited.\n  uint32_t configured_stream_limit_;\n  // The max concurrent stream for this connection, it's initialized by `configured_stream_limit_`\n  // and can be adjusted by SETTINGS frame, but the max value of it can't exceed\n  // `configured_stream_limit_`.\n  uint32_t concurrent_stream_limit_;\n  Upstream::HostDescriptionConstSharedPtr real_host_description_;\n  Stats::TimespanPtr conn_connect_ms_;\n  Stats::TimespanPtr conn_length_;\n  Event::TimerPtr connect_timer_;\n  Event::TimerPtr connection_duration_timer_;\n  bool resources_released_{false};\n  bool timed_out_{false};\n\nprivate:\n  State state_{State::CONNECTING};\n};\n\n// PendingStream is the base class tracking streams for which a connection has been created but not\n// yet established.\nclass PendingStream : public LinkedObject<PendingStream>, public ConnectionPool::Cancellable {\npublic:\n  PendingStream(ConnPoolImplBase& parent, bool can_send_early_data);\n  ~PendingStream() override;\n\n  // ConnectionPool::Cancellable\n  void cancel(Envoy::ConnectionPool::CancelPolicy policy) override;\n\n  // The context here returns a pointer to whatever context is provided with newStream(),\n  // which will be passed back to the parent in onPoolReady or onPoolFailure.\n  virtual AttachContext& context() PURE;\n\n  ConnPoolImplBase& parent_;\n  // The request can be sent as early data.\n  bool can_send_early_data_;\n};\n\nusing PendingStreamPtr = std::unique_ptr<PendingStream>;\n\nusing ActiveClientPtr = std::unique_ptr<ActiveClient>;\n\n// Base class that handles stream queueing logic shared between connection pool implementations.\nclass ConnPoolImplBase : protected Logger::Loggable<Logger::Id::pool> {\npublic:\n  ConnPoolImplBase(Upstream::HostConstSharedPtr host, Upstream::ResourcePriority priority,\n                   Event::Dispatcher& dispatcher,\n                   const Network::ConnectionSocket::OptionsSharedPtr& options,\n                   const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                   Upstream::ClusterConnectivityState& state);\n  virtual ~ConnPoolImplBase();\n\n  void deleteIsPendingImpl();\n  // By default, the connection pool will track connected and connecting stream\n  // capacity as streams are created and destroyed. QUIC does custom stream\n  // accounting so will override this to false.\n  virtual bool trackStreamCapacity() { return true; }\n\n  // A helper function to get the specific context type from the base class context.\n  template <class T> T& typedContext(AttachContext& context) {\n    ASSERT(dynamic_cast<T*>(&context) != nullptr);\n    return *static_cast<T*>(&context);\n  }\n\n  // Determines if prefetching is warranted based on the number of streams in\n  // use, pending streams, anticipated and/or currently unused capacity, and\n  // preconnect configuration.\n  //\n  // If anticipate_incoming_stream is true this assumes a call to newStream is\n  // pending, which is true for global preconnect.\n  static bool shouldConnect(size_t pending_streams, size_t active_streams,\n                            int64_t connecting_and_connected_capacity, float preconnect_ratio,\n                            bool anticipate_incoming_stream = false);\n\n  // Envoy::ConnectionPool::Instance implementation helpers\n  void addIdleCallbackImpl(Instance::IdleCb cb);\n  // Returns true if the pool is idle.\n  bool isIdleImpl() const;\n  void drainConnectionsImpl(DrainBehavior drain_behavior);\n  const Upstream::HostConstSharedPtr& host() const { return host_; }\n  // Called if this pool is likely to be picked soon, to determine if it's worth preconnecting.\n  bool maybePreconnectImpl(float global_preconnect_ratio);\n\n  // Closes and destroys all connections. This must be called in the destructor of\n  // derived classes because the derived ActiveClient will downcast parent_ to a more\n  // specific type of ConnPoolImplBase, but if the more specific part is already destructed\n  // (due to bottom-up destructor ordering in c++) that access will be invalid.\n  void destructAllConnections();\n\n  // Returns a new instance of ActiveClient.\n  virtual ActiveClientPtr instantiateActiveClient() PURE;\n\n  // Gets a pointer to the list that currently owns this client.\n  std::list<ActiveClientPtr>& owningList(ActiveClient::State state);\n\n  // Removes the PendingStream from the list of streams. Called when the PendingStream is\n  // cancelled, e.g. when the stream is reset before a connection has been established.\n  void onPendingStreamCancel(PendingStream& stream, Envoy::ConnectionPool::CancelPolicy policy);\n\n  // Fails all pending streams, calling onPoolFailure on the associated callbacks.\n  void purgePendingStreams(const Upstream::HostDescriptionConstSharedPtr& host_description,\n                           absl::string_view failure_reason,\n                           ConnectionPool::PoolFailureReason pool_failure_reason);\n\n  // Closes any idle connections as this pool is drained.\n  void closeIdleConnectionsForDrainingPool();\n\n  // Changes the state_ of an ActiveClient and moves to the appropriate list.\n  void transitionActiveClientState(ActiveClient& client, ActiveClient::State new_state);\n\n  void onConnectionEvent(ActiveClient& client, absl::string_view failure_reason,\n                         Network::ConnectionEvent event);\n\n  // See if the pool has gone idle. If we're draining, this will also close idle connections.\n  void checkForIdleAndCloseIdleConnsIfDraining();\n\n  void scheduleOnUpstreamReady();\n  ConnectionPool::Cancellable* newStreamImpl(AttachContext& context, bool can_send_early_data);\n\n  virtual ConnectionPool::Cancellable* newPendingStream(AttachContext& context,\n                                                        bool can_send_early_data) PURE;\n\n  virtual void attachStreamToClient(Envoy::ConnectionPool::ActiveClient& client,\n                                    AttachContext& context);\n\n  virtual void onPoolFailure(const Upstream::HostDescriptionConstSharedPtr& host_description,\n                             absl::string_view failure_reason,\n                             ConnectionPool::PoolFailureReason pool_failure_reason,\n                             AttachContext& context) PURE;\n  virtual void onPoolReady(ActiveClient& client, AttachContext& context) PURE;\n  // Called by derived classes any time a stream is completed or destroyed for any reason.\n  void onStreamClosed(Envoy::ConnectionPool::ActiveClient& client, bool delay_attaching_stream);\n\n  Event::Dispatcher& dispatcher() { return dispatcher_; }\n  Upstream::ResourcePriority priority() const { return priority_; }\n  const Network::ConnectionSocket::OptionsSharedPtr& socketOptions() { return socket_options_; }\n  const Network::TransportSocketOptionsConstSharedPtr& transportSocketOptions() {\n    return transport_socket_options_;\n  }\n  bool hasPendingStreams() const { return !pending_streams_.empty(); }\n\n  void decrClusterStreamCapacity(uint32_t delta) {\n    state_.decrConnectingAndConnectedStreamCapacity(delta);\n  }\n  void incrClusterStreamCapacity(uint32_t delta) {\n    state_.incrConnectingAndConnectedStreamCapacity(delta);\n  }\n  void dumpState(std::ostream& os, int indent_level = 0) const {\n    const char* spaces = spacesForLevel(indent_level);\n    os << spaces << \"ConnPoolImplBase \" << this << DUMP_MEMBER(ready_clients_.size())\n       << DUMP_MEMBER(busy_clients_.size()) << DUMP_MEMBER(connecting_clients_.size())\n       << DUMP_MEMBER(connecting_stream_capacity_) << DUMP_MEMBER(num_active_streams_)\n       << DUMP_MEMBER(pending_streams_.size())\n       << \" per upstream preconnect ratio: \" << perUpstreamPreconnectRatio();\n  }\n\n  friend std::ostream& operator<<(std::ostream& os, const ConnPoolImplBase& s) {\n    s.dumpState(os);\n    return os;\n  }\n  Upstream::ClusterConnectivityState& state() { return state_; }\n\n  void decrConnectingAndConnectedStreamCapacity(uint32_t delta) {\n    state_.decrConnectingAndConnectedStreamCapacity(delta);\n    ASSERT(connecting_stream_capacity_ >= delta);\n    connecting_stream_capacity_ -= delta;\n  }\n\n  void incrConnectingAndConnectedStreamCapacity(uint32_t delta) {\n    state_.incrConnectingAndConnectedStreamCapacity(delta);\n    connecting_stream_capacity_ += delta;\n  }\n\n  // Called when an upstream is ready to serve pending streams.\n  void onUpstreamReady();\n\nprotected:\n  virtual void onConnected(Envoy::ConnectionPool::ActiveClient&) {}\n\n  enum class ConnectionResult {\n    FailedToCreateConnection,\n    CreatedNewConnection,\n    ShouldNotConnect,\n    NoConnectionRateLimited,\n    CreatedButRateLimited,\n  };\n  // Creates up to 3 connections, based on the preconnect ratio.\n  // Returns the ConnectionResult of the last attempt.\n  ConnectionResult tryCreateNewConnections();\n\n  // Creates a new connection if there is sufficient demand, it is allowed by resourceManager, or\n  // to avoid starving this pool.\n  // Demand is determined either by perUpstreamPreconnectRatio() or global_preconnect_ratio\n  // if this is called by maybePreconnect()\n  ConnectionResult tryCreateNewConnection(float global_preconnect_ratio = 0);\n\n  // A helper function which determines if a canceled pending connection should\n  // be closed as excess or not.\n  bool connectingConnectionIsExcess() const;\n\n  // A helper function which determines if a new incoming stream should trigger\n  // connection preconnect.\n  bool shouldCreateNewConnection(float global_preconnect_ratio) const;\n\n  float perUpstreamPreconnectRatio() const;\n\n  ConnectionPool::Cancellable*\n  addPendingStream(Envoy::ConnectionPool::PendingStreamPtr&& pending_stream) {\n    LinkedList::moveIntoList(std::move(pending_stream), pending_streams_);\n    state_.incrPendingStreams(1);\n    return pending_streams_.front().get();\n  }\n\n  bool hasActiveStreams() const { return num_active_streams_ > 0; }\n\n  Upstream::ClusterConnectivityState& state_;\n\n  const Upstream::HostConstSharedPtr host_;\n  const Upstream::ResourcePriority priority_;\n\n  Event::Dispatcher& dispatcher_;\n  const Network::ConnectionSocket::OptionsSharedPtr socket_options_;\n  const Network::TransportSocketOptionsConstSharedPtr transport_socket_options_;\n\n  // True if the max requests circuit breakers apply.\n  // This will be false for the TCP pool, true otherwise.\n  virtual bool enforceMaxRequests() const { return true; }\n\n  std::list<Instance::IdleCb> idle_callbacks_;\n\n  // When calling purgePendingStreams, this list will be used to hold the streams we are about\n  // to purge. We need this if one cancelled streams cancels a different pending stream\n  std::list<PendingStreamPtr> pending_streams_to_purge_;\n\n  // Clients that are ready to handle additional streams.\n  // All entries are in state READY.\n  std::list<ActiveClientPtr> ready_clients_;\n\n  // Clients that are not ready to handle additional streams due to being BUSY or DRAINING.\n  std::list<ActiveClientPtr> busy_clients_;\n\n  // Clients that are not ready to handle additional streams because they are CONNECTING.\n  std::list<ActiveClientPtr> connecting_clients_;\n\n  // The number of streams that can be immediately dispatched\n  // if all CONNECTING connections become connected.\n  uint32_t connecting_stream_capacity_{0};\n\nprivate:\n  std::list<PendingStreamPtr> pending_streams_;\n\n  // The number of streams currently attached to clients.\n  uint32_t num_active_streams_{0};\n\n  // Whether the connection pool is currently in the process of closing\n  // all connections so that it can be gracefully deleted.\n  bool is_draining_for_deletion_{false};\n\n  // True iff this object is in the deferred delete list.\n  bool deferred_deleting_{false};\n\n  Event::SchedulableCallbackPtr upstream_ready_cb_;\n};\n\n} // namespace ConnectionPool\n} // namespace Envoy\n", "#include \"test/config/utility.h\"\n\n#include \"envoy/config/bootstrap/v3/bootstrap.pb.h\"\n#include \"envoy/config/cluster/v3/cluster.pb.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/endpoint/v3/endpoint.pb.h\"\n#include \"envoy/config/listener/v3/listener_components.pb.h\"\n#include \"envoy/config/route/v3/route_components.pb.h\"\n#include \"envoy/extensions/access_loggers/file/v3/file.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n#include \"envoy/extensions/transport_sockets/quic/v3/quic_transport.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/http/codec.h\"\n#include \"envoy/service/discovery/v3/discovery.pb.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"test/config/integration/certs/client_ecdsacert_hash.h\"\n#include \"test/config/integration/certs/clientcert_hash.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/resources.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/strings/str_replace.h\"\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\n\nstd::string ConfigHelper::baseConfig() {\n  return fmt::format(R\"EOF(\nadmin:\n  access_log:\n  - name: envoy.access_loggers.file\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n      path: \"{}\"\n  address:\n    socket_address:\n      address: 127.0.0.1\n      port_value: 0\ndynamic_resources:\n  lds_config:\n    resource_api_version: V3\n    path_config_source:\n      path: {}\nstatic_resources:\n  secrets:\n  - name: \"secret_static_0\"\n    tls_certificate:\n      certificate_chain:\n        inline_string: \"DUMMY_INLINE_BYTES\"\n      private_key:\n        inline_string: \"DUMMY_INLINE_BYTES\"\n      password:\n        inline_string: \"DUMMY_INLINE_BYTES\"\n  clusters:\n    name: cluster_0\n    load_assignment:\n      cluster_name: cluster_0\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 0\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        address: 127.0.0.1\n        port_value: 0\n)EOF\",\n                     Platform::null_device_path, Platform::null_device_path);\n}\n\nstd::string ConfigHelper::baseUdpListenerConfig(std::string listen_address) {\n  return fmt::format(R\"EOF(\nadmin:\n  access_log:\n  - name: envoy.access_loggers.file\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n      path: \"{}\"\n  address:\n    socket_address:\n      address: 127.0.0.1\n      port_value: 0\nstatic_resources:\n  clusters:\n    name: cluster_0\n    load_assignment:\n      cluster_name: cluster_0\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 0\n  listeners:\n    name: listener_0\n    address:\n      socket_address:\n        address: {}\n        port_value: 0\n        protocol: udp\n)EOF\",\n                     Platform::null_device_path, listen_address);\n}\n\nstd::string ConfigHelper::tcpProxyConfig() {\n  return absl::StrCat(baseConfig(), R\"EOF(\n    filter_chains:\n      filters:\n        name: tcp\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\n          stat_prefix: tcp_stats\n          cluster: cluster_0\n)EOF\");\n}\n\nstd::string ConfigHelper::startTlsConfig() {\n  return absl::StrCat(\n      tcpProxyConfig(),\n      fmt::format(R\"EOF(\n      transport_socket:\n        name: \"starttls\"\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.starttls.v3.StartTlsConfig\n          cleartext_socket_config:\n          tls_socket_config:\n            common_tls_context:\n              tls_certificates:\n                certificate_chain:\n                  filename: {}\n                private_key:\n                  filename: {}\n)EOF\",\n                  TestEnvironment::runfilesPath(\"test/config/integration/certs/servercert.pem\"),\n                  TestEnvironment::runfilesPath(\"test/config/integration/certs/serverkey.pem\")));\n}\n\nstd::string ConfigHelper::tlsInspectorFilter(bool enable_ja3_fingerprinting) {\n  if (!enable_ja3_fingerprinting) {\n    return R\"EOF(\nname: \"envoy.filters.listener.tls_inspector\"\ntyped_config:\n)EOF\";\n  }\n\n  return R\"EOF(\nname: \"envoy.filters.listener.tls_inspector\"\ntyped_config:\n  \"@type\": type.googleapis.com/envoy.extensions.filters.listener.tls_inspector.v3.TlsInspector\n  enable_ja3_fingerprinting: true\n)EOF\";\n}\n\nstd::string ConfigHelper::httpProxyConfig(bool downstream_use_quic) {\n  if (downstream_use_quic) {\n    return quicHttpProxyConfig();\n  }\n  return absl::StrCat(baseConfig(), fmt::format(R\"EOF(\n    filter_chains:\n      filters:\n        name: http\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          stat_prefix: config_test\n          delayed_close_timeout:\n            nanos: 10000000\n          http_filters:\n            name: envoy.filters.http.router\n          codec_type: HTTP1\n          access_log:\n            name: accesslog\n            filter:\n              not_health_check_filter:  {{}}\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n              path: {}\n          route_config:\n            virtual_hosts:\n              name: integration\n              routes:\n                route:\n                  cluster: cluster_0\n                match:\n                  prefix: \"/\"\n              domains: \"*\"\n            name: route_config_0\n)EOF\",\n                                                Platform::null_device_path));\n}\n\n// TODO(danzh): For better compatibility with HTTP integration test framework,\n// it's better to combine with HTTP_PROXY_CONFIG, and use config modifiers to\n// specify quic specific things.\nstd::string ConfigHelper::quicHttpProxyConfig() {\n  return absl::StrCat(baseUdpListenerConfig(\"127.0.0.1\"), fmt::format(R\"EOF(\n    filter_chains:\n      transport_socket:\n        name: envoy.transport_sockets.quic\n      filters:\n        name: http\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          stat_prefix: config_test\n          http_filters:\n            name: envoy.filters.http.router\n          codec_type: HTTP3\n          access_log:\n            name: file_access_log\n            filter:\n              not_health_check_filter:  {{}}\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n              path: {}\n          route_config:\n            virtual_hosts:\n              name: integration\n              routes:\n                route:\n                  cluster: cluster_0\n                match:\n                  prefix: \"/\"\n              domains: \"*\"\n            name: route_config_0\n    udp_listener_config:\n      quic_options: {{}}\n)EOF\",\n                                                                      Platform::null_device_path));\n}\n\nstd::string ConfigHelper::defaultBufferFilter() {\n  return R\"EOF(\nname: buffer\ntyped_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer\n    max_request_bytes : 5242880\n)EOF\";\n}\n\nstd::string ConfigHelper::smallBufferFilter() {\n  return R\"EOF(\nname: buffer\ntyped_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer\n    max_request_bytes : 1024\n)EOF\";\n}\n\nstd::string ConfigHelper::defaultHealthCheckFilter() {\n  return R\"EOF(\nname: health_check\ntyped_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.health_check.v3.HealthCheck\n    pass_through_mode: false\n)EOF\";\n}\n\nstd::string ConfigHelper::defaultSquashFilter() {\n  return R\"EOF(\nname: squash\ntyped_config:\n  \"@type\": type.googleapis.com/envoy.extensions.filters.http.squash.v3.Squash\n  cluster: squash\n  attachment_template:\n    spec:\n      attachment:\n        env: \"{{ SQUASH_ENV_TEST }}\"\n      match_request: true\n  attachment_timeout:\n    seconds: 1\n    nanos: 0\n  attachment_poll_period:\n    seconds: 2\n    nanos: 0\n  request_timeout:\n    seconds: 1\n    nanos: 0\n)EOF\";\n}\n\n// TODO(#6327) cleaner approach to testing with static config.\nstd::string ConfigHelper::discoveredClustersBootstrap(const std::string& api_type) {\n  return fmt::format(\n      R\"EOF(\nadmin:\n  access_log:\n  - name: envoy.access_loggers.file\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n      path: \"{}\"\n  address:\n    socket_address:\n      address: 127.0.0.1\n      port_value: 0\ndynamic_resources:\n  cds_config:\n    resource_api_version: V3\n    api_config_source:\n      api_type: {}\n      transport_api_version: V3\n      grpc_services:\n        envoy_grpc:\n          cluster_name: my_cds_cluster\n      set_node_on_first_message_only: true\nstatic_resources:\n  clusters:\n  - name: my_cds_cluster\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        explicit_http_config:\n          http2_protocol_options: {{}}\n    load_assignment:\n      cluster_name: my_cds_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 0\n  listeners:\n    name: http\n    address:\n      socket_address:\n        address: 127.0.0.1\n        port_value: 0\n    filter_chains:\n      filters:\n        name: http\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          stat_prefix: config_test\n          http_filters:\n            name: envoy.filters.http.router\n          codec_type: HTTP2\n          route_config:\n            name: route_config_0\n            validate_clusters: false\n            virtual_hosts:\n              name: integration\n              routes:\n              - route:\n                  cluster: cluster_1\n                match:\n                  prefix: \"/cluster1\"\n              - route:\n                  cluster: cluster_2\n                match:\n                  prefix: \"/cluster2\"\n              domains: \"*\"\n)EOF\",\n      Platform::null_device_path, api_type);\n}\n\n// TODO(#6327) cleaner approach to testing with static config.\nstd::string ConfigHelper::adsBootstrap(const std::string& api_type) {\n  // We use this to allow tests to default to having a single API version but override and make\n  // the transport/resource API version distinction when needed.\n  return fmt::format(R\"EOF(\ndynamic_resources:\n  lds_config:\n    resource_api_version: V3\n    ads: {{}}\n  cds_config:\n    resource_api_version: V3\n    ads: {{}}\n  ads_config:\n    transport_api_version: V3\n    api_type: {0}\n    set_node_on_first_message_only: true\nstatic_resources:\n  clusters:\n    name: dummy_cluster\n    connect_timeout:\n      seconds: 5\n    type: STATIC\n    load_assignment:\n      cluster_name: dummy_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 0\n    lb_policy: ROUND_ROBIN\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        explicit_http_config:\n          http2_protocol_options: {{}}\nadmin:\n  access_log:\n  - name: envoy.access_loggers.file\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n      path: \"{1}\"\n  address:\n    socket_address:\n      address: 127.0.0.1\n      port_value: 0\n)EOF\",\n                     api_type, Platform::null_device_path);\n}\n\n// TODO(samflattery): bundle this up with buildCluster\nenvoy::config::cluster::v3::Cluster ConfigHelper::buildStaticCluster(const std::string& name,\n                                                                     int port,\n                                                                     const std::string& address,\n                                                                     const std::string& lb_policy) {\n  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 5s\n      type: STATIC\n      load_assignment:\n        cluster_name: {}\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: {}\n                  port_value: {}\n      lb_policy: {}\n      typed_extension_protocol_options:\n        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n          \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n          explicit_http_config:\n            http2_protocol_options: {{}}\n    )EOF\",\n                  name, name, address, port, lb_policy));\n}\n\nenvoy::config::cluster::v3::Cluster ConfigHelper::buildCluster(const std::string& name,\n                                                               const std::string& lb_policy) {\n  API_NO_BOOST(envoy::config::cluster::v3::Cluster) cluster;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 5s\n      type: EDS\n      eds_cluster_config:\n        eds_config:\n          resource_api_version: V3\n          ads: {{}}\n      lb_policy: {}\n      typed_extension_protocol_options:\n        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n          \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n          explicit_http_config:\n            http2_protocol_options: {{}}\n    )EOF\",\n                                        name, lb_policy),\n                            cluster);\n  return cluster;\n}\n\nenvoy::config::cluster::v3::Cluster ConfigHelper::buildTlsCluster(const std::string& name,\n                                                                  const std::string& lb_policy) {\n  API_NO_BOOST(envoy::config::cluster::v3::Cluster) cluster;\n  TestUtility::loadFromYaml(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 5s\n      type: EDS\n      eds_cluster_config:\n        eds_config:\n          resource_api_version: V3\n          ads: {{}}\n      transport_socket:\n        name: envoy.transport_sockets.tls\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n          common_tls_context:\n            validation_context:\n              trusted_ca:\n                filename: {}\n      lb_policy: {}\n      typed_extension_protocol_options:\n        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n          \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n          explicit_http_config:\n            http2_protocol_options: {{}}\n    )EOF\",\n                  name,\n                  TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"),\n                  lb_policy),\n      cluster);\n  return cluster;\n}\n\nenvoy::config::endpoint::v3::ClusterLoadAssignment\nConfigHelper::buildClusterLoadAssignment(const std::string& name, const std::string& address,\n                                         uint32_t port) {\n  API_NO_BOOST(envoy::config::endpoint::v3::ClusterLoadAssignment) cluster_load_assignment;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      cluster_name: {}\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: {}\n                port_value: {}\n    )EOF\",\n                                        name, address, port),\n                            cluster_load_assignment);\n  return cluster_load_assignment;\n}\n\nenvoy::config::endpoint::v3::ClusterLoadAssignment\nConfigHelper::buildClusterLoadAssignmentWithLeds(const std::string& name,\n                                                 const std::string& leds_collection_name) {\n  API_NO_BOOST(envoy::config::endpoint::v3::ClusterLoadAssignment) cluster_load_assignment;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      cluster_name: {}\n      endpoints:\n        leds_cluster_locality_config:\n          leds_config:\n            resource_api_version: V3\n            ads: {{}}\n          leds_collection_name: {}\n    )EOF\",\n                                        name, leds_collection_name),\n                            cluster_load_assignment);\n  return cluster_load_assignment;\n}\n\nenvoy::config::endpoint::v3::LbEndpoint ConfigHelper::buildLbEndpoint(const std::string& address,\n                                                                      uint32_t port) {\n  API_NO_BOOST(envoy::config::endpoint::v3::LbEndpoint) lb_endpoint;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      endpoint:\n        address:\n          socket_address:\n            address: {}\n            port_value: {}\n    )EOF\",\n                                        address, port),\n                            lb_endpoint);\n  return lb_endpoint;\n}\n\nenvoy::config::listener::v3::Listener\nConfigHelper::buildBaseListener(const std::string& name, const std::string& address,\n                                const std::string& filter_chains) {\n  API_NO_BOOST(envoy::config::listener::v3::Listener) listener;\n  TestUtility::loadFromYaml(fmt::format(\n                                R\"EOF(\n      name: {}\n      address:\n        socket_address:\n          address: {}\n          port_value: 0\n      filter_chains:\n      {}\n    )EOF\",\n                                name, address, filter_chains),\n                            listener);\n  return listener;\n}\n\nenvoy::config::listener::v3::Listener ConfigHelper::buildListener(const std::string& name,\n                                                                  const std::string& route_config,\n                                                                  const std::string& address,\n                                                                  const std::string& stat_prefix) {\n  std::string hcm = fmt::format(\n      R\"EOF(\n        filters:\n        - name: http\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n            stat_prefix: {}\n            codec_type: HTTP2\n            rds:\n              route_config_name: {}\n              config_source:\n                resource_api_version: V3\n                ads: {{}}\n            http_filters: [{{ name: envoy.filters.http.router }}]\n    )EOF\",\n      stat_prefix, route_config);\n  return buildBaseListener(name, address, hcm);\n}\n\nenvoy::config::route::v3::RouteConfiguration\nConfigHelper::buildRouteConfig(const std::string& name, const std::string& cluster) {\n  API_NO_BOOST(envoy::config::route::v3::RouteConfiguration) route;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      name: \"{}\"\n      virtual_hosts:\n      - name: integration\n        domains: [\"*\"]\n        routes:\n        - match: {{ prefix: \"/\" }}\n          route: {{ cluster: \"{}\" }}\n    )EOF\",\n                                        name, cluster),\n                            route);\n  return route;\n}\n\nenvoy::config::endpoint::v3::Endpoint ConfigHelper::buildEndpoint(const std::string& address) {\n  envoy::config::endpoint::v3::Endpoint endpoint;\n  endpoint.mutable_address()->mutable_socket_address()->set_address(address);\n  return endpoint;\n}\n\nConfigHelper::ConfigHelper(const Network::Address::IpVersion version, Api::Api& api,\n                           const std::string& config) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  std::string filename = TestEnvironment::writeStringToFileForTest(\"basic_config.yaml\", config);\n  TestUtility::loadFromFile(filename, bootstrap_, api);\n\n  // Fix up all the socket addresses with the correct version.\n  auto* admin = bootstrap_.mutable_admin();\n  auto* admin_socket_addr = admin->mutable_address()->mutable_socket_address();\n  admin_socket_addr->set_address(Network::Test::getLoopbackAddressString(version));\n\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < static_resources->listeners_size(); ++i) {\n    auto* listener = static_resources->mutable_listeners(i);\n    if (listener->mutable_address()->has_envoy_internal_address()) {\n      ENVOY_LOG_MISC(\n          debug, \"Listener {} has internal address {}. Will not reset to loop back socket address.\",\n          i, listener->mutable_address()->envoy_internal_address().server_listener_name());\n      continue;\n    }\n    if (listener->mutable_address()->has_pipe()) {\n      ENVOY_LOG_MISC(debug,\n                     \"Listener {} has pipe address {}. Will not reset to loop back socket address.\",\n                     i, listener->mutable_address()->pipe().path());\n      continue;\n    }\n    auto* listener_socket_addr = listener->mutable_address()->mutable_socket_address();\n    if (listener_socket_addr->address() == \"0.0.0.0\" || listener_socket_addr->address() == \"::\") {\n      listener_socket_addr->set_address(Network::Test::getAnyAddressString(version));\n    } else {\n      listener_socket_addr->set_address(Network::Test::getLoopbackAddressString(version));\n    }\n  }\n\n  for (int i = 0; i < static_resources->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    for (int j = 0; j < cluster->load_assignment().endpoints_size(); ++j) {\n      auto* locality_lb = cluster->mutable_load_assignment()->mutable_endpoints(j);\n      for (int k = 0; k < locality_lb->lb_endpoints_size(); ++k) {\n        auto* lb_endpoint = locality_lb->mutable_lb_endpoints(k);\n        if (lb_endpoint->endpoint().address().has_socket_address()) {\n          lb_endpoint->mutable_endpoint()->mutable_address()->mutable_socket_address()->set_address(\n              Network::Test::getLoopbackAddressString(version));\n        }\n      }\n    }\n  }\n\n  // Ensure we have a basic admin-capable runtime layer.\n  if (bootstrap_.mutable_layered_runtime()->layers_size() == 0) {\n    auto* static_layer = bootstrap_.mutable_layered_runtime()->add_layers();\n    static_layer->set_name(\"static_layer\");\n    static_layer->mutable_static_layer();\n    auto* admin_layer = bootstrap_.mutable_layered_runtime()->add_layers();\n    admin_layer->set_name(\"admin\");\n    admin_layer->mutable_admin_layer();\n  }\n}\n\nvoid ConfigHelper::addListenerTypedMetadata(absl::string_view key, ProtobufWkt::Any& packed_value) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  ASSERT_TRUE(static_resources->listeners_size() > 0);\n  auto* listener = static_resources->mutable_listeners(0);\n  auto* map = listener->mutable_metadata()->mutable_typed_filter_metadata();\n  (*map)[std::string(key)] = packed_value;\n};\n\nvoid ConfigHelper::addClusterFilterMetadata(absl::string_view metadata_yaml,\n                                            absl::string_view cluster_name) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  ProtobufWkt::Struct cluster_metadata;\n  TestUtility::loadFromYaml(std::string(metadata_yaml), cluster_metadata);\n\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < static_resources->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    if (cluster->name() != cluster_name) {\n      continue;\n    }\n    for (const auto& kvp : cluster_metadata.fields()) {\n      ASSERT_TRUE(kvp.second.kind_case() == ProtobufWkt::Value::KindCase::kStructValue);\n      cluster->mutable_metadata()->mutable_filter_metadata()->insert(\n          {kvp.first, kvp.second.struct_value()});\n    }\n    break;\n  }\n}\n\nvoid ConfigHelper::setConnectConfig(\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager& hcm,\n    bool terminate_connect, bool allow_post, bool http3) {\n  auto* route_config = hcm.mutable_route_config();\n  ASSERT_EQ(1, route_config->virtual_hosts_size());\n  auto* route = route_config->mutable_virtual_hosts(0)->mutable_routes(0);\n  auto* match = route->mutable_match();\n  match->Clear();\n\n  if (allow_post) {\n    match->set_prefix(\"/\");\n\n    auto* header = match->add_headers();\n    header->set_name(\":method\");\n    header->mutable_string_match()->set_exact(\"POST\");\n  } else {\n    match->mutable_connect_matcher();\n  }\n\n  if (terminate_connect) {\n    auto* upgrade = route->mutable_route()->add_upgrade_configs();\n    upgrade->set_upgrade_type(\"CONNECT\");\n    auto* config = upgrade->mutable_connect_config();\n    if (allow_post) {\n      config->set_allow_post(true);\n    }\n  }\n\n  hcm.add_upgrade_configs()->set_upgrade_type(\"CONNECT\");\n  hcm.mutable_http2_protocol_options()->set_allow_connect(true);\n  if (http3) {\n    hcm.mutable_http3_protocol_options()->set_allow_extended_connect(true);\n  }\n}\n\nvoid ConfigHelper::applyConfigModifiers() {\n  for (const auto& config_modifier : config_modifiers_) {\n    config_modifier(bootstrap_);\n  }\n  config_modifiers_.clear();\n}\n\nvoid ConfigHelper::configureUpstreamTls(\n    bool use_alpn, bool http3,\n    absl::optional<envoy::config::core::v3::AlternateProtocolsCacheOptions>\n        alternate_protocol_cache_config) {\n  addConfigModifier([use_alpn, http3, alternate_protocol_cache_config](\n                        envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n\n    ConfigHelper::HttpProtocolOptions protocol_options;\n    protocol_options.mutable_upstream_http_protocol_options()->set_auto_sni(true);\n    ConfigHelper::setProtocolOptions(*cluster, protocol_options);\n\n    if (use_alpn) {\n      ConfigHelper::HttpProtocolOptions new_protocol_options;\n\n      HttpProtocolOptions old_protocol_options =\n          MessageUtil::anyConvert<ConfigHelper::HttpProtocolOptions>(\n              (*cluster->mutable_typed_extension_protocol_options())\n                  [\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"]);\n      protocol_options.MergeFrom(old_protocol_options);\n\n      new_protocol_options = old_protocol_options;\n      new_protocol_options.clear_explicit_http_config();\n      new_protocol_options.mutable_auto_config();\n      if (old_protocol_options.explicit_http_config().has_http_protocol_options()) {\n        new_protocol_options.mutable_auto_config()->mutable_http_protocol_options()->MergeFrom(\n            old_protocol_options.explicit_http_config().http_protocol_options());\n      } else if (old_protocol_options.explicit_http_config().has_http2_protocol_options()) {\n        new_protocol_options.mutable_auto_config()->mutable_http2_protocol_options()->MergeFrom(\n            old_protocol_options.explicit_http_config().http2_protocol_options());\n      }\n      if (http3 || old_protocol_options.explicit_http_config().has_http3_protocol_options()) {\n        new_protocol_options.mutable_auto_config()->mutable_http3_protocol_options()->MergeFrom(\n            old_protocol_options.explicit_http_config().http3_protocol_options());\n      }\n      if (alternate_protocol_cache_config.has_value()) {\n        new_protocol_options.mutable_auto_config()\n            ->mutable_alternate_protocols_cache_options()\n            ->set_name(\"default_alternate_protocols_cache\");\n        new_protocol_options.mutable_auto_config()\n            ->mutable_alternate_protocols_cache_options()\n            ->CopyFrom(alternate_protocol_cache_config.value());\n      }\n      (*cluster->mutable_typed_extension_protocol_options())\n          [\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"]\n              .PackFrom(new_protocol_options);\n    }\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n    auto* validation_context =\n        tls_context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    // The test certs are for *.lyft.com, so make sure SNI matches.\n    tls_context.set_sni(\"foo.lyft.com\");\n    if (http3) {\n      envoy::extensions::transport_sockets::quic::v3::QuicUpstreamTransport quic_context;\n      quic_context.mutable_upstream_tls_context()->CopyFrom(tls_context);\n      cluster->mutable_transport_socket()->set_name(\"envoy.transport_sockets.quic\");\n      cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(quic_context);\n    } else {\n      cluster->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n      cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n    }\n  });\n}\n\nvoid ConfigHelper::addRuntimeOverride(const std::string& key, const std::string& value) {\n  auto* static_layer =\n      bootstrap_.mutable_layered_runtime()->mutable_layers(0)->mutable_static_layer();\n  (*static_layer->mutable_fields())[std::string(key)] = ValueUtil::stringValue(std::string(value));\n}\n\nvoid ConfigHelper::setProtocolOptions(envoy::config::cluster::v3::Cluster& cluster,\n                                      HttpProtocolOptions& protocol_options) {\n  if (cluster.typed_extension_protocol_options().contains(\n          \"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\")) {\n    HttpProtocolOptions old_options = MessageUtil::anyConvert<ConfigHelper::HttpProtocolOptions>(\n        (*cluster.mutable_typed_extension_protocol_options())\n            [\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"]);\n    old_options.MergeFrom(protocol_options);\n    protocol_options.CopyFrom(old_options);\n  }\n  (*cluster.mutable_typed_extension_protocol_options())\n      [\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"]\n          .PackFrom(protocol_options);\n}\n\nvoid ConfigHelper::setHttp2(envoy::config::cluster::v3::Cluster& cluster) {\n  HttpProtocolOptions protocol_options;\n  protocol_options.mutable_explicit_http_config()->mutable_http2_protocol_options();\n  setProtocolOptions(cluster, protocol_options);\n}\n\nvoid ConfigHelper::finalize(const std::vector<uint32_t>& ports) {\n  RELEASE_ASSERT(!finalized_, \"\");\n\n  applyConfigModifiers();\n\n  setPorts(ports);\n\n  if (!connect_timeout_set_) {\n#ifdef __APPLE__\n    // Set a high default connect timeout. Under heavy load (and in particular in CI), macOS\n    // connections can take inordinately long to complete.\n    setConnectTimeout(std::chrono::seconds(30));\n#else\n    // Set a default connect timeout.\n    setConnectTimeout(std::chrono::seconds(5));\n#endif\n  }\n\n  finalized_ = true;\n}\n\nvoid ConfigHelper::setPorts(const std::vector<uint32_t>& ports, bool override_port_zero) {\n  uint32_t port_idx = 0;\n  bool eds_hosts = false;\n  bool custom_cluster = false;\n  bool original_dst_cluster = false;\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < bootstrap_.mutable_static_resources()->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    if (cluster->type() == envoy::config::cluster::v3::Cluster::EDS) {\n      eds_hosts = true;\n    } else if (cluster->type() == envoy::config::cluster::v3::Cluster::ORIGINAL_DST) {\n      original_dst_cluster = true;\n    } else if (cluster->has_cluster_type()) {\n      custom_cluster = true;\n    } else {\n      // Assign ports to statically defined load_assignment hosts.\n      for (int j = 0; j < cluster->load_assignment().endpoints_size(); ++j) {\n        auto locality_lb = cluster->mutable_load_assignment()->mutable_endpoints(j);\n        for (int k = 0; k < locality_lb->lb_endpoints_size(); ++k) {\n          auto lb_endpoint = locality_lb->mutable_lb_endpoints(k);\n          if (lb_endpoint->endpoint().address().has_socket_address()) {\n            if (lb_endpoint->endpoint().address().socket_address().port_value() == 0 ||\n                override_port_zero) {\n              RELEASE_ASSERT(ports.size() > port_idx, \"\");\n              lb_endpoint->mutable_endpoint()\n                  ->mutable_address()\n                  ->mutable_socket_address()\n                  ->set_port_value(ports[port_idx++]);\n            } else {\n              ENVOY_LOG_MISC(debug, \"Not overriding preset port\",\n                             lb_endpoint->endpoint().address().socket_address().port_value());\n            }\n          }\n        }\n      }\n    }\n  }\n  ASSERT(skip_port_usage_validation_ || port_idx == ports.size() || eds_hosts ||\n         original_dst_cluster || custom_cluster || bootstrap_.dynamic_resources().has_cds_config());\n}\n\nvoid ConfigHelper::setSourceAddress(const std::string& address_string) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  bootstrap_.mutable_cluster_manager()\n      ->mutable_upstream_bind_config()\n      ->mutable_source_address()\n      ->set_address(address_string);\n  // We don't have the ability to bind to specific ports yet.\n  bootstrap_.mutable_cluster_manager()\n      ->mutable_upstream_bind_config()\n      ->mutable_source_address()\n      ->set_port_value(0);\n}\n\nvoid ConfigHelper::setDefaultHostAndRoute(const std::string& domains, const std::string& prefix) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n\n  auto* virtual_host = hcm_config.mutable_route_config()->mutable_virtual_hosts(0);\n  virtual_host->set_domains(0, domains);\n  virtual_host->mutable_routes(0)->mutable_match()->set_prefix(prefix);\n\n  storeHttpConnectionManager(hcm_config);\n}\n\nvoid ConfigHelper::setBufferLimits(uint32_t upstream_buffer_limit,\n                                   uint32_t downstream_buffer_limit) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* listener = bootstrap_.mutable_static_resources()->mutable_listeners(0);\n  listener->mutable_per_connection_buffer_limit_bytes()->set_value(downstream_buffer_limit);\n  const uint32_t stream_buffer_size = std::max(\n      downstream_buffer_limit, Http2::Utility::OptionsLimits::MIN_INITIAL_STREAM_WINDOW_SIZE);\n  if (Network::Utility::protobufAddressSocketType(listener->address()) ==\n          Network::Socket::Type::Datagram &&\n      listener->udp_listener_config().has_quic_options()) {\n    // QUIC stream's flow control window is configured in listener config.\n    listener->mutable_udp_listener_config()\n        ->mutable_quic_options()\n        ->mutable_quic_protocol_options()\n        ->mutable_initial_stream_window_size()\n        // The same as kStreamReceiveWindowLimit in QUICHE which only supports stream flow control\n        // window no larger than 16MB.\n        ->set_value(std::min(16u * 1024 * 1024, stream_buffer_size));\n  }\n\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < bootstrap_.mutable_static_resources()->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    cluster->mutable_per_connection_buffer_limit_bytes()->set_value(upstream_buffer_limit);\n  }\n\n  auto filter = getFilterFromListener(\"http\");\n  if (filter) {\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n        hcm_config;\n    loadHttpConnectionManager(hcm_config);\n    if (hcm_config.codec_type() == envoy::extensions::filters::network::http_connection_manager::\n                                       v3::HttpConnectionManager::HTTP2) {\n      auto* options = hcm_config.mutable_http2_protocol_options();\n      options->mutable_initial_stream_window_size()->set_value(stream_buffer_size);\n      storeHttpConnectionManager(hcm_config);\n    }\n  }\n}\n\nvoid ConfigHelper::setListenerSendBufLimits(uint32_t limit) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  RELEASE_ASSERT(bootstrap_.mutable_static_resources()->listeners_size() == 1, \"\");\n  auto* listener = bootstrap_.mutable_static_resources()->mutable_listeners(0);\n  auto* options = listener->add_socket_options();\n  options->set_description(\"SO_SNDBUF\");\n  options->set_level(SOL_SOCKET);\n  options->set_int_value(limit);\n  options->set_name(SO_SNDBUF);\n}\n\nvoid ConfigHelper::setDownstreamHttpIdleTimeout(std::chrono::milliseconds timeout) {\n  addConfigModifier(\n      [timeout](\n          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) {\n        hcm.mutable_common_http_protocol_options()->mutable_idle_timeout()->MergeFrom(\n            ProtobufUtil::TimeUtil::MillisecondsToDuration(timeout.count()));\n      });\n}\n\nvoid ConfigHelper::setDownstreamMaxConnectionDuration(std::chrono::milliseconds timeout) {\n  addConfigModifier(\n      [timeout](\n          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) {\n        hcm.mutable_common_http_protocol_options()->mutable_max_connection_duration()->MergeFrom(\n            ProtobufUtil::TimeUtil::MillisecondsToDuration(timeout.count()));\n      });\n}\n\nvoid ConfigHelper::setDownstreamMaxStreamDuration(std::chrono::milliseconds timeout) {\n  addConfigModifier(\n      [timeout](\n          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) {\n        hcm.mutable_common_http_protocol_options()->mutable_max_stream_duration()->MergeFrom(\n            ProtobufUtil::TimeUtil::MillisecondsToDuration(timeout.count()));\n      });\n}\n\nvoid ConfigHelper::setConnectTimeout(std::chrono::milliseconds timeout) {\n  RELEASE_ASSERT(!finalized_, \"\");\n\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < bootstrap_.mutable_static_resources()->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    cluster->mutable_connect_timeout()->MergeFrom(\n        ProtobufUtil::TimeUtil::MillisecondsToDuration(timeout.count()));\n  }\n  connect_timeout_set_ = true;\n}\n\nvoid ConfigHelper::setDownstreamMaxRequestsPerConnection(uint64_t max_requests_per_connection) {\n  addConfigModifier(\n      [max_requests_per_connection](\n          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) {\n        hcm.mutable_common_http_protocol_options()\n            ->mutable_max_requests_per_connection()\n            ->set_value(max_requests_per_connection);\n      });\n}\n\nenvoy::config::route::v3::VirtualHost\nConfigHelper::createVirtualHost(const char* domain, const char* prefix, const char* cluster) {\n  envoy::config::route::v3::VirtualHost virtual_host;\n  virtual_host.set_name(domain);\n  virtual_host.add_domains(domain);\n  virtual_host.add_routes()->mutable_match()->set_prefix(prefix);\n  auto* route = virtual_host.mutable_routes(0)->mutable_route();\n  route->set_cluster(cluster);\n  return virtual_host;\n}\n\nvoid ConfigHelper::addVirtualHost(const envoy::config::route::v3::VirtualHost& vhost) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n  auto route_config = hcm_config.mutable_route_config();\n  auto* virtual_host = route_config->add_virtual_hosts();\n  virtual_host->CopyFrom(vhost);\n  storeHttpConnectionManager(hcm_config);\n}\n\nvoid ConfigHelper::addFilter(const std::string& config) { prependFilter(config); }\n\nvoid ConfigHelper::prependFilter(const std::string& config) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n\n  auto* filter_list_back = hcm_config.add_http_filters();\n  TestUtility::loadFromYaml(config, *filter_list_back);\n\n  // Now move it to the front.\n  for (int i = hcm_config.http_filters_size() - 1; i > 0; --i) {\n    hcm_config.mutable_http_filters()->SwapElements(i, i - 1);\n  }\n  storeHttpConnectionManager(hcm_config);\n}\n\nvoid ConfigHelper::setClientCodec(envoy::extensions::filters::network::http_connection_manager::v3::\n                                      HttpConnectionManager::CodecType type) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  if (loadHttpConnectionManager(hcm_config)) {\n    hcm_config.set_codec_type(type);\n    storeHttpConnectionManager(hcm_config);\n  }\n}\n\nvoid ConfigHelper::configDownstreamTransportSocketWithTls(\n    envoy::config::bootstrap::v3::Bootstrap& bootstrap,\n    std::function<void(envoy::extensions::transport_sockets::tls::v3::CommonTlsContext&)>\n        configure_tls_context) {\n  for (auto& listener : *bootstrap.mutable_static_resources()->mutable_listeners()) {\n    ASSERT(listener.filter_chains_size() > 0);\n    auto* filter_chain = listener.mutable_filter_chains(0);\n    auto* transport_socket = filter_chain->mutable_transport_socket();\n    if (listener.has_udp_listener_config() && listener.udp_listener_config().has_quic_options()) {\n      transport_socket->set_name(\"envoy.transport_sockets.quic\");\n      envoy::extensions::transport_sockets::quic::v3::QuicDownstreamTransport\n          quic_transport_socket_config;\n      configure_tls_context(*quic_transport_socket_config.mutable_downstream_tls_context()\n                                 ->mutable_common_tls_context());\n      transport_socket->mutable_typed_config()->PackFrom(quic_transport_socket_config);\n    } else if (!listener.has_udp_listener_config()) {\n      transport_socket->set_name(\"envoy.transport_sockets.tls\");\n      envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n      configure_tls_context(*tls_context.mutable_common_tls_context());\n      transport_socket->mutable_typed_config()->PackFrom(tls_context);\n    }\n  }\n}\n\nvoid ConfigHelper::addSslConfig(const ServerSslOptions& options) {\n  RELEASE_ASSERT(!finalized_, \"\");\n\n  auto* filter_chain =\n      bootstrap_.mutable_static_resources()->mutable_listeners(0)->mutable_filter_chains(0);\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  initializeTls(options, *tls_context.mutable_common_tls_context());\n  if (options.ocsp_staple_required_) {\n    tls_context.set_ocsp_staple_policy(\n        envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext::MUST_STAPLE);\n  }\n  filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n  filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n}\n\nvoid ConfigHelper::addQuicDownstreamTransportSocketConfig() {\n  for (auto& listener : *bootstrap_.mutable_static_resources()->mutable_listeners()) {\n    if (listener.udp_listener_config().has_quic_options()) {\n      // Disable SO_REUSEPORT, because it undesirably allows parallel test jobs to use the same\n      // port.\n      listener.mutable_enable_reuse_port()->set_value(false);\n    }\n  }\n  configDownstreamTransportSocketWithTls(\n      bootstrap_,\n      [](envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& common_tls_context) {\n        initializeTls(ServerSslOptions().setRsaCert(true).setTlsV13(true), common_tls_context);\n      });\n}\n\nbool ConfigHelper::setAccessLog(\n    const std::string& filename, absl::string_view format,\n    std::vector<envoy::config::core::v3::TypedExtensionConfig> formatters) {\n  if (getFilterFromListener(\"http\") == nullptr) {\n    return false;\n  }\n  // Replace null device with a real path for the file access log.\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n  envoy::extensions::access_loggers::file::v3::FileAccessLog access_log_config;\n  if (!format.empty()) {\n    auto* log_format = access_log_config.mutable_log_format();\n    log_format->mutable_text_format_source()->set_inline_string(absl::StrCat(format, \"\\n\"));\n    if (!formatters.empty()) {\n      for (const auto& formatter : formatters) {\n        auto* added_formatter = log_format->add_formatters();\n        added_formatter->CopyFrom(formatter);\n      }\n    }\n  }\n  access_log_config.set_path(filename);\n  hcm_config.mutable_access_log(0)->mutable_typed_config()->PackFrom(access_log_config);\n  storeHttpConnectionManager(hcm_config);\n  return true;\n}\n\nbool ConfigHelper::setListenerAccessLog(const std::string& filename, absl::string_view format) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  if (bootstrap_.mutable_static_resources()->listeners_size() == 0) {\n    return false;\n  }\n  envoy::extensions::access_loggers::file::v3::FileAccessLog access_log_config;\n  if (!format.empty()) {\n    access_log_config.mutable_log_format()->mutable_text_format_source()->set_inline_string(\n        std::string(format));\n  }\n  access_log_config.set_path(filename);\n  bootstrap_.mutable_static_resources()\n      ->mutable_listeners(0)\n      ->add_access_log()\n      ->mutable_typed_config()\n      ->PackFrom(access_log_config);\n  return true;\n}\n\nvoid ConfigHelper::initializeTls(\n    const ServerSslOptions& options,\n    envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& common_tls_context) {\n  common_tls_context.add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n  common_tls_context.add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n\n  auto* validation_context = common_tls_context.mutable_validation_context();\n  if (options.custom_validator_config_) {\n    validation_context->set_allocated_custom_validator_config(options.custom_validator_config_);\n  } else {\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/cacert.pem\"));\n    validation_context->add_verify_certificate_hash(\n        options.expect_client_ecdsa_cert_ ? TEST_CLIENT_ECDSA_CERT_HASH : TEST_CLIENT_CERT_HASH);\n  }\n  validation_context->set_allow_expired_certificate(options.allow_expired_certificate_);\n\n  // We'll negotiate up to TLSv1.3 for the tests that care, but it really\n  // depends on what the client sets.\n  common_tls_context.mutable_tls_params()->set_tls_maximum_protocol_version(\n      options.tlsv1_3_ ? envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3\n                       : envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  if (options.rsa_cert_) {\n    auto* tls_certificate = common_tls_context.add_tls_certificates();\n    tls_certificate->mutable_certificate_chain()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/servercert.pem\"));\n    tls_certificate->mutable_private_key()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/serverkey.pem\"));\n    if (options.rsa_cert_ocsp_staple_) {\n      tls_certificate->mutable_ocsp_staple()->set_filename(\n          TestEnvironment::runfilesPath(\"test/config/integration/certs/server_ocsp_resp.der\"));\n    }\n  }\n  if (options.ecdsa_cert_) {\n    auto* tls_certificate = common_tls_context.add_tls_certificates();\n    tls_certificate->mutable_certificate_chain()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/server_ecdsacert.pem\"));\n    tls_certificate->mutable_private_key()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/server_ecdsakey.pem\"));\n    if (options.ecdsa_cert_ocsp_staple_) {\n      tls_certificate->mutable_ocsp_staple()->set_filename(TestEnvironment::runfilesPath(\n          \"test/config/integration/certs/server_ecdsa_ocsp_resp.der\"));\n    }\n  }\n  if (!options.san_matchers_.empty()) {\n    *validation_context->mutable_match_typed_subject_alt_names() = {options.san_matchers_.begin(),\n                                                                    options.san_matchers_.end()};\n  }\n}\n\nvoid ConfigHelper::renameListener(const std::string& name) {\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  if (static_resources->listeners_size() > 0) {\n    static_resources->mutable_listeners(0)->set_name(name);\n  }\n}\n\nenvoy::config::listener::v3::Filter* ConfigHelper::getFilterFromListener(const std::string& name) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  if (bootstrap_.mutable_static_resources()->listeners_size() == 0) {\n    return nullptr;\n  }\n  auto* listener = bootstrap_.mutable_static_resources()->mutable_listeners(0);\n  if (listener->filter_chains_size() == 0) {\n    return nullptr;\n  }\n  auto* filter_chain = listener->mutable_filter_chains(0);\n  for (ssize_t i = 0; i < filter_chain->filters_size(); i++) {\n    if (filter_chain->mutable_filters(i)->name() == name) {\n      return filter_chain->mutable_filters(i);\n    }\n  }\n  return nullptr;\n}\n\nvoid ConfigHelper::addNetworkFilter(const std::string& filter_yaml) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* filter_chain =\n      bootstrap_.mutable_static_resources()->mutable_listeners(0)->mutable_filter_chains(0);\n  auto* filter_list_back = filter_chain->add_filters();\n  TestUtility::loadFromYaml(filter_yaml, *filter_list_back);\n\n  // Now move it to the front.\n  for (int i = filter_chain->filters_size() - 1; i > 0; --i) {\n    filter_chain->mutable_filters()->SwapElements(i, i - 1);\n  }\n}\n\nvoid ConfigHelper::addListenerFilter(const std::string& filter_yaml) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* listener = bootstrap_.mutable_static_resources()->mutable_listeners(0);\n  auto* filter_list_back = listener->add_listener_filters();\n  TestUtility::loadFromYaml(filter_yaml, *filter_list_back);\n\n  // Now move it to the front.\n  for (int i = listener->listener_filters_size() - 1; i > 0; --i) {\n    listener->mutable_listener_filters()->SwapElements(i, i - 1);\n  }\n}\n\nvoid ConfigHelper::addBootstrapExtension(const std::string& config) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* extension = bootstrap_.add_bootstrap_extensions();\n  TestUtility::loadFromYaml(config, *extension);\n}\n\nbool ConfigHelper::loadHttpConnectionManager(\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager& hcm) {\n  return loadFilter<\n      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager>(\n      \"http\", hcm);\n}\n\nvoid ConfigHelper::storeHttpConnectionManager(\n    const envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n        hcm) {\n  return storeFilter<\n      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager>(\n      \"http\", hcm);\n}\n\nvoid ConfigHelper::addConfigModifier(ConfigModifierFunction function) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  config_modifiers_.push_back(std::move(function));\n}\n\nvoid ConfigHelper::addConfigModifier(HttpModifierFunction function) {\n  addConfigModifier([function, this](envoy::config::bootstrap::v3::Bootstrap&) -> void {\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n        hcm_config;\n    if (!loadHttpConnectionManager(hcm_config)) {\n      return;\n    }\n    function(hcm_config);\n    storeHttpConnectionManager(hcm_config);\n  });\n}\n\nvoid ConfigHelper::setLds(absl::string_view version_info) {\n  applyConfigModifiers();\n\n  envoy::service::discovery::v3::DiscoveryResponse lds;\n  lds.set_version_info(std::string(version_info));\n  for (auto& listener : bootstrap_.static_resources().listeners()) {\n    ProtobufWkt::Any* resource = lds.add_resources();\n    resource->PackFrom(listener);\n  }\n\n  const std::string lds_filename =\n      bootstrap().dynamic_resources().lds_config().path_config_source().path();\n  std::string file = TestEnvironment::writeStringToFileForTest(\n      \"new_lds_file\", MessageUtil::getJsonStringFromMessageOrDie(lds));\n  TestEnvironment::renameFile(file, lds_filename);\n}\n\nvoid ConfigHelper::setDownstreamOutboundFramesLimits(uint32_t max_all_frames,\n                                                     uint32_t max_control_frames) {\n  auto filter = getFilterFromListener(\"http\");\n  if (filter) {\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n        hcm_config;\n    loadHttpConnectionManager(hcm_config);\n    if (hcm_config.codec_type() == envoy::extensions::filters::network::http_connection_manager::\n                                       v3::HttpConnectionManager::HTTP2) {\n      auto* options = hcm_config.mutable_http2_protocol_options();\n      options->mutable_max_outbound_frames()->set_value(max_all_frames);\n      options->mutable_max_outbound_control_frames()->set_value(max_control_frames);\n      storeHttpConnectionManager(hcm_config);\n    }\n  }\n}\n\nvoid ConfigHelper::setUpstreamOutboundFramesLimits(uint32_t max_all_frames,\n                                                   uint32_t max_control_frames) {\n  addConfigModifier(\n      [max_all_frames, max_control_frames](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n        ConfigHelper::HttpProtocolOptions protocol_options;\n        auto* http_protocol_options =\n            protocol_options.mutable_explicit_http_config()->mutable_http2_protocol_options();\n        http_protocol_options->mutable_max_outbound_frames()->set_value(max_all_frames);\n        http_protocol_options->mutable_max_outbound_control_frames()->set_value(max_control_frames);\n        ConfigHelper::setProtocolOptions(*bootstrap.mutable_static_resources()->mutable_clusters(0),\n                                         protocol_options);\n      });\n}\n\nvoid ConfigHelper::setLocalReply(\n    const envoy::extensions::filters::network::http_connection_manager::v3::LocalReplyConfig&\n        config) {\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n  hcm_config.mutable_local_reply_config()->MergeFrom(config);\n  storeHttpConnectionManager(hcm_config);\n}\n\nvoid ConfigHelper::adjustUpstreamTimeoutForTsan(\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager& hcm) {\n  auto* route =\n      hcm.mutable_route_config()->mutable_virtual_hosts(0)->mutable_routes(0)->mutable_route();\n  uint64_t timeout_ms = PROTOBUF_GET_MS_OR_DEFAULT(*route, timeout, 15000u);\n  auto* timeout = route->mutable_timeout();\n  // QUIC stream processing is slow under TSAN. Use larger timeout to prevent\n  // upstream_response_timeout.\n  timeout->set_seconds(TSAN_TIMEOUT_FACTOR * timeout_ms / 1000);\n}\n\nenvoy::config::core::v3::Http3ProtocolOptions ConfigHelper::http2ToHttp3ProtocolOptions(\n    const envoy::config::core::v3::Http2ProtocolOptions& http2_options,\n    size_t http3_max_stream_receive_window) {\n  envoy::config::core::v3::Http3ProtocolOptions http3_options;\n  if (http2_options.has_initial_stream_window_size() &&\n      http2_options.initial_stream_window_size().value() < http3_max_stream_receive_window) {\n    // Set http3 stream flow control window only if the configured http2 stream flow control\n    // window is smaller than the upper limit of flow control window supported by QUICHE which is\n    // also the default for http3 streams.\n    http3_options.mutable_quic_protocol_options()->mutable_initial_stream_window_size()->set_value(\n        http2_options.initial_stream_window_size().value());\n  }\n  if (http2_options.has_override_stream_error_on_invalid_http_message()) {\n    http3_options.mutable_override_stream_error_on_invalid_http_message()->set_value(\n        http2_options.override_stream_error_on_invalid_http_message().value());\n  } else if (http2_options.stream_error_on_invalid_http_messaging()) {\n    http3_options.mutable_override_stream_error_on_invalid_http_message()->set_value(true);\n  }\n  return http3_options;\n}\n\nCdsHelper::CdsHelper() : cds_path_(TestEnvironment::writeStringToFileForTest(\"cds.pb_text\", \"\")) {}\n\nvoid CdsHelper::setCds(const std::vector<envoy::config::cluster::v3::Cluster>& clusters) {\n  // Write to file the DiscoveryResponse and trigger inotify watch.\n  envoy::service::discovery::v3::DiscoveryResponse cds_response;\n  cds_response.set_version_info(std::to_string(cds_version_++));\n  cds_response.set_type_url(Config::TypeUrl::get().Cluster);\n  for (const auto& cluster : clusters) {\n    cds_response.add_resources()->PackFrom(cluster);\n  }\n  // Past the initial write, need move semantics to trigger inotify move event that the\n  // FilesystemSubscriptionImpl is subscribed to.\n  std::string path =\n      TestEnvironment::writeStringToFileForTest(\"cds.update.pb_text\", cds_response.DebugString());\n  TestEnvironment::renameFile(path, cds_path_);\n}\n\nEdsHelper::EdsHelper() : eds_path_(TestEnvironment::writeStringToFileForTest(\"eds.pb_text\", \"\")) {\n  // cluster.cluster_0.update_success will be incremented on the initial\n  // load when Envoy comes up.\n  ++update_successes_;\n}\n\nvoid EdsHelper::setEds(const std::vector<envoy::config::endpoint::v3::ClusterLoadAssignment>&\n                           cluster_load_assignments) {\n  // Write to file the DiscoveryResponse and trigger inotify watch.\n  envoy::service::discovery::v3::DiscoveryResponse eds_response;\n  eds_response.set_version_info(std::to_string(eds_version_++));\n  eds_response.set_type_url(Config::TypeUrl::get().ClusterLoadAssignment);\n  for (const auto& cluster_load_assignment : cluster_load_assignments) {\n    eds_response.add_resources()->PackFrom(cluster_load_assignment);\n  }\n  // Past the initial write, need move semantics to trigger inotify move event that the\n  // FilesystemSubscriptionImpl is subscribed to.\n  std::string path =\n      TestEnvironment::writeStringToFileForTest(\"eds.update.pb_text\", eds_response.DebugString());\n  TestEnvironment::renameFile(path, eds_path_);\n}\n\nvoid EdsHelper::setEdsAndWait(\n    const std::vector<envoy::config::endpoint::v3::ClusterLoadAssignment>& cluster_load_assignments,\n    IntegrationTestServerStats& server_stats) {\n  // Make sure the last version has been accepted before setting a new one.\n  server_stats.waitForCounterGe(\"cluster.cluster_0.update_success\", update_successes_);\n  setEds(cluster_load_assignments);\n  // Make sure Envoy has consumed the update now that it is running.\n  ++update_successes_;\n  server_stats.waitForCounterGe(\"cluster.cluster_0.update_success\", update_successes_);\n  RELEASE_ASSERT(\n      update_successes_ == server_stats.counter(\"cluster.cluster_0.update_success\")->value(), \"\");\n}\n\n} // namespace Envoy\n", "#pragma once\n\n#include <chrono>\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"envoy/api/api.h\"\n#include \"envoy/config/bootstrap/v3/bootstrap.pb.h\"\n#include \"envoy/config/cluster/v3/cluster.pb.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/endpoint/v3/endpoint.pb.h\"\n#include \"envoy/config/listener/v3/listener_components.pb.h\"\n#include \"envoy/config/route/v3/route_components.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/common.pb.h\"\n#include \"envoy/extensions/upstreams/http/v3/http_protocol_options.pb.h\"\n#include \"envoy/http/codes.h\"\n\n#include \"source/common/config/api_version.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/protobuf/protobuf.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"test/integration/server_stats.h\"\n\n#include \"absl/types/optional.h\"\n\nnamespace Envoy {\n\nclass ConfigHelper {\npublic:\n  using HttpConnectionManager =\n      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager;\n  struct ServerSslOptions {\n    ServerSslOptions& setAllowExpiredCertificate(bool allow) {\n      allow_expired_certificate_ = allow;\n      return *this;\n    }\n\n    ServerSslOptions& setRsaCert(bool rsa_cert) {\n      rsa_cert_ = rsa_cert;\n      return *this;\n    }\n\n    ServerSslOptions& setRsaCertOcspStaple(bool rsa_cert_ocsp_staple) {\n      rsa_cert_ocsp_staple_ = rsa_cert_ocsp_staple;\n      return *this;\n    }\n\n    ServerSslOptions& setEcdsaCert(bool ecdsa_cert) {\n      ecdsa_cert_ = ecdsa_cert;\n      return *this;\n    }\n\n    ServerSslOptions& setEcdsaCertOcspStaple(bool ecdsa_cert_ocsp_staple) {\n      ecdsa_cert_ocsp_staple_ = ecdsa_cert_ocsp_staple;\n      return *this;\n    }\n\n    ServerSslOptions& setOcspStapleRequired(bool ocsp_staple_required) {\n      ocsp_staple_required_ = ocsp_staple_required;\n      return *this;\n    }\n\n    ServerSslOptions& setTlsV13(bool tlsv1_3) {\n      tlsv1_3_ = tlsv1_3;\n      return *this;\n    }\n\n    ServerSslOptions& setExpectClientEcdsaCert(bool expect_client_ecdsa_cert) {\n      expect_client_ecdsa_cert_ = expect_client_ecdsa_cert;\n      return *this;\n    }\n\n    ServerSslOptions& setCustomValidatorConfig(\n        envoy::config::core::v3::TypedExtensionConfig* custom_validator_config) {\n      custom_validator_config_ = custom_validator_config;\n      return *this;\n    }\n\n    ServerSslOptions&\n    setSanMatchers(std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>\n                       san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }\n\n    bool allow_expired_certificate_{};\n    envoy::config::core::v3::TypedExtensionConfig* custom_validator_config_;\n    bool rsa_cert_{true};\n    bool rsa_cert_ocsp_staple_{true};\n    bool ecdsa_cert_{false};\n    bool ecdsa_cert_ocsp_staple_{false};\n    bool ocsp_staple_required_{false};\n    bool tlsv1_3_{false};\n    bool expect_client_ecdsa_cert_{false};\n    std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>\n        san_matchers_{};\n  };\n\n  // Set up basic config, using the specified IpVersion for all connections: listeners, upstream,\n  // and admin connections.\n  //\n  // By default, this runs with an L7 proxy config, but config can be set to TCP_PROXY_CONFIG\n  // to test L4 proxying.\n  ConfigHelper(const Network::Address::IpVersion version, Api::Api& api,\n               const std::string& config = httpProxyConfig(false));\n\n  static void\n  initializeTls(const ServerSslOptions& options,\n                envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& common_context);\n\n  using ConfigModifierFunction = std::function<void(envoy::config::bootstrap::v3::Bootstrap&)>;\n  using HttpModifierFunction = std::function<void(HttpConnectionManager&)>;\n\n  // A basic configuration (admin port, cluster_0, one listener) with no network filters.\n  static std::string baseConfig();\n\n  // A basic configuration (admin port, cluster_0, one udp listener) with no network filters.\n  static std::string baseUdpListenerConfig(std::string listen_address = \"0.0.0.0\");\n\n  // A string for a tls inspector listener filter which can be used with addListenerFilter()\n  static std::string tlsInspectorFilter(bool enable_ja3_fingerprinting = false);\n\n  // A basic configuration for L4 proxying.\n  static std::string tcpProxyConfig();\n  // A basic configuration for L7 proxying.\n  static std::string httpProxyConfig(bool downstream_use_quic = false);\n  // A basic configuration for L7 proxying with QUIC transport.\n  static std::string quicHttpProxyConfig();\n  // A string for a basic buffer filter, which can be used with prependFilter()\n  static std::string defaultBufferFilter();\n  // A string for a small buffer filter, which can be used with prependFilter()\n  static std::string smallBufferFilter();\n  // A string for a health check filter which can be used with prependFilter()\n  static std::string defaultHealthCheckFilter();\n  // A string for a squash filter which can be used with prependFilter()\n  static std::string defaultSquashFilter();\n  // A string for startTls transport socket config.\n  static std::string startTlsConfig();\n  // A cluster that uses the startTls transport socket.\n  static envoy::config::cluster::v3::Cluster buildStartTlsCluster(const std::string& address,\n                                                                  int port);\n\n  // Configuration for L7 proxying, with clusters cluster_1 and cluster_2 meant to be added via CDS.\n  // api_type should be REST, GRPC, or DELTA_GRPC.\n  static std::string discoveredClustersBootstrap(const std::string& api_type);\n  static std::string adsBootstrap(const std::string& api_type);\n  // Builds a standard Cluster config fragment, with a single endpoint (at address:port).\n  static envoy::config::cluster::v3::Cluster\n  buildStaticCluster(const std::string& name, int port, const std::string& address,\n                     const std::string& lb_policy = \"ROUND_ROBIN\");\n\n  // ADS configurations\n  static envoy::config::cluster::v3::Cluster\n  buildCluster(const std::string& name, const std::string& lb_policy = \"ROUND_ROBIN\");\n\n  static envoy::config::cluster::v3::Cluster\n  buildTlsCluster(const std::string& name, const std::string& lb_policy = \"ROUND_ROBIN\");\n\n  static envoy::config::endpoint::v3::ClusterLoadAssignment\n  buildClusterLoadAssignment(const std::string& name, const std::string& ip_version, uint32_t port);\n\n  static envoy::config::endpoint::v3::ClusterLoadAssignment\n  buildClusterLoadAssignmentWithLeds(const std::string& name,\n                                     const std::string& leds_collection_name);\n\n  static envoy::config::endpoint::v3::LbEndpoint buildLbEndpoint(const std::string& address,\n                                                                 uint32_t port);\n\n  static envoy::config::listener::v3::Listener\n  buildBaseListener(const std::string& name, const std::string& address,\n                    const std::string& filter_chains = \"\");\n\n  static envoy::config::listener::v3::Listener buildListener(const std::string& name,\n                                                             const std::string& route_config,\n                                                             const std::string& address,\n                                                             const std::string& stat_prefix);\n\n  static envoy::config::route::v3::RouteConfiguration buildRouteConfig(const std::string& name,\n                                                                       const std::string& cluster);\n\n  // Builds a standard Endpoint suitable for population by finalize().\n  static envoy::config::endpoint::v3::Endpoint buildEndpoint(const std::string& address);\n\n  // Run the final config modifiers, and then set the upstream ports based on upstream connections.\n  // This is the last operation run on |bootstrap_| before it is handed to Envoy.\n  // Ports are assigned by looping through clusters, hosts, and addresses in the\n  // order they are stored in |bootstrap_|\n  void finalize(const std::vector<uint32_t>& ports);\n\n  // Called by finalize to set up the ports.\n  void setPorts(const std::vector<uint32_t>& ports, bool override_port_zero = false);\n\n  // Set source_address in the bootstrap bind config.\n  void setSourceAddress(const std::string& address_string);\n\n  // Overwrite the first host and route for the primary listener.\n  void setDefaultHostAndRoute(const std::string& host, const std::string& route);\n\n  // Sets byte limits on upstream and downstream connections.\n  void setBufferLimits(uint32_t upstream_buffer_limit, uint32_t downstream_buffer_limit);\n\n  // Sets a small kernel buffer for the listener send buffer\n  void setListenerSendBufLimits(uint32_t limit);\n\n  // Set the idle timeout on downstream connections through the HttpConnectionManager.\n  void setDownstreamHttpIdleTimeout(std::chrono::milliseconds idle_timeout);\n\n  // Set the max connection duration for downstream connections through the HttpConnectionManager.\n  void setDownstreamMaxConnectionDuration(std::chrono::milliseconds max_connection_duration);\n\n  // Set the max stream duration for downstream connections through the HttpConnectionManager.\n  void setDownstreamMaxStreamDuration(std::chrono::milliseconds max_stream_duration);\n\n  // Set the connect timeout on upstream connections.\n  void setConnectTimeout(std::chrono::milliseconds timeout);\n\n  // Set the max_requests_per_connection for downstream through the HttpConnectionManager.\n  void setDownstreamMaxRequestsPerConnection(uint64_t max_requests_per_connection);\n\n  envoy::config::route::v3::VirtualHost createVirtualHost(const char* host, const char* route = \"/\",\n                                                          const char* cluster = \"cluster_0\");\n\n  void addVirtualHost(const envoy::config::route::v3::VirtualHost& vhost);\n\n  // Add an HTTP filter prior to existing filters.\n  void prependFilter(const std::string& filter_yaml);\n\n  // Add an HTTP filter prior to existing filters.\n  // TODO(rgs1): remove once envoy-filter-example has been updated.\n  void addFilter(const std::string& filter_yaml);\n\n  // Add a network filter prior to existing filters.\n  void addNetworkFilter(const std::string& filter_yaml);\n\n  // Add a listener filter prior to existing filters.\n  void addListenerFilter(const std::string& filter_yaml);\n\n  // Add a new bootstrap extension.\n  void addBootstrapExtension(const std::string& config);\n\n  // Sets the client codec to the specified type.\n  void setClientCodec(envoy::extensions::filters::network::http_connection_manager::v3::\n                          HttpConnectionManager::CodecType type);\n\n  // Add TLS configuration for either SSL or QUIC transport socket according to listener config.\n  void configDownstreamTransportSocketWithTls(\n      envoy::config::bootstrap::v3::Bootstrap& bootstrap,\n      std::function<void(envoy::extensions::transport_sockets::tls::v3::CommonTlsContext&)>\n          configure_tls_context);\n\n  // Add the default SSL configuration.\n  void addSslConfig(const ServerSslOptions& options);\n  void addSslConfig() { addSslConfig({}); }\n\n  // Add the default SSL configuration for QUIC downstream.\n  void addQuicDownstreamTransportSocketConfig();\n\n  // Set the HTTP access log for the first HCM (if present) to a given file. The default is\n  // the platform's null device.\n  bool setAccessLog(const std::string& filename, absl::string_view format = \"\",\n                    std::vector<envoy::config::core::v3::TypedExtensionConfig> formatters = {});\n\n  // Set the listener access log for the first listener to a given file.\n  bool setListenerAccessLog(const std::string& filename, absl::string_view format = \"\");\n\n  // Renames the first listener to the name specified.\n  void renameListener(const std::string& name);\n\n  // Allows callers to do their own modification to |bootstrap_| which will be\n  // applied just before ports are modified in finalize().\n  void addConfigModifier(ConfigModifierFunction function);\n\n  // Allows callers to easily modify the HttpConnectionManager configuration.\n  // Modifiers will be applied just before ports are modified in finalize\n  void addConfigModifier(HttpModifierFunction function);\n\n  // Allows callers to easily modify the filter named 'name' from the first filter chain from the\n  // first listener. Modifiers will be applied just before ports are modified in finalize\n  template <class FilterType>\n  void addFilterConfigModifier(const std::string& name,\n                               std::function<void(Protobuf::Message& filter)> function) {\n    addConfigModifier([name, function, this](envoy::config::bootstrap::v3::Bootstrap&) -> void {\n      FilterType filter_config;\n      loadFilter<FilterType>(name, filter_config);\n      function(filter_config);\n      storeFilter<FilterType>(name, filter_config);\n    });\n  }\n\n  // Apply any outstanding config modifiers, stick all the listeners in a discovery response message\n  // and write it to the lds file.\n  void setLds(absl::string_view version_info);\n\n  // Set limits on pending downstream outbound frames.\n  void setDownstreamOutboundFramesLimits(uint32_t max_all_frames, uint32_t max_control_frames);\n\n  // Set limits on pending upstream outbound frames.\n  void setUpstreamOutboundFramesLimits(uint32_t max_all_frames, uint32_t max_control_frames);\n\n  // Return the bootstrap configuration for hand-off to Envoy.\n  const envoy::config::bootstrap::v3::Bootstrap& bootstrap() { return bootstrap_; }\n\n  // Allow a finalized configuration to be edited for generating xDS responses\n  void applyConfigModifiers();\n\n  // Configure Envoy to do TLS to upstream.\n  void configureUpstreamTls(bool use_alpn = false, bool http3 = false,\n                            absl::optional<envoy::config::core::v3::AlternateProtocolsCacheOptions>\n                                alternate_protocol_cache_config = {});\n\n  // Skip validation that ensures that all upstream ports are referenced by the\n  // configuration generated in ConfigHelper::finalize.\n  void skipPortUsageValidation() { skip_port_usage_validation_ = true; }\n\n  // Add this key value pair to the static runtime.\n  void addRuntimeOverride(const std::string& key, const std::string& value);\n\n  // Add typed_filter_metadata to the first listener.\n  void addListenerTypedMetadata(absl::string_view key, ProtobufWkt::Any& packed_value);\n\n  // Add filter_metadata to a cluster with the given name\n  void addClusterFilterMetadata(absl::string_view metadata_yaml,\n                                absl::string_view cluster_name = \"cluster_0\");\n\n  // Given an HCM with the default config, set the matcher to be a connect matcher and enable\n  // CONNECT requests.\n  static void setConnectConfig(HttpConnectionManager& hcm, bool terminate_connect, bool allow_post,\n                               bool http3 = false);\n\n  void setLocalReply(\n      const envoy::extensions::filters::network::http_connection_manager::v3::LocalReplyConfig&\n          config);\n\n  // Adjust the upstream route with larger timeout if running tsan. This is the duration between\n  // whole request being processed and whole response received.\n  static void adjustUpstreamTimeoutForTsan(\n      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager& hcm);\n\n  using HttpProtocolOptions = envoy::extensions::upstreams::http::v3::HttpProtocolOptions;\n  static void setProtocolOptions(envoy::config::cluster::v3::Cluster& cluster,\n                                 HttpProtocolOptions& protocol_options);\n  static void setHttp2(envoy::config::cluster::v3::Cluster& cluster);\n\n  // Populate and return a Http3ProtocolOptions instance based on http2_options.\n  static envoy::config::core::v3::Http3ProtocolOptions\n  http2ToHttp3ProtocolOptions(const envoy::config::core::v3::Http2ProtocolOptions& http2_options,\n                              size_t http3_max_stream_receive_window);\n\nprivate:\n  // Load the first HCM struct from the first listener into a parsed proto.\n  bool loadHttpConnectionManager(HttpConnectionManager& hcm);\n  // Take the contents of the provided HCM proto and stuff them into the first HCM\n  // struct of the first listener.\n  void storeHttpConnectionManager(const HttpConnectionManager& hcm);\n\n  // Load the first FilterType struct from the first listener into a parsed proto.\n  template <class FilterType> bool loadFilter(const std::string& name, FilterType& filter) {\n    RELEASE_ASSERT(!finalized_, \"\");\n    auto* filter_config = getFilterFromListener(name);\n    if (filter_config) {\n      auto* config = filter_config->mutable_typed_config();\n      filter = MessageUtil::anyConvert<FilterType>(*config);\n      return true;\n    }\n    return false;\n  }\n  // Take the contents of the provided FilterType proto and stuff them into the first FilterType\n  // struct of the first listener.\n  template <class FilterType> void storeFilter(const std::string& name, const FilterType& filter) {\n    RELEASE_ASSERT(!finalized_, \"\");\n    auto* filter_config_any = getFilterFromListener(name)->mutable_typed_config();\n\n    filter_config_any->PackFrom(filter);\n  }\n\n  // Finds the filter named 'name' from the first filter chain from the first listener.\n  envoy::config::listener::v3::Filter* getFilterFromListener(const std::string& name);\n\n  // The bootstrap proto Envoy will start up with.\n  envoy::config::bootstrap::v3::Bootstrap bootstrap_;\n\n  // The config modifiers added via addConfigModifier() which will be applied in finalize()\n  std::vector<ConfigModifierFunction> config_modifiers_;\n\n  // Track if the connect timeout has been set (to avoid clobbering a custom setting with the\n  // default).\n  bool connect_timeout_set_{false};\n\n  // Option to disable port usage validation for cases where the number of\n  // upstream ports created is expected to be larger than the number of\n  // upstreams in the config.\n  bool skip_port_usage_validation_{false};\n\n  // A sanity check guard to make sure config is not modified after handing it to Envoy.\n  bool finalized_{false};\n};\n\nclass CdsHelper {\npublic:\n  CdsHelper();\n\n  // Set CDS contents on filesystem.\n  void setCds(const std::vector<envoy::config::cluster::v3::Cluster>& cluster);\n  const std::string& cds_path() const { return cds_path_; }\n\nprivate:\n  const std::string cds_path_;\n  uint32_t cds_version_{};\n};\n\n// Common code for tests that deliver EDS update via the filesystem.\nclass EdsHelper {\npublic:\n  EdsHelper();\n\n  // Set EDS contents on filesystem and wait for Envoy to pick this up.\n  void setEds(const std::vector<envoy::config::endpoint::v3::ClusterLoadAssignment>&\n                  cluster_load_assignments);\n  void setEdsAndWait(const std::vector<envoy::config::endpoint::v3::ClusterLoadAssignment>&\n                         cluster_load_assignments,\n                     IntegrationTestServerStats& server_stats);\n  const std::string& eds_path() const { return eds_path_; }\n\nprivate:\n  const std::string eds_path_;\n  uint32_t eds_version_{};\n  uint32_t update_successes_{};\n};\n\n} // namespace Envoy\n", "load(\"@rules_python//python:defs.bzl\", \"py_binary\")\nload(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_fuzz_test\",\n    \"envoy_cc_test\",\n    \"envoy_cc_test_binary\",\n    \"envoy_cc_test_library\",\n    \"envoy_package\",\n    \"envoy_proto_library\",\n    \"envoy_select_enable_http3\",\n    \"envoy_select_hot_restart\",\n    \"envoy_sh_test\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_package()\n\nenvoy_cc_test_library(\n    name = \"ads_integration_lib\",\n    srcs = [\n        \"ads_integration.cc\",\n    ],\n    hdrs = [\n        \"ads_integration.h\",\n    ],\n    data = [\n        \"//test/config/integration:server_xds_files\",\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/common:matchers_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/protobuf:utility_lib\",\n        \"//source/common/version:version_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/admin/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"ads_integration_test\",\n    size = \"enormous\",\n    srcs = [\"ads_integration_test.cc\"],\n    deps = [\n        \":ads_integration_lib\",\n        \":http_integration_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/protobuf:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"alpn_integration_test\",\n    srcs = [\"alpn_integration_test.cc\"],\n    deps = [\":http_integration_lib\"],\n)\n\nenvoy_cc_test(\n    name = \"api_listener_integration_test\",\n    srcs = [\"api_listener_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/mocks/http:stream_encoder_mock\",\n        \"//test/server:utility_lib\",\n    ],\n)\n\npy_binary(\n    name = \"capture_fuzz_gen\",\n    srcs = [\"capture_fuzz_gen.py\"],\n    licenses = [\"notice\"],  # Apache 2\n    visibility = [\"//visibility:public\"],\n    deps = [\n        \":capture_fuzz_proto_py_proto\",\n        \"@envoy_api//envoy/data/tap/v2alpha:pkg_py_proto\",\n    ],\n)\n\nenvoy_proto_library(\n    name = \"capture_fuzz_proto\",\n    srcs = [\":capture_fuzz.proto\"],\n)\n\nenvoy_proto_library(\n    name = \"h2_capture_fuzz_proto\",\n    srcs = [\":h2_capture_fuzz.proto\"],\n)\n\nenvoy_cc_test(\n    name = \"cds_integration_test\",\n    srcs = [\"cds_integration_test.cc\"],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/protobuf:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"eds_integration_test\",\n    srcs = [\"eds_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/upstream:load_balancer_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/integration/filters:eds_ready_filter_config_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"leds_integration_test\",\n    srcs = [\"leds_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_proto_library(\n    name = \"filter_manager_integration_proto\",\n    srcs = [\":filter_manager_integration_test.proto\"],\n)\n\nenvoy_cc_test(\n    name = \"filter_manager_integration_test\",\n    srcs = [\n        \"filter_manager_integration_test.cc\",\n    ],\n    deps = [\n        \":filter_manager_integration_proto_cc_proto\",\n        \":http_integration_lib\",\n        \":integration_lib\",\n        \"//source/extensions/filters/listener/tls_inspector:config\",\n        \"//source/extensions/filters/network/common:factory_base_lib\",\n        \"//source/extensions/filters/network/echo:config\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/server:utility_lib\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/access_loggers/file/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"cluster_filter_integration_test\",\n    srcs = [\"cluster_filter_integration_test.cc\"],\n    deps = [\n        \":integration_lib\",\n        \"//envoy/network:filter_interface\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:registry_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"custom_cluster_integration_test\",\n    srcs = [\"custom_cluster_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/upstream:load_balancer_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/integration/clusters:custom_static_cluster\",\n        \"//test/test_common:network_utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"vhds_integration_test\",\n    srcs = [\"vhds_integration_test.cc\"],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":vhds_lib\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"vhds_lib\",\n    srcs = [\"vhds.h\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/protobuf:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"drain_close_integration_test\",\n    srcs = [\n        \"drain_close_integration_test.cc\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nexports_files([\"test_utility.sh\"])\n\nenvoy_cc_test_binary(\n    name = \"hotrestart_main\",\n    srcs = [\"hotrestart_main.cc\"],\n    external_deps = [\n        \"abseil_symbolize\",\n    ],\n    stamped = True,\n    deps = [\n        \"//source/exe:envoy_main_common_with_core_extensions_lib\",\n        \"//source/exe:platform_impl_lib\",\n    ],\n)\n\nenvoy_sh_test(\n    name = \"hotrestart_test\",\n    size = \"enormous\",\n    srcs = envoy_select_hot_restart([\n        \"hotrestart_test.sh\",\n    ]),\n    cc_binary = [\":hotrestart_main\"],\n    data = [\n        \"test_utility.sh\",\n        \"//test/config/integration:server_config_files\",\n        \"//tools:socket_passing\",\n    ],\n    # Hot restart does not apply on Windows, skipping\n    tags = [\"skip_on_windows\"],\n)\n\nenvoy_sh_test(\n    name = \"run_envoy_test\",\n    srcs = [\"run_envoy_test.sh\"],\n    cc_binary = [\":hotrestart_main\"],\n    data = [\n        \"test_utility.sh\",\n        \"//test/config/integration:server_config_files\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"alpn_selection_integration_test\",\n    srcs = [\n        \"alpn_selection_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"header_integration_test\",\n    srcs = [\n        \"header_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/protobuf\",\n        \"//source/extensions/http/original_ip_detection/xff:config\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/api/v2:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/http/router/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http_conn_pool_integration_test\",\n    srcs = [\"http_conn_pool_integration_test.cc\"],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http2_flood_integration_test\",\n    srcs = [\n        \"http2_flood_integration_test.cc\",\n    ],\n    shard_count = 4,\n    deps = [\n        \":autonomous_upstream_lib\",\n        \":http_integration_lib\",\n        \":socket_interface_swap_lib\",\n        \":tracked_watermark_buffer_lib\",\n        \"//test/common/http/http2:http2_frame\",\n        \"//test/integration/filters:backpressure_filter_config_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/mocks/http:http_mocks\",\n        \"//test/test_common:test_runtime_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@com_google_absl//absl/synchronization\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"multiplexed_integration_test\",\n    srcs = [\n        \"multiplexed_integration_test.cc\",\n    ],\n    shard_count = 8,\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/integration/filters:metadata_stop_all_filter_config_lib\",\n        \"//test/integration/filters:on_local_reply_filter_config_lib\",\n        \"//test/integration/filters:request_metadata_filter_config_lib\",\n        \"//test/integration/filters:response_metadata_filter_config_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/integration/filters:stop_iteration_and_continue\",\n        \"//test/mocks/http:http_mocks\",\n        \"//test/mocks/upstream:retry_priority_factory_mocks\",\n        \"//test/mocks/upstream:retry_priority_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@com_google_absl//absl/synchronization\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"buffer_accounting_integration_test\",\n    srcs = [\n        \"buffer_accounting_integration_test.cc\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":base_overload_integration_test_lib\",\n        \":http_integration_lib\",\n        \":http_protocol_integration_lib\",\n        \":socket_interface_swap_lib\",\n        \":tracked_watermark_buffer_lib\",\n        \"//test/mocks/http:http_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"socket_interface_swap_lib\",\n    srcs = [\n        \"socket_interface_swap.cc\",\n    ],\n    hdrs = [\n        \"socket_interface_swap.h\",\n    ],\n    deps = [\n        \"//test/integration/filters:test_socket_interface_lib\",\n        \"@com_google_absl//absl/synchronization\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http_subset_lb_integration_test\",\n    srcs = [\n        \"http_subset_lb_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"transport_socket_match_integration_test\",\n    srcs = [\n        \"transport_socket_match_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"header_casing_integration_test\",\n    srcs = [\n        \"header_casing_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http_typed_per_filter_config_test\",\n    srcs = [\n        \"http_typed_per_filter_config_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http_timeout_integration_test\",\n    srcs = [\n        \"http_timeout_integration_test.cc\",\n        \"http_timeout_integration_test.h\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"@envoy_api//envoy/extensions/filters/http/router/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"protocol_integration_test_lib\",\n    srcs = [\n        \"protocol_integration_test.cc\",\n        \"protocol_integration_test.h\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \":socket_interface_swap_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/common/http/http2:http2_frame\",\n        \"//test/integration/filters:add_invalid_data_filter_lib\",\n        \"//test/integration/filters:continue_after_local_reply_filter_lib\",\n        \"//test/integration/filters:continue_headers_only_inject_body\",\n        \"//test/integration/filters:encoder_decoder_buffer_filter_lib\",\n        \"//test/integration/filters:invalid_header_filter_lib\",\n        \"//test/integration/filters:local_reply_during_encoding_data_filter_lib\",\n        \"//test/integration/filters:local_reply_during_encoding_filter_lib\",\n        \"//test/integration/filters:local_reply_with_metadata_filter_lib\",\n        \"//test/integration/filters:random_pause_filter_lib\",\n        \"//test/integration/filters:remove_response_headers_lib\",\n        \"//test/integration/filters:stop_iteration_headers_inject_body\",\n        \"//test/test_common:logging_lib\",\n        \"//test/test_common:threadsafe_singleton_injector_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"protocol_integration_test\",\n    srcs = [\n        \"instantiate_protocol_integration_test.cc\",\n    ],\n    args = [\n        # for coverage, until this defaults true.\n        \"--runtime-feature-override-for-tests=envoy.reloadable_features.allow_upstream_inline_write\",\n    ],\n    # As this test has many H1/H2/v4/v6 tests it takes a while to run.\n    # Shard it enough to bring the run time in line with other integration tests.\n    shard_count = 10,\n    deps = [\n        \":protocol_integration_test_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"multiplexed_upstream_integration_test\",\n    srcs = [\n        \"multiplexed_upstream_integration_test.cc\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/integration/filters:encoder_decoder_buffer_filter_lib\",\n        \"//test/integration/filters:random_pause_filter_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"integration_admin_test\",\n    srcs = [\n        \"integration_admin_test.cc\",\n        \"integration_admin_test.h\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//envoy/http:header_map_interface\",\n        \"//source/common/stats:histogram_lib\",\n        \"//source/common/stats:stats_matcher_lib\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/common/stats:stat_test_utility_lib\",\n        \"@envoy_api//envoy/admin/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/metrics/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"test_host_predicate_lib\",\n    srcs = [\n        \"test_host_predicate.h\",\n        \"test_host_predicate_config.h\",\n    ],\n    deps = [\n        \"//envoy/upstream:retry_interface\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"http_integration_lib\",\n    srcs = [\n        \"http_integration.cc\",\n    ],\n    hdrs = [\n        \"http_integration.h\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":integration_lib\",\n        \":test_host_predicate_lib\",\n        \"//envoy/event:timer_interface\",\n        \"//source/common/common:thread_annotations\",\n        \"//source/common/network:socket_option_lib\",\n        \"//source/extensions/filters/http/router:config\",\n        \"//source/extensions/filters/network/http_connection_manager:config\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/common/http/http2:http2_frame\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/integration/filters:add_body_filter_config_lib\",\n        \"//test/integration/filters:add_trailers_filter_config_lib\",\n        \"//test/integration/filters:call_decodedata_once_filter_config_lib\",\n        \"//test/integration/filters:crash_filter_config_lib\",\n        \"//test/integration/filters:decode_headers_return_stop_all_filter_config_lib\",\n        \"//test/integration/filters:encode_headers_return_stop_all_filter_config_lib\",\n        \"//test/integration/filters:modify_buffer_filter_config_lib\",\n        \"//test/integration/filters:passthrough_filter_config_lib\",\n        \"//test/integration/filters:pause_filter_lib\",\n        \"//test/integration/filters:wait_for_whole_request_and_response_config_lib\",\n        \"//test/mocks/upstream:cluster_info_mocks\",\n        \"//test/test_common:registry_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"http_protocol_integration_lib\",\n    srcs = [\n        \"http_protocol_integration.cc\",\n    ],\n    hdrs = [\n        \"http_protocol_integration.h\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/integration/filters:stream_info_to_headers_filter_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"idle_timeout_integration_test\",\n    srcs = [\"idle_timeout_integration_test.cc\"],\n    # As this test has many pauses for idle timeouts, it takes a while to run.\n    # Shard it enough to bring the run time in line with other integration tests.\n    shard_count = 2,\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//test/integration/filters:backpressure_filter_config_lib\",\n        \"//test/integration/filters:reset_idle_timer_filter_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"integration_stream_decoder_lib\",\n    srcs = [\n        \"integration_stream_decoder.cc\",\n    ],\n    hdrs = [\n        \"integration_stream_decoder.h\",\n    ],\n    deps = [\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/http:codec_interface\",\n        \"//envoy/http:header_map_interface\",\n        \"//envoy/http:metadata_interface\",\n        \"//source/common/common:dump_state_utils\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"integration_tcp_client_lib\",\n    srcs = [\n        \"integration_tcp_client.cc\",\n    ],\n    hdrs = [\n        \"integration_tcp_client.h\",\n    ],\n    deps = [\n        \":utility_lib\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/network:address_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//envoy/network:socket_interface\",\n        \"//test/mocks/buffer:buffer_mocks\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"fake_upstream_lib\",\n    srcs = [\n        \"fake_upstream.cc\",\n    ],\n    hdrs = [\n        \"fake_upstream.h\",\n    ],\n    deps = [\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//source/server:listener_manager_lib\",\n        \"//envoy/api:api_interface\",\n        \"//envoy/grpc:status\",\n        \"//envoy/http:codec_interface\",\n        \"//envoy/network:connection_handler_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/buffer:zero_copy_input_stream_lib\",\n        \"//source/common/common:basic_resource_lib\",\n        \"//source/common/common:callback_impl_lib\",\n        \"//source/common/common:linked_object\",\n        \"//source/common/common:lock_guard_lib\",\n        \"//source/common/http/http3:codec_stats_lib\",\n        \"//source/common/common:thread_lib\",\n        \"//source/common/config:utility_lib\",\n        \"//source/common/grpc:codec_lib\",\n        \"//source/common/grpc:common_lib\",\n        \"//source/common/http/http1:codec_lib\",\n        \"//source/common/http/http2:codec_lib\",\n        \"//source/common/network:connection_balancer_lib\",\n        \"//source/common/network:filter_lib\",\n        \"//source/common/network:listen_socket_lib\",\n        \"//source/common/network:socket_option_factory_lib\",\n        \"//source/common/network:udp_packet_writer_handler_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/common/stats:isolated_store_lib\",\n        \"//source/server:active_raw_udp_listener_config\",\n        \"//source/server:connection_handler_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:test_time_system_interface\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n    ] + envoy_select_enable_http3([\n        \"//source/common/quic:active_quic_listener_lib\",\n        \"//source/common/quic:quic_factory_lib\",\n        \"@com_github_google_quiche//:quic_test_tools_session_peer_lib\",\n    ]),\n)\n\nenvoy_cc_test_library(\n    name = \"base_integration_test_lib\",\n    srcs = [\n        \"base_integration_test.cc\",\n    ],\n    hdrs = [\n        \"base_integration_test.h\",\n    ],\n    deps = [\n        \":autonomous_upstream_lib\",\n        \":fake_upstream_lib\",\n        \":integration_tcp_client_lib\",\n        \":utility_lib\",\n        \"//source/common/common:thread_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/extensions/network/dns_resolver/cares:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//source/extensions/transport_sockets/tls:ssl_socket_lib\",\n        \"//source/server:process_context_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/mocks/buffer:buffer_mocks\",\n        \"//test/mocks/server:transport_socket_factory_context_mocks\",\n        \"//test/test_common:environment_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:simulated_time_system_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"@envoy_api//envoy/admin/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ] + select({\n        \"//bazel:apple\": [\"//source/extensions/network/dns_resolver/apple:config\"],\n        \"//conditions:default\": [],\n    }),\n)\n\nenvoy_cc_test_library(\n    name = \"autonomous_upstream_lib\",\n    srcs = [\n        \"autonomous_upstream.cc\",\n    ],\n    hdrs = [\n        \"autonomous_upstream.h\",\n    ],\n    deps = [\n        \":fake_upstream_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"utility_lib\",\n    srcs = [\n        \"server.cc\",\n        \"ssl_utility.cc\",\n        \"utility.cc\",\n    ],\n    hdrs = [\n        \"server.h\",\n        \"ssl_utility.h\",\n        \"utility.h\",\n    ],\n    data = [\"//test/common/runtime:filesystem_test_data\"],\n    deps = [\n        \":server_stats_interface\",\n        \":tcp_dump\",\n        \"//envoy/api:api_interface\",\n        \"//envoy/http:codec_interface\",\n        \"//envoy/http:header_map_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/server:options_interface\",\n        \"//envoy/server:process_context_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//source/common/api:api_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:lock_guard_lib\",\n        \"//source/common/common:logger_lib\",\n        \"//source/common/common:random_generator_lib\",\n        \"//source/common/common:thread_lib\",\n        \"//source/common/common:utility_lib\",\n        \"//source/common/http:codec_client_lib\",\n        \"//source/common/http/http3:quic_client_connection_factory_lib\",\n        \"//source/common/json:json_loader_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/common/quic:quic_stat_names_lib\",\n        \"//source/common/stats:allocator_lib\",\n        \"//source/common/stats:isolated_store_lib\",\n        \"//source/common/thread_local:thread_local_lib\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//source/server:drain_manager_lib\",\n        \"//source/server:hot_restart_nop_lib\",\n        \"//source/server:listener_hooks_lib\",\n        \"//source/server:options_lib\",\n        \"//source/server:process_context_lib\",\n        \"//source/server:server_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/mocks:common_lib\",\n        \"//test/mocks/event:event_mocks\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/mocks/server:transport_socket_factory_context_mocks\",\n        \"//test/mocks/upstream:cluster_info_mocks\",\n        \"//test/test_common:environment_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:printers_lib\",\n        \"//test/test_common:simulated_time_system_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"//test/test_common:test_time_system_interface\",\n        \"//test/test_common:utility_lib\",\n        \"@com_google_absl//absl/synchronization\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"integration_lib\",\n    hdrs = [\n        \"integration.h\",\n    ],\n    deps = [\n        \":autonomous_upstream_lib\",\n        \":base_integration_test_lib\",\n        \":fake_upstream_lib\",\n        \":integration_stream_decoder_lib\",\n        \":integration_tcp_client_lib\",\n        \":utility_lib\",\n        \"//envoy/api:api_interface\",\n        \"//envoy/buffer:buffer_interface\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/grpc:status\",\n        \"//envoy/http:codec_interface\",\n        \"//envoy/http:header_map_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/server:configuration_interface\",\n        \"//envoy/server:hot_restart_interface\",\n        \"//envoy/server:options_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//envoy/thread:thread_interface\",\n        \"//source/common/api:api_lib\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/buffer:zero_copy_input_stream_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:basic_resource_lib\",\n        \"//source/common/common:minimal_logger_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/grpc:codec_lib\",\n        \"//source/common/grpc:common_lib\",\n        \"//source/common/http:codec_client_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/common/http:headers_lib\",\n        \"//source/common/http/http1:codec_lib\",\n        \"//source/common/http/http2:codec_lib\",\n        \"//source/common/local_info:local_info_lib\",\n        \"//source/common/network:filter_lib\",\n        \"//source/common/network:listen_socket_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/common/runtime:runtime_lib\",\n        \"//source/common/stats:isolated_store_lib\",\n        \"//source/common/stats:thread_local_store_lib\",\n        \"//source/common/thread_local:thread_local_lib\",\n        \"//source/common/upstream:upstream_includes\",\n        \"//source/common/upstream:upstream_lib\",\n        \"//source/extensions/access_loggers/file:config\",\n        \"//source/extensions/access_loggers/stream:config\",\n        \"//source/extensions/transport_sockets/raw_buffer:config\",\n        \"//source/server:connection_handler_lib\",\n        \"//source/server:drain_manager_lib\",\n        \"//source/server:hot_restart_nop_lib\",\n        \"//source/server:listener_hooks_lib\",\n        \"//source/server:process_context_lib\",\n        \"//source/server:server_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/mocks/buffer:buffer_mocks\",\n        \"//test/mocks/stats:stats_mocks\",\n        \"//test/mocks/upstream:retry_priority_factory_mocks\",\n        \"//test/mocks/upstream:retry_priority_mocks\",\n        \"//test/test_common:environment_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:printers_lib\",\n        \"//test/test_common:simulated_time_system_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"//test/test_common:test_time_system_interface\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"integration_test\",\n    srcs = [\n        \"integration_test.cc\",\n        \"integration_test.h\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/common/http:headers_lib\",\n        \"//test/integration/filters:clear_route_cache_filter_lib\",\n        \"//test/integration/filters:encoder_decoder_buffer_filter_lib\",\n        \"//test/integration/filters:invalid_header_filter_lib\",\n        \"//test/integration/filters:process_context_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/integration/filters:set_route_filter_lib\",\n        \"//test/integration/filters:stop_iteration_and_continue\",\n        \"//test/mocks/http:http_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"redirect_integration_test\",\n    srcs = [\n        \"redirect_integration_test.cc\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"websocket_integration_test\",\n    srcs = [\n        \"websocket_integration_test.cc\",\n        \"websocket_integration_test.h\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/access_loggers/file:config\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"socket_interface_integration_test\",\n    srcs = [\"socket_interface_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/network:socket_interface_lib\",\n        \"//source/extensions/filters/network/echo:config\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"stats_integration_test\",\n    srcs = [\"stats_integration_test.cc\"],\n    # The symbol table cluster memory tests take a while to run specially under tsan.\n    # Shard it to avoid test timeout.\n    shard_count = 2,\n    deps = [\n        \":integration_lib\",\n        \"//source/common/memory:stats_lib\",\n        \"//source/extensions/filters/http/router:config\",\n        \"//source/extensions/filters/network/http_connection_manager:config\",\n        \"//test/common/stats:stat_test_utility_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"load_stats_integration_test\",\n    srcs = [\"load_stats_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/load_stats/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"hds_integration_test\",\n    srcs = [\"hds_integration_test.cc\"],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":http_integration_lib\",\n        \":integration_lib\",\n        \"//envoy/upstream:upstream_interface\",\n        \"//source/common/config:metadata_lib\",\n        \"//source/common/json:json_loader_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/common/upstream:health_checker_lib\",\n        \"//source/common/upstream:health_discovery_service_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/health/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"header_prefix_integration_test\",\n    srcs = [\"header_prefix_integration_test.cc\"],\n    coverage = False,\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"fake_resource_monitor_lib\",\n    srcs = [\n        \"fake_resource_monitor.cc\",\n    ],\n    hdrs = [\n        \"fake_resource_monitor.h\",\n    ],\n    deps = [\n        \"//envoy/server:resource_monitor_config_interface\",\n        \"//test/common/config:dummy_config_proto_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"base_overload_integration_test_lib\",\n    srcs = [\n        \"base_overload_integration_test.cc\",\n    ],\n    hdrs = [\n        \"base_overload_integration_test.h\",\n    ],\n    deps = [\n        \":fake_resource_monitor_lib\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/overload/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"overload_integration_test\",\n    srcs = [\"overload_integration_test.cc\"],\n    shard_count = 2,\n    deps = [\n        \":base_overload_integration_test_lib\",\n        \":http_protocol_integration_lib\",\n        \"//test/common/config:dummy_config_proto_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/overload/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"rtds_integration_test\",\n    srcs = [\"rtds_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"@envoy_api//envoy/service/runtime/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"extension_discovery_integration_test\",\n    srcs = [\"extension_discovery_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/integration/filters:set_is_terminal_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_is_terminal_filter_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/extensions/common/matching/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/extension/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"server_stats_interface\",\n    hdrs = [\"server_stats.h\"],\n    deps = [\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/stats:stats_interface\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"sds_static_integration_test\",\n    srcs = [\n        \"sds_static_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/mocks/secret:secret_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"sds_dynamic_integration_test\",\n    srcs = [\n        \"sds_dynamic_integration_test.cc\",\n    ],\n    data = [\n        \"sds_dynamic_key_rotation_setup.sh\",\n        \"//test/config/integration/certs\",\n    ],\n    # TODO(envoyproxy/windows-dev): The key rotation in SdsDynamicKeyRotationIntegrationTest via\n    # TestEnvironment::renameFile() fails on Windows. The renameFile() implementation does not\n    # correctly handle symlinks.\n    tags = [\n        \"fails_on_clang_cl\",\n        \"fails_on_windows\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/extensions/transport_sockets/tls:test_private_key_method_provider_test_lib\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/mocks/secret:secret_mocks\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/secret/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"sds_generic_secret_integration_test\",\n    srcs = [\n        \"sds_generic_secret_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//envoy/registry\",\n        \"//source/common/grpc:common_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_proto_library(\n    name = \"tcp_proxy_integration_proto\",\n    srcs = [\":tcp_proxy_integration_test.proto\"],\n)\n\nenvoy_cc_test(\n    name = \"tcp_proxy_integration_test\",\n    srcs = [\n        \"tcp_proxy_integration_test.cc\",\n        \"tcp_proxy_integration_test.h\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":integration_lib\",\n        \":tcp_proxy_integration_proto_cc_proto\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/access_loggers/file:config\",\n        \"//source/extensions/filters/network/common:factory_base_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/mocks/secret:secret_mocks\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/filter/network/tcp_proxy/v2:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/access_loggers/file/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"tcp_tunneling_integration_test\",\n    size = \"large\",\n    srcs = [\n        \"tcp_tunneling_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    shard_count = 3,\n    deps = [\n        \":http_integration_lib\",\n        \":http_protocol_integration_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"tcp_conn_pool_integration_test\",\n    srcs = [\n        \"tcp_conn_pool_integration_test.cc\",\n    ],\n    deps = [\n        \":integration_lib\",\n        \"//envoy/server:filter_config_interface\",\n        \"//envoy/tcp:conn_pool_interface\",\n        \"//test/server:utility_lib\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"tcp_dump\",\n    srcs = [\"tcp_dump.cc\"],\n    hdrs = [\"tcp_dump.h\"],\n    deps = [\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:fmt_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"tracked_watermark_buffer_lib\",\n    srcs = [\n        \"tracked_watermark_buffer.cc\",\n    ],\n    hdrs = [\n        \"tracked_watermark_buffer.h\",\n    ],\n    deps = [\n        \"//source/common/buffer:watermark_buffer_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/overload/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"tracked_watermark_buffer_test\",\n    srcs = [\"tracked_watermark_buffer_test.cc\"],\n    deps = [\n        \":tracked_watermark_buffer_lib\",\n        \"//test/mocks/http:stream_reset_handler_mock\",\n        \"//test/test_common:test_runtime_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"uds_integration_test\",\n    srcs = [\n        \"uds_integration_test.cc\",\n        \"uds_integration_test.h\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/http:codec_client_lib\",\n        \"//source/common/stats:stats_lib\",\n        \"//test/test_common:environment_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"version_integration_test\",\n    srcs = [\"version_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/extensions/filters/http/ip_tagging:config\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"dynamic_validation_integration_test\",\n    srcs = [\"dynamic_validation_integration_test.cc\"],\n    data = [\"//test/config/integration:server_xds_files\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/stats:stats_lib\",\n        \"//test/test_common:registry_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"xds_integration_test\",\n    srcs = [\"xds_integration_test.cc\"],\n    data = [\n        \"//test/config/integration:server_xds_files\",\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \":http_protocol_integration_lib\",\n        \"//source/extensions/filters/listener/tls_inspector:config\",\n        \"//source/extensions/filters/listener/tls_inspector:tls_inspector_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/test_common:environment_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"xfcc_integration_test\",\n    srcs = [\n        \"xfcc_integration_test.cc\",\n        \"xfcc_integration_test.h\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//test/mocks/server:transport_socket_factory_context_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nH1_FUZZ_LIB_DEPS = [\n    \":capture_fuzz_proto_cc_proto\",\n    \":http_integration_lib\",\n    \"//source/common/common:assert_lib\",\n    \"//source/common/common:logger_lib\",\n    \"//test/fuzz:fuzz_runner_lib\",\n    \"//test/integration:integration_lib\",\n    \"//test/test_common:environment_lib\",\n]\n\nenvoy_cc_test_library(\n    name = \"h1_fuzz_lib\",\n    srcs = [\"h1_fuzz.cc\"],\n    hdrs = [\"h1_fuzz.h\"],\n    deps = H1_FUZZ_LIB_DEPS,\n)\n\nenvoy_cc_test_library(\n    name = \"h1_fuzz_persistent_lib\",\n    srcs = [\"h1_fuzz.cc\"],\n    hdrs = [\"h1_fuzz.h\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    deps = H1_FUZZ_LIB_DEPS,\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h1_capture_fuzz_test\",\n    srcs = [\"h1_capture_fuzz_test.cc\"],\n    corpus = \"h1_corpus\",\n    deps = [\":h1_fuzz_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h1_capture_persistent_fuzz_test\",\n    srcs = [\"h1_capture_fuzz_test.cc\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    corpus = \"h1_corpus\",\n    deps = [\":h1_fuzz_persistent_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h1_capture_direct_response_fuzz_test\",\n    srcs = [\"h1_capture_direct_response_fuzz_test.cc\"],\n    corpus = \"h1_corpus\",\n    deps = [\n        \":h1_fuzz_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h1_capture_direct_response_persistent_fuzz_test\",\n    srcs = [\"h1_capture_direct_response_fuzz_test.cc\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    corpus = \"h1_corpus\",\n    deps = [\n        \":h1_fuzz_persistent_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nH2_FUZZ_LIB_DEPS = [\n    \":h2_capture_fuzz_proto_cc_proto\",\n    \":http_integration_lib\",\n    \"//source/common/common:assert_lib\",\n    \"//source/common/common:logger_lib\",\n    \"//test/common/http/http2:http2_frame\",\n    \"//test/fuzz:fuzz_runner_lib\",\n    \"//test/fuzz:utility_lib\",\n    \"//test/integration:integration_lib\",\n    \"//test/test_common:environment_lib\",\n]\n\nenvoy_cc_test_library(\n    name = \"h2_fuzz_lib\",\n    srcs = [\"h2_fuzz.cc\"],\n    hdrs = [\"h2_fuzz.h\"],\n    deps = H2_FUZZ_LIB_DEPS,\n)\n\nenvoy_cc_test_library(\n    name = \"h2_fuzz_persistent_lib\",\n    srcs = [\"h2_fuzz.cc\"],\n    hdrs = [\"h2_fuzz.h\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    deps = H2_FUZZ_LIB_DEPS,\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_capture_fuzz_test\",\n    srcs = [\"h2_capture_fuzz_test.cc\"],\n    corpus = \"h2_corpus\",\n    deps = [\":h2_fuzz_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_wrapped_capture_fuzz_test\",\n    srcs = [\"h2_wrapped_capture_fuzz_test.cc\"],\n    corpus = \"h2_corpus\",\n    deps = [\":h2_fuzz_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_capture_persistent_fuzz_test\",\n    srcs = [\"h2_capture_fuzz_test.cc\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    corpus = \"h2_corpus\",\n    deps = [\":h2_fuzz_persistent_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_capture_direct_response_fuzz_test\",\n    srcs = [\"h2_capture_direct_response_fuzz_test.cc\"],\n    corpus = \"h2_corpus\",\n    deps = [\n        \":h2_fuzz_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_capture_direct_response_persistent_fuzz_test\",\n    srcs = [\"h2_capture_direct_response_fuzz_test.cc\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    corpus = \"h2_corpus\",\n    deps = [\n        \":h2_fuzz_persistent_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"scoped_rds_lib\",\n    srcs = [\n        \"scoped_rds.h\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"scoped_rds_integration_test\",\n    srcs = [\n        \"scoped_rds_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \":scoped_rds_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"listener_lds_integration_test\",\n    srcs = [\n        \"listener_lds_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/integration/filters:address_restore_listener_filter_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"internal_listener_integration_test\",\n    srcs = [\n        \"internal_listener_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/integration/filters:address_restore_listener_filter_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"listener_filter_integration_test\",\n    srcs = [\n        \"listener_filter_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/access_loggers/file:config\",\n        \"//source/extensions/filters/listener/tls_inspector:config\",\n        \"//source/extensions/filters/listener/tls_inspector:tls_inspector_lib\",\n        \"//source/extensions/filters/network/echo:config\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/mocks/secret:secret_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/access_loggers/file/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"cx_limit_integration_test\",\n    srcs = [\"cx_limit_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/registry\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:logging_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"direct_response_integration_test\",\n    srcs = [\"direct_response_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"local_reply_integration_test\",\n    srcs = [\n        \"local_reply_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \":http_protocol_integration_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"command_formatter_extension_integration_test\",\n    srcs = [\n        \"command_formatter_extension_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/formatter:command_extension_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"health_check_integration_test\",\n    srcs = [\"health_check_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \":integration_lib\",\n        \"//test/common/http/http2:http2_frame\",\n        \"//test/config:v2_link_hacks\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"cluster_upstream_extension_integration_test\",\n    srcs = [\n        \"cluster_upstream_extension_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/protobuf\",\n        \"//test/integration/upstreams:per_host_upstream_config\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\n# TODO(mattklein123): Use target_compatible_with when we switch to Bazel 4.0 instead of multiple\n# selects.\nenvoy_cc_test(\n    name = \"quic_protocol_integration_test\",\n    size = \"large\",\n    srcs = envoy_select_enable_http3([\n        \"quic_protocol_integration_test.cc\",\n    ]),\n    args = [\n        # for coverage, until this defaults true.\n        \"--runtime-feature-override-for-tests=envoy.reloadable_features.allow_upstream_inline_write\",\n    ],\n    data = [\"//test/config/integration/certs\"],\n    shard_count = 8,\n    tags = [\n        \"nofips\",\n    ],\n    deps = envoy_select_enable_http3([\n        \":protocol_integration_test_lib\",\n        \"//source/common/quic:active_quic_listener_lib\",\n        \"//source/common/quic:client_connection_factory_lib\",\n        \"//source/common/quic:quic_factory_lib\",\n        \"//source/common/quic:quic_transport_socket_factory_lib\",\n        \"//test/integration/filters:pause_filter_for_quic_lib\",\n    ]),\n)\n\n# TODO(mattklein123): Use target_compatible_with when we switch to Bazel 4.0 instead of multiple\n# selects.\nenvoy_cc_test(\n    name = \"quic_http_integration_test\",\n    size = \"large\",\n    srcs = envoy_select_enable_http3([\"quic_http_integration_test.cc\"]),\n    data = [\"//test/config/integration/certs\"],\n    shard_count = 6,\n    # TODO(envoyproxy/windows-dev): Diagnose failure shown only on clang-cl build, see:\n    #   https://gist.github.com/wrowe/a152cb1d12c2f751916122aed39d8517\n    # TODO(envoyproxy/windows-dev): Diagnose timeout, why opt build test under Windows GCP RBE\n    # takes 10x as long as on linux (>300s vs ~30s). Shards = 2 solves for windows, see:\n    #   https://github.com/envoyproxy/envoy/pull/13713/files#r512160087\n    # Each of these tests exceeds 20s;\n    # QuicHttpIntegrationTests/QuicHttpIntegrationTest.MultipleQuicConnections[With|No]BPF*\n    tags = [\n        \"fails_on_clang_cl\",\n        \"fails_on_windows\",\n        \"nofips\",\n    ],\n    deps = envoy_select_enable_http3([\n        \":http_integration_lib\",\n        \"//source/common/quic:client_connection_factory_lib\",\n        \"//source/common/quic:envoy_quic_client_connection_lib\",\n        \"//source/common/quic:envoy_quic_client_session_lib\",\n        \"//source/common/quic:envoy_quic_connection_helper_lib\",\n        \"//source/common/quic:envoy_quic_proof_verifier_lib\",\n        \"//source/common/quic:quic_factory_lib\",\n        \"//test/common/quic:quic_test_utils_for_envoy_lib\",\n        \"//test/common/quic:test_utils_lib\",\n        \"//test/integration/filters:encoder_decoder_buffer_filter_lib\",\n        \"//test/test_common:test_runtime_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/overload/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n        \"@com_github_google_quiche//:quic_test_tools_session_peer_lib\",\n    ]),\n)\n\nenvoy_cc_test(\n    name = \"original_ip_detection_integration_test\",\n    srcs = [\n        \"original_ip_detection_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/extensions/http/original_ip_detection/custom_header:config\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/extensions/http/original_ip_detection/custom_header/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"weighted_cluster_integration_test\",\n    srcs = [\"weighted_cluster_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \":integration_lib\",\n        \"//test/integration/filters:repick_cluster_filter_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"typed_metadata_integration_test\",\n    srcs = [\n        \"typed_metadata_integration_test.cc\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/protobuf\",\n        \"//test/integration/filters:listener_typed_metadata_filter_lib\",\n        \"//test/server:utility_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n", "#include \"envoy/config/cluster/v3/cluster.pb.h\"\n#include \"envoy/grpc/status.h\"\n#include \"envoy/service/discovery/v3/discovery.pb.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/config/protobuf_link_hacks.h\"\n#include \"source/common/protobuf/protobuf.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"test/common/grpc/grpc_client_integration.h\"\n#include \"test/config/v2_link_hacks.h\"\n#include \"test/integration/http_integration.h\"\n#include \"test/integration/utility.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/resources.h\"\n#include \"test/test_common/simulated_time_system.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/synchronization/notification.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::AssertionResult;\n\nnamespace Envoy {\nnamespace {\n\nconst char ClusterName1[] = \"cluster_1\";\nconst char ClusterName2[] = \"cluster_2\";\nconst int UpstreamIndex1 = 1;\nconst int UpstreamIndex2 = 2;\n\nclass CdsIntegrationTest : public Grpc::DeltaSotwIntegrationParamTest, public HttpIntegrationTest {\npublic:\n  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }\n\n  void TearDown() override {\n    if (!test_skipped_) {\n      cleanUpXdsConnection();\n    }\n  }\n\n  // Overridden to insert this stuff into the initialize() at the very beginning of\n  // HttpIntegrationTest::testRouterHeaderOnlyRequestAndResponse().\n  void initialize() override {\n    use_lds_ = false;\n    test_skipped_ = false;\n    // Controls how many addFakeUpstream() will happen in\n    // BaseIntegrationTest::createUpstreams() (which is part of initialize()).\n    // Make sure this number matches the size of the 'clusters' repeated field in the bootstrap\n    // config that you use!\n    setUpstreamCount(1);                         // the CDS cluster\n    setUpstreamProtocol(Http::CodecType::HTTP2); // CDS uses gRPC uses HTTP2.\n\n    // HttpIntegrationTest::initialize() does many things:\n    // 1) It appends to fake_upstreams_ as many as you asked for via setUpstreamCount().\n    // 2) It updates your bootstrap config with the ports your fake upstreams are actually listening\n    //    on (since you're supposed to leave them as 0).\n    // 3) It creates and starts an IntegrationTestServer - the thing that wraps the almost-actual\n    //    Envoy used in the tests.\n    // 4) Bringing up the server usually entails waiting to ensure that any listeners specified in\n    //    the bootstrap config have come up, and registering them in a port map (see lookupPort()).\n    //    However, this test needs to defer all of that to later.\n    defer_listener_finalization_ = true;\n    HttpIntegrationTest::initialize();\n\n    // Create the regular (i.e. not an xDS server) upstreams. We create them manually here after\n    // initialize() because finalize() expects all fake_upstreams_ to correspond to a static\n    // cluster in the bootstrap config - which we don't want since we're testing dynamic CDS!\n    addFakeUpstream(Http::CodecType::HTTP2);\n    addFakeUpstream(Http::CodecType::HTTP2);\n    cluster1_ = ConfigHelper::buildStaticCluster(\n        ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    cluster2_ = ConfigHelper::buildStaticCluster(\n        ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n\n    // Let Envoy establish its connection to the CDS server.\n    acceptXdsConnection();\n\n    // Do the initial compareDiscoveryRequest / sendDiscoveryResponse for cluster_1.\n    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"\", {}, {}, {}, true));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                               {cluster1_}, {cluster1_}, {}, \"55\");\n\n    // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n    // the DiscoveryResponse describing cluster_1 that we sent.\n    // 2 because the statically specified CDS server itself counts as a cluster.\n    test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n\n    // Wait for our statically specified listener to become ready, and register its port in the\n    // test framework's downstream listener port map.\n    test_server_->waitUntilListenersReady();\n    registerTestServerPorts({\"http\"});\n  }\n\n  // Regression test to catch the code declaring a gRPC service method for {SotW,delta}\n  // when the user's bootstrap config asks for the other type.\n  void verifyGrpcServiceMethod() {\n    EXPECT_TRUE(xds_stream_->waitForHeadersComplete());\n    Envoy::Http::LowerCaseString path_string(\":path\");\n    std::string expected_method(\n        sotwOrDelta() == Grpc::SotwOrDelta::Sotw || sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n            ? \"/envoy.service.cluster.v3.ClusterDiscoveryService/StreamClusters\"\n            : \"/envoy.service.cluster.v3.ClusterDiscoveryService/DeltaClusters\");\n    EXPECT_EQ(xds_stream_->headers().get(path_string)[0]->value(), expected_method);\n  }\n\n  void acceptXdsConnection() {\n    AssertionResult result = // xds_connection_ is filled with the new FakeHttpConnection.\n        fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, xds_connection_);\n    RELEASE_ASSERT(result, result.message());\n    result = xds_connection_->waitForNewStream(*dispatcher_, xds_stream_);\n    RELEASE_ASSERT(result, result.message());\n    xds_stream_->startGrpcStream();\n    verifyGrpcServiceMethod();\n  }\n\n  envoy::config::cluster::v3::Cluster cluster1_;\n  envoy::config::cluster::v3::Cluster cluster2_;\n  // True if we decided not to run the test after all.\n  bool test_skipped_{true};\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersionsClientTypeDelta, CdsIntegrationTest,\n                         DELTA_SOTW_GRPC_CLIENT_INTEGRATION_PARAMS);\n\n// 1) Envoy starts up with no static clusters (other than the CDS-over-gRPC server).\n// 2) Envoy is told of a cluster via CDS.\n// 3) We send Envoy a request, which we verify is properly proxied to and served by that cluster.\n// 4) Envoy is told that cluster is gone.\n// 5) We send Envoy a request, which should 503.\n// 6) Envoy is told that the cluster is back.\n// 7) We send Envoy a request, which we verify is properly proxied to and served by that cluster.\nTEST_P(CdsIntegrationTest, CdsClusterUpDownUp) {\n  // Calls our initialize(), which includes establishing a listener, route, and cluster.\n  config_helper_.addConfigModifier(configureProxyStatus());\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n\n  // Tell Envoy that cluster_1 is gone.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n                                                             {ClusterName1}, \"42\");\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse that says cluster_1 is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n\n  // Now that cluster_1 is gone, the listener (with its routing to cluster_1) should 503.\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/cluster1\", \"\", downstream_protocol_, version_, \"foo.com\");\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().getStatusValue());\n  EXPECT_EQ(response->headers().getProxyStatusValue(),\n            \"envoy; error=destination_unavailable; details=\\\"cluster_not_found; NC\\\"\");\n\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Tell Envoy that cluster_1 is back.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"42\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                             {cluster1_}, {cluster1_}, {}, \"413\");\n\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse describing cluster_1 that we sent. Again, 2 includes CDS server.\n  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n\n  // Does *not* call our initialize().\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n\n  cleanupUpstreamAndDownstream();\n}\n\n// Make sure that clusters won't create new connections on teardown.\nTEST_P(CdsIntegrationTest, CdsClusterTeardownWhileConnecting) {\n  initialize();\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n  test_server_->waitForCounterExists(\"cluster.cluster_1.upstream_cx_total\");\n  Stats::CounterSharedPtr cx_counter = test_server_->counter(\"cluster.cluster_1.upstream_cx_total\");\n  // Confirm no upstream connection is attempted so far.\n  EXPECT_EQ(0, cx_counter->value());\n\n  // Make the upstreams stop working, to ensure the connection was not\n  // established.\n  fake_upstreams_[1]->dispatcher()->exit();\n  fake_upstreams_[2]->dispatcher()->exit();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"}, {\":path\", \"/cluster1\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}});\n\n  // Tell Envoy that cluster_1 is gone.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n                                                             {ClusterName1}, \"42\");\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse that says cluster_1 is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n  codec_client_->sendReset(encoder_decoder.first);\n  cleanupUpstreamAndDownstream();\n\n  // Either 0 or 1 upstream connection is attempted but no more.\n  EXPECT_LE(cx_counter->value(), 1);\n}\n\n// Test the fast addition and removal of clusters when they use ThreadAwareLb.\nTEST_P(CdsIntegrationTest, CdsClusterWithThreadAwareLbCycleUpDownUp) {\n  // Calls our initialize(), which includes establishing a listener, route, and cluster.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n\n  // Tell Envoy that cluster_1 is gone.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n                                                             {ClusterName1}, \"42\");\n  // Make sure that Envoy's ClusterManager has made use of the DiscoveryResponse that says cluster_1\n  // is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n\n  // Update cluster1_ to use MAGLEV load balancer policy.\n  cluster1_ = ConfigHelper::buildStaticCluster(\n      ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n      Network::Test::getLoopbackAddressString(ipVersion()), \"MAGLEV\");\n\n  // Cyclically add and remove cluster with ThreadAwareLb.\n  for (int i = 42; i < 142; i += 2) {\n    EXPECT_TRUE(\n        compareDiscoveryRequest(Config::TypeUrl::get().Cluster, absl::StrCat(i), {}, {}, {}));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n        Config::TypeUrl::get().Cluster, {cluster1_}, {cluster1_}, {}, absl::StrCat(i + 1));\n    EXPECT_TRUE(\n        compareDiscoveryRequest(Config::TypeUrl::get().Cluster, absl::StrCat(i + 1), {}, {}, {}));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n        Config::TypeUrl::get().Cluster, {}, {}, {ClusterName1}, absl::StrCat(i + 2));\n  }\n\n  cleanupUpstreamAndDownstream();\n}\n\n// Tests adding a cluster, adding another, then removing the first.\nTEST_P(CdsIntegrationTest, TwoClusters) {\n  // Calls our initialize(), which includes establishing a listener, route, and cluster.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Tell Envoy that cluster_2 is here.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n      Config::TypeUrl::get().Cluster, {cluster1_, cluster2_}, {cluster2_}, {}, \"42\");\n  // The '3' includes the fake CDS server.\n  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 3);\n\n  // A request for cluster_2 should be fine.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex2, \"/cluster2\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Tell Envoy that cluster_1 is gone.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"42\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                             {cluster2_}, {}, {ClusterName1}, \"43\");\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse that says cluster_1 is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n\n  // Even with cluster_1 gone, a request for cluster_2 should be fine.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex2, \"/cluster2\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Tell Envoy that cluster_1 is back.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"43\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n      Config::TypeUrl::get().Cluster, {cluster1_, cluster2_}, {cluster1_}, {}, \"413\");\n\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse describing cluster_1 that we sent. Again, 3 includes CDS server.\n  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 3);\n\n  // Does *not* call our initialize().\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n\n  cleanupUpstreamAndDownstream();\n}\n\n// Tests that when Envoy's delta xDS stream dis/reconnects, Envoy can inform the server of the\n// resources it already has: the reconnected stream need not start with a state-of-the-world update.\nTEST_P(CdsIntegrationTest, VersionsRememberedAfterReconnect) {\n  SKIP_IF_XDS_IS(Grpc::SotwOrDelta::Sotw);\n  SKIP_IF_XDS_IS(Grpc::SotwOrDelta::UnifiedSotw);\n\n  // Calls our initialize(), which includes establishing a listener, route, and cluster.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Close the connection carrying Envoy's xDS gRPC stream...\n  AssertionResult result = xds_connection_->close();\n  RELEASE_ASSERT(result, result.message());\n  result = xds_connection_->waitForDisconnect();\n  RELEASE_ASSERT(result, result.message());\n  xds_connection_.reset();\n  // ...and reconnect it.\n  acceptXdsConnection();\n\n  // Upon reconnecting, the Envoy should tell us its current resource versions.\n  envoy::service::discovery::v3::DeltaDiscoveryRequest request;\n  result = xds_stream_->waitForGrpcMessage(*dispatcher_, request);\n  RELEASE_ASSERT(result, result.message());\n  const auto& initial_resource_versions = request.initial_resource_versions();\n  EXPECT_EQ(\"55\", initial_resource_versions.at(std::string(ClusterName1)));\n  EXPECT_EQ(1, initial_resource_versions.size());\n\n  // Tell Envoy that cluster_2 is here. This update does *not* need to include cluster_1,\n  // which Envoy should already know about despite the disconnect.\n  sendDeltaDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                                  {cluster2_}, {}, \"42\");\n  // The '3' includes the fake CDS server.\n  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 3);\n\n  // A request for cluster_1 should be fine.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n  // A request for cluster_2 should be fine.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex2, \"/cluster2\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n}\n\n} // namespace\n} // namespace Envoy\n"], "fixing_code": ["1.22.0 (pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\n* tls: set TLS v1.2 as the default minimal version for servers. Users can still explicitly opt-in to 1.0 and 1.1 using :ref:`tls_minimum_protocol_version <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsParameters.tls_minimum_protocol_version>`.\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\n* dynamic_forward_proxy: if a DNS resolution fails, failing immediately with a specific resolution error, rather than finishing up all local filters and failing to select an upstream host.\n* ext_authz: added requested server name in ext_authz network filter for auth review.\n* file: changed disk based files to truncate files which are not being appended to. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.append_or_truncate`` to false.\n* grpc: flip runtime guard ``envoy.reloadable_features.enable_grpc_async_client_cache`` to be default enabled. async grpc client created through getOrCreateRawAsyncClient will be cached by default.\n* http: avoiding delay-close for HTTP/1.0 responses framed by connection: close as well as HTTP/1.1 if the request is fully read. This means for responses to such requests, the FIN will be sent immediately after the response. This behavior can be temporarily reverted by setting ``envoy.reloadable_features.skip_delay_close`` to false.  If clients are are seen to be receiving sporadic partial responses and flipping this flag fixes it, please notify the project immediately.\n* http: now the max concurrent streams of http2 connection can not only be adjusted down according to the SETTINGS frame but also can be adjusted up, of course, it can not exceed the configured upper bounds. This fix is guarded by ``envoy.reloadable_features.http2_allow_capacity_increase_by_settings``.\n* http: when writing custom filters, `injectEncodedDataToFilterChain` and `injectDecodedDataToFilterChain` now trigger sending of headers if they were not yet sent due to `StopIteration`. Previously, calling one of the inject functions in that state would trigger an assertion. See issue #19891 for more details.\n* perf: ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret update.\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n* access_log: fix memory leak when reopening an access log fails. Access logs will now try to be reopened on each subsequent flush attempt after a failure.\n* data plane: fixing error handling where writing to a socket failed while under the stack of processing. This should genreally affect HTTP/3. This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.\n* eds: fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.\n* tls: fix a bug while matching a certificate SAN with an exact value in ``match_typed_subject_alt_names`` of a listener where wildcard ``*`` character is not the only character of the dns label. Example, ``baz*.example.net`` and ``*baz.example.net`` and ``b*z.example.net`` will match ``baz1.example.net`` and ``foobaz.example.net`` and ``buzz.example.net``, respectively.\n* upstream: fix stack overflow when a cluster with large number of idle connections is removed.\n* xray: fix the AWS X-Ray tracer extension to not sample the trace if ``sampled=`` keyword is not present in the header ``x-amzn-trace-id``.\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n* access_log: removed ``envoy.reloadable_features.unquote_log_string_values`` and legacy code paths.\n* grpc_bridge_filter: removed ``envoy.reloadable_features.grpc_bridge_stats_disabled`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.hash_multiple_header_values`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.no_chunked_encoding_header_for_304`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.preserve_downstream_scheme`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.require_strict_1xx_and_204_response_headers`` and ``envoy.reloadable_features.send_strict_1xx_and_204_response_headers`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.strip_port_from_connect`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.use_observable_cluster_name`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http_transport_failure_reason_in_body`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.allow_response_for_timeout`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http2_consume_stream_refused_errors`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.internal_redirects_with_body`` and legacy code paths.\n* udp: removed ``envoy.reloadable_features.udp_per_event_loop_read_limit`` and legacy code paths.\n* upstream: removed ``envoy.reloadable_features.health_check.graceful_goaway_handling`` and legacy code paths.\n* xds: removed ``envoy.reloadable_features.vhds_heartbeats`` and legacy code paths.\n\n\nNew Features\n------------\n* access_log: make consistent access_log format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* admin: :http:post:`/logging` now accepts ``/logging?paths=name1:level1,name2:level2,...`` to change multiple log levels at once.\n* config: added new file based xDS configuration via :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`.\n  :ref:`watched_directory <envoy_v3_api_field_config.core.v3.PathConfigSource.watched_directory>` can\n  be used to setup an independent watch for when to reload the file path, for example when using\n  Kubernetes ConfigMaps to deliver configuration. See the linked documentation for more information.\n* cors: add dynamic support for headers ``access-control-allow-methods`` and ``access-control-allow-headers`` in cors.\n* http: added random_value_specifier in :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` to allow random value to be specified from configuration proto.\n* http: added support for :ref:`proxy_status_config <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.proxy_status_config>` for configuring `Proxy-Status <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08>`_ HTTP response header fields.\n* http: make consistent custom header format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* http3: downstream HTTP/3 support is now GA! Upstream HTTP/3 also GA for specific deployments. See :ref:`here <arch_overview_http3>` for details.\n* http3: supports upstream HTTP/3 retries. Automatically retry `0-RTT safe requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ if they are rejected because they are sent `too early <https://datatracker.ietf.org/doc/html/rfc8470#section-5.2>`_. And automatically retry 0-RTT safe requests if connect attempt fails later on and the cluster is configured with TCP fallback. And add retry on ``http3-post-connect-failure`` policy which allows retry of failed HTTP/3 requests with TCP fallback even after handshake if the cluster is configured with TCP fallback. This feature is guarded by ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3``.\n* matching: the matching API can now express a match tree that will always match by omitting a matcher at the top level.\n* outlier_detection: :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` configuration added to allow adding a random value to the ejection time to prevent 'thundering herd' scenarios. Defaults to 0 so as to not break or change the behavior of existing deployments.\n\nDeprecated\n----------\n\n* config: deprecated :ref:`path <envoy_v3_api_field_config.core.v3.ConfigSource.path>` in favor of\n  :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`\n* http: removing support for long-deprecated old style filter names, e.g. envoy.router, envoy.lua.\n* re2: removed undocumented histograms ``re2.program_size`` and ``re2.exceeded_warn_level``.\n", "load(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_library\",\n    \"envoy_package\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_package()\n\nenvoy_cc_library(\n    name = \"conn_pool_base_lib\",\n    srcs = [\"conn_pool_base.cc\"],\n    hdrs = [\"conn_pool_base.h\"],\n    deps = [\n        \"//envoy/stats:timespan_interface\",\n        \"//source/common/common:debug_recursion_checker_lib\",\n        \"//source/common/common:linked_object\",\n        \"//source/common/stats:timespan_lib\",\n        \"//source/common/upstream:upstream_lib\",\n    ],\n)\n", "#include \"source/common/conn_pool/conn_pool_base.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/debug_recursion_checker.h\"\n#include \"source/common/network/transport_socket_options_impl.h\"\n#include \"source/common/runtime/runtime_features.h\"\n#include \"source/common/stats/timespan_impl.h\"\n#include \"source/common/upstream/upstream_impl.h\"\n\nnamespace Envoy {\nnamespace ConnectionPool {\nnamespace {\n[[maybe_unused]] ssize_t connectingCapacity(const std::list<ActiveClientPtr>& connecting_clients) {\n  ssize_t ret = 0;\n  for (const auto& client : connecting_clients) {\n    ret += client->effectiveConcurrentStreamLimit();\n  }\n  return ret;\n}\n} // namespace\n\nConnPoolImplBase::ConnPoolImplBase(\n    Upstream::HostConstSharedPtr host, Upstream::ResourcePriority priority,\n    Event::Dispatcher& dispatcher, const Network::ConnectionSocket::OptionsSharedPtr& options,\n    const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n    Upstream::ClusterConnectivityState& state)\n    : state_(state), host_(host), priority_(priority), dispatcher_(dispatcher),\n      socket_options_(options), transport_socket_options_(transport_socket_options),\n      upstream_ready_cb_(dispatcher_.createSchedulableCallback([this]() { onUpstreamReady(); })) {}\n\nConnPoolImplBase::~ConnPoolImplBase() {\n  ASSERT(isIdleImpl());\n  ASSERT(connecting_stream_capacity_ == 0);\n}\n\nvoid ConnPoolImplBase::deleteIsPendingImpl() {\n  deferred_deleting_ = true;\n  ASSERT(isIdleImpl());\n  ASSERT(connecting_stream_capacity_ == 0);\n}\n\nvoid ConnPoolImplBase::destructAllConnections() {\n  for (auto* list : {&ready_clients_, &busy_clients_, &connecting_clients_}) {\n    while (!list->empty()) {\n      list->front()->close();\n    }\n  }\n\n  // Make sure all clients are destroyed before we are destroyed.\n  dispatcher_.clearDeferredDeleteList();\n}\n\nbool ConnPoolImplBase::shouldConnect(size_t pending_streams, size_t active_streams,\n                                     int64_t connecting_and_connected_capacity,\n                                     float preconnect_ratio, bool anticipate_incoming_stream) {\n  // This is set to true any time global preconnect is being calculated.\n  // ClusterManagerImpl::maybePreconnect is called directly before a stream is created, so the\n  // stream must be anticipated.\n  //\n  // Also without this, we would never pre-establish a connection as the first\n  // connection in a pool because pending/active streams could both be 0.\n  int anticipated_streams = anticipate_incoming_stream ? 1 : 0;\n\n  // The number of streams we want to be provisioned for is the number of\n  // pending, active, and anticipated streams times the preconnect ratio.\n  // The number of streams we are (theoretically) provisioned for is the\n  // connecting stream capacity plus the number of active streams.\n  //\n  // If preconnect ratio is not set, it defaults to 1, and this simplifies to the\n  // legacy value of pending_streams_.size() > connecting_stream_capacity_\n  return (pending_streams + active_streams + anticipated_streams) * preconnect_ratio >\n         connecting_and_connected_capacity + active_streams;\n}\n\nbool ConnPoolImplBase::shouldCreateNewConnection(float global_preconnect_ratio) const {\n  // If the host is not healthy, don't make it do extra work, especially as\n  // upstream selection logic may result in bypassing this upstream entirely.\n  // If an Envoy user wants preconnecting for degraded upstreams this could be\n  // added later via extending the preconnect config.\n  if (host_->health() != Upstream::Host::Health::Healthy) {\n    return pending_streams_.size() > connecting_stream_capacity_;\n  }\n\n  // Determine if we are trying to prefetch for global preconnect or local preconnect.\n  if (global_preconnect_ratio != 0) {\n    // If global preconnecting is on, and this connection is within the global\n    // preconnect limit, preconnect.\n    // For global preconnect, we anticipate an incoming stream to this pool, since it is\n    // prefetching for the next upcoming stream, which will likely be assigned to this pool.\n    // We may eventually want to track preconnect_attempts to allow more preconnecting for\n    // heavily weighted upstreams or sticky picks.\n    return shouldConnect(pending_streams_.size(), num_active_streams_, connecting_stream_capacity_,\n                         global_preconnect_ratio, true);\n  } else {\n    // Ensure this local pool has adequate connections for the given load.\n    //\n    // Local preconnect does not need to anticipate a stream. It is called as\n    // new streams are established or torn down and simply attempts to maintain\n    // the correct ratio of streams and anticipated capacity.\n    return shouldConnect(pending_streams_.size(), num_active_streams_, connecting_stream_capacity_,\n                         perUpstreamPreconnectRatio());\n  }\n}\n\nfloat ConnPoolImplBase::perUpstreamPreconnectRatio() const {\n  return host_->cluster().perUpstreamPreconnectRatio();\n}\n\nConnPoolImplBase::ConnectionResult ConnPoolImplBase::tryCreateNewConnections() {\n  ASSERT(!is_draining_for_deletion_);\n  ConnPoolImplBase::ConnectionResult result;\n  // Somewhat arbitrarily cap the number of connections preconnected due to new\n  // incoming connections. The preconnect ratio is capped at 3, so in steady\n  // state, no more than 3 connections should be preconnected. If hosts go\n  // unhealthy, and connections are not immediately preconnected, it could be that\n  // many connections are desired when the host becomes healthy again, but\n  // overwhelming it with connections is not desirable.\n  for (int i = 0; i < 3; ++i) {\n    result = tryCreateNewConnection();\n    if (result != ConnectionResult::CreatedNewConnection) {\n      break;\n    }\n  }\n  return result;\n}\n\nConnPoolImplBase::ConnectionResult\nConnPoolImplBase::tryCreateNewConnection(float global_preconnect_ratio) {\n  // There are already enough CONNECTING connections for the number of queued streams.\n  if (!shouldCreateNewConnection(global_preconnect_ratio)) {\n    ENVOY_LOG(trace, \"not creating a new connection, shouldCreateNewConnection returned false.\");\n    return ConnectionResult::ShouldNotConnect;\n  }\n\n  const bool can_create_connection =\n      host_->cluster().resourceManager(priority_).connections().canCreate();\n  if (!can_create_connection) {\n    host_->cluster().stats().upstream_cx_overflow_.inc();\n  }\n  // If we are at the connection circuit-breaker limit due to other upstreams having\n  // too many open connections, and this upstream has no connections, always create one, to\n  // prevent pending streams being queued to this upstream with no way to be processed.\n  if (can_create_connection ||\n      (ready_clients_.empty() && busy_clients_.empty() && connecting_clients_.empty())) {\n    ENVOY_LOG(debug, \"creating a new connection\");\n    ActiveClientPtr client = instantiateActiveClient();\n    if (client.get() == nullptr) {\n      ENVOY_LOG(trace, \"connection creation failed\");\n      return ConnectionResult::FailedToCreateConnection;\n    }\n    ASSERT(client->state() == ActiveClient::State::CONNECTING);\n    ASSERT(std::numeric_limits<uint64_t>::max() - connecting_stream_capacity_ >=\n           client->effectiveConcurrentStreamLimit());\n    ASSERT(client->real_host_description_);\n    // Increase the connecting capacity to reflect the streams this connection can serve.\n    state_.incrConnectingAndConnectedStreamCapacity(client->effectiveConcurrentStreamLimit());\n    connecting_stream_capacity_ += client->effectiveConcurrentStreamLimit();\n    LinkedList::moveIntoList(std::move(client), owningList(client->state()));\n    return can_create_connection ? ConnectionResult::CreatedNewConnection\n                                 : ConnectionResult::CreatedButRateLimited;\n  } else {\n    ENVOY_LOG(trace, \"not creating a new connection: connection constrained\");\n    return ConnectionResult::NoConnectionRateLimited;\n  }\n}\n\nvoid ConnPoolImplBase::attachStreamToClient(Envoy::ConnectionPool::ActiveClient& client,\n                                            AttachContext& context) {\n  ASSERT(client.state() == Envoy::ConnectionPool::ActiveClient::State::READY);\n\n  if (enforceMaxRequests() && !host_->cluster().resourceManager(priority_).requests().canCreate()) {\n    ENVOY_LOG(debug, \"max streams overflow\");\n    onPoolFailure(client.real_host_description_, absl::string_view(),\n                  ConnectionPool::PoolFailureReason::Overflow, context);\n    host_->cluster().stats().upstream_rq_pending_overflow_.inc();\n    return;\n  }\n  ENVOY_CONN_LOG(debug, \"creating stream\", client);\n\n  // Latch capacity before updating remaining streams.\n  uint64_t capacity = client.currentUnusedCapacity();\n  client.remaining_streams_--;\n  if (client.remaining_streams_ == 0) {\n    ENVOY_CONN_LOG(debug, \"maximum streams per connection, DRAINING\", client);\n    host_->cluster().stats().upstream_cx_max_requests_.inc();\n    transitionActiveClientState(client, Envoy::ConnectionPool::ActiveClient::State::DRAINING);\n  } else if (capacity == 1) {\n    // As soon as the new stream is created, the client will be maxed out.\n    transitionActiveClientState(client, Envoy::ConnectionPool::ActiveClient::State::BUSY);\n  }\n\n  // Decrement the capacity, as there's one less stream available for serving.\n  // For HTTP/3, the capacity is updated in newStreamEncoder.\n  if (trackStreamCapacity()) {\n    state_.decrConnectingAndConnectedStreamCapacity(1);\n  }\n  // Track the new active stream.\n  state_.incrActiveStreams(1);\n  num_active_streams_++;\n  host_->stats().rq_total_.inc();\n  host_->stats().rq_active_.inc();\n  host_->cluster().stats().upstream_rq_total_.inc();\n  host_->cluster().stats().upstream_rq_active_.inc();\n  host_->cluster().resourceManager(priority_).requests().inc();\n\n  onPoolReady(client, context);\n}\n\nvoid ConnPoolImplBase::onStreamClosed(Envoy::ConnectionPool::ActiveClient& client,\n                                      bool delay_attaching_stream) {\n  ENVOY_CONN_LOG(debug, \"destroying stream: {} remaining\", client, client.numActiveStreams());\n  ASSERT(num_active_streams_ > 0);\n  state_.decrActiveStreams(1);\n  num_active_streams_--;\n  host_->stats().rq_active_.dec();\n  host_->cluster().stats().upstream_rq_active_.dec();\n  host_->cluster().resourceManager(priority_).requests().dec();\n  // We don't update the capacity for HTTP/3 as the stream count should only\n  // increase when a MAX_STREAMS frame is received.\n  if (trackStreamCapacity()) {\n    // If the effective client capacity was limited by concurrency, increase connecting capacity.\n    bool limited_by_concurrency =\n        client.remaining_streams_ > client.concurrent_stream_limit_ - client.numActiveStreams() - 1;\n    // The capacity calculated by concurrency could be negative if a SETTINGS frame lowered the\n    // number of allowed streams. In this case, effective client capacity was still limited by\n    // concurrency, compare client.concurrent_stream_limit_ and client.numActiveStreams() directly\n    // to avoid overflow.\n    bool negative_capacity = client.concurrent_stream_limit_ < client.numActiveStreams() + 1;\n    if (negative_capacity || limited_by_concurrency) {\n      state_.incrConnectingAndConnectedStreamCapacity(1);\n    }\n  }\n  if (client.state() == ActiveClient::State::DRAINING && client.numActiveStreams() == 0) {\n    // Close out the draining client if we no longer have active streams.\n    client.close();\n  } else if (client.state() == ActiveClient::State::BUSY && client.currentUnusedCapacity() > 0) {\n    transitionActiveClientState(client, ActiveClient::State::READY);\n    if (!delay_attaching_stream) {\n      onUpstreamReady();\n    }\n  }\n}\n\nConnectionPool::Cancellable* ConnPoolImplBase::newStreamImpl(AttachContext& context,\n                                                             bool can_send_early_data) {\n  ASSERT(!is_draining_for_deletion_);\n  ASSERT(!deferred_deleting_);\n\n  ASSERT(static_cast<ssize_t>(connecting_stream_capacity_) ==\n         connectingCapacity(connecting_clients_)); // O(n) debug check.\n  if (!ready_clients_.empty()) {\n    ActiveClient& client = *ready_clients_.front();\n    ENVOY_CONN_LOG(debug, \"using existing connection\", client);\n    attachStreamToClient(client, context);\n    // Even if there's a ready client, we may want to preconnect to handle the next incoming stream.\n    tryCreateNewConnections();\n    return nullptr;\n  }\n\n  if (!host_->cluster().resourceManager(priority_).pendingRequests().canCreate()) {\n    ENVOY_LOG(debug, \"max pending streams overflow\");\n    onPoolFailure(nullptr, absl::string_view(), ConnectionPool::PoolFailureReason::Overflow,\n                  context);\n    host_->cluster().stats().upstream_rq_pending_overflow_.inc();\n    return nullptr;\n  }\n\n  ConnectionPool::Cancellable* pending = newPendingStream(context, can_send_early_data);\n  ENVOY_LOG(debug, \"trying to create new connection\");\n  ENVOY_LOG(trace, fmt::format(\"{}\", *this));\n\n  auto old_capacity = connecting_stream_capacity_;\n  // This must come after newPendingStream() because this function uses the\n  // length of pending_streams_ to determine if a new connection is needed.\n  const ConnectionResult result = tryCreateNewConnections();\n  // If there is not enough connecting capacity, the only reason to not\n  // increase capacity is if the connection limits are exceeded.\n  ENVOY_BUG(pending_streams_.size() <= connecting_stream_capacity_ ||\n                connecting_stream_capacity_ > old_capacity ||\n                (result == ConnectionResult::NoConnectionRateLimited ||\n                 result == ConnectionResult::FailedToCreateConnection),\n            fmt::format(\"Failed to create expected connection: {}\", *this));\n  if (result == ConnectionResult::FailedToCreateConnection) {\n    // This currently only happens for HTTP/3 if secrets aren't yet loaded.\n    // Trigger connection failure.\n    pending->cancel(Envoy::ConnectionPool::CancelPolicy::CloseExcess);\n    onPoolFailure(nullptr, absl::string_view(), ConnectionPool::PoolFailureReason::Overflow,\n                  context);\n    return nullptr;\n  }\n\n  return pending;\n}\n\nbool ConnPoolImplBase::maybePreconnectImpl(float global_preconnect_ratio) {\n  ASSERT(!deferred_deleting_);\n  return tryCreateNewConnection(global_preconnect_ratio) == ConnectionResult::CreatedNewConnection;\n}\n\nvoid ConnPoolImplBase::scheduleOnUpstreamReady() {\n  upstream_ready_cb_->scheduleCallbackCurrentIteration();\n}\n\nvoid ConnPoolImplBase::onUpstreamReady() {\n  while (!pending_streams_.empty() && !ready_clients_.empty()) {\n    ActiveClientPtr& client = ready_clients_.front();\n    ENVOY_CONN_LOG(debug, \"attaching to next stream\", *client);\n    // Pending streams are pushed onto the front, so pull from the back.\n    attachStreamToClient(*client, pending_streams_.back()->context());\n    state_.decrPendingStreams(1);\n    pending_streams_.pop_back();\n  }\n  if (!pending_streams_.empty()) {\n    tryCreateNewConnections();\n  }\n}\n\nstd::list<ActiveClientPtr>& ConnPoolImplBase::owningList(ActiveClient::State state) {\n  switch (state) {\n  case ActiveClient::State::CONNECTING:\n    return connecting_clients_;\n  case ActiveClient::State::READY:\n    return ready_clients_;\n  case ActiveClient::State::BUSY:\n    return busy_clients_;\n  case ActiveClient::State::DRAINING:\n    return busy_clients_;\n  case ActiveClient::State::CLOSED:\n    break; // Fall through to PANIC.\n  }\n  PANIC(\"unexpected\");\n}\n\nvoid ConnPoolImplBase::transitionActiveClientState(ActiveClient& client,\n                                                   ActiveClient::State new_state) {\n  auto& old_list = owningList(client.state());\n  auto& new_list = owningList(new_state);\n  client.setState(new_state);\n\n  // old_list and new_list can be equal when transitioning from BUSY to DRAINING.\n  //\n  // The documentation for list.splice() (which is what moveBetweenLists() calls) is\n  // unclear whether it is allowed for src and dst to be the same, so check here\n  // since it is a no-op anyways.\n  if (&old_list != &new_list) {\n    client.moveBetweenLists(old_list, new_list);\n  }\n}\n\nvoid ConnPoolImplBase::addIdleCallbackImpl(Instance::IdleCb cb) { idle_callbacks_.push_back(cb); }\n\nvoid ConnPoolImplBase::closeIdleConnectionsForDrainingPool() {\n  Common::AutoDebugRecursionChecker assert_not_in(recursion_checker_);\n\n  // Create a separate list of elements to close to avoid mutate-while-iterating problems.\n  std::list<ActiveClient*> to_close;\n\n  for (auto& client : ready_clients_) {\n    if (client->numActiveStreams() == 0) {\n      to_close.push_back(client.get());\n    }\n  }\n\n  if (pending_streams_.empty()) {\n    for (auto& client : connecting_clients_) {\n      to_close.push_back(client.get());\n    }\n  }\n\n  for (auto& entry : to_close) {\n    ENVOY_LOG_EVENT(debug, \"closing_idle_client\", \"closing idle client {} for cluster {}\",\n                    entry->id(), host_->cluster().name());\n    entry->close();\n  }\n}\n\nvoid ConnPoolImplBase::drainConnectionsImpl(DrainBehavior drain_behavior) {\n  if (drain_behavior == Envoy::ConnectionPool::DrainBehavior::DrainAndDelete) {\n    is_draining_for_deletion_ = true;\n    checkForIdleAndCloseIdleConnsIfDraining();\n    return;\n  }\n  closeIdleConnectionsForDrainingPool();\n\n  // closeIdleConnections() closes all connections in ready_clients_ with no active streams,\n  // so all remaining entries in ready_clients_ are serving streams. Move them and all entries\n  // in busy_clients_ to draining.\n  while (!ready_clients_.empty()) {\n    ENVOY_LOG_EVENT(debug, \"draining_ready_client\", \"draining active client {} for cluster {}\",\n                    ready_clients_.front()->id(), host_->cluster().name());\n    transitionActiveClientState(*ready_clients_.front(), ActiveClient::State::DRAINING);\n  }\n\n  // Changing busy_clients_ to DRAINING does not move them between lists,\n  // so use a for-loop since the list is not mutated.\n  ASSERT(&owningList(ActiveClient::State::DRAINING) == &busy_clients_);\n  for (auto& busy_client : busy_clients_) {\n    ENVOY_LOG_EVENT(debug, \"draining_busy_client\", \"draining busy client {} for cluster {}\",\n                    busy_client->id(), host_->cluster().name());\n    transitionActiveClientState(*busy_client, ActiveClient::State::DRAINING);\n  }\n}\n\nbool ConnPoolImplBase::isIdleImpl() const {\n  return pending_streams_.empty() && ready_clients_.empty() && busy_clients_.empty() &&\n         connecting_clients_.empty();\n}\n\nvoid ConnPoolImplBase::checkForIdleAndNotify() {\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}\n\nvoid ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n\n  checkForIdleAndNotify();\n}\n\nvoid ConnPoolImplBase::onConnectionEvent(ActiveClient& client, absl::string_view failure_reason,\n                                         Network::ConnectionEvent event) {\n  if (client.state() == ActiveClient::State::CONNECTING) {\n    ASSERT(connecting_stream_capacity_ >= client.effectiveConcurrentStreamLimit());\n    connecting_stream_capacity_ -= client.effectiveConcurrentStreamLimit();\n  }\n\n  if (client.connect_timer_) {\n    client.connect_timer_->disableTimer();\n    client.connect_timer_.reset();\n  }\n\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    state_.decrConnectingAndConnectedStreamCapacity(client.currentUnusedCapacity());\n    // Make sure that onStreamClosed won't double count.\n    client.remaining_streams_ = 0;\n    // The client died.\n    ENVOY_CONN_LOG(debug, \"client disconnected, failure reason: {}\", client, failure_reason);\n\n    Envoy::Upstream::reportUpstreamCxDestroy(host_, event);\n    const bool incomplete_stream = client.closingWithIncompleteStream();\n    if (incomplete_stream) {\n      Envoy::Upstream::reportUpstreamCxDestroyActiveRequest(host_, event);\n    }\n\n    if (client.state() == ActiveClient::State::CONNECTING) {\n      host_->cluster().stats().upstream_cx_connect_fail_.inc();\n      host_->stats().cx_connect_fail_.inc();\n\n      ConnectionPool::PoolFailureReason reason;\n      if (client.timed_out_) {\n        reason = ConnectionPool::PoolFailureReason::Timeout;\n      } else if (event == Network::ConnectionEvent::RemoteClose) {\n        reason = ConnectionPool::PoolFailureReason::RemoteConnectionFailure;\n      } else {\n        reason = ConnectionPool::PoolFailureReason::LocalConnectionFailure;\n      }\n\n      // Raw connect failures should never happen under normal circumstances. If we have an upstream\n      // that is behaving badly, streams can get stuck here in the pending state. If we see a\n      // connect failure, we purge all pending streams so that calling code can determine what to\n      // do with the stream.\n      // NOTE: We move the existing pending streams to a temporary list. This is done so that\n      //       if retry logic submits a new stream to the pool, we don't fail it inline.\n      purgePendingStreams(client.real_host_description_, failure_reason, reason);\n      // See if we should preconnect based on active connections.\n      if (!is_draining_for_deletion_) {\n        tryCreateNewConnections();\n      }\n    }\n\n    // We need to release our resourceManager() resources before checking below for\n    // whether we can create a new connection. Normally this would happen when\n    // client's destructor runs, but this object needs to be deferredDelete'd(), so\n    // this forces part of its cleanup to happen now.\n    client.releaseResources();\n\n    // Again, since we know this object is going to be deferredDelete'd(), we take\n    // this opportunity to disable and reset the connection duration timer so that\n    // it doesn't trigger while on the deferred delete list. In theory it is safe\n    // to handle the CLOSED state in onConnectionDurationTimeout, but we handle\n    // it here for simplicity and safety anyway.\n    if (client.connection_duration_timer_) {\n      client.connection_duration_timer_->disableTimer();\n      client.connection_duration_timer_.reset();\n    }\n\n    dispatcher_.deferredDelete(client.removeFromList(owningList(client.state())));\n\n    // Check if the pool transitioned to idle state after removing closed client\n    // from one of the client tracking lists.\n    // There is no need to check if other connections are idle in a draining pool\n    // because the pool will close all idle connection when it is starting to\n    // drain.\n    // Trying to close other connections here can lead to deep recursion when\n    // a large number idle connections are closed at the start of pool drain.\n    // See CdsIntegrationTest.CdsClusterDownWithLotsOfIdleConnections for an example.\n    checkForIdleAndNotify();\n\n    client.setState(ActiveClient::State::CLOSED);\n\n    // If we have pending streams and we just lost a connection we should make a new one.\n    if (!pending_streams_.empty()) {\n      tryCreateNewConnections();\n    }\n  } else if (event == Network::ConnectionEvent::Connected) {\n    client.conn_connect_ms_->complete();\n    client.conn_connect_ms_.reset();\n    ASSERT(client.state() == ActiveClient::State::CONNECTING);\n    bool streams_available = client.currentUnusedCapacity() > 0;\n    transitionActiveClientState(client, streams_available ? ActiveClient::State::READY\n                                                          : ActiveClient::State::BUSY);\n\n    // Now that the active client is ready, set up a timer for max connection duration.\n    const absl::optional<std::chrono::milliseconds> max_connection_duration =\n        client.parent_.host()->cluster().maxConnectionDuration();\n    if (max_connection_duration.has_value()) {\n      client.connection_duration_timer_ = client.parent_.dispatcher().createTimer(\n          [&client]() { client.onConnectionDurationTimeout(); });\n      client.connection_duration_timer_->enableTimer(max_connection_duration.value());\n    }\n\n    // At this point, for the mixed ALPN pool, the client may be deleted. Do not\n    // refer to client after this point.\n    onConnected(client);\n    if (streams_available) {\n      onUpstreamReady();\n    }\n    checkForIdleAndCloseIdleConnsIfDraining();\n  }\n}\n\nPendingStream::PendingStream(ConnPoolImplBase& parent, bool can_send_early_data)\n    : parent_(parent), can_send_early_data_(can_send_early_data) {\n  parent_.host()->cluster().stats().upstream_rq_pending_total_.inc();\n  parent_.host()->cluster().stats().upstream_rq_pending_active_.inc();\n  parent_.host()->cluster().resourceManager(parent_.priority()).pendingRequests().inc();\n}\n\nPendingStream::~PendingStream() {\n  parent_.host()->cluster().stats().upstream_rq_pending_active_.dec();\n  parent_.host()->cluster().resourceManager(parent_.priority()).pendingRequests().dec();\n}\n\nvoid PendingStream::cancel(Envoy::ConnectionPool::CancelPolicy policy) {\n  parent_.onPendingStreamCancel(*this, policy);\n}\n\nvoid ConnPoolImplBase::purgePendingStreams(\n    const Upstream::HostDescriptionConstSharedPtr& host_description,\n    absl::string_view failure_reason, ConnectionPool::PoolFailureReason reason) {\n  // NOTE: We move the existing pending streams to a temporary list. This is done so that\n  //       if retry logic submits a new stream to the pool, we don't fail it inline.\n  state_.decrPendingStreams(pending_streams_.size());\n  pending_streams_to_purge_ = std::move(pending_streams_);\n  while (!pending_streams_to_purge_.empty()) {\n    PendingStreamPtr stream =\n        pending_streams_to_purge_.front()->removeFromList(pending_streams_to_purge_);\n    host_->cluster().stats().upstream_rq_pending_failure_eject_.inc();\n    onPoolFailure(host_description, failure_reason, reason, stream->context());\n  }\n}\n\nbool ConnPoolImplBase::connectingConnectionIsExcess() const {\n  ASSERT(connecting_stream_capacity_ >=\n         connecting_clients_.front()->effectiveConcurrentStreamLimit());\n  // If perUpstreamPreconnectRatio is one, this simplifies to checking if there would still be\n  // sufficient connecting stream capacity to serve all pending streams if the most recent client\n  // were removed from the picture.\n  //\n  // If preconnect ratio is set, it also factors in the anticipated load based on both queued\n  // streams and active streams, and makes sure the connecting capacity would still be sufficient to\n  // serve that even with the most recent client removed.\n  return (pending_streams_.size() + num_active_streams_) * perUpstreamPreconnectRatio() <=\n         (connecting_stream_capacity_ -\n          connecting_clients_.front()->effectiveConcurrentStreamLimit() + num_active_streams_);\n}\n\nvoid ConnPoolImplBase::onPendingStreamCancel(PendingStream& stream,\n                                             Envoy::ConnectionPool::CancelPolicy policy) {\n  ENVOY_LOG(debug, \"cancelling pending stream\");\n  if (!pending_streams_to_purge_.empty()) {\n    // If pending_streams_to_purge_ is not empty, it means that we are called from\n    // with-in a onPoolFailure callback invoked in purgePendingStreams (i.e. purgePendingStreams\n    // is down in the call stack). Remove this stream from the list as it is cancelled,\n    // and there is no need to call its onPoolFailure callback.\n    stream.removeFromList(pending_streams_to_purge_);\n  } else {\n    state_.decrPendingStreams(1);\n    stream.removeFromList(pending_streams_);\n  }\n  if (policy == Envoy::ConnectionPool::CancelPolicy::CloseExcess && !connecting_clients_.empty() &&\n      connectingConnectionIsExcess()) {\n    auto& client = *connecting_clients_.front();\n    transitionActiveClientState(client, ActiveClient::State::DRAINING);\n    client.close();\n  }\n\n  host_->cluster().stats().upstream_rq_cancelled_.inc();\n  checkForIdleAndCloseIdleConnsIfDraining();\n}\n\nnamespace {\n// Translate zero to UINT64_MAX so that the zero/unlimited case doesn't\n// have to be handled specially.\nuint32_t translateZeroToUnlimited(uint32_t limit) {\n  return (limit != 0) ? limit : std::numeric_limits<uint32_t>::max();\n}\n} // namespace\n\nActiveClient::ActiveClient(ConnPoolImplBase& parent, uint32_t lifetime_stream_limit,\n                           uint32_t concurrent_stream_limit)\n    : parent_(parent), remaining_streams_(translateZeroToUnlimited(lifetime_stream_limit)),\n      configured_stream_limit_(translateZeroToUnlimited(concurrent_stream_limit)),\n      concurrent_stream_limit_(translateZeroToUnlimited(concurrent_stream_limit)),\n      connect_timer_(parent_.dispatcher().createTimer([this]() { onConnectTimeout(); })) {\n  conn_connect_ms_ = std::make_unique<Stats::HistogramCompletableTimespanImpl>(\n      parent_.host()->cluster().stats().upstream_cx_connect_ms_, parent_.dispatcher().timeSource());\n  conn_length_ = std::make_unique<Stats::HistogramCompletableTimespanImpl>(\n      parent_.host()->cluster().stats().upstream_cx_length_ms_, parent_.dispatcher().timeSource());\n  connect_timer_->enableTimer(parent_.host()->cluster().connectTimeout());\n  parent_.host()->stats().cx_total_.inc();\n  parent_.host()->stats().cx_active_.inc();\n  parent_.host()->cluster().stats().upstream_cx_total_.inc();\n  parent_.host()->cluster().stats().upstream_cx_active_.inc();\n  parent_.host()->cluster().resourceManager(parent_.priority()).connections().inc();\n}\n\nActiveClient::~ActiveClient() { releaseResourcesBase(); }\n\nvoid ActiveClient::releaseResourcesBase() {\n  if (!resources_released_) {\n    resources_released_ = true;\n\n    conn_length_->complete();\n\n    parent_.host()->cluster().stats().upstream_cx_active_.dec();\n    parent_.host()->stats().cx_active_.dec();\n    parent_.host()->cluster().resourceManager(parent_.priority()).connections().dec();\n  }\n}\n\nvoid ActiveClient::onConnectTimeout() {\n  ENVOY_CONN_LOG(debug, \"connect timeout\", *this);\n  parent_.host()->cluster().stats().upstream_cx_connect_timeout_.inc();\n  timed_out_ = true;\n  close();\n}\n\nvoid ActiveClient::onConnectionDurationTimeout() {\n  // The connection duration timer should only have started after we left the CONNECTING state.\n  ENVOY_BUG(state_ != ActiveClient::State::CONNECTING,\n            \"max connection duration reached while connecting\");\n\n  // The connection duration timer should have been disabled and reset in onConnectionEvent\n  // for closing connections.\n  ENVOY_BUG(state_ != ActiveClient::State::CLOSED, \"max connection duration reached while closed\");\n\n  // There's nothing to do if the client is connecting, closed or draining.\n  // Two of these cases are bugs (see above), but it is safe to no-op either way.\n  if (state_ == ActiveClient::State::CONNECTING || state_ == ActiveClient::State::CLOSED ||\n      state_ == ActiveClient::State::DRAINING) {\n    return;\n  }\n\n  ENVOY_CONN_LOG(debug, \"max connection duration reached, DRAINING\", *this);\n  parent_.host()->cluster().stats().upstream_cx_max_duration_reached_.inc();\n  parent_.transitionActiveClientState(*this, Envoy::ConnectionPool::ActiveClient::State::DRAINING);\n\n  // Close out the draining client if we no longer have active streams.\n  // We have to do this here because there won't be an onStreamClosed (because there are\n  // no active streams) to do it for us later.\n  if (numActiveStreams() == 0) {\n    close();\n  }\n}\n\nvoid ActiveClient::drain() {\n  if (currentUnusedCapacity() <= 0) {\n    return;\n  }\n  if (state() == ActiveClient::State::CONNECTING) {\n    // If connecting, update both the cluster capacity and the local connecting\n    // capacity.\n    parent_.decrConnectingAndConnectedStreamCapacity(currentUnusedCapacity());\n  } else {\n    parent_.state().decrConnectingAndConnectedStreamCapacity(currentUnusedCapacity());\n  }\n\n  remaining_streams_ = 0;\n}\n\n} // namespace ConnectionPool\n} // namespace Envoy\n", "#pragma once\n\n#include \"envoy/common/conn_pool.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/connection.h\"\n#include \"envoy/stats/timespan.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n\n#include \"source/common/common/debug_recursion_checker.h\"\n#include \"source/common/common/dump_state_utils.h\"\n#include \"source/common/common/linked_object.h\"\n\n#include \"absl/strings/string_view.h\"\n\nnamespace Envoy {\nnamespace ConnectionPool {\n\nclass ConnPoolImplBase;\n\n// A placeholder struct for whatever data a given connection pool needs to\n// successfully attach an upstream connection to a downstream connection.\nstruct AttachContext {\n  // Add a virtual destructor to allow for the dynamic_cast ASSERT in typedContext.\n  virtual ~AttachContext() = default;\n};\n\n// ActiveClient provides a base class for connection pool clients that handles connection timings\n// as well as managing the connection timeout.\nclass ActiveClient : public LinkedObject<ActiveClient>,\n                     public Network::ConnectionCallbacks,\n                     public Event::DeferredDeletable,\n                     protected Logger::Loggable<Logger::Id::pool> {\npublic:\n  ActiveClient(ConnPoolImplBase& parent, uint32_t lifetime_stream_limit,\n               uint32_t concurrent_stream_limit);\n  ~ActiveClient() override;\n\n  virtual void releaseResources() { releaseResourcesBase(); }\n  void releaseResourcesBase();\n\n  // Network::ConnectionCallbacks\n  void onAboveWriteBufferHighWatermark() override {}\n  void onBelowWriteBufferLowWatermark() override {}\n\n  // Called if the connection does not complete within the cluster's connectTimeout()\n  void onConnectTimeout();\n\n  // Called if the maximum connection duration is reached.\n  void onConnectionDurationTimeout();\n\n  // Returns the concurrent stream limit, accounting for if the total stream limit\n  // is less than the concurrent stream limit.\n  virtual uint32_t effectiveConcurrentStreamLimit() const {\n    return std::min(remaining_streams_, concurrent_stream_limit_);\n  }\n\n  // Returns the application protocol, or absl::nullopt for TCP.\n  virtual absl::optional<Http::Protocol> protocol() const PURE;\n\n  virtual int64_t currentUnusedCapacity() const {\n    int64_t remaining_concurrent_streams =\n        static_cast<int64_t>(concurrent_stream_limit_) - numActiveStreams();\n\n    return std::min<int64_t>(remaining_streams_, remaining_concurrent_streams);\n  }\n\n  // Closes the underlying connection.\n  virtual void close() PURE;\n  // Returns the ID of the underlying connection.\n  virtual uint64_t id() const PURE;\n  // Returns true if this closed with an incomplete stream, for stats tracking/ purposes.\n  virtual bool closingWithIncompleteStream() const PURE;\n  // Returns the number of active streams on this connection.\n  virtual uint32_t numActiveStreams() const PURE;\n\n  // This function is called onStreamClosed to see if there was a negative delta\n  // and (if necessary) update associated bookkeeping.\n  // HTTP/1 and TCP pools can not have negative delta so the default implementation simply returns\n  // false. The HTTP/2 connection pool can have this state, so overrides this function.\n  virtual bool hadNegativeDeltaOnStreamClosed() { return false; }\n\n  enum class State {\n    CONNECTING, // Connection is not yet established.\n    READY,      // Additional streams may be immediately dispatched to this connection.\n    BUSY,       // Connection is at its concurrent stream limit.\n    DRAINING,   // No more streams can be dispatched to this connection, and it will be closed\n    // when all streams complete.\n    CLOSED // Connection is closed and object is queued for destruction.\n  };\n\n  State state() const { return state_; }\n\n  void setState(State state) {\n    // If the client is transitioning to draining, update the remaining\n    // streams and pool and cluster capacity.\n    if (state == State::DRAINING) {\n      drain();\n    }\n    state_ = state;\n  }\n\n  // Sets the remaining streams to 0, and updates pool and cluster capacity.\n  virtual void drain();\n\n  ConnPoolImplBase& parent_;\n  // The count of remaining streams allowed for this connection.\n  // This will start out as the total number of streams per connection if capped\n  // by configuration, or it will be set to std::numeric_limits<uint32_t>::max() to be\n  // (functionally) unlimited.\n  // TODO: this could be moved to an optional to make it actually unlimited.\n  uint32_t remaining_streams_;\n  // The will start out as the upper limit of max concurrent streams for this connection\n  // if capped by configuration, or it will be set to std::numeric_limits<uint32_t>::max()\n  // to be (functionally) unlimited.\n  uint32_t configured_stream_limit_;\n  // The max concurrent stream for this connection, it's initialized by `configured_stream_limit_`\n  // and can be adjusted by SETTINGS frame, but the max value of it can't exceed\n  // `configured_stream_limit_`.\n  uint32_t concurrent_stream_limit_;\n  Upstream::HostDescriptionConstSharedPtr real_host_description_;\n  Stats::TimespanPtr conn_connect_ms_;\n  Stats::TimespanPtr conn_length_;\n  Event::TimerPtr connect_timer_;\n  Event::TimerPtr connection_duration_timer_;\n  bool resources_released_{false};\n  bool timed_out_{false};\n\nprivate:\n  State state_{State::CONNECTING};\n};\n\n// PendingStream is the base class tracking streams for which a connection has been created but not\n// yet established.\nclass PendingStream : public LinkedObject<PendingStream>, public ConnectionPool::Cancellable {\npublic:\n  PendingStream(ConnPoolImplBase& parent, bool can_send_early_data);\n  ~PendingStream() override;\n\n  // ConnectionPool::Cancellable\n  void cancel(Envoy::ConnectionPool::CancelPolicy policy) override;\n\n  // The context here returns a pointer to whatever context is provided with newStream(),\n  // which will be passed back to the parent in onPoolReady or onPoolFailure.\n  virtual AttachContext& context() PURE;\n\n  ConnPoolImplBase& parent_;\n  // The request can be sent as early data.\n  bool can_send_early_data_;\n};\n\nusing PendingStreamPtr = std::unique_ptr<PendingStream>;\n\nusing ActiveClientPtr = std::unique_ptr<ActiveClient>;\n\n// Base class that handles stream queueing logic shared between connection pool implementations.\nclass ConnPoolImplBase : protected Logger::Loggable<Logger::Id::pool> {\npublic:\n  ConnPoolImplBase(Upstream::HostConstSharedPtr host, Upstream::ResourcePriority priority,\n                   Event::Dispatcher& dispatcher,\n                   const Network::ConnectionSocket::OptionsSharedPtr& options,\n                   const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                   Upstream::ClusterConnectivityState& state);\n  virtual ~ConnPoolImplBase();\n\n  void deleteIsPendingImpl();\n  // By default, the connection pool will track connected and connecting stream\n  // capacity as streams are created and destroyed. QUIC does custom stream\n  // accounting so will override this to false.\n  virtual bool trackStreamCapacity() { return true; }\n\n  // A helper function to get the specific context type from the base class context.\n  template <class T> T& typedContext(AttachContext& context) {\n    ASSERT(dynamic_cast<T*>(&context) != nullptr);\n    return *static_cast<T*>(&context);\n  }\n\n  // Determines if prefetching is warranted based on the number of streams in\n  // use, pending streams, anticipated and/or currently unused capacity, and\n  // preconnect configuration.\n  //\n  // If anticipate_incoming_stream is true this assumes a call to newStream is\n  // pending, which is true for global preconnect.\n  static bool shouldConnect(size_t pending_streams, size_t active_streams,\n                            int64_t connecting_and_connected_capacity, float preconnect_ratio,\n                            bool anticipate_incoming_stream = false);\n\n  // Envoy::ConnectionPool::Instance implementation helpers\n  void addIdleCallbackImpl(Instance::IdleCb cb);\n  // Returns true if the pool is idle.\n  bool isIdleImpl() const;\n  void drainConnectionsImpl(DrainBehavior drain_behavior);\n  const Upstream::HostConstSharedPtr& host() const { return host_; }\n  // Called if this pool is likely to be picked soon, to determine if it's worth preconnecting.\n  bool maybePreconnectImpl(float global_preconnect_ratio);\n\n  // Closes and destroys all connections. This must be called in the destructor of\n  // derived classes because the derived ActiveClient will downcast parent_ to a more\n  // specific type of ConnPoolImplBase, but if the more specific part is already destructed\n  // (due to bottom-up destructor ordering in c++) that access will be invalid.\n  void destructAllConnections();\n\n  // Returns a new instance of ActiveClient.\n  virtual ActiveClientPtr instantiateActiveClient() PURE;\n\n  // Gets a pointer to the list that currently owns this client.\n  std::list<ActiveClientPtr>& owningList(ActiveClient::State state);\n\n  // Removes the PendingStream from the list of streams. Called when the PendingStream is\n  // cancelled, e.g. when the stream is reset before a connection has been established.\n  void onPendingStreamCancel(PendingStream& stream, Envoy::ConnectionPool::CancelPolicy policy);\n\n  // Fails all pending streams, calling onPoolFailure on the associated callbacks.\n  void purgePendingStreams(const Upstream::HostDescriptionConstSharedPtr& host_description,\n                           absl::string_view failure_reason,\n                           ConnectionPool::PoolFailureReason pool_failure_reason);\n\n  // Closes any idle connections as this pool is drained.\n  void closeIdleConnectionsForDrainingPool();\n\n  // Changes the state_ of an ActiveClient and moves to the appropriate list.\n  void transitionActiveClientState(ActiveClient& client, ActiveClient::State new_state);\n\n  void onConnectionEvent(ActiveClient& client, absl::string_view failure_reason,\n                         Network::ConnectionEvent event);\n\n  // Check if the pool has gone idle and invoke idle notification callbacks.\n  void checkForIdleAndNotify();\n\n  // See if the pool has gone idle. If we're draining, this will also close idle connections.\n  void checkForIdleAndCloseIdleConnsIfDraining();\n\n  void scheduleOnUpstreamReady();\n  ConnectionPool::Cancellable* newStreamImpl(AttachContext& context, bool can_send_early_data);\n\n  virtual ConnectionPool::Cancellable* newPendingStream(AttachContext& context,\n                                                        bool can_send_early_data) PURE;\n\n  virtual void attachStreamToClient(Envoy::ConnectionPool::ActiveClient& client,\n                                    AttachContext& context);\n\n  virtual void onPoolFailure(const Upstream::HostDescriptionConstSharedPtr& host_description,\n                             absl::string_view failure_reason,\n                             ConnectionPool::PoolFailureReason pool_failure_reason,\n                             AttachContext& context) PURE;\n  virtual void onPoolReady(ActiveClient& client, AttachContext& context) PURE;\n  // Called by derived classes any time a stream is completed or destroyed for any reason.\n  void onStreamClosed(Envoy::ConnectionPool::ActiveClient& client, bool delay_attaching_stream);\n\n  Event::Dispatcher& dispatcher() { return dispatcher_; }\n  Upstream::ResourcePriority priority() const { return priority_; }\n  const Network::ConnectionSocket::OptionsSharedPtr& socketOptions() { return socket_options_; }\n  const Network::TransportSocketOptionsConstSharedPtr& transportSocketOptions() {\n    return transport_socket_options_;\n  }\n  bool hasPendingStreams() const { return !pending_streams_.empty(); }\n\n  void decrClusterStreamCapacity(uint32_t delta) {\n    state_.decrConnectingAndConnectedStreamCapacity(delta);\n  }\n  void incrClusterStreamCapacity(uint32_t delta) {\n    state_.incrConnectingAndConnectedStreamCapacity(delta);\n  }\n  void dumpState(std::ostream& os, int indent_level = 0) const {\n    const char* spaces = spacesForLevel(indent_level);\n    os << spaces << \"ConnPoolImplBase \" << this << DUMP_MEMBER(ready_clients_.size())\n       << DUMP_MEMBER(busy_clients_.size()) << DUMP_MEMBER(connecting_clients_.size())\n       << DUMP_MEMBER(connecting_stream_capacity_) << DUMP_MEMBER(num_active_streams_)\n       << DUMP_MEMBER(pending_streams_.size())\n       << \" per upstream preconnect ratio: \" << perUpstreamPreconnectRatio();\n  }\n\n  friend std::ostream& operator<<(std::ostream& os, const ConnPoolImplBase& s) {\n    s.dumpState(os);\n    return os;\n  }\n  Upstream::ClusterConnectivityState& state() { return state_; }\n\n  void decrConnectingAndConnectedStreamCapacity(uint32_t delta) {\n    state_.decrConnectingAndConnectedStreamCapacity(delta);\n    ASSERT(connecting_stream_capacity_ >= delta);\n    connecting_stream_capacity_ -= delta;\n  }\n\n  void incrConnectingAndConnectedStreamCapacity(uint32_t delta) {\n    state_.incrConnectingAndConnectedStreamCapacity(delta);\n    connecting_stream_capacity_ += delta;\n  }\n\n  // Called when an upstream is ready to serve pending streams.\n  void onUpstreamReady();\n\nprotected:\n  virtual void onConnected(Envoy::ConnectionPool::ActiveClient&) {}\n\n  enum class ConnectionResult {\n    FailedToCreateConnection,\n    CreatedNewConnection,\n    ShouldNotConnect,\n    NoConnectionRateLimited,\n    CreatedButRateLimited,\n  };\n  // Creates up to 3 connections, based on the preconnect ratio.\n  // Returns the ConnectionResult of the last attempt.\n  ConnectionResult tryCreateNewConnections();\n\n  // Creates a new connection if there is sufficient demand, it is allowed by resourceManager, or\n  // to avoid starving this pool.\n  // Demand is determined either by perUpstreamPreconnectRatio() or global_preconnect_ratio\n  // if this is called by maybePreconnect()\n  ConnectionResult tryCreateNewConnection(float global_preconnect_ratio = 0);\n\n  // A helper function which determines if a canceled pending connection should\n  // be closed as excess or not.\n  bool connectingConnectionIsExcess() const;\n\n  // A helper function which determines if a new incoming stream should trigger\n  // connection preconnect.\n  bool shouldCreateNewConnection(float global_preconnect_ratio) const;\n\n  float perUpstreamPreconnectRatio() const;\n\n  ConnectionPool::Cancellable*\n  addPendingStream(Envoy::ConnectionPool::PendingStreamPtr&& pending_stream) {\n    LinkedList::moveIntoList(std::move(pending_stream), pending_streams_);\n    state_.incrPendingStreams(1);\n    return pending_streams_.front().get();\n  }\n\n  bool hasActiveStreams() const { return num_active_streams_ > 0; }\n\n  Upstream::ClusterConnectivityState& state_;\n\n  const Upstream::HostConstSharedPtr host_;\n  const Upstream::ResourcePriority priority_;\n\n  Event::Dispatcher& dispatcher_;\n  const Network::ConnectionSocket::OptionsSharedPtr socket_options_;\n  const Network::TransportSocketOptionsConstSharedPtr transport_socket_options_;\n\n  // True if the max requests circuit breakers apply.\n  // This will be false for the TCP pool, true otherwise.\n  virtual bool enforceMaxRequests() const { return true; }\n\n  std::list<Instance::IdleCb> idle_callbacks_;\n\n  // When calling purgePendingStreams, this list will be used to hold the streams we are about\n  // to purge. We need this if one cancelled streams cancels a different pending stream\n  std::list<PendingStreamPtr> pending_streams_to_purge_;\n\n  // Clients that are ready to handle additional streams.\n  // All entries are in state READY.\n  std::list<ActiveClientPtr> ready_clients_;\n\n  // Clients that are not ready to handle additional streams due to being BUSY or DRAINING.\n  std::list<ActiveClientPtr> busy_clients_;\n\n  // Clients that are not ready to handle additional streams because they are CONNECTING.\n  std::list<ActiveClientPtr> connecting_clients_;\n\n  // The number of streams that can be immediately dispatched\n  // if all CONNECTING connections become connected.\n  uint32_t connecting_stream_capacity_{0};\n\nprivate:\n  std::list<PendingStreamPtr> pending_streams_;\n\n  // The number of streams currently attached to clients.\n  uint32_t num_active_streams_{0};\n\n  // Whether the connection pool is currently in the process of closing\n  // all connections so that it can be gracefully deleted.\n  bool is_draining_for_deletion_{false};\n\n  // True iff this object is in the deferred delete list.\n  bool deferred_deleting_{false};\n\n  Event::SchedulableCallbackPtr upstream_ready_cb_;\n  Common::DebugRecursionChecker recursion_checker_;\n};\n\n} // namespace ConnectionPool\n} // namespace Envoy\n", "#include \"test/config/utility.h\"\n\n#include \"envoy/config/bootstrap/v3/bootstrap.pb.h\"\n#include \"envoy/config/cluster/v3/cluster.pb.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/endpoint/v3/endpoint.pb.h\"\n#include \"envoy/config/listener/v3/listener_components.pb.h\"\n#include \"envoy/config/route/v3/route_components.pb.h\"\n#include \"envoy/extensions/access_loggers/file/v3/file.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n#include \"envoy/extensions/transport_sockets/quic/v3/quic_transport.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/http/codec.h\"\n#include \"envoy/service/discovery/v3/discovery.pb.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"test/config/integration/certs/client_ecdsacert_hash.h\"\n#include \"test/config/integration/certs/clientcert_hash.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/resources.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/strings/str_replace.h\"\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\n\nstd::string ConfigHelper::baseConfig() {\n  return fmt::format(R\"EOF(\nadmin:\n  access_log:\n  - name: envoy.access_loggers.file\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n      path: \"{}\"\n  address:\n    socket_address:\n      address: 127.0.0.1\n      port_value: 0\ndynamic_resources:\n  lds_config:\n    resource_api_version: V3\n    path_config_source:\n      path: {}\nstatic_resources:\n  secrets:\n  - name: \"secret_static_0\"\n    tls_certificate:\n      certificate_chain:\n        inline_string: \"DUMMY_INLINE_BYTES\"\n      private_key:\n        inline_string: \"DUMMY_INLINE_BYTES\"\n      password:\n        inline_string: \"DUMMY_INLINE_BYTES\"\n  clusters:\n    name: cluster_0\n    load_assignment:\n      cluster_name: cluster_0\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 0\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        address: 127.0.0.1\n        port_value: 0\n)EOF\",\n                     Platform::null_device_path, Platform::null_device_path);\n}\n\nstd::string ConfigHelper::baseUdpListenerConfig(std::string listen_address) {\n  return fmt::format(R\"EOF(\nadmin:\n  access_log:\n  - name: envoy.access_loggers.file\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n      path: \"{}\"\n  address:\n    socket_address:\n      address: 127.0.0.1\n      port_value: 0\nstatic_resources:\n  clusters:\n    name: cluster_0\n    load_assignment:\n      cluster_name: cluster_0\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 0\n  listeners:\n    name: listener_0\n    address:\n      socket_address:\n        address: {}\n        port_value: 0\n        protocol: udp\n)EOF\",\n                     Platform::null_device_path, listen_address);\n}\n\nstd::string ConfigHelper::tcpProxyConfig() {\n  return absl::StrCat(baseConfig(), R\"EOF(\n    filter_chains:\n      filters:\n        name: tcp\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\n          stat_prefix: tcp_stats\n          cluster: cluster_0\n)EOF\");\n}\n\nstd::string ConfigHelper::startTlsConfig() {\n  return absl::StrCat(\n      tcpProxyConfig(),\n      fmt::format(R\"EOF(\n      transport_socket:\n        name: \"starttls\"\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.starttls.v3.StartTlsConfig\n          cleartext_socket_config:\n          tls_socket_config:\n            common_tls_context:\n              tls_certificates:\n                certificate_chain:\n                  filename: {}\n                private_key:\n                  filename: {}\n)EOF\",\n                  TestEnvironment::runfilesPath(\"test/config/integration/certs/servercert.pem\"),\n                  TestEnvironment::runfilesPath(\"test/config/integration/certs/serverkey.pem\")));\n}\n\nstd::string ConfigHelper::tlsInspectorFilter(bool enable_ja3_fingerprinting) {\n  if (!enable_ja3_fingerprinting) {\n    return R\"EOF(\nname: \"envoy.filters.listener.tls_inspector\"\ntyped_config:\n)EOF\";\n  }\n\n  return R\"EOF(\nname: \"envoy.filters.listener.tls_inspector\"\ntyped_config:\n  \"@type\": type.googleapis.com/envoy.extensions.filters.listener.tls_inspector.v3.TlsInspector\n  enable_ja3_fingerprinting: true\n)EOF\";\n}\n\nstd::string ConfigHelper::httpProxyConfig(bool downstream_use_quic) {\n  if (downstream_use_quic) {\n    return quicHttpProxyConfig();\n  }\n  return absl::StrCat(baseConfig(), fmt::format(R\"EOF(\n    filter_chains:\n      filters:\n        name: http\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          stat_prefix: config_test\n          delayed_close_timeout:\n            nanos: 10000000\n          http_filters:\n            name: envoy.filters.http.router\n          codec_type: HTTP1\n          access_log:\n            name: accesslog\n            filter:\n              not_health_check_filter:  {{}}\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n              path: {}\n          route_config:\n            virtual_hosts:\n              name: integration\n              routes:\n                route:\n                  cluster: cluster_0\n                match:\n                  prefix: \"/\"\n              domains: \"*\"\n            name: route_config_0\n)EOF\",\n                                                Platform::null_device_path));\n}\n\n// TODO(danzh): For better compatibility with HTTP integration test framework,\n// it's better to combine with HTTP_PROXY_CONFIG, and use config modifiers to\n// specify quic specific things.\nstd::string ConfigHelper::quicHttpProxyConfig() {\n  return absl::StrCat(baseUdpListenerConfig(\"127.0.0.1\"), fmt::format(R\"EOF(\n    filter_chains:\n      transport_socket:\n        name: envoy.transport_sockets.quic\n      filters:\n        name: http\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          stat_prefix: config_test\n          http_filters:\n            name: envoy.filters.http.router\n          codec_type: HTTP3\n          access_log:\n            name: file_access_log\n            filter:\n              not_health_check_filter:  {{}}\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n              path: {}\n          route_config:\n            virtual_hosts:\n              name: integration\n              routes:\n                route:\n                  cluster: cluster_0\n                match:\n                  prefix: \"/\"\n              domains: \"*\"\n            name: route_config_0\n    udp_listener_config:\n      quic_options: {{}}\n)EOF\",\n                                                                      Platform::null_device_path));\n}\n\nstd::string ConfigHelper::defaultBufferFilter() {\n  return R\"EOF(\nname: buffer\ntyped_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer\n    max_request_bytes : 5242880\n)EOF\";\n}\n\nstd::string ConfigHelper::smallBufferFilter() {\n  return R\"EOF(\nname: buffer\ntyped_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer\n    max_request_bytes : 1024\n)EOF\";\n}\n\nstd::string ConfigHelper::defaultHealthCheckFilter() {\n  return R\"EOF(\nname: health_check\ntyped_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.health_check.v3.HealthCheck\n    pass_through_mode: false\n)EOF\";\n}\n\nstd::string ConfigHelper::defaultSquashFilter() {\n  return R\"EOF(\nname: squash\ntyped_config:\n  \"@type\": type.googleapis.com/envoy.extensions.filters.http.squash.v3.Squash\n  cluster: squash\n  attachment_template:\n    spec:\n      attachment:\n        env: \"{{ SQUASH_ENV_TEST }}\"\n      match_request: true\n  attachment_timeout:\n    seconds: 1\n    nanos: 0\n  attachment_poll_period:\n    seconds: 2\n    nanos: 0\n  request_timeout:\n    seconds: 1\n    nanos: 0\n)EOF\";\n}\n\n// TODO(#6327) cleaner approach to testing with static config.\nstd::string ConfigHelper::discoveredClustersBootstrap(const std::string& api_type) {\n  return fmt::format(\n      R\"EOF(\nadmin:\n  access_log:\n  - name: envoy.access_loggers.file\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n      path: \"{}\"\n  address:\n    socket_address:\n      address: 127.0.0.1\n      port_value: 0\ndynamic_resources:\n  cds_config:\n    resource_api_version: V3\n    api_config_source:\n      api_type: {}\n      transport_api_version: V3\n      grpc_services:\n        envoy_grpc:\n          cluster_name: my_cds_cluster\n      set_node_on_first_message_only: true\nstatic_resources:\n  clusters:\n  - name: my_cds_cluster\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        explicit_http_config:\n          http2_protocol_options: {{}}\n    load_assignment:\n      cluster_name: my_cds_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 0\n  listeners:\n    name: http\n    address:\n      socket_address:\n        address: 127.0.0.1\n        port_value: 0\n    filter_chains:\n      filters:\n        name: http\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          stat_prefix: config_test\n          http_filters:\n            name: envoy.filters.http.router\n          codec_type: HTTP2\n          route_config:\n            name: route_config_0\n            validate_clusters: false\n            virtual_hosts:\n              name: integration\n              routes:\n              - route:\n                  cluster: cluster_1\n                match:\n                  prefix: \"/cluster1\"\n              - route:\n                  cluster: cluster_2\n                match:\n                  prefix: \"/cluster2\"\n              domains: \"*\"\n)EOF\",\n      Platform::null_device_path, api_type);\n}\n\n// TODO(#6327) cleaner approach to testing with static config.\nstd::string ConfigHelper::adsBootstrap(const std::string& api_type) {\n  // We use this to allow tests to default to having a single API version but override and make\n  // the transport/resource API version distinction when needed.\n  return fmt::format(R\"EOF(\ndynamic_resources:\n  lds_config:\n    resource_api_version: V3\n    ads: {{}}\n  cds_config:\n    resource_api_version: V3\n    ads: {{}}\n  ads_config:\n    transport_api_version: V3\n    api_type: {0}\n    set_node_on_first_message_only: true\nstatic_resources:\n  clusters:\n    name: dummy_cluster\n    connect_timeout:\n      seconds: 5\n    type: STATIC\n    load_assignment:\n      cluster_name: dummy_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: 127.0.0.1\n                port_value: 0\n    lb_policy: ROUND_ROBIN\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        explicit_http_config:\n          http2_protocol_options: {{}}\nadmin:\n  access_log:\n  - name: envoy.access_loggers.file\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n      path: \"{1}\"\n  address:\n    socket_address:\n      address: 127.0.0.1\n      port_value: 0\n)EOF\",\n                     api_type, Platform::null_device_path);\n}\n\n// TODO(samflattery): bundle this up with buildCluster\nenvoy::config::cluster::v3::Cluster ConfigHelper::buildStaticCluster(const std::string& name,\n                                                                     int port,\n                                                                     const std::string& address,\n                                                                     const std::string& lb_policy) {\n  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 5s\n      type: STATIC\n      load_assignment:\n        cluster_name: {}\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: {}\n                  port_value: {}\n      lb_policy: {}\n      typed_extension_protocol_options:\n        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n          \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n          explicit_http_config:\n            http2_protocol_options: {{}}\n    )EOF\",\n                  name, name, address, port, lb_policy));\n}\n\nenvoy::config::cluster::v3::Cluster ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits(\n    const std::string& name, int port, const std::string& address, const std::string& lb_policy) {\n  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 50s\n      type: STATIC\n      circuit_breakers:\n        thresholds:\n        - priority: DEFAULT\n          max_connections: 10000\n          max_pending_requests: 10000\n          max_requests: 10000\n          max_retries: 10000\n      load_assignment:\n        cluster_name: {}\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: {}\n                  port_value: {}\n      lb_policy: {}\n    )EOF\",\n                  name, name, address, port, lb_policy));\n}\n\nenvoy::config::cluster::v3::Cluster ConfigHelper::buildCluster(const std::string& name,\n                                                               const std::string& lb_policy) {\n  API_NO_BOOST(envoy::config::cluster::v3::Cluster) cluster;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 5s\n      type: EDS\n      eds_cluster_config:\n        eds_config:\n          resource_api_version: V3\n          ads: {{}}\n      lb_policy: {}\n      typed_extension_protocol_options:\n        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n          \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n          explicit_http_config:\n            http2_protocol_options: {{}}\n    )EOF\",\n                                        name, lb_policy),\n                            cluster);\n  return cluster;\n}\n\nenvoy::config::cluster::v3::Cluster ConfigHelper::buildTlsCluster(const std::string& name,\n                                                                  const std::string& lb_policy) {\n  API_NO_BOOST(envoy::config::cluster::v3::Cluster) cluster;\n  TestUtility::loadFromYaml(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 5s\n      type: EDS\n      eds_cluster_config:\n        eds_config:\n          resource_api_version: V3\n          ads: {{}}\n      transport_socket:\n        name: envoy.transport_sockets.tls\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n          common_tls_context:\n            validation_context:\n              trusted_ca:\n                filename: {}\n      lb_policy: {}\n      typed_extension_protocol_options:\n        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n          \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n          explicit_http_config:\n            http2_protocol_options: {{}}\n    )EOF\",\n                  name,\n                  TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"),\n                  lb_policy),\n      cluster);\n  return cluster;\n}\n\nenvoy::config::endpoint::v3::ClusterLoadAssignment\nConfigHelper::buildClusterLoadAssignment(const std::string& name, const std::string& address,\n                                         uint32_t port) {\n  API_NO_BOOST(envoy::config::endpoint::v3::ClusterLoadAssignment) cluster_load_assignment;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      cluster_name: {}\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: {}\n                port_value: {}\n    )EOF\",\n                                        name, address, port),\n                            cluster_load_assignment);\n  return cluster_load_assignment;\n}\n\nenvoy::config::endpoint::v3::ClusterLoadAssignment\nConfigHelper::buildClusterLoadAssignmentWithLeds(const std::string& name,\n                                                 const std::string& leds_collection_name) {\n  API_NO_BOOST(envoy::config::endpoint::v3::ClusterLoadAssignment) cluster_load_assignment;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      cluster_name: {}\n      endpoints:\n        leds_cluster_locality_config:\n          leds_config:\n            resource_api_version: V3\n            ads: {{}}\n          leds_collection_name: {}\n    )EOF\",\n                                        name, leds_collection_name),\n                            cluster_load_assignment);\n  return cluster_load_assignment;\n}\n\nenvoy::config::endpoint::v3::LbEndpoint ConfigHelper::buildLbEndpoint(const std::string& address,\n                                                                      uint32_t port) {\n  API_NO_BOOST(envoy::config::endpoint::v3::LbEndpoint) lb_endpoint;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      endpoint:\n        address:\n          socket_address:\n            address: {}\n            port_value: {}\n    )EOF\",\n                                        address, port),\n                            lb_endpoint);\n  return lb_endpoint;\n}\n\nenvoy::config::listener::v3::Listener\nConfigHelper::buildBaseListener(const std::string& name, const std::string& address,\n                                const std::string& filter_chains) {\n  API_NO_BOOST(envoy::config::listener::v3::Listener) listener;\n  TestUtility::loadFromYaml(fmt::format(\n                                R\"EOF(\n      name: {}\n      address:\n        socket_address:\n          address: {}\n          port_value: 0\n      filter_chains:\n      {}\n    )EOF\",\n                                name, address, filter_chains),\n                            listener);\n  return listener;\n}\n\nenvoy::config::listener::v3::Listener ConfigHelper::buildListener(const std::string& name,\n                                                                  const std::string& route_config,\n                                                                  const std::string& address,\n                                                                  const std::string& stat_prefix) {\n  std::string hcm = fmt::format(\n      R\"EOF(\n        filters:\n        - name: http\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n            stat_prefix: {}\n            codec_type: HTTP2\n            rds:\n              route_config_name: {}\n              config_source:\n                resource_api_version: V3\n                ads: {{}}\n            http_filters: [{{ name: envoy.filters.http.router }}]\n    )EOF\",\n      stat_prefix, route_config);\n  return buildBaseListener(name, address, hcm);\n}\n\nenvoy::config::route::v3::RouteConfiguration\nConfigHelper::buildRouteConfig(const std::string& name, const std::string& cluster) {\n  API_NO_BOOST(envoy::config::route::v3::RouteConfiguration) route;\n  TestUtility::loadFromYaml(fmt::format(R\"EOF(\n      name: \"{}\"\n      virtual_hosts:\n      - name: integration\n        domains: [\"*\"]\n        routes:\n        - match: {{ prefix: \"/\" }}\n          route: {{ cluster: \"{}\" }}\n    )EOF\",\n                                        name, cluster),\n                            route);\n  return route;\n}\n\nenvoy::config::endpoint::v3::Endpoint ConfigHelper::buildEndpoint(const std::string& address) {\n  envoy::config::endpoint::v3::Endpoint endpoint;\n  endpoint.mutable_address()->mutable_socket_address()->set_address(address);\n  return endpoint;\n}\n\nConfigHelper::ConfigHelper(const Network::Address::IpVersion version, Api::Api& api,\n                           const std::string& config) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  std::string filename = TestEnvironment::writeStringToFileForTest(\"basic_config.yaml\", config);\n  TestUtility::loadFromFile(filename, bootstrap_, api);\n\n  // Fix up all the socket addresses with the correct version.\n  auto* admin = bootstrap_.mutable_admin();\n  auto* admin_socket_addr = admin->mutable_address()->mutable_socket_address();\n  admin_socket_addr->set_address(Network::Test::getLoopbackAddressString(version));\n\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < static_resources->listeners_size(); ++i) {\n    auto* listener = static_resources->mutable_listeners(i);\n    if (listener->mutable_address()->has_envoy_internal_address()) {\n      ENVOY_LOG_MISC(\n          debug, \"Listener {} has internal address {}. Will not reset to loop back socket address.\",\n          i, listener->mutable_address()->envoy_internal_address().server_listener_name());\n      continue;\n    }\n    if (listener->mutable_address()->has_pipe()) {\n      ENVOY_LOG_MISC(debug,\n                     \"Listener {} has pipe address {}. Will not reset to loop back socket address.\",\n                     i, listener->mutable_address()->pipe().path());\n      continue;\n    }\n    auto* listener_socket_addr = listener->mutable_address()->mutable_socket_address();\n    if (listener_socket_addr->address() == \"0.0.0.0\" || listener_socket_addr->address() == \"::\") {\n      listener_socket_addr->set_address(Network::Test::getAnyAddressString(version));\n    } else {\n      listener_socket_addr->set_address(Network::Test::getLoopbackAddressString(version));\n    }\n  }\n\n  for (int i = 0; i < static_resources->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    for (int j = 0; j < cluster->load_assignment().endpoints_size(); ++j) {\n      auto* locality_lb = cluster->mutable_load_assignment()->mutable_endpoints(j);\n      for (int k = 0; k < locality_lb->lb_endpoints_size(); ++k) {\n        auto* lb_endpoint = locality_lb->mutable_lb_endpoints(k);\n        if (lb_endpoint->endpoint().address().has_socket_address()) {\n          lb_endpoint->mutable_endpoint()->mutable_address()->mutable_socket_address()->set_address(\n              Network::Test::getLoopbackAddressString(version));\n        }\n      }\n    }\n  }\n\n  // Ensure we have a basic admin-capable runtime layer.\n  if (bootstrap_.mutable_layered_runtime()->layers_size() == 0) {\n    auto* static_layer = bootstrap_.mutable_layered_runtime()->add_layers();\n    static_layer->set_name(\"static_layer\");\n    static_layer->mutable_static_layer();\n    auto* admin_layer = bootstrap_.mutable_layered_runtime()->add_layers();\n    admin_layer->set_name(\"admin\");\n    admin_layer->mutable_admin_layer();\n  }\n}\n\nvoid ConfigHelper::addListenerTypedMetadata(absl::string_view key, ProtobufWkt::Any& packed_value) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  ASSERT_TRUE(static_resources->listeners_size() > 0);\n  auto* listener = static_resources->mutable_listeners(0);\n  auto* map = listener->mutable_metadata()->mutable_typed_filter_metadata();\n  (*map)[std::string(key)] = packed_value;\n};\n\nvoid ConfigHelper::addClusterFilterMetadata(absl::string_view metadata_yaml,\n                                            absl::string_view cluster_name) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  ProtobufWkt::Struct cluster_metadata;\n  TestUtility::loadFromYaml(std::string(metadata_yaml), cluster_metadata);\n\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < static_resources->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    if (cluster->name() != cluster_name) {\n      continue;\n    }\n    for (const auto& kvp : cluster_metadata.fields()) {\n      ASSERT_TRUE(kvp.second.kind_case() == ProtobufWkt::Value::KindCase::kStructValue);\n      cluster->mutable_metadata()->mutable_filter_metadata()->insert(\n          {kvp.first, kvp.second.struct_value()});\n    }\n    break;\n  }\n}\n\nvoid ConfigHelper::setConnectConfig(\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager& hcm,\n    bool terminate_connect, bool allow_post, bool http3) {\n  auto* route_config = hcm.mutable_route_config();\n  ASSERT_EQ(1, route_config->virtual_hosts_size());\n  auto* route = route_config->mutable_virtual_hosts(0)->mutable_routes(0);\n  auto* match = route->mutable_match();\n  match->Clear();\n\n  if (allow_post) {\n    match->set_prefix(\"/\");\n\n    auto* header = match->add_headers();\n    header->set_name(\":method\");\n    header->mutable_string_match()->set_exact(\"POST\");\n  } else {\n    match->mutable_connect_matcher();\n  }\n\n  if (terminate_connect) {\n    auto* upgrade = route->mutable_route()->add_upgrade_configs();\n    upgrade->set_upgrade_type(\"CONNECT\");\n    auto* config = upgrade->mutable_connect_config();\n    if (allow_post) {\n      config->set_allow_post(true);\n    }\n  }\n\n  hcm.add_upgrade_configs()->set_upgrade_type(\"CONNECT\");\n  hcm.mutable_http2_protocol_options()->set_allow_connect(true);\n  if (http3) {\n    hcm.mutable_http3_protocol_options()->set_allow_extended_connect(true);\n  }\n}\n\nvoid ConfigHelper::applyConfigModifiers() {\n  for (const auto& config_modifier : config_modifiers_) {\n    config_modifier(bootstrap_);\n  }\n  config_modifiers_.clear();\n}\n\nvoid ConfigHelper::configureUpstreamTls(\n    bool use_alpn, bool http3,\n    absl::optional<envoy::config::core::v3::AlternateProtocolsCacheOptions>\n        alternate_protocol_cache_config) {\n  addConfigModifier([use_alpn, http3, alternate_protocol_cache_config](\n                        envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n\n    ConfigHelper::HttpProtocolOptions protocol_options;\n    protocol_options.mutable_upstream_http_protocol_options()->set_auto_sni(true);\n    ConfigHelper::setProtocolOptions(*cluster, protocol_options);\n\n    if (use_alpn) {\n      ConfigHelper::HttpProtocolOptions new_protocol_options;\n\n      HttpProtocolOptions old_protocol_options =\n          MessageUtil::anyConvert<ConfigHelper::HttpProtocolOptions>(\n              (*cluster->mutable_typed_extension_protocol_options())\n                  [\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"]);\n      protocol_options.MergeFrom(old_protocol_options);\n\n      new_protocol_options = old_protocol_options;\n      new_protocol_options.clear_explicit_http_config();\n      new_protocol_options.mutable_auto_config();\n      if (old_protocol_options.explicit_http_config().has_http_protocol_options()) {\n        new_protocol_options.mutable_auto_config()->mutable_http_protocol_options()->MergeFrom(\n            old_protocol_options.explicit_http_config().http_protocol_options());\n      } else if (old_protocol_options.explicit_http_config().has_http2_protocol_options()) {\n        new_protocol_options.mutable_auto_config()->mutable_http2_protocol_options()->MergeFrom(\n            old_protocol_options.explicit_http_config().http2_protocol_options());\n      }\n      if (http3 || old_protocol_options.explicit_http_config().has_http3_protocol_options()) {\n        new_protocol_options.mutable_auto_config()->mutable_http3_protocol_options()->MergeFrom(\n            old_protocol_options.explicit_http_config().http3_protocol_options());\n      }\n      if (alternate_protocol_cache_config.has_value()) {\n        new_protocol_options.mutable_auto_config()\n            ->mutable_alternate_protocols_cache_options()\n            ->set_name(\"default_alternate_protocols_cache\");\n        new_protocol_options.mutable_auto_config()\n            ->mutable_alternate_protocols_cache_options()\n            ->CopyFrom(alternate_protocol_cache_config.value());\n      }\n      (*cluster->mutable_typed_extension_protocol_options())\n          [\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"]\n              .PackFrom(new_protocol_options);\n    }\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n    auto* validation_context =\n        tls_context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    // The test certs are for *.lyft.com, so make sure SNI matches.\n    tls_context.set_sni(\"foo.lyft.com\");\n    if (http3) {\n      envoy::extensions::transport_sockets::quic::v3::QuicUpstreamTransport quic_context;\n      quic_context.mutable_upstream_tls_context()->CopyFrom(tls_context);\n      cluster->mutable_transport_socket()->set_name(\"envoy.transport_sockets.quic\");\n      cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(quic_context);\n    } else {\n      cluster->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n      cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n    }\n  });\n}\n\nvoid ConfigHelper::addRuntimeOverride(const std::string& key, const std::string& value) {\n  auto* static_layer =\n      bootstrap_.mutable_layered_runtime()->mutable_layers(0)->mutable_static_layer();\n  (*static_layer->mutable_fields())[std::string(key)] = ValueUtil::stringValue(std::string(value));\n}\n\nvoid ConfigHelper::setProtocolOptions(envoy::config::cluster::v3::Cluster& cluster,\n                                      HttpProtocolOptions& protocol_options) {\n  if (cluster.typed_extension_protocol_options().contains(\n          \"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\")) {\n    HttpProtocolOptions old_options = MessageUtil::anyConvert<ConfigHelper::HttpProtocolOptions>(\n        (*cluster.mutable_typed_extension_protocol_options())\n            [\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"]);\n    old_options.MergeFrom(protocol_options);\n    protocol_options.CopyFrom(old_options);\n  }\n  (*cluster.mutable_typed_extension_protocol_options())\n      [\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\"]\n          .PackFrom(protocol_options);\n}\n\nvoid ConfigHelper::setHttp2(envoy::config::cluster::v3::Cluster& cluster) {\n  HttpProtocolOptions protocol_options;\n  protocol_options.mutable_explicit_http_config()->mutable_http2_protocol_options();\n  setProtocolOptions(cluster, protocol_options);\n}\n\nvoid ConfigHelper::finalize(const std::vector<uint32_t>& ports) {\n  RELEASE_ASSERT(!finalized_, \"\");\n\n  applyConfigModifiers();\n\n  setPorts(ports);\n\n  if (!connect_timeout_set_) {\n#ifdef __APPLE__\n    // Set a high default connect timeout. Under heavy load (and in particular in CI), macOS\n    // connections can take inordinately long to complete.\n    setConnectTimeout(std::chrono::seconds(30));\n#else\n    // Set a default connect timeout.\n    setConnectTimeout(std::chrono::seconds(5));\n#endif\n  }\n\n  finalized_ = true;\n}\n\nvoid ConfigHelper::setPorts(const std::vector<uint32_t>& ports, bool override_port_zero) {\n  uint32_t port_idx = 0;\n  bool eds_hosts = false;\n  bool custom_cluster = false;\n  bool original_dst_cluster = false;\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < bootstrap_.mutable_static_resources()->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    if (cluster->type() == envoy::config::cluster::v3::Cluster::EDS) {\n      eds_hosts = true;\n    } else if (cluster->type() == envoy::config::cluster::v3::Cluster::ORIGINAL_DST) {\n      original_dst_cluster = true;\n    } else if (cluster->has_cluster_type()) {\n      custom_cluster = true;\n    } else {\n      // Assign ports to statically defined load_assignment hosts.\n      for (int j = 0; j < cluster->load_assignment().endpoints_size(); ++j) {\n        auto locality_lb = cluster->mutable_load_assignment()->mutable_endpoints(j);\n        for (int k = 0; k < locality_lb->lb_endpoints_size(); ++k) {\n          auto lb_endpoint = locality_lb->mutable_lb_endpoints(k);\n          if (lb_endpoint->endpoint().address().has_socket_address()) {\n            if (lb_endpoint->endpoint().address().socket_address().port_value() == 0 ||\n                override_port_zero) {\n              RELEASE_ASSERT(ports.size() > port_idx, \"\");\n              lb_endpoint->mutable_endpoint()\n                  ->mutable_address()\n                  ->mutable_socket_address()\n                  ->set_port_value(ports[port_idx++]);\n            } else {\n              ENVOY_LOG_MISC(debug, \"Not overriding preset port\",\n                             lb_endpoint->endpoint().address().socket_address().port_value());\n            }\n          }\n        }\n      }\n    }\n  }\n  ASSERT(skip_port_usage_validation_ || port_idx == ports.size() || eds_hosts ||\n         original_dst_cluster || custom_cluster || bootstrap_.dynamic_resources().has_cds_config());\n}\n\nvoid ConfigHelper::setSourceAddress(const std::string& address_string) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  bootstrap_.mutable_cluster_manager()\n      ->mutable_upstream_bind_config()\n      ->mutable_source_address()\n      ->set_address(address_string);\n  // We don't have the ability to bind to specific ports yet.\n  bootstrap_.mutable_cluster_manager()\n      ->mutable_upstream_bind_config()\n      ->mutable_source_address()\n      ->set_port_value(0);\n}\n\nvoid ConfigHelper::setDefaultHostAndRoute(const std::string& domains, const std::string& prefix) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n\n  auto* virtual_host = hcm_config.mutable_route_config()->mutable_virtual_hosts(0);\n  virtual_host->set_domains(0, domains);\n  virtual_host->mutable_routes(0)->mutable_match()->set_prefix(prefix);\n\n  storeHttpConnectionManager(hcm_config);\n}\n\nvoid ConfigHelper::setBufferLimits(uint32_t upstream_buffer_limit,\n                                   uint32_t downstream_buffer_limit) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* listener = bootstrap_.mutable_static_resources()->mutable_listeners(0);\n  listener->mutable_per_connection_buffer_limit_bytes()->set_value(downstream_buffer_limit);\n  const uint32_t stream_buffer_size = std::max(\n      downstream_buffer_limit, Http2::Utility::OptionsLimits::MIN_INITIAL_STREAM_WINDOW_SIZE);\n  if (Network::Utility::protobufAddressSocketType(listener->address()) ==\n          Network::Socket::Type::Datagram &&\n      listener->udp_listener_config().has_quic_options()) {\n    // QUIC stream's flow control window is configured in listener config.\n    listener->mutable_udp_listener_config()\n        ->mutable_quic_options()\n        ->mutable_quic_protocol_options()\n        ->mutable_initial_stream_window_size()\n        // The same as kStreamReceiveWindowLimit in QUICHE which only supports stream flow control\n        // window no larger than 16MB.\n        ->set_value(std::min(16u * 1024 * 1024, stream_buffer_size));\n  }\n\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < bootstrap_.mutable_static_resources()->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    cluster->mutable_per_connection_buffer_limit_bytes()->set_value(upstream_buffer_limit);\n  }\n\n  auto filter = getFilterFromListener(\"http\");\n  if (filter) {\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n        hcm_config;\n    loadHttpConnectionManager(hcm_config);\n    if (hcm_config.codec_type() == envoy::extensions::filters::network::http_connection_manager::\n                                       v3::HttpConnectionManager::HTTP2) {\n      auto* options = hcm_config.mutable_http2_protocol_options();\n      options->mutable_initial_stream_window_size()->set_value(stream_buffer_size);\n      storeHttpConnectionManager(hcm_config);\n    }\n  }\n}\n\nvoid ConfigHelper::setListenerSendBufLimits(uint32_t limit) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  RELEASE_ASSERT(bootstrap_.mutable_static_resources()->listeners_size() == 1, \"\");\n  auto* listener = bootstrap_.mutable_static_resources()->mutable_listeners(0);\n  auto* options = listener->add_socket_options();\n  options->set_description(\"SO_SNDBUF\");\n  options->set_level(SOL_SOCKET);\n  options->set_int_value(limit);\n  options->set_name(SO_SNDBUF);\n}\n\nvoid ConfigHelper::setDownstreamHttpIdleTimeout(std::chrono::milliseconds timeout) {\n  addConfigModifier(\n      [timeout](\n          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) {\n        hcm.mutable_common_http_protocol_options()->mutable_idle_timeout()->MergeFrom(\n            ProtobufUtil::TimeUtil::MillisecondsToDuration(timeout.count()));\n      });\n}\n\nvoid ConfigHelper::setDownstreamMaxConnectionDuration(std::chrono::milliseconds timeout) {\n  addConfigModifier(\n      [timeout](\n          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) {\n        hcm.mutable_common_http_protocol_options()->mutable_max_connection_duration()->MergeFrom(\n            ProtobufUtil::TimeUtil::MillisecondsToDuration(timeout.count()));\n      });\n}\n\nvoid ConfigHelper::setDownstreamMaxStreamDuration(std::chrono::milliseconds timeout) {\n  addConfigModifier(\n      [timeout](\n          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) {\n        hcm.mutable_common_http_protocol_options()->mutable_max_stream_duration()->MergeFrom(\n            ProtobufUtil::TimeUtil::MillisecondsToDuration(timeout.count()));\n      });\n}\n\nvoid ConfigHelper::setConnectTimeout(std::chrono::milliseconds timeout) {\n  RELEASE_ASSERT(!finalized_, \"\");\n\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  for (int i = 0; i < bootstrap_.mutable_static_resources()->clusters_size(); ++i) {\n    auto* cluster = static_resources->mutable_clusters(i);\n    cluster->mutable_connect_timeout()->MergeFrom(\n        ProtobufUtil::TimeUtil::MillisecondsToDuration(timeout.count()));\n  }\n  connect_timeout_set_ = true;\n}\n\nvoid ConfigHelper::setDownstreamMaxRequestsPerConnection(uint64_t max_requests_per_connection) {\n  addConfigModifier(\n      [max_requests_per_connection](\n          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) {\n        hcm.mutable_common_http_protocol_options()\n            ->mutable_max_requests_per_connection()\n            ->set_value(max_requests_per_connection);\n      });\n}\n\nenvoy::config::route::v3::VirtualHost\nConfigHelper::createVirtualHost(const char* domain, const char* prefix, const char* cluster) {\n  envoy::config::route::v3::VirtualHost virtual_host;\n  virtual_host.set_name(domain);\n  virtual_host.add_domains(domain);\n  virtual_host.add_routes()->mutable_match()->set_prefix(prefix);\n  auto* route = virtual_host.mutable_routes(0)->mutable_route();\n  route->set_cluster(cluster);\n  return virtual_host;\n}\n\nvoid ConfigHelper::addVirtualHost(const envoy::config::route::v3::VirtualHost& vhost) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n  auto route_config = hcm_config.mutable_route_config();\n  auto* virtual_host = route_config->add_virtual_hosts();\n  virtual_host->CopyFrom(vhost);\n  storeHttpConnectionManager(hcm_config);\n}\n\nvoid ConfigHelper::addFilter(const std::string& config) { prependFilter(config); }\n\nvoid ConfigHelper::prependFilter(const std::string& config) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n\n  auto* filter_list_back = hcm_config.add_http_filters();\n  TestUtility::loadFromYaml(config, *filter_list_back);\n\n  // Now move it to the front.\n  for (int i = hcm_config.http_filters_size() - 1; i > 0; --i) {\n    hcm_config.mutable_http_filters()->SwapElements(i, i - 1);\n  }\n  storeHttpConnectionManager(hcm_config);\n}\n\nvoid ConfigHelper::setClientCodec(envoy::extensions::filters::network::http_connection_manager::v3::\n                                      HttpConnectionManager::CodecType type) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  if (loadHttpConnectionManager(hcm_config)) {\n    hcm_config.set_codec_type(type);\n    storeHttpConnectionManager(hcm_config);\n  }\n}\n\nvoid ConfigHelper::configDownstreamTransportSocketWithTls(\n    envoy::config::bootstrap::v3::Bootstrap& bootstrap,\n    std::function<void(envoy::extensions::transport_sockets::tls::v3::CommonTlsContext&)>\n        configure_tls_context) {\n  for (auto& listener : *bootstrap.mutable_static_resources()->mutable_listeners()) {\n    ASSERT(listener.filter_chains_size() > 0);\n    auto* filter_chain = listener.mutable_filter_chains(0);\n    auto* transport_socket = filter_chain->mutable_transport_socket();\n    if (listener.has_udp_listener_config() && listener.udp_listener_config().has_quic_options()) {\n      transport_socket->set_name(\"envoy.transport_sockets.quic\");\n      envoy::extensions::transport_sockets::quic::v3::QuicDownstreamTransport\n          quic_transport_socket_config;\n      configure_tls_context(*quic_transport_socket_config.mutable_downstream_tls_context()\n                                 ->mutable_common_tls_context());\n      transport_socket->mutable_typed_config()->PackFrom(quic_transport_socket_config);\n    } else if (!listener.has_udp_listener_config()) {\n      transport_socket->set_name(\"envoy.transport_sockets.tls\");\n      envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n      configure_tls_context(*tls_context.mutable_common_tls_context());\n      transport_socket->mutable_typed_config()->PackFrom(tls_context);\n    }\n  }\n}\n\nvoid ConfigHelper::addSslConfig(const ServerSslOptions& options) {\n  RELEASE_ASSERT(!finalized_, \"\");\n\n  auto* filter_chain =\n      bootstrap_.mutable_static_resources()->mutable_listeners(0)->mutable_filter_chains(0);\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  initializeTls(options, *tls_context.mutable_common_tls_context());\n  if (options.ocsp_staple_required_) {\n    tls_context.set_ocsp_staple_policy(\n        envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext::MUST_STAPLE);\n  }\n  filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n  filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n}\n\nvoid ConfigHelper::addQuicDownstreamTransportSocketConfig() {\n  for (auto& listener : *bootstrap_.mutable_static_resources()->mutable_listeners()) {\n    if (listener.udp_listener_config().has_quic_options()) {\n      // Disable SO_REUSEPORT, because it undesirably allows parallel test jobs to use the same\n      // port.\n      listener.mutable_enable_reuse_port()->set_value(false);\n    }\n  }\n  configDownstreamTransportSocketWithTls(\n      bootstrap_,\n      [](envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& common_tls_context) {\n        initializeTls(ServerSslOptions().setRsaCert(true).setTlsV13(true), common_tls_context);\n      });\n}\n\nbool ConfigHelper::setAccessLog(\n    const std::string& filename, absl::string_view format,\n    std::vector<envoy::config::core::v3::TypedExtensionConfig> formatters) {\n  if (getFilterFromListener(\"http\") == nullptr) {\n    return false;\n  }\n  // Replace null device with a real path for the file access log.\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n  envoy::extensions::access_loggers::file::v3::FileAccessLog access_log_config;\n  if (!format.empty()) {\n    auto* log_format = access_log_config.mutable_log_format();\n    log_format->mutable_text_format_source()->set_inline_string(absl::StrCat(format, \"\\n\"));\n    if (!formatters.empty()) {\n      for (const auto& formatter : formatters) {\n        auto* added_formatter = log_format->add_formatters();\n        added_formatter->CopyFrom(formatter);\n      }\n    }\n  }\n  access_log_config.set_path(filename);\n  hcm_config.mutable_access_log(0)->mutable_typed_config()->PackFrom(access_log_config);\n  storeHttpConnectionManager(hcm_config);\n  return true;\n}\n\nbool ConfigHelper::setListenerAccessLog(const std::string& filename, absl::string_view format) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  if (bootstrap_.mutable_static_resources()->listeners_size() == 0) {\n    return false;\n  }\n  envoy::extensions::access_loggers::file::v3::FileAccessLog access_log_config;\n  if (!format.empty()) {\n    access_log_config.mutable_log_format()->mutable_text_format_source()->set_inline_string(\n        std::string(format));\n  }\n  access_log_config.set_path(filename);\n  bootstrap_.mutable_static_resources()\n      ->mutable_listeners(0)\n      ->add_access_log()\n      ->mutable_typed_config()\n      ->PackFrom(access_log_config);\n  return true;\n}\n\nvoid ConfigHelper::initializeTls(\n    const ServerSslOptions& options,\n    envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& common_tls_context) {\n  common_tls_context.add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n  common_tls_context.add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n\n  auto* validation_context = common_tls_context.mutable_validation_context();\n  if (options.custom_validator_config_) {\n    validation_context->set_allocated_custom_validator_config(options.custom_validator_config_);\n  } else {\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/cacert.pem\"));\n    validation_context->add_verify_certificate_hash(\n        options.expect_client_ecdsa_cert_ ? TEST_CLIENT_ECDSA_CERT_HASH : TEST_CLIENT_CERT_HASH);\n  }\n  validation_context->set_allow_expired_certificate(options.allow_expired_certificate_);\n\n  // We'll negotiate up to TLSv1.3 for the tests that care, but it really\n  // depends on what the client sets.\n  common_tls_context.mutable_tls_params()->set_tls_maximum_protocol_version(\n      options.tlsv1_3_ ? envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3\n                       : envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  if (options.rsa_cert_) {\n    auto* tls_certificate = common_tls_context.add_tls_certificates();\n    tls_certificate->mutable_certificate_chain()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/servercert.pem\"));\n    tls_certificate->mutable_private_key()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/serverkey.pem\"));\n    if (options.rsa_cert_ocsp_staple_) {\n      tls_certificate->mutable_ocsp_staple()->set_filename(\n          TestEnvironment::runfilesPath(\"test/config/integration/certs/server_ocsp_resp.der\"));\n    }\n  }\n  if (options.ecdsa_cert_) {\n    auto* tls_certificate = common_tls_context.add_tls_certificates();\n    tls_certificate->mutable_certificate_chain()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/server_ecdsacert.pem\"));\n    tls_certificate->mutable_private_key()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/server_ecdsakey.pem\"));\n    if (options.ecdsa_cert_ocsp_staple_) {\n      tls_certificate->mutable_ocsp_staple()->set_filename(TestEnvironment::runfilesPath(\n          \"test/config/integration/certs/server_ecdsa_ocsp_resp.der\"));\n    }\n  }\n  if (!options.san_matchers_.empty()) {\n    *validation_context->mutable_match_typed_subject_alt_names() = {options.san_matchers_.begin(),\n                                                                    options.san_matchers_.end()};\n  }\n}\n\nvoid ConfigHelper::renameListener(const std::string& name) {\n  auto* static_resources = bootstrap_.mutable_static_resources();\n  if (static_resources->listeners_size() > 0) {\n    static_resources->mutable_listeners(0)->set_name(name);\n  }\n}\n\nenvoy::config::listener::v3::Filter* ConfigHelper::getFilterFromListener(const std::string& name) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  if (bootstrap_.mutable_static_resources()->listeners_size() == 0) {\n    return nullptr;\n  }\n  auto* listener = bootstrap_.mutable_static_resources()->mutable_listeners(0);\n  if (listener->filter_chains_size() == 0) {\n    return nullptr;\n  }\n  auto* filter_chain = listener->mutable_filter_chains(0);\n  for (ssize_t i = 0; i < filter_chain->filters_size(); i++) {\n    if (filter_chain->mutable_filters(i)->name() == name) {\n      return filter_chain->mutable_filters(i);\n    }\n  }\n  return nullptr;\n}\n\nvoid ConfigHelper::addNetworkFilter(const std::string& filter_yaml) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* filter_chain =\n      bootstrap_.mutable_static_resources()->mutable_listeners(0)->mutable_filter_chains(0);\n  auto* filter_list_back = filter_chain->add_filters();\n  TestUtility::loadFromYaml(filter_yaml, *filter_list_back);\n\n  // Now move it to the front.\n  for (int i = filter_chain->filters_size() - 1; i > 0; --i) {\n    filter_chain->mutable_filters()->SwapElements(i, i - 1);\n  }\n}\n\nvoid ConfigHelper::addListenerFilter(const std::string& filter_yaml) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* listener = bootstrap_.mutable_static_resources()->mutable_listeners(0);\n  auto* filter_list_back = listener->add_listener_filters();\n  TestUtility::loadFromYaml(filter_yaml, *filter_list_back);\n\n  // Now move it to the front.\n  for (int i = listener->listener_filters_size() - 1; i > 0; --i) {\n    listener->mutable_listener_filters()->SwapElements(i, i - 1);\n  }\n}\n\nvoid ConfigHelper::addBootstrapExtension(const std::string& config) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  auto* extension = bootstrap_.add_bootstrap_extensions();\n  TestUtility::loadFromYaml(config, *extension);\n}\n\nbool ConfigHelper::loadHttpConnectionManager(\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager& hcm) {\n  return loadFilter<\n      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager>(\n      \"http\", hcm);\n}\n\nvoid ConfigHelper::storeHttpConnectionManager(\n    const envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n        hcm) {\n  return storeFilter<\n      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager>(\n      \"http\", hcm);\n}\n\nvoid ConfigHelper::addConfigModifier(ConfigModifierFunction function) {\n  RELEASE_ASSERT(!finalized_, \"\");\n  config_modifiers_.push_back(std::move(function));\n}\n\nvoid ConfigHelper::addConfigModifier(HttpModifierFunction function) {\n  addConfigModifier([function, this](envoy::config::bootstrap::v3::Bootstrap&) -> void {\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n        hcm_config;\n    if (!loadHttpConnectionManager(hcm_config)) {\n      return;\n    }\n    function(hcm_config);\n    storeHttpConnectionManager(hcm_config);\n  });\n}\n\nvoid ConfigHelper::setLds(absl::string_view version_info) {\n  applyConfigModifiers();\n\n  envoy::service::discovery::v3::DiscoveryResponse lds;\n  lds.set_version_info(std::string(version_info));\n  for (auto& listener : bootstrap_.static_resources().listeners()) {\n    ProtobufWkt::Any* resource = lds.add_resources();\n    resource->PackFrom(listener);\n  }\n\n  const std::string lds_filename =\n      bootstrap().dynamic_resources().lds_config().path_config_source().path();\n  std::string file = TestEnvironment::writeStringToFileForTest(\n      \"new_lds_file\", MessageUtil::getJsonStringFromMessageOrDie(lds));\n  TestEnvironment::renameFile(file, lds_filename);\n}\n\nvoid ConfigHelper::setDownstreamOutboundFramesLimits(uint32_t max_all_frames,\n                                                     uint32_t max_control_frames) {\n  auto filter = getFilterFromListener(\"http\");\n  if (filter) {\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n        hcm_config;\n    loadHttpConnectionManager(hcm_config);\n    if (hcm_config.codec_type() == envoy::extensions::filters::network::http_connection_manager::\n                                       v3::HttpConnectionManager::HTTP2) {\n      auto* options = hcm_config.mutable_http2_protocol_options();\n      options->mutable_max_outbound_frames()->set_value(max_all_frames);\n      options->mutable_max_outbound_control_frames()->set_value(max_control_frames);\n      storeHttpConnectionManager(hcm_config);\n    }\n  }\n}\n\nvoid ConfigHelper::setUpstreamOutboundFramesLimits(uint32_t max_all_frames,\n                                                   uint32_t max_control_frames) {\n  addConfigModifier(\n      [max_all_frames, max_control_frames](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n        ConfigHelper::HttpProtocolOptions protocol_options;\n        auto* http_protocol_options =\n            protocol_options.mutable_explicit_http_config()->mutable_http2_protocol_options();\n        http_protocol_options->mutable_max_outbound_frames()->set_value(max_all_frames);\n        http_protocol_options->mutable_max_outbound_control_frames()->set_value(max_control_frames);\n        ConfigHelper::setProtocolOptions(*bootstrap.mutable_static_resources()->mutable_clusters(0),\n                                         protocol_options);\n      });\n}\n\nvoid ConfigHelper::setLocalReply(\n    const envoy::extensions::filters::network::http_connection_manager::v3::LocalReplyConfig&\n        config) {\n  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager\n      hcm_config;\n  loadHttpConnectionManager(hcm_config);\n  hcm_config.mutable_local_reply_config()->MergeFrom(config);\n  storeHttpConnectionManager(hcm_config);\n}\n\nvoid ConfigHelper::adjustUpstreamTimeoutForTsan(\n    envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager& hcm) {\n  auto* route =\n      hcm.mutable_route_config()->mutable_virtual_hosts(0)->mutable_routes(0)->mutable_route();\n  uint64_t timeout_ms = PROTOBUF_GET_MS_OR_DEFAULT(*route, timeout, 15000u);\n  auto* timeout = route->mutable_timeout();\n  // QUIC stream processing is slow under TSAN. Use larger timeout to prevent\n  // upstream_response_timeout.\n  timeout->set_seconds(TSAN_TIMEOUT_FACTOR * timeout_ms / 1000);\n}\n\nenvoy::config::core::v3::Http3ProtocolOptions ConfigHelper::http2ToHttp3ProtocolOptions(\n    const envoy::config::core::v3::Http2ProtocolOptions& http2_options,\n    size_t http3_max_stream_receive_window) {\n  envoy::config::core::v3::Http3ProtocolOptions http3_options;\n  if (http2_options.has_initial_stream_window_size() &&\n      http2_options.initial_stream_window_size().value() < http3_max_stream_receive_window) {\n    // Set http3 stream flow control window only if the configured http2 stream flow control\n    // window is smaller than the upper limit of flow control window supported by QUICHE which is\n    // also the default for http3 streams.\n    http3_options.mutable_quic_protocol_options()->mutable_initial_stream_window_size()->set_value(\n        http2_options.initial_stream_window_size().value());\n  }\n  if (http2_options.has_override_stream_error_on_invalid_http_message()) {\n    http3_options.mutable_override_stream_error_on_invalid_http_message()->set_value(\n        http2_options.override_stream_error_on_invalid_http_message().value());\n  } else if (http2_options.stream_error_on_invalid_http_messaging()) {\n    http3_options.mutable_override_stream_error_on_invalid_http_message()->set_value(true);\n  }\n  return http3_options;\n}\n\nCdsHelper::CdsHelper() : cds_path_(TestEnvironment::writeStringToFileForTest(\"cds.pb_text\", \"\")) {}\n\nvoid CdsHelper::setCds(const std::vector<envoy::config::cluster::v3::Cluster>& clusters) {\n  // Write to file the DiscoveryResponse and trigger inotify watch.\n  envoy::service::discovery::v3::DiscoveryResponse cds_response;\n  cds_response.set_version_info(std::to_string(cds_version_++));\n  cds_response.set_type_url(Config::TypeUrl::get().Cluster);\n  for (const auto& cluster : clusters) {\n    cds_response.add_resources()->PackFrom(cluster);\n  }\n  // Past the initial write, need move semantics to trigger inotify move event that the\n  // FilesystemSubscriptionImpl is subscribed to.\n  std::string path =\n      TestEnvironment::writeStringToFileForTest(\"cds.update.pb_text\", cds_response.DebugString());\n  TestEnvironment::renameFile(path, cds_path_);\n}\n\nEdsHelper::EdsHelper() : eds_path_(TestEnvironment::writeStringToFileForTest(\"eds.pb_text\", \"\")) {\n  // cluster.cluster_0.update_success will be incremented on the initial\n  // load when Envoy comes up.\n  ++update_successes_;\n}\n\nvoid EdsHelper::setEds(const std::vector<envoy::config::endpoint::v3::ClusterLoadAssignment>&\n                           cluster_load_assignments) {\n  // Write to file the DiscoveryResponse and trigger inotify watch.\n  envoy::service::discovery::v3::DiscoveryResponse eds_response;\n  eds_response.set_version_info(std::to_string(eds_version_++));\n  eds_response.set_type_url(Config::TypeUrl::get().ClusterLoadAssignment);\n  for (const auto& cluster_load_assignment : cluster_load_assignments) {\n    eds_response.add_resources()->PackFrom(cluster_load_assignment);\n  }\n  // Past the initial write, need move semantics to trigger inotify move event that the\n  // FilesystemSubscriptionImpl is subscribed to.\n  std::string path =\n      TestEnvironment::writeStringToFileForTest(\"eds.update.pb_text\", eds_response.DebugString());\n  TestEnvironment::renameFile(path, eds_path_);\n}\n\nvoid EdsHelper::setEdsAndWait(\n    const std::vector<envoy::config::endpoint::v3::ClusterLoadAssignment>& cluster_load_assignments,\n    IntegrationTestServerStats& server_stats) {\n  // Make sure the last version has been accepted before setting a new one.\n  server_stats.waitForCounterGe(\"cluster.cluster_0.update_success\", update_successes_);\n  setEds(cluster_load_assignments);\n  // Make sure Envoy has consumed the update now that it is running.\n  ++update_successes_;\n  server_stats.waitForCounterGe(\"cluster.cluster_0.update_success\", update_successes_);\n  RELEASE_ASSERT(\n      update_successes_ == server_stats.counter(\"cluster.cluster_0.update_success\")->value(), \"\");\n}\n\n} // namespace Envoy\n", "#pragma once\n\n#include <chrono>\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"envoy/api/api.h\"\n#include \"envoy/config/bootstrap/v3/bootstrap.pb.h\"\n#include \"envoy/config/cluster/v3/cluster.pb.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/endpoint/v3/endpoint.pb.h\"\n#include \"envoy/config/listener/v3/listener_components.pb.h\"\n#include \"envoy/config/route/v3/route_components.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/common.pb.h\"\n#include \"envoy/extensions/upstreams/http/v3/http_protocol_options.pb.h\"\n#include \"envoy/http/codes.h\"\n\n#include \"source/common/config/api_version.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/protobuf/protobuf.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"test/integration/server_stats.h\"\n\n#include \"absl/types/optional.h\"\n\nnamespace Envoy {\n\nclass ConfigHelper {\npublic:\n  using HttpConnectionManager =\n      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager;\n  struct ServerSslOptions {\n    ServerSslOptions& setAllowExpiredCertificate(bool allow) {\n      allow_expired_certificate_ = allow;\n      return *this;\n    }\n\n    ServerSslOptions& setRsaCert(bool rsa_cert) {\n      rsa_cert_ = rsa_cert;\n      return *this;\n    }\n\n    ServerSslOptions& setRsaCertOcspStaple(bool rsa_cert_ocsp_staple) {\n      rsa_cert_ocsp_staple_ = rsa_cert_ocsp_staple;\n      return *this;\n    }\n\n    ServerSslOptions& setEcdsaCert(bool ecdsa_cert) {\n      ecdsa_cert_ = ecdsa_cert;\n      return *this;\n    }\n\n    ServerSslOptions& setEcdsaCertOcspStaple(bool ecdsa_cert_ocsp_staple) {\n      ecdsa_cert_ocsp_staple_ = ecdsa_cert_ocsp_staple;\n      return *this;\n    }\n\n    ServerSslOptions& setOcspStapleRequired(bool ocsp_staple_required) {\n      ocsp_staple_required_ = ocsp_staple_required;\n      return *this;\n    }\n\n    ServerSslOptions& setTlsV13(bool tlsv1_3) {\n      tlsv1_3_ = tlsv1_3;\n      return *this;\n    }\n\n    ServerSslOptions& setExpectClientEcdsaCert(bool expect_client_ecdsa_cert) {\n      expect_client_ecdsa_cert_ = expect_client_ecdsa_cert;\n      return *this;\n    }\n\n    ServerSslOptions& setCustomValidatorConfig(\n        envoy::config::core::v3::TypedExtensionConfig* custom_validator_config) {\n      custom_validator_config_ = custom_validator_config;\n      return *this;\n    }\n\n    ServerSslOptions&\n    setSanMatchers(std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>\n                       san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }\n\n    bool allow_expired_certificate_{};\n    envoy::config::core::v3::TypedExtensionConfig* custom_validator_config_;\n    bool rsa_cert_{true};\n    bool rsa_cert_ocsp_staple_{true};\n    bool ecdsa_cert_{false};\n    bool ecdsa_cert_ocsp_staple_{false};\n    bool ocsp_staple_required_{false};\n    bool tlsv1_3_{false};\n    bool expect_client_ecdsa_cert_{false};\n    std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>\n        san_matchers_{};\n  };\n\n  // Set up basic config, using the specified IpVersion for all connections: listeners, upstream,\n  // and admin connections.\n  //\n  // By default, this runs with an L7 proxy config, but config can be set to TCP_PROXY_CONFIG\n  // to test L4 proxying.\n  ConfigHelper(const Network::Address::IpVersion version, Api::Api& api,\n               const std::string& config = httpProxyConfig(false));\n\n  static void\n  initializeTls(const ServerSslOptions& options,\n                envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& common_context);\n\n  using ConfigModifierFunction = std::function<void(envoy::config::bootstrap::v3::Bootstrap&)>;\n  using HttpModifierFunction = std::function<void(HttpConnectionManager&)>;\n\n  // A basic configuration (admin port, cluster_0, one listener) with no network filters.\n  static std::string baseConfig();\n\n  // A basic configuration (admin port, cluster_0, one udp listener) with no network filters.\n  static std::string baseUdpListenerConfig(std::string listen_address = \"0.0.0.0\");\n\n  // A string for a tls inspector listener filter which can be used with addListenerFilter()\n  static std::string tlsInspectorFilter(bool enable_ja3_fingerprinting = false);\n\n  // A basic configuration for L4 proxying.\n  static std::string tcpProxyConfig();\n  // A basic configuration for L7 proxying.\n  static std::string httpProxyConfig(bool downstream_use_quic = false);\n  // A basic configuration for L7 proxying with QUIC transport.\n  static std::string quicHttpProxyConfig();\n  // A string for a basic buffer filter, which can be used with prependFilter()\n  static std::string defaultBufferFilter();\n  // A string for a small buffer filter, which can be used with prependFilter()\n  static std::string smallBufferFilter();\n  // A string for a health check filter which can be used with prependFilter()\n  static std::string defaultHealthCheckFilter();\n  // A string for a squash filter which can be used with prependFilter()\n  static std::string defaultSquashFilter();\n  // A string for startTls transport socket config.\n  static std::string startTlsConfig();\n  // A cluster that uses the startTls transport socket.\n  static envoy::config::cluster::v3::Cluster buildStartTlsCluster(const std::string& address,\n                                                                  int port);\n\n  // Configuration for L7 proxying, with clusters cluster_1 and cluster_2 meant to be added via CDS.\n  // api_type should be REST, GRPC, or DELTA_GRPC.\n  static std::string discoveredClustersBootstrap(const std::string& api_type);\n  static std::string adsBootstrap(const std::string& api_type);\n  // Builds a standard Cluster config fragment, with a single endpoint (at address:port).\n  static envoy::config::cluster::v3::Cluster\n  buildStaticCluster(const std::string& name, int port, const std::string& address,\n                     const std::string& lb_policy = \"ROUND_ROBIN\");\n\n  static envoy::config::cluster::v3::Cluster\n  buildH1ClusterWithHighCircuitBreakersLimits(const std::string& name, int port,\n                                              const std::string& address,\n                                              const std::string& lb_policy = \"ROUND_ROBIN\");\n\n  // ADS configurations\n  static envoy::config::cluster::v3::Cluster\n  buildCluster(const std::string& name, const std::string& lb_policy = \"ROUND_ROBIN\");\n\n  static envoy::config::cluster::v3::Cluster\n  buildTlsCluster(const std::string& name, const std::string& lb_policy = \"ROUND_ROBIN\");\n\n  static envoy::config::endpoint::v3::ClusterLoadAssignment\n  buildClusterLoadAssignment(const std::string& name, const std::string& ip_version, uint32_t port);\n\n  static envoy::config::endpoint::v3::ClusterLoadAssignment\n  buildClusterLoadAssignmentWithLeds(const std::string& name,\n                                     const std::string& leds_collection_name);\n\n  static envoy::config::endpoint::v3::LbEndpoint buildLbEndpoint(const std::string& address,\n                                                                 uint32_t port);\n\n  static envoy::config::listener::v3::Listener\n  buildBaseListener(const std::string& name, const std::string& address,\n                    const std::string& filter_chains = \"\");\n\n  static envoy::config::listener::v3::Listener buildListener(const std::string& name,\n                                                             const std::string& route_config,\n                                                             const std::string& address,\n                                                             const std::string& stat_prefix);\n\n  static envoy::config::route::v3::RouteConfiguration buildRouteConfig(const std::string& name,\n                                                                       const std::string& cluster);\n\n  // Builds a standard Endpoint suitable for population by finalize().\n  static envoy::config::endpoint::v3::Endpoint buildEndpoint(const std::string& address);\n\n  // Run the final config modifiers, and then set the upstream ports based on upstream connections.\n  // This is the last operation run on |bootstrap_| before it is handed to Envoy.\n  // Ports are assigned by looping through clusters, hosts, and addresses in the\n  // order they are stored in |bootstrap_|\n  void finalize(const std::vector<uint32_t>& ports);\n\n  // Called by finalize to set up the ports.\n  void setPorts(const std::vector<uint32_t>& ports, bool override_port_zero = false);\n\n  // Set source_address in the bootstrap bind config.\n  void setSourceAddress(const std::string& address_string);\n\n  // Overwrite the first host and route for the primary listener.\n  void setDefaultHostAndRoute(const std::string& host, const std::string& route);\n\n  // Sets byte limits on upstream and downstream connections.\n  void setBufferLimits(uint32_t upstream_buffer_limit, uint32_t downstream_buffer_limit);\n\n  // Sets a small kernel buffer for the listener send buffer\n  void setListenerSendBufLimits(uint32_t limit);\n\n  // Set the idle timeout on downstream connections through the HttpConnectionManager.\n  void setDownstreamHttpIdleTimeout(std::chrono::milliseconds idle_timeout);\n\n  // Set the max connection duration for downstream connections through the HttpConnectionManager.\n  void setDownstreamMaxConnectionDuration(std::chrono::milliseconds max_connection_duration);\n\n  // Set the max stream duration for downstream connections through the HttpConnectionManager.\n  void setDownstreamMaxStreamDuration(std::chrono::milliseconds max_stream_duration);\n\n  // Set the connect timeout on upstream connections.\n  void setConnectTimeout(std::chrono::milliseconds timeout);\n\n  // Set the max_requests_per_connection for downstream through the HttpConnectionManager.\n  void setDownstreamMaxRequestsPerConnection(uint64_t max_requests_per_connection);\n\n  envoy::config::route::v3::VirtualHost createVirtualHost(const char* host, const char* route = \"/\",\n                                                          const char* cluster = \"cluster_0\");\n\n  void addVirtualHost(const envoy::config::route::v3::VirtualHost& vhost);\n\n  // Add an HTTP filter prior to existing filters.\n  void prependFilter(const std::string& filter_yaml);\n\n  // Add an HTTP filter prior to existing filters.\n  // TODO(rgs1): remove once envoy-filter-example has been updated.\n  void addFilter(const std::string& filter_yaml);\n\n  // Add a network filter prior to existing filters.\n  void addNetworkFilter(const std::string& filter_yaml);\n\n  // Add a listener filter prior to existing filters.\n  void addListenerFilter(const std::string& filter_yaml);\n\n  // Add a new bootstrap extension.\n  void addBootstrapExtension(const std::string& config);\n\n  // Sets the client codec to the specified type.\n  void setClientCodec(envoy::extensions::filters::network::http_connection_manager::v3::\n                          HttpConnectionManager::CodecType type);\n\n  // Add TLS configuration for either SSL or QUIC transport socket according to listener config.\n  void configDownstreamTransportSocketWithTls(\n      envoy::config::bootstrap::v3::Bootstrap& bootstrap,\n      std::function<void(envoy::extensions::transport_sockets::tls::v3::CommonTlsContext&)>\n          configure_tls_context);\n\n  // Add the default SSL configuration.\n  void addSslConfig(const ServerSslOptions& options);\n  void addSslConfig() { addSslConfig({}); }\n\n  // Add the default SSL configuration for QUIC downstream.\n  void addQuicDownstreamTransportSocketConfig();\n\n  // Set the HTTP access log for the first HCM (if present) to a given file. The default is\n  // the platform's null device.\n  bool setAccessLog(const std::string& filename, absl::string_view format = \"\",\n                    std::vector<envoy::config::core::v3::TypedExtensionConfig> formatters = {});\n\n  // Set the listener access log for the first listener to a given file.\n  bool setListenerAccessLog(const std::string& filename, absl::string_view format = \"\");\n\n  // Renames the first listener to the name specified.\n  void renameListener(const std::string& name);\n\n  // Allows callers to do their own modification to |bootstrap_| which will be\n  // applied just before ports are modified in finalize().\n  void addConfigModifier(ConfigModifierFunction function);\n\n  // Allows callers to easily modify the HttpConnectionManager configuration.\n  // Modifiers will be applied just before ports are modified in finalize\n  void addConfigModifier(HttpModifierFunction function);\n\n  // Allows callers to easily modify the filter named 'name' from the first filter chain from the\n  // first listener. Modifiers will be applied just before ports are modified in finalize\n  template <class FilterType>\n  void addFilterConfigModifier(const std::string& name,\n                               std::function<void(Protobuf::Message& filter)> function) {\n    addConfigModifier([name, function, this](envoy::config::bootstrap::v3::Bootstrap&) -> void {\n      FilterType filter_config;\n      loadFilter<FilterType>(name, filter_config);\n      function(filter_config);\n      storeFilter<FilterType>(name, filter_config);\n    });\n  }\n\n  // Apply any outstanding config modifiers, stick all the listeners in a discovery response message\n  // and write it to the lds file.\n  void setLds(absl::string_view version_info);\n\n  // Set limits on pending downstream outbound frames.\n  void setDownstreamOutboundFramesLimits(uint32_t max_all_frames, uint32_t max_control_frames);\n\n  // Set limits on pending upstream outbound frames.\n  void setUpstreamOutboundFramesLimits(uint32_t max_all_frames, uint32_t max_control_frames);\n\n  // Return the bootstrap configuration for hand-off to Envoy.\n  const envoy::config::bootstrap::v3::Bootstrap& bootstrap() { return bootstrap_; }\n\n  // Allow a finalized configuration to be edited for generating xDS responses\n  void applyConfigModifiers();\n\n  // Configure Envoy to do TLS to upstream.\n  void configureUpstreamTls(bool use_alpn = false, bool http3 = false,\n                            absl::optional<envoy::config::core::v3::AlternateProtocolsCacheOptions>\n                                alternate_protocol_cache_config = {});\n\n  // Skip validation that ensures that all upstream ports are referenced by the\n  // configuration generated in ConfigHelper::finalize.\n  void skipPortUsageValidation() { skip_port_usage_validation_ = true; }\n\n  // Add this key value pair to the static runtime.\n  void addRuntimeOverride(const std::string& key, const std::string& value);\n\n  // Add typed_filter_metadata to the first listener.\n  void addListenerTypedMetadata(absl::string_view key, ProtobufWkt::Any& packed_value);\n\n  // Add filter_metadata to a cluster with the given name\n  void addClusterFilterMetadata(absl::string_view metadata_yaml,\n                                absl::string_view cluster_name = \"cluster_0\");\n\n  // Given an HCM with the default config, set the matcher to be a connect matcher and enable\n  // CONNECT requests.\n  static void setConnectConfig(HttpConnectionManager& hcm, bool terminate_connect, bool allow_post,\n                               bool http3 = false);\n\n  void setLocalReply(\n      const envoy::extensions::filters::network::http_connection_manager::v3::LocalReplyConfig&\n          config);\n\n  // Adjust the upstream route with larger timeout if running tsan. This is the duration between\n  // whole request being processed and whole response received.\n  static void adjustUpstreamTimeoutForTsan(\n      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager& hcm);\n\n  using HttpProtocolOptions = envoy::extensions::upstreams::http::v3::HttpProtocolOptions;\n  static void setProtocolOptions(envoy::config::cluster::v3::Cluster& cluster,\n                                 HttpProtocolOptions& protocol_options);\n  static void setHttp2(envoy::config::cluster::v3::Cluster& cluster);\n\n  // Populate and return a Http3ProtocolOptions instance based on http2_options.\n  static envoy::config::core::v3::Http3ProtocolOptions\n  http2ToHttp3ProtocolOptions(const envoy::config::core::v3::Http2ProtocolOptions& http2_options,\n                              size_t http3_max_stream_receive_window);\n\nprivate:\n  // Load the first HCM struct from the first listener into a parsed proto.\n  bool loadHttpConnectionManager(HttpConnectionManager& hcm);\n  // Take the contents of the provided HCM proto and stuff them into the first HCM\n  // struct of the first listener.\n  void storeHttpConnectionManager(const HttpConnectionManager& hcm);\n\n  // Load the first FilterType struct from the first listener into a parsed proto.\n  template <class FilterType> bool loadFilter(const std::string& name, FilterType& filter) {\n    RELEASE_ASSERT(!finalized_, \"\");\n    auto* filter_config = getFilterFromListener(name);\n    if (filter_config) {\n      auto* config = filter_config->mutable_typed_config();\n      filter = MessageUtil::anyConvert<FilterType>(*config);\n      return true;\n    }\n    return false;\n  }\n  // Take the contents of the provided FilterType proto and stuff them into the first FilterType\n  // struct of the first listener.\n  template <class FilterType> void storeFilter(const std::string& name, const FilterType& filter) {\n    RELEASE_ASSERT(!finalized_, \"\");\n    auto* filter_config_any = getFilterFromListener(name)->mutable_typed_config();\n\n    filter_config_any->PackFrom(filter);\n  }\n\n  // Finds the filter named 'name' from the first filter chain from the first listener.\n  envoy::config::listener::v3::Filter* getFilterFromListener(const std::string& name);\n\n  // The bootstrap proto Envoy will start up with.\n  envoy::config::bootstrap::v3::Bootstrap bootstrap_;\n\n  // The config modifiers added via addConfigModifier() which will be applied in finalize()\n  std::vector<ConfigModifierFunction> config_modifiers_;\n\n  // Track if the connect timeout has been set (to avoid clobbering a custom setting with the\n  // default).\n  bool connect_timeout_set_{false};\n\n  // Option to disable port usage validation for cases where the number of\n  // upstream ports created is expected to be larger than the number of\n  // upstreams in the config.\n  bool skip_port_usage_validation_{false};\n\n  // A sanity check guard to make sure config is not modified after handing it to Envoy.\n  bool finalized_{false};\n};\n\nclass CdsHelper {\npublic:\n  CdsHelper();\n\n  // Set CDS contents on filesystem.\n  void setCds(const std::vector<envoy::config::cluster::v3::Cluster>& cluster);\n  const std::string& cds_path() const { return cds_path_; }\n\nprivate:\n  const std::string cds_path_;\n  uint32_t cds_version_{};\n};\n\n// Common code for tests that deliver EDS update via the filesystem.\nclass EdsHelper {\npublic:\n  EdsHelper();\n\n  // Set EDS contents on filesystem and wait for Envoy to pick this up.\n  void setEds(const std::vector<envoy::config::endpoint::v3::ClusterLoadAssignment>&\n                  cluster_load_assignments);\n  void setEdsAndWait(const std::vector<envoy::config::endpoint::v3::ClusterLoadAssignment>&\n                         cluster_load_assignments,\n                     IntegrationTestServerStats& server_stats);\n  const std::string& eds_path() const { return eds_path_; }\n\nprivate:\n  const std::string eds_path_;\n  uint32_t eds_version_{};\n  uint32_t update_successes_{};\n};\n\n} // namespace Envoy\n", "load(\"@rules_python//python:defs.bzl\", \"py_binary\")\nload(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_fuzz_test\",\n    \"envoy_cc_test\",\n    \"envoy_cc_test_binary\",\n    \"envoy_cc_test_library\",\n    \"envoy_package\",\n    \"envoy_proto_library\",\n    \"envoy_select_enable_http3\",\n    \"envoy_select_hot_restart\",\n    \"envoy_sh_test\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_package()\n\nenvoy_cc_test_library(\n    name = \"ads_integration_lib\",\n    srcs = [\n        \"ads_integration.cc\",\n    ],\n    hdrs = [\n        \"ads_integration.h\",\n    ],\n    data = [\n        \"//test/config/integration:server_xds_files\",\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/common:matchers_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/protobuf:utility_lib\",\n        \"//source/common/version:version_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/admin/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"ads_integration_test\",\n    size = \"enormous\",\n    srcs = [\"ads_integration_test.cc\"],\n    deps = [\n        \":ads_integration_lib\",\n        \":http_integration_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/protobuf:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"alpn_integration_test\",\n    srcs = [\"alpn_integration_test.cc\"],\n    deps = [\":http_integration_lib\"],\n)\n\nenvoy_cc_test(\n    name = \"api_listener_integration_test\",\n    srcs = [\"api_listener_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/mocks/http:stream_encoder_mock\",\n        \"//test/server:utility_lib\",\n    ],\n)\n\npy_binary(\n    name = \"capture_fuzz_gen\",\n    srcs = [\"capture_fuzz_gen.py\"],\n    licenses = [\"notice\"],  # Apache 2\n    visibility = [\"//visibility:public\"],\n    deps = [\n        \":capture_fuzz_proto_py_proto\",\n        \"@envoy_api//envoy/data/tap/v2alpha:pkg_py_proto\",\n    ],\n)\n\nenvoy_proto_library(\n    name = \"capture_fuzz_proto\",\n    srcs = [\":capture_fuzz.proto\"],\n)\n\nenvoy_proto_library(\n    name = \"h2_capture_fuzz_proto\",\n    srcs = [\":h2_capture_fuzz.proto\"],\n)\n\nenvoy_cc_test(\n    name = \"cds_integration_test\",\n    size = \"large\",\n    srcs = [\"cds_integration_test.cc\"],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    shard_count = 4,\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/protobuf:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"eds_integration_test\",\n    srcs = [\"eds_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/upstream:load_balancer_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/integration/filters:eds_ready_filter_config_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"leds_integration_test\",\n    srcs = [\"leds_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_proto_library(\n    name = \"filter_manager_integration_proto\",\n    srcs = [\":filter_manager_integration_test.proto\"],\n)\n\nenvoy_cc_test(\n    name = \"filter_manager_integration_test\",\n    srcs = [\n        \"filter_manager_integration_test.cc\",\n    ],\n    deps = [\n        \":filter_manager_integration_proto_cc_proto\",\n        \":http_integration_lib\",\n        \":integration_lib\",\n        \"//source/extensions/filters/listener/tls_inspector:config\",\n        \"//source/extensions/filters/network/common:factory_base_lib\",\n        \"//source/extensions/filters/network/echo:config\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/server:utility_lib\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/access_loggers/file/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"cluster_filter_integration_test\",\n    srcs = [\"cluster_filter_integration_test.cc\"],\n    deps = [\n        \":integration_lib\",\n        \"//envoy/network:filter_interface\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:registry_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"custom_cluster_integration_test\",\n    srcs = [\"custom_cluster_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/upstream:load_balancer_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/integration/clusters:custom_static_cluster\",\n        \"//test/test_common:network_utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"vhds_integration_test\",\n    srcs = [\"vhds_integration_test.cc\"],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":vhds_lib\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"vhds_lib\",\n    srcs = [\"vhds.h\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/protobuf:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"drain_close_integration_test\",\n    srcs = [\n        \"drain_close_integration_test.cc\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nexports_files([\"test_utility.sh\"])\n\nenvoy_cc_test_binary(\n    name = \"hotrestart_main\",\n    srcs = [\"hotrestart_main.cc\"],\n    external_deps = [\n        \"abseil_symbolize\",\n    ],\n    stamped = True,\n    deps = [\n        \"//source/exe:envoy_main_common_with_core_extensions_lib\",\n        \"//source/exe:platform_impl_lib\",\n    ],\n)\n\nenvoy_sh_test(\n    name = \"hotrestart_test\",\n    size = \"enormous\",\n    srcs = envoy_select_hot_restart([\n        \"hotrestart_test.sh\",\n    ]),\n    cc_binary = [\":hotrestart_main\"],\n    data = [\n        \"test_utility.sh\",\n        \"//test/config/integration:server_config_files\",\n        \"//tools:socket_passing\",\n    ],\n    # Hot restart does not apply on Windows, skipping\n    tags = [\"skip_on_windows\"],\n)\n\nenvoy_sh_test(\n    name = \"run_envoy_test\",\n    srcs = [\"run_envoy_test.sh\"],\n    cc_binary = [\":hotrestart_main\"],\n    data = [\n        \"test_utility.sh\",\n        \"//test/config/integration:server_config_files\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"alpn_selection_integration_test\",\n    srcs = [\n        \"alpn_selection_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"header_integration_test\",\n    srcs = [\n        \"header_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/protobuf\",\n        \"//source/extensions/http/original_ip_detection/xff:config\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/api/v2:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/http/router/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http_conn_pool_integration_test\",\n    srcs = [\"http_conn_pool_integration_test.cc\"],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http2_flood_integration_test\",\n    srcs = [\n        \"http2_flood_integration_test.cc\",\n    ],\n    shard_count = 4,\n    deps = [\n        \":autonomous_upstream_lib\",\n        \":http_integration_lib\",\n        \":socket_interface_swap_lib\",\n        \":tracked_watermark_buffer_lib\",\n        \"//test/common/http/http2:http2_frame\",\n        \"//test/integration/filters:backpressure_filter_config_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/mocks/http:http_mocks\",\n        \"//test/test_common:test_runtime_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@com_google_absl//absl/synchronization\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"multiplexed_integration_test\",\n    srcs = [\n        \"multiplexed_integration_test.cc\",\n    ],\n    shard_count = 8,\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/integration/filters:metadata_stop_all_filter_config_lib\",\n        \"//test/integration/filters:on_local_reply_filter_config_lib\",\n        \"//test/integration/filters:request_metadata_filter_config_lib\",\n        \"//test/integration/filters:response_metadata_filter_config_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/integration/filters:stop_iteration_and_continue\",\n        \"//test/mocks/http:http_mocks\",\n        \"//test/mocks/upstream:retry_priority_factory_mocks\",\n        \"//test/mocks/upstream:retry_priority_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@com_google_absl//absl/synchronization\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"buffer_accounting_integration_test\",\n    srcs = [\n        \"buffer_accounting_integration_test.cc\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":base_overload_integration_test_lib\",\n        \":http_integration_lib\",\n        \":http_protocol_integration_lib\",\n        \":socket_interface_swap_lib\",\n        \":tracked_watermark_buffer_lib\",\n        \"//test/mocks/http:http_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"socket_interface_swap_lib\",\n    srcs = [\n        \"socket_interface_swap.cc\",\n    ],\n    hdrs = [\n        \"socket_interface_swap.h\",\n    ],\n    deps = [\n        \"//test/integration/filters:test_socket_interface_lib\",\n        \"@com_google_absl//absl/synchronization\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http_subset_lb_integration_test\",\n    srcs = [\n        \"http_subset_lb_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"transport_socket_match_integration_test\",\n    srcs = [\n        \"transport_socket_match_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"header_casing_integration_test\",\n    srcs = [\n        \"header_casing_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http_typed_per_filter_config_test\",\n    srcs = [\n        \"http_typed_per_filter_config_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"http_timeout_integration_test\",\n    srcs = [\n        \"http_timeout_integration_test.cc\",\n        \"http_timeout_integration_test.h\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"@envoy_api//envoy/extensions/filters/http/router/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"protocol_integration_test_lib\",\n    srcs = [\n        \"protocol_integration_test.cc\",\n        \"protocol_integration_test.h\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \":socket_interface_swap_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/common/http/http2:http2_frame\",\n        \"//test/integration/filters:add_invalid_data_filter_lib\",\n        \"//test/integration/filters:continue_after_local_reply_filter_lib\",\n        \"//test/integration/filters:continue_headers_only_inject_body\",\n        \"//test/integration/filters:encoder_decoder_buffer_filter_lib\",\n        \"//test/integration/filters:invalid_header_filter_lib\",\n        \"//test/integration/filters:local_reply_during_encoding_data_filter_lib\",\n        \"//test/integration/filters:local_reply_during_encoding_filter_lib\",\n        \"//test/integration/filters:local_reply_with_metadata_filter_lib\",\n        \"//test/integration/filters:random_pause_filter_lib\",\n        \"//test/integration/filters:remove_response_headers_lib\",\n        \"//test/integration/filters:stop_iteration_headers_inject_body\",\n        \"//test/test_common:logging_lib\",\n        \"//test/test_common:threadsafe_singleton_injector_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"protocol_integration_test\",\n    srcs = [\n        \"instantiate_protocol_integration_test.cc\",\n    ],\n    args = [\n        # for coverage, until this defaults true.\n        \"--runtime-feature-override-for-tests=envoy.reloadable_features.allow_upstream_inline_write\",\n    ],\n    # As this test has many H1/H2/v4/v6 tests it takes a while to run.\n    # Shard it enough to bring the run time in line with other integration tests.\n    shard_count = 10,\n    deps = [\n        \":protocol_integration_test_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"multiplexed_upstream_integration_test\",\n    srcs = [\n        \"multiplexed_upstream_integration_test.cc\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/integration/filters:encoder_decoder_buffer_filter_lib\",\n        \"//test/integration/filters:random_pause_filter_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"integration_admin_test\",\n    srcs = [\n        \"integration_admin_test.cc\",\n        \"integration_admin_test.h\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//envoy/http:header_map_interface\",\n        \"//source/common/stats:histogram_lib\",\n        \"//source/common/stats:stats_matcher_lib\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/common/stats:stat_test_utility_lib\",\n        \"@envoy_api//envoy/admin/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/metrics/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"test_host_predicate_lib\",\n    srcs = [\n        \"test_host_predicate.h\",\n        \"test_host_predicate_config.h\",\n    ],\n    deps = [\n        \"//envoy/upstream:retry_interface\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"http_integration_lib\",\n    srcs = [\n        \"http_integration.cc\",\n    ],\n    hdrs = [\n        \"http_integration.h\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":integration_lib\",\n        \":test_host_predicate_lib\",\n        \"//envoy/event:timer_interface\",\n        \"//source/common/common:thread_annotations\",\n        \"//source/common/network:socket_option_lib\",\n        \"//source/extensions/filters/http/router:config\",\n        \"//source/extensions/filters/network/http_connection_manager:config\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/common/http/http2:http2_frame\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/integration/filters:add_body_filter_config_lib\",\n        \"//test/integration/filters:add_trailers_filter_config_lib\",\n        \"//test/integration/filters:call_decodedata_once_filter_config_lib\",\n        \"//test/integration/filters:crash_filter_config_lib\",\n        \"//test/integration/filters:decode_headers_return_stop_all_filter_config_lib\",\n        \"//test/integration/filters:encode_headers_return_stop_all_filter_config_lib\",\n        \"//test/integration/filters:modify_buffer_filter_config_lib\",\n        \"//test/integration/filters:passthrough_filter_config_lib\",\n        \"//test/integration/filters:pause_filter_lib\",\n        \"//test/integration/filters:wait_for_whole_request_and_response_config_lib\",\n        \"//test/mocks/upstream:cluster_info_mocks\",\n        \"//test/test_common:registry_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"http_protocol_integration_lib\",\n    srcs = [\n        \"http_protocol_integration.cc\",\n    ],\n    hdrs = [\n        \"http_protocol_integration.h\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/integration/filters:stream_info_to_headers_filter_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"idle_timeout_integration_test\",\n    srcs = [\"idle_timeout_integration_test.cc\"],\n    # As this test has many pauses for idle timeouts, it takes a while to run.\n    # Shard it enough to bring the run time in line with other integration tests.\n    shard_count = 2,\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//test/integration/filters:backpressure_filter_config_lib\",\n        \"//test/integration/filters:reset_idle_timer_filter_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"integration_stream_decoder_lib\",\n    srcs = [\n        \"integration_stream_decoder.cc\",\n    ],\n    hdrs = [\n        \"integration_stream_decoder.h\",\n    ],\n    deps = [\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/http:codec_interface\",\n        \"//envoy/http:header_map_interface\",\n        \"//envoy/http:metadata_interface\",\n        \"//source/common/common:dump_state_utils\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"integration_tcp_client_lib\",\n    srcs = [\n        \"integration_tcp_client.cc\",\n    ],\n    hdrs = [\n        \"integration_tcp_client.h\",\n    ],\n    deps = [\n        \":utility_lib\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/network:address_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//envoy/network:socket_interface\",\n        \"//test/mocks/buffer:buffer_mocks\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"fake_upstream_lib\",\n    srcs = [\n        \"fake_upstream.cc\",\n    ],\n    hdrs = [\n        \"fake_upstream.h\",\n    ],\n    deps = [\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//source/server:listener_manager_lib\",\n        \"//envoy/api:api_interface\",\n        \"//envoy/grpc:status\",\n        \"//envoy/http:codec_interface\",\n        \"//envoy/network:connection_handler_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/buffer:zero_copy_input_stream_lib\",\n        \"//source/common/common:basic_resource_lib\",\n        \"//source/common/common:callback_impl_lib\",\n        \"//source/common/common:linked_object\",\n        \"//source/common/common:lock_guard_lib\",\n        \"//source/common/http/http3:codec_stats_lib\",\n        \"//source/common/common:thread_lib\",\n        \"//source/common/config:utility_lib\",\n        \"//source/common/grpc:codec_lib\",\n        \"//source/common/grpc:common_lib\",\n        \"//source/common/http/http1:codec_lib\",\n        \"//source/common/http/http2:codec_lib\",\n        \"//source/common/network:connection_balancer_lib\",\n        \"//source/common/network:filter_lib\",\n        \"//source/common/network:listen_socket_lib\",\n        \"//source/common/network:socket_option_factory_lib\",\n        \"//source/common/network:udp_packet_writer_handler_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/common/stats:isolated_store_lib\",\n        \"//source/server:active_raw_udp_listener_config\",\n        \"//source/server:connection_handler_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:test_time_system_interface\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n    ] + envoy_select_enable_http3([\n        \"//source/common/quic:active_quic_listener_lib\",\n        \"//source/common/quic:quic_factory_lib\",\n        \"@com_github_google_quiche//:quic_test_tools_session_peer_lib\",\n    ]),\n)\n\nenvoy_cc_test_library(\n    name = \"base_integration_test_lib\",\n    srcs = [\n        \"base_integration_test.cc\",\n    ],\n    hdrs = [\n        \"base_integration_test.h\",\n    ],\n    deps = [\n        \":autonomous_upstream_lib\",\n        \":fake_upstream_lib\",\n        \":integration_tcp_client_lib\",\n        \":utility_lib\",\n        \"//source/common/common:thread_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/extensions/network/dns_resolver/cares:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//source/extensions/transport_sockets/tls:ssl_socket_lib\",\n        \"//source/server:process_context_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/mocks/buffer:buffer_mocks\",\n        \"//test/mocks/server:transport_socket_factory_context_mocks\",\n        \"//test/test_common:environment_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:simulated_time_system_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"@envoy_api//envoy/admin/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ] + select({\n        \"//bazel:apple\": [\"//source/extensions/network/dns_resolver/apple:config\"],\n        \"//conditions:default\": [],\n    }),\n)\n\nenvoy_cc_test_library(\n    name = \"autonomous_upstream_lib\",\n    srcs = [\n        \"autonomous_upstream.cc\",\n    ],\n    hdrs = [\n        \"autonomous_upstream.h\",\n    ],\n    deps = [\n        \":fake_upstream_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"utility_lib\",\n    srcs = [\n        \"server.cc\",\n        \"ssl_utility.cc\",\n        \"utility.cc\",\n    ],\n    hdrs = [\n        \"server.h\",\n        \"ssl_utility.h\",\n        \"utility.h\",\n    ],\n    data = [\"//test/common/runtime:filesystem_test_data\"],\n    deps = [\n        \":server_stats_interface\",\n        \":tcp_dump\",\n        \"//envoy/api:api_interface\",\n        \"//envoy/http:codec_interface\",\n        \"//envoy/http:header_map_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/server:options_interface\",\n        \"//envoy/server:process_context_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//source/common/api:api_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:lock_guard_lib\",\n        \"//source/common/common:logger_lib\",\n        \"//source/common/common:random_generator_lib\",\n        \"//source/common/common:thread_lib\",\n        \"//source/common/common:utility_lib\",\n        \"//source/common/http:codec_client_lib\",\n        \"//source/common/http/http3:quic_client_connection_factory_lib\",\n        \"//source/common/json:json_loader_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/common/quic:quic_stat_names_lib\",\n        \"//source/common/stats:allocator_lib\",\n        \"//source/common/stats:isolated_store_lib\",\n        \"//source/common/thread_local:thread_local_lib\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//source/server:drain_manager_lib\",\n        \"//source/server:hot_restart_nop_lib\",\n        \"//source/server:listener_hooks_lib\",\n        \"//source/server:options_lib\",\n        \"//source/server:process_context_lib\",\n        \"//source/server:server_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/mocks:common_lib\",\n        \"//test/mocks/event:event_mocks\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/mocks/server:transport_socket_factory_context_mocks\",\n        \"//test/mocks/upstream:cluster_info_mocks\",\n        \"//test/test_common:environment_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:printers_lib\",\n        \"//test/test_common:simulated_time_system_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"//test/test_common:test_time_system_interface\",\n        \"//test/test_common:utility_lib\",\n        \"@com_google_absl//absl/synchronization\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"integration_lib\",\n    hdrs = [\n        \"integration.h\",\n    ],\n    deps = [\n        \":autonomous_upstream_lib\",\n        \":base_integration_test_lib\",\n        \":fake_upstream_lib\",\n        \":integration_stream_decoder_lib\",\n        \":integration_tcp_client_lib\",\n        \":utility_lib\",\n        \"//envoy/api:api_interface\",\n        \"//envoy/buffer:buffer_interface\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/grpc:status\",\n        \"//envoy/http:codec_interface\",\n        \"//envoy/http:header_map_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/server:configuration_interface\",\n        \"//envoy/server:hot_restart_interface\",\n        \"//envoy/server:options_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//envoy/thread:thread_interface\",\n        \"//source/common/api:api_lib\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/buffer:zero_copy_input_stream_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:basic_resource_lib\",\n        \"//source/common/common:minimal_logger_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/grpc:codec_lib\",\n        \"//source/common/grpc:common_lib\",\n        \"//source/common/http:codec_client_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/common/http:headers_lib\",\n        \"//source/common/http/http1:codec_lib\",\n        \"//source/common/http/http2:codec_lib\",\n        \"//source/common/local_info:local_info_lib\",\n        \"//source/common/network:filter_lib\",\n        \"//source/common/network:listen_socket_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/common/runtime:runtime_lib\",\n        \"//source/common/stats:isolated_store_lib\",\n        \"//source/common/stats:thread_local_store_lib\",\n        \"//source/common/thread_local:thread_local_lib\",\n        \"//source/common/upstream:upstream_includes\",\n        \"//source/common/upstream:upstream_lib\",\n        \"//source/extensions/access_loggers/file:config\",\n        \"//source/extensions/access_loggers/stream:config\",\n        \"//source/extensions/transport_sockets/raw_buffer:config\",\n        \"//source/server:connection_handler_lib\",\n        \"//source/server:drain_manager_lib\",\n        \"//source/server:hot_restart_nop_lib\",\n        \"//source/server:listener_hooks_lib\",\n        \"//source/server:process_context_lib\",\n        \"//source/server:server_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/mocks/buffer:buffer_mocks\",\n        \"//test/mocks/stats:stats_mocks\",\n        \"//test/mocks/upstream:retry_priority_factory_mocks\",\n        \"//test/mocks/upstream:retry_priority_mocks\",\n        \"//test/test_common:environment_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:printers_lib\",\n        \"//test/test_common:simulated_time_system_lib\",\n        \"//test/test_common:test_time_lib\",\n        \"//test/test_common:test_time_system_interface\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"integration_test\",\n    srcs = [\n        \"integration_test.cc\",\n        \"integration_test.h\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/common/http:headers_lib\",\n        \"//test/integration/filters:clear_route_cache_filter_lib\",\n        \"//test/integration/filters:encoder_decoder_buffer_filter_lib\",\n        \"//test/integration/filters:invalid_header_filter_lib\",\n        \"//test/integration/filters:process_context_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/integration/filters:set_route_filter_lib\",\n        \"//test/integration/filters:stop_iteration_and_continue\",\n        \"//test/mocks/http:http_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"redirect_integration_test\",\n    srcs = [\n        \"redirect_integration_test.cc\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"websocket_integration_test\",\n    srcs = [\n        \"websocket_integration_test.cc\",\n        \"websocket_integration_test.h\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/access_loggers/file:config\",\n        \"//source/extensions/filters/http/buffer:config\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"socket_interface_integration_test\",\n    srcs = [\"socket_interface_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/network:socket_interface_lib\",\n        \"//source/extensions/filters/network/echo:config\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"stats_integration_test\",\n    srcs = [\"stats_integration_test.cc\"],\n    # The symbol table cluster memory tests take a while to run specially under tsan.\n    # Shard it to avoid test timeout.\n    shard_count = 2,\n    deps = [\n        \":integration_lib\",\n        \"//source/common/memory:stats_lib\",\n        \"//source/extensions/filters/http/router:config\",\n        \"//source/extensions/filters/network/http_connection_manager:config\",\n        \"//test/common/stats:stat_test_utility_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"load_stats_integration_test\",\n    srcs = [\"load_stats_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/load_stats/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"hds_integration_test\",\n    srcs = [\"hds_integration_test.cc\"],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":http_integration_lib\",\n        \":integration_lib\",\n        \"//envoy/upstream:upstream_interface\",\n        \"//source/common/config:metadata_lib\",\n        \"//source/common/json:json_loader_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/common/upstream:health_checker_lib\",\n        \"//source/common/upstream:health_discovery_service_lib\",\n        \"//test/common/upstream:utility_lib\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/health/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"header_prefix_integration_test\",\n    srcs = [\"header_prefix_integration_test.cc\"],\n    coverage = False,\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"fake_resource_monitor_lib\",\n    srcs = [\n        \"fake_resource_monitor.cc\",\n    ],\n    hdrs = [\n        \"fake_resource_monitor.h\",\n    ],\n    deps = [\n        \"//envoy/server:resource_monitor_config_interface\",\n        \"//test/common/config:dummy_config_proto_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"base_overload_integration_test_lib\",\n    srcs = [\n        \"base_overload_integration_test.cc\",\n    ],\n    hdrs = [\n        \"base_overload_integration_test.h\",\n    ],\n    deps = [\n        \":fake_resource_monitor_lib\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/overload/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"overload_integration_test\",\n    srcs = [\"overload_integration_test.cc\"],\n    shard_count = 2,\n    deps = [\n        \":base_overload_integration_test_lib\",\n        \":http_protocol_integration_lib\",\n        \"//test/common/config:dummy_config_proto_cc_proto\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/overload/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"rtds_integration_test\",\n    srcs = [\"rtds_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"@envoy_api//envoy/service/runtime/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"extension_discovery_integration_test\",\n    srcs = [\"extension_discovery_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/integration/filters:set_is_terminal_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_is_terminal_filter_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/extensions/common/matching/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/extension/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"server_stats_interface\",\n    hdrs = [\"server_stats.h\"],\n    deps = [\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/stats:stats_interface\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"sds_static_integration_test\",\n    srcs = [\n        \"sds_static_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/mocks/secret:secret_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"sds_dynamic_integration_test\",\n    srcs = [\n        \"sds_dynamic_integration_test.cc\",\n    ],\n    data = [\n        \"sds_dynamic_key_rotation_setup.sh\",\n        \"//test/config/integration/certs\",\n    ],\n    # TODO(envoyproxy/windows-dev): The key rotation in SdsDynamicKeyRotationIntegrationTest via\n    # TestEnvironment::renameFile() fails on Windows. The renameFile() implementation does not\n    # correctly handle symlinks.\n    tags = [\n        \"fails_on_clang_cl\",\n        \"fails_on_windows\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/config:protobuf_link_hacks\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/extensions/transport_sockets/tls:test_private_key_method_provider_test_lib\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/mocks/secret:secret_mocks\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/secret/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"sds_generic_secret_integration_test\",\n    srcs = [\n        \"sds_generic_secret_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//envoy/registry\",\n        \"//source/common/grpc:common_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_proto_library(\n    name = \"tcp_proxy_integration_proto\",\n    srcs = [\":tcp_proxy_integration_test.proto\"],\n)\n\nenvoy_cc_test(\n    name = \"tcp_proxy_integration_test\",\n    srcs = [\n        \"tcp_proxy_integration_test.cc\",\n        \"tcp_proxy_integration_test.h\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    shard_count = 2,\n    deps = [\n        \":integration_lib\",\n        \":tcp_proxy_integration_proto_cc_proto\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/access_loggers/file:config\",\n        \"//source/extensions/filters/network/common:factory_base_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/mocks/secret:secret_mocks\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/filter/network/tcp_proxy/v2:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/access_loggers/file/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"tcp_tunneling_integration_test\",\n    size = \"large\",\n    srcs = [\n        \"tcp_tunneling_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    shard_count = 3,\n    deps = [\n        \":http_integration_lib\",\n        \":http_protocol_integration_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"tcp_conn_pool_integration_test\",\n    srcs = [\n        \"tcp_conn_pool_integration_test.cc\",\n    ],\n    deps = [\n        \":integration_lib\",\n        \"//envoy/server:filter_config_interface\",\n        \"//envoy/tcp:conn_pool_interface\",\n        \"//test/server:utility_lib\",\n        \"//test/test_common:registry_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"tcp_dump\",\n    srcs = [\"tcp_dump.cc\"],\n    hdrs = [\"tcp_dump.h\"],\n    deps = [\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:fmt_lib\",\n    ],\n)\n\nenvoy_cc_test_library(\n    name = \"tracked_watermark_buffer_lib\",\n    srcs = [\n        \"tracked_watermark_buffer.cc\",\n    ],\n    hdrs = [\n        \"tracked_watermark_buffer.h\",\n    ],\n    deps = [\n        \"//source/common/buffer:watermark_buffer_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/overload/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"tracked_watermark_buffer_test\",\n    srcs = [\"tracked_watermark_buffer_test.cc\"],\n    deps = [\n        \":tracked_watermark_buffer_lib\",\n        \"//test/mocks/http:stream_reset_handler_mock\",\n        \"//test/test_common:test_runtime_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"uds_integration_test\",\n    srcs = [\n        \"uds_integration_test.cc\",\n        \"uds_integration_test.h\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/http:codec_client_lib\",\n        \"//source/common/stats:stats_lib\",\n        \"//test/test_common:environment_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"version_integration_test\",\n    srcs = [\"version_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/extensions/filters/http/ip_tagging:config\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"dynamic_validation_integration_test\",\n    srcs = [\"dynamic_validation_integration_test.cc\"],\n    data = [\"//test/config/integration:server_xds_files\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/stats:stats_lib\",\n        \"//test/test_common:registry_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"xds_integration_test\",\n    srcs = [\"xds_integration_test.cc\"],\n    data = [\n        \"//test/config/integration:server_xds_files\",\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \":http_protocol_integration_lib\",\n        \"//source/extensions/filters/listener/tls_inspector:config\",\n        \"//source/extensions/filters/listener/tls_inspector:tls_inspector_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/test_common:environment_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"xfcc_integration_test\",\n    srcs = [\n        \"xfcc_integration_test.cc\",\n        \"xfcc_integration_test.h\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/http:header_map_lib\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//test/mocks/server:transport_socket_factory_context_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto\",\n    ],\n)\n\nH1_FUZZ_LIB_DEPS = [\n    \":capture_fuzz_proto_cc_proto\",\n    \":http_integration_lib\",\n    \"//source/common/common:assert_lib\",\n    \"//source/common/common:logger_lib\",\n    \"//test/fuzz:fuzz_runner_lib\",\n    \"//test/integration:integration_lib\",\n    \"//test/test_common:environment_lib\",\n]\n\nenvoy_cc_test_library(\n    name = \"h1_fuzz_lib\",\n    srcs = [\"h1_fuzz.cc\"],\n    hdrs = [\"h1_fuzz.h\"],\n    deps = H1_FUZZ_LIB_DEPS,\n)\n\nenvoy_cc_test_library(\n    name = \"h1_fuzz_persistent_lib\",\n    srcs = [\"h1_fuzz.cc\"],\n    hdrs = [\"h1_fuzz.h\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    deps = H1_FUZZ_LIB_DEPS,\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h1_capture_fuzz_test\",\n    srcs = [\"h1_capture_fuzz_test.cc\"],\n    corpus = \"h1_corpus\",\n    deps = [\":h1_fuzz_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h1_capture_persistent_fuzz_test\",\n    srcs = [\"h1_capture_fuzz_test.cc\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    corpus = \"h1_corpus\",\n    deps = [\":h1_fuzz_persistent_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h1_capture_direct_response_fuzz_test\",\n    srcs = [\"h1_capture_direct_response_fuzz_test.cc\"],\n    corpus = \"h1_corpus\",\n    deps = [\n        \":h1_fuzz_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h1_capture_direct_response_persistent_fuzz_test\",\n    srcs = [\"h1_capture_direct_response_fuzz_test.cc\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    corpus = \"h1_corpus\",\n    deps = [\n        \":h1_fuzz_persistent_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nH2_FUZZ_LIB_DEPS = [\n    \":h2_capture_fuzz_proto_cc_proto\",\n    \":http_integration_lib\",\n    \"//source/common/common:assert_lib\",\n    \"//source/common/common:logger_lib\",\n    \"//test/common/http/http2:http2_frame\",\n    \"//test/fuzz:fuzz_runner_lib\",\n    \"//test/fuzz:utility_lib\",\n    \"//test/integration:integration_lib\",\n    \"//test/test_common:environment_lib\",\n]\n\nenvoy_cc_test_library(\n    name = \"h2_fuzz_lib\",\n    srcs = [\"h2_fuzz.cc\"],\n    hdrs = [\"h2_fuzz.h\"],\n    deps = H2_FUZZ_LIB_DEPS,\n)\n\nenvoy_cc_test_library(\n    name = \"h2_fuzz_persistent_lib\",\n    srcs = [\"h2_fuzz.cc\"],\n    hdrs = [\"h2_fuzz.h\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    deps = H2_FUZZ_LIB_DEPS,\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_capture_fuzz_test\",\n    srcs = [\"h2_capture_fuzz_test.cc\"],\n    corpus = \"h2_corpus\",\n    deps = [\":h2_fuzz_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_wrapped_capture_fuzz_test\",\n    srcs = [\"h2_wrapped_capture_fuzz_test.cc\"],\n    corpus = \"h2_corpus\",\n    deps = [\":h2_fuzz_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_capture_persistent_fuzz_test\",\n    srcs = [\"h2_capture_fuzz_test.cc\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    corpus = \"h2_corpus\",\n    deps = [\":h2_fuzz_persistent_lib\"],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_capture_direct_response_fuzz_test\",\n    srcs = [\"h2_capture_direct_response_fuzz_test.cc\"],\n    corpus = \"h2_corpus\",\n    deps = [\n        \":h2_fuzz_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_fuzz_test(\n    name = \"h2_capture_direct_response_persistent_fuzz_test\",\n    srcs = [\"h2_capture_direct_response_fuzz_test.cc\"],\n    copts = [\"-DPERSISTENT_FUZZER\"],\n    corpus = \"h2_corpus\",\n    deps = [\n        \":h2_fuzz_persistent_lib\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"scoped_rds_lib\",\n    srcs = [\n        \"scoped_rds.h\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"scoped_rds_integration_test\",\n    srcs = [\n        \"scoped_rds_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \":scoped_rds_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"listener_lds_integration_test\",\n    srcs = [\n        \"listener_lds_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/integration/filters:address_restore_listener_filter_lib\",\n        \"//test/integration/filters:set_response_code_filter_config_proto_cc_proto\",\n        \"//test/integration/filters:set_response_code_filter_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"internal_listener_integration_test\",\n    srcs = [\n        \"internal_listener_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:connection_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/common/grpc:grpc_client_integration_lib\",\n        \"//test/config:v2_link_hacks\",\n        \"//test/integration/filters:address_restore_listener_filter_lib\",\n        \"//test/test_common:network_utility_lib\",\n        \"//test/test_common:resources_lib\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/service/discovery/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"listener_filter_integration_test\",\n    srcs = [\n        \"listener_filter_integration_test.cc\",\n    ],\n    data = [\n        \"//test/config/integration/certs\",\n    ],\n    deps = [\n        \":integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/event:dispatcher_lib\",\n        \"//source/common/network:utility_lib\",\n        \"//source/extensions/access_loggers/file:config\",\n        \"//source/extensions/filters/listener/tls_inspector:config\",\n        \"//source/extensions/filters/listener/tls_inspector:tls_inspector_lib\",\n        \"//source/extensions/filters/network/echo:config\",\n        \"//source/extensions/transport_sockets/tls:config\",\n        \"//source/extensions/transport_sockets/tls:context_config_lib\",\n        \"//source/extensions/transport_sockets/tls:context_lib\",\n        \"//test/mocks/runtime:runtime_mocks\",\n        \"//test/mocks/secret:secret_mocks\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/access_loggers/file/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"cx_limit_integration_test\",\n    srcs = [\"cx_limit_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/registry\",\n        \"//source/extensions/filters/network/tcp_proxy:config\",\n        \"//test/config:utility_lib\",\n        \"//test/test_common:logging_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"direct_response_integration_test\",\n    srcs = [\"direct_response_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"local_reply_integration_test\",\n    srcs = [\n        \"local_reply_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \":http_protocol_integration_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"command_formatter_extension_integration_test\",\n    srcs = [\n        \"command_formatter_extension_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//test/common/formatter:command_extension_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"health_check_integration_test\",\n    srcs = [\"health_check_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \":integration_lib\",\n        \"//test/common/http/http2:http2_frame\",\n        \"//test/config:v2_link_hacks\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"cluster_upstream_extension_integration_test\",\n    srcs = [\n        \"cluster_upstream_extension_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/common/config:api_version_lib\",\n        \"//source/common/protobuf\",\n        \"//test/integration/upstreams:per_host_upstream_config\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\n# TODO(mattklein123): Use target_compatible_with when we switch to Bazel 4.0 instead of multiple\n# selects.\nenvoy_cc_test(\n    name = \"quic_protocol_integration_test\",\n    size = \"large\",\n    srcs = envoy_select_enable_http3([\n        \"quic_protocol_integration_test.cc\",\n    ]),\n    args = [\n        # for coverage, until this defaults true.\n        \"--runtime-feature-override-for-tests=envoy.reloadable_features.allow_upstream_inline_write\",\n    ],\n    data = [\"//test/config/integration/certs\"],\n    shard_count = 8,\n    tags = [\n        \"nofips\",\n    ],\n    deps = envoy_select_enable_http3([\n        \":protocol_integration_test_lib\",\n        \"//source/common/quic:active_quic_listener_lib\",\n        \"//source/common/quic:client_connection_factory_lib\",\n        \"//source/common/quic:quic_factory_lib\",\n        \"//source/common/quic:quic_transport_socket_factory_lib\",\n        \"//test/integration/filters:pause_filter_for_quic_lib\",\n    ]),\n)\n\n# TODO(mattklein123): Use target_compatible_with when we switch to Bazel 4.0 instead of multiple\n# selects.\nenvoy_cc_test(\n    name = \"quic_http_integration_test\",\n    size = \"large\",\n    srcs = envoy_select_enable_http3([\"quic_http_integration_test.cc\"]),\n    data = [\"//test/config/integration/certs\"],\n    shard_count = 6,\n    # TODO(envoyproxy/windows-dev): Diagnose failure shown only on clang-cl build, see:\n    #   https://gist.github.com/wrowe/a152cb1d12c2f751916122aed39d8517\n    # TODO(envoyproxy/windows-dev): Diagnose timeout, why opt build test under Windows GCP RBE\n    # takes 10x as long as on linux (>300s vs ~30s). Shards = 2 solves for windows, see:\n    #   https://github.com/envoyproxy/envoy/pull/13713/files#r512160087\n    # Each of these tests exceeds 20s;\n    # QuicHttpIntegrationTests/QuicHttpIntegrationTest.MultipleQuicConnections[With|No]BPF*\n    tags = [\n        \"fails_on_clang_cl\",\n        \"fails_on_windows\",\n        \"nofips\",\n    ],\n    deps = envoy_select_enable_http3([\n        \":http_integration_lib\",\n        \"//source/common/quic:client_connection_factory_lib\",\n        \"//source/common/quic:envoy_quic_client_connection_lib\",\n        \"//source/common/quic:envoy_quic_client_session_lib\",\n        \"//source/common/quic:envoy_quic_connection_helper_lib\",\n        \"//source/common/quic:envoy_quic_proof_verifier_lib\",\n        \"//source/common/quic:quic_factory_lib\",\n        \"//test/common/quic:quic_test_utils_for_envoy_lib\",\n        \"//test/common/quic:test_utils_lib\",\n        \"//test/integration/filters:encoder_decoder_buffer_filter_lib\",\n        \"//test/test_common:test_runtime_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/overload/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto\",\n        \"@com_github_google_quiche//:quic_test_tools_session_peer_lib\",\n    ]),\n)\n\nenvoy_cc_test(\n    name = \"original_ip_detection_integration_test\",\n    srcs = [\n        \"original_ip_detection_integration_test.cc\",\n    ],\n    deps = [\n        \":http_integration_lib\",\n        \"//source/extensions/http/original_ip_detection/custom_header:config\",\n        \"//test/test_common:utility_lib\",\n        \"@envoy_api//envoy/extensions/http/original_ip_detection/custom_header/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"weighted_cluster_integration_test\",\n    srcs = [\"weighted_cluster_integration_test.cc\"],\n    deps = [\n        \":http_integration_lib\",\n        \":integration_lib\",\n        \"//test/integration/filters:repick_cluster_filter_lib\",\n        \"@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/config/route/v3:pkg_cc_proto\",\n        \"@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_test(\n    name = \"typed_metadata_integration_test\",\n    srcs = [\n        \"typed_metadata_integration_test.cc\",\n    ],\n    deps = [\n        \":http_protocol_integration_lib\",\n        \"//source/common/protobuf\",\n        \"//test/integration/filters:listener_typed_metadata_filter_lib\",\n        \"//test/server:utility_lib\",\n        \"//test/test_common:utility_lib\",\n    ],\n)\n", "#include \"envoy/config/cluster/v3/cluster.pb.h\"\n#include \"envoy/grpc/status.h\"\n#include \"envoy/service/discovery/v3/discovery.pb.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/config/protobuf_link_hacks.h\"\n#include \"source/common/protobuf/protobuf.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"test/common/grpc/grpc_client_integration.h\"\n#include \"test/config/v2_link_hacks.h\"\n#include \"test/integration/http_integration.h\"\n#include \"test/integration/utility.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/resources.h\"\n#include \"test/test_common/simulated_time_system.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/synchronization/notification.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::AssertionResult;\n\nnamespace Envoy {\nnamespace {\n\nconst char ClusterName1[] = \"cluster_1\";\nconst char ClusterName2[] = \"cluster_2\";\nconst int UpstreamIndex1 = 1;\nconst int UpstreamIndex2 = 2;\n\nclass CdsIntegrationTest : public Grpc::DeltaSotwIntegrationParamTest, public HttpIntegrationTest {\npublic:\n  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")),\n        cluster_creator_(&ConfigHelper::buildStaticCluster) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }\n\n  void TearDown() override {\n    if (!test_skipped_) {\n      cleanUpXdsConnection();\n    }\n  }\n\n  // Overridden to insert this stuff into the initialize() at the very beginning of\n  // HttpIntegrationTest::testRouterHeaderOnlyRequestAndResponse().\n  void initialize() override {\n    use_lds_ = false;\n    test_skipped_ = false;\n    // Controls how many addFakeUpstream() will happen in\n    // BaseIntegrationTest::createUpstreams() (which is part of initialize()).\n    // Make sure this number matches the size of the 'clusters' repeated field in the bootstrap\n    // config that you use!\n    setUpstreamCount(1);                         // the CDS cluster\n    setUpstreamProtocol(Http::CodecType::HTTP2); // CDS uses gRPC uses HTTP2.\n\n    // HttpIntegrationTest::initialize() does many things:\n    // 1) It appends to fake_upstreams_ as many as you asked for via setUpstreamCount().\n    // 2) It updates your bootstrap config with the ports your fake upstreams are actually listening\n    //    on (since you're supposed to leave them as 0).\n    // 3) It creates and starts an IntegrationTestServer - the thing that wraps the almost-actual\n    //    Envoy used in the tests.\n    // 4) Bringing up the server usually entails waiting to ensure that any listeners specified in\n    //    the bootstrap config have come up, and registering them in a port map (see lookupPort()).\n    //    However, this test needs to defer all of that to later.\n    defer_listener_finalization_ = true;\n    HttpIntegrationTest::initialize();\n\n    // Create the regular (i.e. not an xDS server) upstreams. We create them manually here after\n    // initialize() because finalize() expects all fake_upstreams_ to correspond to a static\n    // cluster in the bootstrap config - which we don't want since we're testing dynamic CDS!\n    addFakeUpstream(upstream_codec_type_);\n    addFakeUpstream(upstream_codec_type_);\n    cluster1_ = cluster_creator_(\n        ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()), \"ROUND_ROBIN\");\n    cluster2_ = cluster_creator_(\n        ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()), \"ROUND_ROBIN\");\n\n    // Let Envoy establish its connection to the CDS server.\n    acceptXdsConnection();\n\n    // Do the initial compareDiscoveryRequest / sendDiscoveryResponse for cluster_1.\n    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"\", {}, {}, {}, true));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                               {cluster1_}, {cluster1_}, {}, \"55\");\n\n    // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n    // the DiscoveryResponse describing cluster_1 that we sent.\n    // 2 because the statically specified CDS server itself counts as a cluster.\n    test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n\n    // Wait for our statically specified listener to become ready, and register its port in the\n    // test framework's downstream listener port map.\n    test_server_->waitUntilListenersReady();\n    registerTestServerPorts({\"http\"});\n  }\n\n  // Regression test to catch the code declaring a gRPC service method for {SotW,delta}\n  // when the user's bootstrap config asks for the other type.\n  void verifyGrpcServiceMethod() {\n    EXPECT_TRUE(xds_stream_->waitForHeadersComplete());\n    Envoy::Http::LowerCaseString path_string(\":path\");\n    std::string expected_method(\n        sotwOrDelta() == Grpc::SotwOrDelta::Sotw || sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n            ? \"/envoy.service.cluster.v3.ClusterDiscoveryService/StreamClusters\"\n            : \"/envoy.service.cluster.v3.ClusterDiscoveryService/DeltaClusters\");\n    EXPECT_EQ(xds_stream_->headers().get(path_string)[0]->value(), expected_method);\n  }\n\n  void acceptXdsConnection() {\n    AssertionResult result = // xds_connection_ is filled with the new FakeHttpConnection.\n        fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, xds_connection_);\n    RELEASE_ASSERT(result, result.message());\n    result = xds_connection_->waitForNewStream(*dispatcher_, xds_stream_);\n    RELEASE_ASSERT(result, result.message());\n    xds_stream_->startGrpcStream();\n    verifyGrpcServiceMethod();\n  }\n\n  envoy::config::cluster::v3::Cluster cluster1_;\n  envoy::config::cluster::v3::Cluster cluster2_;\n  // True if we decided not to run the test after all.\n  bool test_skipped_{true};\n  Http::CodecType upstream_codec_type_{Http::CodecType::HTTP2};\n  std::function<envoy::config::cluster::v3::Cluster(const std::string&, int, const std::string&,\n                                                    const std::string&)>\n      cluster_creator_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersionsClientTypeDelta, CdsIntegrationTest,\n                         DELTA_SOTW_GRPC_CLIENT_INTEGRATION_PARAMS);\n\n// 1) Envoy starts up with no static clusters (other than the CDS-over-gRPC server).\n// 2) Envoy is told of a cluster via CDS.\n// 3) We send Envoy a request, which we verify is properly proxied to and served by that cluster.\n// 4) Envoy is told that cluster is gone.\n// 5) We send Envoy a request, which should 503.\n// 6) Envoy is told that the cluster is back.\n// 7) We send Envoy a request, which we verify is properly proxied to and served by that cluster.\nTEST_P(CdsIntegrationTest, CdsClusterUpDownUp) {\n  // Calls our initialize(), which includes establishing a listener, route, and cluster.\n  config_helper_.addConfigModifier(configureProxyStatus());\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n\n  // Tell Envoy that cluster_1 is gone.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n                                                             {ClusterName1}, \"42\");\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse that says cluster_1 is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n\n  // Now that cluster_1 is gone, the listener (with its routing to cluster_1) should 503.\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/cluster1\", \"\", downstream_protocol_, version_, \"foo.com\");\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().getStatusValue());\n  EXPECT_EQ(response->headers().getProxyStatusValue(),\n            \"envoy; error=destination_unavailable; details=\\\"cluster_not_found; NC\\\"\");\n\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Tell Envoy that cluster_1 is back.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"42\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                             {cluster1_}, {cluster1_}, {}, \"413\");\n\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse describing cluster_1 that we sent. Again, 2 includes CDS server.\n  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n\n  // Does *not* call our initialize().\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n\n  cleanupUpstreamAndDownstream();\n}\n\n// Make sure that clusters won't create new connections on teardown.\nTEST_P(CdsIntegrationTest, CdsClusterTeardownWhileConnecting) {\n  initialize();\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n  test_server_->waitForCounterExists(\"cluster.cluster_1.upstream_cx_total\");\n  Stats::CounterSharedPtr cx_counter = test_server_->counter(\"cluster.cluster_1.upstream_cx_total\");\n  // Confirm no upstream connection is attempted so far.\n  EXPECT_EQ(0, cx_counter->value());\n\n  // Make the upstreams stop working, to ensure the connection was not\n  // established.\n  fake_upstreams_[1]->dispatcher()->exit();\n  fake_upstreams_[2]->dispatcher()->exit();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"GET\"}, {\":path\", \"/cluster1\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}});\n\n  // Tell Envoy that cluster_1 is gone.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n                                                             {ClusterName1}, \"42\");\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse that says cluster_1 is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n  codec_client_->sendReset(encoder_decoder.first);\n  cleanupUpstreamAndDownstream();\n\n  // Either 0 or 1 upstream connection is attempted but no more.\n  EXPECT_LE(cx_counter->value(), 1);\n}\n\n// Test the fast addition and removal of clusters when they use ThreadAwareLb.\nTEST_P(CdsIntegrationTest, CdsClusterWithThreadAwareLbCycleUpDownUp) {\n  // Calls our initialize(), which includes establishing a listener, route, and cluster.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n\n  // Tell Envoy that cluster_1 is gone.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n                                                             {ClusterName1}, \"42\");\n  // Make sure that Envoy's ClusterManager has made use of the DiscoveryResponse that says cluster_1\n  // is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n\n  // Update cluster1_ to use MAGLEV load balancer policy.\n  cluster1_ = ConfigHelper::buildStaticCluster(\n      ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n      Network::Test::getLoopbackAddressString(ipVersion()), \"MAGLEV\");\n\n  // Cyclically add and remove cluster with ThreadAwareLb.\n  for (int i = 42; i < 142; i += 2) {\n    EXPECT_TRUE(\n        compareDiscoveryRequest(Config::TypeUrl::get().Cluster, absl::StrCat(i), {}, {}, {}));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n        Config::TypeUrl::get().Cluster, {cluster1_}, {cluster1_}, {}, absl::StrCat(i + 1));\n    EXPECT_TRUE(\n        compareDiscoveryRequest(Config::TypeUrl::get().Cluster, absl::StrCat(i + 1), {}, {}, {}));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n        Config::TypeUrl::get().Cluster, {}, {}, {ClusterName1}, absl::StrCat(i + 2));\n  }\n\n  cleanupUpstreamAndDownstream();\n}\n\n// Tests adding a cluster, adding another, then removing the first.\nTEST_P(CdsIntegrationTest, TwoClusters) {\n  // Calls our initialize(), which includes establishing a listener, route, and cluster.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Tell Envoy that cluster_2 is here.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n      Config::TypeUrl::get().Cluster, {cluster1_, cluster2_}, {cluster2_}, {}, \"42\");\n  // The '3' includes the fake CDS server.\n  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 3);\n\n  // A request for cluster_2 should be fine.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex2, \"/cluster2\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Tell Envoy that cluster_1 is gone.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"42\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                             {cluster2_}, {}, {ClusterName1}, \"43\");\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse that says cluster_1 is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n\n  // Even with cluster_1 gone, a request for cluster_2 should be fine.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex2, \"/cluster2\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Tell Envoy that cluster_1 is back.\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"43\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(\n      Config::TypeUrl::get().Cluster, {cluster1_, cluster2_}, {cluster1_}, {}, \"413\");\n\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse describing cluster_1 that we sent. Again, 3 includes CDS server.\n  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 3);\n\n  // Does *not* call our initialize().\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n\n  cleanupUpstreamAndDownstream();\n}\n\n// Tests that when Envoy's delta xDS stream dis/reconnects, Envoy can inform the server of the\n// resources it already has: the reconnected stream need not start with a state-of-the-world update.\nTEST_P(CdsIntegrationTest, VersionsRememberedAfterReconnect) {\n  SKIP_IF_XDS_IS(Grpc::SotwOrDelta::Sotw);\n  SKIP_IF_XDS_IS(Grpc::SotwOrDelta::UnifiedSotw);\n\n  // Calls our initialize(), which includes establishing a listener, route, and cluster.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n\n  // Close the connection carrying Envoy's xDS gRPC stream...\n  AssertionResult result = xds_connection_->close();\n  RELEASE_ASSERT(result, result.message());\n  result = xds_connection_->waitForDisconnect();\n  RELEASE_ASSERT(result, result.message());\n  xds_connection_.reset();\n  // ...and reconnect it.\n  acceptXdsConnection();\n\n  // Upon reconnecting, the Envoy should tell us its current resource versions.\n  envoy::service::discovery::v3::DeltaDiscoveryRequest request;\n  result = xds_stream_->waitForGrpcMessage(*dispatcher_, request);\n  RELEASE_ASSERT(result, result.message());\n  const auto& initial_resource_versions = request.initial_resource_versions();\n  EXPECT_EQ(\"55\", initial_resource_versions.at(std::string(ClusterName1)));\n  EXPECT_EQ(1, initial_resource_versions.size());\n\n  // Tell Envoy that cluster_2 is here. This update does *not* need to include cluster_1,\n  // which Envoy should already know about despite the disconnect.\n  sendDeltaDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                                  {cluster2_}, {}, \"42\");\n  // The '3' includes the fake CDS server.\n  test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 3);\n\n  // A request for cluster_1 should be fine.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex1, \"/cluster1\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n  // A request for cluster_2 should be fine.\n  testRouterHeaderOnlyRequestAndResponse(nullptr, UpstreamIndex2, \"/cluster2\");\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n}\n\n// This test verifies that Envoy can delete a cluster with a lot of idle connections.\n// The original problem was recursive closure of idle connections that can run out\n// of stack when there are a lot of idle connections.\nTEST_P(CdsIntegrationTest, CdsClusterDownWithLotsOfIdleConnections) {\n  constexpr int num_requests = 2000;\n  // Make upstream H/1 so it creates connection for each request\n  upstream_codec_type_ = Http::CodecType::HTTP1;\n  // Relax default circuit breaker limits and timeouts so Envoy can accumulate a lot of idle\n  // connections\n  cluster_creator_ = &ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits;\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        hcm.mutable_route_config()\n            ->mutable_virtual_hosts(0)\n            ->mutable_routes(0)\n            ->mutable_route()\n            ->mutable_timeout()\n            ->set_seconds(600);\n        hcm.mutable_route_config()\n            ->mutable_virtual_hosts(0)\n            ->mutable_routes(0)\n            ->mutable_route()\n            ->mutable_idle_timeout()\n            ->set_seconds(600);\n      });\n  initialize();\n  std::vector<IntegrationStreamDecoderPtr> responses;\n  std::vector<FakeHttpConnectionPtr> upstream_connections;\n  std::vector<FakeStreamPtr> upstream_requests;\n  codec_client_ = makeHttpConnection(makeClientConnection((lookupPort(\"http\"))));\n  // The first loop establishes a lot of open connections with active requests to upstream\n  for (int i = 0; i < num_requests; ++i) {\n    Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n                                                   {\":path\", \"/cluster1\"},\n                                                   {\":scheme\", \"http\"},\n                                                   {\":authority\", \"host\"},\n                                                   {\"x-lyft-user-id\", absl::StrCat(i)}};\n\n    auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n    responses.push_back(std::move(response));\n\n    FakeHttpConnectionPtr fake_upstream_connection;\n    waitForNextUpstreamConnection({UpstreamIndex1}, TestUtility::DefaultTimeout,\n                                  fake_upstream_connection);\n    // Wait for the next stream on the upstream connection.\n    FakeStreamPtr upstream_request;\n    AssertionResult result =\n        fake_upstream_connection->waitForNewStream(*dispatcher_, upstream_request);\n    RELEASE_ASSERT(result, result.message());\n    // Wait for the stream to be completely received.\n    result = upstream_request->waitForEndStream(*dispatcher_);\n    RELEASE_ASSERT(result, result.message());\n    upstream_connections.push_back(std::move(fake_upstream_connection));\n    upstream_requests.push_back(std::move(upstream_request));\n  }\n\n  // This loop completes all requests making the all upstream connections idle\n  for (int i = 0; i < num_requests; ++i) {\n    // Send response headers, and end_stream if there is no response body.\n    upstream_requests[i]->encodeHeaders(default_response_headers_, true);\n    // Wait for the response to be read by the codec client.\n    RELEASE_ASSERT(responses[i]->waitForEndStream(), \"unexpected timeout\");\n    ASSERT_TRUE(responses[i]->complete());\n    EXPECT_EQ(\"200\", responses[i]->headers().getStatusValue());\n  }\n\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n\n  // Tell Envoy that cluster_1 is gone. Envoy will try to close all idle connections\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n                                                             {ClusterName1}, \"42\");\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse that says cluster_1 is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n\n  // If we made it this far then everything is ok.\n  for (int i = 0; i < num_requests; ++i) {\n    AssertionResult result = upstream_connections[i]->close();\n    RELEASE_ASSERT(result, result.message());\n    result = upstream_connections[i]->waitForDisconnect();\n    RELEASE_ASSERT(result, result.message());\n  }\n  upstream_connections.clear();\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n}\n\n// This test verifies that Envoy can delete a cluster with a lot of connections in the connecting\n// state and associated pending requests. The recursion guard in the\n// ConnPoolImplBase::closeIdleConnectionsForDrainingPool() would fire if it was called recursively.\n//\n// Test is currently disabled as there is presently no reliable way of making upstream connections\n// hang in connecting state.\nTEST_P(CdsIntegrationTest, DISABLED_CdsClusterDownWithLotsOfConnectingConnections) {\n  // Use low number of pending connections to prevent bumping into the default\n  // limit of 128, since the upstream will be prevented below from\n  // accepting connections.\n  constexpr int num_requests = 64;\n  // Make upstream H/1 so it creates connection for each request\n  upstream_codec_type_ = Http::CodecType::HTTP1;\n  cluster_creator_ = &ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits;\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        hcm.mutable_route_config()\n            ->mutable_virtual_hosts(0)\n            ->mutable_routes(0)\n            ->mutable_route()\n            ->mutable_timeout()\n            ->set_seconds(600);\n        hcm.mutable_route_config()\n            ->mutable_virtual_hosts(0)\n            ->mutable_routes(0)\n            ->mutable_route()\n            ->mutable_idle_timeout()\n            ->set_seconds(600);\n      });\n  initialize();\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_added\", 1);\n  std::vector<IntegrationStreamDecoderPtr> responses;\n  codec_client_ = makeHttpConnection(makeClientConnection((lookupPort(\"http\"))));\n  // Stop upstream at UpstreamIndex1 dispatcher, to prevent it from accepting TCP connections.\n  // This will cause Envoy's connections to that upstream hang in the connecting state.\n  fake_upstreams_[UpstreamIndex1]->dispatcher()->exit();\n  for (int i = 0; i < num_requests; ++i) {\n    Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n                                                   {\":path\", \"/cluster1\"},\n                                                   {\":scheme\", \"http\"},\n                                                   {\":authority\", \"host\"},\n                                                   {\"x-lyft-user-id\", absl::StrCat(i)}};\n\n    auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n    responses.push_back(std::move(response));\n  }\n\n  // Wait for Envoy to try to establish all expected connections\n  test_server_->waitForCounterEq(\"cluster.cluster_1.upstream_cx_total\", num_requests);\n\n  // Tell Envoy that cluster_1 is gone. Envoy will try to close all pending connections\n  EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"55\", {}, {}, {}));\n  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster, {}, {},\n                                                             {ClusterName1}, \"42\");\n  // We can continue the test once we're sure that Envoy's ClusterManager has made use of\n  // the DiscoveryResponse that says cluster_1 is gone.\n  test_server_->waitForCounterGe(\"cluster_manager.cluster_removed\", 1);\n\n  cleanupUpstreamAndDownstream();\n  ASSERT_TRUE(codec_client_->waitForDisconnect());\n  // If we got here it means that the recursion guard in the\n  // ConnPoolImplBase::closeIdleConnectionsForDrainingPool() did not fire, which is what this test\n  // validates.\n}\n\n} // namespace\n} // namespace Envoy\n"], "filenames": ["docs/root/version_history/current.rst", "source/common/conn_pool/BUILD", "source/common/conn_pool/conn_pool_base.cc", "source/common/conn_pool/conn_pool_base.h", "test/config/utility.cc", "test/config/utility.h", "test/integration/BUILD", "test/integration/cds_integration_test.cc"], "buggy_code_start_loc": [30, 16, 3, 8, 444, 155, 112, 40], "buggy_code_end_loc": [30, 16, 491, 373, 444, 155, 116, 345], "fixing_code_start_loc": [31, 17, 4, 9, 445, 156, 113, 40], "fixing_code_end_loc": [32, 18, 506, 379, 473, 161, 119, 506], "type": "CWE-674", "message": "Envoy is an open source edge and service proxy, designed for cloud-native applications. When a cluster is deleted via Cluster Discovery Service (CDS) all idle connections established to endpoints in that cluster are disconnected. A recursion was introduced in the procedure of disconnecting idle connections that can lead to stack exhaustion and abnormal process termination when a cluster has a large number of idle connections. This infinite recursion causes Envoy to crash. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2022-23606", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-22T23:15:11.337", "lastModified": "2022-03-02T14:37:33.870", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is an open source edge and service proxy, designed for cloud-native applications. When a cluster is deleted via Cluster Discovery Service (CDS) all idle connections established to endpoints in that cluster are disconnected. A recursion was introduced in the procedure of disconnecting idle connections that can lead to stack exhaustion and abnormal process termination when a cluster has a large number of idle connections. This infinite recursion causes Envoy to crash. Users are advised to upgrade."}, {"lang": "es", "value": "Envoy es un proxy de borde y servicio de c\u00f3digo abierto, dise\u00f1ado para aplicaciones nativas de la nube. Cuando se elimina un cl\u00faster a trav\u00e9s del Servicio de Descubrimiento de Cl\u00fasteres (CDS), se desconectan todas las conexiones inactivas establecidas con los puntos finales de ese cl\u00faster. Se introdujo una recursi\u00f3n en el procedimiento de desconexi\u00f3n de las conexiones inactivas que puede llevar al agotamiento de la pila y a la terminaci\u00f3n anormal del proceso cuando un cl\u00faster tiene un gran n\u00famero de conexiones inactivas. Esta recursi\u00f3n infinita hace que Envoy se bloquee. Se aconseja a los usuarios que actualicen"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.20.0", "versionEndExcluding": "1.20.2", "matchCriteriaId": "F5441B2D-F807-4ED9-AFB9-ED4DE07CE5F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.21.0:*:*:*:*:*:*:*", "matchCriteriaId": "6E0F077C-1153-43C1-88E2-5E41FDE5C6E9"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-9vp2-4cp7-vvxf", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31"}}