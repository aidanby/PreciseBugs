{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%           AAA   N   N  N   N   OOO   TTTTT   AAA   TTTTT  EEEEE             %\n%          A   A  NN  N  NN  N  O   O    T    A   A    T    E                 %\n%          AAAAA  N N N  N N N  O   O    T    AAAAA    T    EEE               %\n%          A   A  N  NN  N  NN  O   O    T    A   A    T    E                 %\n%          A   A  N   N  N   N   OOO     T    A   A    T    EEEEE             %\n%                                                                             %\n%                                                                             %\n%                   MagickCore Image Annotation Methods                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Digital Applications (www.digapp.com) contributed the stroked text algorithm.\n% It was written by Leonard Rosenthol.\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/annotate-private.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/draw-private.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/transform-private.h\"\n#include \"MagickCore/type.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/xwindow.h\"\n#include \"MagickCore/xwindow-private.h\"\n#if defined(MAGICKCORE_FREETYPE_DELEGATE)\n#if defined(__MINGW32__)\n#  undef interface\n#endif\n#include <ft2build.h>\n#if defined(FT_FREETYPE_H)\n#  include FT_FREETYPE_H\n#else\n#  include <freetype/freetype.h>\n#endif\n#if defined(FT_GLYPH_H)\n#  include FT_GLYPH_H\n#else\n#  include <freetype/ftglyph.h>\n#endif\n#if defined(FT_OUTLINE_H)\n#  include FT_OUTLINE_H\n#else\n#  include <freetype/ftoutln.h>\n#endif\n#if defined(FT_BBOX_H)\n#  include FT_BBOX_H\n#else\n#  include <freetype/ftbbox.h>\n#endif /* defined(FT_BBOX_H) */\n#endif\n#if defined(MAGICKCORE_RAQM_DELEGATE)\n#include <raqm.h>\n#endif\ntypedef struct _GraphemeInfo\n{\n  size_t\n    index,\n    x_offset,\n    x_advance,\n    y_offset;\n\n  size_t\n    cluster;\n} GraphemeInfo;\n\f\n/*\n  Annotate semaphores.\n*/\nstatic SemaphoreInfo\n  *annotate_semaphore = (SemaphoreInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  RenderType(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *),\n  RenderPostscript(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *),\n  RenderFreetype(Image *,const DrawInfo *,const char *,const PointInfo *,\n    TypeMetric *,ExceptionInfo *),\n  RenderX11(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A n n o t a t e C o m p o n e n t G e n e s i s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateComponentGenesis() instantiates the annotate component.\n%\n%  The format of the AnnotateComponentGenesis method is:\n%\n%      MagickBooleanType AnnotateComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType AnnotateComponentGenesis(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    annotate_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A n n o t a t e C o m p o n e n t T e r m i n u s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateComponentTerminus() destroys the annotate component.\n%\n%  The format of the AnnotateComponentTerminus method is:\n%\n%      AnnotateComponentTerminus(void)\n%\n*/\nMagickPrivate void AnnotateComponentTerminus(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  RelinquishSemaphoreInfo(&annotate_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A n n o t a t e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateImage() annotates an image with text.\n%\n%  The format of the AnnotateImage method is:\n%\n%      MagickBooleanType AnnotateImage(Image *image,DrawInfo *draw_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType AnnotateImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  char\n    *p,\n    primitive[MagickPathExtent],\n    *text,\n    **textlist;\n\n  DrawInfo\n    *annotate,\n    *annotate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    number_lines;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (draw_info->text == (char *) NULL)\n    return(MagickFalse);\n  if (*draw_info->text == '\\0')\n    return(MagickTrue);\n  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  text=annotate->text;\n  annotate->text=(char *) NULL;\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  number_lines=1;\n  for (p=text; *p != '\\0'; p++)\n    if (*p == '\\n')\n      number_lines++;\n  textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    return(MagickFalse);\n  p=text;\n  for (i=0; i < number_lines; i++)\n  {\n    char\n      *q;\n\n    textlist[i]=p;\n    for (q=p; *q != '\\0'; q++)\n      if ((*q == '\\r') || (*q == '\\n'))\n        break;\n    if (*q == '\\r')\n      {\n        *q='\\0';\n        q++;\n      }\n    *q='\\0';\n    p=q+1;\n  }\n  textlist[i]=(char *) NULL;\n  SetGeometry(image,&geometry);\n  SetGeometryInfo(&geometry_info);\n  if (annotate_info->geometry != (char *) NULL)\n    {\n      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,\n        exception);\n      (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n    }\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  status=MagickTrue;\n  (void) memset(&metrics,0,sizeof(metrics));\n  for (i=0; textlist[i] != (char *) NULL; i++)\n  {\n    if (*textlist[i] == '\\0')\n      continue;\n    /*\n      Position text relative to image.\n    */\n    annotate_info->affine.tx=geometry_info.xi-image->page.x;\n    annotate_info->affine.ty=geometry_info.psi-image->page.y;\n    (void) CloneString(&annotate->text,textlist[i]);\n    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))\n      (void) GetTypeMetrics(image,annotate,&metrics,exception);\n    height=(ssize_t) (metrics.ascent-metrics.descent+\n      draw_info->interline_spacing+0.5);\n    switch (annotate->gravity)\n    {\n      case UndefinedGravity:\n      default:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case NorthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent;\n        break;\n      }\n      case NorthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case NorthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent)-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      case WestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case CenterGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case EastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+\n          annotate_info->affine.ry*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case SouthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height-annotate_info->affine.ry*\n          (number_lines-1.0)*height;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0-\n          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width-\n          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n    }\n    switch (annotate->align)\n    {\n      case LeftAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case CenterAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case RightAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      default:\n        break;\n    }\n    if (draw_info->undercolor.alpha != TransparentAlpha)\n      {\n        DrawInfo\n          *undercolor_info;\n\n        /*\n          Text box.\n        */\n        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);\n        undercolor_info->fill=draw_info->undercolor;\n        undercolor_info->affine=draw_info->affine;\n        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;\n        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;\n        (void) FormatLocaleString(primitive,MagickPathExtent,\n          \"rectangle 0.0,0.0 %g,%g\",metrics.origin.x,(double) height);\n        (void) CloneString(&undercolor_info->primitive,primitive);\n        (void) DrawImage(image,undercolor_info,exception);\n        (void) DestroyDrawInfo(undercolor_info);\n      }\n    annotate_info->affine.tx=offset.x;\n    annotate_info->affine.ty=offset.y;\n    (void) FormatLocaleString(primitive,MagickPathExtent,\"stroke-width %g \"\n      \"line 0,0 %g,0\",metrics.underline_thickness,metrics.width);\n    if (annotate->decorate == OverlineDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+\n          metrics.descent-metrics.underline_position));\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n    else\n      if (annotate->decorate == UnderlineDecoration)\n        {\n          annotate_info->affine.ty-=(draw_info->affine.sy*\n            metrics.underline_position);\n          (void) CloneString(&annotate_info->primitive,primitive);\n          (void) DrawImage(image,annotate_info,exception);\n        }\n    /*\n      Annotate image with text.\n    */\n    status=RenderType(image,annotate,&offset,&metrics,exception);\n    if (status == MagickFalse)\n      break;\n    if (annotate->decorate == LineThroughDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(height+\n          metrics.underline_position+metrics.descent)/2.0);\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  annotate=DestroyDrawInfo(annotate);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t M a g i c k C a p t i o n                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatMagickCaption() formats a caption so that it fits within the image\n%  width.  It returns the number of lines in the formatted caption.\n%\n%  The format of the FormatMagickCaption method is:\n%\n%      ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,\n%        const MagickBooleanType split,TypeMetric *metrics,char **caption,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image:  The image.\n%\n%    o draw_info: the draw info.\n%\n%    o split: when no convenient line breaks-- insert newline.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o caption: the caption.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,\n  const MagickBooleanType split,TypeMetric *metrics,char **caption,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register char\n    *p,\n    *q,\n    *s;\n\n  register ssize_t\n    i;\n\n  size_t\n    width;\n\n  ssize_t\n    n;\n\n  q=draw_info->text;\n  s=(char *) NULL;\n  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n  {\n    if (IsUTFSpace(GetUTFCode(p)) != MagickFalse)\n      s=p;\n    if (GetUTFCode(p) == '\\n')\n      {\n        q=draw_info->text;\n        continue;\n      }\n    for (i=0; i < (ssize_t) GetUTFOctets(p); i++)\n      *q++=(*(p+i));\n    *q='\\0';\n    status=GetTypeMetrics(image,draw_info,metrics,exception);\n    if (status == MagickFalse)\n      break;\n    width=(size_t) floor(metrics->width+draw_info->stroke_width+0.5);\n    if (width <= image->columns)\n      continue;\n    if (s != (char *) NULL)\n      {\n        *s='\\n';\n        p=s;\n      }\n    else\n      if (split != MagickFalse)\n        {\n          /*\n            No convenient line breaks-- insert newline.\n          */\n          n=p-(*caption);\n          if ((n > 0) && ((*caption)[n-1] != '\\n'))\n            {\n              char\n                *target;\n\n              target=AcquireString(*caption);\n              CopyMagickString(target,*caption,n+1);\n              ConcatenateMagickString(target,\"\\n\",strlen(*caption)+1);\n              ConcatenateMagickString(target,p,strlen(*caption)+2);\n              (void) DestroyString(*caption);\n              *caption=target;\n              p=(*caption)+n;\n            }\n        }\n    q=draw_info->text;\n    s=(char *) NULL;\n  }\n  n=0;\n  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n    if (GetUTFCode(p) == '\\n')\n      n++;\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M u l t i l i n e T y p e M e t r i c s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMultilineTypeMetrics() returns the following information for the\n%  specified font and text:\n%\n%    character width\n%    character height\n%    ascender\n%    descender\n%    text width\n%    text height\n%    maximum horizontal advance\n%    bounds: x1\n%    bounds: y1\n%    bounds: x2\n%    bounds: y2\n%    origin: x\n%    origin: y\n%    underline position\n%    underline thickness\n%\n%  This method is like GetTypeMetrics() but it returns the maximum text width\n%  and height for multiple lines of text.\n%\n%  The format of the GetMultilineTypeMetrics method is:\n%\n%      MagickBooleanType GetMultilineTypeMetrics(Image *image,\n%        const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetMultilineTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  char\n    **textlist;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    count;\n\n  TypeMetric\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (*draw_info->text == '\\0')\n    return(MagickFalse);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->text=DestroyString(annotate_info->text);\n  /*\n    Convert newlines to multiple lines of text.\n  */\n  textlist=StringToStrings(draw_info->text,&count);\n  if (textlist == (char **) NULL)\n    return(MagickFalse);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  (void) memset(&extent,0,sizeof(extent));\n  /*\n    Find the widest of the text lines.\n  */\n  annotate_info->text=textlist[0];\n  status=GetTypeMetrics(image,annotate_info,&extent,exception);\n  *metrics=extent;\n  height=(count*(size_t) (metrics->ascent-metrics->descent+\n    0.5)+(count-1)*draw_info->interline_spacing);\n  if (AcquireMagickResource(HeightResource,height) == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"WidthOrHeightExceedsLimit\",\"`%s'\",image->filename);\n      status=MagickFalse;\n    }\n  else\n    {\n      for (i=1; i < (ssize_t) count; i++)\n      {\n        annotate_info->text=textlist[i];\n        status=GetTypeMetrics(image,annotate_info,&extent,exception);\n        if (status == MagickFalse)\n          break;\n        if (extent.width > metrics->width)\n          *metrics=extent;\n        if (AcquireMagickResource(WidthResource,extent.width) == MagickFalse)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n              \"WidthOrHeightExceedsLimit\",\"`%s'\",image->filename);\n            status=MagickFalse;\n            break;\n          }\n      }\n      metrics->height=(double) height;\n    }\n  /*\n    Relinquish resources.\n  */\n  annotate_info->text=(char *) NULL;\n  annotate_info=DestroyDrawInfo(annotate_info);\n  for (i=0; i < (ssize_t) count; i++)\n    textlist[i]=DestroyString(textlist[i]);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t T y p e M e t r i c s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetTypeMetrics() returns the following information for the specified font\n%  and text:\n%\n%    character width\n%    character height\n%    ascender\n%    descender\n%    text width\n%    text height\n%    maximum horizontal advance\n%    bounds: x1\n%    bounds: y1\n%    bounds: x2\n%    bounds: y2\n%    origin: x\n%    origin: y\n%    underline position\n%    underline thickness\n%\n%  The format of the GetTypeMetrics method is:\n%\n%      MagickBooleanType GetTypeMetrics(Image *image,const DrawInfo *draw_info,\n%        TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  offset.x=0.0;\n  offset.y=0.0;\n  status=RenderType(image,annotate_info,&offset,metrics,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Metrics: text: %s; \"\n      \"width: %g; height: %g; ascent: %g; descent: %g; max advance: %g; \"\n      \"bounds: %g,%g  %g,%g; origin: %g,%g; pixels per em: %g,%g; \"\n      \"underline position: %g; underline thickness: %g\",annotate_info->text,\n      metrics->width,metrics->height,metrics->ascent,metrics->descent,\n      metrics->max_advance,metrics->bounds.x1,metrics->bounds.y1,\n      metrics->bounds.x2,metrics->bounds.y2,metrics->origin.x,metrics->origin.y,\n      metrics->pixels_per_em.x,metrics->pixels_per_em.y,\n      metrics->underline_position,metrics->underline_thickness);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r T y p e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderType() renders text on the image.  It also returns the bounding box of\n%  the text relative to the image.\n%\n%  The format of the RenderType method is:\n%\n%      MagickBooleanType RenderType(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType RenderType(Image *image,const DrawInfo *draw_info,\n  const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  const TypeInfo\n    *type_info;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  type_info=(const TypeInfo *) NULL;\n  if (draw_info->font != (char *) NULL)\n    {\n      if (*draw_info->font == '@')\n        {\n          status=RenderFreetype(image,draw_info,draw_info->encoding,offset,\n            metrics,exception);\n          return(status);\n        }\n      if (*draw_info->font == '-')\n        return(RenderX11(image,draw_info,offset,metrics,exception));\n      if (*draw_info->font == '^')\n        return(RenderPostscript(image,draw_info,offset,metrics,exception));\n      if (IsPathAccessible(draw_info->font) != MagickFalse)\n        {\n          status=RenderFreetype(image,draw_info,draw_info->encoding,offset,\n            metrics,exception);\n          return(status);\n        }\n      type_info=GetTypeInfo(draw_info->font,exception);\n      if (type_info == (const TypeInfo *) NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n          \"UnableToReadFont\",\"`%s'\",draw_info->font);\n    }\n  if ((type_info == (const TypeInfo *) NULL) &&\n      (draw_info->family != (const char *) NULL))\n    {\n      type_info=GetTypeInfoByFamily(draw_info->family,draw_info->style,\n        draw_info->stretch,draw_info->weight,exception);\n      if (type_info == (const TypeInfo *) NULL)\n        {\n          char\n            **family;\n\n          int\n            number_families;\n\n          register ssize_t\n            i;\n\n          /*\n            Parse font family list.\n          */\n          family=StringToArgv(draw_info->family,&number_families);\n          for (i=1; i < (ssize_t) number_families; i++)\n          {\n            type_info=GetTypeInfoByFamily(family[i],draw_info->style,\n              draw_info->stretch,draw_info->weight,exception);\n            if (type_info != (const TypeInfo *) NULL)\n              break;\n          }\n          for (i=0; i < (ssize_t) number_families; i++)\n            family[i]=DestroyString(family[i]);\n          family=(char **) RelinquishMagickMemory(family);\n          if (type_info == (const TypeInfo *) NULL)\n            (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n              \"UnableToReadFont\",\"`%s'\",draw_info->family);\n        }\n    }\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Arial\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Helvetica\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Century Schoolbook\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Sans\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily((const char *) NULL,draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfo(\"*\",exception);\n  if (type_info == (const TypeInfo *) NULL)\n    {\n      status=RenderFreetype(image,draw_info,draw_info->encoding,offset,metrics,\n        exception);\n      return(status);\n    }\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->face=type_info->face;\n  if (type_info->metrics != (char *) NULL)\n    (void) CloneString(&annotate_info->metrics,type_info->metrics);\n  if (type_info->glyphs != (char *) NULL)\n    (void) CloneString(&annotate_info->font,type_info->glyphs);\n  status=RenderFreetype(image,annotate_info,type_info->encoding,offset,metrics,\n    exception);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r F r e e t y p e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderFreetype() renders text on the image with a Truetype font.  It also\n%  returns the bounding box of the text relative to the image.\n%\n%  The format of the RenderFreetype method is:\n%\n%      MagickBooleanType RenderFreetype(Image *image,DrawInfo *draw_info,\n%        const char *encoding,const PointInfo *offset,TypeMetric *metrics,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o encoding: the font encoding.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FREETYPE_DELEGATE)\n\nstatic size_t ComplexTextLayout(const Image *image,const DrawInfo *draw_info,\n  const char *text,const size_t length,const FT_Face face,const FT_Int32 flags,\n  GraphemeInfo **grapheme,ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_RAQM_DELEGATE)\n  const char\n    *features;\n\n  raqm_t\n    *rq;\n\n  raqm_glyph_t\n    *glyphs;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  extent=0;\n  rq=raqm_create();\n  if (rq == (raqm_t *) NULL)\n    goto cleanup;\n  if (raqm_set_text_utf8(rq,text,length) == 0)\n    goto cleanup;\n  if (raqm_set_par_direction(rq,(raqm_direction_t) draw_info->direction) == 0)\n    goto cleanup;\n  if (raqm_set_freetype_face(rq,face) == 0)\n    goto cleanup;\n  features=GetImageProperty(image,\"type:features\",exception);\n  if (features != (const char *) NULL)\n    {\n      char\n        breaker,\n        quote,\n        *token;\n\n      int\n        next,\n        status_token;\n\n      TokenInfo\n        *token_info;\n\n      next=0;\n      token_info=AcquireTokenInfo();\n      token=AcquireString(\"\");\n      status_token=Tokenizer(token_info,0,token,50,features,\"\",\",\",\"\",'\\0',\n        &breaker,&next,&quote);\n      while (status_token == 0)\n      {\n        raqm_add_font_feature(rq,token,strlen(token));\n        status_token=Tokenizer(token_info,0,token,50,features,\"\",\",\",\"\",'\\0',\n          &breaker,&next,&quote);\n      }\n      token_info=DestroyTokenInfo(token_info);\n      token=DestroyString(token);\n    }\n  if (raqm_layout(rq) == 0)\n    goto cleanup;\n  glyphs=raqm_get_glyphs(rq,&extent);\n  if (glyphs == (raqm_glyph_t *) NULL)\n    {\n      extent=0;\n      goto cleanup;\n    }\n  *grapheme=(GraphemeInfo *) AcquireQuantumMemory(extent,sizeof(**grapheme));\n  if (*grapheme == (GraphemeInfo *) NULL)\n    {\n      extent=0;\n      goto cleanup;\n    }\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    (*grapheme)[i].index=glyphs[i].index;\n    (*grapheme)[i].x_offset=glyphs[i].x_offset;\n    (*grapheme)[i].x_advance=glyphs[i].x_advance;\n    (*grapheme)[i].y_offset=glyphs[i].y_offset;\n    (*grapheme)[i].cluster=glyphs[i].cluster;\n  }\n\ncleanup:\n  raqm_destroy(rq);\n  return(extent);\n#else\n  const char\n    *p;\n\n  FT_Error\n    ft_status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    last_glyph;\n\n  /*\n    Simple layout for bi-directional text (right-to-left or left-to-right).\n  */\n  magick_unreferenced(image);\n  magick_unreferenced(exception);\n  *grapheme=(GraphemeInfo *) AcquireQuantumMemory(length+1,sizeof(**grapheme));\n  if (*grapheme == (GraphemeInfo *) NULL)\n    return(0);\n  last_glyph=0;\n  p=text;\n  for (i=0; GetUTFCode(p) != 0; p+=GetUTFOctets(p), i++)\n  {\n    (*grapheme)[i].index=(ssize_t) FT_Get_Char_Index(face,GetUTFCode(p));\n    (*grapheme)[i].x_offset=0;\n    (*grapheme)[i].y_offset=0;\n    if (((*grapheme)[i].index != 0) && (last_glyph != 0))\n      {\n        if (FT_HAS_KERNING(face))\n          {\n            FT_Vector\n              kerning;\n\n            ft_status=FT_Get_Kerning(face,(FT_UInt) last_glyph,(FT_UInt)\n              (*grapheme)[i].index,ft_kerning_default,&kerning);\n            if (ft_status == 0)\n              (*grapheme)[i-1].x_advance+=(FT_Pos) ((draw_info->direction ==\n                RightToLeftDirection ? -1.0 : 1.0)*kerning.x);\n          }\n      }\n    ft_status=FT_Load_Glyph(face,(FT_UInt) (*grapheme)[i].index,flags);\n    (*grapheme)[i].x_advance=face->glyph->advance.x;\n    (*grapheme)[i].cluster=p-text;\n    last_glyph=(*grapheme)[i].index;\n  }\n  return((size_t) i);\n#endif\n}\n\nstatic int TraceCubicBezier(FT_Vector *p,FT_Vector *q,FT_Vector *to,\n  DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"C%g,%g %g,%g %g,%g\",\n    affine.tx+p->x/64.0,affine.ty-p->y/64.0,affine.tx+q->x/64.0,affine.ty-\n    q->y/64.0,affine.tx+to->x/64.0,affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceLineTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"L%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceMoveTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"M%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceQuadraticBezier(FT_Vector *control,FT_Vector *to,\n  DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"Q%g,%g %g,%g\",affine.tx+\n    control->x/64.0,affine.ty-control->y/64.0,affine.tx+to->x/64.0,affine.ty-\n    to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *encoding,const PointInfo *offset,TypeMetric *metrics,\n  ExceptionInfo *exception)\n{\n#if !defined(FT_OPEN_PATHNAME)\n#define FT_OPEN_PATHNAME  ft_open_pathname\n#endif\n\n  typedef struct _GlyphInfo\n  {\n    FT_UInt\n      id;\n\n    FT_Vector\n      origin;\n\n    FT_Glyph\n      image;\n  } GlyphInfo;\n\n  const char\n    *value;\n\n  DrawInfo\n    *annotate_info;\n\n  FT_BBox\n    bounds;\n\n  FT_BitmapGlyph\n    bitmap;\n\n  FT_Encoding\n    encoding_type;\n\n  FT_Error\n    ft_status;\n\n  FT_Face\n    face;\n\n  FT_Int32\n    flags;\n\n  FT_Library\n    library;\n\n  FT_Matrix\n    affine;\n\n  FT_Open_Args\n    args;\n\n  FT_Vector\n    origin;\n\n  GlyphInfo\n    glyph,\n    last_glyph;\n\n  GraphemeInfo\n    *grapheme;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    point,\n    resolution;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    code,\n    y;\n\n  static FT_Outline_Funcs\n    OutlineMethods =\n    {\n      (FT_Outline_MoveTo_Func) TraceMoveTo,\n      (FT_Outline_LineTo_Func) TraceLineTo,\n      (FT_Outline_ConicTo_Func) TraceQuadraticBezier,\n      (FT_Outline_CubicTo_Func) TraceCubicBezier,\n      0, 0\n    };\n\n  unsigned char\n    *utf8;\n\n  /*\n    Initialize Truetype library.\n  */\n  ft_status=FT_Init_FreeType(&library);\n  if (ft_status != 0)\n    ThrowBinaryException(TypeError,\"UnableToInitializeFreetypeLibrary\",\n      image->filename);\n  args.flags=FT_OPEN_PATHNAME;\n  if (draw_info->font == (char *) NULL)\n    args.pathname=ConstantString(\"helvetica\");\n  else\n    if (*draw_info->font != '@')\n      args.pathname=ConstantString(draw_info->font);\n    else\n      args.pathname=ConstantString(draw_info->font+1);\n  face=(FT_Face) NULL;\n  ft_status=FT_Open_Face(library,&args,(long) draw_info->face,&face);\n  if (ft_status != 0)\n    {\n      (void) FT_Done_FreeType(library);\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeError,\n        \"UnableToReadFont\",\"`%s'\",args.pathname);\n      args.pathname=DestroyString(args.pathname);\n      return(MagickFalse);\n    }\n  args.pathname=DestroyString(args.pathname);\n  if ((draw_info->metrics != (char *) NULL) &&\n      (IsPathAccessible(draw_info->metrics) != MagickFalse))\n    (void) FT_Attach_File(face,draw_info->metrics);\n  encoding_type=FT_ENCODING_UNICODE;\n  ft_status=FT_Select_Charmap(face,encoding_type);\n  if ((ft_status != 0) && (face->num_charmaps != 0))\n    ft_status=FT_Set_Charmap(face,face->charmaps[0]);\n  if (encoding != (const char *) NULL)\n    {\n      if (LocaleCompare(encoding,\"AdobeCustom\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_CUSTOM;\n      if (LocaleCompare(encoding,\"AdobeExpert\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_EXPERT;\n      if (LocaleCompare(encoding,\"AdobeStandard\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_STANDARD;\n      if (LocaleCompare(encoding,\"AppleRoman\") == 0)\n        encoding_type=FT_ENCODING_APPLE_ROMAN;\n      if (LocaleCompare(encoding,\"BIG5\") == 0)\n        encoding_type=FT_ENCODING_BIG5;\n#if defined(FT_ENCODING_PRC)\n      if (LocaleCompare(encoding,\"GB2312\") == 0)\n        encoding_type=FT_ENCODING_PRC;\n#endif\n#if defined(FT_ENCODING_JOHAB)\n      if (LocaleCompare(encoding,\"Johab\") == 0)\n        encoding_type=FT_ENCODING_JOHAB;\n#endif\n#if defined(FT_ENCODING_ADOBE_LATIN_1)\n      if (LocaleCompare(encoding,\"Latin-1\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_LATIN_1;\n#endif\n#if defined(FT_ENCODING_ADOBE_LATIN_2)\n      if (LocaleCompare(encoding,\"Latin-2\") == 0)\n        encoding_type=FT_ENCODING_OLD_LATIN_2;\n#endif\n      if (LocaleCompare(encoding,\"None\") == 0)\n        encoding_type=FT_ENCODING_NONE;\n      if (LocaleCompare(encoding,\"SJIScode\") == 0)\n        encoding_type=FT_ENCODING_SJIS;\n      if (LocaleCompare(encoding,\"Symbol\") == 0)\n        encoding_type=FT_ENCODING_MS_SYMBOL;\n      if (LocaleCompare(encoding,\"Unicode\") == 0)\n        encoding_type=FT_ENCODING_UNICODE;\n      if (LocaleCompare(encoding,\"Wansung\") == 0)\n        encoding_type=FT_ENCODING_WANSUNG;\n      ft_status=FT_Select_Charmap(face,encoding_type);\n      if (ft_status != 0)\n        {\n          (void) FT_Done_Face(face);\n          (void) FT_Done_FreeType(library);\n          ThrowBinaryException(TypeError,\"UnrecognizedFontEncoding\",encoding);\n        }\n    }\n  /*\n    Set text size.\n  */\n  resolution.x=DefaultResolution;\n  resolution.y=DefaultResolution;\n  if (draw_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        geometry_flags;\n\n      geometry_flags=ParseGeometry(draw_info->density,&geometry_info);\n      resolution.x=geometry_info.rho;\n      resolution.y=geometry_info.sigma;\n      if ((geometry_flags & SigmaValue) == 0)\n        resolution.y=resolution.x;\n    }\n  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),\n    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,\n    (FT_UInt) resolution.y);\n  if (ft_status != 0)\n    {\n      (void) FT_Done_Face(face);\n      (void) FT_Done_FreeType(library);\n      ThrowBinaryException(TypeError,\"UnableToReadFont\",draw_info->font);\n    }\n  metrics->pixels_per_em.x=face->size->metrics.x_ppem;\n  metrics->pixels_per_em.y=face->size->metrics.y_ppem;\n  metrics->ascent=(double) face->size->metrics.ascender/64.0;\n  metrics->descent=(double) face->size->metrics.descender/64.0;\n  metrics->width=0;\n  metrics->origin.x=0;\n  metrics->origin.y=0;\n  metrics->height=(double) face->size->metrics.height/64.0;\n  metrics->max_advance=0.0;\n  if (face->size->metrics.max_advance > MagickEpsilon)\n    metrics->max_advance=(double) face->size->metrics.max_advance/64.0;\n  metrics->bounds.x1=0.0;\n  metrics->bounds.y1=metrics->descent;\n  metrics->bounds.x2=metrics->ascent+metrics->descent;\n  metrics->bounds.y2=metrics->ascent+metrics->descent;\n  metrics->underline_position=face->underline_position/64.0;\n  metrics->underline_thickness=face->underline_thickness/64.0;\n  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\\0'))\n    {\n      (void) FT_Done_Face(face);\n      (void) FT_Done_FreeType(library);\n      return(MagickTrue);\n    }\n  /*\n    Compute bounding box.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Font %s; \"\n      \"font-encoding %s; text-encoding %s; pointsize %g\",\n      draw_info->font != (char *) NULL ? draw_info->font : \"none\",\n      encoding != (char *) NULL ? encoding : \"none\",\n      draw_info->encoding != (char *) NULL ? draw_info->encoding : \"none\",\n      draw_info->pointsize);\n  flags=FT_LOAD_DEFAULT;\n  if (draw_info->render == MagickFalse)\n    flags=FT_LOAD_NO_BITMAP;\n  if (draw_info->text_antialias == MagickFalse)\n    flags|=FT_LOAD_TARGET_MONO;\n  else\n    {\n#if defined(FT_LOAD_TARGET_LIGHT)\n      flags|=FT_LOAD_TARGET_LIGHT;\n#elif defined(FT_LOAD_TARGET_LCD)\n      flags|=FT_LOAD_TARGET_LCD;\n#endif\n    }\n  value=GetImageProperty(image,\"type:hinting\",exception);\n  if ((value != (const char *) NULL) && (LocaleCompare(value,\"off\") == 0))\n    flags|=FT_LOAD_NO_HINTING;\n  glyph.id=0;\n  glyph.image=NULL;\n  last_glyph.id=0;\n  last_glyph.image=NULL;\n  origin.x=0;\n  origin.y=0;\n  affine.xx=65536L;\n  affine.yx=0L;\n  affine.xy=0L;\n  affine.yy=65536L;\n  if (draw_info->render != MagickFalse)\n    {\n      affine.xx=(FT_Fixed) (65536L*draw_info->affine.sx+0.5);\n      affine.yx=(FT_Fixed) (-65536L*draw_info->affine.rx+0.5);\n      affine.xy=(FT_Fixed) (-65536L*draw_info->affine.ry+0.5);\n      affine.yy=(FT_Fixed) (65536L*draw_info->affine.sy+0.5);\n    }\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (annotate_info->dash_pattern != (double *) NULL)\n    annotate_info->dash_pattern[0]=0.0;\n  (void) CloneString(&annotate_info->primitive,\"path '\");\n  status=MagickTrue;\n  if (draw_info->render != MagickFalse)\n    {\n      if (image->storage_class != DirectClass)\n        (void) SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    }\n  point.x=0.0;\n  point.y=0.0;\n  for (p=draw_info->text; GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n    if (GetUTFCode(p) < 0)\n      break;\n  utf8=(unsigned char *) NULL;\n  if (GetUTFCode(p) == 0)\n    p=draw_info->text;\n  else\n    {\n      utf8=ConvertLatin1ToUTF8((unsigned char *) draw_info->text);\n      if (utf8 != (unsigned char *) NULL)\n        p=(char *) utf8;\n    }\n  grapheme=(GraphemeInfo *) NULL;\n  length=ComplexTextLayout(image,draw_info,p,strlen(p),face,flags,&grapheme,\n    exception);\n  code=0;\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    FT_Outline\n      outline;\n\n    /*\n      Render UTF-8 sequence.\n    */\n    glyph.id=(FT_UInt) grapheme[i].index;\n    if (glyph.id == 0)\n      glyph.id=FT_Get_Char_Index(face,' ');\n    if ((glyph.id != 0) && (last_glyph.id != 0))\n      origin.x+=(FT_Pos) (64.0*draw_info->kerning);\n    glyph.origin=origin;\n    glyph.origin.x+=(FT_Pos) grapheme[i].x_offset;\n    glyph.origin.y+=(FT_Pos) grapheme[i].y_offset;\n    glyph.image=0;\n    ft_status=FT_Load_Glyph(face,glyph.id,flags);\n    if (ft_status != 0)\n      continue;\n    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);\n    if (ft_status != 0)\n      continue;\n    outline=((FT_OutlineGlyph) glyph.image)->outline;\n    ft_status=FT_Outline_Get_BBox(&outline,&bounds);\n    if (ft_status != 0)\n      continue;\n    if ((p == draw_info->text) || (bounds.xMin < metrics->bounds.x1))\n      if (bounds.xMin != 0)\n        metrics->bounds.x1=(double) bounds.xMin;\n    if ((p == draw_info->text) || (bounds.yMin < metrics->bounds.y1))\n      if (bounds.yMin != 0)\n        metrics->bounds.y1=(double) bounds.yMin;\n    if ((p == draw_info->text) || (bounds.xMax > metrics->bounds.x2))\n      if (bounds.xMax != 0)\n        metrics->bounds.x2=(double) bounds.xMax;\n    if ((p == draw_info->text) || (bounds.yMax > metrics->bounds.y2))\n      if (bounds.yMax != 0)\n        metrics->bounds.y2=(double) bounds.yMax;\n    if (((draw_info->stroke.alpha != TransparentAlpha) ||\n         (draw_info->stroke_pattern != (Image *) NULL)) &&\n        ((status != MagickFalse) && (draw_info->render != MagickFalse)))\n      {\n        /*\n          Trace the glyph.\n        */\n        annotate_info->affine.tx=glyph.origin.x/64.0;\n        annotate_info->affine.ty=(-glyph.origin.y/64.0);\n        if ((outline.n_contours > 0) && (outline.n_points > 0))\n          ft_status=FT_Outline_Decompose(&outline,&OutlineMethods,\n            annotate_info);\n      }\n    FT_Vector_Transform(&glyph.origin,&affine);\n    (void) FT_Glyph_Transform(glyph.image,&affine,&glyph.origin);\n    ft_status=FT_Glyph_To_Bitmap(&glyph.image,ft_render_mode_normal,\n      (FT_Vector *) NULL,MagickTrue);\n    if (ft_status != 0)\n      continue;\n    bitmap=(FT_BitmapGlyph) glyph.image;\n    point.x=offset->x+bitmap->left;\n    if (bitmap->bitmap.pixel_mode == ft_pixel_mode_mono)\n      point.x=offset->x+(origin.x >> 6);\n    point.y=offset->y-bitmap->top;\n    if (draw_info->render != MagickFalse)\n      {\n        CacheView\n          *image_view;\n\n        MagickBooleanType\n          transparent_fill;\n\n        register unsigned char\n          *r;\n\n        /*\n          Rasterize the glyph.\n        */\n        transparent_fill=((draw_info->fill.alpha == TransparentAlpha) &&\n          (draw_info->fill_pattern == (Image *) NULL) &&\n          (draw_info->stroke.alpha == TransparentAlpha) &&\n          (draw_info->stroke_pattern == (Image *) NULL)) ? MagickTrue :\n          MagickFalse;\n        image_view=AcquireAuthenticCacheView(image,exception);\n        r=bitmap->bitmap.buffer;\n        for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)\n        {\n          double\n            fill_opacity;\n\n          MagickBooleanType\n            active,\n            sync;\n\n          PixelInfo\n            fill_color;\n\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          ssize_t\n            n,\n            x_offset,\n            y_offset;\n\n          if (status == MagickFalse)\n            continue;\n          x_offset=(ssize_t) ceil(point.x-0.5);\n          y_offset=(ssize_t) ceil(point.y+y-0.5);\n          if ((y_offset < 0) || (y_offset >= (ssize_t) image->rows))\n            continue;\n          q=(Quantum *) NULL;\n          if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))\n            active=MagickFalse;\n          else\n            {\n              q=GetCacheViewAuthenticPixels(image_view,x_offset,y_offset,\n                bitmap->bitmap.width,1,exception);\n              active=q != (Quantum *) NULL ? MagickTrue : MagickFalse;\n            }\n          n=y*bitmap->bitmap.pitch-1;\n          for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)\n          {\n            n++;\n            x_offset++;\n            if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))\n              {\n                if (q != (Quantum *) NULL)\n                  q+=GetPixelChannels(image);\n                continue;\n              }\n            if (bitmap->bitmap.pixel_mode != ft_pixel_mode_mono)\n              fill_opacity=(double) (r[n])/(bitmap->bitmap.num_grays-1);\n            else\n              fill_opacity=((r[(x >> 3)+y*bitmap->bitmap.pitch] &\n                (1 << (~x & 0x07)))) == 0 ? 0.0 : 1.0;\n            if (draw_info->text_antialias == MagickFalse)\n              fill_opacity=fill_opacity >= 0.5 ? 1.0 : 0.0;\n            if (active == MagickFalse)\n              q=GetCacheViewAuthenticPixels(image_view,x_offset,y_offset,1,1,\n                exception);\n            if (q == (Quantum *) NULL)\n              continue;\n            if (transparent_fill == MagickFalse)\n              {\n                GetPixelInfo(image,&fill_color);\n                GetFillColor(draw_info,x_offset,y_offset,&fill_color,exception);\n                fill_opacity=fill_opacity*fill_color.alpha;\n                CompositePixelOver(image,&fill_color,fill_opacity,q,\n                  GetPixelAlpha(image,q),q);\n              }\n            else\n              {\n                double\n                  Sa,\n                  Da;\n\n                Da=1.0-(QuantumScale*GetPixelAlpha(image,q));\n                Sa=fill_opacity;\n                fill_opacity=(1.0-RoundToUnity(Sa+Da-Sa*Da))*QuantumRange;\n                SetPixelAlpha(image,fill_opacity,q);\n              }\n            if (active == MagickFalse)\n              {\n                sync=SyncCacheViewAuthenticPixels(image_view,exception);\n                if (sync == MagickFalse)\n                  status=MagickFalse;\n              }\n            q+=GetPixelChannels(image);\n          }\n          sync=SyncCacheViewAuthenticPixels(image_view,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        image_view=DestroyCacheView(image_view);\n        if (((draw_info->stroke.alpha != TransparentAlpha) ||\n             (draw_info->stroke_pattern != (Image *) NULL)) &&\n            (status != MagickFalse))\n          {\n            /*\n              Draw text stroke.\n            */\n            annotate_info->linejoin=RoundJoin;\n            annotate_info->affine.tx=offset->x;\n            annotate_info->affine.ty=offset->y;\n            (void) ConcatenateString(&annotate_info->primitive,\"'\");\n            if (strlen(annotate_info->primitive) > 7)\n              (void) DrawImage(image,annotate_info,exception);\n            (void) CloneString(&annotate_info->primitive,\"path '\");\n          }\n      }\n    if ((fabs(draw_info->interword_spacing) >= MagickEpsilon) &&\n        (IsUTFSpace(GetUTFCode(p+grapheme[i].cluster)) != MagickFalse) &&\n        (IsUTFSpace(code) == MagickFalse))\n      origin.x+=(FT_Pos) (64.0*draw_info->interword_spacing);\n    else\n      origin.x+=(FT_Pos) grapheme[i].x_advance;\n    metrics->origin.x=(double) origin.x;\n    metrics->origin.y=(double) origin.y;\n    if (metrics->origin.x > metrics->width)\n      metrics->width=metrics->origin.x;\n    if (last_glyph.image != 0)\n      {\n        FT_Done_Glyph(last_glyph.image);\n        last_glyph.image=0;\n      }\n    last_glyph=glyph;\n    code=GetUTFCode(p+grapheme[i].cluster);\n  }\n  if (grapheme != (GraphemeInfo *) NULL)\n    grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);\n  if (utf8 != (unsigned char *) NULL)\n    utf8=(unsigned char *) RelinquishMagickMemory(utf8);\n  if (glyph.image != 0)\n    {\n      FT_Done_Glyph(glyph.image);\n      glyph.image=0;\n    }\n  /*\n    Determine font metrics.\n  */\n  metrics->bounds.x1/=64.0;\n  metrics->bounds.y1/=64.0;\n  metrics->bounds.x2/=64.0;\n  metrics->bounds.y2/=64.0;\n  metrics->origin.x/=64.0;\n  metrics->origin.y/=64.0;\n  metrics->width/=64.0;\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  (void) FT_Done_Face(face);\n  (void) FT_Done_FreeType(library);\n  return(status);\n}\n#else\nstatic MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *magick_unused(encoding),const PointInfo *offset,\n  TypeMetric *metrics,ExceptionInfo *exception)\n{\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"'%s' (Freetype)\",\n    draw_info->font != (char *) NULL ? draw_info->font : \"none\");\n  return(RenderPostscript(image,draw_info,offset,metrics,exception));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r P o s t s c r i p t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderPostscript() renders text on the image with a Postscript font.  It\n%  also returns the bounding box of the text relative to the image.\n%\n%  The format of the RenderPostscript method is:\n%\n%      MagickBooleanType RenderPostscript(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char *EscapeParenthesis(const char *source)\n{\n  char\n    *destination;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  assert(source != (const char *) NULL);\n  length=0;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      {\n        if (~length < 1)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n        length++;\n      }\n    length++;\n  }\n  destination=(char *) NULL;\n  if (~length >= (MagickPathExtent-1))\n    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n      sizeof(*destination));\n  if (destination == (char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n  *destination='\\0';\n  q=destination;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      *q++='\\\\';\n    *q++=(*p);\n  }\n  *q='\\0';\n  return(destination);\n}\n\nstatic MagickBooleanType RenderPostscript(Image *image,\n  const DrawInfo *draw_info,const PointInfo *offset,TypeMetric *metrics,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *text;\n\n  FILE\n    *file;\n\n  Image\n    *annotate_image;\n\n  ImageInfo\n    *annotate_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    identity;\n\n  PointInfo\n    extent,\n    point,\n    resolution;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  /*\n    Render label with a Postscript font.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\n      \"Font %s; pointsize %g\",draw_info->font != (char *) NULL ?\n      draw_info->font : \"none\",draw_info->pointsize);\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleFile(file,\"%%!PS-Adobe-3.0\\n\");\n  (void) FormatLocaleFile(file,\"/ReencodeType\\n\");\n  (void) FormatLocaleFile(file,\"{\\n\");\n  (void) FormatLocaleFile(file,\"  findfont dup length\\n\");\n  (void) FormatLocaleFile(file,\n    \"  dict begin { 1 index /FID ne {def} {pop pop} ifelse } forall\\n\");\n  (void) FormatLocaleFile(file,\n    \"  /Encoding ISOLatin1Encoding def currentdict end definefont pop\\n\");\n  (void) FormatLocaleFile(file,\"} bind def\\n\");\n  /*\n    Sample to compute bounding box.\n  */\n  identity=(fabs(draw_info->affine.sx-draw_info->affine.sy) < MagickEpsilon) &&\n    (fabs(draw_info->affine.rx) < MagickEpsilon) &&\n    (fabs(draw_info->affine.ry) < MagickEpsilon) ? MagickTrue : MagickFalse;\n  extent.x=0.0;\n  extent.y=0.0;\n  length=strlen(draw_info->text);\n  for (i=0; i <= (ssize_t) (length+2); i++)\n  {\n    point.x=fabs(draw_info->affine.sx*i*draw_info->pointsize+\n      draw_info->affine.ry*2.0*draw_info->pointsize);\n    point.y=fabs(draw_info->affine.rx*i*draw_info->pointsize+\n      draw_info->affine.sy*2.0*draw_info->pointsize);\n    if (point.x > extent.x)\n      extent.x=point.x;\n    if (point.y > extent.y)\n      extent.y=point.y;\n  }\n  (void) FormatLocaleFile(file,\"%g %g moveto\\n\",identity  != MagickFalse ? 0.0 :\n    extent.x/2.0,extent.y/2.0);\n  (void) FormatLocaleFile(file,\"%g %g scale\\n\",draw_info->pointsize,\n    draw_info->pointsize);\n  if ((draw_info->font == (char *) NULL) || (*draw_info->font == '\\0') ||\n      (strchr(draw_info->font,'/') != (char *) NULL))\n    (void) FormatLocaleFile(file,\n      \"/Times-Roman-ISO dup /Times-Roman ReencodeType findfont setfont\\n\");\n  else\n    (void) FormatLocaleFile(file,\n      \"/%s-ISO dup /%s ReencodeType findfont setfont\\n\",draw_info->font,\n      draw_info->font);\n  (void) FormatLocaleFile(file,\"[%g %g %g %g 0 0] concat\\n\",\n    draw_info->affine.sx,-draw_info->affine.rx,-draw_info->affine.ry,\n    draw_info->affine.sy);\n  text=EscapeParenthesis(draw_info->text);\n  if (identity == MagickFalse)\n    (void) FormatLocaleFile(file,\"(%s) stringwidth pop -0.5 mul -0.5 rmoveto\\n\",\n      text);\n  (void) FormatLocaleFile(file,\"(%s) show\\n\",text);\n  text=DestroyString(text);\n  (void) FormatLocaleFile(file,\"showpage\\n\");\n  (void) fclose(file);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g+0+0!\",\n    floor(extent.x+0.5),floor(extent.y+0.5));\n  annotate_info=AcquireImageInfo();\n  (void) FormatLocaleString(annotate_info->filename,MagickPathExtent,\"ps:%s\",\n    filename);\n  (void) CloneString(&annotate_info->page,geometry);\n  if (draw_info->density != (char *) NULL)\n    (void) CloneString(&annotate_info->density,draw_info->density);\n  annotate_info->antialias=draw_info->text_antialias;\n  annotate_image=ReadImage(annotate_info,exception);\n  CatchException(exception);\n  annotate_info=DestroyImageInfo(annotate_info);\n  (void) RelinquishUniqueFileResource(filename);\n  if (annotate_image == (Image *) NULL)\n    return(MagickFalse);\n  (void) NegateImage(annotate_image,MagickFalse,exception);\n  resolution.x=DefaultResolution;\n  resolution.y=DefaultResolution;\n  if (draw_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(draw_info->density,&geometry_info);\n      resolution.x=geometry_info.rho;\n      resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        resolution.y=resolution.x;\n    }\n  if (identity == MagickFalse)\n    (void) TransformImage(&annotate_image,\"0x0\",(char *) NULL,exception);\n  else\n    {\n      RectangleInfo\n        crop_info;\n\n      crop_info=GetImageBoundingBox(annotate_image,exception);\n      crop_info.height=(size_t) ((resolution.y/DefaultResolution)*\n        ExpandAffine(&draw_info->affine)*draw_info->pointsize+0.5);\n      crop_info.y=(ssize_t) ceil((resolution.y/DefaultResolution)*extent.y/8.0-\n        0.5);\n      (void) FormatLocaleString(geometry,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) crop_info.width,(double)\n        crop_info.height,(double) crop_info.x,(double) crop_info.y);\n      (void) TransformImage(&annotate_image,geometry,(char *) NULL,exception);\n    }\n  metrics->pixels_per_em.x=(resolution.y/DefaultResolution)*\n    ExpandAffine(&draw_info->affine)*draw_info->pointsize;\n  metrics->pixels_per_em.y=metrics->pixels_per_em.x;\n  metrics->ascent=metrics->pixels_per_em.x;\n  metrics->descent=metrics->pixels_per_em.y/-5.0;\n  metrics->width=(double) annotate_image->columns/\n    ExpandAffine(&draw_info->affine);\n  metrics->height=1.152*metrics->pixels_per_em.x;\n  metrics->max_advance=metrics->pixels_per_em.x;\n  metrics->bounds.x1=0.0;\n  metrics->bounds.y1=metrics->descent;\n  metrics->bounds.x2=metrics->ascent+metrics->descent;\n  metrics->bounds.y2=metrics->ascent+metrics->descent;\n  metrics->underline_position=(-2.0);\n  metrics->underline_thickness=1.0;\n  if (draw_info->render == MagickFalse)\n    {\n      annotate_image=DestroyImage(annotate_image);\n      return(MagickTrue);\n    }\n  if (draw_info->fill.alpha != TransparentAlpha)\n    {\n      CacheView\n        *annotate_view;\n\n      MagickBooleanType\n        sync;\n\n      PixelInfo\n        fill_color;\n\n      /*\n        Render fill color.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      if (annotate_image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(annotate_image,OpaqueAlphaChannel,\n          exception);\n      fill_color=draw_info->fill;\n      annotate_view=AcquireAuthenticCacheView(annotate_image,exception);\n      for (y=0; y < (ssize_t) annotate_image->rows; y++)\n      {\n        register ssize_t\n          x;\n\n        register Quantum\n          *magick_restrict q;\n\n        q=GetCacheViewAuthenticPixels(annotate_view,0,y,annotate_image->columns,\n          1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) annotate_image->columns; x++)\n        {\n          GetFillColor(draw_info,x,y,&fill_color,exception);\n          SetPixelAlpha(annotate_image,ClampToQuantum((((double) QuantumScale*\n            GetPixelIntensity(annotate_image,q)*fill_color.alpha))),q);\n          SetPixelRed(annotate_image,fill_color.red,q);\n          SetPixelGreen(annotate_image,fill_color.green,q);\n          SetPixelBlue(annotate_image,fill_color.blue,q);\n          q+=GetPixelChannels(annotate_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(annotate_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      annotate_view=DestroyCacheView(annotate_view);\n      (void) CompositeImage(image,annotate_image,OverCompositeOp,MagickTrue,\n        (ssize_t) ceil(offset->x-0.5),(ssize_t) ceil(offset->y-(metrics->ascent+\n        metrics->descent)-0.5),exception);\n    }\n  annotate_image=DestroyImage(annotate_image);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r X 1 1                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderX11() renders text on the image with an X11 font.  It also returns the\n%  bounding box of the text relative to the image.\n%\n%  The format of the RenderX11 method is:\n%\n%      MagickBooleanType RenderX11(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType RenderX11(Image *image,const DrawInfo *draw_info,\n  const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  LockSemaphoreInfo(annotate_semaphore);\n  status=XRenderImage(image,draw_info,offset,metrics,exception);\n  UnlockSemaphoreInfo(annotate_semaphore);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%           AAA   N   N  N   N   OOO   TTTTT   AAA   TTTTT  EEEEE             %\n%          A   A  NN  N  NN  N  O   O    T    A   A    T    E                 %\n%          AAAAA  N N N  N N N  O   O    T    AAAAA    T    EEE               %\n%          A   A  N  NN  N  NN  O   O    T    A   A    T    E                 %\n%          A   A  N   N  N   N   OOO     T    A   A    T    EEEEE             %\n%                                                                             %\n%                                                                             %\n%                   MagickCore Image Annotation Methods                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Digital Applications (www.digapp.com) contributed the stroked text algorithm.\n% It was written by Leonard Rosenthol.\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/annotate-private.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/draw-private.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/transform-private.h\"\n#include \"MagickCore/type.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/xwindow.h\"\n#include \"MagickCore/xwindow-private.h\"\n#if defined(MAGICKCORE_FREETYPE_DELEGATE)\n#if defined(__MINGW32__)\n#  undef interface\n#endif\n#include <ft2build.h>\n#if defined(FT_FREETYPE_H)\n#  include FT_FREETYPE_H\n#else\n#  include <freetype/freetype.h>\n#endif\n#if defined(FT_GLYPH_H)\n#  include FT_GLYPH_H\n#else\n#  include <freetype/ftglyph.h>\n#endif\n#if defined(FT_OUTLINE_H)\n#  include FT_OUTLINE_H\n#else\n#  include <freetype/ftoutln.h>\n#endif\n#if defined(FT_BBOX_H)\n#  include FT_BBOX_H\n#else\n#  include <freetype/ftbbox.h>\n#endif /* defined(FT_BBOX_H) */\n#endif\n#if defined(MAGICKCORE_RAQM_DELEGATE)\n#include <raqm.h>\n#endif\ntypedef struct _GraphemeInfo\n{\n  size_t\n    index,\n    x_offset,\n    x_advance,\n    y_offset;\n\n  size_t\n    cluster;\n} GraphemeInfo;\n\f\n/*\n  Annotate semaphores.\n*/\nstatic SemaphoreInfo\n  *annotate_semaphore = (SemaphoreInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  RenderType(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *),\n  RenderPostscript(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *),\n  RenderFreetype(Image *,const DrawInfo *,const char *,const PointInfo *,\n    TypeMetric *,ExceptionInfo *),\n  RenderX11(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A n n o t a t e C o m p o n e n t G e n e s i s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateComponentGenesis() instantiates the annotate component.\n%\n%  The format of the AnnotateComponentGenesis method is:\n%\n%      MagickBooleanType AnnotateComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType AnnotateComponentGenesis(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    annotate_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A n n o t a t e C o m p o n e n t T e r m i n u s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateComponentTerminus() destroys the annotate component.\n%\n%  The format of the AnnotateComponentTerminus method is:\n%\n%      AnnotateComponentTerminus(void)\n%\n*/\nMagickPrivate void AnnotateComponentTerminus(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  RelinquishSemaphoreInfo(&annotate_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A n n o t a t e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateImage() annotates an image with text.\n%\n%  The format of the AnnotateImage method is:\n%\n%      MagickBooleanType AnnotateImage(Image *image,DrawInfo *draw_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType AnnotateImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  char\n    *p,\n    primitive[MagickPathExtent],\n    *text,\n    **textlist;\n\n  DrawInfo\n    *annotate,\n    *annotate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    number_lines;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (draw_info->text == (char *) NULL)\n    return(MagickFalse);\n  if (*draw_info->text == '\\0')\n    return(MagickTrue);\n  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  text=annotate->text;\n  annotate->text=(char *) NULL;\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  number_lines=1;\n  for (p=text; *p != '\\0'; p++)\n    if (*p == '\\n')\n      number_lines++;\n  textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      return(MagickFalse);\n    }\n  p=text;\n  for (i=0; i < number_lines; i++)\n  {\n    char\n      *q;\n\n    textlist[i]=p;\n    for (q=p; *q != '\\0'; q++)\n      if ((*q == '\\r') || (*q == '\\n'))\n        break;\n    if (*q == '\\r')\n      {\n        *q='\\0';\n        q++;\n      }\n    *q='\\0';\n    p=q+1;\n  }\n  textlist[i]=(char *) NULL;\n  SetGeometry(image,&geometry);\n  SetGeometryInfo(&geometry_info);\n  if (annotate_info->geometry != (char *) NULL)\n    {\n      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,\n        exception);\n      (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n    }\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      textlist=(char **) RelinquishMagickMemory(textlist);\n      return(MagickFalse);\n    }\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  status=MagickTrue;\n  (void) memset(&metrics,0,sizeof(metrics));\n  for (i=0; textlist[i] != (char *) NULL; i++)\n  {\n    if (*textlist[i] == '\\0')\n      continue;\n    /*\n      Position text relative to image.\n    */\n    annotate_info->affine.tx=geometry_info.xi-image->page.x;\n    annotate_info->affine.ty=geometry_info.psi-image->page.y;\n    (void) CloneString(&annotate->text,textlist[i]);\n    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))\n      (void) GetTypeMetrics(image,annotate,&metrics,exception);\n    height=(ssize_t) (metrics.ascent-metrics.descent+\n      draw_info->interline_spacing+0.5);\n    switch (annotate->gravity)\n    {\n      case UndefinedGravity:\n      default:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case NorthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent;\n        break;\n      }\n      case NorthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case NorthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent)-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      case WestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case CenterGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case EastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+\n          annotate_info->affine.ry*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case SouthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height-annotate_info->affine.ry*\n          (number_lines-1.0)*height;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0-\n          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width-\n          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n    }\n    switch (annotate->align)\n    {\n      case LeftAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case CenterAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case RightAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      default:\n        break;\n    }\n    if (draw_info->undercolor.alpha != TransparentAlpha)\n      {\n        DrawInfo\n          *undercolor_info;\n\n        /*\n          Text box.\n        */\n        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);\n        undercolor_info->fill=draw_info->undercolor;\n        undercolor_info->affine=draw_info->affine;\n        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;\n        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;\n        (void) FormatLocaleString(primitive,MagickPathExtent,\n          \"rectangle 0.0,0.0 %g,%g\",metrics.origin.x,(double) height);\n        (void) CloneString(&undercolor_info->primitive,primitive);\n        (void) DrawImage(image,undercolor_info,exception);\n        (void) DestroyDrawInfo(undercolor_info);\n      }\n    annotate_info->affine.tx=offset.x;\n    annotate_info->affine.ty=offset.y;\n    (void) FormatLocaleString(primitive,MagickPathExtent,\"stroke-width %g \"\n      \"line 0,0 %g,0\",metrics.underline_thickness,metrics.width);\n    if (annotate->decorate == OverlineDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+\n          metrics.descent-metrics.underline_position));\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n    else\n      if (annotate->decorate == UnderlineDecoration)\n        {\n          annotate_info->affine.ty-=(draw_info->affine.sy*\n            metrics.underline_position);\n          (void) CloneString(&annotate_info->primitive,primitive);\n          (void) DrawImage(image,annotate_info,exception);\n        }\n    /*\n      Annotate image with text.\n    */\n    status=RenderType(image,annotate,&offset,&metrics,exception);\n    if (status == MagickFalse)\n      break;\n    if (annotate->decorate == LineThroughDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(height+\n          metrics.underline_position+metrics.descent)/2.0);\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  annotate=DestroyDrawInfo(annotate);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t M a g i c k C a p t i o n                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatMagickCaption() formats a caption so that it fits within the image\n%  width.  It returns the number of lines in the formatted caption.\n%\n%  The format of the FormatMagickCaption method is:\n%\n%      ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,\n%        const MagickBooleanType split,TypeMetric *metrics,char **caption,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image:  The image.\n%\n%    o draw_info: the draw info.\n%\n%    o split: when no convenient line breaks-- insert newline.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o caption: the caption.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,\n  const MagickBooleanType split,TypeMetric *metrics,char **caption,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register char\n    *p,\n    *q,\n    *s;\n\n  register ssize_t\n    i;\n\n  size_t\n    width;\n\n  ssize_t\n    n;\n\n  q=draw_info->text;\n  s=(char *) NULL;\n  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n  {\n    if (IsUTFSpace(GetUTFCode(p)) != MagickFalse)\n      s=p;\n    if (GetUTFCode(p) == '\\n')\n      {\n        q=draw_info->text;\n        continue;\n      }\n    for (i=0; i < (ssize_t) GetUTFOctets(p); i++)\n      *q++=(*(p+i));\n    *q='\\0';\n    status=GetTypeMetrics(image,draw_info,metrics,exception);\n    if (status == MagickFalse)\n      break;\n    width=(size_t) floor(metrics->width+draw_info->stroke_width+0.5);\n    if (width <= image->columns)\n      continue;\n    if (s != (char *) NULL)\n      {\n        *s='\\n';\n        p=s;\n      }\n    else\n      if (split != MagickFalse)\n        {\n          /*\n            No convenient line breaks-- insert newline.\n          */\n          n=p-(*caption);\n          if ((n > 0) && ((*caption)[n-1] != '\\n'))\n            {\n              char\n                *target;\n\n              target=AcquireString(*caption);\n              CopyMagickString(target,*caption,n+1);\n              ConcatenateMagickString(target,\"\\n\",strlen(*caption)+1);\n              ConcatenateMagickString(target,p,strlen(*caption)+2);\n              (void) DestroyString(*caption);\n              *caption=target;\n              p=(*caption)+n;\n            }\n        }\n    q=draw_info->text;\n    s=(char *) NULL;\n  }\n  n=0;\n  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n    if (GetUTFCode(p) == '\\n')\n      n++;\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M u l t i l i n e T y p e M e t r i c s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMultilineTypeMetrics() returns the following information for the\n%  specified font and text:\n%\n%    character width\n%    character height\n%    ascender\n%    descender\n%    text width\n%    text height\n%    maximum horizontal advance\n%    bounds: x1\n%    bounds: y1\n%    bounds: x2\n%    bounds: y2\n%    origin: x\n%    origin: y\n%    underline position\n%    underline thickness\n%\n%  This method is like GetTypeMetrics() but it returns the maximum text width\n%  and height for multiple lines of text.\n%\n%  The format of the GetMultilineTypeMetrics method is:\n%\n%      MagickBooleanType GetMultilineTypeMetrics(Image *image,\n%        const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetMultilineTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  char\n    **textlist;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    count;\n\n  TypeMetric\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (*draw_info->text == '\\0')\n    return(MagickFalse);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->text=DestroyString(annotate_info->text);\n  /*\n    Convert newlines to multiple lines of text.\n  */\n  textlist=StringToStrings(draw_info->text,&count);\n  if (textlist == (char **) NULL)\n    return(MagickFalse);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  (void) memset(&extent,0,sizeof(extent));\n  /*\n    Find the widest of the text lines.\n  */\n  annotate_info->text=textlist[0];\n  status=GetTypeMetrics(image,annotate_info,&extent,exception);\n  *metrics=extent;\n  height=(count*(size_t) (metrics->ascent-metrics->descent+\n    0.5)+(count-1)*draw_info->interline_spacing);\n  if (AcquireMagickResource(HeightResource,height) == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"WidthOrHeightExceedsLimit\",\"`%s'\",image->filename);\n      status=MagickFalse;\n    }\n  else\n    {\n      for (i=1; i < (ssize_t) count; i++)\n      {\n        annotate_info->text=textlist[i];\n        status=GetTypeMetrics(image,annotate_info,&extent,exception);\n        if (status == MagickFalse)\n          break;\n        if (extent.width > metrics->width)\n          *metrics=extent;\n        if (AcquireMagickResource(WidthResource,extent.width) == MagickFalse)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n              \"WidthOrHeightExceedsLimit\",\"`%s'\",image->filename);\n            status=MagickFalse;\n            break;\n          }\n      }\n      metrics->height=(double) height;\n    }\n  /*\n    Relinquish resources.\n  */\n  annotate_info->text=(char *) NULL;\n  annotate_info=DestroyDrawInfo(annotate_info);\n  for (i=0; i < (ssize_t) count; i++)\n    textlist[i]=DestroyString(textlist[i]);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t T y p e M e t r i c s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetTypeMetrics() returns the following information for the specified font\n%  and text:\n%\n%    character width\n%    character height\n%    ascender\n%    descender\n%    text width\n%    text height\n%    maximum horizontal advance\n%    bounds: x1\n%    bounds: y1\n%    bounds: x2\n%    bounds: y2\n%    origin: x\n%    origin: y\n%    underline position\n%    underline thickness\n%\n%  The format of the GetTypeMetrics method is:\n%\n%      MagickBooleanType GetTypeMetrics(Image *image,const DrawInfo *draw_info,\n%        TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  offset.x=0.0;\n  offset.y=0.0;\n  status=RenderType(image,annotate_info,&offset,metrics,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Metrics: text: %s; \"\n      \"width: %g; height: %g; ascent: %g; descent: %g; max advance: %g; \"\n      \"bounds: %g,%g  %g,%g; origin: %g,%g; pixels per em: %g,%g; \"\n      \"underline position: %g; underline thickness: %g\",annotate_info->text,\n      metrics->width,metrics->height,metrics->ascent,metrics->descent,\n      metrics->max_advance,metrics->bounds.x1,metrics->bounds.y1,\n      metrics->bounds.x2,metrics->bounds.y2,metrics->origin.x,metrics->origin.y,\n      metrics->pixels_per_em.x,metrics->pixels_per_em.y,\n      metrics->underline_position,metrics->underline_thickness);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r T y p e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderType() renders text on the image.  It also returns the bounding box of\n%  the text relative to the image.\n%\n%  The format of the RenderType method is:\n%\n%      MagickBooleanType RenderType(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType RenderType(Image *image,const DrawInfo *draw_info,\n  const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  const TypeInfo\n    *type_info;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  type_info=(const TypeInfo *) NULL;\n  if (draw_info->font != (char *) NULL)\n    {\n      if (*draw_info->font == '@')\n        {\n          status=RenderFreetype(image,draw_info,draw_info->encoding,offset,\n            metrics,exception);\n          return(status);\n        }\n      if (*draw_info->font == '-')\n        return(RenderX11(image,draw_info,offset,metrics,exception));\n      if (*draw_info->font == '^')\n        return(RenderPostscript(image,draw_info,offset,metrics,exception));\n      if (IsPathAccessible(draw_info->font) != MagickFalse)\n        {\n          status=RenderFreetype(image,draw_info,draw_info->encoding,offset,\n            metrics,exception);\n          return(status);\n        }\n      type_info=GetTypeInfo(draw_info->font,exception);\n      if (type_info == (const TypeInfo *) NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n          \"UnableToReadFont\",\"`%s'\",draw_info->font);\n    }\n  if ((type_info == (const TypeInfo *) NULL) &&\n      (draw_info->family != (const char *) NULL))\n    {\n      type_info=GetTypeInfoByFamily(draw_info->family,draw_info->style,\n        draw_info->stretch,draw_info->weight,exception);\n      if (type_info == (const TypeInfo *) NULL)\n        {\n          char\n            **family;\n\n          int\n            number_families;\n\n          register ssize_t\n            i;\n\n          /*\n            Parse font family list.\n          */\n          family=StringToArgv(draw_info->family,&number_families);\n          for (i=1; i < (ssize_t) number_families; i++)\n          {\n            type_info=GetTypeInfoByFamily(family[i],draw_info->style,\n              draw_info->stretch,draw_info->weight,exception);\n            if (type_info != (const TypeInfo *) NULL)\n              break;\n          }\n          for (i=0; i < (ssize_t) number_families; i++)\n            family[i]=DestroyString(family[i]);\n          family=(char **) RelinquishMagickMemory(family);\n          if (type_info == (const TypeInfo *) NULL)\n            (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n              \"UnableToReadFont\",\"`%s'\",draw_info->family);\n        }\n    }\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Arial\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Helvetica\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Century Schoolbook\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Sans\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily((const char *) NULL,draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfo(\"*\",exception);\n  if (type_info == (const TypeInfo *) NULL)\n    {\n      status=RenderFreetype(image,draw_info,draw_info->encoding,offset,metrics,\n        exception);\n      return(status);\n    }\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->face=type_info->face;\n  if (type_info->metrics != (char *) NULL)\n    (void) CloneString(&annotate_info->metrics,type_info->metrics);\n  if (type_info->glyphs != (char *) NULL)\n    (void) CloneString(&annotate_info->font,type_info->glyphs);\n  status=RenderFreetype(image,annotate_info,type_info->encoding,offset,metrics,\n    exception);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r F r e e t y p e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderFreetype() renders text on the image with a Truetype font.  It also\n%  returns the bounding box of the text relative to the image.\n%\n%  The format of the RenderFreetype method is:\n%\n%      MagickBooleanType RenderFreetype(Image *image,DrawInfo *draw_info,\n%        const char *encoding,const PointInfo *offset,TypeMetric *metrics,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o encoding: the font encoding.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FREETYPE_DELEGATE)\n\nstatic size_t ComplexTextLayout(const Image *image,const DrawInfo *draw_info,\n  const char *text,const size_t length,const FT_Face face,const FT_Int32 flags,\n  GraphemeInfo **grapheme,ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_RAQM_DELEGATE)\n  const char\n    *features;\n\n  raqm_t\n    *rq;\n\n  raqm_glyph_t\n    *glyphs;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  extent=0;\n  rq=raqm_create();\n  if (rq == (raqm_t *) NULL)\n    goto cleanup;\n  if (raqm_set_text_utf8(rq,text,length) == 0)\n    goto cleanup;\n  if (raqm_set_par_direction(rq,(raqm_direction_t) draw_info->direction) == 0)\n    goto cleanup;\n  if (raqm_set_freetype_face(rq,face) == 0)\n    goto cleanup;\n  features=GetImageProperty(image,\"type:features\",exception);\n  if (features != (const char *) NULL)\n    {\n      char\n        breaker,\n        quote,\n        *token;\n\n      int\n        next,\n        status_token;\n\n      TokenInfo\n        *token_info;\n\n      next=0;\n      token_info=AcquireTokenInfo();\n      token=AcquireString(\"\");\n      status_token=Tokenizer(token_info,0,token,50,features,\"\",\",\",\"\",'\\0',\n        &breaker,&next,&quote);\n      while (status_token == 0)\n      {\n        raqm_add_font_feature(rq,token,strlen(token));\n        status_token=Tokenizer(token_info,0,token,50,features,\"\",\",\",\"\",'\\0',\n          &breaker,&next,&quote);\n      }\n      token_info=DestroyTokenInfo(token_info);\n      token=DestroyString(token);\n    }\n  if (raqm_layout(rq) == 0)\n    goto cleanup;\n  glyphs=raqm_get_glyphs(rq,&extent);\n  if (glyphs == (raqm_glyph_t *) NULL)\n    {\n      extent=0;\n      goto cleanup;\n    }\n  *grapheme=(GraphemeInfo *) AcquireQuantumMemory(extent,sizeof(**grapheme));\n  if (*grapheme == (GraphemeInfo *) NULL)\n    {\n      extent=0;\n      goto cleanup;\n    }\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    (*grapheme)[i].index=glyphs[i].index;\n    (*grapheme)[i].x_offset=glyphs[i].x_offset;\n    (*grapheme)[i].x_advance=glyphs[i].x_advance;\n    (*grapheme)[i].y_offset=glyphs[i].y_offset;\n    (*grapheme)[i].cluster=glyphs[i].cluster;\n  }\n\ncleanup:\n  raqm_destroy(rq);\n  return(extent);\n#else\n  const char\n    *p;\n\n  FT_Error\n    ft_status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    last_glyph;\n\n  /*\n    Simple layout for bi-directional text (right-to-left or left-to-right).\n  */\n  magick_unreferenced(image);\n  magick_unreferenced(exception);\n  *grapheme=(GraphemeInfo *) AcquireQuantumMemory(length+1,sizeof(**grapheme));\n  if (*grapheme == (GraphemeInfo *) NULL)\n    return(0);\n  last_glyph=0;\n  p=text;\n  for (i=0; GetUTFCode(p) != 0; p+=GetUTFOctets(p), i++)\n  {\n    (*grapheme)[i].index=(ssize_t) FT_Get_Char_Index(face,GetUTFCode(p));\n    (*grapheme)[i].x_offset=0;\n    (*grapheme)[i].y_offset=0;\n    if (((*grapheme)[i].index != 0) && (last_glyph != 0))\n      {\n        if (FT_HAS_KERNING(face))\n          {\n            FT_Vector\n              kerning;\n\n            ft_status=FT_Get_Kerning(face,(FT_UInt) last_glyph,(FT_UInt)\n              (*grapheme)[i].index,ft_kerning_default,&kerning);\n            if (ft_status == 0)\n              (*grapheme)[i-1].x_advance+=(FT_Pos) ((draw_info->direction ==\n                RightToLeftDirection ? -1.0 : 1.0)*kerning.x);\n          }\n      }\n    ft_status=FT_Load_Glyph(face,(FT_UInt) (*grapheme)[i].index,flags);\n    (*grapheme)[i].x_advance=face->glyph->advance.x;\n    (*grapheme)[i].cluster=p-text;\n    last_glyph=(*grapheme)[i].index;\n  }\n  return((size_t) i);\n#endif\n}\n\nstatic int TraceCubicBezier(FT_Vector *p,FT_Vector *q,FT_Vector *to,\n  DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"C%g,%g %g,%g %g,%g\",\n    affine.tx+p->x/64.0,affine.ty-p->y/64.0,affine.tx+q->x/64.0,affine.ty-\n    q->y/64.0,affine.tx+to->x/64.0,affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceLineTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"L%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceMoveTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"M%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceQuadraticBezier(FT_Vector *control,FT_Vector *to,\n  DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"Q%g,%g %g,%g\",affine.tx+\n    control->x/64.0,affine.ty-control->y/64.0,affine.tx+to->x/64.0,affine.ty-\n    to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *encoding,const PointInfo *offset,TypeMetric *metrics,\n  ExceptionInfo *exception)\n{\n#if !defined(FT_OPEN_PATHNAME)\n#define FT_OPEN_PATHNAME  ft_open_pathname\n#endif\n\n  typedef struct _GlyphInfo\n  {\n    FT_UInt\n      id;\n\n    FT_Vector\n      origin;\n\n    FT_Glyph\n      image;\n  } GlyphInfo;\n\n  const char\n    *value;\n\n  DrawInfo\n    *annotate_info;\n\n  FT_BBox\n    bounds;\n\n  FT_BitmapGlyph\n    bitmap;\n\n  FT_Encoding\n    encoding_type;\n\n  FT_Error\n    ft_status;\n\n  FT_Face\n    face;\n\n  FT_Int32\n    flags;\n\n  FT_Library\n    library;\n\n  FT_Matrix\n    affine;\n\n  FT_Open_Args\n    args;\n\n  FT_Vector\n    origin;\n\n  GlyphInfo\n    glyph,\n    last_glyph;\n\n  GraphemeInfo\n    *grapheme;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    point,\n    resolution;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    code,\n    y;\n\n  static FT_Outline_Funcs\n    OutlineMethods =\n    {\n      (FT_Outline_MoveTo_Func) TraceMoveTo,\n      (FT_Outline_LineTo_Func) TraceLineTo,\n      (FT_Outline_ConicTo_Func) TraceQuadraticBezier,\n      (FT_Outline_CubicTo_Func) TraceCubicBezier,\n      0, 0\n    };\n\n  unsigned char\n    *utf8;\n\n  /*\n    Initialize Truetype library.\n  */\n  ft_status=FT_Init_FreeType(&library);\n  if (ft_status != 0)\n    ThrowBinaryException(TypeError,\"UnableToInitializeFreetypeLibrary\",\n      image->filename);\n  args.flags=FT_OPEN_PATHNAME;\n  if (draw_info->font == (char *) NULL)\n    args.pathname=ConstantString(\"helvetica\");\n  else\n    if (*draw_info->font != '@')\n      args.pathname=ConstantString(draw_info->font);\n    else\n      args.pathname=ConstantString(draw_info->font+1);\n  face=(FT_Face) NULL;\n  ft_status=FT_Open_Face(library,&args,(long) draw_info->face,&face);\n  if (ft_status != 0)\n    {\n      (void) FT_Done_FreeType(library);\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeError,\n        \"UnableToReadFont\",\"`%s'\",args.pathname);\n      args.pathname=DestroyString(args.pathname);\n      return(MagickFalse);\n    }\n  args.pathname=DestroyString(args.pathname);\n  if ((draw_info->metrics != (char *) NULL) &&\n      (IsPathAccessible(draw_info->metrics) != MagickFalse))\n    (void) FT_Attach_File(face,draw_info->metrics);\n  encoding_type=FT_ENCODING_UNICODE;\n  ft_status=FT_Select_Charmap(face,encoding_type);\n  if ((ft_status != 0) && (face->num_charmaps != 0))\n    ft_status=FT_Set_Charmap(face,face->charmaps[0]);\n  if (encoding != (const char *) NULL)\n    {\n      if (LocaleCompare(encoding,\"AdobeCustom\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_CUSTOM;\n      if (LocaleCompare(encoding,\"AdobeExpert\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_EXPERT;\n      if (LocaleCompare(encoding,\"AdobeStandard\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_STANDARD;\n      if (LocaleCompare(encoding,\"AppleRoman\") == 0)\n        encoding_type=FT_ENCODING_APPLE_ROMAN;\n      if (LocaleCompare(encoding,\"BIG5\") == 0)\n        encoding_type=FT_ENCODING_BIG5;\n#if defined(FT_ENCODING_PRC)\n      if (LocaleCompare(encoding,\"GB2312\") == 0)\n        encoding_type=FT_ENCODING_PRC;\n#endif\n#if defined(FT_ENCODING_JOHAB)\n      if (LocaleCompare(encoding,\"Johab\") == 0)\n        encoding_type=FT_ENCODING_JOHAB;\n#endif\n#if defined(FT_ENCODING_ADOBE_LATIN_1)\n      if (LocaleCompare(encoding,\"Latin-1\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_LATIN_1;\n#endif\n#if defined(FT_ENCODING_ADOBE_LATIN_2)\n      if (LocaleCompare(encoding,\"Latin-2\") == 0)\n        encoding_type=FT_ENCODING_OLD_LATIN_2;\n#endif\n      if (LocaleCompare(encoding,\"None\") == 0)\n        encoding_type=FT_ENCODING_NONE;\n      if (LocaleCompare(encoding,\"SJIScode\") == 0)\n        encoding_type=FT_ENCODING_SJIS;\n      if (LocaleCompare(encoding,\"Symbol\") == 0)\n        encoding_type=FT_ENCODING_MS_SYMBOL;\n      if (LocaleCompare(encoding,\"Unicode\") == 0)\n        encoding_type=FT_ENCODING_UNICODE;\n      if (LocaleCompare(encoding,\"Wansung\") == 0)\n        encoding_type=FT_ENCODING_WANSUNG;\n      ft_status=FT_Select_Charmap(face,encoding_type);\n      if (ft_status != 0)\n        {\n          (void) FT_Done_Face(face);\n          (void) FT_Done_FreeType(library);\n          ThrowBinaryException(TypeError,\"UnrecognizedFontEncoding\",encoding);\n        }\n    }\n  /*\n    Set text size.\n  */\n  resolution.x=DefaultResolution;\n  resolution.y=DefaultResolution;\n  if (draw_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        geometry_flags;\n\n      geometry_flags=ParseGeometry(draw_info->density,&geometry_info);\n      resolution.x=geometry_info.rho;\n      resolution.y=geometry_info.sigma;\n      if ((geometry_flags & SigmaValue) == 0)\n        resolution.y=resolution.x;\n    }\n  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),\n    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,\n    (FT_UInt) resolution.y);\n  if (ft_status != 0)\n    {\n      (void) FT_Done_Face(face);\n      (void) FT_Done_FreeType(library);\n      ThrowBinaryException(TypeError,\"UnableToReadFont\",draw_info->font);\n    }\n  metrics->pixels_per_em.x=face->size->metrics.x_ppem;\n  metrics->pixels_per_em.y=face->size->metrics.y_ppem;\n  metrics->ascent=(double) face->size->metrics.ascender/64.0;\n  metrics->descent=(double) face->size->metrics.descender/64.0;\n  metrics->width=0;\n  metrics->origin.x=0;\n  metrics->origin.y=0;\n  metrics->height=(double) face->size->metrics.height/64.0;\n  metrics->max_advance=0.0;\n  if (face->size->metrics.max_advance > MagickEpsilon)\n    metrics->max_advance=(double) face->size->metrics.max_advance/64.0;\n  metrics->bounds.x1=0.0;\n  metrics->bounds.y1=metrics->descent;\n  metrics->bounds.x2=metrics->ascent+metrics->descent;\n  metrics->bounds.y2=metrics->ascent+metrics->descent;\n  metrics->underline_position=face->underline_position/64.0;\n  metrics->underline_thickness=face->underline_thickness/64.0;\n  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\\0'))\n    {\n      (void) FT_Done_Face(face);\n      (void) FT_Done_FreeType(library);\n      return(MagickTrue);\n    }\n  /*\n    Compute bounding box.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Font %s; \"\n      \"font-encoding %s; text-encoding %s; pointsize %g\",\n      draw_info->font != (char *) NULL ? draw_info->font : \"none\",\n      encoding != (char *) NULL ? encoding : \"none\",\n      draw_info->encoding != (char *) NULL ? draw_info->encoding : \"none\",\n      draw_info->pointsize);\n  flags=FT_LOAD_DEFAULT;\n  if (draw_info->render == MagickFalse)\n    flags=FT_LOAD_NO_BITMAP;\n  if (draw_info->text_antialias == MagickFalse)\n    flags|=FT_LOAD_TARGET_MONO;\n  else\n    {\n#if defined(FT_LOAD_TARGET_LIGHT)\n      flags|=FT_LOAD_TARGET_LIGHT;\n#elif defined(FT_LOAD_TARGET_LCD)\n      flags|=FT_LOAD_TARGET_LCD;\n#endif\n    }\n  value=GetImageProperty(image,\"type:hinting\",exception);\n  if ((value != (const char *) NULL) && (LocaleCompare(value,\"off\") == 0))\n    flags|=FT_LOAD_NO_HINTING;\n  glyph.id=0;\n  glyph.image=NULL;\n  last_glyph.id=0;\n  last_glyph.image=NULL;\n  origin.x=0;\n  origin.y=0;\n  affine.xx=65536L;\n  affine.yx=0L;\n  affine.xy=0L;\n  affine.yy=65536L;\n  if (draw_info->render != MagickFalse)\n    {\n      affine.xx=(FT_Fixed) (65536L*draw_info->affine.sx+0.5);\n      affine.yx=(FT_Fixed) (-65536L*draw_info->affine.rx+0.5);\n      affine.xy=(FT_Fixed) (-65536L*draw_info->affine.ry+0.5);\n      affine.yy=(FT_Fixed) (65536L*draw_info->affine.sy+0.5);\n    }\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (annotate_info->dash_pattern != (double *) NULL)\n    annotate_info->dash_pattern[0]=0.0;\n  (void) CloneString(&annotate_info->primitive,\"path '\");\n  status=MagickTrue;\n  if (draw_info->render != MagickFalse)\n    {\n      if (image->storage_class != DirectClass)\n        (void) SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    }\n  point.x=0.0;\n  point.y=0.0;\n  for (p=draw_info->text; GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n    if (GetUTFCode(p) < 0)\n      break;\n  utf8=(unsigned char *) NULL;\n  if (GetUTFCode(p) == 0)\n    p=draw_info->text;\n  else\n    {\n      utf8=ConvertLatin1ToUTF8((unsigned char *) draw_info->text);\n      if (utf8 != (unsigned char *) NULL)\n        p=(char *) utf8;\n    }\n  grapheme=(GraphemeInfo *) NULL;\n  length=ComplexTextLayout(image,draw_info,p,strlen(p),face,flags,&grapheme,\n    exception);\n  code=0;\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    FT_Outline\n      outline;\n\n    /*\n      Render UTF-8 sequence.\n    */\n    glyph.id=(FT_UInt) grapheme[i].index;\n    if (glyph.id == 0)\n      glyph.id=FT_Get_Char_Index(face,' ');\n    if ((glyph.id != 0) && (last_glyph.id != 0))\n      origin.x+=(FT_Pos) (64.0*draw_info->kerning);\n    glyph.origin=origin;\n    glyph.origin.x+=(FT_Pos) grapheme[i].x_offset;\n    glyph.origin.y+=(FT_Pos) grapheme[i].y_offset;\n    glyph.image=0;\n    ft_status=FT_Load_Glyph(face,glyph.id,flags);\n    if (ft_status != 0)\n      continue;\n    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);\n    if (ft_status != 0)\n      continue;\n    outline=((FT_OutlineGlyph) glyph.image)->outline;\n    ft_status=FT_Outline_Get_BBox(&outline,&bounds);\n    if (ft_status != 0)\n      continue;\n    if ((p == draw_info->text) || (bounds.xMin < metrics->bounds.x1))\n      if (bounds.xMin != 0)\n        metrics->bounds.x1=(double) bounds.xMin;\n    if ((p == draw_info->text) || (bounds.yMin < metrics->bounds.y1))\n      if (bounds.yMin != 0)\n        metrics->bounds.y1=(double) bounds.yMin;\n    if ((p == draw_info->text) || (bounds.xMax > metrics->bounds.x2))\n      if (bounds.xMax != 0)\n        metrics->bounds.x2=(double) bounds.xMax;\n    if ((p == draw_info->text) || (bounds.yMax > metrics->bounds.y2))\n      if (bounds.yMax != 0)\n        metrics->bounds.y2=(double) bounds.yMax;\n    if (((draw_info->stroke.alpha != TransparentAlpha) ||\n         (draw_info->stroke_pattern != (Image *) NULL)) &&\n        ((status != MagickFalse) && (draw_info->render != MagickFalse)))\n      {\n        /*\n          Trace the glyph.\n        */\n        annotate_info->affine.tx=glyph.origin.x/64.0;\n        annotate_info->affine.ty=(-glyph.origin.y/64.0);\n        if ((outline.n_contours > 0) && (outline.n_points > 0))\n          ft_status=FT_Outline_Decompose(&outline,&OutlineMethods,\n            annotate_info);\n      }\n    FT_Vector_Transform(&glyph.origin,&affine);\n    (void) FT_Glyph_Transform(glyph.image,&affine,&glyph.origin);\n    ft_status=FT_Glyph_To_Bitmap(&glyph.image,ft_render_mode_normal,\n      (FT_Vector *) NULL,MagickTrue);\n    if (ft_status != 0)\n      continue;\n    bitmap=(FT_BitmapGlyph) glyph.image;\n    point.x=offset->x+bitmap->left;\n    if (bitmap->bitmap.pixel_mode == ft_pixel_mode_mono)\n      point.x=offset->x+(origin.x >> 6);\n    point.y=offset->y-bitmap->top;\n    if (draw_info->render != MagickFalse)\n      {\n        CacheView\n          *image_view;\n\n        MagickBooleanType\n          transparent_fill;\n\n        register unsigned char\n          *r;\n\n        /*\n          Rasterize the glyph.\n        */\n        transparent_fill=((draw_info->fill.alpha == TransparentAlpha) &&\n          (draw_info->fill_pattern == (Image *) NULL) &&\n          (draw_info->stroke.alpha == TransparentAlpha) &&\n          (draw_info->stroke_pattern == (Image *) NULL)) ? MagickTrue :\n          MagickFalse;\n        image_view=AcquireAuthenticCacheView(image,exception);\n        r=bitmap->bitmap.buffer;\n        for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)\n        {\n          double\n            fill_opacity;\n\n          MagickBooleanType\n            active,\n            sync;\n\n          PixelInfo\n            fill_color;\n\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          ssize_t\n            n,\n            x_offset,\n            y_offset;\n\n          if (status == MagickFalse)\n            continue;\n          x_offset=(ssize_t) ceil(point.x-0.5);\n          y_offset=(ssize_t) ceil(point.y+y-0.5);\n          if ((y_offset < 0) || (y_offset >= (ssize_t) image->rows))\n            continue;\n          q=(Quantum *) NULL;\n          if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))\n            active=MagickFalse;\n          else\n            {\n              q=GetCacheViewAuthenticPixels(image_view,x_offset,y_offset,\n                bitmap->bitmap.width,1,exception);\n              active=q != (Quantum *) NULL ? MagickTrue : MagickFalse;\n            }\n          n=y*bitmap->bitmap.pitch-1;\n          for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)\n          {\n            n++;\n            x_offset++;\n            if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))\n              {\n                if (q != (Quantum *) NULL)\n                  q+=GetPixelChannels(image);\n                continue;\n              }\n            if (bitmap->bitmap.pixel_mode != ft_pixel_mode_mono)\n              fill_opacity=(double) (r[n])/(bitmap->bitmap.num_grays-1);\n            else\n              fill_opacity=((r[(x >> 3)+y*bitmap->bitmap.pitch] &\n                (1 << (~x & 0x07)))) == 0 ? 0.0 : 1.0;\n            if (draw_info->text_antialias == MagickFalse)\n              fill_opacity=fill_opacity >= 0.5 ? 1.0 : 0.0;\n            if (active == MagickFalse)\n              q=GetCacheViewAuthenticPixels(image_view,x_offset,y_offset,1,1,\n                exception);\n            if (q == (Quantum *) NULL)\n              continue;\n            if (transparent_fill == MagickFalse)\n              {\n                GetPixelInfo(image,&fill_color);\n                GetFillColor(draw_info,x_offset,y_offset,&fill_color,exception);\n                fill_opacity=fill_opacity*fill_color.alpha;\n                CompositePixelOver(image,&fill_color,fill_opacity,q,\n                  GetPixelAlpha(image,q),q);\n              }\n            else\n              {\n                double\n                  Sa,\n                  Da;\n\n                Da=1.0-(QuantumScale*GetPixelAlpha(image,q));\n                Sa=fill_opacity;\n                fill_opacity=(1.0-RoundToUnity(Sa+Da-Sa*Da))*QuantumRange;\n                SetPixelAlpha(image,fill_opacity,q);\n              }\n            if (active == MagickFalse)\n              {\n                sync=SyncCacheViewAuthenticPixels(image_view,exception);\n                if (sync == MagickFalse)\n                  status=MagickFalse;\n              }\n            q+=GetPixelChannels(image);\n          }\n          sync=SyncCacheViewAuthenticPixels(image_view,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        image_view=DestroyCacheView(image_view);\n        if (((draw_info->stroke.alpha != TransparentAlpha) ||\n             (draw_info->stroke_pattern != (Image *) NULL)) &&\n            (status != MagickFalse))\n          {\n            /*\n              Draw text stroke.\n            */\n            annotate_info->linejoin=RoundJoin;\n            annotate_info->affine.tx=offset->x;\n            annotate_info->affine.ty=offset->y;\n            (void) ConcatenateString(&annotate_info->primitive,\"'\");\n            if (strlen(annotate_info->primitive) > 7)\n              (void) DrawImage(image,annotate_info,exception);\n            (void) CloneString(&annotate_info->primitive,\"path '\");\n          }\n      }\n    if ((fabs(draw_info->interword_spacing) >= MagickEpsilon) &&\n        (IsUTFSpace(GetUTFCode(p+grapheme[i].cluster)) != MagickFalse) &&\n        (IsUTFSpace(code) == MagickFalse))\n      origin.x+=(FT_Pos) (64.0*draw_info->interword_spacing);\n    else\n      origin.x+=(FT_Pos) grapheme[i].x_advance;\n    metrics->origin.x=(double) origin.x;\n    metrics->origin.y=(double) origin.y;\n    if (metrics->origin.x > metrics->width)\n      metrics->width=metrics->origin.x;\n    if (last_glyph.image != 0)\n      {\n        FT_Done_Glyph(last_glyph.image);\n        last_glyph.image=0;\n      }\n    last_glyph=glyph;\n    code=GetUTFCode(p+grapheme[i].cluster);\n  }\n  if (grapheme != (GraphemeInfo *) NULL)\n    grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);\n  if (utf8 != (unsigned char *) NULL)\n    utf8=(unsigned char *) RelinquishMagickMemory(utf8);\n  if (glyph.image != 0)\n    {\n      FT_Done_Glyph(glyph.image);\n      glyph.image=0;\n    }\n  /*\n    Determine font metrics.\n  */\n  metrics->bounds.x1/=64.0;\n  metrics->bounds.y1/=64.0;\n  metrics->bounds.x2/=64.0;\n  metrics->bounds.y2/=64.0;\n  metrics->origin.x/=64.0;\n  metrics->origin.y/=64.0;\n  metrics->width/=64.0;\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  (void) FT_Done_Face(face);\n  (void) FT_Done_FreeType(library);\n  return(status);\n}\n#else\nstatic MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *magick_unused(encoding),const PointInfo *offset,\n  TypeMetric *metrics,ExceptionInfo *exception)\n{\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"'%s' (Freetype)\",\n    draw_info->font != (char *) NULL ? draw_info->font : \"none\");\n  return(RenderPostscript(image,draw_info,offset,metrics,exception));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r P o s t s c r i p t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderPostscript() renders text on the image with a Postscript font.  It\n%  also returns the bounding box of the text relative to the image.\n%\n%  The format of the RenderPostscript method is:\n%\n%      MagickBooleanType RenderPostscript(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char *EscapeParenthesis(const char *source)\n{\n  char\n    *destination;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  assert(source != (const char *) NULL);\n  length=0;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      {\n        if (~length < 1)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n        length++;\n      }\n    length++;\n  }\n  destination=(char *) NULL;\n  if (~length >= (MagickPathExtent-1))\n    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n      sizeof(*destination));\n  if (destination == (char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n  *destination='\\0';\n  q=destination;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      *q++='\\\\';\n    *q++=(*p);\n  }\n  *q='\\0';\n  return(destination);\n}\n\nstatic MagickBooleanType RenderPostscript(Image *image,\n  const DrawInfo *draw_info,const PointInfo *offset,TypeMetric *metrics,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *text;\n\n  FILE\n    *file;\n\n  Image\n    *annotate_image;\n\n  ImageInfo\n    *annotate_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    identity;\n\n  PointInfo\n    extent,\n    point,\n    resolution;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  /*\n    Render label with a Postscript font.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\n      \"Font %s; pointsize %g\",draw_info->font != (char *) NULL ?\n      draw_info->font : \"none\",draw_info->pointsize);\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleFile(file,\"%%!PS-Adobe-3.0\\n\");\n  (void) FormatLocaleFile(file,\"/ReencodeType\\n\");\n  (void) FormatLocaleFile(file,\"{\\n\");\n  (void) FormatLocaleFile(file,\"  findfont dup length\\n\");\n  (void) FormatLocaleFile(file,\n    \"  dict begin { 1 index /FID ne {def} {pop pop} ifelse } forall\\n\");\n  (void) FormatLocaleFile(file,\n    \"  /Encoding ISOLatin1Encoding def currentdict end definefont pop\\n\");\n  (void) FormatLocaleFile(file,\"} bind def\\n\");\n  /*\n    Sample to compute bounding box.\n  */\n  identity=(fabs(draw_info->affine.sx-draw_info->affine.sy) < MagickEpsilon) &&\n    (fabs(draw_info->affine.rx) < MagickEpsilon) &&\n    (fabs(draw_info->affine.ry) < MagickEpsilon) ? MagickTrue : MagickFalse;\n  extent.x=0.0;\n  extent.y=0.0;\n  length=strlen(draw_info->text);\n  for (i=0; i <= (ssize_t) (length+2); i++)\n  {\n    point.x=fabs(draw_info->affine.sx*i*draw_info->pointsize+\n      draw_info->affine.ry*2.0*draw_info->pointsize);\n    point.y=fabs(draw_info->affine.rx*i*draw_info->pointsize+\n      draw_info->affine.sy*2.0*draw_info->pointsize);\n    if (point.x > extent.x)\n      extent.x=point.x;\n    if (point.y > extent.y)\n      extent.y=point.y;\n  }\n  (void) FormatLocaleFile(file,\"%g %g moveto\\n\",identity  != MagickFalse ? 0.0 :\n    extent.x/2.0,extent.y/2.0);\n  (void) FormatLocaleFile(file,\"%g %g scale\\n\",draw_info->pointsize,\n    draw_info->pointsize);\n  if ((draw_info->font == (char *) NULL) || (*draw_info->font == '\\0') ||\n      (strchr(draw_info->font,'/') != (char *) NULL))\n    (void) FormatLocaleFile(file,\n      \"/Times-Roman-ISO dup /Times-Roman ReencodeType findfont setfont\\n\");\n  else\n    (void) FormatLocaleFile(file,\n      \"/%s-ISO dup /%s ReencodeType findfont setfont\\n\",draw_info->font,\n      draw_info->font);\n  (void) FormatLocaleFile(file,\"[%g %g %g %g 0 0] concat\\n\",\n    draw_info->affine.sx,-draw_info->affine.rx,-draw_info->affine.ry,\n    draw_info->affine.sy);\n  text=EscapeParenthesis(draw_info->text);\n  if (identity == MagickFalse)\n    (void) FormatLocaleFile(file,\"(%s) stringwidth pop -0.5 mul -0.5 rmoveto\\n\",\n      text);\n  (void) FormatLocaleFile(file,\"(%s) show\\n\",text);\n  text=DestroyString(text);\n  (void) FormatLocaleFile(file,\"showpage\\n\");\n  (void) fclose(file);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g+0+0!\",\n    floor(extent.x+0.5),floor(extent.y+0.5));\n  annotate_info=AcquireImageInfo();\n  (void) FormatLocaleString(annotate_info->filename,MagickPathExtent,\"ps:%s\",\n    filename);\n  (void) CloneString(&annotate_info->page,geometry);\n  if (draw_info->density != (char *) NULL)\n    (void) CloneString(&annotate_info->density,draw_info->density);\n  annotate_info->antialias=draw_info->text_antialias;\n  annotate_image=ReadImage(annotate_info,exception);\n  CatchException(exception);\n  annotate_info=DestroyImageInfo(annotate_info);\n  (void) RelinquishUniqueFileResource(filename);\n  if (annotate_image == (Image *) NULL)\n    return(MagickFalse);\n  (void) NegateImage(annotate_image,MagickFalse,exception);\n  resolution.x=DefaultResolution;\n  resolution.y=DefaultResolution;\n  if (draw_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(draw_info->density,&geometry_info);\n      resolution.x=geometry_info.rho;\n      resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        resolution.y=resolution.x;\n    }\n  if (identity == MagickFalse)\n    (void) TransformImage(&annotate_image,\"0x0\",(char *) NULL,exception);\n  else\n    {\n      RectangleInfo\n        crop_info;\n\n      crop_info=GetImageBoundingBox(annotate_image,exception);\n      crop_info.height=(size_t) ((resolution.y/DefaultResolution)*\n        ExpandAffine(&draw_info->affine)*draw_info->pointsize+0.5);\n      crop_info.y=(ssize_t) ceil((resolution.y/DefaultResolution)*extent.y/8.0-\n        0.5);\n      (void) FormatLocaleString(geometry,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) crop_info.width,(double)\n        crop_info.height,(double) crop_info.x,(double) crop_info.y);\n      (void) TransformImage(&annotate_image,geometry,(char *) NULL,exception);\n    }\n  metrics->pixels_per_em.x=(resolution.y/DefaultResolution)*\n    ExpandAffine(&draw_info->affine)*draw_info->pointsize;\n  metrics->pixels_per_em.y=metrics->pixels_per_em.x;\n  metrics->ascent=metrics->pixels_per_em.x;\n  metrics->descent=metrics->pixels_per_em.y/-5.0;\n  metrics->width=(double) annotate_image->columns/\n    ExpandAffine(&draw_info->affine);\n  metrics->height=1.152*metrics->pixels_per_em.x;\n  metrics->max_advance=metrics->pixels_per_em.x;\n  metrics->bounds.x1=0.0;\n  metrics->bounds.y1=metrics->descent;\n  metrics->bounds.x2=metrics->ascent+metrics->descent;\n  metrics->bounds.y2=metrics->ascent+metrics->descent;\n  metrics->underline_position=(-2.0);\n  metrics->underline_thickness=1.0;\n  if (draw_info->render == MagickFalse)\n    {\n      annotate_image=DestroyImage(annotate_image);\n      return(MagickTrue);\n    }\n  if (draw_info->fill.alpha != TransparentAlpha)\n    {\n      CacheView\n        *annotate_view;\n\n      MagickBooleanType\n        sync;\n\n      PixelInfo\n        fill_color;\n\n      /*\n        Render fill color.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      if (annotate_image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(annotate_image,OpaqueAlphaChannel,\n          exception);\n      fill_color=draw_info->fill;\n      annotate_view=AcquireAuthenticCacheView(annotate_image,exception);\n      for (y=0; y < (ssize_t) annotate_image->rows; y++)\n      {\n        register ssize_t\n          x;\n\n        register Quantum\n          *magick_restrict q;\n\n        q=GetCacheViewAuthenticPixels(annotate_view,0,y,annotate_image->columns,\n          1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) annotate_image->columns; x++)\n        {\n          GetFillColor(draw_info,x,y,&fill_color,exception);\n          SetPixelAlpha(annotate_image,ClampToQuantum((((double) QuantumScale*\n            GetPixelIntensity(annotate_image,q)*fill_color.alpha))),q);\n          SetPixelRed(annotate_image,fill_color.red,q);\n          SetPixelGreen(annotate_image,fill_color.green,q);\n          SetPixelBlue(annotate_image,fill_color.blue,q);\n          q+=GetPixelChannels(annotate_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(annotate_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      annotate_view=DestroyCacheView(annotate_view);\n      (void) CompositeImage(image,annotate_image,OverCompositeOp,MagickTrue,\n        (ssize_t) ceil(offset->x-0.5),(ssize_t) ceil(offset->y-(metrics->ascent+\n        metrics->descent)-0.5),exception);\n    }\n  annotate_image=DestroyImage(annotate_image);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r X 1 1                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderX11() renders text on the image with an X11 font.  It also returns the\n%  bounding box of the text relative to the image.\n%\n%  The format of the RenderX11 method is:\n%\n%      MagickBooleanType RenderX11(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType RenderX11(Image *image,const DrawInfo *draw_info,\n  const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  LockSemaphoreInfo(annotate_semaphore);\n  status=XRenderImage(image,draw_info,offset,metrics,exception);\n  UnlockSemaphoreInfo(annotate_semaphore);\n  return(status);\n}\n"], "filenames": ["MagickCore/annotate.c"], "buggy_code_start_loc": [283], "buggy_code_end_loc": [313], "fixing_code_start_loc": [283], "fixing_code_end_loc": [322], "type": "CWE-401", "message": "ImageMagick 7.0.8-50 Q16 has memory leaks in AcquireMagickMemory because of an AnnotateImage error.", "other": {"cve": {"id": "CVE-2019-13301", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:10.297", "lastModified": "2023-02-23T15:07:31.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has memory leaks in AcquireMagickMemory because of an AnnotateImage error."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16 tiene fugas de memoria en AcquireMagickMemory debido a un error de AnnotateImage."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/f595a1985233c399a05c0c37cc41de16a90dd025", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1585", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1589", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/f595a1985233c399a05c0c37cc41de16a90dd025"}}