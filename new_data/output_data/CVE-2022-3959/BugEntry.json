{"buggy_code": ["/**\n *\n *  @file HttpRequest.h\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include <drogon/exports.h>\n#include <drogon/utils/string_view.h>\n#include <drogon/utils/optional.h>\n#include <drogon/utils/Utilities.h>\n#include <drogon/DrClassMap.h>\n#include <drogon/HttpTypes.h>\n#include <drogon/Session.h>\n#include <drogon/Attribute.h>\n#include <drogon/UploadFile.h>\n#include <json/json.h>\n#include <trantor/net/InetAddress.h>\n#include <trantor/utils/Date.h>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\nnamespace drogon\n{\nclass HttpRequest;\nusing HttpRequestPtr = std::shared_ptr<HttpRequest>;\n\n/**\n * @brief This template is used to convert a request object to a custom\n * type object. Users must specialize the template for a particular type.\n */\ntemplate <typename T>\nT fromRequest(const HttpRequest &)\n{\n    LOG_ERROR << \"You must specialize the fromRequest template for the type of \"\n              << DrClassMap::demangle(typeid(T).name());\n    exit(1);\n}\n\n/**\n * @brief This template is used to create a request object from a custom\n * type object by calling the newCustomHttpRequest(). Users must specialize\n * the template for a particular type.\n */\ntemplate <typename T>\nHttpRequestPtr toRequest(T &&)\n{\n    LOG_ERROR << \"You must specialize the toRequest template for the type of \"\n              << DrClassMap::demangle(typeid(T).name());\n    exit(1);\n}\n\ntemplate <>\nHttpRequestPtr toRequest<const Json::Value &>(const Json::Value &pJson);\ntemplate <>\nHttpRequestPtr toRequest(Json::Value &&pJson);\ntemplate <>\ninline HttpRequestPtr toRequest<Json::Value &>(Json::Value &pJson)\n{\n    return toRequest((const Json::Value &)pJson);\n}\n\ntemplate <>\nstd::shared_ptr<Json::Value> fromRequest(const HttpRequest &req);\n\n/// Abstract class for webapp developer to get or set the Http request;\nclass DROGON_EXPORT HttpRequest\n{\n  public:\n    /**\n     * @brief This template enables implicit type conversion. For using this\n     * template, user must specialize the fromRequest template. For example a\n     * shared_ptr<Json::Value> specialization version is available above, so\n     * we can use the following code to get a json object:\n     * @code\n       std::shared_ptr<Json::Value> jsonPtr = *requestPtr;\n       @endcode\n     * With this template, user can use their favorite JSON library instead of\n     * the default jsoncpp library or convert the request to an object of any\n     * custom type.\n     */\n    template <typename T>\n    operator T() const\n    {\n        return fromRequest<T>(*this);\n    }\n\n    /**\n     * @brief This template enables explicit type conversion, see the above\n     * template.\n     */\n    template <typename T>\n    T as() const\n    {\n        return fromRequest<T>(*this);\n    }\n\n    /// Return the method string of the request, such as GET, POST, etc.\n    virtual const char *methodString() const = 0;\n    const char *getMethodString() const\n    {\n        return methodString();\n    }\n\n    /// Return the enum type method of the request.\n    virtual HttpMethod method() const = 0;\n    HttpMethod getMethod() const\n    {\n        return method();\n    }\n\n    /// Get the header string identified by the key parameter.\n    /**\n     * @note\n     * If there is no the header, a empty string is retured.\n     * The key is case insensitive\n     */\n    virtual const std::string &getHeader(std::string key) const = 0;\n\n    /**\n     * @brief Set the header string identified by the field parameter\n     *\n     * @param field The field parameter is transformed to lower case before\n     * storing.\n     * @param value The value of the header.\n     */\n    virtual void addHeader(std::string field, const std::string &value) = 0;\n    virtual void addHeader(std::string field, std::string &&value) = 0;\n\n    /**\n     * @brief  Remove the header identified by the key parameter.\n     *\n     * @param key The key is case insensitive\n     */\n    virtual void removeHeader(std::string key) = 0;\n\n    /// Get the cookie string identified by the field parameter\n    virtual const std::string &getCookie(const std::string &field) const = 0;\n\n    /// Get all headers of the request\n    virtual const std::unordered_map<std::string, std::string> &headers()\n        const = 0;\n\n    /// Get all headers of the request\n    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }\n\n    /// Get all cookies of the request\n    virtual const std::unordered_map<std::string, std::string> &cookies()\n        const = 0;\n\n    /// Get all cookies of the request\n    const std::unordered_map<std::string, std::string> &getCookies() const\n    {\n        return cookies();\n    }\n\n    /// Get the query string of the request.\n    /**\n     * The query string is the substring after the '?' in the URL string.\n     */\n    virtual const std::string &query() const = 0;\n\n    /// Get the query string of the request.\n    const std::string &getQuery() const\n    {\n        return query();\n    }\n\n    /// Get the content string of the request, which is the body part of the\n    /// request.\n    string_view body() const\n    {\n        return string_view(bodyData(), bodyLength());\n    }\n\n    /// Get the content string of the request, which is the body part of the\n    /// request.\n    string_view getBody() const\n    {\n        return body();\n    }\n    virtual const char *bodyData() const = 0;\n    virtual size_t bodyLength() const = 0;\n\n    /// Set the content string of the request.\n    virtual void setBody(const std::string &body) = 0;\n\n    /// Set the content string of the request.\n    virtual void setBody(std::string &&body) = 0;\n\n    /// Get the path of the request.\n    virtual const std::string &path() const = 0;\n\n    /// Get the path of the request.\n    const std::string &getPath() const\n    {\n        return path();\n    }\n\n    /// Get the matched path pattern after routing\n    string_view getMatchedPathPattern() const\n    {\n        return matchedPathPattern();\n    }\n\n    /// Get the matched path pattern after routing\n    string_view matchedPathPattern() const\n    {\n        return string_view(matchedPathPatternData(),\n                           matchedPathPatternLength());\n    }\n    virtual const char *matchedPathPatternData() const = 0;\n    virtual size_t matchedPathPatternLength() const = 0;\n\n    /// Return the string of http version of request, such as HTTP/1.0,\n    /// HTTP/1.1, etc.\n    virtual const char *versionString() const = 0;\n    const char *getVersionString() const\n    {\n        return versionString();\n    }\n\n    /// Return the enum type version of the request.\n    /**\n     * kHttp10 means Http version is 1.0\n     * kHttp11 means Http verison is 1.1\n     */\n    virtual Version version() const = 0;\n\n    /// Return the enum type version of the request.\n    Version getVersion() const\n    {\n        return version();\n    }\n\n    /// Get the session to which the request belongs.\n    virtual const SessionPtr &session() const = 0;\n\n    /// Get the session to which the request belongs.\n    const SessionPtr &getSession() const\n    {\n        return session();\n    }\n\n    /// Get the attributes store, users can add/get any type of data to/from\n    /// this store\n    virtual const AttributesPtr &attributes() const = 0;\n\n    /// Get the attributes store, users can add/get any type of data to/from\n    /// this store\n    const AttributesPtr &getAttributes() const\n    {\n        return attributes();\n    }\n\n    /// Get parameters of the request.\n    virtual const std::unordered_map<std::string, std::string> &parameters()\n        const = 0;\n\n    /// Get parameters of the request.\n    const std::unordered_map<std::string, std::string> &getParameters() const\n    {\n        return parameters();\n    }\n\n    /// Get a parameter identified by the @param key\n    virtual const std::string &getParameter(const std::string &key) const = 0;\n\n    /**\n     * @brief Get the optional parameter identified by the @param key. if the\n     * parameter doesn't exist, or the original parameter can't be converted to\n     * a T type object, an empty optional object is returned.\n     *\n     * @tparam T\n     * @param key\n     * @return optional<T>\n     */\n    template <typename T>\n    optional<T> getOptionalParameter(const std::string &key)\n    {\n        auto &params = getParameters();\n        auto it = params.find(key);\n        if (it != params.end())\n        {\n            try\n            {\n                return optional<T>(drogon::utils::fromString<T>(it->second));\n            }\n            catch (const std::exception &e)\n            {\n                LOG_ERROR << e.what();\n                return optional<T>{};\n            }\n        }\n        else\n        {\n            return optional<T>{};\n        }\n    }\n\n    /// Return the remote IP address and port\n    virtual const trantor::InetAddress &peerAddr() const = 0;\n    const trantor::InetAddress &getPeerAddr() const\n    {\n        return peerAddr();\n    }\n\n    /// Return the local IP address and port\n    virtual const trantor::InetAddress &localAddr() const = 0;\n    const trantor::InetAddress &getLocalAddr() const\n    {\n        return localAddr();\n    }\n\n    /// Return the creation timestamp set by the framework.\n    virtual const trantor::Date &creationDate() const = 0;\n    const trantor::Date &getCreationDate() const\n    {\n        return creationDate();\n    }\n\n    /// Get the Json object of the request\n    /**\n     * The content type of the request must be 'application/json',\n     * otherwise the method returns an empty shared_ptr object.\n     */\n    virtual const std::shared_ptr<Json::Value> &jsonObject() const = 0;\n\n    /// Get the Json object of the request\n    const std::shared_ptr<Json::Value> &getJsonObject() const\n    {\n        return jsonObject();\n    }\n\n    /**\n     * @brief Get the error message of parsing the JSON body received from peer.\n     * This method usually is called after getting a empty shared_ptr object\n     * by the getJsonObject() method.\n     *\n     * @return const std::string& The error message. An empty string is returned\n     * when no error occurs.\n     */\n    virtual const std::string &getJsonError() const = 0;\n\n    /// Get the content type\n    virtual ContentType contentType() const = 0;\n    ContentType getContentType() const\n    {\n        return contentType();\n    }\n\n    /// Set the Http method\n    virtual void setMethod(const HttpMethod method) = 0;\n\n    /// Set the path of the request\n    virtual void setPath(const std::string &path) = 0;\n\n    /**\n     * @brief The default behavior is to encode the value of setPath\n     * using urlEncode. Setting the path encode to false avoid the\n     * value of path will be changed by the library\n     *\n     * @param bool true --> the path will be url encoded\n     *             false --> using value of path as it is set\n     */\n    virtual void setPathEncode(bool) = 0;\n\n    /// Set the parameter of the request\n    virtual void setParameter(const std::string &key,\n                              const std::string &value) = 0;\n\n    /// Set or get the content type\n    virtual void setContentTypeCode(const ContentType type) = 0;\n\n    /// Set the content-type string, The string may contain the header name and\n    /// CRLF. Or just the MIME type\n    //\n    /// For example, \"content-type: text/plain\\r\\n\" or \"text/plain\"\n    void setContentTypeString(const string_view &typeString)\n    {\n        setContentTypeString(typeString.data(), typeString.size());\n    }\n\n    /// Set the request content-type string, The string\n    /// must contain the header name and CRLF.\n    /// For example, \"content-type: text/plain\\r\\n\"\n    virtual void setCustomContentTypeString(const std::string &type) = 0;\n\n    /// Add a cookie\n    virtual void addCookie(const std::string &key,\n                           const std::string &value) = 0;\n\n    /**\n     * @brief Set the request object to the pass-through mode or not. It's not\n     * by default when a new request object is created.\n     * In pass-through mode, no addtional headers (including user-agent,\n     * connection, etc.) are added to the request. This mode is useful for some\n     * applications such as a proxy.\n     *\n     * @param flag\n     */\n    virtual void setPassThrough(bool flag) = 0;\n\n    /// The following methods are a series of factory methods that help users\n    /// create request objects.\n\n    /// Create a normal request with http method Get and version Http1.1.\n    static HttpRequestPtr newHttpRequest();\n\n    /// Create a http request with:\n    /// Method: Get\n    /// Version: Http1.1\n    /// Content type: application/json, the @param data is serialized into the\n    /// content of the request.\n    static HttpRequestPtr newHttpJsonRequest(const Json::Value &data);\n\n    /// Create a http request with:\n    /// Method: Post\n    /// Version: Http1.1\n    /// Content type: application/x-www-form-urlencoded\n    static HttpRequestPtr newHttpFormPostRequest();\n\n    /// Create a http file upload request with:\n    /// Method: Post\n    /// Version: Http1.1\n    /// Content type: multipart/form-data\n    /// The @param files represents pload files which are transferred to the\n    /// server via the multipart/form-data format\n    static HttpRequestPtr newFileUploadRequest(\n        const std::vector<UploadFile> &files);\n\n    /**\n     * @brief Create a custom HTTP request object. For using this template,\n     * users must specialize the toRequest template.\n     */\n    template <typename T>\n    static HttpRequestPtr newCustomHttpRequest(T &&obj)\n    {\n        return toRequest(std::forward<T>(obj));\n    }\n\n    virtual bool isOnSecureConnection() const noexcept = 0;\n    virtual void setContentTypeString(const char *typeString,\n                                      size_t typeStringLength) = 0;\n\n    virtual ~HttpRequest()\n    {\n    }\n};\n\ntemplate <>\ninline HttpRequestPtr toRequest<const Json::Value &>(const Json::Value &pJson)\n{\n    return HttpRequest::newHttpJsonRequest(pJson);\n}\n\ntemplate <>\ninline HttpRequestPtr toRequest(Json::Value &&pJson)\n{\n    return HttpRequest::newHttpJsonRequest(std::move(pJson));\n}\n\ntemplate <>\ninline std::shared_ptr<Json::Value> fromRequest(const HttpRequest &req)\n{\n    return req.getJsonObject();\n}\n\n}  // namespace drogon\n", "/**\n *  @file HttpResponse.h\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include <drogon/exports.h>\n#include <drogon/utils/string_view.h>\n#include <drogon/DrClassMap.h>\n#include <drogon/Cookie.h>\n#include <drogon/HttpTypes.h>\n#include <drogon/HttpViewData.h>\n#include <json/json.h>\n#include <memory>\n#include <string>\n\nnamespace drogon\n{\n/// Abstract class for webapp developer to get or set the Http response;\nclass HttpResponse;\nusing HttpResponsePtr = std::shared_ptr<HttpResponse>;\n\n/**\n * @brief This template is used to convert a response object to a custom\n * type object. Users must specialize the template for a particular type.\n */\ntemplate <typename T>\nT fromResponse(const HttpResponse &resp)\n{\n    LOG_ERROR\n        << \"You must specialize the fromResponse template for the type of \"\n        << DrClassMap::demangle(typeid(T).name());\n    exit(1);\n}\n\n/**\n * @brief This template is used to create a response object from a custom\n * type object by calling the newCustomHttpResponse(). Users must specialize\n * the template for a particular type.\n */\ntemplate <typename T>\nHttpResponsePtr toResponse(T &&)\n{\n    LOG_ERROR << \"You must specialize the toResponse template for the type of \"\n              << DrClassMap::demangle(typeid(T).name());\n    exit(1);\n}\ntemplate <>\nHttpResponsePtr toResponse<const Json::Value &>(const Json::Value &pJson);\ntemplate <>\nHttpResponsePtr toResponse(Json::Value &&pJson);\ntemplate <>\ninline HttpResponsePtr toResponse<Json::Value &>(Json::Value &pJson)\n{\n    return toResponse((const Json::Value &)pJson);\n}\n\nclass DROGON_EXPORT HttpResponse\n{\n  public:\n    /**\n     * @brief This template enables automatic type conversion. For using this\n     * template, user must specialize the fromResponse template. For example a\n     * shared_ptr<Json::Value> specialization version is available above, so\n     * we can use the following code to get a json object:\n     * @code\n     *  std::shared_ptr<Json::Value> jsonPtr = *responsePtr;\n     *  @endcode\n     * With this template, user can use their favorite JSON library instead of\n     * the default jsoncpp library or convert the response to an object of any\n     * custom type.\n     */\n    template <typename T>\n    operator T() const\n    {\n        return fromResponse<T>(*this);\n    }\n\n    /**\n     * @brief This template enables explicit type conversion, see the above\n     * template.\n     */\n    template <typename T>\n    T as() const\n    {\n        return fromResponse<T>(*this);\n    }\n\n    /// Get the status code such as 200, 404\n    virtual HttpStatusCode statusCode() const = 0;\n    HttpStatusCode getStatusCode() const\n    {\n        return statusCode();\n    }\n\n    /// Set the status code of the response.\n    virtual void setStatusCode(HttpStatusCode code) = 0;\n\n    void setCustomStatusCode(int code, string_view message = string_view{})\n    {\n        setCustomStatusCode(code, message.data(), message.length());\n    }\n\n    /// Get the creation timestamp of the response.\n    virtual const trantor::Date &creationDate() const = 0;\n    const trantor::Date &getCreationDate() const\n    {\n        return creationDate();\n    }\n\n    /// Set the http version, http1.0 or http1.1\n    virtual void setVersion(const Version v) = 0;\n\n    /// Set if close the connection after the request is sent.\n    /**\n     * @param on if the parameter is false, the connection keeps alive on the\n     * condition that the client request has a 'keep-alive' head, otherwise it\n     * is closed immediately after sending the last byte of the response. It's\n     * false by default when the response is created.\n     */\n    virtual void setCloseConnection(bool on) = 0;\n\n    /// Get the status set by the setCloseConnection() method.\n    virtual bool ifCloseConnection() const = 0;\n\n    /// Set the response content type, such as text/html, text/plain, image/png\n    /// and so on. If the content type\n    /// is a text type, the character set is utf8.\n    virtual void setContentTypeCode(ContentType type) = 0;\n\n    /// Set the content-type string, The string may contain the header name and\n    /// CRLF. Or just the MIME type For example, \"content-type: text/plain\\r\\n\"\n    /// or \"text/plain\"\n    void setContentTypeString(const string_view &typeString)\n    {\n        setContentTypeString(typeString.data(), typeString.size());\n    }\n\n    /// Set the response content type and the content-type string, The string\n    /// may contain the header name and CRLF. Or just the MIME type\n    /// For example, \"content-type: text/plain\\r\\n\" or \"text/plain\"\n    void setContentTypeCodeAndCustomString(ContentType type,\n                                           const string_view &typeString)\n    {\n        setContentTypeCodeAndCustomString(type,\n                                          typeString.data(),\n                                          typeString.length());\n    }\n    template <int N>\n    void setContentTypeCodeAndCustomString(ContentType type,\n                                           const char (&typeString)[N])\n    {\n        assert(N > 0);\n        setContentTypeCodeAndCustomString(type, typeString, N - 1);\n    }\n\n    /// Set the reponse content type and the character set.\n    /// virtual void setContentTypeCodeAndCharacterSet(ContentType type, const\n    /// std::string &charSet = \"utf-8\") = 0;\n\n    /// Get the response content type.\n    virtual ContentType contentType() const = 0;\n    ContentType getContentType() const\n    {\n        return contentType();\n    }\n\n    /// Get the header string identified by the key parameter.\n    /**\n     * @note\n     * If there is no the header, a empty string is retured.\n     * The key is case insensitive\n     */\n    virtual const std::string &getHeader(std::string key) const = 0;\n\n    /**\n     * @brief  Remove the header identified by the key parameter.\n     *\n     * @param key The key is case insensitive\n     */\n    virtual void removeHeader(std::string key) = 0;\n\n    /// Get all headers of the response\n    virtual const std::unordered_map<std::string, std::string> &headers()\n        const = 0;\n\n    /// Get all headers of the response\n    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }\n\n    /**\n     * @brief Set the header string identified by the field parameter\n     *\n     * @param field The field parameter is transformed to lower case before\n     * storing.\n     * @param value The value of the header.\n     */\n    virtual void addHeader(std::string field, const std::string &value) = 0;\n    virtual void addHeader(std::string field, std::string &&value) = 0;\n\n    /// Add a cookie\n    virtual void addCookie(const std::string &key,\n                           const std::string &value) = 0;\n\n    /// Add a cookie\n    virtual void addCookie(const Cookie &cookie) = 0;\n    virtual void addCookie(Cookie &&cookie) = 0;\n\n    /// Get the cookie identified by the key parameter.\n    /// If there is no the cookie, the empty cookie is retured.\n    virtual const Cookie &getCookie(const std::string &key) const = 0;\n\n    /// Get all cookies.\n    virtual const std::unordered_map<std::string, Cookie> &cookies() const = 0;\n\n    /// Get all cookies.\n    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }\n\n    /// Remove the cookie identified by the key parameter.\n    virtual void removeCookie(const std::string &key) = 0;\n\n    /// Set the response body(content).\n    /**\n     * @note The body must match the content type\n     */\n    virtual void setBody(const std::string &body) = 0;\n\n    /// Set the response body(content).\n    virtual void setBody(std::string &&body) = 0;\n\n    /// Set the response body(content).\n    template <int N>\n    void setBody(const char (&body)[N])\n    {\n        assert(strnlen(body, N) == N - 1);\n        setBody(body, N - 1);\n    }\n\n    /// Get the response body.\n    string_view body() const\n    {\n        return string_view{getBodyData(), getBodyLength()};\n    }\n\n    /// Get the response body.\n    string_view getBody() const\n    {\n        return body();\n    }\n\n    /// Return the string of http version of request, such as HTTP/1.0,\n    /// HTTP/1.1, etc.\n    virtual const char *versionString() const = 0;\n    const char *getVersionString() const\n    {\n        return versionString();\n    }\n\n    /// Return the enum type version of the response.\n    /**\n     * kHttp10 means Http version is 1.0\n     * kHttp11 means Http verison is 1.1\n     */\n    virtual Version version() const = 0;\n\n    /// Return the enum type version of the response.\n    Version getVersion() const\n    {\n        return version();\n    }\n\n    /// Reset the reponse object to its initial state\n    virtual void clear() = 0;\n\n    /// Set the expiration time of the response cache in memory.\n    /// in seconds, 0 means always cache, negative means not cache, default is\n    /// -1.\n    virtual void setExpiredTime(ssize_t expiredTime) = 0;\n\n    /// Get the expiration time of the response.\n    virtual ssize_t expiredTime() const = 0;\n    ssize_t getExpiredTime() const\n    {\n        return expiredTime();\n    }\n\n    /// Get the json object from the server response.\n    /// If the response is not in json format, then a empty shared_ptr is\n    /// retured.\n    virtual const std::shared_ptr<Json::Value> &jsonObject() const = 0;\n    const std::shared_ptr<Json::Value> &getJsonObject() const\n    {\n        return jsonObject();\n    }\n\n    /**\n     * @brief Get the error message of parsing the JSON body received from peer.\n     * This method usually is called after getting a empty shared_ptr object\n     * by the getJsonObject() method.\n     *\n     * @return const std::string& The error message. An empty string is returned\n     * when no error occurs.\n     */\n    virtual const std::string &getJsonError() const = 0;\n\n    /**\n     * @brief Set the reponse object to the pass-through mode or not. It's not\n     * by default when a new response object is created.\n     * In pass-through mode, no addtional headers (including server, date,\n     * content-type and content-length, etc.) are added to the response. This\n     * mode is useful for some applications such as a proxy.\n     *\n     * @param flag\n     */\n    virtual void setPassThrough(bool flag) = 0;\n\n    /* The following methods are a series of factory methods that help users\n     * create response objects. */\n\n    /// Create a normal response with a status code of 200ok and a content type\n    /// of text/html.\n    static HttpResponsePtr newHttpResponse();\n    /// Create a response which returns a 404 page.\n    static HttpResponsePtr newNotFoundResponse();\n    /// Create a response which returns a json object. Its content type is set\n    /// to set/json.\n    static HttpResponsePtr newHttpJsonResponse(const Json::Value &data);\n    static HttpResponsePtr newHttpJsonResponse(Json::Value &&data);\n    /// Create a response that returns a page rendered by a view named\n    /// viewName.\n    /**\n     * @param viewName The name of the view\n     * @param data is the data displayed on the page.\n     * @note For more details, see the wiki pages, the \"View\" section.\n     */\n    static HttpResponsePtr newHttpViewResponse(\n        const std::string &viewName,\n        const HttpViewData &data = HttpViewData());\n\n    /// Create a response that returns a redirection page, redirecting to\n    /// another page located in the location parameter.\n    /**\n     * @param location The location to redirect\n     * @param status The HTTP status code, k302Found by default. Users could set\n     * it to one of the 301, 302, 303, 307, ...\n     */\n    static HttpResponsePtr newRedirectionResponse(\n        const std::string &location,\n        HttpStatusCode status = k302Found);\n\n    /// Create a response that returns a file to the client.\n    /**\n     * @param fullPath is the full path to the file.\n     * @param attachmentFileName if the parameter is not empty, the browser\n     * does not open the file, but saves it as an attachment.\n     * @param type the content type code. If the parameter is CT_NONE, the\n     * content type is set by drogon based on the file extension and typeString.\n     * Set it to CT_CUSTOM when no drogon internal content type matches.\n     * @param typeString the MIME string of the content type.\n     */\n    static HttpResponsePtr newFileResponse(\n        const std::string &fullPath,\n        const std::string &attachmentFileName = \"\",\n        ContentType type = CT_NONE,\n        const std::string &typeString = \"\");\n\n    /// Create a response that returns part of a file to the client.\n    /**\n     * @brief If offset and length can not be satisfied, statusCode will be set\n     * to k416RequestedRangeNotSatisfiable, and nothing else will be modified.\n     *\n     * @param fullPath is the full path to the file.\n     * @param offset is the offset to begin sending, in bytes.\n     * @param length is the total length to send, in bytes. In particular,\n     * length = 0 means send all content from offset till end of file.\n     * @param setContentRange whether set 'Content-Range' header automatically.\n     * @param attachmentFileName if the parameter is not empty, the browser\n     * does not open the file, but saves it as an attachment.\n     * @param type the content type code. If the parameter is CT_NONE, the\n     * content type is set by drogon based on the file extension and typeString.\n     * Set it to CT_CUSTOM when no drogon internal content type matches.\n     * @param typeString the MIME string of the content type.\n     */\n    static HttpResponsePtr newFileResponse(\n        const std::string &fullPath,\n        size_t offset,\n        size_t length,\n        bool setContentRange = true,\n        const std::string &attachmentFileName = \"\",\n        ContentType type = CT_NONE,\n        const std::string &typeString = \"\");\n\n    /// Create a response that returns a file to the client from buffer in\n    /// memory/stack\n    /**\n     * @param pBuffer is a uint 8 bit flat buffer for object/files in memory\n     * @param bufferLength is the length of the expected buffer\n     * @param attachmentFileName if the parameter is not empty, the browser\n     * does not open the file, but saves it as an attachment.\n     * @param type the content type code. If the parameter is CT_NONE, the\n     * content type is set by drogon based on the file extension and typeString.\n     * Set it to CT_CUSTOM when no drogon internal content type matches.\n     * @param typeString the MIME string of the content type.\n     */\n    static HttpResponsePtr newFileResponse(\n        const unsigned char *pBuffer,\n        size_t bufferLength,\n        const std::string &attachmentFileName = \"\",\n        ContentType type = CT_NONE,\n        const std::string &typeString = \"\");\n\n    /// Create a response that returns a file to the client from a callback\n    /// function\n    /**\n     * @note if the Connection is keep-alive and the Content-Length header is\n     * not set, the stream data is sent with Transfer-Encoding: chunked.\n     * @param function to retrieve the stream data (stream ends when a zero size\n     * is returned) the callback will be called with nullptr when the send is\n     * finished/interruped so that it cleans up its internals.\n     * @param attachmentFileName if the parameter is not empty, the browser\n     *                           does not open the file, but saves it as an\n     * attachment.\n     * @param type the content type code. If the parameter is CT_NONE, the\n     *             content type is set by drogon based on the file extension and\n     * typeString. Set it to CT_CUSTOM when no drogon internal content type\n     * matches.\n     * @param typeString the MIME string of the content type.\n     */\n    static HttpResponsePtr newStreamResponse(\n        const std::function<std::size_t(char *, std::size_t)> &callback,\n        const std::string &attachmentFileName = \"\",\n        ContentType type = CT_NONE,\n        const std::string &typeString = \"\");\n\n    /**\n     * @brief Create a custom HTTP response object. For using this template,\n     * users must specialize the toResponse template.\n     */\n    template <typename T>\n    static HttpResponsePtr newCustomHttpResponse(T &&obj)\n    {\n        return toResponse(std::forward<T>(obj));\n    }\n\n    /**\n     * @brief If the response is a file response (i.e. created by\n     * newFileResponse) returns the path on the filesystem. Otherwise a\n     * empty string.\n     */\n    virtual const std::string &sendfileName() const = 0;\n\n    /**\n     * @brief Returns the range of the file response as a pair ot size_t\n     * (offset, length). Length of 0 means the entire file is sent. Behaivor of\n     * this function is undefined if the response if not a file response\n     */\n    using SendfileRange = std::pair<size_t, size_t>;  // { offset, length }\n    virtual const SendfileRange &sendfileRange() const = 0;\n\n    /**\n     * @brief If the response is a stream response (i.e. created by\n     * newStreamResponse) returns the callback function. Otherwise a\n     * null function.\n     */\n    virtual const std::function<std::size_t(char *, std::size_t)>\n        &streamCallback() const = 0;\n\n    /**\n     * @brief Returns the content type associated with the response\n     */\n    virtual std::string contentTypeString() const = 0;\n\n    virtual ~HttpResponse()\n    {\n    }\n\n  private:\n    virtual void setBody(const char *body, size_t len) = 0;\n    virtual const char *getBodyData() const = 0;\n    virtual size_t getBodyLength() const = 0;\n    virtual void setContentTypeCodeAndCustomString(ContentType type,\n                                                   const char *typeString,\n                                                   size_t typeStringLength) = 0;\n    virtual void setContentTypeString(const char *typeString,\n                                      size_t typeStringLength) = 0;\n    virtual void setCustomStatusCode(int code,\n                                     const char *message,\n                                     size_t messageLength) = 0;\n};\ntemplate <>\ninline HttpResponsePtr toResponse<const Json::Value &>(const Json::Value &pJson)\n{\n    return HttpResponse::newHttpJsonResponse(pJson);\n}\n\ntemplate <>\ninline HttpResponsePtr toResponse(Json::Value &&pJson)\n{\n    return HttpResponse::newHttpJsonResponse(std::move(pJson));\n}\n\ntemplate <>\ninline std::shared_ptr<Json::Value> fromResponse(const HttpResponse &resp)\n{\n    return resp.getJsonObject();\n}\n}  // namespace drogon\n", "/**\n *\n *  @file Utilities.h\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include <drogon/exports.h>\n#include <trantor/utils/Date.h>\n#include <trantor/utils/Funcs.h>\n#include <trantor/utils/Utilities.h>\n#include <drogon/utils/string_view.h>\n#include <memory>\n#include <string>\n#include <vector>\n#include <set>\n#include <limits>\n#include <sstream>\n#include <algorithm>\n#ifdef _WIN32\n#include <time.h>\nDROGON_EXPORT char *strptime(const char *s, const char *f, struct tm *tm);\nDROGON_EXPORT time_t timegm(struct tm *tm);\n#endif\nnamespace drogon\n{\nnamespace internal\n{\ntemplate <typename T>\nstruct CanConvertFromStringStream\n{\n  private:\n    using yes = std::true_type;\n    using no = std::false_type;\n\n    template <typename U>\n    static auto test(U *p, std::stringstream &&ss)\n        -> decltype((ss >> *p), yes());\n\n    template <typename>\n    static no test(...);\n\n  public:\n    static constexpr bool value =\n        std::is_same<decltype(test<T>(nullptr, std::stringstream())),\n                     yes>::value;\n};\n}  // namespace internal\nnamespace utils\n{\n/// Determine if the string is an integer\nDROGON_EXPORT bool isInteger(const std::string &str);\n\n/// Generate random a string\n/**\n * @param length The string length\n * The returned string consists of uppercase and lowercase letters and numbers\n */\nDROGON_EXPORT std::string genRandomString(int length);\n\n/// Convert a binary string to hex format\nDROGON_EXPORT std::string binaryStringToHex(const unsigned char *ptr,\n                                            size_t length);\n\n/// Get a binary string from hexadecimal format\nDROGON_EXPORT std::string hexToBinaryString(const char *ptr, size_t length);\n\n/// Get a binary vector from hexadecimal format\nDROGON_EXPORT std::vector<char> hexToBinaryVector(const char *ptr,\n                                                  size_t length);\n\n/// Split the string into multiple separated strings.\n/**\n * @param acceptEmptyString if true, empty strings are accepted in the\n * result, for example, splitting the \",1,2,,3,\" by \",\" produces\n * [\"\",\"1\",\"2\",\"\",\"3\",\"\"]\n */\ninline std::vector<std::string> splitString(const std::string &str,\n                                            const std::string &separator,\n                                            bool acceptEmptyString = false)\n{\n    return trantor::splitString(str, separator, acceptEmptyString);\n}\n\nDROGON_EXPORT std::set<std::string> splitStringToSet(\n    const std::string &str,\n    const std::string &separator);\n\n/// Get UUID string.\nDROGON_EXPORT std::string getUuid();\n\n/// Encode the string to base64 format.\nDROGON_EXPORT std::string base64Encode(const unsigned char *bytes_to_encode,\n                                       unsigned int in_len,\n                                       bool url_safe = false);\n\n/// Decode the base64 format string.\nDROGON_EXPORT std::string base64Decode(const std::string &encoded_string);\nDROGON_EXPORT std::vector<char> base64DecodeToVector(\n    const std::string &encoded_string);\n\n/// Check if the string need decoding\nDROGON_EXPORT bool needUrlDecoding(const char *begin, const char *end);\n\n/// Decode from or encode to the URL format string\nDROGON_EXPORT std::string urlDecode(const char *begin, const char *end);\ninline std::string urlDecode(const std::string &szToDecode)\n{\n    auto begin = szToDecode.data();\n    return urlDecode(begin, begin + szToDecode.length());\n}\ninline std::string urlDecode(const string_view &szToDecode)\n{\n    auto begin = szToDecode.data();\n    return urlDecode(begin, begin + szToDecode.length());\n}\n\nDROGON_EXPORT std::string urlEncode(const std::string &);\nDROGON_EXPORT std::string urlEncodeComponent(const std::string &);\n\n/// Get the MD5 digest of a string.\nDROGON_EXPORT std::string getMd5(const char *data, const size_t dataLen);\ninline std::string getMd5(const std::string &originalString)\n{\n    return getMd5(originalString.data(), originalString.length());\n}\n\n/// Commpress or decompress data using gzip lib.\n/**\n * @param data the input data\n * @param ndata the input data length\n */\nDROGON_EXPORT std::string gzipCompress(const char *data, const size_t ndata);\nDROGON_EXPORT std::string gzipDecompress(const char *data, const size_t ndata);\n\n/// Commpress or decompress data using brotli lib.\n/**\n * @param data the input data\n * @param ndata the input data length\n */\nDROGON_EXPORT std::string brotliCompress(const char *data, const size_t ndata);\nDROGON_EXPORT std::string brotliDecompress(const char *data,\n                                           const size_t ndata);\n\n/// Get the http full date string\n/**\n * rfc2616-3.3.1\n * Full Date format(RFC 822)\n * like this:\n * @code\n   Sun, 06 Nov 1994 08:49:37 GMT\n   Wed, 12 Sep 2018 09:22:40 GMT\n   @endcode\n */\nDROGON_EXPORT char *getHttpFullDate(\n    const trantor::Date &date = trantor::Date::now());\n\n/// Get the trantor::Date object according to the http full date string\n/**\n * Returns trantor::Date(std::numeric_limits<int64_t>::max()) upon failure.\n */\nDROGON_EXPORT trantor::Date getHttpDate(const std::string &httpFullDateString);\n\n/// Get a formatted string\nDROGON_EXPORT std::string formattedString(const char *format, ...);\n\n/// Recursively create a file system path\n/**\n * Return 0 or -1 on success or failure.\n */\nDROGON_EXPORT int createPath(const std::string &path);\n\n/**\n * @details Convert a wide string path with arbitrary directory separators\n * to a UTF-8 portable path for use with trantor.\n *\n * This is a helper, mainly for Windows and multi-platform projects.\n *\n * @note On Windows, backslash directory separators are converted to slash to\n * keep portable paths.\n *\n * @remarks On other OSes, backslashes are not converted to slash, since they\n * are valid characters for directory/file names.\n *\n * @param strPath Wide string path.\n *\n * @return std::string UTF-8 path, with slash directory separator.\n */\ninline std::string fromWidePath(const std::wstring &strPath)\n{\n    return trantor::utils::fromWidePath(strPath);\n}\n\n/**\n * @details Convert a UTF-8 path with arbitrary directory separator to a wide\n * string path.\n *\n * This is a helper, mainly for Windows and multi-platform projects.\n *\n * @note On Windows, slash directory separators are converted to backslash.\n * Although it accepts both slash and backslash as directory separator in its\n * API, it is better to stick to its standard.\n\n * @remarks On other OSes, slashes are not converted to backslashes, since they\n * are not interpreted as directory separators and are valid characters for\n * directory/file names.\n *\n * @param strUtf8Path Ascii path considered as being UTF-8.\n *\n * @return std::wstring path with, on windows, standard backslash directory\n * separator to stick to its standard.\n */\ninline std::wstring toWidePath(const std::string &strUtf8Path)\n{\n    return trantor::utils::toWidePath(strUtf8Path);\n}\n\n/**\n * @brief Convert a generic (UTF-8) path with to an OS native path.\n * @details This is a helper, mainly for Windows and multi-platform projects.\n *\n * On Windows, slash directory separators are converted to backslash, and a\n * wide string is returned.\n *\n * On other OSes, returns an UTF-8 string _without_ altering the directory\n * separators.\n *\n * @param strPath Wide string or UTF-8 path.\n *\n * @return An OS path, suitable for use with the OS API.\n */\n#if defined(_WIN32) && !defined(__MINGW32__)\ninline std::wstring toNativePath(const std::string &strPath)\n{\n    return trantor::utils::toNativePath(strPath);\n}\ninline const std::wstring &toNativePath(const std::wstring &strPath)\n{\n    return trantor::utils::toNativePath(strPath);\n}\n#else   // __WIN32\ninline const std::string &toNativePath(const std::string &strPath)\n{\n    return trantor::utils::toNativePath(strPath);\n}\ninline std::string toNativePath(const std::wstring &strPath)\n{\n    return trantor::utils::toNativePath(strPath);\n}\n#endif  // _WIN32\n/**\n * @brief Convert a OS native path (wide string on Windows) to a generic UTF-8\n * path.\n * @details This is a helper, mainly for Windows and multi-platform projects.\n *\n * On Windows, backslash directory separators are converted to slash, and a\n * a UTF-8 string is returned, suitable for libraries that supports UTF-8 paths\n * like OpenSSL or drogon.\n *\n * On other OSes, returns an UTF-8 string without altering the directory\n * separators (backslashes are *NOT* replaced with slashes, since they\n * are valid characters for directory/file names).\n *\n * @param strPath Wide string or UTF-8 path.\n *\n * @return A generic path.\n */\ninline const std::string &fromNativePath(const std::string &strPath)\n{\n    return trantor::utils::fromNativePath(strPath);\n}\n// Convert on all systems\ninline std::string fromNativePath(const std::wstring &strPath)\n{\n    return trantor::utils::fromNativePath(strPath);\n}\n\n/// Replace all occurances of from to to inplace\n/**\n * @param from string to replace\n * @param to string to replace with\n */\nDROGON_EXPORT void replaceAll(std::string &s,\n                              const std::string &from,\n                              const std::string &to);\n\n/**\n * @brief Generates cryptographically secure random bytes.\n *\n * @param ptr the pointer which the random bytes are stored to\n * @param size number of bytes to generate\n *\n * @return true if generation is successfull. False otherwise\n *\n * @note DO NOT abuse this function. Especially if Drogon is built without\n * OpenSSL. Entropy running low is a real issue.\n */\nDROGON_EXPORT bool secureRandomBytes(void *ptr, size_t size);\n\ntemplate <typename T>\ntypename std::enable_if<internal::CanConvertFromStringStream<T>::value, T>::type\nfromString(const std::string &p) noexcept(false)\n{\n    T value{};\n    if (!p.empty())\n    {\n        std::stringstream ss(p);\n        ss >> value;\n    }\n    return value;\n}\n\ntemplate <typename T>\ntypename std::enable_if<!(internal::CanConvertFromStringStream<T>::value),\n                        T>::type\nfromString(const std::string &) noexcept(false)\n{\n    throw std::runtime_error(\"Bad type conversion\");\n}\n\ntemplate <>\ninline std::string fromString<std::string>(const std::string &p) noexcept(false)\n{\n    return p;\n}\n\ntemplate <>\ninline int fromString<int>(const std::string &p) noexcept(false)\n{\n    return std::stoi(p);\n}\n\ntemplate <>\ninline long fromString<long>(const std::string &p) noexcept(false)\n{\n    return std::stol(p);\n}\n\ntemplate <>\ninline long long fromString<long long>(const std::string &p) noexcept(false)\n{\n    return std::stoll(p);\n}\n\ntemplate <>\ninline unsigned long fromString<unsigned long>(const std::string &p) noexcept(\n    false)\n{\n    return std::stoul(p);\n}\n\ntemplate <>\ninline unsigned long long fromString<unsigned long long>(\n    const std::string &p) noexcept(false)\n{\n    return std::stoull(p);\n}\n\ntemplate <>\ninline float fromString<float>(const std::string &p) noexcept(false)\n{\n    return std::stof(p);\n}\n\ntemplate <>\ninline double fromString<double>(const std::string &p) noexcept(false)\n{\n    return std::stod(p);\n}\n\ntemplate <>\ninline long double fromString<long double>(const std::string &p) noexcept(false)\n{\n    return std::stold(p);\n}\n\ntemplate <>\ninline bool fromString<bool>(const std::string &p) noexcept(false)\n{\n    if (p == \"1\")\n    {\n        return true;\n    }\n    if (p == \"0\")\n    {\n        return false;\n    }\n    std::string l{p};\n    std::transform(p.begin(), p.end(), l.begin(), [](unsigned char c) {\n        return tolower(c);\n    });\n    if (l == \"true\")\n    {\n        return true;\n    }\n    else if (l == \"false\")\n    {\n        return false;\n    }\n    throw std::runtime_error(\"Can't convert from string '\" + p + \"' to bool\");\n}\n}  // namespace utils\n}  // namespace drogon\n", "/**\n *\n *  @file HttpRequestImpl.h\n *  An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include \"HttpUtils.h\"\n#include \"CacheFile.h\"\n#include <drogon/utils/Utilities.h>\n#include <drogon/HttpRequest.h>\n#include <drogon/utils/Utilities.h>\n#include <trantor/net/EventLoop.h>\n#include <trantor/net/InetAddress.h>\n#include <trantor/utils/Logger.h>\n#include <trantor/utils/MsgBuffer.h>\n#include <trantor/utils/NonCopyable.h>\n#include <algorithm>\n#include <string>\n#include <thread>\n#include <unordered_map>\n#include <assert.h>\n#include <stdio.h>\n\nnamespace drogon\n{\nenum class StreamDecompressStatus\n{\n    TooLarge,\n    DecompressError,\n    NotSupported,\n    Ok\n};\n\nclass HttpRequestImpl : public HttpRequest\n{\n  public:\n    friend class HttpRequestParser;\n\n    explicit HttpRequestImpl(trantor::EventLoop *loop)\n        : creationDate_(trantor::Date::now()), loop_(loop)\n    {\n    }\n    void reset()\n    {\n        method_ = Invalid;\n        version_ = Version::kUnknown;\n        flagForParsingJson_ = false;\n        headers_.clear();\n        cookies_.clear();\n        flagForParsingParameters_ = false;\n        path_.clear();\n        pathEncode_ = true;\n        matchedPathPattern_ = \"\";\n        query_.clear();\n        parameters_.clear();\n        jsonPtr_.reset();\n        sessionPtr_.reset();\n        attributesPtr_.reset();\n        cacheFilePtr_.reset();\n        expectPtr_.reset();\n        content_.clear();\n        contentType_ = CT_TEXT_PLAIN;\n        flagForParsingContentType_ = false;\n        contentTypeString_.clear();\n        keepAlive_ = true;\n        jsonParsingErrorPtr_.reset();\n    }\n    trantor::EventLoop *getLoop()\n    {\n        return loop_;\n    }\n\n    void setVersion(Version v)\n    {\n        version_ = v;\n        if (version_ == Version::kHttp10)\n        {\n            keepAlive_ = false;\n        }\n    }\n\n    Version version() const override\n    {\n        return version_;\n    }\n\n    const char *versionString() const override;\n\n    bool setMethod(const char *start, const char *end);\n    void setSecure(bool secure)\n    {\n        isOnSecureConnection_ = secure;\n    }\n\n    void setMethod(const HttpMethod method) override\n    {\n        method_ = method;\n        return;\n    }\n\n    HttpMethod method() const override\n    {\n        return method_;\n    }\n\n    const char *methodString() const override;\n\n    void setPath(const char *start, const char *end)\n    {\n        if (utils::needUrlDecoding(start, end))\n        {\n            path_ = utils::urlDecode(start, end);\n        }\n        else\n        {\n            path_.append(start, end);\n        }\n    }\n\n    void setPath(const std::string &path) override\n    {\n        path_ = path;\n    }\n\n    void setPathEncode(bool pathEncode) override\n    {\n        pathEncode_ = pathEncode;\n    }\n\n    const std::unordered_map<std::string, std::string> &parameters()\n        const override\n    {\n        parseParametersOnce();\n        return parameters_;\n    }\n\n    const std::string &getParameter(const std::string &key) const override\n    {\n        const static std::string defaultVal;\n        parseParametersOnce();\n        auto iter = parameters_.find(key);\n        if (iter != parameters_.end())\n            return iter->second;\n        return defaultVal;\n    }\n\n    const std::string &path() const override\n    {\n        return path_;\n    }\n\n    void setQuery(const char *start, const char *end)\n    {\n        query_.assign(start, end);\n    }\n\n    void setQuery(const std::string &query)\n    {\n        query_ = query;\n    }\n\n    string_view bodyView() const\n    {\n        if (cacheFilePtr_)\n        {\n            return cacheFilePtr_->getStringView();\n        }\n        return content_;\n    }\n    const char *bodyData() const override\n    {\n        if (cacheFilePtr_)\n        {\n            return cacheFilePtr_->getStringView().data();\n        }\n        return content_.data();\n    }\n    size_t bodyLength() const override\n    {\n        if (cacheFilePtr_)\n        {\n            return cacheFilePtr_->getStringView().length();\n        }\n        return content_.length();\n    }\n\n    void appendToBody(const char *data, size_t length);\n\n    void reserveBodySize(size_t length);\n\n    string_view queryView() const\n    {\n        return query_;\n    }\n\n    string_view contentView() const\n    {\n        if (cacheFilePtr_)\n            return cacheFilePtr_->getStringView();\n        return content_;\n    }\n\n    const std::string &query() const override\n    {\n        return query_;\n    }\n\n    const trantor::InetAddress &peerAddr() const override\n    {\n        return peer_;\n    }\n\n    const trantor::InetAddress &localAddr() const override\n    {\n        return local_;\n    }\n\n    const trantor::Date &creationDate() const override\n    {\n        return creationDate_;\n    }\n\n    void setCreationDate(const trantor::Date &date)\n    {\n        creationDate_ = date;\n    }\n\n    void setPeerAddr(const trantor::InetAddress &peer)\n    {\n        peer_ = peer;\n    }\n\n    void setLocalAddr(const trantor::InetAddress &local)\n    {\n        local_ = local;\n    }\n\n    void addHeader(const char *start, const char *colon, const char *end);\n\n    void removeHeader(std::string key) override\n    {\n        transform(key.begin(), key.end(), key.begin(), [](unsigned char c) {\n            return tolower(c);\n        });\n        removeHeaderBy(key);\n    }\n\n    void removeHeaderBy(const std::string &lowerKey)\n    {\n        headers_.erase(lowerKey);\n    }\n\n    const std::string &getHeader(std::string field) const override\n    {\n        std::transform(field.begin(),\n                       field.end(),\n                       field.begin(),\n                       [](unsigned char c) { return tolower(c); });\n        return getHeaderBy(field);\n    }\n\n    const std::string &getHeaderBy(const std::string &lowerField) const\n    {\n        const static std::string defaultVal;\n        auto it = headers_.find(lowerField);\n        if (it != headers_.end())\n        {\n            return it->second;\n        }\n        return defaultVal;\n    }\n\n    const std::string &getCookie(const std::string &field) const override\n    {\n        const static std::string defaultVal;\n        auto it = cookies_.find(field);\n        if (it != cookies_.end())\n        {\n            return it->second;\n        }\n        return defaultVal;\n    }\n\n    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }\n\n    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }\n\n    void setParameter(const std::string &key, const std::string &value) override\n    {\n        flagForParsingParameters_ = true;\n        parameters_[key] = value;\n    }\n\n    const std::string &getContent() const\n    {\n        return content_;\n    }\n\n    void swap(HttpRequestImpl &that) noexcept;\n\n    void setContent(const std::string &content)\n    {\n        content_ = content;\n    }\n\n    void setBody(const std::string &body) override\n    {\n        content_ = body;\n    }\n\n    void setBody(std::string &&body) override\n    {\n        content_ = std::move(body);\n    }\n\n    void addHeader(std::string field, const std::string &value) override\n    {\n        transform(field.begin(),\n                  field.end(),\n                  field.begin(),\n                  [](unsigned char c) { return tolower(c); });\n        headers_[std::move(field)] = value;\n    }\n\n    void addHeader(std::string field, std::string &&value) override\n    {\n        transform(field.begin(),\n                  field.end(),\n                  field.begin(),\n                  [](unsigned char c) { return tolower(c); });\n        headers_[std::move(field)] = std::move(value);\n    }\n\n    void addCookie(const std::string &key, const std::string &value) override\n    {\n        cookies_[key] = value;\n    }\n\n    void setPassThrough(bool flag) override\n    {\n        passThrough_ = flag;\n    }\n\n    bool passThrough() const\n    {\n        return passThrough_;\n    }\n\n    void appendToBuffer(trantor::MsgBuffer *output) const;\n\n    const SessionPtr &session() const override\n    {\n        return sessionPtr_;\n    }\n\n    void setSession(const SessionPtr &session)\n    {\n        sessionPtr_ = session;\n    }\n\n    const AttributesPtr &attributes() const override\n    {\n        if (!attributesPtr_)\n        {\n            attributesPtr_ = std::make_shared<Attributes>();\n        }\n        return attributesPtr_;\n    }\n\n    const std::shared_ptr<Json::Value> &jsonObject() const override\n    {\n        // Not multi-thread safe but good, because we basically call this\n        // function in a single thread\n        if (!flagForParsingJson_)\n        {\n            flagForParsingJson_ = true;\n            parseJson();\n        }\n        return jsonPtr_;\n    }\n\n    void setCustomContentTypeString(const std::string &type) override\n    {\n        contentType_ = CT_NONE;\n        flagForParsingContentType_ = true;\n        bool haveHeader = type.find(\"content-type: \") == 0;\n        bool haveCRLF = type.rfind(\"\\r\\n\") == type.size() - 2;\n\n        size_t endOffset = 0;\n        if (haveHeader)\n            endOffset += 14;\n        if (haveCRLF)\n            endOffset += 2;\n        contentTypeString_ = std::string(type.begin() + (haveHeader ? 14 : 0),\n                                         type.end() - endOffset);\n    }\n    void setContentTypeCode(const ContentType type) override\n    {\n        contentType_ = type;\n        flagForParsingContentType_ = true;\n        auto &typeStr = contentTypeToMime(type);\n        setContentType(std::string(typeStr.data(), typeStr.length()));\n    }\n\n    void setContentTypeString(const char *typeString,\n                              size_t typeStringLength) override;\n\n    // void setContentTypeCodeAndCharacterSet(ContentType type, const\n    // std::string &charSet = \"utf-8\") override\n    // {\n    //     contentType_ = type;\n    //     setContentType(webContentTypeAndCharsetToString(type, charSet));\n    // }\n\n    ContentType contentType() const override\n    {\n        parseContentTypeAndString();\n        return contentType_;\n    }\n\n    const char *matchedPathPatternData() const override\n    {\n        return matchedPathPattern_.data();\n    }\n    size_t matchedPathPatternLength() const override\n    {\n        return matchedPathPattern_.length();\n    }\n\n    void setMatchedPathPattern(const std::string &pathPattern)\n    {\n        matchedPathPattern_ = pathPattern;\n    }\n    const std::string &expect() const\n    {\n        const static std::string none{\"\"};\n        if (expectPtr_)\n            return *expectPtr_;\n        return none;\n    }\n    bool keepAlive() const\n    {\n        return keepAlive_;\n    }\n    bool isOnSecureConnection() const noexcept override\n    {\n        return isOnSecureConnection_;\n    }\n    const std::string &getJsonError() const override\n    {\n        const static std::string none{\"\"};\n        if (jsonParsingErrorPtr_)\n            return *jsonParsingErrorPtr_;\n        return none;\n    }\n    StreamDecompressStatus decompressBody();\n\n    ~HttpRequestImpl();\n\n  protected:\n    friend class HttpRequest;\n    void setContentType(const std::string &contentType)\n    {\n        contentTypeString_ = contentType;\n    }\n    void setContentType(std::string &&contentType)\n    {\n        contentTypeString_ = std::move(contentType);\n    }\n\n    void parseContentTypeAndString() const\n    {\n        if (!flagForParsingContentType_)\n        {\n            flagForParsingContentType_ = true;\n            auto &contentTypeString = getHeaderBy(\"content-type\");\n            if (contentTypeString == \"\")\n            {\n                contentType_ = CT_NONE;\n            }\n            else\n            {\n                auto pos = contentTypeString.find(';');\n                if (pos != std::string::npos)\n                {\n                    contentType_ = parseContentType(\n                        string_view(contentTypeString.data(), pos));\n                }\n                else\n                {\n                    contentType_ =\n                        parseContentType(string_view(contentTypeString));\n                }\n\n                if (contentType_ == CT_NONE)\n                    contentType_ = CT_CUSTOM;\n                contentTypeString_ = contentTypeString;\n            }\n        }\n    }\n\n  private:\n    void parseParameters() const;\n    void parseParametersOnce() const\n    {\n        // Not multi-thread safe but good, because we basically call this\n        // function in a single thread\n        if (!flagForParsingParameters_)\n        {\n            flagForParsingParameters_ = true;\n            parseParameters();\n        }\n    }\n    void createTmpFile();\n    void parseJson() const;\n#ifdef USE_BROTLI\n    StreamDecompressStatus decompressBodyBrotli() noexcept;\n#endif\n    StreamDecompressStatus decompressBodyGzip() noexcept;\n    mutable bool flagForParsingParameters_{false};\n    mutable bool flagForParsingJson_{false};\n    HttpMethod method_{Invalid};\n    Version version_{Version::kUnknown};\n    std::string path_;\n    bool pathEncode_{true};\n    string_view matchedPathPattern_{\"\"};\n    std::string query_;\n    std::unordered_map<std::string, std::string> headers_;\n    std::unordered_map<std::string, std::string> cookies_;\n    mutable std::unordered_map<std::string, std::string> parameters_;\n    mutable std::shared_ptr<Json::Value> jsonPtr_;\n    SessionPtr sessionPtr_;\n    mutable AttributesPtr attributesPtr_;\n    trantor::InetAddress peer_;\n    trantor::InetAddress local_;\n    trantor::Date creationDate_;\n    std::unique_ptr<CacheFile> cacheFilePtr_;\n    mutable std::unique_ptr<std::string> jsonParsingErrorPtr_;\n    std::unique_ptr<std::string> expectPtr_;\n    bool keepAlive_{true};\n    bool isOnSecureConnection_{false};\n    bool passThrough_{false};\n\n  protected:\n    std::string content_;\n    trantor::EventLoop *loop_;\n    mutable ContentType contentType_{CT_TEXT_PLAIN};\n    mutable bool flagForParsingContentType_{false};\n    mutable std::string contentTypeString_;\n};\n\nusing HttpRequestImplPtr = std::shared_ptr<HttpRequestImpl>;\n\ninline void swap(HttpRequestImpl &one, HttpRequestImpl &two) noexcept\n{\n    one.swap(two);\n}\n\n}  // namespace drogon\n", "/**\n *\n *  @file HttpResponseImpl.h\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include \"HttpUtils.h\"\n#include \"HttpMessageBody.h\"\n#include <drogon/exports.h>\n#include <drogon/HttpResponse.h>\n#include <drogon/utils/Utilities.h>\n#include <trantor/net/InetAddress.h>\n#include <trantor/utils/Date.h>\n#include <trantor/utils/MsgBuffer.h>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <atomic>\n#include <unordered_map>\n\nnamespace drogon\n{\nclass DROGON_EXPORT HttpResponseImpl : public HttpResponse\n{\n    friend class HttpResponseParser;\n\n  public:\n    HttpResponseImpl() : creationDate_(trantor::Date::now())\n    {\n    }\n    HttpResponseImpl(HttpStatusCode code, ContentType type)\n        : statusCode_(code),\n          statusMessage_(statusCodeToString(code)),\n          creationDate_(trantor::Date::now()),\n          contentType_(type),\n          flagForParsingContentType_(true),\n          contentTypeString_(contentTypeToMime(type))\n    {\n    }\n    void setPassThrough(bool flag) override\n    {\n        passThrough_ = flag;\n    }\n    HttpStatusCode statusCode() const override\n    {\n        return statusCode_;\n    }\n\n    const trantor::Date &creationDate() const override\n    {\n        return creationDate_;\n    }\n\n    void setStatusCode(HttpStatusCode code) override\n    {\n        statusCode_ = code;\n        setStatusMessage(statusCodeToString(code));\n    }\n\n    void setVersion(const Version v) override\n    {\n        version_ = v;\n        if (version_ == Version::kHttp10)\n        {\n            closeConnection_ = true;\n        }\n    }\n\n    Version version() const override\n    {\n        return version_;\n    }\n\n    const char *versionString() const override;\n\n    void setCloseConnection(bool on) override\n    {\n        closeConnection_ = on;\n    }\n\n    bool ifCloseConnection() const override\n    {\n        return closeConnection_;\n    }\n\n    void setContentTypeCode(ContentType type) override\n    {\n        contentType_ = type;\n        auto ct = contentTypeToMime(type);\n        contentTypeString_ = std::string(ct.data(), ct.size());\n        flagForParsingContentType_ = true;\n    }\n\n    //  void setContentTypeCodeAndCharacterSet(ContentType type, const\n    // std::string &charSet = \"utf-8\") override\n    // {\n    //     contentType_ = type;\n    //     setContentType(webContentTypeAndCharsetToString(type, charSet));\n    // }\n\n    ContentType contentType() const override\n    {\n        parseContentTypeAndString();\n        return contentType_;\n    }\n\n    const std::string &getHeader(std::string key) const override\n    {\n        transform(key.begin(), key.end(), key.begin(), [](unsigned char c) {\n            return tolower(c);\n        });\n        return getHeaderBy(key);\n    }\n\n    void removeHeader(std::string key) override\n    {\n        transform(key.begin(), key.end(), key.begin(), [](unsigned char c) {\n            return tolower(c);\n        });\n        removeHeaderBy(key);\n    }\n\n    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }\n\n    const std::string &getHeaderBy(const std::string &lowerKey) const\n    {\n        const static std::string defaultVal;\n        auto iter = headers_.find(lowerKey);\n        if (iter == headers_.end())\n        {\n            return defaultVal;\n        }\n        return iter->second;\n    }\n\n    void removeHeaderBy(const std::string &lowerKey)\n    {\n        fullHeaderString_.reset();\n        headers_.erase(lowerKey);\n    }\n\n    void addHeader(std::string field, const std::string &value) override\n    {\n        fullHeaderString_.reset();\n        transform(field.begin(),\n                  field.end(),\n                  field.begin(),\n                  [](unsigned char c) { return tolower(c); });\n        headers_[std::move(field)] = value;\n    }\n\n    void addHeader(std::string field, std::string &&value) override\n    {\n        fullHeaderString_.reset();\n        transform(field.begin(),\n                  field.end(),\n                  field.begin(),\n                  [](unsigned char c) { return tolower(c); });\n        headers_[std::move(field)] = std::move(value);\n    }\n\n    void addHeader(const char *start, const char *colon, const char *end);\n\n    void addCookie(const std::string &key, const std::string &value) override\n    {\n        cookies_[key] = Cookie(key, value);\n    }\n\n    void addCookie(const Cookie &cookie) override\n    {\n        cookies_[cookie.key()] = cookie;\n    }\n\n    void addCookie(Cookie &&cookie) override\n    {\n        cookies_[cookie.key()] = std::move(cookie);\n    }\n\n    const Cookie &getCookie(const std::string &key) const override\n    {\n        static const Cookie defaultCookie;\n        auto it = cookies_.find(key);\n        if (it != cookies_.end())\n        {\n            return it->second;\n        }\n        return defaultCookie;\n    }\n\n    const std::unordered_map<std::string, Cookie> &cookies() const override\n    {\n        return cookies_;\n    }\n\n    void removeCookie(const std::string &key) override\n    {\n        cookies_.erase(key);\n    }\n\n    void setBody(const std::string &body) override\n    {\n        bodyPtr_ = std::make_shared<HttpMessageStringBody>(body);\n        if (passThrough_)\n        {\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n    void setBody(std::string &&body) override\n    {\n        bodyPtr_ = std::make_shared<HttpMessageStringBody>(std::move(body));\n        if (passThrough_)\n        {\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n\n    void redirect(const std::string &url)\n    {\n        headers_[\"location\"] = url;\n    }\n    std::shared_ptr<trantor::MsgBuffer> renderToBuffer();\n    void renderToBuffer(trantor::MsgBuffer &buffer);\n    std::shared_ptr<trantor::MsgBuffer> renderHeaderForHeadMethod();\n    void clear() override;\n\n    void setExpiredTime(ssize_t expiredTime) override\n    {\n        expriedTime_ = expiredTime;\n        datePos_ = std::string::npos;\n        if (expriedTime_ < 0 && version_ == Version::kHttp10)\n        {\n            fullHeaderString_.reset();\n        }\n    }\n\n    ssize_t expiredTime() const override\n    {\n        return expriedTime_;\n    }\n\n    const char *getBodyData() const override\n    {\n        if (!flagForSerializingJson_ && jsonPtr_)\n        {\n            generateBodyFromJson();\n        }\n        else if (!bodyPtr_)\n        {\n            return nullptr;\n        }\n        return bodyPtr_->data();\n    }\n    size_t getBodyLength() const override\n    {\n        if (bodyPtr_)\n            return bodyPtr_->length();\n        return 0;\n    }\n\n    void swap(HttpResponseImpl &that) noexcept;\n    void parseJson() const;\n    const std::shared_ptr<Json::Value> &jsonObject() const override\n    {\n        // Not multi-thread safe but good, because we basically call this\n        // function in a single thread\n        if (!flagForParsingJson_)\n        {\n            flagForParsingJson_ = true;\n            parseJson();\n        }\n        return jsonPtr_;\n    }\n    const std::string &getJsonError() const override\n    {\n        const static std::string none;\n        if (jsonParsingErrorPtr_)\n            return *jsonParsingErrorPtr_;\n        return none;\n    }\n    void setJsonObject(const Json::Value &pJson)\n    {\n        flagForParsingJson_ = true;\n        flagForSerializingJson_ = false;\n        jsonPtr_ = std::make_shared<Json::Value>(pJson);\n    }\n    void setJsonObject(Json::Value &&pJson)\n    {\n        flagForParsingJson_ = true;\n        flagForSerializingJson_ = false;\n        jsonPtr_ = std::make_shared<Json::Value>(std::move(pJson));\n    }\n    bool shouldBeCompressed() const;\n    void generateBodyFromJson() const;\n    const std::string &sendfileName() const override\n    {\n        return sendfileName_;\n    }\n    const SendfileRange &sendfileRange() const override\n    {\n        return sendfileRange_;\n    }\n    void setSendfile(const std::string &filename)\n    {\n        sendfileName_ = filename;\n    }\n    void setSendfileRange(size_t offset, size_t len)\n    {\n        sendfileRange_.first = offset;\n        sendfileRange_.second = len;\n    }\n    const std::function<std::size_t(char *, std::size_t)> &streamCallback()\n        const override\n    {\n        return streamCallback_;\n    }\n    void setStreamCallback(\n        const std::function<std::size_t(char *, std::size_t)> &callback)\n    {\n        streamCallback_ = callback;\n    }\n    void makeHeaderString()\n    {\n        fullHeaderString_ = std::make_shared<trantor::MsgBuffer>(128);\n        makeHeaderString(*fullHeaderString_);\n    }\n\n    std::string contentTypeString() const override\n    {\n        parseContentTypeAndString();\n        return contentTypeString_;\n    }\n\n    void gunzip()\n    {\n        if (bodyPtr_)\n        {\n            auto gunzipBody =\n                utils::gzipDecompress(bodyPtr_->data(), bodyPtr_->length());\n            removeHeaderBy(\"content-encoding\");\n            bodyPtr_ =\n                std::make_shared<HttpMessageStringBody>(move(gunzipBody));\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n#ifdef USE_BROTLI\n    void brDecompress()\n    {\n        if (bodyPtr_)\n        {\n            auto gunzipBody =\n                utils::brotliDecompress(bodyPtr_->data(), bodyPtr_->length());\n            removeHeaderBy(\"content-encoding\");\n            bodyPtr_ =\n                std::make_shared<HttpMessageStringBody>(move(gunzipBody));\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n#endif\n    ~HttpResponseImpl() override = default;\n\n  protected:\n    void makeHeaderString(trantor::MsgBuffer &headerString);\n\n    void parseContentTypeAndString() const\n    {\n        if (!flagForParsingContentType_)\n        {\n            flagForParsingContentType_ = true;\n            auto &contentTypeString = getHeaderBy(\"content-type\");\n            if (contentTypeString == \"\")\n            {\n                contentType_ = CT_NONE;\n            }\n            else\n            {\n                auto pos = contentTypeString.find(';');\n                if (pos != std::string::npos)\n                {\n                    contentType_ = parseContentType(\n                        string_view(contentTypeString.data(), pos));\n                }\n                else\n                {\n                    contentType_ =\n                        parseContentType(string_view(contentTypeString));\n                }\n\n                if (contentType_ == CT_NONE)\n                    contentType_ = CT_CUSTOM;\n                contentTypeString_ = contentTypeString;\n            }\n        }\n    }\n\n  private:\n    void setBody(const char *body, size_t len) override\n    {\n        bodyPtr_ = std::make_shared<HttpMessageStringViewBody>(body, len);\n        if (passThrough_)\n        {\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n    void setContentTypeCodeAndCustomString(ContentType type,\n                                           const char *typeString,\n                                           size_t typeStringLength) override\n    {\n        contentType_ = type;\n        flagForParsingContentType_ = true;\n\n        string_view sv(typeString, typeStringLength);\n        bool haveHeader = sv.find(\"content-type: \") == 0;\n        bool haveCRLF = sv.rfind(\"\\r\\n\") == sv.size() - 2;\n\n        size_t endOffset = 0;\n        if (haveHeader)\n            endOffset += 14;\n        if (haveCRLF)\n            endOffset += 2;\n        setContentType(string_view{typeString + (haveHeader ? 14 : 0),\n                                   typeStringLength - endOffset});\n    }\n\n    void setContentTypeString(const char *typeString,\n                              size_t typeStringLength) override;\n\n    void setCustomStatusCode(int code,\n                             const char *message,\n                             size_t messageLength) override\n    {\n        assert(code >= 0);\n        customStatusCode_ = code;\n        statusMessage_ = string_view{message, messageLength};\n    }\n\n    std::unordered_map<std::string, std::string> headers_;\n    std::unordered_map<std::string, Cookie> cookies_;\n\n    int customStatusCode_{-1};\n    HttpStatusCode statusCode_{kUnknown};\n    string_view statusMessage_;\n\n    trantor::Date creationDate_;\n    Version version_{Version::kHttp11};\n    bool closeConnection_{false};\n    mutable std::shared_ptr<HttpMessageBody> bodyPtr_;\n    ssize_t expriedTime_{-1};\n    std::string sendfileName_;\n    SendfileRange sendfileRange_{0, 0};\n    std::function<std::size_t(char *, std::size_t)> streamCallback_;\n\n    mutable std::shared_ptr<Json::Value> jsonPtr_;\n\n    std::shared_ptr<trantor::MsgBuffer> fullHeaderString_;\n    mutable std::shared_ptr<trantor::MsgBuffer> httpString_;\n    mutable size_t datePos_{static_cast<size_t>(-1)};\n    mutable int64_t httpStringDate_{-1};\n    mutable bool flagForParsingJson_{false};\n    mutable bool flagForSerializingJson_{true};\n    mutable ContentType contentType_{CT_TEXT_PLAIN};\n    mutable bool flagForParsingContentType_{false};\n    mutable std::shared_ptr<std::string> jsonParsingErrorPtr_;\n    mutable std::string contentTypeString_{\"text/html; charset=utf-8\"};\n    bool passThrough_{false};\n    void setContentType(const string_view &contentType)\n    {\n        contentTypeString_ =\n            std::string(contentType.data(), contentType.size());\n    }\n    void setStatusMessage(const string_view &message)\n    {\n        statusMessage_ = message;\n    }\n};\nusing HttpResponseImplPtr = std::shared_ptr<HttpResponseImpl>;\n\ninline void swap(HttpResponseImpl &one, HttpResponseImpl &two) noexcept\n{\n    one.swap(two);\n}\n\n}  // namespace drogon\n", "/**\n *\n *  @file Utilities.cc\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#include <drogon/utils/Utilities.h>\n#include \"filesystem.h\"\n#include <trantor/utils/Logger.h>\n#include <drogon/config.h>\n#ifdef OpenSSL_FOUND\n#include <openssl/md5.h>\n#include <openssl/rand.h>\n#else\n#include \"ssl_funcs/Md5.h\"\n#endif\n#ifdef USE_BROTLI\n#include <brotli/decode.h>\n#include <brotli/encode.h>\n#endif\n#ifdef _WIN32\n#include <Rpc.h>\n#include <direct.h>\n#include <io.h>\n#include <ntsecapi.h>\n#else\n#include <uuid.h>\n#include <unistd.h>\n#endif\n#include <zlib.h>\n#include <iomanip>\n#include <mutex>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <thread>\n#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdarg.h>\n\n#ifdef _WIN32\n\nchar *strptime(const char *s, const char *f, struct tm *tm)\n{\n    // std::get_time is defined such that its\n    // format parameters are the exact same as strptime.\n    std::istringstream input(s);\n    input.imbue(std::locale(setlocale(LC_ALL, nullptr)));\n    input >> std::get_time(tm, f);\n    if (input.fail())\n    {\n        return nullptr;\n    }\n    return (char *)(s + input.tellg());\n}\ntime_t timegm(struct tm *tm)\n{\n    struct tm my_tm;\n\n    memcpy(&my_tm, tm, sizeof(struct tm));\n\n    /* _mkgmtime() changes the value of the struct tm* you pass in, so\n     * use a copy\n     */\n    return _mkgmtime(&my_tm);\n}\n#endif\n\n#ifdef __HAIKU__\n// HACK: Haiku has a timegm implementation. But it is not exposed\nextern \"C\" time_t timegm(struct tm *tm);\n#endif\n\nnamespace drogon\n{\nnamespace utils\n{\nstatic const std::string base64Chars =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789+/\";\n\nstatic const std::string urlBase64Chars =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789-_\";\nclass Base64CharMap\n{\n  public:\n    Base64CharMap()\n    {\n        char index = 0;\n        for (int c = 'A'; c <= 'Z'; ++c)\n        {\n            charMap_[c] = index++;\n        }\n        for (int c = 'a'; c <= 'z'; ++c)\n        {\n            charMap_[c] = index++;\n        }\n        for (int c = '0'; c <= '9'; ++c)\n        {\n            charMap_[c] = index++;\n        }\n        charMap_[static_cast<int>('+')] = charMap_[static_cast<int>('-')] =\n            index++;\n        charMap_[static_cast<int>('/')] = charMap_[static_cast<int>('_')] =\n            index;\n        charMap_[0] = 0xff;\n    }\n    char getIndex(const char c) const noexcept\n    {\n        return charMap_[static_cast<int>(c)];\n    }\n\n  private:\n    char charMap_[256]{0};\n};\nconst static Base64CharMap base64CharMap;\n\nstatic inline bool isBase64(unsigned char c)\n{\n    if (isalnum(c))\n        return true;\n    switch (c)\n    {\n        case '+':\n        case '/':\n        case '-':\n        case '_':\n            return true;\n    }\n    return false;\n}\n\nbool isInteger(const std::string &str)\n{\n    for (auto const &c : str)\n    {\n        if (c > '9' || c < '0')\n            return false;\n    }\n    return true;\n}\n\nstd::string genRandomString(int length)\n{\n    static const char char_space[] =\n        \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    static std::once_flag once;\n    static const size_t len = strlen(char_space);\n    static const int randMax = RAND_MAX - (RAND_MAX % len);\n    std::call_once(once, []() {\n        std::srand(static_cast<unsigned int>(time(nullptr)));\n    });\n\n    int i;\n    std::string str;\n    str.resize(length);\n\n    for (i = 0; i < length; ++i)\n    {\n        int x = std::rand();\n        while (x >= randMax)\n        {\n            x = std::rand();\n        }\n        x = (x % len);\n        str[i] = char_space[x];\n    }\n\n    return str;\n}\n\nstd::vector<char> hexToBinaryVector(const char *ptr, size_t length)\n{\n    assert(length % 2 == 0);\n    std::vector<char> ret(length / 2, '\\0');\n    for (size_t i = 0; i < ret.size(); ++i)\n    {\n        auto p = i * 2;\n        char c1 = ptr[p];\n        if (c1 >= '0' && c1 <= '9')\n        {\n            c1 -= '0';\n        }\n        else if (c1 >= 'a' && c1 <= 'f')\n        {\n            c1 -= 'a';\n            c1 += 10;\n        }\n        else if (c1 >= 'A' && c1 <= 'F')\n        {\n            c1 -= 'A';\n            c1 += 10;\n        }\n        else\n        {\n            return std::vector<char>();\n        }\n        char c2 = ptr[p + 1];\n        if (c2 >= '0' && c2 <= '9')\n        {\n            c2 -= '0';\n        }\n        else if (c2 >= 'a' && c2 <= 'f')\n        {\n            c2 -= 'a';\n            c2 += 10;\n        }\n        else if (c2 >= 'A' && c2 <= 'F')\n        {\n            c2 -= 'A';\n            c2 += 10;\n        }\n        else\n        {\n            return std::vector<char>();\n        }\n        ret[i] = c1 * 16 + c2;\n    }\n    return ret;\n}\nstd::string hexToBinaryString(const char *ptr, size_t length)\n{\n    assert(length % 2 == 0);\n    std::string ret(length / 2, '\\0');\n    for (size_t i = 0; i < ret.length(); ++i)\n    {\n        auto p = i * 2;\n        char c1 = ptr[p];\n        if (c1 >= '0' && c1 <= '9')\n        {\n            c1 -= '0';\n        }\n        else if (c1 >= 'a' && c1 <= 'f')\n        {\n            c1 -= 'a';\n            c1 += 10;\n        }\n        else if (c1 >= 'A' && c1 <= 'F')\n        {\n            c1 -= 'A';\n            c1 += 10;\n        }\n        else\n        {\n            return \"\";\n        }\n        char c2 = ptr[p + 1];\n        if (c2 >= '0' && c2 <= '9')\n        {\n            c2 -= '0';\n        }\n        else if (c2 >= 'a' && c2 <= 'f')\n        {\n            c2 -= 'a';\n            c2 += 10;\n        }\n        else if (c2 >= 'A' && c2 <= 'F')\n        {\n            c2 -= 'A';\n            c2 += 10;\n        }\n        else\n        {\n            return \"\";\n        }\n        ret[i] = c1 * 16 + c2;\n    }\n    return ret;\n}\n\nstd::string binaryStringToHex(const unsigned char *ptr, size_t length)\n{\n    std::string idString;\n    for (size_t i = 0; i < length; ++i)\n    {\n        int value = (ptr[i] & 0xf0) >> 4;\n        if (value < 10)\n        {\n            idString.append(1, char(value + 48));\n        }\n        else\n        {\n            idString.append(1, char(value + 55));\n        }\n\n        value = (ptr[i] & 0x0f);\n        if (value < 10)\n        {\n            idString.append(1, char(value + 48));\n        }\n        else\n        {\n            idString.append(1, char(value + 55));\n        }\n    }\n    return idString;\n}\n\nstd::set<std::string> splitStringToSet(const std::string &str,\n                                       const std::string &separator)\n{\n    std::set<std::string> ret;\n    std::string::size_type pos1, pos2;\n    pos2 = 0;\n    pos1 = str.find(separator);\n    while (pos1 != std::string::npos)\n    {\n        if (pos1 != 0)\n        {\n            std::string item = str.substr(pos2, pos1 - pos2);\n            ret.insert(item);\n        }\n        pos2 = pos1 + separator.length();\n        while (pos2 < str.length() &&\n               str.substr(pos2, separator.length()) == separator)\n            pos2 += separator.length();\n        pos1 = str.find(separator, pos2);\n    }\n    if (pos2 < str.length())\n        ret.insert(str.substr(pos2));\n    return ret;\n}\n\nstd::string getUuid()\n{\n#if USE_OSSP_UUID\n    uuid_t *uuid;\n    uuid_create(&uuid);\n    uuid_make(uuid, UUID_MAKE_V4);\n    char *str{nullptr};\n    size_t len{0};\n    uuid_export(uuid, UUID_FMT_BIN, &str, &len);\n    uuid_destroy(uuid);\n    std::string ret{binaryStringToHex((const unsigned char *)str, len)};\n    free(str);\n    return ret;\n#elif defined __FreeBSD__ || defined __OpenBSD__\n    uuid_t *uuid = new uuid_t;\n    char *binstr = (char *)malloc(16);\n#if defined __FreeBSD__\n    uuidgen(uuid, 1);\n#else\n    uint32_t status;\n    uuid_create(uuid, &status);\n#endif\n#if _BYTE_ORDER == _LITTLE_ENDIAN\n    uuid_enc_le(binstr, uuid);\n#else  /* _BYTE_ORDER != _LITTLE_ENDIAN */\n    uuid_enc_be(binstr, uuid);\n#endif /* _BYTE_ORDER == _LITTLE_ENDIAN */\n    delete uuid;\n    std::string ret{binaryStringToHex((const unsigned char *)binstr, 16)};\n    free(binstr);\n    return ret;\n#elif defined _WIN32\n    uuid_t uu;\n    UuidCreate(&uu);\n    char tempStr[100];\n    auto len = snprintf(tempStr,\n                        sizeof(tempStr),\n                        \"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n                        uu.Data1,\n                        uu.Data2,\n                        uu.Data3,\n                        uu.Data4[0],\n                        uu.Data4[1],\n                        uu.Data4[2],\n                        uu.Data4[3],\n                        uu.Data4[4],\n                        uu.Data4[5],\n                        uu.Data4[6],\n                        uu.Data4[7]);\n    return std::string{tempStr, static_cast<size_t>(len)};\n#else\n    uuid_t uu;\n    uuid_generate(uu);\n    return binaryStringToHex(uu, 16);\n#endif\n}\n\nstd::string base64Encode(const unsigned char *bytes_to_encode,\n                         unsigned int in_len,\n                         bool url_safe)\n{\n    std::string ret;\n    int i = 0;\n    unsigned char char_array_3[3];\n    unsigned char char_array_4[4];\n\n    const std::string &charSet = url_safe ? urlBase64Chars : base64Chars;\n\n    while (in_len--)\n    {\n        char_array_3[i++] = *(bytes_to_encode++);\n        if (i == 3)\n        {\n            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;\n            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) +\n                              ((char_array_3[1] & 0xf0) >> 4);\n            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) +\n                              ((char_array_3[2] & 0xc0) >> 6);\n            char_array_4[3] = char_array_3[2] & 0x3f;\n\n            for (i = 0; (i < 4); ++i)\n                ret += charSet[char_array_4[i]];\n            i = 0;\n        }\n    }\n\n    if (i)\n    {\n        for (int j = i; j < 3; ++j)\n            char_array_3[j] = '\\0';\n\n        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;\n        char_array_4[1] =\n            ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);\n        char_array_4[2] =\n            ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);\n        char_array_4[3] = char_array_3[2] & 0x3f;\n\n        for (int j = 0; (j < i + 1); ++j)\n            ret += charSet[char_array_4[j]];\n\n        while ((i++ < 3))\n            ret += '=';\n    }\n    return ret;\n}\n\nstd::vector<char> base64DecodeToVector(const std::string &encoded_string)\n{\n    auto in_len = encoded_string.size();\n    int i = 0;\n    int in_{0};\n    char char_array_4[4], char_array_3[3];\n    std::vector<char> ret;\n    ret.reserve(in_len);\n\n    while (in_len-- && (encoded_string[in_] != '=') &&\n           isBase64(encoded_string[in_]))\n    {\n        char_array_4[i++] = encoded_string[in_];\n        ++in_;\n        if (i == 4)\n        {\n            for (i = 0; i < 4; ++i)\n            {\n                char_array_4[i] = base64CharMap.getIndex(char_array_4[i]);\n            }\n\n            char_array_3[0] =\n                (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) +\n                              ((char_array_4[2] & 0x3c) >> 2);\n            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n            for (i = 0; (i < 3); ++i)\n                ret.push_back(char_array_3[i]);\n            i = 0;\n        }\n    }\n\n    if (i)\n    {\n        for (int j = i; j < 4; ++j)\n            char_array_4[j] = 0;\n\n        for (int j = 0; j < 4; ++j)\n        {\n            char_array_4[j] = base64CharMap.getIndex(char_array_4[j]);\n        }\n\n        char_array_3[0] =\n            (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n        char_array_3[1] =\n            ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);\n        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n        for (int j = 0; (j < i - 1); ++j)\n            ret.push_back(char_array_3[j]);\n    }\n\n    return ret;\n}\n\nstd::string base64Decode(const std::string &encoded_string)\n{\n    auto in_len = encoded_string.size();\n    int i = 0;\n    int in_{0};\n    unsigned char char_array_4[4], char_array_3[3];\n    std::string ret;\n\n    while (in_len-- && (encoded_string[in_] != '=') &&\n           isBase64(encoded_string[in_]))\n    {\n        char_array_4[i++] = encoded_string[in_];\n        ++in_;\n        if (i == 4)\n        {\n            for (i = 0; i < 4; ++i)\n            {\n                char_array_4[i] = base64CharMap.getIndex(char_array_4[i]);\n            }\n            char_array_3[0] =\n                (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) +\n                              ((char_array_4[2] & 0x3c) >> 2);\n            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n            for (i = 0; (i < 3); ++i)\n                ret += char_array_3[i];\n            i = 0;\n        }\n    }\n\n    if (i)\n    {\n        for (int j = i; j < 4; ++j)\n            char_array_4[j] = 0;\n\n        for (int j = 0; j < 4; ++j)\n        {\n            char_array_4[j] = base64CharMap.getIndex(char_array_4[j]);\n        }\n\n        char_array_3[0] =\n            (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n        char_array_3[1] =\n            ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);\n        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n        for (int j = 0; (j < i - 1); ++j)\n            ret += char_array_3[j];\n    }\n\n    return ret;\n}\nstatic std::string charToHex(char c)\n{\n    std::string result;\n    char first, second;\n\n    first = (c & 0xF0) / 16;\n    first += first > 9 ? 'A' - 10 : '0';\n    second = c & 0x0F;\n    second += second > 9 ? 'A' - 10 : '0';\n\n    result.append(1, first);\n    result.append(1, second);\n\n    return result;\n}\nstd::string urlEncodeComponent(const std::string &src)\n{\n    std::string result;\n    std::string::const_iterator iter;\n\n    for (iter = src.begin(); iter != src.end(); ++iter)\n    {\n        switch (*iter)\n        {\n            case ' ':\n                result.append(1, '+');\n                break;\n            // alnum\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case 'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case 's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            // mark\n            case '-':\n            case '_':\n            case '.':\n            case '!':\n            case '~':\n            case '*':\n            case '(':\n            case ')':\n                result.append(1, *iter);\n                break;\n            // escape\n            default:\n                result.append(1, '%');\n                result.append(charToHex(*iter));\n                break;\n        }\n    }\n\n    return result;\n}\nstd::string urlEncode(const std::string &src)\n{\n    std::string result;\n    std::string::const_iterator iter;\n\n    for (iter = src.begin(); iter != src.end(); ++iter)\n    {\n        switch (*iter)\n        {\n            case ' ':\n                result.append(1, '+');\n                break;\n            // alnum\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case 'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case 's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            // mark\n            case '-':\n            case '_':\n            case '.':\n            case '!':\n            case '~':\n            case '*':\n            case '\\'':\n            case '(':\n            case ')':\n            case '&':\n            case '=':\n            case '/':\n            case '\\\\':\n            case '?':\n                result.append(1, *iter);\n                break;\n            // escape\n            default:\n                result.append(1, '%');\n                result.append(charToHex(*iter));\n                break;\n        }\n    }\n\n    return result;\n}\nbool needUrlDecoding(const char *begin, const char *end)\n{\n    return std::find_if(begin, end, [](const char c) {\n               return c == '+' || c == '%';\n           }) != end;\n}\nstd::string urlDecode(const char *begin, const char *end)\n{\n    std::string result;\n    size_t len = end - begin;\n    result.reserve(len * 2);\n    int hex = 0;\n    for (size_t i = 0; i < len; ++i)\n    {\n        switch (begin[i])\n        {\n            case '+':\n                result += ' ';\n                break;\n            case '%':\n                if ((i + 2) < len && isxdigit(begin[i + 1]) &&\n                    isxdigit(begin[i + 2]))\n                {\n                    unsigned int x1 = begin[i + 1];\n                    if (x1 >= '0' && x1 <= '9')\n                    {\n                        x1 -= '0';\n                    }\n                    else if (x1 >= 'a' && x1 <= 'f')\n                    {\n                        x1 = x1 - 'a' + 10;\n                    }\n                    else if (x1 >= 'A' && x1 <= 'F')\n                    {\n                        x1 = x1 - 'A' + 10;\n                    }\n                    unsigned int x2 = begin[i + 2];\n                    if (x2 >= '0' && x2 <= '9')\n                    {\n                        x2 -= '0';\n                    }\n                    else if (x2 >= 'a' && x2 <= 'f')\n                    {\n                        x2 = x2 - 'a' + 10;\n                    }\n                    else if (x2 >= 'A' && x2 <= 'F')\n                    {\n                        x2 = x2 - 'A' + 10;\n                    }\n                    hex = x1 * 16 + x2;\n\n                    result += char(hex);\n                    i += 2;\n                }\n                else\n                {\n                    result += '%';\n                }\n                break;\n            default:\n                result += begin[i];\n                break;\n        }\n    }\n    return result;\n}\n\n/* Compress gzip data */\nstd::string gzipCompress(const char *data, const size_t ndata)\n{\n    z_stream strm = {nullptr,\n                     0,\n                     0,\n                     nullptr,\n                     0,\n                     0,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     0,\n                     0,\n                     0};\n    if (data && ndata > 0)\n    {\n        if (deflateInit2(&strm,\n                         Z_DEFAULT_COMPRESSION,\n                         Z_DEFLATED,\n                         MAX_WBITS + 16,\n                         8,\n                         Z_DEFAULT_STRATEGY) != Z_OK)\n        {\n            LOG_ERROR << \"deflateInit2 error!\";\n            return std::string{};\n        }\n        std::string outstr;\n        outstr.resize(compressBound(static_cast<uLong>(ndata)));\n        strm.next_in = (Bytef *)data;\n        strm.avail_in = static_cast<uInt>(ndata);\n        int ret;\n        do\n        {\n            if (strm.total_out >= outstr.size())\n            {\n                outstr.resize(strm.total_out * 2);\n            }\n            assert(outstr.size() >= strm.total_out);\n            strm.avail_out = static_cast<uInt>(outstr.size() - strm.total_out);\n            strm.next_out = (Bytef *)outstr.data() + strm.total_out;\n            ret = deflate(&strm, Z_FINISH); /* no bad return value */\n            if (ret == Z_STREAM_ERROR)\n            {\n                (void)deflateEnd(&strm);\n                return std::string{};\n            }\n        } while (strm.avail_out == 0);\n        assert(strm.avail_in == 0);\n        assert(ret == Z_STREAM_END); /* stream will be complete */\n        outstr.resize(strm.total_out);\n        /* clean up and return */\n        (void)deflateEnd(&strm);\n        return outstr;\n    }\n    return std::string{};\n}\n\nstd::string gzipDecompress(const char *data, const size_t ndata)\n{\n    if (ndata == 0)\n        return std::string(data, ndata);\n\n    auto full_length = ndata;\n\n    auto decompressed = std::string(full_length * 2, 0);\n    bool done = false;\n\n    z_stream strm = {nullptr,\n                     0,\n                     0,\n                     nullptr,\n                     0,\n                     0,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     0,\n                     0,\n                     0};\n    strm.next_in = (Bytef *)data;\n    strm.avail_in = static_cast<uInt>(ndata);\n    strm.total_out = 0;\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    if (inflateInit2(&strm, (15 + 32)) != Z_OK)\n    {\n        LOG_ERROR << \"inflateInit2 error!\";\n        return std::string{};\n    }\n    while (!done)\n    {\n        // Make sure we have enough room and reset the lengths.\n        if (strm.total_out >= decompressed.length())\n        {\n            decompressed.resize(decompressed.length() * 2);\n        }\n        strm.next_out = (Bytef *)decompressed.data() + strm.total_out;\n        strm.avail_out =\n            static_cast<uInt>(decompressed.length() - strm.total_out);\n        // Inflate another chunk.\n        int status = inflate(&strm, Z_SYNC_FLUSH);\n        if (status == Z_STREAM_END)\n        {\n            done = true;\n        }\n        else if (status != Z_OK)\n        {\n            break;\n        }\n    }\n    if (inflateEnd(&strm) != Z_OK)\n        return std::string{};\n    // Set real length.\n    if (done)\n    {\n        decompressed.resize(strm.total_out);\n        return decompressed;\n    }\n    else\n    {\n        return std::string{};\n    }\n}\n\nchar *getHttpFullDate(const trantor::Date &date)\n{\n    static thread_local int64_t lastSecond = 0;\n    static thread_local char lastTimeString[128] = {0};\n    auto nowSecond = date.microSecondsSinceEpoch() / MICRO_SECONDS_PRE_SEC;\n    if (nowSecond == lastSecond)\n    {\n        return lastTimeString;\n    }\n    lastSecond = nowSecond;\n    date.toCustomedFormattedString(\"%a, %d %b %Y %H:%M:%S GMT\",\n                                   lastTimeString,\n                                   sizeof(lastTimeString));\n    return lastTimeString;\n}\ntrantor::Date getHttpDate(const std::string &httpFullDateString)\n{\n    static const std::array<const char *, 4> formats = {\n        // RFC822 (default)\n        \"%a, %d %b %Y %H:%M:%S\",\n        // RFC 850 (deprecated)\n        \"%a, %d-%b-%y %H:%M:%S\",\n        // ansi asctime format\n        \"%a %b %d %H:%M:%S %Y\",\n        // weird RFC 850-hybrid thing that reddit uses\n        \"%a, %d-%b-%Y %H:%M:%S\",\n    };\n    struct tm tmptm;\n    for (const char *format : formats)\n    {\n        if (strptime(httpFullDateString.c_str(), format, &tmptm) != NULL)\n        {\n            auto epoch = timegm(&tmptm);\n            return trantor::Date(epoch * MICRO_SECONDS_PRE_SEC);\n        }\n    }\n    LOG_WARN << \"invalid datetime format: '\" << httpFullDateString << \"'\";\n    return trantor::Date((std::numeric_limits<int64_t>::max)());\n}\nstd::string formattedString(const char *format, ...)\n{\n    std::string strBuffer(128, 0);\n    va_list ap, backup_ap;\n    va_start(ap, format);\n    va_copy(backup_ap, ap);\n    auto result = vsnprintf((char *)strBuffer.data(),\n                            strBuffer.size(),\n                            format,\n                            backup_ap);\n    va_end(backup_ap);\n    if ((result >= 0) && ((std::string::size_type)result < strBuffer.size()))\n    {\n        strBuffer.resize(result);\n    }\n    else\n    {\n        while (true)\n        {\n            if (result < 0)\n            {\n                // Older snprintf() behavior. Just try doubling the buffer size\n                strBuffer.resize(strBuffer.size() * 2);\n            }\n            else\n            {\n                strBuffer.resize(result + 1);\n            }\n\n            va_copy(backup_ap, ap);\n            auto result = vsnprintf((char *)strBuffer.data(),\n                                    strBuffer.size(),\n                                    format,\n                                    backup_ap);\n            va_end(backup_ap);\n\n            if ((result >= 0) &&\n                ((std::string::size_type)result < strBuffer.size()))\n            {\n                strBuffer.resize(result);\n                break;\n            }\n        }\n    }\n    va_end(ap);\n    return strBuffer;\n}\n\nint createPath(const std::string &path)\n{\n    if (path.empty())\n        return 0;\n    auto osPath{toNativePath(path)};\n    if (osPath.back() != filesystem::path::preferred_separator)\n        osPath.push_back(filesystem::path::preferred_separator);\n    filesystem::path fsPath(osPath);\n    drogon::error_code err;\n    filesystem::create_directories(fsPath, err);\n    if (err)\n    {\n        LOG_ERROR << \"Error \" << err.value() << \" creating path \" << osPath\n                  << \": \" << err.message();\n        return -1;\n    }\n    return 0;\n}\n#ifdef USE_BROTLI\nstd::string brotliCompress(const char *data, const size_t ndata)\n{\n    std::string ret;\n    if (ndata == 0)\n        return ret;\n    ret.resize(BrotliEncoderMaxCompressedSize(ndata));\n    size_t encodedSize{ret.size()};\n    auto r = BrotliEncoderCompress(5,\n                                   BROTLI_DEFAULT_WINDOW,\n                                   BROTLI_DEFAULT_MODE,\n                                   ndata,\n                                   (const uint8_t *)(data),\n                                   &encodedSize,\n                                   (uint8_t *)(ret.data()));\n    if (r == BROTLI_FALSE)\n        ret.resize(0);\n    else\n        ret.resize(encodedSize);\n    return ret;\n}\nstd::string brotliDecompress(const char *data, const size_t ndata)\n{\n    if (ndata == 0)\n        return std::string(data, ndata);\n\n    size_t availableIn = ndata;\n    auto nextIn = (const uint8_t *)(data);\n    auto decompressed = std::string(availableIn * 3, 0);\n    size_t availableOut = decompressed.size();\n    auto nextOut = (uint8_t *)(decompressed.data());\n    size_t totalOut{0};\n    bool done = false;\n    auto s = BrotliDecoderCreateInstance(nullptr, nullptr, nullptr);\n    while (!done)\n    {\n        auto result = BrotliDecoderDecompressStream(\n            s, &availableIn, &nextIn, &availableOut, &nextOut, &totalOut);\n        if (result == BROTLI_DECODER_RESULT_SUCCESS)\n        {\n            decompressed.resize(totalOut);\n            done = true;\n        }\n        else if (result == BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT)\n        {\n            assert(totalOut == decompressed.size());\n            decompressed.resize(totalOut * 2);\n            nextOut = (uint8_t *)(decompressed.data() + totalOut);\n            availableOut = totalOut;\n        }\n        else\n        {\n            decompressed.resize(0);\n            done = true;\n        }\n    }\n    BrotliDecoderDestroyInstance(s);\n    return decompressed;\n}\n#else\nstd::string brotliCompress(const char * /*data*/, const size_t /*ndata*/)\n{\n    LOG_ERROR << \"If you do not have the brotli package installed, you cannot \"\n                 \"use brotliCompress()\";\n    abort();\n}\nstd::string brotliDecompress(const char * /*data*/, const size_t /*ndata*/)\n{\n    LOG_ERROR << \"If you do not have the brotli package installed, you cannot \"\n                 \"use brotliDecompress()\";\n    abort();\n}\n#endif\n\nstd::string getMd5(const char *data, const size_t dataLen)\n{\n#if defined(OpenSSL_FOUND) && OPENSSL_VERSION_MAJOR < 3\n    MD5_CTX c;\n    unsigned char md5[16] = {0};\n    MD5_Init(&c);\n    MD5_Update(&c, data, dataLen);\n    MD5_Final(md5, &c);\n    return utils::binaryStringToHex(md5, 16);\n#elif defined(OpenSSL_FOUND)\n    unsigned char md5[16] = {0};\n    const EVP_MD *md = EVP_get_digestbyname(\"md5\");\n    assert(md != nullptr);\n\n    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();\n    EVP_DigestInit_ex2(mdctx, md, NULL);\n    EVP_DigestUpdate(mdctx, data, dataLen);\n    EVP_DigestFinal_ex(mdctx, md5, NULL);\n    EVP_MD_CTX_free(mdctx);\n    return utils::binaryStringToHex(md5, 16);\n#else\n    return Md5Encode::encode(data, dataLen);\n#endif\n}\n\nvoid replaceAll(std::string &s, const std::string &from, const std::string &to)\n{\n    size_t pos = 0;\n    while ((pos = s.find(from, pos)) != std::string::npos)\n    {\n        s.replace(pos, from.size(), to);\n        pos += to.size();\n    }\n}\n\n/**\n * @brief Generates `size` random bytes from the systems random source and\n * stores them into `ptr`.\n */\nstatic bool systemRandomBytes(void *ptr, size_t size)\n{\n#if defined(__BSD__) || defined(__APPLE__)\n    arc4random_buf(ptr, size);\n    return true;\n#elif defined(__linux__) && \\\n    ((defined(__GLIBC__) && \\\n      (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25))))\n    return getentropy(ptr, size) != -1;\n#elif defined(_WIN32)  // Windows\n    return RtlGenRandom(ptr, size);\n#elif defined(__unix__) || defined(__HAIKU__)\n    // fallback to /dev/urandom for other/old UNIX\n    thread_local std::unique_ptr<FILE, std::function<void(FILE *)> > fptr(\n        fopen(\"/dev/urandom\", \"rb\"), [](FILE *ptr) {\n            if (ptr != nullptr)\n                fclose(ptr);\n        });\n    if (fptr == nullptr)\n    {\n        LOG_FATAL << \"Failed to open /dev/urandom for randomness\";\n        abort();\n    }\n    if (fread(ptr, 1, size, fptr.get()) != 0)\n        return true;\n#endif\n    return false;\n}\n\nbool secureRandomBytes(void *ptr, size_t size)\n{\n#ifdef OpenSSL_FOUND\n    if (RAND_bytes((unsigned char *)ptr, size) == 0)\n        return true;\n#endif\n    if (systemRandomBytes(ptr, size))\n        return true;\n    return false;\n}\n\n}  // namespace utils\n}  // namespace drogon\n"], "fixing_code": ["/**\n *\n *  @file HttpRequest.h\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include <drogon/exports.h>\n#include <drogon/utils/string_view.h>\n#include <drogon/utils/optional.h>\n#include <drogon/utils/Utilities.h>\n#include <drogon/DrClassMap.h>\n#include <drogon/HttpTypes.h>\n#include <drogon/Session.h>\n#include <drogon/Attribute.h>\n#include <drogon/UploadFile.h>\n#include <json/json.h>\n#include <trantor/net/InetAddress.h>\n#include <trantor/utils/Date.h>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\nnamespace drogon\n{\nclass HttpRequest;\nusing HttpRequestPtr = std::shared_ptr<HttpRequest>;\n\n/**\n * @brief This template is used to convert a request object to a custom\n * type object. Users must specialize the template for a particular type.\n */\ntemplate <typename T>\nT fromRequest(const HttpRequest &)\n{\n    LOG_ERROR << \"You must specialize the fromRequest template for the type of \"\n              << DrClassMap::demangle(typeid(T).name());\n    exit(1);\n}\n\n/**\n * @brief This template is used to create a request object from a custom\n * type object by calling the newCustomHttpRequest(). Users must specialize\n * the template for a particular type.\n */\ntemplate <typename T>\nHttpRequestPtr toRequest(T &&)\n{\n    LOG_ERROR << \"You must specialize the toRequest template for the type of \"\n              << DrClassMap::demangle(typeid(T).name());\n    exit(1);\n}\n\ntemplate <>\nHttpRequestPtr toRequest<const Json::Value &>(const Json::Value &pJson);\ntemplate <>\nHttpRequestPtr toRequest(Json::Value &&pJson);\ntemplate <>\ninline HttpRequestPtr toRequest<Json::Value &>(Json::Value &pJson)\n{\n    return toRequest((const Json::Value &)pJson);\n}\n\ntemplate <>\nstd::shared_ptr<Json::Value> fromRequest(const HttpRequest &req);\n\n/// Abstract class for webapp developer to get or set the Http request;\nclass DROGON_EXPORT HttpRequest\n{\n  public:\n    /**\n     * @brief This template enables implicit type conversion. For using this\n     * template, user must specialize the fromRequest template. For example a\n     * shared_ptr<Json::Value> specialization version is available above, so\n     * we can use the following code to get a json object:\n     * @code\n       std::shared_ptr<Json::Value> jsonPtr = *requestPtr;\n       @endcode\n     * With this template, user can use their favorite JSON library instead of\n     * the default jsoncpp library or convert the request to an object of any\n     * custom type.\n     */\n    template <typename T>\n    operator T() const\n    {\n        return fromRequest<T>(*this);\n    }\n\n    /**\n     * @brief This template enables explicit type conversion, see the above\n     * template.\n     */\n    template <typename T>\n    T as() const\n    {\n        return fromRequest<T>(*this);\n    }\n\n    /// Return the method string of the request, such as GET, POST, etc.\n    virtual const char *methodString() const = 0;\n    const char *getMethodString() const\n    {\n        return methodString();\n    }\n\n    /// Return the enum type method of the request.\n    virtual HttpMethod method() const = 0;\n    HttpMethod getMethod() const\n    {\n        return method();\n    }\n\n    /// Get the header string identified by the key parameter.\n    /**\n     * @note\n     * If there is no the header, a empty string is retured.\n     * The key is case insensitive\n     */\n    virtual const std::string &getHeader(std::string key) const = 0;\n\n    /**\n     * @brief Set the header string identified by the field parameter\n     *\n     * @param field The field parameter is transformed to lower case before\n     * storing.\n     * @param value The value of the header.\n     */\n    virtual void addHeader(std::string field, const std::string &value) = 0;\n    virtual void addHeader(std::string field, std::string &&value) = 0;\n\n    /**\n     * @brief  Remove the header identified by the key parameter.\n     *\n     * @param key The key is case insensitive\n     */\n    virtual void removeHeader(std::string key) = 0;\n\n    /// Get the cookie string identified by the field parameter\n    virtual const std::string &getCookie(const std::string &field) const = 0;\n\n    /// Get all headers of the request\n    virtual const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &headers() const = 0;\n\n    /// Get all headers of the request\n    const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &getHeaders() const\n    {\n        return headers();\n    }\n\n    /// Get all cookies of the request\n    virtual const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &cookies() const = 0;\n\n    /// Get all cookies of the request\n    const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &getCookies() const\n    {\n        return cookies();\n    }\n\n    /// Get the query string of the request.\n    /**\n     * The query string is the substring after the '?' in the URL string.\n     */\n    virtual const std::string &query() const = 0;\n\n    /// Get the query string of the request.\n    const std::string &getQuery() const\n    {\n        return query();\n    }\n\n    /// Get the content string of the request, which is the body part of the\n    /// request.\n    string_view body() const\n    {\n        return string_view(bodyData(), bodyLength());\n    }\n\n    /// Get the content string of the request, which is the body part of the\n    /// request.\n    string_view getBody() const\n    {\n        return body();\n    }\n    virtual const char *bodyData() const = 0;\n    virtual size_t bodyLength() const = 0;\n\n    /// Set the content string of the request.\n    virtual void setBody(const std::string &body) = 0;\n\n    /// Set the content string of the request.\n    virtual void setBody(std::string &&body) = 0;\n\n    /// Get the path of the request.\n    virtual const std::string &path() const = 0;\n\n    /// Get the path of the request.\n    const std::string &getPath() const\n    {\n        return path();\n    }\n\n    /// Get the matched path pattern after routing\n    string_view getMatchedPathPattern() const\n    {\n        return matchedPathPattern();\n    }\n\n    /// Get the matched path pattern after routing\n    string_view matchedPathPattern() const\n    {\n        return string_view(matchedPathPatternData(),\n                           matchedPathPatternLength());\n    }\n    virtual const char *matchedPathPatternData() const = 0;\n    virtual size_t matchedPathPatternLength() const = 0;\n\n    /// Return the string of http version of request, such as HTTP/1.0,\n    /// HTTP/1.1, etc.\n    virtual const char *versionString() const = 0;\n    const char *getVersionString() const\n    {\n        return versionString();\n    }\n\n    /// Return the enum type version of the request.\n    /**\n     * kHttp10 means Http version is 1.0\n     * kHttp11 means Http verison is 1.1\n     */\n    virtual Version version() const = 0;\n\n    /// Return the enum type version of the request.\n    Version getVersion() const\n    {\n        return version();\n    }\n\n    /// Get the session to which the request belongs.\n    virtual const SessionPtr &session() const = 0;\n\n    /// Get the session to which the request belongs.\n    const SessionPtr &getSession() const\n    {\n        return session();\n    }\n\n    /// Get the attributes store, users can add/get any type of data to/from\n    /// this store\n    virtual const AttributesPtr &attributes() const = 0;\n\n    /// Get the attributes store, users can add/get any type of data to/from\n    /// this store\n    const AttributesPtr &getAttributes() const\n    {\n        return attributes();\n    }\n\n    /// Get parameters of the request.\n    virtual const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &parameters() const = 0;\n\n    /// Get parameters of the request.\n    const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &getParameters() const\n    {\n        return parameters();\n    }\n\n    /// Get a parameter identified by the @param key\n    virtual const std::string &getParameter(const std::string &key) const = 0;\n\n    /**\n     * @brief Get the optional parameter identified by the @param key. if the\n     * parameter doesn't exist, or the original parameter can't be converted to\n     * a T type object, an empty optional object is returned.\n     *\n     * @tparam T\n     * @param key\n     * @return optional<T>\n     */\n    template <typename T>\n    optional<T> getOptionalParameter(const std::string &key)\n    {\n        auto &params = getParameters();\n        auto it = params.find(key);\n        if (it != params.end())\n        {\n            try\n            {\n                return optional<T>(drogon::utils::fromString<T>(it->second));\n            }\n            catch (const std::exception &e)\n            {\n                LOG_ERROR << e.what();\n                return optional<T>{};\n            }\n        }\n        else\n        {\n            return optional<T>{};\n        }\n    }\n\n    /// Return the remote IP address and port\n    virtual const trantor::InetAddress &peerAddr() const = 0;\n    const trantor::InetAddress &getPeerAddr() const\n    {\n        return peerAddr();\n    }\n\n    /// Return the local IP address and port\n    virtual const trantor::InetAddress &localAddr() const = 0;\n    const trantor::InetAddress &getLocalAddr() const\n    {\n        return localAddr();\n    }\n\n    /// Return the creation timestamp set by the framework.\n    virtual const trantor::Date &creationDate() const = 0;\n    const trantor::Date &getCreationDate() const\n    {\n        return creationDate();\n    }\n\n    /// Get the Json object of the request\n    /**\n     * The content type of the request must be 'application/json',\n     * otherwise the method returns an empty shared_ptr object.\n     */\n    virtual const std::shared_ptr<Json::Value> &jsonObject() const = 0;\n\n    /// Get the Json object of the request\n    const std::shared_ptr<Json::Value> &getJsonObject() const\n    {\n        return jsonObject();\n    }\n\n    /**\n     * @brief Get the error message of parsing the JSON body received from peer.\n     * This method usually is called after getting a empty shared_ptr object\n     * by the getJsonObject() method.\n     *\n     * @return const std::string& The error message. An empty string is returned\n     * when no error occurs.\n     */\n    virtual const std::string &getJsonError() const = 0;\n\n    /// Get the content type\n    virtual ContentType contentType() const = 0;\n    ContentType getContentType() const\n    {\n        return contentType();\n    }\n\n    /// Set the Http method\n    virtual void setMethod(const HttpMethod method) = 0;\n\n    /// Set the path of the request\n    virtual void setPath(const std::string &path) = 0;\n\n    /**\n     * @brief The default behavior is to encode the value of setPath\n     * using urlEncode. Setting the path encode to false avoid the\n     * value of path will be changed by the library\n     *\n     * @param bool true --> the path will be url encoded\n     *             false --> using value of path as it is set\n     */\n    virtual void setPathEncode(bool) = 0;\n\n    /// Set the parameter of the request\n    virtual void setParameter(const std::string &key,\n                              const std::string &value) = 0;\n\n    /// Set or get the content type\n    virtual void setContentTypeCode(const ContentType type) = 0;\n\n    /// Set the content-type string, The string may contain the header name and\n    /// CRLF. Or just the MIME type\n    //\n    /// For example, \"content-type: text/plain\\r\\n\" or \"text/plain\"\n    void setContentTypeString(const string_view &typeString)\n    {\n        setContentTypeString(typeString.data(), typeString.size());\n    }\n\n    /// Set the request content-type string, The string\n    /// must contain the header name and CRLF.\n    /// For example, \"content-type: text/plain\\r\\n\"\n    virtual void setCustomContentTypeString(const std::string &type) = 0;\n\n    /// Add a cookie\n    virtual void addCookie(const std::string &key,\n                           const std::string &value) = 0;\n\n    /**\n     * @brief Set the request object to the pass-through mode or not. It's not\n     * by default when a new request object is created.\n     * In pass-through mode, no addtional headers (including user-agent,\n     * connection, etc.) are added to the request. This mode is useful for some\n     * applications such as a proxy.\n     *\n     * @param flag\n     */\n    virtual void setPassThrough(bool flag) = 0;\n\n    /// The following methods are a series of factory methods that help users\n    /// create request objects.\n\n    /// Create a normal request with http method Get and version Http1.1.\n    static HttpRequestPtr newHttpRequest();\n\n    /// Create a http request with:\n    /// Method: Get\n    /// Version: Http1.1\n    /// Content type: application/json, the @param data is serialized into the\n    /// content of the request.\n    static HttpRequestPtr newHttpJsonRequest(const Json::Value &data);\n\n    /// Create a http request with:\n    /// Method: Post\n    /// Version: Http1.1\n    /// Content type: application/x-www-form-urlencoded\n    static HttpRequestPtr newHttpFormPostRequest();\n\n    /// Create a http file upload request with:\n    /// Method: Post\n    /// Version: Http1.1\n    /// Content type: multipart/form-data\n    /// The @param files represents pload files which are transferred to the\n    /// server via the multipart/form-data format\n    static HttpRequestPtr newFileUploadRequest(\n        const std::vector<UploadFile> &files);\n\n    /**\n     * @brief Create a custom HTTP request object. For using this template,\n     * users must specialize the toRequest template.\n     */\n    template <typename T>\n    static HttpRequestPtr newCustomHttpRequest(T &&obj)\n    {\n        return toRequest(std::forward<T>(obj));\n    }\n\n    virtual bool isOnSecureConnection() const noexcept = 0;\n    virtual void setContentTypeString(const char *typeString,\n                                      size_t typeStringLength) = 0;\n\n    virtual ~HttpRequest()\n    {\n    }\n};\n\ntemplate <>\ninline HttpRequestPtr toRequest<const Json::Value &>(const Json::Value &pJson)\n{\n    return HttpRequest::newHttpJsonRequest(pJson);\n}\n\ntemplate <>\ninline HttpRequestPtr toRequest(Json::Value &&pJson)\n{\n    return HttpRequest::newHttpJsonRequest(std::move(pJson));\n}\n\ntemplate <>\ninline std::shared_ptr<Json::Value> fromRequest(const HttpRequest &req)\n{\n    return req.getJsonObject();\n}\n\n}  // namespace drogon\n", "/**\n *  @file HttpResponse.h\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include <drogon/exports.h>\n#include <drogon/utils/string_view.h>\n#include <drogon/DrClassMap.h>\n#include <drogon/Cookie.h>\n#include <drogon/HttpTypes.h>\n#include <drogon/HttpViewData.h>\n#include <drogon/utils/Utilities.h>\n#include <json/json.h>\n#include <memory>\n#include <string>\n\nnamespace drogon\n{\n/// Abstract class for webapp developer to get or set the Http response;\nclass HttpResponse;\nusing HttpResponsePtr = std::shared_ptr<HttpResponse>;\n\n/**\n * @brief This template is used to convert a response object to a custom\n * type object. Users must specialize the template for a particular type.\n */\ntemplate <typename T>\nT fromResponse(const HttpResponse &resp)\n{\n    LOG_ERROR\n        << \"You must specialize the fromResponse template for the type of \"\n        << DrClassMap::demangle(typeid(T).name());\n    exit(1);\n}\n\n/**\n * @brief This template is used to create a response object from a custom\n * type object by calling the newCustomHttpResponse(). Users must specialize\n * the template for a particular type.\n */\ntemplate <typename T>\nHttpResponsePtr toResponse(T &&)\n{\n    LOG_ERROR << \"You must specialize the toResponse template for the type of \"\n              << DrClassMap::demangle(typeid(T).name());\n    exit(1);\n}\ntemplate <>\nHttpResponsePtr toResponse<const Json::Value &>(const Json::Value &pJson);\ntemplate <>\nHttpResponsePtr toResponse(Json::Value &&pJson);\ntemplate <>\ninline HttpResponsePtr toResponse<Json::Value &>(Json::Value &pJson)\n{\n    return toResponse((const Json::Value &)pJson);\n}\n\nclass DROGON_EXPORT HttpResponse\n{\n  public:\n    /**\n     * @brief This template enables automatic type conversion. For using this\n     * template, user must specialize the fromResponse template. For example a\n     * shared_ptr<Json::Value> specialization version is available above, so\n     * we can use the following code to get a json object:\n     * @code\n     *  std::shared_ptr<Json::Value> jsonPtr = *responsePtr;\n     *  @endcode\n     * With this template, user can use their favorite JSON library instead of\n     * the default jsoncpp library or convert the response to an object of any\n     * custom type.\n     */\n    template <typename T>\n    operator T() const\n    {\n        return fromResponse<T>(*this);\n    }\n\n    /**\n     * @brief This template enables explicit type conversion, see the above\n     * template.\n     */\n    template <typename T>\n    T as() const\n    {\n        return fromResponse<T>(*this);\n    }\n\n    /// Get the status code such as 200, 404\n    virtual HttpStatusCode statusCode() const = 0;\n    HttpStatusCode getStatusCode() const\n    {\n        return statusCode();\n    }\n\n    /// Set the status code of the response.\n    virtual void setStatusCode(HttpStatusCode code) = 0;\n\n    void setCustomStatusCode(int code, string_view message = string_view{})\n    {\n        setCustomStatusCode(code, message.data(), message.length());\n    }\n\n    /// Get the creation timestamp of the response.\n    virtual const trantor::Date &creationDate() const = 0;\n    const trantor::Date &getCreationDate() const\n    {\n        return creationDate();\n    }\n\n    /// Set the http version, http1.0 or http1.1\n    virtual void setVersion(const Version v) = 0;\n\n    /// Set if close the connection after the request is sent.\n    /**\n     * @param on if the parameter is false, the connection keeps alive on the\n     * condition that the client request has a 'keep-alive' head, otherwise it\n     * is closed immediately after sending the last byte of the response. It's\n     * false by default when the response is created.\n     */\n    virtual void setCloseConnection(bool on) = 0;\n\n    /// Get the status set by the setCloseConnection() method.\n    virtual bool ifCloseConnection() const = 0;\n\n    /// Set the response content type, such as text/html, text/plain, image/png\n    /// and so on. If the content type\n    /// is a text type, the character set is utf8.\n    virtual void setContentTypeCode(ContentType type) = 0;\n\n    /// Set the content-type string, The string may contain the header name and\n    /// CRLF. Or just the MIME type For example, \"content-type: text/plain\\r\\n\"\n    /// or \"text/plain\"\n    void setContentTypeString(const string_view &typeString)\n    {\n        setContentTypeString(typeString.data(), typeString.size());\n    }\n\n    /// Set the response content type and the content-type string, The string\n    /// may contain the header name and CRLF. Or just the MIME type\n    /// For example, \"content-type: text/plain\\r\\n\" or \"text/plain\"\n    void setContentTypeCodeAndCustomString(ContentType type,\n                                           const string_view &typeString)\n    {\n        setContentTypeCodeAndCustomString(type,\n                                          typeString.data(),\n                                          typeString.length());\n    }\n    template <int N>\n    void setContentTypeCodeAndCustomString(ContentType type,\n                                           const char (&typeString)[N])\n    {\n        assert(N > 0);\n        setContentTypeCodeAndCustomString(type, typeString, N - 1);\n    }\n\n    /// Set the reponse content type and the character set.\n    /// virtual void setContentTypeCodeAndCharacterSet(ContentType type, const\n    /// std::string &charSet = \"utf-8\") = 0;\n\n    /// Get the response content type.\n    virtual ContentType contentType() const = 0;\n    ContentType getContentType() const\n    {\n        return contentType();\n    }\n\n    /// Get the header string identified by the key parameter.\n    /**\n     * @note\n     * If there is no the header, a empty string is retured.\n     * The key is case insensitive\n     */\n    virtual const std::string &getHeader(std::string key) const = 0;\n\n    /**\n     * @brief  Remove the header identified by the key parameter.\n     *\n     * @param key The key is case insensitive\n     */\n    virtual void removeHeader(std::string key) = 0;\n\n    /// Get all headers of the response\n    virtual const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &headers() const = 0;\n\n    /// Get all headers of the response\n    const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &getHeaders() const\n    {\n        return headers();\n    }\n\n    /**\n     * @brief Set the header string identified by the field parameter\n     *\n     * @param field The field parameter is transformed to lower case before\n     * storing.\n     * @param value The value of the header.\n     */\n    virtual void addHeader(std::string field, const std::string &value) = 0;\n    virtual void addHeader(std::string field, std::string &&value) = 0;\n\n    /// Add a cookie\n    virtual void addCookie(const std::string &key,\n                           const std::string &value) = 0;\n\n    /// Add a cookie\n    virtual void addCookie(const Cookie &cookie) = 0;\n    virtual void addCookie(Cookie &&cookie) = 0;\n\n    /// Get the cookie identified by the key parameter.\n    /// If there is no the cookie, the empty cookie is retured.\n    virtual const Cookie &getCookie(const std::string &key) const = 0;\n\n    /// Get all cookies.\n    virtual const std::\n        unordered_map<std::string, Cookie, utils::internal::SafeStringHash>\n            &cookies() const = 0;\n\n    /// Get all cookies.\n    const std::\n        unordered_map<std::string, Cookie, utils::internal::SafeStringHash>\n            &getCookies() const\n    {\n        return cookies();\n    }\n\n    /// Remove the cookie identified by the key parameter.\n    virtual void removeCookie(const std::string &key) = 0;\n\n    /// Set the response body(content).\n    /**\n     * @note The body must match the content type\n     */\n    virtual void setBody(const std::string &body) = 0;\n\n    /// Set the response body(content).\n    virtual void setBody(std::string &&body) = 0;\n\n    /// Set the response body(content).\n    template <int N>\n    void setBody(const char (&body)[N])\n    {\n        assert(strnlen(body, N) == N - 1);\n        setBody(body, N - 1);\n    }\n\n    /// Get the response body.\n    string_view body() const\n    {\n        return string_view{getBodyData(), getBodyLength()};\n    }\n\n    /// Get the response body.\n    string_view getBody() const\n    {\n        return body();\n    }\n\n    /// Return the string of http version of request, such as HTTP/1.0,\n    /// HTTP/1.1, etc.\n    virtual const char *versionString() const = 0;\n    const char *getVersionString() const\n    {\n        return versionString();\n    }\n\n    /// Return the enum type version of the response.\n    /**\n     * kHttp10 means Http version is 1.0\n     * kHttp11 means Http verison is 1.1\n     */\n    virtual Version version() const = 0;\n\n    /// Return the enum type version of the response.\n    Version getVersion() const\n    {\n        return version();\n    }\n\n    /// Reset the reponse object to its initial state\n    virtual void clear() = 0;\n\n    /// Set the expiration time of the response cache in memory.\n    /// in seconds, 0 means always cache, negative means not cache, default is\n    /// -1.\n    virtual void setExpiredTime(ssize_t expiredTime) = 0;\n\n    /// Get the expiration time of the response.\n    virtual ssize_t expiredTime() const = 0;\n    ssize_t getExpiredTime() const\n    {\n        return expiredTime();\n    }\n\n    /// Get the json object from the server response.\n    /// If the response is not in json format, then a empty shared_ptr is\n    /// retured.\n    virtual const std::shared_ptr<Json::Value> &jsonObject() const = 0;\n    const std::shared_ptr<Json::Value> &getJsonObject() const\n    {\n        return jsonObject();\n    }\n\n    /**\n     * @brief Get the error message of parsing the JSON body received from peer.\n     * This method usually is called after getting a empty shared_ptr object\n     * by the getJsonObject() method.\n     *\n     * @return const std::string& The error message. An empty string is returned\n     * when no error occurs.\n     */\n    virtual const std::string &getJsonError() const = 0;\n\n    /**\n     * @brief Set the reponse object to the pass-through mode or not. It's not\n     * by default when a new response object is created.\n     * In pass-through mode, no addtional headers (including server, date,\n     * content-type and content-length, etc.) are added to the response. This\n     * mode is useful for some applications such as a proxy.\n     *\n     * @param flag\n     */\n    virtual void setPassThrough(bool flag) = 0;\n\n    /* The following methods are a series of factory methods that help users\n     * create response objects. */\n\n    /// Create a normal response with a status code of 200ok and a content type\n    /// of text/html.\n    static HttpResponsePtr newHttpResponse();\n    /// Create a response which returns a 404 page.\n    static HttpResponsePtr newNotFoundResponse();\n    /// Create a response which returns a json object. Its content type is set\n    /// to set/json.\n    static HttpResponsePtr newHttpJsonResponse(const Json::Value &data);\n    static HttpResponsePtr newHttpJsonResponse(Json::Value &&data);\n    /// Create a response that returns a page rendered by a view named\n    /// viewName.\n    /**\n     * @param viewName The name of the view\n     * @param data is the data displayed on the page.\n     * @note For more details, see the wiki pages, the \"View\" section.\n     */\n    static HttpResponsePtr newHttpViewResponse(\n        const std::string &viewName,\n        const HttpViewData &data = HttpViewData());\n\n    /// Create a response that returns a redirection page, redirecting to\n    /// another page located in the location parameter.\n    /**\n     * @param location The location to redirect\n     * @param status The HTTP status code, k302Found by default. Users could set\n     * it to one of the 301, 302, 303, 307, ...\n     */\n    static HttpResponsePtr newRedirectionResponse(\n        const std::string &location,\n        HttpStatusCode status = k302Found);\n\n    /// Create a response that returns a file to the client.\n    /**\n     * @param fullPath is the full path to the file.\n     * @param attachmentFileName if the parameter is not empty, the browser\n     * does not open the file, but saves it as an attachment.\n     * @param type the content type code. If the parameter is CT_NONE, the\n     * content type is set by drogon based on the file extension and typeString.\n     * Set it to CT_CUSTOM when no drogon internal content type matches.\n     * @param typeString the MIME string of the content type.\n     */\n    static HttpResponsePtr newFileResponse(\n        const std::string &fullPath,\n        const std::string &attachmentFileName = \"\",\n        ContentType type = CT_NONE,\n        const std::string &typeString = \"\");\n\n    /// Create a response that returns part of a file to the client.\n    /**\n     * @brief If offset and length can not be satisfied, statusCode will be set\n     * to k416RequestedRangeNotSatisfiable, and nothing else will be modified.\n     *\n     * @param fullPath is the full path to the file.\n     * @param offset is the offset to begin sending, in bytes.\n     * @param length is the total length to send, in bytes. In particular,\n     * length = 0 means send all content from offset till end of file.\n     * @param setContentRange whether set 'Content-Range' header automatically.\n     * @param attachmentFileName if the parameter is not empty, the browser\n     * does not open the file, but saves it as an attachment.\n     * @param type the content type code. If the parameter is CT_NONE, the\n     * content type is set by drogon based on the file extension and typeString.\n     * Set it to CT_CUSTOM when no drogon internal content type matches.\n     * @param typeString the MIME string of the content type.\n     */\n    static HttpResponsePtr newFileResponse(\n        const std::string &fullPath,\n        size_t offset,\n        size_t length,\n        bool setContentRange = true,\n        const std::string &attachmentFileName = \"\",\n        ContentType type = CT_NONE,\n        const std::string &typeString = \"\");\n\n    /// Create a response that returns a file to the client from buffer in\n    /// memory/stack\n    /**\n     * @param pBuffer is a uint 8 bit flat buffer for object/files in memory\n     * @param bufferLength is the length of the expected buffer\n     * @param attachmentFileName if the parameter is not empty, the browser\n     * does not open the file, but saves it as an attachment.\n     * @param type the content type code. If the parameter is CT_NONE, the\n     * content type is set by drogon based on the file extension and typeString.\n     * Set it to CT_CUSTOM when no drogon internal content type matches.\n     * @param typeString the MIME string of the content type.\n     */\n    static HttpResponsePtr newFileResponse(\n        const unsigned char *pBuffer,\n        size_t bufferLength,\n        const std::string &attachmentFileName = \"\",\n        ContentType type = CT_NONE,\n        const std::string &typeString = \"\");\n\n    /// Create a response that returns a file to the client from a callback\n    /// function\n    /**\n     * @note if the Connection is keep-alive and the Content-Length header is\n     * not set, the stream data is sent with Transfer-Encoding: chunked.\n     * @param function to retrieve the stream data (stream ends when a zero size\n     * is returned) the callback will be called with nullptr when the send is\n     * finished/interruped so that it cleans up its internals.\n     * @param attachmentFileName if the parameter is not empty, the browser\n     *                           does not open the file, but saves it as an\n     * attachment.\n     * @param type the content type code. If the parameter is CT_NONE, the\n     *             content type is set by drogon based on the file extension and\n     * typeString. Set it to CT_CUSTOM when no drogon internal content type\n     * matches.\n     * @param typeString the MIME string of the content type.\n     */\n    static HttpResponsePtr newStreamResponse(\n        const std::function<std::size_t(char *, std::size_t)> &callback,\n        const std::string &attachmentFileName = \"\",\n        ContentType type = CT_NONE,\n        const std::string &typeString = \"\");\n\n    /**\n     * @brief Create a custom HTTP response object. For using this template,\n     * users must specialize the toResponse template.\n     */\n    template <typename T>\n    static HttpResponsePtr newCustomHttpResponse(T &&obj)\n    {\n        return toResponse(std::forward<T>(obj));\n    }\n\n    /**\n     * @brief If the response is a file response (i.e. created by\n     * newFileResponse) returns the path on the filesystem. Otherwise a\n     * empty string.\n     */\n    virtual const std::string &sendfileName() const = 0;\n\n    /**\n     * @brief Returns the range of the file response as a pair ot size_t\n     * (offset, length). Length of 0 means the entire file is sent. Behaivor of\n     * this function is undefined if the response if not a file response\n     */\n    using SendfileRange = std::pair<size_t, size_t>;  // { offset, length }\n    virtual const SendfileRange &sendfileRange() const = 0;\n\n    /**\n     * @brief If the response is a stream response (i.e. created by\n     * newStreamResponse) returns the callback function. Otherwise a\n     * null function.\n     */\n    virtual const std::function<std::size_t(char *, std::size_t)>\n        &streamCallback() const = 0;\n\n    /**\n     * @brief Returns the content type associated with the response\n     */\n    virtual std::string contentTypeString() const = 0;\n\n    virtual ~HttpResponse()\n    {\n    }\n\n  private:\n    virtual void setBody(const char *body, size_t len) = 0;\n    virtual const char *getBodyData() const = 0;\n    virtual size_t getBodyLength() const = 0;\n    virtual void setContentTypeCodeAndCustomString(ContentType type,\n                                                   const char *typeString,\n                                                   size_t typeStringLength) = 0;\n    virtual void setContentTypeString(const char *typeString,\n                                      size_t typeStringLength) = 0;\n    virtual void setCustomStatusCode(int code,\n                                     const char *message,\n                                     size_t messageLength) = 0;\n};\ntemplate <>\ninline HttpResponsePtr toResponse<const Json::Value &>(const Json::Value &pJson)\n{\n    return HttpResponse::newHttpJsonResponse(pJson);\n}\n\ntemplate <>\ninline HttpResponsePtr toResponse(Json::Value &&pJson)\n{\n    return HttpResponse::newHttpJsonResponse(std::move(pJson));\n}\n\ntemplate <>\ninline std::shared_ptr<Json::Value> fromResponse(const HttpResponse &resp)\n{\n    return resp.getJsonObject();\n}\n}  // namespace drogon\n", "/**\n *\n *  @file Utilities.h\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include <drogon/exports.h>\n#include <trantor/utils/Date.h>\n#include <trantor/utils/Funcs.h>\n#include <trantor/utils/Utilities.h>\n#include <drogon/utils/string_view.h>\n#include <memory>\n#include <string>\n#include <vector>\n#include <set>\n#include <limits>\n#include <sstream>\n#include <algorithm>\n#ifdef _WIN32\n#include <time.h>\nDROGON_EXPORT char *strptime(const char *s, const char *f, struct tm *tm);\nDROGON_EXPORT time_t timegm(struct tm *tm);\n#endif\nnamespace drogon\n{\nnamespace internal\n{\ntemplate <typename T>\nstruct CanConvertFromStringStream\n{\n  private:\n    using yes = std::true_type;\n    using no = std::false_type;\n\n    template <typename U>\n    static auto test(U *p, std::stringstream &&ss)\n        -> decltype((ss >> *p), yes());\n\n    template <typename>\n    static no test(...);\n\n  public:\n    static constexpr bool value =\n        std::is_same<decltype(test<T>(nullptr, std::stringstream())),\n                     yes>::value;\n};\n}  // namespace internal\nnamespace utils\n{\n/// Determine if the string is an integer\nDROGON_EXPORT bool isInteger(const std::string &str);\n\n/// Generate random a string\n/**\n * @param length The string length\n * The returned string consists of uppercase and lowercase letters and numbers\n */\nDROGON_EXPORT std::string genRandomString(int length);\n\n/// Convert a binary string to hex format\nDROGON_EXPORT std::string binaryStringToHex(const unsigned char *ptr,\n                                            size_t length);\n\n/// Get a binary string from hexadecimal format\nDROGON_EXPORT std::string hexToBinaryString(const char *ptr, size_t length);\n\n/// Get a binary vector from hexadecimal format\nDROGON_EXPORT std::vector<char> hexToBinaryVector(const char *ptr,\n                                                  size_t length);\n\n/// Split the string into multiple separated strings.\n/**\n * @param acceptEmptyString if true, empty strings are accepted in the\n * result, for example, splitting the \",1,2,,3,\" by \",\" produces\n * [\"\",\"1\",\"2\",\"\",\"3\",\"\"]\n */\ninline std::vector<std::string> splitString(const std::string &str,\n                                            const std::string &separator,\n                                            bool acceptEmptyString = false)\n{\n    return trantor::splitString(str, separator, acceptEmptyString);\n}\n\nDROGON_EXPORT std::set<std::string> splitStringToSet(\n    const std::string &str,\n    const std::string &separator);\n\n/// Get UUID string.\nDROGON_EXPORT std::string getUuid();\n\n/// Encode the string to base64 format.\nDROGON_EXPORT std::string base64Encode(const unsigned char *bytes_to_encode,\n                                       unsigned int in_len,\n                                       bool url_safe = false);\n\n/// Decode the base64 format string.\nDROGON_EXPORT std::string base64Decode(const std::string &encoded_string);\nDROGON_EXPORT std::vector<char> base64DecodeToVector(\n    const std::string &encoded_string);\n\n/// Check if the string need decoding\nDROGON_EXPORT bool needUrlDecoding(const char *begin, const char *end);\n\n/// Decode from or encode to the URL format string\nDROGON_EXPORT std::string urlDecode(const char *begin, const char *end);\ninline std::string urlDecode(const std::string &szToDecode)\n{\n    auto begin = szToDecode.data();\n    return urlDecode(begin, begin + szToDecode.length());\n}\ninline std::string urlDecode(const string_view &szToDecode)\n{\n    auto begin = szToDecode.data();\n    return urlDecode(begin, begin + szToDecode.length());\n}\n\nDROGON_EXPORT std::string urlEncode(const std::string &);\nDROGON_EXPORT std::string urlEncodeComponent(const std::string &);\n\n/// Get the MD5 digest of a string.\nDROGON_EXPORT std::string getMd5(const char *data, const size_t dataLen);\ninline std::string getMd5(const std::string &originalString)\n{\n    return getMd5(originalString.data(), originalString.length());\n}\n\n/// Commpress or decompress data using gzip lib.\n/**\n * @param data the input data\n * @param ndata the input data length\n */\nDROGON_EXPORT std::string gzipCompress(const char *data, const size_t ndata);\nDROGON_EXPORT std::string gzipDecompress(const char *data, const size_t ndata);\n\n/// Commpress or decompress data using brotli lib.\n/**\n * @param data the input data\n * @param ndata the input data length\n */\nDROGON_EXPORT std::string brotliCompress(const char *data, const size_t ndata);\nDROGON_EXPORT std::string brotliDecompress(const char *data,\n                                           const size_t ndata);\n\n/// Get the http full date string\n/**\n * rfc2616-3.3.1\n * Full Date format(RFC 822)\n * like this:\n * @code\n   Sun, 06 Nov 1994 08:49:37 GMT\n   Wed, 12 Sep 2018 09:22:40 GMT\n   @endcode\n */\nDROGON_EXPORT char *getHttpFullDate(\n    const trantor::Date &date = trantor::Date::now());\n\n/// Get the trantor::Date object according to the http full date string\n/**\n * Returns trantor::Date(std::numeric_limits<int64_t>::max()) upon failure.\n */\nDROGON_EXPORT trantor::Date getHttpDate(const std::string &httpFullDateString);\n\n/// Get a formatted string\nDROGON_EXPORT std::string formattedString(const char *format, ...);\n\n/// Recursively create a file system path\n/**\n * Return 0 or -1 on success or failure.\n */\nDROGON_EXPORT int createPath(const std::string &path);\n\n/**\n * @details Convert a wide string path with arbitrary directory separators\n * to a UTF-8 portable path for use with trantor.\n *\n * This is a helper, mainly for Windows and multi-platform projects.\n *\n * @note On Windows, backslash directory separators are converted to slash to\n * keep portable paths.\n *\n * @remarks On other OSes, backslashes are not converted to slash, since they\n * are valid characters for directory/file names.\n *\n * @param strPath Wide string path.\n *\n * @return std::string UTF-8 path, with slash directory separator.\n */\ninline std::string fromWidePath(const std::wstring &strPath)\n{\n    return trantor::utils::fromWidePath(strPath);\n}\n\n/**\n * @details Convert a UTF-8 path with arbitrary directory separator to a wide\n * string path.\n *\n * This is a helper, mainly for Windows and multi-platform projects.\n *\n * @note On Windows, slash directory separators are converted to backslash.\n * Although it accepts both slash and backslash as directory separator in its\n * API, it is better to stick to its standard.\n\n * @remarks On other OSes, slashes are not converted to backslashes, since they\n * are not interpreted as directory separators and are valid characters for\n * directory/file names.\n *\n * @param strUtf8Path Ascii path considered as being UTF-8.\n *\n * @return std::wstring path with, on windows, standard backslash directory\n * separator to stick to its standard.\n */\ninline std::wstring toWidePath(const std::string &strUtf8Path)\n{\n    return trantor::utils::toWidePath(strUtf8Path);\n}\n\n/**\n * @brief Convert a generic (UTF-8) path with to an OS native path.\n * @details This is a helper, mainly for Windows and multi-platform projects.\n *\n * On Windows, slash directory separators are converted to backslash, and a\n * wide string is returned.\n *\n * On other OSes, returns an UTF-8 string _without_ altering the directory\n * separators.\n *\n * @param strPath Wide string or UTF-8 path.\n *\n * @return An OS path, suitable for use with the OS API.\n */\n#if defined(_WIN32) && !defined(__MINGW32__)\ninline std::wstring toNativePath(const std::string &strPath)\n{\n    return trantor::utils::toNativePath(strPath);\n}\ninline const std::wstring &toNativePath(const std::wstring &strPath)\n{\n    return trantor::utils::toNativePath(strPath);\n}\n#else   // __WIN32\ninline const std::string &toNativePath(const std::string &strPath)\n{\n    return trantor::utils::toNativePath(strPath);\n}\ninline std::string toNativePath(const std::wstring &strPath)\n{\n    return trantor::utils::toNativePath(strPath);\n}\n#endif  // _WIN32\n/**\n * @brief Convert a OS native path (wide string on Windows) to a generic UTF-8\n * path.\n * @details This is a helper, mainly for Windows and multi-platform projects.\n *\n * On Windows, backslash directory separators are converted to slash, and a\n * a UTF-8 string is returned, suitable for libraries that supports UTF-8 paths\n * like OpenSSL or drogon.\n *\n * On other OSes, returns an UTF-8 string without altering the directory\n * separators (backslashes are *NOT* replaced with slashes, since they\n * are valid characters for directory/file names).\n *\n * @param strPath Wide string or UTF-8 path.\n *\n * @return A generic path.\n */\ninline const std::string &fromNativePath(const std::string &strPath)\n{\n    return trantor::utils::fromNativePath(strPath);\n}\n// Convert on all systems\ninline std::string fromNativePath(const std::wstring &strPath)\n{\n    return trantor::utils::fromNativePath(strPath);\n}\n\n/// Replace all occurances of from to to inplace\n/**\n * @param from string to replace\n * @param to string to replace with\n */\nDROGON_EXPORT void replaceAll(std::string &s,\n                              const std::string &from,\n                              const std::string &to);\n\n/**\n * @brief Generates cryptographically secure random bytes.\n *\n * @param ptr the pointer which the random bytes are stored to\n * @param size number of bytes to generate\n *\n * @return true if generation is successfull. False otherwise\n *\n * @note DO NOT abuse this function. Especially if Drogon is built without\n * OpenSSL. Entropy running low is a real issue.\n */\nDROGON_EXPORT bool secureRandomBytes(void *ptr, size_t size);\n\ntemplate <typename T>\ntypename std::enable_if<internal::CanConvertFromStringStream<T>::value, T>::type\nfromString(const std::string &p) noexcept(false)\n{\n    T value{};\n    if (!p.empty())\n    {\n        std::stringstream ss(p);\n        ss >> value;\n    }\n    return value;\n}\n\ntemplate <typename T>\ntypename std::enable_if<!(internal::CanConvertFromStringStream<T>::value),\n                        T>::type\nfromString(const std::string &) noexcept(false)\n{\n    throw std::runtime_error(\"Bad type conversion\");\n}\n\ntemplate <>\ninline std::string fromString<std::string>(const std::string &p) noexcept(false)\n{\n    return p;\n}\n\ntemplate <>\ninline int fromString<int>(const std::string &p) noexcept(false)\n{\n    return std::stoi(p);\n}\n\ntemplate <>\ninline long fromString<long>(const std::string &p) noexcept(false)\n{\n    return std::stol(p);\n}\n\ntemplate <>\ninline long long fromString<long long>(const std::string &p) noexcept(false)\n{\n    return std::stoll(p);\n}\n\ntemplate <>\ninline unsigned long fromString<unsigned long>(const std::string &p) noexcept(\n    false)\n{\n    return std::stoul(p);\n}\n\ntemplate <>\ninline unsigned long long fromString<unsigned long long>(\n    const std::string &p) noexcept(false)\n{\n    return std::stoull(p);\n}\n\ntemplate <>\ninline float fromString<float>(const std::string &p) noexcept(false)\n{\n    return std::stof(p);\n}\n\ntemplate <>\ninline double fromString<double>(const std::string &p) noexcept(false)\n{\n    return std::stod(p);\n}\n\ntemplate <>\ninline long double fromString<long double>(const std::string &p) noexcept(false)\n{\n    return std::stold(p);\n}\n\ntemplate <>\ninline bool fromString<bool>(const std::string &p) noexcept(false)\n{\n    if (p == \"1\")\n    {\n        return true;\n    }\n    if (p == \"0\")\n    {\n        return false;\n    }\n    std::string l{p};\n    std::transform(p.begin(), p.end(), l.begin(), [](unsigned char c) {\n        return tolower(c);\n    });\n    if (l == \"true\")\n    {\n        return true;\n    }\n    else if (l == \"false\")\n    {\n        return false;\n    }\n    throw std::runtime_error(\"Can't convert from string '\" + p + \"' to bool\");\n}\n\nnamespace internal\n{\nDROGON_EXPORT extern const size_t fixedRandomNumber;\nstruct SafeStringHash\n{\n    size_t operator()(const std::string &str) const\n    {\n        const size_t A = 6665339;\n        const size_t B = 2534641;\n        size_t h = fixedRandomNumber;\n        for (char ch : str)\n            h = (h * A) ^ (ch * B);\n        return h;\n    }\n};\n}  // namespace internal\n}  // namespace utils\n}  // namespace drogon\n", "/**\n *\n *  @file HttpRequestImpl.h\n *  An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include \"HttpUtils.h\"\n#include \"CacheFile.h\"\n#include <drogon/utils/Utilities.h>\n#include <drogon/HttpRequest.h>\n#include <drogon/utils/Utilities.h>\n#include <trantor/net/EventLoop.h>\n#include <trantor/net/InetAddress.h>\n#include <trantor/utils/Logger.h>\n#include <trantor/utils/MsgBuffer.h>\n#include <trantor/utils/NonCopyable.h>\n#include <algorithm>\n#include <string>\n#include <thread>\n#include <unordered_map>\n#include <assert.h>\n#include <stdio.h>\n\nnamespace drogon\n{\nenum class StreamDecompressStatus\n{\n    TooLarge,\n    DecompressError,\n    NotSupported,\n    Ok\n};\n\nclass HttpRequestImpl : public HttpRequest\n{\n  public:\n    friend class HttpRequestParser;\n\n    explicit HttpRequestImpl(trantor::EventLoop *loop)\n        : creationDate_(trantor::Date::now()), loop_(loop)\n    {\n    }\n    void reset()\n    {\n        method_ = Invalid;\n        version_ = Version::kUnknown;\n        flagForParsingJson_ = false;\n        headers_.clear();\n        cookies_.clear();\n        flagForParsingParameters_ = false;\n        path_.clear();\n        pathEncode_ = true;\n        matchedPathPattern_ = \"\";\n        query_.clear();\n        parameters_.clear();\n        jsonPtr_.reset();\n        sessionPtr_.reset();\n        attributesPtr_.reset();\n        cacheFilePtr_.reset();\n        expectPtr_.reset();\n        content_.clear();\n        contentType_ = CT_TEXT_PLAIN;\n        flagForParsingContentType_ = false;\n        contentTypeString_.clear();\n        keepAlive_ = true;\n        jsonParsingErrorPtr_.reset();\n    }\n    trantor::EventLoop *getLoop()\n    {\n        return loop_;\n    }\n\n    void setVersion(Version v)\n    {\n        version_ = v;\n        if (version_ == Version::kHttp10)\n        {\n            keepAlive_ = false;\n        }\n    }\n\n    Version version() const override\n    {\n        return version_;\n    }\n\n    const char *versionString() const override;\n\n    bool setMethod(const char *start, const char *end);\n    void setSecure(bool secure)\n    {\n        isOnSecureConnection_ = secure;\n    }\n\n    void setMethod(const HttpMethod method) override\n    {\n        method_ = method;\n        return;\n    }\n\n    HttpMethod method() const override\n    {\n        return method_;\n    }\n\n    const char *methodString() const override;\n\n    void setPath(const char *start, const char *end)\n    {\n        if (utils::needUrlDecoding(start, end))\n        {\n            path_ = utils::urlDecode(start, end);\n        }\n        else\n        {\n            path_.append(start, end);\n        }\n    }\n\n    void setPath(const std::string &path) override\n    {\n        path_ = path;\n    }\n\n    void setPathEncode(bool pathEncode) override\n    {\n        pathEncode_ = pathEncode;\n    }\n\n    const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &parameters() const override\n    {\n        parseParametersOnce();\n        return parameters_;\n    }\n\n    const std::string &getParameter(const std::string &key) const override\n    {\n        const static std::string defaultVal;\n        parseParametersOnce();\n        auto iter = parameters_.find(key);\n        if (iter != parameters_.end())\n            return iter->second;\n        return defaultVal;\n    }\n\n    const std::string &path() const override\n    {\n        return path_;\n    }\n\n    void setQuery(const char *start, const char *end)\n    {\n        query_.assign(start, end);\n    }\n\n    void setQuery(const std::string &query)\n    {\n        query_ = query;\n    }\n\n    string_view bodyView() const\n    {\n        if (cacheFilePtr_)\n        {\n            return cacheFilePtr_->getStringView();\n        }\n        return content_;\n    }\n    const char *bodyData() const override\n    {\n        if (cacheFilePtr_)\n        {\n            return cacheFilePtr_->getStringView().data();\n        }\n        return content_.data();\n    }\n    size_t bodyLength() const override\n    {\n        if (cacheFilePtr_)\n        {\n            return cacheFilePtr_->getStringView().length();\n        }\n        return content_.length();\n    }\n\n    void appendToBody(const char *data, size_t length);\n\n    void reserveBodySize(size_t length);\n\n    string_view queryView() const\n    {\n        return query_;\n    }\n\n    string_view contentView() const\n    {\n        if (cacheFilePtr_)\n            return cacheFilePtr_->getStringView();\n        return content_;\n    }\n\n    const std::string &query() const override\n    {\n        return query_;\n    }\n\n    const trantor::InetAddress &peerAddr() const override\n    {\n        return peer_;\n    }\n\n    const trantor::InetAddress &localAddr() const override\n    {\n        return local_;\n    }\n\n    const trantor::Date &creationDate() const override\n    {\n        return creationDate_;\n    }\n\n    void setCreationDate(const trantor::Date &date)\n    {\n        creationDate_ = date;\n    }\n\n    void setPeerAddr(const trantor::InetAddress &peer)\n    {\n        peer_ = peer;\n    }\n\n    void setLocalAddr(const trantor::InetAddress &local)\n    {\n        local_ = local;\n    }\n\n    void addHeader(const char *start, const char *colon, const char *end);\n\n    void removeHeader(std::string key) override\n    {\n        transform(key.begin(), key.end(), key.begin(), [](unsigned char c) {\n            return tolower(c);\n        });\n        removeHeaderBy(key);\n    }\n\n    void removeHeaderBy(const std::string &lowerKey)\n    {\n        headers_.erase(lowerKey);\n    }\n\n    const std::string &getHeader(std::string field) const override\n    {\n        std::transform(field.begin(),\n                       field.end(),\n                       field.begin(),\n                       [](unsigned char c) { return tolower(c); });\n        return getHeaderBy(field);\n    }\n\n    const std::string &getHeaderBy(const std::string &lowerField) const\n    {\n        const static std::string defaultVal;\n        auto it = headers_.find(lowerField);\n        if (it != headers_.end())\n        {\n            return it->second;\n        }\n        return defaultVal;\n    }\n\n    const std::string &getCookie(const std::string &field) const override\n    {\n        const static std::string defaultVal;\n        auto it = cookies_.find(field);\n        if (it != cookies_.end())\n        {\n            return it->second;\n        }\n        return defaultVal;\n    }\n\n    const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &headers() const override\n    {\n        return headers_;\n    }\n\n    const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &cookies() const override\n    {\n        return cookies_;\n    }\n\n    void setParameter(const std::string &key, const std::string &value) override\n    {\n        flagForParsingParameters_ = true;\n        parameters_[key] = value;\n    }\n\n    const std::string &getContent() const\n    {\n        return content_;\n    }\n\n    void swap(HttpRequestImpl &that) noexcept;\n\n    void setContent(const std::string &content)\n    {\n        content_ = content;\n    }\n\n    void setBody(const std::string &body) override\n    {\n        content_ = body;\n    }\n\n    void setBody(std::string &&body) override\n    {\n        content_ = std::move(body);\n    }\n\n    void addHeader(std::string field, const std::string &value) override\n    {\n        transform(field.begin(),\n                  field.end(),\n                  field.begin(),\n                  [](unsigned char c) { return tolower(c); });\n        headers_[std::move(field)] = value;\n    }\n\n    void addHeader(std::string field, std::string &&value) override\n    {\n        transform(field.begin(),\n                  field.end(),\n                  field.begin(),\n                  [](unsigned char c) { return tolower(c); });\n        headers_[std::move(field)] = std::move(value);\n    }\n\n    void addCookie(const std::string &key, const std::string &value) override\n    {\n        cookies_[key] = value;\n    }\n\n    void setPassThrough(bool flag) override\n    {\n        passThrough_ = flag;\n    }\n\n    bool passThrough() const\n    {\n        return passThrough_;\n    }\n\n    void appendToBuffer(trantor::MsgBuffer *output) const;\n\n    const SessionPtr &session() const override\n    {\n        return sessionPtr_;\n    }\n\n    void setSession(const SessionPtr &session)\n    {\n        sessionPtr_ = session;\n    }\n\n    const AttributesPtr &attributes() const override\n    {\n        if (!attributesPtr_)\n        {\n            attributesPtr_ = std::make_shared<Attributes>();\n        }\n        return attributesPtr_;\n    }\n\n    const std::shared_ptr<Json::Value> &jsonObject() const override\n    {\n        // Not multi-thread safe but good, because we basically call this\n        // function in a single thread\n        if (!flagForParsingJson_)\n        {\n            flagForParsingJson_ = true;\n            parseJson();\n        }\n        return jsonPtr_;\n    }\n\n    void setCustomContentTypeString(const std::string &type) override\n    {\n        contentType_ = CT_NONE;\n        flagForParsingContentType_ = true;\n        bool haveHeader = type.find(\"content-type: \") == 0;\n        bool haveCRLF = type.rfind(\"\\r\\n\") == type.size() - 2;\n\n        size_t endOffset = 0;\n        if (haveHeader)\n            endOffset += 14;\n        if (haveCRLF)\n            endOffset += 2;\n        contentTypeString_ = std::string(type.begin() + (haveHeader ? 14 : 0),\n                                         type.end() - endOffset);\n    }\n    void setContentTypeCode(const ContentType type) override\n    {\n        contentType_ = type;\n        flagForParsingContentType_ = true;\n        auto &typeStr = contentTypeToMime(type);\n        setContentType(std::string(typeStr.data(), typeStr.length()));\n    }\n\n    void setContentTypeString(const char *typeString,\n                              size_t typeStringLength) override;\n\n    // void setContentTypeCodeAndCharacterSet(ContentType type, const\n    // std::string &charSet = \"utf-8\") override\n    // {\n    //     contentType_ = type;\n    //     setContentType(webContentTypeAndCharsetToString(type, charSet));\n    // }\n\n    ContentType contentType() const override\n    {\n        parseContentTypeAndString();\n        return contentType_;\n    }\n\n    const char *matchedPathPatternData() const override\n    {\n        return matchedPathPattern_.data();\n    }\n    size_t matchedPathPatternLength() const override\n    {\n        return matchedPathPattern_.length();\n    }\n\n    void setMatchedPathPattern(const std::string &pathPattern)\n    {\n        matchedPathPattern_ = pathPattern;\n    }\n    const std::string &expect() const\n    {\n        const static std::string none{\"\"};\n        if (expectPtr_)\n            return *expectPtr_;\n        return none;\n    }\n    bool keepAlive() const\n    {\n        return keepAlive_;\n    }\n    bool isOnSecureConnection() const noexcept override\n    {\n        return isOnSecureConnection_;\n    }\n    const std::string &getJsonError() const override\n    {\n        const static std::string none{\"\"};\n        if (jsonParsingErrorPtr_)\n            return *jsonParsingErrorPtr_;\n        return none;\n    }\n    StreamDecompressStatus decompressBody();\n\n    ~HttpRequestImpl();\n\n  protected:\n    friend class HttpRequest;\n    void setContentType(const std::string &contentType)\n    {\n        contentTypeString_ = contentType;\n    }\n    void setContentType(std::string &&contentType)\n    {\n        contentTypeString_ = std::move(contentType);\n    }\n\n    void parseContentTypeAndString() const\n    {\n        if (!flagForParsingContentType_)\n        {\n            flagForParsingContentType_ = true;\n            auto &contentTypeString = getHeaderBy(\"content-type\");\n            if (contentTypeString == \"\")\n            {\n                contentType_ = CT_NONE;\n            }\n            else\n            {\n                auto pos = contentTypeString.find(';');\n                if (pos != std::string::npos)\n                {\n                    contentType_ = parseContentType(\n                        string_view(contentTypeString.data(), pos));\n                }\n                else\n                {\n                    contentType_ =\n                        parseContentType(string_view(contentTypeString));\n                }\n\n                if (contentType_ == CT_NONE)\n                    contentType_ = CT_CUSTOM;\n                contentTypeString_ = contentTypeString;\n            }\n        }\n    }\n\n  private:\n    void parseParameters() const;\n    void parseParametersOnce() const\n    {\n        // Not multi-thread safe but good, because we basically call this\n        // function in a single thread\n        if (!flagForParsingParameters_)\n        {\n            flagForParsingParameters_ = true;\n            parseParameters();\n        }\n    }\n    void createTmpFile();\n    void parseJson() const;\n#ifdef USE_BROTLI\n    StreamDecompressStatus decompressBodyBrotli() noexcept;\n#endif\n    StreamDecompressStatus decompressBodyGzip() noexcept;\n    mutable bool flagForParsingParameters_{false};\n    mutable bool flagForParsingJson_{false};\n    HttpMethod method_{Invalid};\n    Version version_{Version::kUnknown};\n    std::string path_;\n    bool pathEncode_{true};\n    string_view matchedPathPattern_{\"\"};\n    std::string query_;\n    std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            headers_;\n    std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            cookies_;\n    mutable std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            parameters_;\n    mutable std::shared_ptr<Json::Value> jsonPtr_;\n    SessionPtr sessionPtr_;\n    mutable AttributesPtr attributesPtr_;\n    trantor::InetAddress peer_;\n    trantor::InetAddress local_;\n    trantor::Date creationDate_;\n    std::unique_ptr<CacheFile> cacheFilePtr_;\n    mutable std::unique_ptr<std::string> jsonParsingErrorPtr_;\n    std::unique_ptr<std::string> expectPtr_;\n    bool keepAlive_{true};\n    bool isOnSecureConnection_{false};\n    bool passThrough_{false};\n\n  protected:\n    std::string content_;\n    trantor::EventLoop *loop_;\n    mutable ContentType contentType_{CT_TEXT_PLAIN};\n    mutable bool flagForParsingContentType_{false};\n    mutable std::string contentTypeString_;\n};\n\nusing HttpRequestImplPtr = std::shared_ptr<HttpRequestImpl>;\n\ninline void swap(HttpRequestImpl &one, HttpRequestImpl &two) noexcept\n{\n    one.swap(two);\n}\n\n}  // namespace drogon\n", "/**\n *\n *  @file HttpResponseImpl.h\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#pragma once\n\n#include \"HttpUtils.h\"\n#include \"HttpMessageBody.h\"\n#include <drogon/exports.h>\n#include <drogon/HttpResponse.h>\n#include <drogon/utils/Utilities.h>\n#include <trantor/net/InetAddress.h>\n#include <trantor/utils/Date.h>\n#include <trantor/utils/MsgBuffer.h>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <atomic>\n#include <unordered_map>\n\nnamespace drogon\n{\nclass DROGON_EXPORT HttpResponseImpl : public HttpResponse\n{\n    friend class HttpResponseParser;\n\n  public:\n    HttpResponseImpl() : creationDate_(trantor::Date::now())\n    {\n    }\n    HttpResponseImpl(HttpStatusCode code, ContentType type)\n        : statusCode_(code),\n          statusMessage_(statusCodeToString(code)),\n          creationDate_(trantor::Date::now()),\n          contentType_(type),\n          flagForParsingContentType_(true),\n          contentTypeString_(contentTypeToMime(type))\n    {\n    }\n    void setPassThrough(bool flag) override\n    {\n        passThrough_ = flag;\n    }\n    HttpStatusCode statusCode() const override\n    {\n        return statusCode_;\n    }\n\n    const trantor::Date &creationDate() const override\n    {\n        return creationDate_;\n    }\n\n    void setStatusCode(HttpStatusCode code) override\n    {\n        statusCode_ = code;\n        setStatusMessage(statusCodeToString(code));\n    }\n\n    void setVersion(const Version v) override\n    {\n        version_ = v;\n        if (version_ == Version::kHttp10)\n        {\n            closeConnection_ = true;\n        }\n    }\n\n    Version version() const override\n    {\n        return version_;\n    }\n\n    const char *versionString() const override;\n\n    void setCloseConnection(bool on) override\n    {\n        closeConnection_ = on;\n    }\n\n    bool ifCloseConnection() const override\n    {\n        return closeConnection_;\n    }\n\n    void setContentTypeCode(ContentType type) override\n    {\n        contentType_ = type;\n        auto ct = contentTypeToMime(type);\n        contentTypeString_ = std::string(ct.data(), ct.size());\n        flagForParsingContentType_ = true;\n    }\n\n    //  void setContentTypeCodeAndCharacterSet(ContentType type, const\n    // std::string &charSet = \"utf-8\") override\n    // {\n    //     contentType_ = type;\n    //     setContentType(webContentTypeAndCharsetToString(type, charSet));\n    // }\n\n    ContentType contentType() const override\n    {\n        parseContentTypeAndString();\n        return contentType_;\n    }\n\n    const std::string &getHeader(std::string key) const override\n    {\n        transform(key.begin(), key.end(), key.begin(), [](unsigned char c) {\n            return tolower(c);\n        });\n        return getHeaderBy(key);\n    }\n\n    void removeHeader(std::string key) override\n    {\n        transform(key.begin(), key.end(), key.begin(), [](unsigned char c) {\n            return tolower(c);\n        });\n        removeHeaderBy(key);\n    }\n\n    const std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            &headers() const override\n    {\n        return headers_;\n    }\n\n    const std::string &getHeaderBy(const std::string &lowerKey) const\n    {\n        const static std::string defaultVal;\n        auto iter = headers_.find(lowerKey);\n        if (iter == headers_.end())\n        {\n            return defaultVal;\n        }\n        return iter->second;\n    }\n\n    void removeHeaderBy(const std::string &lowerKey)\n    {\n        fullHeaderString_.reset();\n        headers_.erase(lowerKey);\n    }\n\n    void addHeader(std::string field, const std::string &value) override\n    {\n        fullHeaderString_.reset();\n        transform(field.begin(),\n                  field.end(),\n                  field.begin(),\n                  [](unsigned char c) { return tolower(c); });\n        headers_[std::move(field)] = value;\n    }\n\n    void addHeader(std::string field, std::string &&value) override\n    {\n        fullHeaderString_.reset();\n        transform(field.begin(),\n                  field.end(),\n                  field.begin(),\n                  [](unsigned char c) { return tolower(c); });\n        headers_[std::move(field)] = std::move(value);\n    }\n\n    void addHeader(const char *start, const char *colon, const char *end);\n\n    void addCookie(const std::string &key, const std::string &value) override\n    {\n        cookies_[key] = Cookie(key, value);\n    }\n\n    void addCookie(const Cookie &cookie) override\n    {\n        cookies_[cookie.key()] = cookie;\n    }\n\n    void addCookie(Cookie &&cookie) override\n    {\n        cookies_[cookie.key()] = std::move(cookie);\n    }\n\n    const Cookie &getCookie(const std::string &key) const override\n    {\n        static const Cookie defaultCookie;\n        auto it = cookies_.find(key);\n        if (it != cookies_.end())\n        {\n            return it->second;\n        }\n        return defaultCookie;\n    }\n\n    const std::\n        unordered_map<std::string, Cookie, utils::internal::SafeStringHash>\n            &cookies() const override\n    {\n        return cookies_;\n    }\n\n    void removeCookie(const std::string &key) override\n    {\n        cookies_.erase(key);\n    }\n\n    void setBody(const std::string &body) override\n    {\n        bodyPtr_ = std::make_shared<HttpMessageStringBody>(body);\n        if (passThrough_)\n        {\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n    void setBody(std::string &&body) override\n    {\n        bodyPtr_ = std::make_shared<HttpMessageStringBody>(std::move(body));\n        if (passThrough_)\n        {\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n\n    void redirect(const std::string &url)\n    {\n        headers_[\"location\"] = url;\n    }\n    std::shared_ptr<trantor::MsgBuffer> renderToBuffer();\n    void renderToBuffer(trantor::MsgBuffer &buffer);\n    std::shared_ptr<trantor::MsgBuffer> renderHeaderForHeadMethod();\n    void clear() override;\n\n    void setExpiredTime(ssize_t expiredTime) override\n    {\n        expriedTime_ = expiredTime;\n        datePos_ = std::string::npos;\n        if (expriedTime_ < 0 && version_ == Version::kHttp10)\n        {\n            fullHeaderString_.reset();\n        }\n    }\n\n    ssize_t expiredTime() const override\n    {\n        return expriedTime_;\n    }\n\n    const char *getBodyData() const override\n    {\n        if (!flagForSerializingJson_ && jsonPtr_)\n        {\n            generateBodyFromJson();\n        }\n        else if (!bodyPtr_)\n        {\n            return nullptr;\n        }\n        return bodyPtr_->data();\n    }\n    size_t getBodyLength() const override\n    {\n        if (bodyPtr_)\n            return bodyPtr_->length();\n        return 0;\n    }\n\n    void swap(HttpResponseImpl &that) noexcept;\n    void parseJson() const;\n    const std::shared_ptr<Json::Value> &jsonObject() const override\n    {\n        // Not multi-thread safe but good, because we basically call this\n        // function in a single thread\n        if (!flagForParsingJson_)\n        {\n            flagForParsingJson_ = true;\n            parseJson();\n        }\n        return jsonPtr_;\n    }\n    const std::string &getJsonError() const override\n    {\n        const static std::string none;\n        if (jsonParsingErrorPtr_)\n            return *jsonParsingErrorPtr_;\n        return none;\n    }\n    void setJsonObject(const Json::Value &pJson)\n    {\n        flagForParsingJson_ = true;\n        flagForSerializingJson_ = false;\n        jsonPtr_ = std::make_shared<Json::Value>(pJson);\n    }\n    void setJsonObject(Json::Value &&pJson)\n    {\n        flagForParsingJson_ = true;\n        flagForSerializingJson_ = false;\n        jsonPtr_ = std::make_shared<Json::Value>(std::move(pJson));\n    }\n    bool shouldBeCompressed() const;\n    void generateBodyFromJson() const;\n    const std::string &sendfileName() const override\n    {\n        return sendfileName_;\n    }\n    const SendfileRange &sendfileRange() const override\n    {\n        return sendfileRange_;\n    }\n    void setSendfile(const std::string &filename)\n    {\n        sendfileName_ = filename;\n    }\n    void setSendfileRange(size_t offset, size_t len)\n    {\n        sendfileRange_.first = offset;\n        sendfileRange_.second = len;\n    }\n    const std::function<std::size_t(char *, std::size_t)> &streamCallback()\n        const override\n    {\n        return streamCallback_;\n    }\n    void setStreamCallback(\n        const std::function<std::size_t(char *, std::size_t)> &callback)\n    {\n        streamCallback_ = callback;\n    }\n    void makeHeaderString()\n    {\n        fullHeaderString_ = std::make_shared<trantor::MsgBuffer>(128);\n        makeHeaderString(*fullHeaderString_);\n    }\n\n    std::string contentTypeString() const override\n    {\n        parseContentTypeAndString();\n        return contentTypeString_;\n    }\n\n    void gunzip()\n    {\n        if (bodyPtr_)\n        {\n            auto gunzipBody =\n                utils::gzipDecompress(bodyPtr_->data(), bodyPtr_->length());\n            removeHeaderBy(\"content-encoding\");\n            bodyPtr_ =\n                std::make_shared<HttpMessageStringBody>(move(gunzipBody));\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n#ifdef USE_BROTLI\n    void brDecompress()\n    {\n        if (bodyPtr_)\n        {\n            auto gunzipBody =\n                utils::brotliDecompress(bodyPtr_->data(), bodyPtr_->length());\n            removeHeaderBy(\"content-encoding\");\n            bodyPtr_ =\n                std::make_shared<HttpMessageStringBody>(move(gunzipBody));\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n#endif\n    ~HttpResponseImpl() override = default;\n\n  protected:\n    void makeHeaderString(trantor::MsgBuffer &headerString);\n\n    void parseContentTypeAndString() const\n    {\n        if (!flagForParsingContentType_)\n        {\n            flagForParsingContentType_ = true;\n            auto &contentTypeString = getHeaderBy(\"content-type\");\n            if (contentTypeString == \"\")\n            {\n                contentType_ = CT_NONE;\n            }\n            else\n            {\n                auto pos = contentTypeString.find(';');\n                if (pos != std::string::npos)\n                {\n                    contentType_ = parseContentType(\n                        string_view(contentTypeString.data(), pos));\n                }\n                else\n                {\n                    contentType_ =\n                        parseContentType(string_view(contentTypeString));\n                }\n\n                if (contentType_ == CT_NONE)\n                    contentType_ = CT_CUSTOM;\n                contentTypeString_ = contentTypeString;\n            }\n        }\n    }\n\n  private:\n    void setBody(const char *body, size_t len) override\n    {\n        bodyPtr_ = std::make_shared<HttpMessageStringViewBody>(body, len);\n        if (passThrough_)\n        {\n            addHeader(\"content-length\", std::to_string(bodyPtr_->length()));\n        }\n    }\n    void setContentTypeCodeAndCustomString(ContentType type,\n                                           const char *typeString,\n                                           size_t typeStringLength) override\n    {\n        contentType_ = type;\n        flagForParsingContentType_ = true;\n\n        string_view sv(typeString, typeStringLength);\n        bool haveHeader = sv.find(\"content-type: \") == 0;\n        bool haveCRLF = sv.rfind(\"\\r\\n\") == sv.size() - 2;\n\n        size_t endOffset = 0;\n        if (haveHeader)\n            endOffset += 14;\n        if (haveCRLF)\n            endOffset += 2;\n        setContentType(string_view{typeString + (haveHeader ? 14 : 0),\n                                   typeStringLength - endOffset});\n    }\n\n    void setContentTypeString(const char *typeString,\n                              size_t typeStringLength) override;\n\n    void setCustomStatusCode(int code,\n                             const char *message,\n                             size_t messageLength) override\n    {\n        assert(code >= 0);\n        customStatusCode_ = code;\n        statusMessage_ = string_view{message, messageLength};\n    }\n\n    std::\n        unordered_map<std::string, std::string, utils::internal::SafeStringHash>\n            headers_;\n    std::unordered_map<std::string, Cookie, utils::internal::SafeStringHash>\n        cookies_;\n\n    int customStatusCode_{-1};\n    HttpStatusCode statusCode_{kUnknown};\n    string_view statusMessage_;\n\n    trantor::Date creationDate_;\n    Version version_{Version::kHttp11};\n    bool closeConnection_{false};\n    mutable std::shared_ptr<HttpMessageBody> bodyPtr_;\n    ssize_t expriedTime_{-1};\n    std::string sendfileName_;\n    SendfileRange sendfileRange_{0, 0};\n    std::function<std::size_t(char *, std::size_t)> streamCallback_;\n\n    mutable std::shared_ptr<Json::Value> jsonPtr_;\n\n    std::shared_ptr<trantor::MsgBuffer> fullHeaderString_;\n    mutable std::shared_ptr<trantor::MsgBuffer> httpString_;\n    mutable size_t datePos_{static_cast<size_t>(-1)};\n    mutable int64_t httpStringDate_{-1};\n    mutable bool flagForParsingJson_{false};\n    mutable bool flagForSerializingJson_{true};\n    mutable ContentType contentType_{CT_TEXT_PLAIN};\n    mutable bool flagForParsingContentType_{false};\n    mutable std::shared_ptr<std::string> jsonParsingErrorPtr_;\n    mutable std::string contentTypeString_{\"text/html; charset=utf-8\"};\n    bool passThrough_{false};\n    void setContentType(const string_view &contentType)\n    {\n        contentTypeString_ =\n            std::string(contentType.data(), contentType.size());\n    }\n    void setStatusMessage(const string_view &message)\n    {\n        statusMessage_ = message;\n    }\n};\nusing HttpResponseImplPtr = std::shared_ptr<HttpResponseImpl>;\n\ninline void swap(HttpResponseImpl &one, HttpResponseImpl &two) noexcept\n{\n    one.swap(two);\n}\n\n}  // namespace drogon\n", "/**\n *\n *  @file Utilities.cc\n *  @author An Tao\n *\n *  Copyright 2018, An Tao.  All rights reserved.\n *  https://github.com/an-tao/drogon\n *  Use of this source code is governed by a MIT license\n *  that can be found in the License file.\n *\n *  Drogon\n *\n */\n\n#include <drogon/utils/Utilities.h>\n#include \"filesystem.h\"\n#include <trantor/utils/Logger.h>\n#include <drogon/config.h>\n#ifdef OpenSSL_FOUND\n#include <openssl/md5.h>\n#include <openssl/rand.h>\n#else\n#include \"ssl_funcs/Md5.h\"\n#endif\n#ifdef USE_BROTLI\n#include <brotli/decode.h>\n#include <brotli/encode.h>\n#endif\n#ifdef _WIN32\n#include <Rpc.h>\n#include <direct.h>\n#include <io.h>\n#include <ntsecapi.h>\n#else\n#include <uuid.h>\n#include <unistd.h>\n#endif\n#include <zlib.h>\n#include <iomanip>\n#include <mutex>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <thread>\n#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdarg.h>\n\n#ifdef _WIN32\n\nchar *strptime(const char *s, const char *f, struct tm *tm)\n{\n    // std::get_time is defined such that its\n    // format parameters are the exact same as strptime.\n    std::istringstream input(s);\n    input.imbue(std::locale(setlocale(LC_ALL, nullptr)));\n    input >> std::get_time(tm, f);\n    if (input.fail())\n    {\n        return nullptr;\n    }\n    return (char *)(s + input.tellg());\n}\ntime_t timegm(struct tm *tm)\n{\n    struct tm my_tm;\n\n    memcpy(&my_tm, tm, sizeof(struct tm));\n\n    /* _mkgmtime() changes the value of the struct tm* you pass in, so\n     * use a copy\n     */\n    return _mkgmtime(&my_tm);\n}\n#endif\n\n#ifdef __HAIKU__\n// HACK: Haiku has a timegm implementation. But it is not exposed\nextern \"C\" time_t timegm(struct tm *tm);\n#endif\n\nnamespace drogon\n{\nnamespace utils\n{\nstatic const std::string base64Chars =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789+/\";\n\nstatic const std::string urlBase64Chars =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789-_\";\nclass Base64CharMap\n{\n  public:\n    Base64CharMap()\n    {\n        char index = 0;\n        for (int c = 'A'; c <= 'Z'; ++c)\n        {\n            charMap_[c] = index++;\n        }\n        for (int c = 'a'; c <= 'z'; ++c)\n        {\n            charMap_[c] = index++;\n        }\n        for (int c = '0'; c <= '9'; ++c)\n        {\n            charMap_[c] = index++;\n        }\n        charMap_[static_cast<int>('+')] = charMap_[static_cast<int>('-')] =\n            index++;\n        charMap_[static_cast<int>('/')] = charMap_[static_cast<int>('_')] =\n            index;\n        charMap_[0] = 0xff;\n    }\n    char getIndex(const char c) const noexcept\n    {\n        return charMap_[static_cast<int>(c)];\n    }\n\n  private:\n    char charMap_[256]{0};\n};\nconst static Base64CharMap base64CharMap;\n\nstatic inline bool isBase64(unsigned char c)\n{\n    if (isalnum(c))\n        return true;\n    switch (c)\n    {\n        case '+':\n        case '/':\n        case '-':\n        case '_':\n            return true;\n    }\n    return false;\n}\n\nbool isInteger(const std::string &str)\n{\n    for (auto const &c : str)\n    {\n        if (c > '9' || c < '0')\n            return false;\n    }\n    return true;\n}\n\nstd::string genRandomString(int length)\n{\n    static const char char_space[] =\n        \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    static std::once_flag once;\n    static const size_t len = strlen(char_space);\n    static const int randMax = RAND_MAX - (RAND_MAX % len);\n    std::call_once(once, []() {\n        std::srand(static_cast<unsigned int>(time(nullptr)));\n    });\n\n    int i;\n    std::string str;\n    str.resize(length);\n\n    for (i = 0; i < length; ++i)\n    {\n        int x = std::rand();\n        while (x >= randMax)\n        {\n            x = std::rand();\n        }\n        x = (x % len);\n        str[i] = char_space[x];\n    }\n\n    return str;\n}\n\nstd::vector<char> hexToBinaryVector(const char *ptr, size_t length)\n{\n    assert(length % 2 == 0);\n    std::vector<char> ret(length / 2, '\\0');\n    for (size_t i = 0; i < ret.size(); ++i)\n    {\n        auto p = i * 2;\n        char c1 = ptr[p];\n        if (c1 >= '0' && c1 <= '9')\n        {\n            c1 -= '0';\n        }\n        else if (c1 >= 'a' && c1 <= 'f')\n        {\n            c1 -= 'a';\n            c1 += 10;\n        }\n        else if (c1 >= 'A' && c1 <= 'F')\n        {\n            c1 -= 'A';\n            c1 += 10;\n        }\n        else\n        {\n            return std::vector<char>();\n        }\n        char c2 = ptr[p + 1];\n        if (c2 >= '0' && c2 <= '9')\n        {\n            c2 -= '0';\n        }\n        else if (c2 >= 'a' && c2 <= 'f')\n        {\n            c2 -= 'a';\n            c2 += 10;\n        }\n        else if (c2 >= 'A' && c2 <= 'F')\n        {\n            c2 -= 'A';\n            c2 += 10;\n        }\n        else\n        {\n            return std::vector<char>();\n        }\n        ret[i] = c1 * 16 + c2;\n    }\n    return ret;\n}\nstd::string hexToBinaryString(const char *ptr, size_t length)\n{\n    assert(length % 2 == 0);\n    std::string ret(length / 2, '\\0');\n    for (size_t i = 0; i < ret.length(); ++i)\n    {\n        auto p = i * 2;\n        char c1 = ptr[p];\n        if (c1 >= '0' && c1 <= '9')\n        {\n            c1 -= '0';\n        }\n        else if (c1 >= 'a' && c1 <= 'f')\n        {\n            c1 -= 'a';\n            c1 += 10;\n        }\n        else if (c1 >= 'A' && c1 <= 'F')\n        {\n            c1 -= 'A';\n            c1 += 10;\n        }\n        else\n        {\n            return \"\";\n        }\n        char c2 = ptr[p + 1];\n        if (c2 >= '0' && c2 <= '9')\n        {\n            c2 -= '0';\n        }\n        else if (c2 >= 'a' && c2 <= 'f')\n        {\n            c2 -= 'a';\n            c2 += 10;\n        }\n        else if (c2 >= 'A' && c2 <= 'F')\n        {\n            c2 -= 'A';\n            c2 += 10;\n        }\n        else\n        {\n            return \"\";\n        }\n        ret[i] = c1 * 16 + c2;\n    }\n    return ret;\n}\n\nstd::string binaryStringToHex(const unsigned char *ptr, size_t length)\n{\n    std::string idString;\n    for (size_t i = 0; i < length; ++i)\n    {\n        int value = (ptr[i] & 0xf0) >> 4;\n        if (value < 10)\n        {\n            idString.append(1, char(value + 48));\n        }\n        else\n        {\n            idString.append(1, char(value + 55));\n        }\n\n        value = (ptr[i] & 0x0f);\n        if (value < 10)\n        {\n            idString.append(1, char(value + 48));\n        }\n        else\n        {\n            idString.append(1, char(value + 55));\n        }\n    }\n    return idString;\n}\n\nstd::set<std::string> splitStringToSet(const std::string &str,\n                                       const std::string &separator)\n{\n    std::set<std::string> ret;\n    std::string::size_type pos1, pos2;\n    pos2 = 0;\n    pos1 = str.find(separator);\n    while (pos1 != std::string::npos)\n    {\n        if (pos1 != 0)\n        {\n            std::string item = str.substr(pos2, pos1 - pos2);\n            ret.insert(item);\n        }\n        pos2 = pos1 + separator.length();\n        while (pos2 < str.length() &&\n               str.substr(pos2, separator.length()) == separator)\n            pos2 += separator.length();\n        pos1 = str.find(separator, pos2);\n    }\n    if (pos2 < str.length())\n        ret.insert(str.substr(pos2));\n    return ret;\n}\n\nstd::string getUuid()\n{\n#if USE_OSSP_UUID\n    uuid_t *uuid;\n    uuid_create(&uuid);\n    uuid_make(uuid, UUID_MAKE_V4);\n    char *str{nullptr};\n    size_t len{0};\n    uuid_export(uuid, UUID_FMT_BIN, &str, &len);\n    uuid_destroy(uuid);\n    std::string ret{binaryStringToHex((const unsigned char *)str, len)};\n    free(str);\n    return ret;\n#elif defined __FreeBSD__ || defined __OpenBSD__\n    uuid_t *uuid = new uuid_t;\n    char *binstr = (char *)malloc(16);\n#if defined __FreeBSD__\n    uuidgen(uuid, 1);\n#else\n    uint32_t status;\n    uuid_create(uuid, &status);\n#endif\n#if _BYTE_ORDER == _LITTLE_ENDIAN\n    uuid_enc_le(binstr, uuid);\n#else  /* _BYTE_ORDER != _LITTLE_ENDIAN */\n    uuid_enc_be(binstr, uuid);\n#endif /* _BYTE_ORDER == _LITTLE_ENDIAN */\n    delete uuid;\n    std::string ret{binaryStringToHex((const unsigned char *)binstr, 16)};\n    free(binstr);\n    return ret;\n#elif defined _WIN32\n    uuid_t uu;\n    UuidCreate(&uu);\n    char tempStr[100];\n    auto len = snprintf(tempStr,\n                        sizeof(tempStr),\n                        \"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n                        uu.Data1,\n                        uu.Data2,\n                        uu.Data3,\n                        uu.Data4[0],\n                        uu.Data4[1],\n                        uu.Data4[2],\n                        uu.Data4[3],\n                        uu.Data4[4],\n                        uu.Data4[5],\n                        uu.Data4[6],\n                        uu.Data4[7]);\n    return std::string{tempStr, static_cast<size_t>(len)};\n#else\n    uuid_t uu;\n    uuid_generate(uu);\n    return binaryStringToHex(uu, 16);\n#endif\n}\n\nstd::string base64Encode(const unsigned char *bytes_to_encode,\n                         unsigned int in_len,\n                         bool url_safe)\n{\n    std::string ret;\n    int i = 0;\n    unsigned char char_array_3[3];\n    unsigned char char_array_4[4];\n\n    const std::string &charSet = url_safe ? urlBase64Chars : base64Chars;\n\n    while (in_len--)\n    {\n        char_array_3[i++] = *(bytes_to_encode++);\n        if (i == 3)\n        {\n            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;\n            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) +\n                              ((char_array_3[1] & 0xf0) >> 4);\n            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) +\n                              ((char_array_3[2] & 0xc0) >> 6);\n            char_array_4[3] = char_array_3[2] & 0x3f;\n\n            for (i = 0; (i < 4); ++i)\n                ret += charSet[char_array_4[i]];\n            i = 0;\n        }\n    }\n\n    if (i)\n    {\n        for (int j = i; j < 3; ++j)\n            char_array_3[j] = '\\0';\n\n        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;\n        char_array_4[1] =\n            ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);\n        char_array_4[2] =\n            ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);\n        char_array_4[3] = char_array_3[2] & 0x3f;\n\n        for (int j = 0; (j < i + 1); ++j)\n            ret += charSet[char_array_4[j]];\n\n        while ((i++ < 3))\n            ret += '=';\n    }\n    return ret;\n}\n\nstd::vector<char> base64DecodeToVector(const std::string &encoded_string)\n{\n    auto in_len = encoded_string.size();\n    int i = 0;\n    int in_{0};\n    char char_array_4[4], char_array_3[3];\n    std::vector<char> ret;\n    ret.reserve(in_len);\n\n    while (in_len-- && (encoded_string[in_] != '=') &&\n           isBase64(encoded_string[in_]))\n    {\n        char_array_4[i++] = encoded_string[in_];\n        ++in_;\n        if (i == 4)\n        {\n            for (i = 0; i < 4; ++i)\n            {\n                char_array_4[i] = base64CharMap.getIndex(char_array_4[i]);\n            }\n\n            char_array_3[0] =\n                (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) +\n                              ((char_array_4[2] & 0x3c) >> 2);\n            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n            for (i = 0; (i < 3); ++i)\n                ret.push_back(char_array_3[i]);\n            i = 0;\n        }\n    }\n\n    if (i)\n    {\n        for (int j = i; j < 4; ++j)\n            char_array_4[j] = 0;\n\n        for (int j = 0; j < 4; ++j)\n        {\n            char_array_4[j] = base64CharMap.getIndex(char_array_4[j]);\n        }\n\n        char_array_3[0] =\n            (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n        char_array_3[1] =\n            ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);\n        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n        for (int j = 0; (j < i - 1); ++j)\n            ret.push_back(char_array_3[j]);\n    }\n\n    return ret;\n}\n\nstd::string base64Decode(const std::string &encoded_string)\n{\n    auto in_len = encoded_string.size();\n    int i = 0;\n    int in_{0};\n    unsigned char char_array_4[4], char_array_3[3];\n    std::string ret;\n\n    while (in_len-- && (encoded_string[in_] != '=') &&\n           isBase64(encoded_string[in_]))\n    {\n        char_array_4[i++] = encoded_string[in_];\n        ++in_;\n        if (i == 4)\n        {\n            for (i = 0; i < 4; ++i)\n            {\n                char_array_4[i] = base64CharMap.getIndex(char_array_4[i]);\n            }\n            char_array_3[0] =\n                (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) +\n                              ((char_array_4[2] & 0x3c) >> 2);\n            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n            for (i = 0; (i < 3); ++i)\n                ret += char_array_3[i];\n            i = 0;\n        }\n    }\n\n    if (i)\n    {\n        for (int j = i; j < 4; ++j)\n            char_array_4[j] = 0;\n\n        for (int j = 0; j < 4; ++j)\n        {\n            char_array_4[j] = base64CharMap.getIndex(char_array_4[j]);\n        }\n\n        char_array_3[0] =\n            (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n        char_array_3[1] =\n            ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);\n        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n        for (int j = 0; (j < i - 1); ++j)\n            ret += char_array_3[j];\n    }\n\n    return ret;\n}\nstatic std::string charToHex(char c)\n{\n    std::string result;\n    char first, second;\n\n    first = (c & 0xF0) / 16;\n    first += first > 9 ? 'A' - 10 : '0';\n    second = c & 0x0F;\n    second += second > 9 ? 'A' - 10 : '0';\n\n    result.append(1, first);\n    result.append(1, second);\n\n    return result;\n}\nstd::string urlEncodeComponent(const std::string &src)\n{\n    std::string result;\n    std::string::const_iterator iter;\n\n    for (iter = src.begin(); iter != src.end(); ++iter)\n    {\n        switch (*iter)\n        {\n            case ' ':\n                result.append(1, '+');\n                break;\n            // alnum\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case 'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case 's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            // mark\n            case '-':\n            case '_':\n            case '.':\n            case '!':\n            case '~':\n            case '*':\n            case '(':\n            case ')':\n                result.append(1, *iter);\n                break;\n            // escape\n            default:\n                result.append(1, '%');\n                result.append(charToHex(*iter));\n                break;\n        }\n    }\n\n    return result;\n}\nstd::string urlEncode(const std::string &src)\n{\n    std::string result;\n    std::string::const_iterator iter;\n\n    for (iter = src.begin(); iter != src.end(); ++iter)\n    {\n        switch (*iter)\n        {\n            case ' ':\n                result.append(1, '+');\n                break;\n            // alnum\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case 'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case 's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            // mark\n            case '-':\n            case '_':\n            case '.':\n            case '!':\n            case '~':\n            case '*':\n            case '\\'':\n            case '(':\n            case ')':\n            case '&':\n            case '=':\n            case '/':\n            case '\\\\':\n            case '?':\n                result.append(1, *iter);\n                break;\n            // escape\n            default:\n                result.append(1, '%');\n                result.append(charToHex(*iter));\n                break;\n        }\n    }\n\n    return result;\n}\nbool needUrlDecoding(const char *begin, const char *end)\n{\n    return std::find_if(begin, end, [](const char c) {\n               return c == '+' || c == '%';\n           }) != end;\n}\nstd::string urlDecode(const char *begin, const char *end)\n{\n    std::string result;\n    size_t len = end - begin;\n    result.reserve(len * 2);\n    int hex = 0;\n    for (size_t i = 0; i < len; ++i)\n    {\n        switch (begin[i])\n        {\n            case '+':\n                result += ' ';\n                break;\n            case '%':\n                if ((i + 2) < len && isxdigit(begin[i + 1]) &&\n                    isxdigit(begin[i + 2]))\n                {\n                    unsigned int x1 = begin[i + 1];\n                    if (x1 >= '0' && x1 <= '9')\n                    {\n                        x1 -= '0';\n                    }\n                    else if (x1 >= 'a' && x1 <= 'f')\n                    {\n                        x1 = x1 - 'a' + 10;\n                    }\n                    else if (x1 >= 'A' && x1 <= 'F')\n                    {\n                        x1 = x1 - 'A' + 10;\n                    }\n                    unsigned int x2 = begin[i + 2];\n                    if (x2 >= '0' && x2 <= '9')\n                    {\n                        x2 -= '0';\n                    }\n                    else if (x2 >= 'a' && x2 <= 'f')\n                    {\n                        x2 = x2 - 'a' + 10;\n                    }\n                    else if (x2 >= 'A' && x2 <= 'F')\n                    {\n                        x2 = x2 - 'A' + 10;\n                    }\n                    hex = x1 * 16 + x2;\n\n                    result += char(hex);\n                    i += 2;\n                }\n                else\n                {\n                    result += '%';\n                }\n                break;\n            default:\n                result += begin[i];\n                break;\n        }\n    }\n    return result;\n}\n\n/* Compress gzip data */\nstd::string gzipCompress(const char *data, const size_t ndata)\n{\n    z_stream strm = {nullptr,\n                     0,\n                     0,\n                     nullptr,\n                     0,\n                     0,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     0,\n                     0,\n                     0};\n    if (data && ndata > 0)\n    {\n        if (deflateInit2(&strm,\n                         Z_DEFAULT_COMPRESSION,\n                         Z_DEFLATED,\n                         MAX_WBITS + 16,\n                         8,\n                         Z_DEFAULT_STRATEGY) != Z_OK)\n        {\n            LOG_ERROR << \"deflateInit2 error!\";\n            return std::string{};\n        }\n        std::string outstr;\n        outstr.resize(compressBound(static_cast<uLong>(ndata)));\n        strm.next_in = (Bytef *)data;\n        strm.avail_in = static_cast<uInt>(ndata);\n        int ret;\n        do\n        {\n            if (strm.total_out >= outstr.size())\n            {\n                outstr.resize(strm.total_out * 2);\n            }\n            assert(outstr.size() >= strm.total_out);\n            strm.avail_out = static_cast<uInt>(outstr.size() - strm.total_out);\n            strm.next_out = (Bytef *)outstr.data() + strm.total_out;\n            ret = deflate(&strm, Z_FINISH); /* no bad return value */\n            if (ret == Z_STREAM_ERROR)\n            {\n                (void)deflateEnd(&strm);\n                return std::string{};\n            }\n        } while (strm.avail_out == 0);\n        assert(strm.avail_in == 0);\n        assert(ret == Z_STREAM_END); /* stream will be complete */\n        outstr.resize(strm.total_out);\n        /* clean up and return */\n        (void)deflateEnd(&strm);\n        return outstr;\n    }\n    return std::string{};\n}\n\nstd::string gzipDecompress(const char *data, const size_t ndata)\n{\n    if (ndata == 0)\n        return std::string(data, ndata);\n\n    auto full_length = ndata;\n\n    auto decompressed = std::string(full_length * 2, 0);\n    bool done = false;\n\n    z_stream strm = {nullptr,\n                     0,\n                     0,\n                     nullptr,\n                     0,\n                     0,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     nullptr,\n                     0,\n                     0,\n                     0};\n    strm.next_in = (Bytef *)data;\n    strm.avail_in = static_cast<uInt>(ndata);\n    strm.total_out = 0;\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    if (inflateInit2(&strm, (15 + 32)) != Z_OK)\n    {\n        LOG_ERROR << \"inflateInit2 error!\";\n        return std::string{};\n    }\n    while (!done)\n    {\n        // Make sure we have enough room and reset the lengths.\n        if (strm.total_out >= decompressed.length())\n        {\n            decompressed.resize(decompressed.length() * 2);\n        }\n        strm.next_out = (Bytef *)decompressed.data() + strm.total_out;\n        strm.avail_out =\n            static_cast<uInt>(decompressed.length() - strm.total_out);\n        // Inflate another chunk.\n        int status = inflate(&strm, Z_SYNC_FLUSH);\n        if (status == Z_STREAM_END)\n        {\n            done = true;\n        }\n        else if (status != Z_OK)\n        {\n            break;\n        }\n    }\n    if (inflateEnd(&strm) != Z_OK)\n        return std::string{};\n    // Set real length.\n    if (done)\n    {\n        decompressed.resize(strm.total_out);\n        return decompressed;\n    }\n    else\n    {\n        return std::string{};\n    }\n}\n\nchar *getHttpFullDate(const trantor::Date &date)\n{\n    static thread_local int64_t lastSecond = 0;\n    static thread_local char lastTimeString[128] = {0};\n    auto nowSecond = date.microSecondsSinceEpoch() / MICRO_SECONDS_PRE_SEC;\n    if (nowSecond == lastSecond)\n    {\n        return lastTimeString;\n    }\n    lastSecond = nowSecond;\n    date.toCustomedFormattedString(\"%a, %d %b %Y %H:%M:%S GMT\",\n                                   lastTimeString,\n                                   sizeof(lastTimeString));\n    return lastTimeString;\n}\ntrantor::Date getHttpDate(const std::string &httpFullDateString)\n{\n    static const std::array<const char *, 4> formats = {\n        // RFC822 (default)\n        \"%a, %d %b %Y %H:%M:%S\",\n        // RFC 850 (deprecated)\n        \"%a, %d-%b-%y %H:%M:%S\",\n        // ansi asctime format\n        \"%a %b %d %H:%M:%S %Y\",\n        // weird RFC 850-hybrid thing that reddit uses\n        \"%a, %d-%b-%Y %H:%M:%S\",\n    };\n    struct tm tmptm;\n    for (const char *format : formats)\n    {\n        if (strptime(httpFullDateString.c_str(), format, &tmptm) != NULL)\n        {\n            auto epoch = timegm(&tmptm);\n            return trantor::Date(epoch * MICRO_SECONDS_PRE_SEC);\n        }\n    }\n    LOG_WARN << \"invalid datetime format: '\" << httpFullDateString << \"'\";\n    return trantor::Date((std::numeric_limits<int64_t>::max)());\n}\nstd::string formattedString(const char *format, ...)\n{\n    std::string strBuffer(128, 0);\n    va_list ap, backup_ap;\n    va_start(ap, format);\n    va_copy(backup_ap, ap);\n    auto result = vsnprintf((char *)strBuffer.data(),\n                            strBuffer.size(),\n                            format,\n                            backup_ap);\n    va_end(backup_ap);\n    if ((result >= 0) && ((std::string::size_type)result < strBuffer.size()))\n    {\n        strBuffer.resize(result);\n    }\n    else\n    {\n        while (true)\n        {\n            if (result < 0)\n            {\n                // Older snprintf() behavior. Just try doubling the buffer size\n                strBuffer.resize(strBuffer.size() * 2);\n            }\n            else\n            {\n                strBuffer.resize(result + 1);\n            }\n\n            va_copy(backup_ap, ap);\n            auto result = vsnprintf((char *)strBuffer.data(),\n                                    strBuffer.size(),\n                                    format,\n                                    backup_ap);\n            va_end(backup_ap);\n\n            if ((result >= 0) &&\n                ((std::string::size_type)result < strBuffer.size()))\n            {\n                strBuffer.resize(result);\n                break;\n            }\n        }\n    }\n    va_end(ap);\n    return strBuffer;\n}\n\nint createPath(const std::string &path)\n{\n    if (path.empty())\n        return 0;\n    auto osPath{toNativePath(path)};\n    if (osPath.back() != filesystem::path::preferred_separator)\n        osPath.push_back(filesystem::path::preferred_separator);\n    filesystem::path fsPath(osPath);\n    drogon::error_code err;\n    filesystem::create_directories(fsPath, err);\n    if (err)\n    {\n        LOG_ERROR << \"Error \" << err.value() << \" creating path \" << osPath\n                  << \": \" << err.message();\n        return -1;\n    }\n    return 0;\n}\n#ifdef USE_BROTLI\nstd::string brotliCompress(const char *data, const size_t ndata)\n{\n    std::string ret;\n    if (ndata == 0)\n        return ret;\n    ret.resize(BrotliEncoderMaxCompressedSize(ndata));\n    size_t encodedSize{ret.size()};\n    auto r = BrotliEncoderCompress(5,\n                                   BROTLI_DEFAULT_WINDOW,\n                                   BROTLI_DEFAULT_MODE,\n                                   ndata,\n                                   (const uint8_t *)(data),\n                                   &encodedSize,\n                                   (uint8_t *)(ret.data()));\n    if (r == BROTLI_FALSE)\n        ret.resize(0);\n    else\n        ret.resize(encodedSize);\n    return ret;\n}\nstd::string brotliDecompress(const char *data, const size_t ndata)\n{\n    if (ndata == 0)\n        return std::string(data, ndata);\n\n    size_t availableIn = ndata;\n    auto nextIn = (const uint8_t *)(data);\n    auto decompressed = std::string(availableIn * 3, 0);\n    size_t availableOut = decompressed.size();\n    auto nextOut = (uint8_t *)(decompressed.data());\n    size_t totalOut{0};\n    bool done = false;\n    auto s = BrotliDecoderCreateInstance(nullptr, nullptr, nullptr);\n    while (!done)\n    {\n        auto result = BrotliDecoderDecompressStream(\n            s, &availableIn, &nextIn, &availableOut, &nextOut, &totalOut);\n        if (result == BROTLI_DECODER_RESULT_SUCCESS)\n        {\n            decompressed.resize(totalOut);\n            done = true;\n        }\n        else if (result == BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT)\n        {\n            assert(totalOut == decompressed.size());\n            decompressed.resize(totalOut * 2);\n            nextOut = (uint8_t *)(decompressed.data() + totalOut);\n            availableOut = totalOut;\n        }\n        else\n        {\n            decompressed.resize(0);\n            done = true;\n        }\n    }\n    BrotliDecoderDestroyInstance(s);\n    return decompressed;\n}\n#else\nstd::string brotliCompress(const char * /*data*/, const size_t /*ndata*/)\n{\n    LOG_ERROR << \"If you do not have the brotli package installed, you cannot \"\n                 \"use brotliCompress()\";\n    abort();\n}\nstd::string brotliDecompress(const char * /*data*/, const size_t /*ndata*/)\n{\n    LOG_ERROR << \"If you do not have the brotli package installed, you cannot \"\n                 \"use brotliDecompress()\";\n    abort();\n}\n#endif\n\nstd::string getMd5(const char *data, const size_t dataLen)\n{\n#if defined(OpenSSL_FOUND) && OPENSSL_VERSION_MAJOR < 3\n    MD5_CTX c;\n    unsigned char md5[16] = {0};\n    MD5_Init(&c);\n    MD5_Update(&c, data, dataLen);\n    MD5_Final(md5, &c);\n    return utils::binaryStringToHex(md5, 16);\n#elif defined(OpenSSL_FOUND)\n    unsigned char md5[16] = {0};\n    const EVP_MD *md = EVP_get_digestbyname(\"md5\");\n    assert(md != nullptr);\n\n    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();\n    EVP_DigestInit_ex2(mdctx, md, NULL);\n    EVP_DigestUpdate(mdctx, data, dataLen);\n    EVP_DigestFinal_ex(mdctx, md5, NULL);\n    EVP_MD_CTX_free(mdctx);\n    return utils::binaryStringToHex(md5, 16);\n#else\n    return Md5Encode::encode(data, dataLen);\n#endif\n}\n\nvoid replaceAll(std::string &s, const std::string &from, const std::string &to)\n{\n    size_t pos = 0;\n    while ((pos = s.find(from, pos)) != std::string::npos)\n    {\n        s.replace(pos, from.size(), to);\n        pos += to.size();\n    }\n}\n\n/**\n * @brief Generates `size` random bytes from the systems random source and\n * stores them into `ptr`.\n */\nstatic bool systemRandomBytes(void *ptr, size_t size)\n{\n#if defined(__BSD__) || defined(__APPLE__)\n    arc4random_buf(ptr, size);\n    return true;\n#elif defined(__linux__) && \\\n    ((defined(__GLIBC__) && \\\n      (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25))))\n    return getentropy(ptr, size) != -1;\n#elif defined(_WIN32)  // Windows\n    return RtlGenRandom(ptr, size);\n#elif defined(__unix__) || defined(__HAIKU__)\n    // fallback to /dev/urandom for other/old UNIX\n    thread_local std::unique_ptr<FILE, std::function<void(FILE *)> > fptr(\n        fopen(\"/dev/urandom\", \"rb\"), [](FILE *ptr) {\n            if (ptr != nullptr)\n                fclose(ptr);\n        });\n    if (fptr == nullptr)\n    {\n        LOG_FATAL << \"Failed to open /dev/urandom for randomness\";\n        abort();\n    }\n    if (fread(ptr, 1, size, fptr.get()) != 0)\n        return true;\n#endif\n    return false;\n}\n\nbool secureRandomBytes(void *ptr, size_t size)\n{\n#ifdef OpenSSL_FOUND\n    if (RAND_bytes((unsigned char *)ptr, size) == 0)\n        return true;\n#endif\n    if (systemRandomBytes(ptr, size))\n        return true;\n    return false;\n}\n\nnamespace internal\n{\nDROGON_EXPORT const size_t fixedRandomNumber = []() {\n    size_t res;\n    utils::secureRandomBytes(&res, sizeof(res));\n    return res;\n}();\n}\n\n}  // namespace utils\n}  // namespace drogon\n"], "filenames": ["lib/inc/drogon/HttpRequest.h", "lib/inc/drogon/HttpResponse.h", "lib/inc/drogon/utils/Utilities.h", "lib/src/HttpRequestImpl.h", "lib/src/HttpResponseImpl.h", "lib/src/Utilities.cc"], "buggy_code_start_loc": [151, 21, 410, 140, 133, 1223], "buggy_code_end_loc": [275, 229, 410, 547, 451, 1223], "fixing_code_start_loc": [151, 22, 411, 140, 133, 1224], "fixing_code_end_loc": [284, 237, 428, 558, 458, 1233], "type": "CWE-330", "message": "A vulnerability, which was classified as problematic, has been found in drogon up to 1.8.1. Affected by this issue is some unknown functionality of the component Session Hash Handler. The manipulation leads to small space of random values. The attack may be launched remotely. Upgrading to version 1.8.2 is able to address this issue. The name of the patch is c0d48da99f66aaada17bcd28b07741cac8697647. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213464.", "other": {"cve": {"id": "CVE-2022-3959", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-11T16:15:16.843", "lastModified": "2022-11-16T16:06:59.987", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, has been found in drogon up to 1.8.1. Affected by this issue is some unknown functionality of the component Session Hash Handler. The manipulation leads to small space of random values. The attack may be launched remotely. Upgrading to version 1.8.2 is able to address this issue. The name of the patch is c0d48da99f66aaada17bcd28b07741cac8697647. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213464."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-330"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-330"}, {"lang": "en", "value": "CWE-331"}, {"lang": "en", "value": "CWE-334"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drogon:drogon:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.2", "matchCriteriaId": "093C783E-0219-4192-9F9B-71B1F9FF5E11"}]}]}], "references": [{"url": "https://github.com/drogonframework/drogon/commit/c0d48da99f66aaada17bcd28b07741cac8697647", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/drogonframework/drogon/pull/1433", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/drogonframework/drogon/releases/tag/v1.8.2", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.213464", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/drogonframework/drogon/commit/c0d48da99f66aaada17bcd28b07741cac8697647"}}