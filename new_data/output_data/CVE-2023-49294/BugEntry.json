{"buggy_code": ["/*\n * Asterisk -- An open source telephony toolkit.\n *\n * Copyright (C) 1999 - 2006, Digium, Inc.\n *\n * Mark Spencer <markster@digium.com>\n *\n * See http://www.asterisk.org for more information about\n * the Asterisk project. Please do not directly contact\n * any of the maintainers of this project for assistance;\n * the project provides a web site, mailing lists and IRC\n * channels for your use.\n *\n * This program is free software, distributed under the terms of\n * the GNU General Public License Version 2. See the LICENSE file\n * at the top of the source tree.\n */\n\n/*! \\file\n *\n * \\brief The Asterisk Management Interface - AMI\n *\n * \\author Mark Spencer <markster@digium.com>\n *\n * OpenSSL http://www.openssl.org - for AMI/SSL\n *\n * At the moment this file contains a number of functions, namely:\n *\n * - data structures storing AMI state\n * - AMI-related API functions, used by internal asterisk components\n * - handlers for AMI-related CLI functions\n * - handlers for AMI functions (available through the AMI socket)\n * - the code for the main AMI listener thread and individual session threads\n * - the http handlers invoked for AMI-over-HTTP by the threads in main/http.c\n *\n * \\ref amiconf\n */\n\n/*! \\li \\ref manager.c uses the configuration file \\ref manager.conf and \\ref users.conf\n * \\addtogroup configuration_file\n */\n\n/*! \\page manager.conf manager.conf\n * \\verbinclude manager.conf.sample\n */\n\n/*! \\page users.conf users.conf\n * \\verbinclude users.conf.sample\n */\n\n/*** MODULEINFO\n\t<support_level>core</support_level>\n ***/\n\n#include \"asterisk.h\"\n\n#include \"asterisk/paths.h\"\t/* use various ast_config_AST_* */\n#include <ctype.h>\n#include <sys/time.h>\n#include <signal.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <regex.h>\n\n#include \"asterisk/channel.h\"\n#include \"asterisk/file.h\"\n#include \"asterisk/manager.h\"\n#include \"asterisk/module.h\"\n#include \"asterisk/config.h\"\n#include \"asterisk/callerid.h\"\n#include \"asterisk/core_local.h\"\n#include \"asterisk/lock.h\"\n#include \"asterisk/cli.h\"\n#include \"asterisk/app.h\"\n#include \"asterisk/mwi.h\"\n#include \"asterisk/pbx.h\"\n#include \"asterisk/md5.h\"\n#include \"asterisk/acl.h\"\n#include \"asterisk/utils.h\"\n#include \"asterisk/tcptls.h\"\n#include \"asterisk/http.h\"\n#include \"asterisk/ast_version.h\"\n#include \"asterisk/threadstorage.h\"\n#include \"asterisk/linkedlists.h\"\n#include \"asterisk/term.h\"\n#include \"asterisk/astobj2.h\"\n#include \"asterisk/features.h\"\n#include \"asterisk/security_events.h\"\n#include \"asterisk/aoc.h\"\n#include \"asterisk/strings.h\"\n#include \"asterisk/stringfields.h\"\n#include \"asterisk/presencestate.h\"\n#include \"asterisk/stasis_message_router.h\"\n#include \"asterisk/stasis_channels.h\"\n#include \"asterisk/stasis_bridges.h\"\n#include \"asterisk/test.h\"\n#include \"asterisk/json.h\"\n#include \"asterisk/bridge.h\"\n#include \"asterisk/features_config.h\"\n#include \"asterisk/rtp_engine.h\"\n#include \"asterisk/format_cache.h\"\n#include \"asterisk/translate.h\"\n#include \"asterisk/taskprocessor.h\"\n#include \"asterisk/message.h\"\n\n/*** DOCUMENTATION\n\t<manager name=\"Ping\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tKeepalive command.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>A 'Ping' action will elicit a 'Pong' response. Used to keep the\n\t\t\tmanager connection open.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Events\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tControl Event Flow.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"EventMask\" required=\"true\">\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"on\">\n\t\t\t\t\t\t<para>If all events should be sent.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t\t<enum name=\"off\">\n\t\t\t\t\t\t<para>If no events should be sent.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t\t<enum name=\"system,call,log,...\">\n\t\t\t\t\t\t<para>To select which flags events should have to be sent.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Enable/Disable sending of events to this manager client.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Logoff\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tLogoff Manager.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Logoff the current manager session.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Login</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Login\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tLogin Manager.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"ActionID\">\n\t\t\t\t<para>ActionID for this transaction. Will be returned.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Username\" required=\"true\">\n\t\t\t\t<para>Username to login with as specified in manager.conf.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Secret\">\n\t\t\t\t<para>Secret to login with as specified in manager.conf.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Login Manager.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Logoff</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Challenge\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGenerate Challenge for MD5 Auth.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"AuthType\" required=\"true\">\n\t\t\t\t<para>Digest algorithm to use in the challenge. Valid values are:</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"MD5\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Generate a challenge for MD5 authentication.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Hangup\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tHangup channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>The exact channel name to be hungup, or to use a regular expression, set this parameter to: /regex/</para>\n\t\t\t\t<para>Example exact channel: SIP/provider-0000012a</para>\n\t\t\t\t<para>Example regular expression: /^SIP/provider-.*$/</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Cause\">\n\t\t\t\t<para>Numeric hangup cause.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Hangup a channel.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Status\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList channel status.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"false\">\n\t\t\t\t<para>The name of the channel to query for status.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Variables\">\n\t\t\t\t<para>Comma <literal>,</literal> separated list of variable to include.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"AllVariables\">\n\t\t\t\t<para>If set to \"true\", the Status event will include all channel variables for\n\t\t\t\tthe requested channel(s).</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"true\"/>\n\t\t\t\t\t<enum name=\"false\"/>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Will return the status information of each channel along with the\n\t\t\tvalue for the specified channel variables.</para>\n\t\t</description>\n\t\t<responses>\n\t\t\t<list-elements>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/managerEvent[@name='Status'])\" />\n\t\t\t</list-elements>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/managerEvent[@name='StatusComplete'])\" />\n\t\t</responses>\n\t</manager>\n\t<managerEvent language=\"en_US\" name=\"Status\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised in response to a Status command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"ActionID\" required=\"false\"/>\n\t\t\t\t<channel_snapshot/>\n\t\t\t\t<parameter name=\"Type\">\n\t\t\t\t\t<para>Type of channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"DNID\">\n\t\t\t\t\t<para>Dialed number identifier</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"EffectiveConnectedLineNum\">\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"EffectiveConnectedLineName\">\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"TimeToHangup\">\n\t\t\t\t\t<para>Absolute lifetime of the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"BridgeID\">\n\t\t\t\t\t<para>Identifier of the bridge the channel is in, may be empty if not in one</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Application\">\n\t\t\t\t\t<para>Application currently executing on the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Data\">\n\t\t\t\t\t<para>Data given to the currently executing channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Nativeformats\">\n\t\t\t\t\t<para>Media formats the connected party is willing to send or receive</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Readformat\">\n\t\t\t\t\t<para>Media formats that frames from the channel are received in</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Readtrans\">\n\t\t\t\t\t<para>Translation path for media received in native formats</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Writeformat\">\n\t\t\t\t\t<para>Media formats that frames to the channel are accepted in</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Writetrans\">\n\t\t\t\t\t<para>Translation path for media sent to the connected party</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Callgroup\">\n\t\t\t\t\t<para>Configured call group on the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Pickupgroup\">\n\t\t\t\t\t<para>Configured pickup group on the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Seconds\">\n\t\t\t\t\t<para>Number of seconds the channel has been active</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">Status</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<managerEvent language=\"en_US\" name=\"StatusComplete\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised in response to a Status command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"Items\">\n\t\t\t\t\t<para>Number of Status events returned</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">Status</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<manager name=\"Setvar\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSets a channel variable or function value.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\">\n\t\t\t\t<para>Channel to set variable for.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Variable\" required=\"true\">\n\t\t\t\t<para>Variable name, function or expression.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Value\" required=\"true\">\n\t\t\t\t<para>Variable or function value.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This command can be used to set the value of channel variables or dialplan\n\t\t\tfunctions.</para>\n\t\t\t<note>\n\t\t\t\t<para>If a channel name is not provided then the variable is considered global.</para>\n\t\t\t</note>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Getvar</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Getvar\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGets a channel variable or function value.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\">\n\t\t\t\t<para>Channel to read variable from.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Variable\" required=\"true\">\n\t\t\t\t<para>Variable name, function or expression.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Get the value of a channel variable or function return.</para>\n\t\t\t<note>\n\t\t\t\t<para>If a channel name is not provided then the variable is considered global.</para>\n\t\t\t</note>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Setvar</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"GetConfig\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tRetrieve configuration.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Filename\" required=\"true\">\n\t\t\t\t<para>Configuration filename (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Category\">\n\t\t\t\t<para>Category in configuration file.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Filter\">\n\t\t\t\t<para>A comma separated list of\n\t\t\t\t<replaceable>name_regex</replaceable>=<replaceable>value_regex</replaceable>\n\t\t\t\texpressions which will cause only categories whose variables match all expressions\n\t\t\t\tto be considered.  The special variable name <literal>TEMPLATES</literal>\n\t\t\t\tcan be used to control whether templates are included.  Passing\n\t\t\t\t<literal>include</literal> as the value will include templates\n\t\t\t\talong with normal categories. Passing\n\t\t\t\t<literal>restrict</literal> as the value will restrict the operation to\n\t\t\t\tONLY templates.  Not specifying a <literal>TEMPLATES</literal> expression\n\t\t\t\tresults in the default behavior which is to not include templates.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will dump the contents of a configuration\n\t\t\tfile by category and contents or optionally by specified category only.\n\t\t\tIn the case where a category name is non-unique, a filter may be specified\n\t\t\tto match only categories with matching variable values.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfigJSON</ref>\n\t\t\t<ref type=\"manager\">UpdateConfig</ref>\n\t\t\t<ref type=\"manager\">CreateConfig</ref>\n\t\t\t<ref type=\"manager\">ListCategories</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"GetConfigJSON\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tRetrieve configuration (JSON format).\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Filename\" required=\"true\">\n\t\t\t\t<para>Configuration filename (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Category\">\n\t\t\t\t<para>Category in configuration file.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Filter\">\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='GetConfig']/syntax/parameter[@name='Filter']/para[1])\" />\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will dump the contents of a configuration file by category\n\t\t\tand contents in JSON format or optionally by specified category only.\n\t\t\tThis only makes sense to be used using rawman over the HTTP interface.\n\t\t\tIn the case where a category name is non-unique, a filter may be specified\n\t\t\tto match only categories with matching variable values.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfig</ref>\n\t\t\t<ref type=\"manager\">UpdateConfig</ref>\n\t\t\t<ref type=\"manager\">CreateConfig</ref>\n\t\t\t<ref type=\"manager\">ListCategories</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"UpdateConfig\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tUpdate basic configuration.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"SrcFilename\" required=\"true\">\n\t\t\t\t<para>Configuration filename to read (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"DstFilename\" required=\"true\">\n\t\t\t\t<para>Configuration filename to write (e.g. <filename>foo.conf</filename>)</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Reload\">\n\t\t\t\t<para>Whether or not a reload should take place (or name of specific module).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"PreserveEffectiveContext\">\n\t\t\t\t<para>Whether the effective category contents should be preserved on template change. Default is true (pre 13.2 behavior).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Action-000000\">\n\t\t\t\t<para>Action to take.</para>\n\t\t\t\t<para>0's represent 6 digit number beginning with 000000.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"NewCat\" />\n\t\t\t\t\t<enum name=\"RenameCat\" />\n\t\t\t\t\t<enum name=\"DelCat\" />\n\t\t\t\t\t<enum name=\"EmptyCat\" />\n\t\t\t\t\t<enum name=\"Update\" />\n\t\t\t\t\t<enum name=\"Delete\" />\n\t\t\t\t\t<enum name=\"Append\" />\n\t\t\t\t\t<enum name=\"Insert\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Cat-000000\">\n\t\t\t\t<para>Category to operate on.</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Var-000000\">\n\t\t\t\t<para>Variable to work on.</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Value-000000\">\n\t\t\t\t<para>Value to work on.</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Match-000000\">\n\t\t\t\t<para>Extra match required to match line.</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Line-000000\">\n\t\t\t\t<para>Line in category to operate on (used with delete and insert actions).</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Options-000000\">\n\t\t\t\t<para>A comma separated list of action-specific options.</para>\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"NewCat\"><para>One or more of the following... </para>\n\t\t\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t\t\t<enum name=\"allowdups\"><para>Allow duplicate category names.</para></enum>\n\t\t\t\t\t\t\t\t<enum name=\"template\"><para>This category is a template.</para></enum>\n\t\t\t\t\t\t\t\t<enum name=\"inherit=&quot;template[,...]&quot;\"><para>Templates from which to inherit.</para></enum>\n\t\t\t\t\t\t\t</enumlist>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t</enumlist>\n\t\t\t\t\t<para> </para>\n\t\t\t\t\t\t<para>The following actions share the same options...</para>\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"RenameCat\"/>\n\t\t\t\t\t\t<enum name=\"DelCat\"/>\n\t\t\t\t\t\t<enum name=\"EmptyCat\"/>\n\t\t\t\t\t\t<enum name=\"Update\"/>\n\t\t\t\t\t\t<enum name=\"Delete\"/>\n\t\t\t\t\t\t<enum name=\"Append\"/>\n\t\t\t\t\t\t<enum name=\"Insert\"><para> </para>\n\t\t\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t\t\t<enum name=\"catfilter=&quot;&lt;expression&gt;[,...]&quot;\"><para> </para>\n\t\t\t\t\t\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='GetConfig']/syntax/parameter[@name='Filter']/para[1])\" />\n\t\t\t\t\t\t\t\t\t<para><literal>catfilter</literal> is most useful when a file\n\t\t\t\t\t\t\t\t\tcontains multiple categories with the same name and you wish to\n\t\t\t\t\t\t\t\t\toperate on specific ones instead of all of them.</para>\n\t\t\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t\t</enumlist>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t</enumlist>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will modify, create, or delete configuration elements\n\t\t\tin Asterisk configuration files.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfig</ref>\n\t\t\t<ref type=\"manager\">GetConfigJSON</ref>\n\t\t\t<ref type=\"manager\">CreateConfig</ref>\n\t\t\t<ref type=\"manager\">ListCategories</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"CreateConfig\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCreates an empty file in the configuration directory.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Filename\" required=\"true\">\n\t\t\t\t<para>The configuration filename to create (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will create an empty file in the configuration\n\t\t\tdirectory. This action is intended to be used before an UpdateConfig\n\t\t\taction.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfig</ref>\n\t\t\t<ref type=\"manager\">GetConfigJSON</ref>\n\t\t\t<ref type=\"manager\">UpdateConfig</ref>\n\t\t\t<ref type=\"manager\">ListCategories</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"ListCategories\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList categories in configuration file.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Filename\" required=\"true\">\n\t\t\t\t<para>Configuration filename (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will dump the categories in a given file.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfig</ref>\n\t\t\t<ref type=\"manager\">GetConfigJSON</ref>\n\t\t\t<ref type=\"manager\">UpdateConfig</ref>\n\t\t\t<ref type=\"manager\">CreateConfig</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Redirect\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tRedirect (transfer) a call.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Channel to redirect.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ExtraChannel\">\n\t\t\t\t<para>Second call leg to transfer (optional).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Exten\" required=\"true\">\n\t\t\t\t<para>Extension to transfer to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ExtraExten\">\n\t\t\t\t<para>Extension to transfer extrachannel to (optional).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\" required=\"true\">\n\t\t\t\t<para>Context to transfer to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ExtraContext\">\n\t\t\t\t<para>Context to transfer extrachannel to (optional).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Priority\" required=\"true\">\n\t\t\t\t<para>Priority to transfer to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ExtraPriority\">\n\t\t\t\t<para>Priority to transfer extrachannel to (optional).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Redirect (transfer) a call.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">BlindTransfer</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Atxfer\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tAttended transfer.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Transferer's channel.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Exten\" required=\"true\">\n\t\t\t\t<para>Extension to transfer to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\">\n\t\t\t\t<para>Context to transfer to.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Attended transfer.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">AttendedTransfer</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"CancelAtxfer\" language=\"en_US\">\n\t\t<since>\n\t\t\t<version>13.18.0</version>\n\t\t\t<version>14.7.0</version>\n\t\t\t<version>15.1.0</version>\n\t\t\t<version>16.0.0</version>\n\t\t</since>\n\t\t<synopsis>\n\t\t\tCancel an attended transfer.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>The transferer channel.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Cancel an attended transfer. Note, this uses the configured cancel attended transfer\n\t\t\tfeature option (atxferabort) to cancel the transfer. If not available this action will fail.\n\t\t\t</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">AttendedTransfer</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Originate\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tOriginate a call.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Channel name to call.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Exten\">\n\t\t\t\t<para>Extension to use (requires <literal>Context</literal> and\n\t\t\t\t<literal>Priority</literal>)</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\">\n\t\t\t\t<para>Context to use (requires <literal>Exten</literal> and\n\t\t\t\t<literal>Priority</literal>)</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Priority\">\n\t\t\t\t<para>Priority to use (requires <literal>Exten</literal> and\n\t\t\t\t<literal>Context</literal>)</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Application\">\n\t\t\t\t<para>Application to execute.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Data\">\n\t\t\t\t<para>Data to use (requires <literal>Application</literal>).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Timeout\" default=\"30000\">\n\t\t\t\t<para>How long to wait for call to be answered (in ms.).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"CallerID\">\n\t\t\t\t<para>Caller ID to be set on the outgoing channel.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Variable\">\n\t\t\t\t<para>Channel variable to set, multiple Variable: headers are allowed.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Account\">\n\t\t\t\t<para>Account code.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"EarlyMedia\">\n\t\t\t\t<para>Set to <literal>true</literal> to force call bridge on early media..</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Async\">\n\t\t\t\t<para>Set to <literal>true</literal> for fast origination.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Codecs\">\n\t\t\t\t<para>Comma-separated list of codecs to use for this call.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChannelId\">\n\t\t\t\t<para>Channel UniqueId to be set on the channel.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"OtherChannelId\">\n\t\t\t\t<para>Channel UniqueId to be set on the second local channel.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Generates an outgoing call to a\n\t\t\t<replaceable>Extension</replaceable>/<replaceable>Context</replaceable>/<replaceable>Priority</replaceable>\n\t\t\tor <replaceable>Application</replaceable>/<replaceable>Data</replaceable></para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">OriginateResponse</ref>\n\t\t</see-also>\n\t</manager>\n\t<managerEvent language=\"en_US\" name=\"OriginateResponse\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised in response to an Originate command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"ActionID\" required=\"false\"/>\n\t\t\t\t<parameter name=\"Response\">\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"Failure\"/>\n\t\t\t\t\t\t<enum name=\"Success\"/>\n\t\t\t\t\t</enumlist>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Channel\"/>\n\t\t\t\t<parameter name=\"Context\"/>\n\t\t\t\t<parameter name=\"Exten\"/>\n\t\t\t\t<parameter name=\"Application\"/>\n\t\t\t\t<parameter name=\"Data\"/>\n\t\t\t\t<parameter name=\"Reason\"/>\n\t\t\t\t<parameter name=\"Uniqueid\"/>\n\t\t\t\t<parameter name=\"CallerIDNum\"/>\n\t\t\t\t<parameter name=\"CallerIDName\"/>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">Originate</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<manager name=\"Command\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tExecute Asterisk CLI Command.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Command\" required=\"true\">\n\t\t\t\t<para>Asterisk CLI command to run.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Run a CLI command.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"ExtensionState\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck Extension Status.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Exten\" required=\"true\">\n\t\t\t\t<para>Extension to check state on.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\" required=\"true\">\n\t\t\t\t<para>Context for extension.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Report the extension state for given extension. If the extension has a hint,\n\t\t\twill use devicestate to check the status of the device connected to the extension.</para>\n\t\t\t<para>Will return an <literal>Extension Status</literal> message. The response will include\n\t\t\tthe hint for the extension and the status.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">ExtensionStatus</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"PresenceState\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck Presence State\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Provider\" required=\"true\">\n\t\t\t\t<para>Presence Provider to check the state of</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Report the presence state for the given presence provider.</para>\n\t\t\t<para>Will return a <literal>Presence State</literal> message. The response will include the\n\t\t\tpresence state and, if set, a presence subtype and custom message.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">PresenceStatus</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"AbsoluteTimeout\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSet absolute timeout.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Channel name to hangup.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Timeout\" required=\"true\">\n\t\t\t\t<para>Maximum duration of the call (sec).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Hangup a channel after a certain time. Acknowledges set time with\n\t\t\t<literal>Timeout Set</literal> message.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"MailboxStatus\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck mailbox.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Mailbox\" required=\"true\">\n\t\t\t\t<para>Full mailbox ID <replaceable>mailbox</replaceable>@<replaceable>vm-context</replaceable>.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Checks a voicemail account for status.</para>\n\t\t\t<para>Returns whether there are messages waiting.</para>\n\t\t\t<para>Message: Mailbox Status.</para>\n\t\t\t<para>Mailbox: <replaceable>mailboxid</replaceable>.</para>\n\t\t\t<para>Waiting: <literal>0</literal> if messages waiting, <literal>1</literal>\n\t\t\tif no messages waiting.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">MailboxCount</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"MailboxCount\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck Mailbox Message Count.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Mailbox\" required=\"true\">\n\t\t\t\t<para>Full mailbox ID <replaceable>mailbox</replaceable>@<replaceable>vm-context</replaceable>.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Checks a voicemail account for new messages.</para>\n\t\t\t<para>Returns number of urgent, new and old messages.</para>\n\t\t\t<para>Message: Mailbox Message Count</para>\n\t\t\t<para>Mailbox: <replaceable>mailboxid</replaceable></para>\n\t\t\t<para>UrgentMessages: <replaceable>count</replaceable></para>\n\t\t\t<para>NewMessages: <replaceable>count</replaceable></para>\n\t\t\t<para>OldMessages: <replaceable>count</replaceable></para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">MailboxStatus</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"ListCommands\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList available manager commands.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Returns the action name and synopsis for every action that\n\t\t\tis available to the user.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"SendText\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSends a text message to channel. A content type\tcan be optionally specified. If not set\n\t\t\tit is set to an empty string allowing a custom handler to default it as it sees fit.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Channel to send message to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Message\" required=\"true\">\n\t\t\t\t<para>Message to send.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Content-Type\" required=\"false\" default=\"\">\n\t\t\t\t<para>The type of content in the message</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Sends A Text Message to a channel while in a call.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"application\">SendText</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"UserEvent\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSend an arbitrary event.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"UserEvent\" required=\"true\">\n\t\t\t\t<para>Event string to send.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Header1\">\n\t\t\t\t<para>Content1.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"HeaderN\">\n\t\t\t\t<para>ContentN.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Send an event to manager sessions.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">UserEvent</ref>\n\t\t\t<ref type=\"application\">UserEvent</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"WaitEvent\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tWait for an event to occur.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Timeout\" required=\"true\">\n\t\t\t\t<para>Maximum time (in seconds) to wait for events, <literal>-1</literal> means forever.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will elicit a <literal>Success</literal> response. Whenever\n\t\t\ta manager event is queued. Once WaitEvent has been called on an HTTP manager\n\t\t\tsession, events will be generated and queued.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"CoreSettings\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tShow PBX core settings (version etc).\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Query for Core PBX settings.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"CoreStatus\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tShow PBX core status variables.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Query for Core PBX status.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Reload\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSend a reload event.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Module\">\n\t\t\t\t<para>Name of the module to reload.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Send a reload event.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">ModuleLoad</ref>\n\t\t</see-also>\n\t</manager>\n\t<managerEvent language=\"en_US\" name=\"CoreShowChannel\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised in response to a CoreShowChannels command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t\t<channel_snapshot/>\n\t\t\t\t<parameter name=\"BridgeId\">\n\t\t\t\t\t<para>Identifier of the bridge the channel is in, may be empty if not in one</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Application\">\n\t\t\t\t\t<para>Application currently executing on the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"ApplicationData\">\n\t\t\t\t\t<para>Data given to the currently executing application</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Duration\">\n\t\t\t\t\t<para>The amount of time the channel has existed</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">CoreShowChannels</ref>\n\t\t\t\t<ref type=\"managerEvent\">CoreShowChannelsComplete</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<managerEvent language=\"en_US\" name=\"CoreShowChannelsComplete\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised at the end of the CoreShowChannel list produced by the CoreShowChannels command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t\t<parameter name=\"EventList\">\n\t\t\t\t\t<para>Conveys the status of the command reponse list</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"ListItems\">\n\t\t\t\t\t<para>The total number of list items produced</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">CoreShowChannels</ref>\n\t\t\t\t<ref type=\"managerEvent\">CoreShowChannel</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<manager name=\"CoreShowChannels\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList currently active channels.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>List currently defined channels and some information about them.</para>\n\t\t</description>\n\t\t<responses>\n\t\t\t<list-elements>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/managerEvent[@name='CoreShowChannel'])\" />\n\t\t\t</list-elements>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/managerEvent[@name='CoreShowChannelsComplete'])\" />\n\t\t</responses>\n\t</manager>\n\t<managerEvent language=\"en_US\" name=\"CoreShowChannelMapComplete\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised at the end of the CoreShowChannelMap list produced by the CoreShowChannelMap command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"EventList\">\n\t\t\t\t\t<para>Conveys the status of the command response list</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"ListItems\">\n\t\t\t\t\t<para>The total number of list items produced</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<manager name=\"CoreShowChannelMap\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList all channels connected to the specified channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"Channel\">\n\t\t\t\t<para>The channel to get the mapping for. Requires a channel name.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>List all channels currently connected to the specified channel. This can be any channel, including\n\t\t\tLocal channels, and Local channels will be followed through to their other half.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"LoggerRotate\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tReload and rotate the Asterisk logger.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Reload and rotate the logger. Analogous to the CLI command 'logger rotate'.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"ModuleLoad\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tModule management.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Module\">\n\t\t\t\t<para>Asterisk module name (including .so extension) or subsystem identifier:</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"cdr\" />\n\t\t\t\t\t<enum name=\"dnsmgr\" />\n\t\t\t\t\t<enum name=\"extconfig\" />\n\t\t\t\t\t<enum name=\"enum\" />\n\t\t\t\t\t<enum name=\"acl\" />\n\t\t\t\t\t<enum name=\"manager\" />\n\t\t\t\t\t<enum name=\"http\" />\n\t\t\t\t\t<enum name=\"logger\" />\n\t\t\t\t\t<enum name=\"features\" />\n\t\t\t\t\t<enum name=\"dsp\" />\n\t\t\t\t\t<enum name=\"udptl\" />\n\t\t\t\t\t<enum name=\"indications\" />\n\t\t\t\t\t<enum name=\"cel\" />\n\t\t\t\t\t<enum name=\"plc\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"LoadType\" required=\"true\">\n\t\t\t\t<para>The operation to be done on module. Subsystem identifiers may only\n\t\t\t\tbe reloaded.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"load\" />\n\t\t\t\t\t<enum name=\"unload\" />\n\t\t\t\t\t<enum name=\"reload\" />\n\t\t\t\t</enumlist>\n\t\t\t\t<para>If no module is specified for a <literal>reload</literal> loadtype,\n\t\t\t\tall modules are reloaded.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Loads, unloads or reloads an Asterisk module in a running system.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Reload</ref>\n\t\t\t<ref type=\"manager\">ModuleCheck</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"ModuleCheck\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck if module is loaded.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Module\" required=\"true\">\n\t\t\t\t<para>Asterisk module name (not including extension).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Checks if Asterisk module is loaded. Will return Success/Failure.\n\t\t\tAn empty Version header is also returned (which doesn't contain\n\t\t\tthe module revision number).</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">ModuleLoad</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"AOCMessage\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGenerate an Advice of Charge message on a channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\">\n\t\t\t\t<para>Channel name to generate the AOC message on.\n\t\t\t\tThis value is required unless ChannelPrefix is given.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChannelPrefix\">\n\t\t\t\t<para>Partial channel prefix.  By using this option one can match the beginning part\n\t\t\t\tof a channel name without having to put the entire name in.  For example\n\t\t\t\tif a channel name is SIP/snom-00000001 and this value is set to SIP/snom, then\n\t\t\t\tthat channel matches and the message will be sent.  Note however that only\n\t\t\t\tthe first matched channel has the message sent on it. </para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"MsgType\" required=\"true\">\n\t\t\t\t<para>Defines what type of AOC message to create, AOC-S, AOC-D or AOC-E</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"S\" />\n\t\t\t\t\t<enum name=\"D\" />\n\t\t\t\t\t<enum name=\"E\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargeType\">\n\t\t\t\t<para>Defines what kind of charge this message represents for AOC-D and AOC-E.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"NA\" />\n\t\t\t\t\t<enum name=\"FREE\" />\n\t\t\t\t\t<enum name=\"Currency\" />\n\t\t\t\t\t<enum name=\"Unit\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"UnitAmount(0)\">\n\t\t\t\t<para>This represents the amount of units charged. The ETSI AOC standard specifies that\n\t\t\t\tthis value along with the optional UnitType value are entries in a list.  To accommodate this\n\t\t\t\tthese values take an index value starting at 0 which can be used to generate this list of\n\t\t\t\tunit entries.  For Example, If two unit entires were required this could be achieved by setting the\n\t\t\t\tparamter UnitAmount(0)=1234 and UnitAmount(1)=5678.  Note that UnitAmount at index 0 is\n\t\t\t\trequired when ChargeType=Unit, all other entries in the list are optional.\n\t\t\t\t</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"UnitType(0)\">\n\t\t\t\t<para>Defines the type of unit.  ETSI AOC standard specifies this as an integer\n\t\t\t\tvalue between 1 and 16, but this value is left open to accept any positive\n\t\t\t\tinteger.  Like the UnitAmount parameter, this value represents a list entry\n\t\t\t\tand has an index parameter that starts at 0.\n\t\t\t\t</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"CurrencyName\">\n\t\t\t\t<para>Specifies the currency's name.  Note that this value is truncated after 10 characters.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"CurrencyAmount\">\n\t\t\t\t<para>Specifies the charge unit amount as a positive integer.\n\t\t\t\tThis value is required when ChargeType==Currency (AOC-D or AOC-E) or\n\t\t\t\tRateType==Duration/Flat/Volume (AOC-S).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"CurrencyMultiplier\">\n\t\t\t\t<para>Specifies the currency multiplier.\n\t\t\t\tThis value is required when CurrencyAmount is given.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"OneThousandth\" />\n\t\t\t\t\t<enum name=\"OneHundredth\" />\n\t\t\t\t\t<enum name=\"OneTenth\" />\n\t\t\t\t\t<enum name=\"One\" />\n\t\t\t\t\t<enum name=\"Ten\" />\n\t\t\t\t\t<enum name=\"Hundred\" />\n\t\t\t\t\t<enum name=\"Thousand\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"TotalType\" default=\"Total\">\n\t\t\t\t<para>Defines what kind of AOC-D total is represented.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"Total\" />\n\t\t\t\t\t<enum name=\"SubTotal\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"AOCBillingId\">\n\t\t\t\t<para>Represents a billing ID associated with an AOC-D or AOC-E message. Note\n\t\t\t\tthat only the first 3 items of the enum are valid AOC-D billing IDs</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"Normal\" />\n\t\t\t\t\t<enum name=\"ReverseCharge\" />\n\t\t\t\t\t<enum name=\"CreditCard\" />\n\t\t\t\t\t<enum name=\"CallFwdUnconditional\" />\n\t\t\t\t\t<enum name=\"CallFwdBusy\" />\n\t\t\t\t\t<enum name=\"CallFwdNoReply\" />\n\t\t\t\t\t<enum name=\"CallDeflection\" />\n\t\t\t\t\t<enum name=\"CallTransfer\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargingAssociationId\">\n\t\t\t\t<para>Charging association identifier.  This is optional for AOC-E and can be\n\t\t\t\tset to any value between -32768 and 32767</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargingAssociationNumber\">\n\t\t\t\t<para>Represents the charging association party number.  This value is optional\n\t\t\t\tfor AOC-E.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargingAssociationPlan\">\n\t\t\t\t<para>Integer representing the charging plan associated with the ChargingAssociationNumber.\n\t\t\t\tThe value is bits 7 through 1 of the Q.931 octet containing the type-of-number and\n\t\t\t\tnumbering-plan-identification fields.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargedItem\">\n\t\t\t\t<para>Defines what part of the call is charged in AOC-S. Usually this is set to\n\t\t\t\tBasicCommunication, which refers to the time after the call is answered, but establishment\n\t\t\t\t(CallAttempt) or successful establishment (CallSetup) of a call can also be used.\n\t\t\t\tOther options are available, but these generally do not carry enough information to actually\n\t\t\t\tcalculate the price of a call.\n\t\t\t\tIt is possible to have multiple ChargedItem entries for a single call -- for example to\n\t\t\t\tcharge for both the establishment of the call and the actual call. In this case, each\n\t\t\t\tChargedItem is described by a ChargedItem: header and all other headers that follow it up to\n\t\t\t\tthe next ChargedItem: header.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"NA\" />\n\t\t\t\t\t<enum name=\"SpecialArrangement\" />\n\t\t\t\t\t<enum name=\"BasicCommunication\" />\n\t\t\t\t\t<enum name=\"CallAttempt\" />\n\t\t\t\t\t<enum name=\"CallSetup\" />\n\t\t\t\t\t<enum name=\"UserUserInfo\" />\n\t\t\t\t\t<enum name=\"SupplementaryService\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"RateType\">\n\t\t\t\t<para>Defines how an AOC-S ChargedItem is charged.\n\t\t\t\tThe Duration option is only available when ChargedItem==BasicCommunication.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"NA\" />\n\t\t\t\t\t<enum name=\"Free\" />\n\t\t\t\t\t<enum name=\"FreeFromBeginning\" />\n\t\t\t\t\t<enum name=\"Duration\" />\n\t\t\t\t\t<enum name=\"Flat\" />\n\t\t\t\t\t<enum name=\"Volume\" />\n\t\t\t\t\t<enum name=\"SpecialCode\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Time\">\n\t\t\t\t<para>Specifies a positive integer which is the amount of time is paid for by one\n\t\t\t\tCurrencyAmount.\n\t\t\t\tThis value is required when RateType==Duration.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"TimeScale\">\n\t\t\t\t<para>Specifies the time multiplier.\n\t\t\t\tThis value is required when Time is given.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"OneHundredthSecond\" />\n\t\t\t\t\t<enum name=\"OneTenthSecond\" />\n\t\t\t\t\t<enum name=\"Second\" />\n\t\t\t\t\t<enum name=\"TenSeconds\" />\n\t\t\t\t\t<enum name=\"Minute\" />\n\t\t\t\t\t<enum name=\"Hour\" />\n\t\t\t\t\t<enum name=\"Day\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Granularity\">\n\t\t\t\t<para>Specifies a positive integer which is the size of the charged time increments.\n\t\t\t\tThis value is optional when RateType==Duration and ChargingType==StepFunction.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"GranularityTimeScale\">\n\t\t\t\t<para>Specifies the granularity time multiplier.\n\t\t\t\tThis value is required when Granularity is given.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"OneHundredthSecond\" />\n\t\t\t\t\t<enum name=\"OneTenthSecond\" />\n\t\t\t\t\t<enum name=\"Second\" />\n\t\t\t\t\t<enum name=\"TenSeconds\" />\n\t\t\t\t\t<enum name=\"Minute\" />\n\t\t\t\t\t<enum name=\"Hour\" />\n\t\t\t\t\t<enum name=\"Day\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargingType\">\n\t\t\t\t<para>Specifies whether the charge increases continuously with time or in increments of\n\t\t\t\tTime or, if provided, Granularity.\n\t\t\t\tThis value is required when RateType==Duration.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"ContinuousCharging\" />\n\t\t\t\t\t<enum name=\"StepFunction\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"VolumeUnit\">\n\t\t\t\t<para>Specifies the quantity of which one unit is paid for by one CurrencyAmount.\n\t\t\t\tThis value is required when RateType==Volume.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"Octet\" />\n\t\t\t\t\t<enum name=\"Segment\" />\n\t\t\t\t\t<enum name=\"Message\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Code\">\n\t\t\t\t<para>Specifies the charging code, which can be set to a value between 1 and 10.\n\t\t\t\tThis value is required when ChargedItem==SpecialArrangement or RateType==SpecialCode.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Generates an AOC-S, AOC-D or AOC-E message on a channel.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">AOC-S</ref>\n\t\t\t<ref type=\"managerEvent\">AOC-D</ref>\n\t\t\t<ref type=\"managerEvent\">AOC-E</ref>\n\t\t</see-also>\n\t</manager>\n\t<function name=\"AMI_CLIENT\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tChecks attributes of manager accounts\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"loginname\" required=\"true\">\n\t\t\t\t<para>Login name, specified in manager.conf</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"field\" required=\"true\">\n\t\t\t\t<para>The manager account attribute to return</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"sessions\"><para>The number of sessions for this AMI account</para></enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>\n\t\t\t\tCurrently, the only supported  parameter is \"sessions\" which will return the current number of\n\t\t\t\tactive sessions for this AMI account.\n\t\t\t</para>\n\t\t</description>\n\t</function>\n\t<manager name=\"Filter\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tDynamically add filters for the current manager session.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Operation\">\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"Add\">\n\t\t\t\t\t\t<para>Add a filter.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Filter\">\n\t\t\t\t<para>Filters can be whitelist or blacklist</para>\n\t\t\t\t<para>Example whitelist filter: \"Event: Newchannel\"</para>\n\t\t\t\t<para>Example blacklist filter: \"!Channel: DAHDI.*\"</para>\n\t\t\t\t<para>This filter option is used to whitelist or blacklist events per user to be\n\t\t\t\treported with regular expressions and are allowed if both the regex matches\n\t\t\t\tand the user has read access as defined in manager.conf. Filters are assumed to be for whitelisting\n\t\t\t\tunless preceeded by an exclamation point, which marks it as being black.\n\t\t\t\tEvaluation of the filters is as follows:</para>\n\t\t\t\t<para>- If no filters are configured all events are reported as normal.</para>\n\t\t\t\t<para>- If there are white filters only: implied black all filter processed first, then white filters.</para>\n\t\t\t\t<para>- If there are black filters only: implied white all filter processed first, then black filters.</para>\n\t\t\t\t<para>- If there are both white and black filters: implied black all filter processed first, then white\n\t\t\t\tfilters, and lastly black filters.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>The filters added are only used for the current session.\n\t\t\tOnce the connection is closed the filters are removed.</para>\n\t\t\t<para>This comand requires the system permission because\n\t\t\tthis command can be used to create filters that may bypass\n\t\t\tfilters defined in manager.conf</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"BlindTransfer\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tBlind transfer channel(s) to the given destination\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\">\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Exten\">\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Redirect all channels currently bridged to the specified channel to the specified destination.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Redirect</ref>\n\t\t\t<ref type=\"managerEvent\">BlindTransfer</ref>\n\t\t</see-also>\n\t</manager>\n\t<managerEvent name=\"ExtensionStatus\" language=\"en_US\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised when a hint changes due to a device state change.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"Exten\">\n\t\t\t\t\t<para>Name of the extension.</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Context\">\n\t\t\t\t\t<para>Context that owns the extension.</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Hint\">\n\t\t\t\t\t<para>Hint set for the extension</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Status\">\n\t\t\t\t\t<para>Numerical value of the extension status. Extension\n\t\t\t\t\tstatus is determined by the combined device state of all items\n\t\t\t\t\tcontained in the hint.</para>\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"-2\">\n\t\t\t\t\t\t\t<para>The extension was removed from the dialplan.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"-1\">\n\t\t\t\t\t\t\t<para>The extension's hint was removed from the dialplan.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"0\">\n\t\t\t\t\t\t\t<para><literal>Idle</literal> - Related device(s) are in an idle\n\t\t\t\t\t\t\tstate.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"1\">\n\t\t\t\t\t\t\t<para><literal>InUse</literal> - Related device(s) are in active\n\t\t\t\t\t\t\tcalls but may take more calls.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"2\">\n\t\t\t\t\t\t\t<para><literal>Busy</literal> - Related device(s) are in active\n\t\t\t\t\t\t\tcalls and may not take any more calls.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"4\">\n\t\t\t\t\t\t\t<para><literal>Unavailable</literal> - Related device(s) are\n\t\t\t\t\t\t\tnot reachable.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"8\">\n\t\t\t\t\t\t\t<para><literal>Ringing</literal> - Related device(s) are\n\t\t\t\t\t\t\tcurrently ringing.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"9\">\n\t\t\t\t\t\t\t<para><literal>InUse&amp;Ringing</literal> - Related device(s)\n\t\t\t\t\t\t\tare currently ringing and in active calls.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"16\">\n\t\t\t\t\t\t\t<para><literal>Hold</literal> - Related device(s) are\n\t\t\t\t\t\t\tcurrently on hold.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"17\">\n\t\t\t\t\t\t\t<para><literal>InUse&amp;Hold</literal> - Related device(s)\n\t\t\t\t\t\t\tare currently on hold and in active calls.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t</enumlist>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"StatusText\">\n\t\t\t\t\t<para>Text representation of <literal>Status</literal>.</para>\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"Idle\" />\n\t\t\t\t\t\t<enum name=\"InUse\" />\n\t\t\t\t\t\t<enum name=\"Busy\" />\n\t\t\t\t\t\t<enum name=\"Unavailable\" />\n\t\t\t\t\t\t<enum name=\"Ringing\" />\n\t\t\t\t\t\t<enum name=\"InUse&amp;Ringing\" />\n\t\t\t\t\t\t<enum name=\"Hold\" />\n\t\t\t\t\t\t<enum name=\"InUse&amp;Hold\" />\n\t\t\t\t\t\t<enum name=\"Unknown\">\n\t\t\t\t\t\t\t<para>Status does not match any of the above values.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t</enumlist>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">ExtensionState</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<managerEvent name=\"PresenceStatus\" language=\"en_US\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised when a hint changes due to a presence state change.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"Exten\" />\n\t\t\t\t<parameter name=\"Context\" />\n\t\t\t\t<parameter name=\"Hint\" />\n\t\t\t\t<parameter name=\"Status\" />\n\t\t\t\t<parameter name=\"Subtype\" />\n\t\t\t\t<parameter name=\"Message\" />\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">PresenceState</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n ***/\n\n/*! \\addtogroup Group_AMI AMI functions\n*/\n/*! @{\n Doxygen group */\n\nenum error_type {\n\tUNKNOWN_ACTION = 1,\n\tUNKNOWN_CATEGORY,\n\tUNSPECIFIED_CATEGORY,\n\tUNSPECIFIED_ARGUMENT,\n\tFAILURE_ALLOCATION,\n\tFAILURE_NEWCAT,\n\tFAILURE_DELCAT,\n\tFAILURE_EMPTYCAT,\n\tFAILURE_UPDATE,\n\tFAILURE_DELETE,\n\tFAILURE_APPEND,\n\tFAILURE_TEMPLATE\n};\n\nenum add_filter_result {\n\tFILTER_SUCCESS,\n\tFILTER_ALLOC_FAILED,\n\tFILTER_COMPILE_FAIL,\n};\n\n/*!\n * Linked list of events.\n * Global events are appended to the list by append_event().\n * The usecount is the number of stored pointers to the element,\n * excluding the list pointers. So an element that is only in\n * the list has a usecount of 0, not 1.\n *\n * Clients have a pointer to the last event processed, and for each\n * of these clients we track the usecount of the elements.\n * If we have a pointer to an entry in the list, it is safe to navigate\n * it forward because elements will not be deleted, but only appended.\n * The worst that can happen is seeing the pointer still NULL.\n *\n * When the usecount of an element drops to 0, and the element is the\n * first in the list, we can remove it. Removal is done within the\n * main thread, which is woken up for the purpose.\n *\n * For simplicity of implementation, we make sure the list is never empty.\n */\nstruct eventqent {\n\tint usecount;\t\t/*!< # of clients who still need the event */\n\tint category;\n\tunsigned int seq;\t/*!< sequence number */\n\tstruct timeval tv;  /*!< When event was allocated */\n\tAST_RWLIST_ENTRY(eventqent) eq_next;\n\tchar eventdata[1];\t/*!< really variable size, allocated by append_event() */\n};\n\nstatic AST_RWLIST_HEAD_STATIC(all_events, eventqent);\n\nstatic int displayconnects = 1;\nstatic int allowmultiplelogin = 1;\nstatic int timestampevents;\nstatic int httptimeout = 60;\nstatic int broken_events_action = 0;\nstatic int manager_enabled = 0;\nstatic int subscribed = 0;\nstatic int webmanager_enabled = 0;\nstatic int manager_debug = 0;\t/*!< enable some debugging code in the manager */\nstatic int authtimeout;\nstatic int authlimit;\nstatic char *manager_channelvars;\nstatic char *manager_disabledevents;\n\n#define DEFAULT_REALM\t\t\"asterisk\"\nstatic char global_realm[MAXHOSTNAMELEN];\t/*!< Default realm */\n\nstatic int unauth_sessions = 0;\nstatic struct stasis_subscription *acl_change_sub;\n\n/*! \\brief A \\ref stasis_topic that all topics AMI cares about will be forwarded to */\nstatic struct stasis_topic *manager_topic;\n\n/*! \\brief The \\ref stasis_message_router for all \\ref stasis messages */\nstatic struct stasis_message_router *stasis_router;\n\n/*! \\brief The \\ref stasis_subscription for forwarding the RTP topic to the AMI topic */\nstatic struct stasis_forward *rtp_topic_forwarder;\n\n/*! \\brief The \\ref stasis_subscription for forwarding the Security topic to the AMI topic */\nstatic struct stasis_forward *security_topic_forwarder;\n\n/*!\n * \\brief Set to true (non-zero) to globally allow all dangerous AMI actions to run\n */\nstatic int live_dangerously;\n\n#ifdef TEST_FRAMEWORK\n/*! \\brief The \\ref stasis_subscription for forwarding the Test topic to the AMI topic */\nstatic struct stasis_forward *test_suite_forwarder;\n#endif\n\n#define MGR_SHOW_TERMINAL_WIDTH 80\n\n#define MAX_VARS 128\n\n/*! \\brief Fake event class used to end sessions at shutdown */\n#define EVENT_FLAG_SHUTDOWN -1\n\n/*! \\brief\n * Descriptor for a manager session, either on the AMI socket or over HTTP.\n *\n * \\note\n * AMI session have managerid == 0; the entry is created upon a connect,\n * and destroyed with the socket.\n * HTTP sessions have managerid != 0, the value is used as a search key\n * to lookup sessions (using the mansession_id cookie, or nonce key from\n * Digest Authentication http header).\n */\n#define MAX_BLACKLIST_CMD_LEN 2\nstatic const struct {\n\tconst char *words[AST_MAX_CMD_LEN];\n} command_blacklist[] = {\n\t{{ \"module\", \"load\", NULL }},\n\t{{ \"module\", \"unload\", NULL }},\n\t{{ \"restart\", \"gracefully\", NULL }},\n};\n\nstatic void acl_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message);\n\nstatic void acl_change_stasis_subscribe(void)\n{\n\tif (!acl_change_sub) {\n\t\tacl_change_sub = stasis_subscribe(ast_security_topic(),\n\t\t\tacl_change_stasis_cb, NULL);\n\t\tstasis_subscription_accept_message_type(acl_change_sub, ast_named_acl_change_type());\n\t\tstasis_subscription_set_filter(acl_change_sub, STASIS_SUBSCRIPTION_FILTER_SELECTIVE);\n\t}\n}\n\nstatic void acl_change_stasis_unsubscribe(void)\n{\n\tacl_change_sub = stasis_unsubscribe_and_join(acl_change_sub);\n}\n\n/* In order to understand what the heck is going on with the\n * mansession_session and mansession structs, we need to have a bit of a history\n * lesson.\n *\n * In the beginning, there was the mansession. The mansession contained data that was\n * intrinsic to a manager session, such as the time that it started, the name of the logged-in\n * user, etc. In addition to these parameters were the f and fd parameters. For typical manager\n * sessions, these were used to represent the TCP socket over which the AMI session was taking\n * place. It makes perfect sense for these fields to be a part of the session-specific data since\n * the session actually defines this information.\n *\n * Then came the HTTP AMI sessions. With these, the f and fd fields need to be opened and closed\n * for every single action that occurs. Thus the f and fd fields aren't really specific to the session\n * but rather to the action that is being executed. Because a single session may execute many commands\n * at once, some sort of safety needed to be added in order to be sure that we did not end up with fd\n * leaks from one action overwriting the f and fd fields used by a previous action before the previous action\n * has had a chance to properly close its handles.\n *\n * The initial idea to solve this was to use thread synchronization, but this prevented multiple actions\n * from being run at the same time in a single session. Some manager actions may block for a long time, thus\n * creating a large queue of actions to execute. In addition, this fix did not address the basic architectural\n * issue that for HTTP manager sessions, the f and fd variables are not really a part of the session, but are\n * part of the action instead.\n *\n * The new idea was to create a structure on the stack for each HTTP Manager action. This structure would\n * contain the action-specific information, such as which file to write to. In order to maintain expectations\n * of action handlers and not have to change the public API of the manager code, we would need to name this\n * new stacked structure 'mansession' and contain within it the old mansession struct that we used to use.\n * We renamed the old mansession struct 'mansession_session' to hopefully convey that what is in this structure\n * is session-specific data. The structure that it is wrapped in, called a 'mansession' really contains action-specific\n * data.\n */\nstruct mansession_session {\n\t\t\t\t/*! \\todo XXX need to document which fields it is protecting */\n\tstruct ast_sockaddr addr;\t/*!< address we are connecting from */\n\tstruct ast_iostream *stream;\t/*!< AMI stream */\n\tint inuse;\t\t/*!< number of HTTP sessions using this entry */\n\tint needdestroy;\t/*!< Whether an HTTP session should be destroyed */\n\tpthread_t waiting_thread;\t/*!< Sleeping thread using this descriptor */\n\tuint32_t managerid;\t/*!< Unique manager identifier, 0 for AMI sessions */\n\ttime_t sessionstart;    /*!< Session start time */\n\tstruct timeval sessionstart_tv; /*!< Session start time */\n\ttime_t sessiontimeout;\t/*!< Session timeout if HTTP */\n\tchar username[80];\t/*!< Logged in username */\n\tchar challenge[10];\t/*!< Authentication challenge */\n\tint authenticated;\t/*!< Authentication status */\n\tint readperm;\t\t/*!< Authorization for reading */\n\tint writeperm;\t\t/*!< Authorization for writing */\n\tchar inbuf[1025];\t/*!< Buffer -  we use the extra byte to add a '\\\\0' and simplify parsing */\n\tint inlen;\t\t/*!< number of buffered bytes */\n\tstruct ao2_container *whitefilters;\t/*!< Manager event filters - white list */\n\tstruct ao2_container *blackfilters;\t/*!< Manager event filters - black list */\n\tstruct ast_variable *chanvars;  /*!< Channel variables to set for originate */\n\tint send_events;\t/*!<  XXX what ? */\n\tstruct eventqent *last_ev;\t/*!< last event processed. */\n\tint writetimeout;\t/*!< Timeout for ast_carefulwrite() */\n\ttime_t authstart;\n\tint pending_event;         /*!< Pending events indicator in case when waiting_thread is NULL */\n\ttime_t noncetime;\t/*!< Timer for nonce value expiration */\n\tunsigned long oldnonce;\t/*!< Stale nonce value */\n\tunsigned long nc;\t/*!< incremental  nonce counter */\n\tast_mutex_t notify_lock; /*!< Lock for notifying this session of events */\n\tAST_LIST_HEAD_NOLOCK(mansession_datastores, ast_datastore) datastores; /*!< Data stores on the session */\n\tAST_LIST_ENTRY(mansession_session) list;\n};\n\nenum mansession_message_parsing {\n\tMESSAGE_OKAY,\n\tMESSAGE_LINE_TOO_LONG\n};\n\n/*! \\brief In case you didn't read that giant block of text above the mansession_session struct, the\n * \\ref mansession is named this solely to keep the API the same in Asterisk. This structure really\n * represents data that is different from Manager action to Manager action. The mansession_session pointer\n * contained within points to session-specific data.\n */\nstruct mansession {\n\tstruct mansession_session *session;\n\tstruct ast_iostream *stream;\n\tstruct ast_tcptls_session_instance *tcptls_session;\n\tenum mansession_message_parsing parsing;\n\tunsigned int write_error:1;\n\tstruct manager_custom_hook *hook;\n\tast_mutex_t lock;\n};\n\n/*! Active manager connection sessions container. */\nstatic AO2_GLOBAL_OBJ_STATIC(mgr_sessions);\n\n/*! \\brief user descriptor, as read from the config file.\n *\n * \\note It is still missing some fields -- e.g. we can have multiple permit and deny\n * lines which are not supported here, and readperm/writeperm/writetimeout\n * are not stored.\n */\nstruct ast_manager_user {\n\tchar username[80];\n\tchar *secret;\t\t\t/*!< Secret for logging in */\n\tint readperm;\t\t\t/*!< Authorization for reading */\n\tint writeperm;\t\t\t/*!< Authorization for writing */\n\tint writetimeout;\t\t/*!< Per user Timeout for ast_carefulwrite() */\n\tint displayconnects;\t\t/*!< XXX unused */\n\tint allowmultiplelogin; /*!< Per user option*/\n\tint keep;\t\t\t/*!< mark entries created on a reload */\n\tstruct ao2_container *whitefilters; /*!< Manager event filters - white list */\n\tstruct ao2_container *blackfilters; /*!< Manager event filters - black list */\n\tstruct ast_acl_list *acl;       /*!< ACL setting */\n\tchar *a1_hash;\t\t\t/*!< precalculated A1 for Digest auth */\n\tstruct ast_variable *chanvars;  /*!< Channel variables to set for originate */\n\tAST_RWLIST_ENTRY(ast_manager_user) list;\n};\n\n/*! \\brief list of users found in the config file */\nstatic AST_RWLIST_HEAD_STATIC(users, ast_manager_user);\n\n/*! \\brief list of actions registered */\nstatic AST_RWLIST_HEAD_STATIC(actions, manager_action);\n\n/*! \\brief list of hooks registered */\nstatic AST_RWLIST_HEAD_STATIC(manager_hooks, manager_custom_hook);\n\n#ifdef AST_XML_DOCS\n/*! \\brief A container of event documentation nodes */\nstatic AO2_GLOBAL_OBJ_STATIC(event_docs);\n#endif\n\nstatic int __attribute__((format(printf, 9, 0))) __manager_event_sessions(\n\tstruct ao2_container *sessions,\n\tint category,\n\tconst char *event,\n\tint chancount,\n\tstruct ast_channel **chans,\n\tconst char *file,\n\tint line,\n\tconst char *func,\n\tconst char *fmt,\n\t...);\nstatic enum add_filter_result manager_add_filter(const char *filter_pattern, struct ao2_container *whitefilters, struct ao2_container *blackfilters);\n\nstatic int match_filter(struct mansession *s, char *eventdata);\n\n/*!\n * @{ \\brief Define AMI message types.\n */\nSTASIS_MESSAGE_TYPE_DEFN(ast_manager_get_generic_type);\n/*! @} */\n\n/*!\n * \\internal\n * \\brief Find a registered action object.\n *\n * \\param name Name of AMI action to find.\n *\n * \\return Reffed action found or NULL\n */\nstatic struct manager_action *action_find(const char *name)\n{\n\tstruct manager_action *act;\n\n\tAST_RWLIST_RDLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, act, list) {\n\t\tif (!strcasecmp(name, act->action)) {\n\t\t\tao2_t_ref(act, +1, \"found action object\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&actions);\n\n\treturn act;\n}\n\nstruct stasis_topic *ast_manager_get_topic(void)\n{\n\treturn manager_topic;\n}\n\nstruct stasis_message_router *ast_manager_get_message_router(void)\n{\n\treturn stasis_router;\n}\n\nstatic void manager_json_value_str_append(struct ast_json *value, const char *key,\n\t\t\t\t\t  struct ast_str **res)\n{\n\tswitch (ast_json_typeof(value)) {\n\tcase AST_JSON_STRING:\n\t\tast_str_append(res, 0, \"%s: %s\\r\\n\", key, ast_json_string_get(value));\n\t\tbreak;\n\tcase AST_JSON_INTEGER:\n\t\tast_str_append(res, 0, \"%s: %jd\\r\\n\", key, ast_json_integer_get(value));\n\t\tbreak;\n\tcase AST_JSON_TRUE:\n\t\tast_str_append(res, 0, \"%s: True\\r\\n\", key);\n\t\tbreak;\n\tcase AST_JSON_FALSE:\n\t\tast_str_append(res, 0, \"%s: False\\r\\n\", key);\n\t\tbreak;\n\tdefault:\n\t\tast_str_append(res, 0, \"%s: \\r\\n\", key);\n\t\tbreak;\n\t}\n}\n\nstatic void manager_json_to_ast_str(struct ast_json *obj, const char *key,\n\t\t\t\t    struct ast_str **res, key_exclusion_cb exclusion_cb);\n\nstatic void manager_json_array_with_key(struct ast_json *obj, const char* key,\n\t\t\t\t\tsize_t index, struct ast_str **res,\n\t\t\t\t\tkey_exclusion_cb exclusion_cb)\n{\n\tstruct ast_str *key_str = ast_str_alloca(64);\n\tast_str_set(&key_str, 0, \"%s(%zu)\", key, index);\n\tmanager_json_to_ast_str(obj, ast_str_buffer(key_str),\n\t\t\t\tres, exclusion_cb);\n}\n\nstatic void manager_json_obj_with_key(struct ast_json *obj, const char* key,\n\t\t\t\t      const char *parent_key, struct ast_str **res,\n\t\t\t\t      key_exclusion_cb exclusion_cb)\n{\n\tif (parent_key) {\n\t\tstruct ast_str *key_str = ast_str_alloca(64);\n\t\tast_str_set(&key_str, 0, \"%s/%s\", parent_key, key);\n\t\tmanager_json_to_ast_str(obj, ast_str_buffer(key_str),\n\t\t\t\t\tres, exclusion_cb);\n\t\treturn;\n\t}\n\n\tmanager_json_to_ast_str(obj, key, res, exclusion_cb);\n}\n\nvoid manager_json_to_ast_str(struct ast_json *obj, const char *key,\n\t\t\t     struct ast_str **res, key_exclusion_cb exclusion_cb)\n{\n\tstruct ast_json_iter *i;\n\n\t/* If obj or res is not given, just return */\n\tif (!obj || !res) {\n\t\treturn;\n\t}\n\n\tif (!*res && !(*res = ast_str_create(1024))) {\n\t\treturn;\n\t}\n\n\tif (exclusion_cb && key && exclusion_cb(key)) {\n\t\treturn;\n\t}\n\n\tif (ast_json_typeof(obj) != AST_JSON_OBJECT &&\n\t    ast_json_typeof(obj) != AST_JSON_ARRAY) {\n\t\tmanager_json_value_str_append(obj, key, res);\n\t\treturn;\n\t}\n\n\tif (ast_json_typeof(obj) == AST_JSON_ARRAY) {\n\t\tsize_t j;\n\t\tfor (j = 0; j < ast_json_array_size(obj); ++j) {\n\t\t\tmanager_json_array_with_key(ast_json_array_get(obj, j),\n\t\t\t\t\t\t    key, j, res, exclusion_cb);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = ast_json_object_iter(obj); i;\n\t     i = ast_json_object_iter_next(obj, i)) {\n\t\tmanager_json_obj_with_key(ast_json_object_iter_value(i),\n\t\t\t\t\t  ast_json_object_iter_key(i),\n\t\t\t\t\t  key, res, exclusion_cb);\n\t}\n}\n\nstruct ast_str *ast_manager_str_from_json_object(struct ast_json *blob, key_exclusion_cb exclusion_cb)\n{\n\tstruct ast_str *res = ast_str_create(1024);\n\n\tif (!ast_json_is_null(blob)) {\n\t   manager_json_to_ast_str(blob, NULL, &res, exclusion_cb);\n\t}\n\n\treturn res;\n}\n\n#define manager_event_sessions(sessions, category, event, contents , ...)\t\\\n\t__manager_event_sessions(sessions, category, event, 0, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__, contents , ## __VA_ARGS__)\n\n#define any_manager_listeners(sessions)\t\\\n\t((sessions && ao2_container_count(sessions)) || !AST_RWLIST_EMPTY(&manager_hooks))\n\nstatic void manager_default_msg_cb(void *data, struct stasis_subscription *sub,\n\t\t\t\t    struct stasis_message *message)\n{\n\tstruct ao2_container *sessions;\n\tstruct ast_manager_event_blob *ev;\n\n\tif (!stasis_message_can_be_ami(message)) {\n\t\t/* Not an AMI message; disregard */\n\t\treturn;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!any_manager_listeners(sessions)) {\n\t\t/* Nobody is listening */\n\t\tao2_cleanup(sessions);\n\t\treturn;\n\t}\n\n\tev = stasis_message_to_ami(message);\n\tif (!ev) {\n\t\t/* Conversion failure */\n\t\tao2_cleanup(sessions);\n\t\treturn;\n\t}\n\n\tmanager_event_sessions(sessions, ev->event_flags, ev->manager_event,\n\t\t\"%s\", ev->extra_fields);\n\tao2_ref(ev, -1);\n\tao2_cleanup(sessions);\n}\n\nstatic void manager_generic_msg_cb(void *data, struct stasis_subscription *sub,\n\t\t\t\t    struct stasis_message *message)\n{\n\tstruct ast_json_payload *payload;\n\tint class_type;\n\tconst char *type;\n\tstruct ast_json *event;\n\tstruct ast_str *event_buffer;\n\tstruct ao2_container *sessions;\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!any_manager_listeners(sessions)) {\n\t\t/* Nobody is listening */\n\t\tao2_cleanup(sessions);\n\t\treturn;\n\t}\n\n\tpayload = stasis_message_data(message);\n\tclass_type = ast_json_integer_get(ast_json_object_get(payload->json, \"class_type\"));\n\ttype = ast_json_string_get(ast_json_object_get(payload->json, \"type\"));\n\tevent = ast_json_object_get(payload->json, \"event\");\n\n\tevent_buffer = ast_manager_str_from_json_object(event, NULL);\n\tif (!event_buffer) {\n\t\tast_log(AST_LOG_WARNING, \"Error while creating payload for event %s\\n\", type);\n\t\tao2_cleanup(sessions);\n\t\treturn;\n\t}\n\tmanager_event_sessions(sessions, class_type, type,\n\t\t\"%s\", ast_str_buffer(event_buffer));\n\tast_free(event_buffer);\n\tao2_cleanup(sessions);\n}\n\nvoid ast_manager_publish_event(const char *type, int class_type, struct ast_json *obj)\n{\n\tRAII_VAR(struct ast_json *, event_info, NULL, ast_json_unref);\n\tRAII_VAR(struct ast_json_payload *, payload, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\n\tif (!obj || !ast_manager_get_generic_type()) {\n\t\treturn;\n\t}\n\n\tast_json_ref(obj);\n\tevent_info = ast_json_pack(\"{s: s, s: i, s: o}\",\n\t\t\t\"type\", type,\n\t\t\t\"class_type\", class_type,\n\t\t\t\"event\", obj);\n\tif (!event_info) {\n\t\treturn;\n\t}\n\n\tpayload = ast_json_payload_create(event_info);\n\tif (!payload) {\n\t\treturn;\n\t}\n\tmessage = stasis_message_create(ast_manager_get_generic_type(), payload);\n\tif (!message) {\n\t\treturn;\n\t}\n\tstasis_publish(ast_manager_get_topic(), message);\n}\n\n/*! \\brief Add a custom hook to be called when an event is fired */\nvoid ast_manager_register_hook(struct manager_custom_hook *hook)\n{\n\tAST_RWLIST_WRLOCK(&manager_hooks);\n\tAST_RWLIST_INSERT_TAIL(&manager_hooks, hook, list);\n\tAST_RWLIST_UNLOCK(&manager_hooks);\n}\n\n/*! \\brief Delete a custom hook to be called when an event is fired */\nvoid ast_manager_unregister_hook(struct manager_custom_hook *hook)\n{\n\tAST_RWLIST_WRLOCK(&manager_hooks);\n\tAST_RWLIST_REMOVE(&manager_hooks, hook, list);\n\tAST_RWLIST_UNLOCK(&manager_hooks);\n}\n\nint ast_manager_check_enabled(void)\n{\n\treturn manager_enabled;\n}\n\nint ast_webmanager_check_enabled(void)\n{\n\treturn (webmanager_enabled && manager_enabled);\n}\n\n/*!\n * Grab a reference to the last event, update usecount as needed.\n * Can handle a NULL pointer.\n */\nstatic struct eventqent *grab_last(void)\n{\n\tstruct eventqent *ret;\n\n\tAST_RWLIST_WRLOCK(&all_events);\n\tret = AST_RWLIST_LAST(&all_events);\n\t/* the list is never empty now, but may become so when\n\t * we optimize it in the future, so be prepared.\n\t */\n\tif (ret) {\n\t\tast_atomic_fetchadd_int(&ret->usecount, 1);\n\t}\n\tAST_RWLIST_UNLOCK(&all_events);\n\treturn ret;\n}\n\n/*!\n * Purge unused events. Remove elements from the head\n * as long as their usecount is 0 and there is a next element.\n */\nstatic void purge_events(void)\n{\n\tstruct eventqent *ev;\n\tstruct timeval now = ast_tvnow();\n\n\tAST_RWLIST_WRLOCK(&all_events);\n\twhile ( (ev = AST_RWLIST_FIRST(&all_events)) &&\n\t    ev->usecount == 0 && AST_RWLIST_NEXT(ev, eq_next)) {\n\t\tAST_RWLIST_REMOVE_HEAD(&all_events, eq_next);\n\t\tast_free(ev);\n\t}\n\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&all_events, ev, eq_next) {\n\t\t/* Never release the last event */\n\t\tif (!AST_RWLIST_NEXT(ev, eq_next)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* 2.5 times whatever the HTTP timeout is (maximum 2.5 hours) is the maximum time that we will definitely cache an event */\n\t\tif (ev->usecount == 0 && ast_tvdiff_sec(now, ev->tv) > (httptimeout > 3600 ? 3600 : httptimeout) * 2.5) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(eq_next);\n\t\t\tast_free(ev);\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&all_events);\n}\n\n/*!\n * helper functions to convert back and forth between\n * string and numeric representation of set of flags\n */\nstatic const struct permalias {\n\tint num;\n\tconst char *label;\n} perms[] = {\n\t{ EVENT_FLAG_SYSTEM, \"system\" },\n\t{ EVENT_FLAG_CALL, \"call\" },\n\t{ EVENT_FLAG_LOG, \"log\" },\n\t{ EVENT_FLAG_VERBOSE, \"verbose\" },\n\t{ EVENT_FLAG_COMMAND, \"command\" },\n\t{ EVENT_FLAG_AGENT, \"agent\" },\n\t{ EVENT_FLAG_USER, \"user\" },\n\t{ EVENT_FLAG_CONFIG, \"config\" },\n\t{ EVENT_FLAG_DTMF, \"dtmf\" },\n\t{ EVENT_FLAG_REPORTING, \"reporting\" },\n\t{ EVENT_FLAG_CDR, \"cdr\" },\n\t{ EVENT_FLAG_DIALPLAN, \"dialplan\" },\n\t{ EVENT_FLAG_ORIGINATE, \"originate\" },\n\t{ EVENT_FLAG_AGI, \"agi\" },\n\t{ EVENT_FLAG_CC, \"cc\" },\n\t{ EVENT_FLAG_AOC, \"aoc\" },\n\t{ EVENT_FLAG_TEST, \"test\" },\n\t{ EVENT_FLAG_SECURITY, \"security\" },\n\t{ EVENT_FLAG_MESSAGE, \"message\" },\n\t{ INT_MAX, \"all\" },\n\t{ 0, \"none\" },\n};\n\n/*! Maximum string length of the AMI authority permission string buildable from perms[]. */\n#define MAX_AUTH_PERM_STRING\t150\n\n/*! \\brief Checks to see if a string which can be used to evaluate functions should be rejected */\nstatic int function_capable_string_allowed_with_auths(const char *evaluating, int writepermlist)\n{\n\tif (!(writepermlist & EVENT_FLAG_SYSTEM)\n\t\t&& (\n\t\t\tstrstr(evaluating, \"SHELL\") ||       /* NoOp(${SHELL(rm -rf /)})  */\n\t\t\tstrstr(evaluating, \"EVAL\")           /* NoOp(${EVAL(${some_var_containing_SHELL})}) */\n\t\t)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*! \\brief Convert authority code to a list of options for a user. This will only\n * display those authority codes that have an explicit match on authority */\nstatic const char *user_authority_to_str(int authority, struct ast_str **res)\n{\n\tint i;\n\tchar *sep = \"\";\n\n\tast_str_reset(*res);\n\tfor (i = 0; i < ARRAY_LEN(perms) - 1; i++) {\n\t\tif ((authority & perms[i].num) == perms[i].num) {\n\t\t\tast_str_append(res, 0, \"%s%s\", sep, perms[i].label);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n\n\tif (ast_str_strlen(*res) == 0) {\n\t\t/* replace empty string with something sensible */\n\t\tast_str_append(res, 0, \"<none>\");\n\t}\n\n\treturn ast_str_buffer(*res);\n}\n\n\n/*! \\brief Convert authority code to a list of options. Note that the EVENT_FLAG_ALL\n * authority will always be returned. */\nstatic const char *authority_to_str(int authority, struct ast_str **res)\n{\n\tint i;\n\tchar *sep = \"\";\n\n\tast_str_reset(*res);\n\tif (authority != EVENT_FLAG_SHUTDOWN) {\n\t\tfor (i = 0; i < ARRAY_LEN(perms) - 1; i++) {\n\t\t\tif (authority & perms[i].num) {\n\t\t\t\tast_str_append(res, 0, \"%s%s\", sep, perms[i].label);\n\t\t\t\tsep = \",\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ast_str_strlen(*res) == 0) {\n\t\t/* replace empty string with something sensible */\n\t\tast_str_append(res, 0, \"<none>\");\n\t}\n\n\treturn ast_str_buffer(*res);\n}\n\n/*! Tells you if smallstr exists inside bigstr\n   which is delim by delim and uses no buf or stringsep\n   ast_instring(\"this|that|more\",\"this\",'|') == 1;\n\n   feel free to move this to app.c -anthm */\nstatic int ast_instring(const char *bigstr, const char *smallstr, const char delim)\n{\n\tconst char *val = bigstr, *next;\n\n\tdo {\n\t\tif ((next = strchr(val, delim))) {\n\t\t\tif (!strncmp(val, smallstr, (next - val))) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\treturn !strcmp(smallstr, val);\n\t\t}\n\t} while (*(val = (next + 1)));\n\n\treturn 0;\n}\n\nstatic int get_perm(const char *instr)\n{\n\tint x = 0, ret = 0;\n\n\tif (!instr) {\n\t\treturn 0;\n\t}\n\n\tfor (x = 0; x < ARRAY_LEN(perms); x++) {\n\t\tif (ast_instring(instr, perms[x].label, ',')) {\n\t\t\tret |= perms[x].num;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/*!\n * A number returns itself, false returns 0, true returns all flags,\n * other strings return the flags that are set.\n */\nstatic int strings_to_mask(const char *string)\n{\n\tconst char *p;\n\n\tif (ast_strlen_zero(string)) {\n\t\treturn -1;\n\t}\n\n\tfor (p = string; *p; p++) {\n\t\tif (*p < '0' || *p > '9') {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!*p) { /* all digits */\n\t\treturn atoi(string);\n\t}\n\tif (ast_false(string)) {\n\t\treturn 0;\n\t}\n\tif (ast_true(string)) {\t/* all permissions */\n\t\tint x, ret = 0;\n\t\tfor (x = 0; x < ARRAY_LEN(perms); x++) {\n\t\t\tret |= perms[x].num;\n\t\t}\n\t\treturn ret;\n\t}\n\treturn get_perm(string);\n}\n\n/*! \\brief Unreference manager session object.\n     If no more references, then go ahead and delete it */\nstatic struct mansession_session *unref_mansession(struct mansession_session *s)\n{\n\tint refcount = ao2_ref(s, -1);\n\tif (manager_debug) {\n\t\tast_debug(1, \"Mansession: %p refcount now %d\\n\", s, refcount - 1);\n\t}\n\treturn NULL;\n}\n\nstatic void event_filter_destructor(void *obj)\n{\n\tregex_t *regex_filter = obj;\n\tregfree(regex_filter);\n}\n\nstatic void session_destructor(void *obj)\n{\n\tstruct mansession_session *session = obj;\n\tstruct eventqent *eqe = session->last_ev;\n\tstruct ast_datastore *datastore;\n\n\t/* Get rid of each of the data stores on the session */\n\twhile ((datastore = AST_LIST_REMOVE_HEAD(&session->datastores, entry))) {\n\t\t/* Free the data store */\n\t\tast_datastore_free(datastore);\n\t}\n\n\tif (eqe) {\n\t\tast_atomic_fetchadd_int(&eqe->usecount, -1);\n\t}\n\tif (session->chanvars) {\n\t\tast_variables_destroy(session->chanvars);\n\t}\n\n\tif (session->whitefilters) {\n\t\tao2_t_ref(session->whitefilters, -1, \"decrement ref for white container, should be last one\");\n\t}\n\n\tif (session->blackfilters) {\n\t\tao2_t_ref(session->blackfilters, -1, \"decrement ref for black container, should be last one\");\n\t}\n\n\tast_mutex_destroy(&session->notify_lock);\n}\n\n/*! \\brief Allocate manager session structure and add it to the list of sessions */\nstatic struct mansession_session *build_mansession(const struct ast_sockaddr *addr)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *newsession;\n\n\tnewsession = ao2_alloc(sizeof(*newsession), session_destructor);\n\tif (!newsession) {\n\t\treturn NULL;\n\t}\n\n\tnewsession->whitefilters = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, NULL);\n\tnewsession->blackfilters = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, NULL);\n\tif (!newsession->whitefilters || !newsession->blackfilters) {\n\t\tao2_ref(newsession, -1);\n\t\treturn NULL;\n\t}\n\n\tnewsession->waiting_thread = AST_PTHREADT_NULL;\n\tnewsession->writetimeout = 100;\n\tnewsession->send_events = -1;\n\tast_sockaddr_copy(&newsession->addr, addr);\n\n\tast_mutex_init(&newsession->notify_lock);\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (sessions) {\n\t\tao2_link(sessions, newsession);\n\t\tao2_ref(sessions, -1);\n\t}\n\n\treturn newsession;\n}\n\nstatic int mansession_cmp_fn(void *obj, void *arg, int flags)\n{\n\tstruct mansession_session *s = obj;\n\tchar *str = arg;\n\treturn !strcasecmp(s->username, str) ? CMP_MATCH : 0;\n}\n\nstatic void session_destroy(struct mansession_session *s)\n{\n\tstruct ao2_container *sessions;\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (sessions) {\n\t\tao2_unlink(sessions, s);\n\t\tao2_ref(sessions, -1);\n\t}\n\tunref_mansession(s);\n}\n\n\nstatic int check_manager_session_inuse(const char *name)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *session;\n\tint inuse = 0;\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (sessions) {\n\t\tsession = ao2_find(sessions, (char *) name, 0);\n\t\tao2_ref(sessions, -1);\n\t\tif (session) {\n\t\t\tunref_mansession(session);\n\t\t\tinuse = 1;\n\t\t}\n\t}\n\treturn inuse;\n}\n\n\n/*!\n * lookup an entry in the list of registered users.\n * must be called with the list lock held.\n */\nstatic struct ast_manager_user *get_manager_by_name_locked(const char *name)\n{\n\tstruct ast_manager_user *user = NULL;\n\n\tAST_RWLIST_TRAVERSE(&users, user, list) {\n\t\tif (!strcasecmp(user->username, name)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn user;\n}\n\n/*! \\brief Get displayconnects config option.\n *  \\param session manager session to get parameter from.\n *  \\return displayconnects config option value.\n */\nstatic int manager_displayconnects(struct mansession_session *session)\n{\n\tstruct ast_manager_user *user = NULL;\n\tint ret = 0;\n\n\tAST_RWLIST_RDLOCK(&users);\n\tif ((user = get_manager_by_name_locked(session->username))) {\n\t\tret = user->displayconnects;\n\t}\n\tAST_RWLIST_UNLOCK(&users);\n\n\treturn ret;\n}\n\n#ifdef AST_XML_DOCS\nstatic void print_event_instance(struct ast_cli_args *a, struct ast_xml_doc_item *instance);\n#endif\n\nstatic char *handle_showmancmd(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct manager_action *cur;\n\tstruct ast_str *authority;\n\tint num;\n\tint l;\n\tconst char *auth_str;\n#ifdef AST_XML_DOCS\n\tchar syntax_title[64], description_title[64], synopsis_title[64], seealso_title[64];\n\tchar arguments_title[64], privilege_title[64], final_response_title[64], list_responses_title[64];\n#endif\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show command\";\n\t\te->usage =\n\t\t\t\"Usage: manager show command <actionname> [<actionname> [<actionname> [...]]]\\n\"\n\t\t\t\"\tShows the detailed description for a specific Asterisk manager interface command.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tl = strlen(a->word);\n\t\tAST_RWLIST_RDLOCK(&actions);\n\t\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\t\tif (!strncasecmp(a->word, cur->action, l)) {\n\t\t\t\tif (ast_cli_completion_add(ast_strdup(cur->action))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAST_RWLIST_UNLOCK(&actions);\n\t\treturn NULL;\n\t}\n\tif (a->argc < 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tauthority = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\n#ifdef AST_XML_DOCS\n\t/* setup the titles */\n\tterm_color(synopsis_title, \"[Synopsis]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(description_title, \"[Description]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(syntax_title, \"[Syntax]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(seealso_title, \"[See Also]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(arguments_title, \"[Arguments]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(privilege_title, \"[Privilege]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(final_response_title, \"[Final Response]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(list_responses_title, \"[List Responses]\\n\", COLOR_MAGENTA, 0, 40);\n#endif\n\n\tAST_RWLIST_RDLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tfor (num = 3; num < a->argc; num++) {\n\t\t\tif (!strcasecmp(cur->action, a->argv[num])) {\n\t\t\t\tauth_str = authority_to_str(cur->authority, &authority);\n\n#ifdef AST_XML_DOCS\n\t\t\t\tif (cur->docsrc == AST_XML_DOC) {\n\t\t\t\t\tchar *syntax = ast_xmldoc_printable(S_OR(cur->syntax, \"Not available\"), 1);\n\t\t\t\t\tchar *synopsis = ast_xmldoc_printable(S_OR(cur->synopsis, \"Not available\"), 1);\n\t\t\t\t\tchar *description = ast_xmldoc_printable(S_OR(cur->description, \"Not available\"), 1);\n\t\t\t\t\tchar *arguments = ast_xmldoc_printable(S_OR(cur->arguments, \"Not available\"), 1);\n\t\t\t\t\tchar *seealso = ast_xmldoc_printable(S_OR(cur->seealso, \"Not available\"), 1);\n\t\t\t\t\tchar *privilege = ast_xmldoc_printable(S_OR(auth_str, \"Not available\"), 1);\n\t\t\t\t\tchar *responses = ast_xmldoc_printable(\"None\", 1);\n\n\t\t\t\t\tif (!syntax || !synopsis || !description || !arguments\n\t\t\t\t\t\t\t|| !seealso || !privilege || !responses) {\n\t\t\t\t\t\tast_free(syntax);\n\t\t\t\t\t\tast_free(synopsis);\n\t\t\t\t\t\tast_free(description);\n\t\t\t\t\t\tast_free(arguments);\n\t\t\t\t\t\tast_free(seealso);\n\t\t\t\t\t\tast_free(privilege);\n\t\t\t\t\t\tast_free(responses);\n\t\t\t\t\t\tast_cli(a->fd, \"Allocation failure.\\n\");\n\t\t\t\t\t\tAST_RWLIST_UNLOCK(&actions);\n\n\t\t\t\t\t\treturn CLI_FAILURE;\n\t\t\t\t\t}\n\n\t\t\t\t\tast_cli(a->fd, \"%s%s\\n\\n%s%s\\n\\n%s%s\\n\\n%s%s\\n\\n%s%s\\n\\n%s%s\\n\\n%s\",\n\t\t\t\t\t\tsyntax_title, syntax,\n\t\t\t\t\t\tsynopsis_title, synopsis,\n\t\t\t\t\t\tdescription_title, description,\n\t\t\t\t\t\targuments_title, arguments,\n\t\t\t\t\t\tseealso_title, seealso,\n\t\t\t\t\t\tprivilege_title, privilege,\n\t\t\t\t\t\tlist_responses_title);\n\n\t\t\t\t\tif (!cur->list_responses) {\n\t\t\t\t\t\tast_cli(a->fd, \"%s\\n\\n\", responses);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstruct ast_xml_doc_item *temp;\n\t\t\t\t\t\tfor (temp = cur->list_responses; temp; temp = AST_LIST_NEXT(temp, next)) {\n\t\t\t\t\t\t\tast_cli(a->fd, \"Event: %s\\n\", temp->name);\n\t\t\t\t\t\t\tprint_event_instance(a, temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tast_cli(a->fd, \"%s\", final_response_title);\n\n\t\t\t\t\tif (!cur->final_response) {\n\t\t\t\t\t\tast_cli(a->fd, \"%s\\n\\n\", responses);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_cli(a->fd, \"Event: %s\\n\", cur->final_response->name);\n\t\t\t\t\t\tprint_event_instance(a, cur->final_response);\n\t\t\t\t\t}\n\n\t\t\t\t\tast_free(syntax);\n\t\t\t\t\tast_free(synopsis);\n\t\t\t\t\tast_free(description);\n\t\t\t\t\tast_free(arguments);\n\t\t\t\t\tast_free(seealso);\n\t\t\t\t\tast_free(privilege);\n\t\t\t\t\tast_free(responses);\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tast_cli(a->fd, \"Action: %s\\nSynopsis: %s\\nPrivilege: %s\\n%s\\n\",\n\t\t\t\t\t\tcur->action, cur->synopsis,\n\t\t\t\t\t\tauth_str,\n\t\t\t\t\t\tS_OR(cur->description, \"\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&actions);\n\n\treturn CLI_SUCCESS;\n}\n\nstatic char *handle_mandebug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager set debug [on|off]\";\n\t\te->usage = \"Usage: manager set debug [on|off]\\n\tShow, enable, disable debugging of the manager code.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc == 3) {\n\t\tast_cli(a->fd, \"manager debug is %s\\n\", manager_debug? \"on\" : \"off\");\n\t} else if (a->argc == 4) {\n\t\tif (!strcasecmp(a->argv[3], \"on\")) {\n\t\t\tmanager_debug = 1;\n\t\t} else if (!strcasecmp(a->argv[3], \"off\")) {\n\t\t\tmanager_debug = 0;\n\t\t} else {\n\t\t\treturn CLI_SHOWUSAGE;\n\t\t}\n\t}\n\treturn CLI_SUCCESS;\n}\n\nstatic char *handle_showmanager(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_manager_user *user = NULL;\n\tint l;\n\tstruct ast_str *rauthority = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\tstruct ast_str *wauthority = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\tstruct ast_variable *v;\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show user\";\n\t\te->usage =\n\t\t\t\" Usage: manager show user <user>\\n\"\n\t\t\t\"        Display all information related to the manager user specified.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tl = strlen(a->word);\n\t\tif (a->pos != 3) {\n\t\t\treturn NULL;\n\t\t}\n\t\tAST_RWLIST_RDLOCK(&users);\n\t\tAST_RWLIST_TRAVERSE(&users, user, list) {\n\t\t\tif (!strncasecmp(a->word, user->username, l)) {\n\t\t\t\tif (ast_cli_completion_add(ast_strdup(user->username))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\treturn NULL;\n\t}\n\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tAST_RWLIST_RDLOCK(&users);\n\n\tif (!(user = get_manager_by_name_locked(a->argv[3]))) {\n\t\tast_cli(a->fd, \"There is no manager called %s\\n\", a->argv[3]);\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tast_cli(a->fd, \"\\n\");\n\tast_cli(a->fd,\n\t\t\"          username: %s\\n\"\n\t\t\"            secret: %s\\n\"\n\t\t\"               ACL: %s\\n\"\n\t\t\"         read perm: %s\\n\"\n\t\t\"        write perm: %s\\n\"\n\t\t\"   displayconnects: %s\\n\"\n\t\t\"allowmultiplelogin: %s\\n\",\n\t\tS_OR(user->username, \"(N/A)\"),\n\t\t(user->secret ? \"<Set>\" : \"(N/A)\"),\n\t\t((user->acl && !ast_acl_list_is_empty(user->acl)) ? \"yes\" : \"no\"),\n\t\tuser_authority_to_str(user->readperm, &rauthority),\n\t\tuser_authority_to_str(user->writeperm, &wauthority),\n\t\t(user->displayconnects ? \"yes\" : \"no\"),\n\t\t(user->allowmultiplelogin ? \"yes\" : \"no\"));\n\tast_cli(a->fd, \"         Variables: \\n\");\n\t\tfor (v = user->chanvars ; v ; v = v->next) {\n\t\t\tast_cli(a->fd, \"                 %s = %s\\n\", v->name, v->value);\n\t\t}\n\tif (!ast_acl_list_is_empty(user->acl)) {\n\t\tast_acl_output(a->fd, user->acl, NULL);\n\t}\n\n\tAST_RWLIST_UNLOCK(&users);\n\n\treturn CLI_SUCCESS;\n}\n\nstatic char *handle_showmanagers(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_manager_user *user = NULL;\n\tint count_amu = 0;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show users\";\n\t\te->usage =\n\t\t\t\"Usage: manager show users\\n\"\n\t\t\t\"       Prints a listing of all managers that are currently configured on that\\n\"\n\t\t\t\" system.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tAST_RWLIST_RDLOCK(&users);\n\n\t/* If there are no users, print out something along those lines */\n\tif (AST_RWLIST_EMPTY(&users)) {\n\t\tast_cli(a->fd, \"There are no manager users.\\n\");\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tast_cli(a->fd, \"\\nusername\\n--------\\n\");\n\n\tAST_RWLIST_TRAVERSE(&users, user, list) {\n\t\tast_cli(a->fd, \"%s\\n\", user->username);\n\t\tcount_amu++;\n\t}\n\n\tAST_RWLIST_UNLOCK(&users);\n\n\tast_cli(a->fd,\"-------------------\\n\"\n\t\t      \"%d manager users configured.\\n\", count_amu);\n\treturn CLI_SUCCESS;\n}\n\n/*! \\brief  CLI command  manager list commands */\nstatic char *handle_showmancmds(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct manager_action *cur;\n\tint name_len = 1;\n\tint space_remaining;\n#define HSMC_FORMAT \"  %-*.*s  %-.*s\\n\"\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show commands\";\n\t\te->usage =\n\t\t\t\"Usage: manager show commands\\n\"\n\t\t\t\"\tPrints a listing of all the available Asterisk manager interface commands.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tAST_RWLIST_RDLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tint incoming_len = strlen(cur->action);\n\t\tif (incoming_len > name_len) {\n\t\t\tname_len = incoming_len;\n\t\t}\n\t}\n\n\tspace_remaining = MGR_SHOW_TERMINAL_WIDTH - name_len - 4;\n\tif (space_remaining < 0) {\n\t\tspace_remaining = 0;\n\t}\n\n\tast_cli(a->fd, HSMC_FORMAT, name_len, name_len, \"Action\", space_remaining, \"Synopsis\");\n\tast_cli(a->fd, HSMC_FORMAT, name_len, name_len, \"------\", space_remaining, \"--------\");\n\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tast_cli(a->fd, HSMC_FORMAT, name_len, name_len, cur->action, space_remaining, cur->synopsis);\n\t}\n\tAST_RWLIST_UNLOCK(&actions);\n\n\treturn CLI_SUCCESS;\n}\n\n/*! \\brief CLI command manager list connected */\nstatic char *handle_showmanconn(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *session;\n\ttime_t now = time(NULL);\n#define HSMCONN_FORMAT1 \"  %-15.15s  %-55.55s  %-10.10s  %-10.10s  %-8.8s  %-8.8s  %-10.10s  %-10.10s\\n\"\n#define HSMCONN_FORMAT2 \"  %-15.15s  %-55.55s  %-10d  %-10d  %-8d  %-8d  %-10.10d  %-10.10d\\n\"\n\tint count = 0;\n\tstruct ao2_iterator i;\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show connected\";\n\t\te->usage =\n\t\t\t\"Usage: manager show connected\\n\"\n\t\t\t\"\tPrints a listing of the users that are currently connected to the\\n\"\n\t\t\t\"Asterisk manager interface.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tast_cli(a->fd, HSMCONN_FORMAT1, \"Username\", \"IP Address\", \"Start\", \"Elapsed\", \"FileDes\", \"HttpCnt\", \"ReadPerms\", \"WritePerms\");\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (sessions) {\n\t\ti = ao2_iterator_init(sessions, 0);\n\t\tao2_ref(sessions, -1);\n\t\twhile ((session = ao2_iterator_next(&i))) {\n\t\t\tao2_lock(session);\n\t\t\tast_cli(a->fd, HSMCONN_FORMAT2, session->username,\n\t\t\t\tast_sockaddr_stringify_addr(&session->addr),\n\t\t\t\t(int) (session->sessionstart),\n\t\t\t\t(int) (now - session->sessionstart),\n\t\t\t\tsession->stream ? ast_iostream_get_fd(session->stream) : -1,\n\t\t\t\tsession->inuse,\n\t\t\t\tsession->readperm,\n\t\t\t\tsession->writeperm);\n\t\t\tcount++;\n\t\t\tao2_unlock(session);\n\t\t\tunref_mansession(session);\n\t\t}\n\t\tao2_iterator_destroy(&i);\n\t}\n\tast_cli(a->fd, \"%d users connected.\\n\", count);\n\n\treturn CLI_SUCCESS;\n}\n\n/*! \\brief CLI command manager list eventq */\n/* Should change to \"manager show connected\" */\nstatic char *handle_showmaneventq(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct eventqent *s;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show eventq\";\n\t\te->usage =\n\t\t\t\"Usage: manager show eventq\\n\"\n\t\t\t\"\tPrints a listing of all events pending in the Asterisk manger\\n\"\n\t\t\t\"event queue.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tAST_RWLIST_RDLOCK(&all_events);\n\tAST_RWLIST_TRAVERSE(&all_events, s, eq_next) {\n\t\tast_cli(a->fd, \"Usecount: %d\\n\", s->usecount);\n\t\tast_cli(a->fd, \"Category: %d\\n\", s->category);\n\t\tast_cli(a->fd, \"Event:\\n%s\", s->eventdata);\n\t}\n\tAST_RWLIST_UNLOCK(&all_events);\n\n\treturn CLI_SUCCESS;\n}\n\nstatic int reload_module(void);\n\n/*! \\brief CLI command manager reload */\nstatic char *handle_manager_reload(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager reload\";\n\t\te->usage =\n\t\t\t\"Usage: manager reload\\n\"\n\t\t\t\"       Reloads the manager configuration.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc > 2) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\treload_module();\n\treturn CLI_SUCCESS;\n}\n\nstatic struct eventqent *advance_event(struct eventqent *e)\n{\n\tstruct eventqent *next;\n\n\tAST_RWLIST_RDLOCK(&all_events);\n\tif ((next = AST_RWLIST_NEXT(e, eq_next))) {\n\t\tast_atomic_fetchadd_int(&next->usecount, 1);\n\t\tast_atomic_fetchadd_int(&e->usecount, -1);\n\t}\n\tAST_RWLIST_UNLOCK(&all_events);\n\treturn next;\n}\n\n#define\tGET_HEADER_FIRST_MATCH\t0\n#define\tGET_HEADER_LAST_MATCH\t1\n#define\tGET_HEADER_SKIP_EMPTY\t2\n\n/*!\n * \\brief Return a matching header value.\n *\n * \\details\n * Generic function to return either the first or the last\n * matching header from a list of variables, possibly skipping\n * empty strings.\n *\n * \\note At the moment there is only one use of this function in\n * this file, so we make it static.\n *\n * \\note Never returns NULL.\n */\nstatic const char *__astman_get_header(const struct message *m, char *var, int mode)\n{\n\tint x, l = strlen(var);\n\tconst char *result = \"\";\n\n\tif (!m) {\n\t\treturn result;\n\t}\n\n\tfor (x = 0; x < m->hdrcount; x++) {\n\t\tconst char *h = m->headers[x];\n\t\tif (!strncasecmp(var, h, l) && h[l] == ':') {\n\t\t\tconst char *value = h + l + 1;\n\t\t\tvalue = ast_skip_blanks(value); /* ignore leading spaces in the value */\n\t\t\t/* found a potential candidate */\n\t\t\tif ((mode & GET_HEADER_SKIP_EMPTY) && ast_strlen_zero(value)) {\n\t\t\t\tcontinue;\t/* not interesting */\n\t\t\t}\n\t\t\tif (mode & GET_HEADER_LAST_MATCH) {\n\t\t\t\tresult = value;\t/* record the last match so far */\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*!\n * \\brief Return the first matching variable from an array.\n *\n * \\note This is the legacy function and is implemented in\n * therms of __astman_get_header().\n *\n * \\note Never returns NULL.\n */\nconst char *astman_get_header(const struct message *m, char *var)\n{\n\treturn __astman_get_header(m, var, GET_HEADER_FIRST_MATCH);\n}\n\n/*!\n * \\brief Append additional headers into the message structure from params.\n *\n * \\note You likely want to initialize m->hdrcount to 0 before calling this.\n */\nstatic void astman_append_headers(struct message *m, const struct ast_variable *params)\n{\n\tconst struct ast_variable *v;\n\n\tfor (v = params; v && m->hdrcount < ARRAY_LEN(m->headers); v = v->next) {\n\t\tif (ast_asprintf((char**)&m->headers[m->hdrcount], \"%s: %s\", v->name, v->value) > -1) {\n\t\t\t++m->hdrcount;\n\t\t}\n\t}\n}\n\n/*!\n * \\brief Free headers inside message structure, but not the message structure itself.\n */\nstatic void astman_free_headers(struct message *m)\n{\n\twhile (m->hdrcount) {\n\t\t--m->hdrcount;\n\t\tast_free((void *) m->headers[m->hdrcount]);\n\t\tm->headers[m->hdrcount] = NULL;\n\t}\n}\n\n/*!\n * \\internal\n * \\brief Process one \"Variable:\" header value string.\n *\n * \\param head Current list of AMI variables to get new values added.\n * \\param hdr_val Header value string to process.\n *\n * \\return New variable list head.\n */\nstatic struct ast_variable *man_do_variable_value(struct ast_variable *head, const char *hdr_val)\n{\n\tchar *parse;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(vars)[64];\n\t);\n\n\thdr_val = ast_skip_blanks(hdr_val); /* ignore leading spaces in the value */\n\tparse = ast_strdupa(hdr_val);\n\n\t/* Break the header value string into name=val pair items. */\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (args.argc) {\n\t\tint y;\n\n\t\t/* Process each name=val pair item. */\n\t\tfor (y = 0; y < args.argc; y++) {\n\t\t\tstruct ast_variable *cur;\n\t\t\tchar *var;\n\t\t\tchar *val;\n\n\t\t\tif (!args.vars[y]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar = val = args.vars[y];\n\t\t\tstrsep(&val, \"=\");\n\n\t\t\t/* XXX We may wish to trim whitespace from the strings. */\n\t\t\tif (!val || ast_strlen_zero(var)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Create new variable list node and prepend it to the list. */\n\t\t\tcur = ast_variable_new(var, val, \"\");\n\t\t\tif (cur) {\n\t\t\t\tcur->next = head;\n\t\t\t\thead = cur;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn head;\n}\n\nstruct ast_variable *astman_get_variables(const struct message *m)\n{\n\treturn astman_get_variables_order(m, ORDER_REVERSE);\n}\n\nstruct ast_variable *astman_get_variables_order(const struct message *m,\n\tenum variable_orders order)\n{\n\tint varlen;\n\tint x;\n\tstruct ast_variable *head = NULL;\n\n\tstatic const char var_hdr[] = \"Variable:\";\n\n\t/* Process all \"Variable:\" headers. */\n\tvarlen = strlen(var_hdr);\n\tfor (x = 0; x < m->hdrcount; x++) {\n\t\tif (strncasecmp(var_hdr, m->headers[x], varlen)) {\n\t\t\tcontinue;\n\t\t}\n\t\thead = man_do_variable_value(head, m->headers[x] + varlen);\n\t}\n\n\tif (order == ORDER_NATURAL) {\n\t\thead = ast_variables_reverse(head);\n\t}\n\n\treturn head;\n}\n\n/*! \\brief access for hooks to send action messages to ami */\nint ast_hook_send_action(struct manager_custom_hook *hook, const char *msg)\n{\n\tconst char *action;\n\tint ret = 0;\n\tstruct manager_action *act_found;\n\tstruct mansession s = {.session = NULL, };\n\tstruct message m = { 0 };\n\tchar *dup_str;\n\tchar *src;\n\tint x = 0;\n\tint curlen;\n\n\tif (hook == NULL) {\n\t\treturn -1;\n\t}\n\n\t/* Create our own copy of the AMI action msg string. */\n\tsrc = dup_str = ast_strdup(msg);\n\tif (!dup_str) {\n\t\treturn -1;\n\t}\n\n\t/* convert msg string to message struct */\n\tcurlen = strlen(src);\n\tfor (x = 0; x < curlen; x++) {\n\t\tint cr;\t/* set if we have \\r */\n\t\tif (src[x] == '\\r' && x+1 < curlen && src[x+1] == '\\n')\n\t\t\tcr = 2;\t/* Found. Update length to include \\r\\n */\n\t\telse if (src[x] == '\\n')\n\t\t\tcr = 1;\t/* also accept \\n only */\n\t\telse\n\t\t\tcontinue;\n\t\t/* don't keep empty lines */\n\t\tif (x && m.hdrcount < ARRAY_LEN(m.headers)) {\n\t\t\t/* ... but trim \\r\\n and terminate the header string */\n\t\t\tsrc[x] = '\\0';\n\t\t\tm.headers[m.hdrcount++] = src;\n\t\t}\n\t\tx += cr;\n\t\tcurlen -= x;\t\t/* remaining size */\n\t\tsrc += x;\t\t/* update pointer */\n\t\tx = -1;\t\t\t/* reset loop */\n\t}\n\n\taction = astman_get_header(&m, \"Action\");\n\n\tdo {\n\t\tif (!strcasecmp(action, \"login\")) {\n\t\t\tbreak;\n\t\t}\n\n\t\tact_found = action_find(action);\n\t\tif (!act_found) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * we have to simulate a session for this action request\n\t\t * to be able to pass it down for processing\n\t\t * This is necessary to meet the previous design of manager.c\n\t\t */\n\t\ts.hook = hook;\n\n\t\tret = -1;\n\t\tao2_lock(act_found);\n\t\tif (act_found->registered && act_found->func) {\n\t\t\tstruct ast_module *mod_ref = ast_module_running_ref(act_found->module);\n\n\t\t\tao2_unlock(act_found);\n\t\t\t/* If the action is in a module it must be running. */\n\t\t\tif (!act_found->module || mod_ref) {\n\t\t\t\tret = act_found->func(&s, &m);\n\t\t\t\tast_module_unref(mod_ref);\n\t\t\t}\n\t\t} else {\n\t\t\tao2_unlock(act_found);\n\t\t}\n\t\tao2_t_ref(act_found, -1, \"done with found action object\");\n\t} while (0);\n\n\tast_free(dup_str);\n\treturn ret;\n}\n\n/*!\n * helper function to send a string to the socket.\n * Return -1 on error (e.g. buffer full).\n */\nstatic int send_string(struct mansession *s, char *string)\n{\n\tstruct ast_iostream *stream;\n\tint len, res;\n\n\t/* It's a result from one of the hook's action invocation */\n\tif (s->hook) {\n\t\t/*\n\t\t * to send responses, we're using the same function\n\t\t * as for receiving events. We call the event \"HookResponse\"\n\t\t */\n\t\ts->hook->helper(EVENT_FLAG_HOOKRESPONSE, \"HookResponse\", string);\n\t\treturn 0;\n\t}\n\n\tstream = s->stream ? s->stream : s->session->stream;\n\n\tlen = strlen(string);\n\tast_iostream_set_timeout_inactivity(stream, s->session->writetimeout);\n\tres = ast_iostream_write(stream, string, len);\n\tast_iostream_set_timeout_disable(stream);\n\n\tif (res < len) {\n\t\ts->write_error = 1;\n\t}\n\n\treturn res;\n}\n\n/*!\n * \\brief thread local buffer for astman_append\n *\n * \\note This can not be defined within the astman_append() function\n *       because it declares a couple of functions that get used to\n *       initialize the thread local storage key.\n */\nAST_THREADSTORAGE(astman_append_buf);\n\nAST_THREADSTORAGE(userevent_buf);\n\n/*! \\brief initial allocated size for the astman_append_buf and astman_send_*_va */\n#define ASTMAN_APPEND_BUF_INITSIZE   256\n\nstatic void astman_flush(struct mansession *s, struct ast_str *buf)\n{\n\tif (s->hook || (s->tcptls_session && s->tcptls_session->stream)) {\n\t\tsend_string(s, ast_str_buffer(buf));\n\t} else {\n\t\tast_verbose(\"No connection stream in astman_append, should not happen\\n\");\n\t}\n}\n\n/*!\n * utility functions for creating AMI replies\n */\nvoid astman_append(struct mansession *s, const char *fmt, ...)\n{\n\tint res;\n\tva_list ap;\n\tstruct ast_str *buf;\n\n\tif (!(buf = ast_str_thread_get(&astman_append_buf, ASTMAN_APPEND_BUF_INITSIZE))) {\n\t\treturn;\n\t}\n\n\tva_start(ap, fmt);\n\tres = ast_str_set_va(&buf, 0, fmt, ap);\n\tva_end(ap);\n\tif (res == AST_DYNSTR_BUILD_FAILED) {\n\t\treturn;\n\t}\n\n\tif (s->hook || (s->tcptls_session != NULL && s->tcptls_session->stream != NULL)) {\n\t\tsend_string(s, ast_str_buffer(buf));\n\t} else {\n\t\tast_verbose(\"No connection stream in astman_append, should not happen\\n\");\n\t}\n}\n\n/*! \\note NOTE: XXX this comment is unclear and possibly wrong.\n   Callers of astman_send_error(), astman_send_response() or astman_send_ack() must EITHER\n   hold the session lock _or_ be running in an action callback (in which case s->session->busy will\n   be non-zero). In either of these cases, there is no need to lock-protect the session's\n   fd, since no other output will be sent (events will be queued), and no input will\n   be read until either the current action finishes or get_input() obtains the session\n   lock.\n */\n\n/*! \\todo XXX MSG_MOREDATA should go to a header file. */\n#define MSG_MOREDATA\t((char *)astman_send_response)\n\n/*! \\brief send a response with an optional message,\n * and terminate it with an empty line.\n * m is used only to grab the 'ActionID' field.\n *\n * Use the explicit constant MSG_MOREDATA to remove the empty line.\n * XXX MSG_MOREDATA should go to a header file.\n */\nstatic void astman_send_response_full(struct mansession *s, const struct message *m, char *resp, char *msg, char *listflag)\n{\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tstruct ast_str *buf;\n\n\tbuf = ast_str_thread_get(&astman_append_buf, ASTMAN_APPEND_BUF_INITSIZE);\n\tif (!buf) {\n\t\treturn;\n\t}\n\n\tast_str_set(&buf, 0, \"Response: %s\\r\\n\", resp);\n\n\tif (!ast_strlen_zero(id)) {\n\t\tast_str_append(&buf, 0, \"ActionID: %s\\r\\n\", id);\n\t}\n\n\tif (listflag) {\n\t\t/* Start, complete, cancelled */\n\t\tast_str_append(&buf, 0, \"EventList: %s\\r\\n\", listflag);\n\t}\n\n\tif (msg != MSG_MOREDATA) {\n\t\tif (msg) {\n\t\t\tast_str_append(&buf, 0, \"Message: %s\\r\\n\", msg);\n\t\t}\n\t\tast_str_append(&buf, 0, \"\\r\\n\");\n\t}\n\n\tastman_flush(s, buf);\n}\n\nvoid astman_send_response(struct mansession *s, const struct message *m, char *resp, char *msg)\n{\n\tastman_send_response_full(s, m, resp, msg, NULL);\n}\n\nvoid astman_send_error(struct mansession *s, const struct message *m, char *error)\n{\n\tastman_send_response_full(s, m, \"Error\", error, NULL);\n}\n\nvoid astman_send_error_va(struct mansession *s, const struct message *m, const char *fmt, ...)\n{\n\tint res;\n\tva_list ap;\n\tstruct ast_str *buf;\n\tchar *msg;\n\n\tif (!(buf = ast_str_thread_get(&astman_append_buf, ASTMAN_APPEND_BUF_INITSIZE))) {\n\t\treturn;\n\t}\n\n\tva_start(ap, fmt);\n\tres = ast_str_set_va(&buf, 0, fmt, ap);\n\tva_end(ap);\n\tif (res == AST_DYNSTR_BUILD_FAILED) {\n\t\treturn;\n\t}\n\n\t/* astman_append will use the same underlying buffer, so copy the message out\n\t * before sending the response */\n\tmsg = ast_str_buffer(buf);\n\tif (msg) {\n\t\tmsg = ast_strdupa(msg);\n\t}\n\tastman_send_response_full(s, m, \"Error\", msg, NULL);\n}\n\nvoid astman_send_ack(struct mansession *s, const struct message *m, char *msg)\n{\n\tastman_send_response_full(s, m, \"Success\", msg, NULL);\n}\n\nstatic void astman_start_ack(struct mansession *s, const struct message *m)\n{\n\tastman_send_response_full(s, m, \"Success\", MSG_MOREDATA, NULL);\n}\n\nvoid astman_send_listack(struct mansession *s, const struct message *m, char *msg, char *listflag)\n{\n\tastman_send_response_full(s, m, \"Success\", msg, listflag);\n}\n\nstatic struct ast_str *astman_send_list_complete_start_common(struct mansession *s, const struct message *m, const char *event_name, int count)\n{\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tstruct ast_str *buf;\n\n\tbuf = ast_str_thread_get(&astman_append_buf, ASTMAN_APPEND_BUF_INITSIZE);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tast_str_set(&buf, 0, \"Event: %s\\r\\n\", event_name);\n\tif (!ast_strlen_zero(id)) {\n\t\tast_str_append(&buf, 0, \"ActionID: %s\\r\\n\", id);\n\t}\n\tast_str_append(&buf, 0,\n\t\t\"EventList: Complete\\r\\n\"\n\t\t\"ListItems: %d\\r\\n\",\n\t\tcount);\n\n\treturn buf;\n}\n\nstatic void astman_send_list_complete(struct mansession *s, const struct message *m, const char *event_name, int count)\n{\n\tstruct ast_str *buf = astman_send_list_complete_start_common(s, m, event_name, count);\n\tif (buf) {\n\t\tast_str_append(&buf, 0, \"\\r\\n\");\n\t\tastman_flush(s, buf);\n\t}\n}\n\nvoid astman_send_list_complete_start(struct mansession *s, const struct message *m, const char *event_name, int count)\n{\n\tstruct ast_str *buf = astman_send_list_complete_start_common(s, m, event_name, count);\n\tif (buf) {\n\t\tastman_flush(s, buf);\n\t}\n}\n\nvoid astman_send_list_complete_end(struct mansession *s)\n{\n\tastman_append(s, \"\\r\\n\");\n}\n\n/*! \\brief Lock the 'mansession' structure. */\nstatic void mansession_lock(struct mansession *s)\n{\n\tast_mutex_lock(&s->lock);\n}\n\n/*! \\brief Unlock the 'mansession' structure. */\nstatic void mansession_unlock(struct mansession *s)\n{\n\tast_mutex_unlock(&s->lock);\n}\n\n/*! \\brief\n   Rather than braindead on,off this now can also accept a specific int mask value\n   or a ',' delim list of mask strings (the same as manager.conf) -anthm\n*/\nstatic int set_eventmask(struct mansession *s, const char *eventmask)\n{\n\tint maskint = strings_to_mask(eventmask);\n\n\tao2_lock(s->session);\n\tif (maskint >= 0) {\n\t\ts->session->send_events = maskint;\n\t}\n\tao2_unlock(s->session);\n\n\treturn maskint;\n}\n\nstatic enum ast_transport mansession_get_transport(const struct mansession *s)\n{\n\treturn s->tcptls_session->parent->tls_cfg ? AST_TRANSPORT_TLS :\n\t\t\tAST_TRANSPORT_TCP;\n}\n\nstatic void report_invalid_user(const struct mansession *s, const char *username)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_inval_acct_id inval_acct_id = {\n\t\t.common.event_type = AST_SECURITY_EVENT_INVAL_ACCT_ID,\n\t\t.common.version    = AST_SECURITY_EVENT_INVAL_ACCT_ID_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s);\n\n\tast_security_event_report(AST_SEC_EVT(&inval_acct_id));\n}\n\nstatic void report_failed_acl(const struct mansession *s, const char *username)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_failed_acl failed_acl_event = {\n\t\t.common.event_type = AST_SECURITY_EVENT_FAILED_ACL,\n\t\t.common.version    = AST_SECURITY_EVENT_FAILED_ACL_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&failed_acl_event));\n}\n\nstatic void report_inval_password(const struct mansession *s, const char *username)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_inval_password inval_password = {\n\t\t.common.event_type = AST_SECURITY_EVENT_INVAL_PASSWORD,\n\t\t.common.version    = AST_SECURITY_EVENT_INVAL_PASSWORD_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&inval_password));\n}\n\nstatic void report_auth_success(const struct mansession *s)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_successful_auth successful_auth = {\n\t\t.common.event_type = AST_SECURITY_EVENT_SUCCESSFUL_AUTH,\n\t\t.common.version    = AST_SECURITY_EVENT_SUCCESSFUL_AUTH_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&successful_auth));\n}\n\nstatic void report_req_not_allowed(const struct mansession *s, const char *action)\n{\n\tchar session_id[32];\n\tchar request_type[64];\n\tstruct ast_security_event_req_not_allowed req_not_allowed = {\n\t\t.common.event_type = AST_SECURITY_EVENT_REQ_NOT_ALLOWED,\n\t\t.common.version    = AST_SECURITY_EVENT_REQ_NOT_ALLOWED_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\n\t\t.request_type      = request_type,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\tsnprintf(request_type, sizeof(request_type), \"Action: %s\", action);\n\n\tast_security_event_report(AST_SEC_EVT(&req_not_allowed));\n}\n\nstatic void report_req_bad_format(const struct mansession *s, const char *action)\n{\n\tchar session_id[32];\n\tchar request_type[64];\n\tstruct ast_security_event_req_bad_format req_bad_format = {\n\t\t.common.event_type = AST_SECURITY_EVENT_REQ_BAD_FORMAT,\n\t\t.common.version    = AST_SECURITY_EVENT_REQ_BAD_FORMAT_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\n\t\t.request_type      = request_type,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\tsnprintf(request_type, sizeof(request_type), \"Action: %s\", action);\n\n\tast_security_event_report(AST_SEC_EVT(&req_bad_format));\n}\n\nstatic void report_failed_challenge_response(const struct mansession *s,\n\t\tconst char *response, const char *expected_response)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_chal_resp_failed chal_resp_failed = {\n\t\t.common.event_type = AST_SECURITY_EVENT_CHAL_RESP_FAILED,\n\t\t.common.version    = AST_SECURITY_EVENT_CHAL_RESP_FAILED_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\n\t\t.challenge         = s->session->challenge,\n\t\t.response          = response,\n\t\t.expected_response = expected_response,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&chal_resp_failed));\n}\n\nstatic void report_session_limit(const struct mansession *s)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_session_limit session_limit = {\n\t\t.common.event_type = AST_SECURITY_EVENT_SESSION_LIMIT,\n\t\t.common.version    = AST_SECURITY_EVENT_SESSION_LIMIT_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&session_limit));\n}\n\n/*\n * Here we start with action_ handlers for AMI actions,\n * and the internal functions used by them.\n * Generally, the handlers are called action_foo()\n */\n\n/* helper function for action_login() */\nstatic int authenticate(struct mansession *s, const struct message *m)\n{\n\tconst char *username = astman_get_header(m, \"Username\");\n\tconst char *password = astman_get_header(m, \"Secret\");\n\tint error = -1;\n\tstruct ast_manager_user *user = NULL;\n\tregex_t *regex_filter;\n\tstruct ao2_iterator filter_iter;\n\n\tif (ast_strlen_zero(username)) {\t/* missing username */\n\t\treturn -1;\n\t}\n\n\t/* locate user in locked state */\n\tAST_RWLIST_WRLOCK(&users);\n\n\tif (!(user = get_manager_by_name_locked(username))) {\n\t\treport_invalid_user(s, username);\n\t\tast_log(LOG_NOTICE, \"%s tried to authenticate with nonexistent user '%s'\\n\", ast_sockaddr_stringify_addr(&s->session->addr), username);\n\t} else if (user->acl && (ast_apply_acl(user->acl, &s->session->addr, \"Manager User ACL: \") == AST_SENSE_DENY)) {\n\t\treport_failed_acl(s, username);\n\t\tast_log(LOG_NOTICE, \"%s failed to pass IP ACL as '%s'\\n\", ast_sockaddr_stringify_addr(&s->session->addr), username);\n\t} else if (!strcasecmp(astman_get_header(m, \"AuthType\"), \"MD5\")) {\n\t\tconst char *key = astman_get_header(m, \"Key\");\n\t\tif (!ast_strlen_zero(key) && !ast_strlen_zero(s->session->challenge) && user->secret) {\n\t\t\tint x;\n\t\t\tint len = 0;\n\t\t\tchar md5key[256] = \"\";\n\t\t\tstruct MD5Context md5;\n\t\t\tunsigned char digest[16];\n\n\t\t\tMD5Init(&md5);\n\t\t\tMD5Update(&md5, (unsigned char *) s->session->challenge, strlen(s->session->challenge));\n\t\t\tMD5Update(&md5, (unsigned char *) user->secret, strlen(user->secret));\n\t\t\tMD5Final(digest, &md5);\n\t\t\tfor (x = 0; x < 16; x++)\n\t\t\t\tlen += sprintf(md5key + len, \"%02hhx\", digest[x]);\n\t\t\tif (!strcmp(md5key, key)) {\n\t\t\t\terror = 0;\n\t\t\t} else {\n\t\t\t\treport_failed_challenge_response(s, key, md5key);\n\t\t\t}\n\t\t} else {\n\t\t\tast_debug(1, \"MD5 authentication is not possible.  challenge: '%s'\\n\",\n\t\t\t\tS_OR(s->session->challenge, \"\"));\n\t\t}\n\t} else if (user->secret) {\n\t\tif (!strcmp(password, user->secret)) {\n\t\t\terror = 0;\n\t\t} else {\n\t\t\treport_inval_password(s, username);\n\t\t}\n\t}\n\n\tif (error) {\n\t\tast_log(LOG_NOTICE, \"%s failed to authenticate as '%s'\\n\", ast_sockaddr_stringify_addr(&s->session->addr), username);\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\treturn -1;\n\t}\n\n\t/* auth complete */\n\n\t/* All of the user parameters are copied to the session so that in the event\n\t* of a reload and a configuration change, the session parameters are not\n\t* changed. */\n\tast_copy_string(s->session->username, username, sizeof(s->session->username));\n\ts->session->readperm = user->readperm;\n\ts->session->writeperm = user->writeperm;\n\ts->session->writetimeout = user->writetimeout;\n\tif (user->chanvars) {\n\t\ts->session->chanvars = ast_variables_dup(user->chanvars);\n\t}\n\n\tfilter_iter = ao2_iterator_init(user->whitefilters, 0);\n\twhile ((regex_filter = ao2_iterator_next(&filter_iter))) {\n\t\tao2_t_link(s->session->whitefilters, regex_filter, \"add white user filter to session\");\n\t\tao2_t_ref(regex_filter, -1, \"remove iterator ref\");\n\t}\n\tao2_iterator_destroy(&filter_iter);\n\n\tfilter_iter = ao2_iterator_init(user->blackfilters, 0);\n\twhile ((regex_filter = ao2_iterator_next(&filter_iter))) {\n\t\tao2_t_link(s->session->blackfilters, regex_filter, \"add black user filter to session\");\n\t\tao2_t_ref(regex_filter, -1, \"remove iterator ref\");\n\t}\n\tao2_iterator_destroy(&filter_iter);\n\n\ts->session->sessionstart = time(NULL);\n\ts->session->sessionstart_tv = ast_tvnow();\n\tset_eventmask(s, astman_get_header(m, \"Events\"));\n\n\treport_auth_success(s);\n\n\tAST_RWLIST_UNLOCK(&users);\n\treturn 0;\n}\n\nstatic int action_ping(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tstruct timeval now = ast_tvnow();\n\n\tastman_append(s, \"Response: Success\\r\\n\");\n\tif (!ast_strlen_zero(actionid)){\n\t\tastman_append(s, \"ActionID: %s\\r\\n\", actionid);\n\t}\n\tastman_append(\n\t\ts,\n\t\t\"Ping: Pong\\r\\n\"\n\t\t\"Timestamp: %ld.%06lu\\r\\n\"\n\t\t\"\\r\\n\",\n\t\t(long) now.tv_sec, (unsigned long) now.tv_usec);\n\treturn 0;\n}\n\nvoid astman_live_dangerously(int new_live_dangerously)\n{\n\tif (new_live_dangerously && !live_dangerously)\n\t{\n\t\tast_log(LOG_WARNING, \"Manager Configuration load protection disabled.\\n\");\n\t}\n\n\tif (!new_live_dangerously && live_dangerously)\n\t{\n\t\tast_log(LOG_NOTICE, \"Manager Configuration load protection enabled.\\n\");\n\t}\n\tlive_dangerously = new_live_dangerously;\n}\n\nstatic int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\nstatic int action_listcategories(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *match = astman_get_header(m, \"Match\");\n\tstruct ast_category *category = NULL;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\tint catcount = 0;\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (!(cfg = ast_config_load2(fn, \"manager\", config_flags))) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((category = ast_category_browse_filtered(cfg, NULL, category, match))) {\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, ast_category_get_name(category));\n\t\tcatcount++;\n\t}\n\n\tif (catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"Error: no categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\n/*! The amount of space in out must be at least ( 2 * strlen(in) + 1 ) */\nstatic void json_escape(char *out, const char *in)\n{\n\tfor (; *in; in++) {\n\t\tif (*in == '\\\\' || *in == '\\\"') {\n\t\t\t*out++ = '\\\\';\n\t\t}\n\t\t*out++ = *in;\n\t}\n\t*out = '\\0';\n}\n\n/*!\n * \\internal\n * \\brief Append a JSON escaped string to the manager stream.\n *\n * \\param s AMI stream to append a string.\n * \\param str String to append to the stream after JSON escaping it.\n */\nstatic void astman_append_json(struct mansession *s, const char *str)\n{\n\tchar *buf;\n\n\tbuf = ast_alloca(2 * strlen(str) + 1);\n\tjson_escape(buf, str);\n\tastman_append(s, \"%s\", buf);\n}\n\nstatic int action_getconfigjson(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tstruct ast_category *cur_category = NULL;\n\tconst char *category_name;\n\tstruct ast_variable *v;\n\tint comma1 = 0;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tif (!(cfg = ast_config_load2(fn, \"manager\", config_flags))) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\tastman_append(s, \"JSON: {\");\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tint comma2 = 0;\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tastman_append(s, \"%s\\\"\", comma1 ? \",\" : \"\");\n\t\tastman_append_json(s, category_name);\n\t\tastman_append(s, \"\\\":{\");\n\t\tcomma1 = 1;\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"\\\"istemplate\\\":1\");\n\t\t\tcomma2 = 1;\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"%s\", comma2 ? \",\" : \"\");\n\t\t\tastman_append(s, \"\\\"templates\\\":\\\"%s\\\"\", ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t\tcomma2 = 1;\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"%s\\\"\", comma2 ? \",\" : \"\");\n\t\t\tastman_append_json(s, v->name);\n\t\t\tastman_append(s, \"\\\":\\\"\");\n\t\t\tastman_append_json(s, v->value);\n\t\t\tastman_append(s, \"\\\"\");\n\t\t\tcomma2 = 1;\n\t\t}\n\n\t\tastman_append(s, \"}\");\n\t}\n\tastman_append(s, \"}\\r\\n\\r\\n\");\n\n\tast_config_destroy(cfg);\n\n\treturn 0;\n}\n\n/*! \\brief helper function for action_updateconfig */\nstatic enum error_type handle_updates(struct mansession *s, const struct message *m, struct ast_config *cfg, const char *dfn)\n{\n\tint x;\n\tchar hdr[40];\n\tconst char *action, *cat, *var, *value, *match, *line, *options;\n\tstruct ast_variable *v;\n\tstruct ast_str *str1 = ast_str_create(16), *str2 = ast_str_create(16);\n\tenum error_type result = 0;\n\n\tfor (x = 0; x < 100000; x++) {\t/* 100000 = the max number of allowed updates + 1 */\n\t\tunsigned int object = 0;\n\t\tchar *dupoptions;\n\t\tint allowdups = 0;\n\t\tint istemplate = 0;\n\t\tint ignoreerror = 0;\n\t\tRAII_VAR(char *, inherit, NULL, ast_free);\n\t\tRAII_VAR(char *, catfilter, NULL, ast_free);\n\t\tchar *token;\n\t\tint foundvar = 0;\n\t\tint foundcat = 0;\n\t\tstruct ast_category *category = NULL;\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Action-%06d\", x);\n\t\taction = astman_get_header(m, hdr);\n\t\tif (ast_strlen_zero(action))\t\t/* breaks the for loop if no action header */\n\t\t\tbreak;\t\t\t\t\t\t\t/* this could cause problems if actions come in misnumbered */\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Cat-%06d\", x);\n\t\tcat = astman_get_header(m, hdr);\n\t\tif (ast_strlen_zero(cat)) {\t\t/* every action needs a category */\n\t\t\tresult =  UNSPECIFIED_CATEGORY;\n\t\t\tbreak;\n\t\t}\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Var-%06d\", x);\n\t\tvar = astman_get_header(m, hdr);\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Value-%06d\", x);\n\t\tvalue = astman_get_header(m, hdr);\n\n\t\tif (!ast_strlen_zero(value) && *value == '>') {\n\t\t\tobject = 1;\n\t\t\tvalue++;\n\t\t}\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Match-%06d\", x);\n\t\tmatch = astman_get_header(m, hdr);\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Line-%06d\", x);\n\t\tline = astman_get_header(m, hdr);\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Options-%06d\", x);\n\t\toptions = astman_get_header(m, hdr);\n\t\tif (!ast_strlen_zero(options)) {\n\t\t\tchar copy[strlen(options) + 1];\n\t\t\tstrcpy(copy, options); /* safe */\n\t\t\tdupoptions = copy;\n\t\t\twhile ((token = ast_strsep(&dupoptions, ',', AST_STRSEP_STRIP))) {\n\t\t\t\tif (!strcasecmp(\"allowdups\", token)) {\n\t\t\t\t\tallowdups = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!strcasecmp(\"template\", token)) {\n\t\t\t\t\tistemplate = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!strcasecmp(\"ignoreerror\", token)) {\n\t\t\t\t\tignoreerror = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ast_begins_with(token, \"inherit\")) {\n\t\t\t\t\tchar *c = ast_strsep(&token, '=', AST_STRSEP_STRIP);\n\t\t\t\t\tc = ast_strsep(&token, '=', AST_STRSEP_STRIP);\n\t\t\t\t\tif (c) {\n\t\t\t\t\t\tinherit = ast_strdup(c);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ast_begins_with(token, \"catfilter\")) {\n\t\t\t\t\tchar *c = ast_strsep(&token, '=', AST_STRSEP_STRIP);\n\t\t\t\t\tc = ast_strsep(&token, '=', AST_STRSEP_STRIP);\n\t\t\t\t\tif (c) {\n\t\t\t\t\t\tcatfilter = ast_strdup(c);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!strcasecmp(action, \"newcat\")) {\n\t\t\tstruct ast_category *template;\n\t\t\tchar *tmpl_name = NULL;\n\n\t\t\tif (!allowdups) {\n\t\t\t\tif (ast_category_get(cfg, cat, \"TEMPLATES=include\")) {\n\t\t\t\t\tif (ignoreerror) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = FAILURE_NEWCAT;\t/* already exist */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (istemplate) {\n\t\t\t\tcategory = ast_category_new_template(cat, dfn, -1);\n\t\t\t} else {\n\t\t\t\tcategory = ast_category_new(cat, dfn, -1);\n\t\t\t}\n\n\t\t\tif (!category) {\n\t\t\t\tresult = FAILURE_ALLOCATION;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (inherit) {\n\t\t\t\twhile ((tmpl_name = ast_strsep(&inherit, ',', AST_STRSEP_STRIP))) {\n\t\t\t\t\tif ((template = ast_category_get(cfg, tmpl_name, \"TEMPLATES=restrict\"))) {\n\t\t\t\t\t\tif (ast_category_inherit(category, template)) {\n\t\t\t\t\t\t\tresult = FAILURE_ALLOCATION;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_category_destroy(category);\n\t\t\t\t\t\tcategory = NULL;\n\t\t\t\t\t\tresult = FAILURE_TEMPLATE;\t/* template not found */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (category != NULL) {\n\t\t\t\tif (ast_strlen_zero(match)) {\n\t\t\t\t\tast_category_append(cfg, category);\n\t\t\t\t} else {\n\t\t\t\t\tif (ast_category_insert(cfg, category, match)) {\n\t\t\t\t\t\tast_category_destroy(category);\n\t\t\t\t\t\tresult = FAILURE_NEWCAT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"renamecat\")) {\n\t\t\tif (ast_strlen_zero(value)) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tast_category_rename(category, value);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"delcat\")) {\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tcategory = ast_category_delete(cfg, category);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat && !ignoreerror) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"emptycat\")) {\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tast_category_empty(category);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"update\")) {\n\t\t\tif (ast_strlen_zero(var)) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\tfoundvar = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tif (!ast_variable_update(category, var, value, match, object)) {\n\t\t\t\t\tfoundvar = 1;\n\t\t\t\t}\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!foundvar) {\n\t\t\t\tresult = FAILURE_UPDATE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"delete\")) {\n\t\t\tif ((ast_strlen_zero(var) && ast_strlen_zero(line))) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\tfoundvar = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tif (!ast_variable_delete(category, var, match, line)) {\n\t\t\t\t\tfoundvar = 1;\n\t\t\t\t}\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!foundvar && !ignoreerror) {\n\t\t\t\tresult = FAILURE_UPDATE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"append\")) {\n\t\t\tif (ast_strlen_zero(var)) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tif (!(v = ast_variable_new(var, value, dfn))) {\n\t\t\t\t\tresult = FAILURE_ALLOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (object || (match && !strcasecmp(match, \"object\"))) {\n\t\t\t\t\tv->object = 1;\n\t\t\t\t}\n\t\t\t\tast_variable_append(category, v);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"insert\")) {\n\t\t\tif (ast_strlen_zero(var) || ast_strlen_zero(line)) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tif (!(v = ast_variable_new(var, value, dfn))) {\n\t\t\t\t\tresult = FAILURE_ALLOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tast_variable_insert(category, v, line);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tast_log(LOG_WARNING, \"Action-%06d: %s not handled\\n\", x, action);\n\t\t\tresult = UNKNOWN_ACTION;\n\t\t\tbreak;\n\t\t}\n\t}\n\tast_free(str1);\n\tast_free(str2);\n\treturn result;\n}\n\nstatic int action_updateconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *sfn = astman_get_header(m, \"SrcFilename\");\n\tconst char *dfn = astman_get_header(m, \"DstFilename\");\n\tint res;\n\tconst char *rld = astman_get_header(m, \"Reload\");\n\tint preserve_effective_context = CONFIG_SAVE_FLAG_PRESERVE_EFFECTIVE_CONTEXT;\n\tconst char *preserve_effective_context_string = astman_get_header(m, \"PreserveEffectiveContext\");\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\tenum error_type result;\n\n\tif (ast_strlen_zero(sfn) || ast_strlen_zero(dfn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\tif (restrictedFile(sfn) || restrictedFile(dfn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\tif (!(cfg = ast_config_load2(sfn, \"manager\", config_flags))) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\tresult = handle_updates(s, m, cfg, dfn);\n\tif (!result) {\n\t\tast_include_rename(cfg, sfn, dfn); /* change the include references from dfn to sfn, so things match up */\n\t\tif (!ast_strlen_zero(preserve_effective_context_string) && !ast_true(preserve_effective_context_string)) {\n\t\t\tpreserve_effective_context = CONFIG_SAVE_FLAG_NONE;\n\t\t}\n\t\tres = ast_config_text_file_save2(dfn, cfg, \"Manager\", preserve_effective_context);\n\t\tast_config_destroy(cfg);\n\t\tif (res) {\n\t\t\tastman_send_error(s, m, \"Save of config failed\");\n\t\t\treturn 0;\n\t\t}\n\t\tastman_send_ack(s, m, NULL);\n\t\tif (!ast_strlen_zero(rld)) {\n\t\t\tif (ast_true(rld)) {\n\t\t\t\trld = NULL;\n\t\t\t}\n\t\t\tast_module_reload(rld);\n\t\t}\n\t} else {\n\t\tast_config_destroy(cfg);\n\t\tswitch(result) {\n\t\tcase UNKNOWN_ACTION:\n\t\t\tastman_send_error(s, m, \"Unknown action command\");\n\t\t\tbreak;\n\t\tcase UNKNOWN_CATEGORY:\n\t\t\tastman_send_error(s, m, \"Given category does not exist\");\n\t\t\tbreak;\n\t\tcase UNSPECIFIED_CATEGORY:\n\t\t\tastman_send_error(s, m, \"Category not specified\");\n\t\t\tbreak;\n\t\tcase UNSPECIFIED_ARGUMENT:\n\t\t\tastman_send_error(s, m, \"Problem with category, value, or line (if required)\");\n\t\t\tbreak;\n\t\tcase FAILURE_ALLOCATION:\n\t\t\tastman_send_error(s, m, \"Memory allocation failure, this should not happen\");\n\t\t\tbreak;\n\t\tcase FAILURE_NEWCAT:\n\t\t\tastman_send_error(s, m, \"Create category did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_DELCAT:\n\t\t\tastman_send_error(s, m, \"Delete category did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_EMPTYCAT:\n\t\t\tastman_send_error(s, m, \"Empty category did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_UPDATE:\n\t\t\tastman_send_error(s, m, \"Update did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_DELETE:\n\t\t\tastman_send_error(s, m, \"Delete did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_APPEND:\n\t\t\tastman_send_error(s, m, \"Append did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_TEMPLATE:\n\t\t\tastman_send_error(s, m, \"Template category not found\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int action_createconfig(struct mansession *s, const struct message *m)\n{\n\tint fd;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tstruct ast_str *filepath = ast_str_alloca(PATH_MAX);\n\tast_str_set(&filepath, 0, \"%s/\", ast_config_AST_CONFIG_DIR);\n\tast_str_append(&filepath, 0, \"%s\", fn);\n\n\tif ((fd = open(ast_str_buffer(filepath), O_CREAT | O_EXCL, AST_FILE_MODE)) != -1) {\n\t\tclose(fd);\n\t\tastman_send_ack(s, m, \"New configuration file created successfully\");\n\t} else {\n\t\tastman_send_error(s, m, strerror(errno));\n\t}\n\n\treturn 0;\n}\n\nstatic int action_waitevent(struct mansession *s, const struct message *m)\n{\n\tconst char *timeouts = astman_get_header(m, \"Timeout\");\n\tint timeout = -1;\n\tint x;\n\tint needexit = 0;\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tchar idText[256];\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", id);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tif (!ast_strlen_zero(timeouts)) {\n\t\tsscanf(timeouts, \"%30i\", &timeout);\n\t\tif (timeout < -1) {\n\t\t\ttimeout = -1;\n\t\t}\n\t\t/* XXX maybe put an upper bound, or prevent the use of 0 ? */\n\t}\n\n\tast_mutex_lock(&s->session->notify_lock);\n\tif (s->session->waiting_thread != AST_PTHREADT_NULL) {\n\t\tpthread_kill(s->session->waiting_thread, SIGURG);\n\t}\n\tast_mutex_unlock(&s->session->notify_lock);\n\n\tao2_lock(s->session);\n\n\tif (s->session->managerid) { /* AMI-over-HTTP session */\n\t\t/*\n\t\t * Make sure the timeout is within the expire time of the session,\n\t\t * as the client will likely abort the request if it does not see\n\t\t * data coming after some amount of time.\n\t\t */\n\t\ttime_t now = time(NULL);\n\t\tint max = s->session->sessiontimeout - now - 10;\n\n\t\tif (max < 0) {\t/* We are already late. Strange but possible. */\n\t\t\tmax = 0;\n\t\t}\n\t\tif (timeout < 0 || timeout > max) {\n\t\t\ttimeout = max;\n\t\t}\n\t\tif (!s->session->send_events) {\t/* make sure we record events */\n\t\t\ts->session->send_events = -1;\n\t\t}\n\t}\n\tao2_unlock(s->session);\n\n\tast_mutex_lock(&s->session->notify_lock);\n\ts->session->waiting_thread = pthread_self();\t/* let new events wake up this thread */\n\tast_mutex_unlock(&s->session->notify_lock);\n\tast_debug(1, \"Starting waiting for an event!\\n\");\n\n\tfor (x = 0; x < timeout || timeout < 0; x++) {\n\t\tao2_lock(s->session);\n\t\tif (AST_RWLIST_NEXT(s->session->last_ev, eq_next)) {\n\t\t\tneedexit = 1;\n\t\t}\n\t\tif (s->session->needdestroy) {\n\t\t\tneedexit = 1;\n\t\t}\n\t\tao2_unlock(s->session);\n\t\t/* We can have multiple HTTP session point to the same mansession entry.\n\t\t * The way we deal with it is not very nice: newcomers kick out the previous\n\t\t * HTTP session. XXX this needs to be improved.\n\t\t */\n\t\tast_mutex_lock(&s->session->notify_lock);\n\t\tif (s->session->waiting_thread != pthread_self()) {\n\t\t\tneedexit = 1;\n\t\t}\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\t\tif (needexit) {\n\t\t\tbreak;\n\t\t}\n\t\tif (s->session->managerid == 0) {\t/* AMI session */\n\t\t\tif (ast_wait_for_input(ast_iostream_get_fd(s->session->stream), 1000)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\t/* HTTP session */\n\t\t\tsleep(1);\n\t\t}\n\t}\n\tast_debug(1, \"Finished waiting for an event!\\n\");\n\n\tast_mutex_lock(&s->session->notify_lock);\n\tif (s->session->waiting_thread == pthread_self()) {\n\t\tstruct eventqent *eqe = s->session->last_ev;\n\n\t\ts->session->waiting_thread = AST_PTHREADT_NULL;\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\n\t\tao2_lock(s->session);\n\t\tastman_send_response(s, m, \"Success\", \"Waiting for Event completed.\");\n\t\twhile ((eqe = advance_event(eqe))) {\n\t\t\tif (((s->session->readperm & eqe->category) == eqe->category)\n\t\t\t\t&& ((s->session->send_events & eqe->category) == eqe->category)\n\t\t\t\t&& match_filter(s, eqe->eventdata)) {\n\t\t\t\tastman_append(s, \"%s\", eqe->eventdata);\n\t\t\t}\n\t\t\ts->session->last_ev = eqe;\n\t\t}\n\t\tastman_append(s,\n\t\t\t\"Event: WaitEventComplete\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"\\r\\n\", idText);\n\t\tao2_unlock(s->session);\n\t} else {\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\t\tast_debug(1, \"Abandoning event request!\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int action_listcommands(struct mansession *s, const struct message *m)\n{\n\tstruct manager_action *cur;\n\tstruct ast_str *temp = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\n\tastman_start_ack(s, m);\n\tAST_RWLIST_RDLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tif ((s->session->writeperm & cur->authority) || cur->authority == 0) {\n\t\t\tastman_append(s, \"%s: %s (Priv: %s)\\r\\n\",\n\t\t\t\tcur->action, cur->synopsis, authority_to_str(cur->authority, &temp));\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&actions);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\nstatic int action_events(struct mansession *s, const struct message *m)\n{\n\tconst char *mask = astman_get_header(m, \"EventMask\");\n\tint res, x;\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tchar id_text[256];\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(id_text, sizeof(id_text), \"ActionID: %s\\r\\n\", id);\n\t} else {\n\t\tid_text[0] = '\\0';\n\t}\n\n\tres = set_eventmask(s, mask);\n\tif (broken_events_action) {\n\t\t/* if this option is set we should not return a response on\n\t\t * error, or when all events are set */\n\n\t\tif (res > 0) {\n\t\t\tfor (x = 0; x < ARRAY_LEN(perms); x++) {\n\t\t\t\tif (!strcasecmp(perms[x].label, \"all\") && res == perms[x].num) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tastman_append(s, \"Response: Success\\r\\n%s\"\n\t\t\t\t\t \"Events: On\\r\\n\\r\\n\", id_text);\n\t\t} else if (res == 0)\n\t\t\tastman_append(s, \"Response: Success\\r\\n%s\"\n\t\t\t\t\t \"Events: Off\\r\\n\\r\\n\", id_text);\n\t\treturn 0;\n\t}\n\n\tif (res > 0)\n\t\tastman_append(s, \"Response: Success\\r\\n%s\"\n\t\t\t\t \"Events: On\\r\\n\\r\\n\", id_text);\n\telse if (res == 0)\n\t\tastman_append(s, \"Response: Success\\r\\n%s\"\n\t\t\t\t \"Events: Off\\r\\n\\r\\n\", id_text);\n\telse\n\t\tastman_send_error(s, m, \"Invalid event mask\");\n\n\treturn 0;\n}\n\nstatic int action_logoff(struct mansession *s, const struct message *m)\n{\n\tastman_send_response(s, m, \"Goodbye\", \"Thanks for all the fish.\");\n\treturn -1;\n}\n\nstatic int action_login(struct mansession *s, const struct message *m)\n{\n\n\t/* still authenticated - don't process again */\n\tif (s->session->authenticated) {\n\t\tastman_send_ack(s, m, \"Already authenticated\");\n\t\treturn 0;\n\t}\n\n\tif (authenticate(s, m)) {\n\t\tsleep(1);\n\t\tastman_send_error(s, m, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\ts->session->authenticated = 1;\n\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\tif (manager_displayconnects(s->session)) {\n\t\tast_verb(2, \"%sManager '%s' logged on from %s\\n\", (s->session->managerid ? \"HTTP \" : \"\"), s->session->username, ast_sockaddr_stringify_addr(&s->session->addr));\n\t}\n\tastman_send_ack(s, m, \"Authentication accepted\");\n\tif ((s->session->send_events & EVENT_FLAG_SYSTEM)\n\t\t&& (s->session->readperm & EVENT_FLAG_SYSTEM)\n\t\t&& ast_test_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {\n\t\tstruct ast_str *auth = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\t\tconst char *cat_str = authority_to_str(EVENT_FLAG_SYSTEM, &auth);\n\t\tlong uptime = 0;\n\t\tlong lastreloaded = 0;\n\t\tstruct timeval tmp;\n\t\tstruct timeval curtime = ast_tvnow();\n\n\t\tif (ast_startuptime.tv_sec) {\n\t\t\ttmp = ast_tvsub(curtime, ast_startuptime);\n\t\t\tuptime = tmp.tv_sec;\n\t\t}\n\n\t\tif (ast_lastreloadtime.tv_sec) {\n\t\t\ttmp = ast_tvsub(curtime, ast_lastreloadtime);\n\t\t\tlastreloaded = tmp.tv_sec;\n\t\t}\n\n\t\tastman_append(s, \"Event: FullyBooted\\r\\n\"\n\t\t\t\"Privilege: %s\\r\\n\"\n\t\t\t\"Uptime: %ld\\r\\n\"\n\t\t\t\"LastReload: %ld\\r\\n\"\n\t\t\t\"Status: Fully Booted\\r\\n\\r\\n\", cat_str, uptime, lastreloaded);\n\t}\n\treturn 0;\n}\n\nstatic int action_challenge(struct mansession *s, const struct message *m)\n{\n\tconst char *authtype = astman_get_header(m, \"AuthType\");\n\n\tif (!strcasecmp(authtype, \"MD5\")) {\n\t\tif (ast_strlen_zero(s->session->challenge)) {\n\t\t\tsnprintf(s->session->challenge, sizeof(s->session->challenge), \"%ld\", ast_random());\n\t\t}\n\t\tmansession_lock(s);\n\t\tastman_start_ack(s, m);\n\t\tastman_append(s, \"Challenge: %s\\r\\n\\r\\n\", s->session->challenge);\n\t\tmansession_unlock(s);\n\t} else {\n\t\tastman_send_error(s, m, \"Must specify AuthType\");\n\t}\n\treturn 0;\n}\n\nint ast_manager_hangup_helper(struct mansession *s,\n\tconst struct message *m, manager_hangup_handler_t hangup_handler,\n\tmanager_hangup_cause_validator_t cause_validator)\n{\n\tstruct ast_channel *c = NULL;\n\tint causecode = 0; /* all values <= 0 mean 'do not set hangupcause in channel' */\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tconst char *name_or_regex = astman_get_header(m, \"Channel\");\n\tconst char *cause = astman_get_header(m, \"Cause\");\n\tchar idText[256];\n\tregex_t regexbuf;\n\tstruct ast_channel_iterator *iter = NULL;\n\tstruct ast_str *regex_string;\n\tint channels_matched = 0;\n\n\tif (ast_strlen_zero(name_or_regex)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", id);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tif (cause_validator) {\n\t\tcausecode = cause_validator(name_or_regex, cause);\n\t} else if (!ast_strlen_zero(cause)) {\n\t\tchar *endptr;\n\t\tcausecode = strtol(cause, &endptr, 10);\n\t\tif (causecode < 0 || causecode > 127 || *endptr != '\\0') {\n\t\t\tast_log(LOG_NOTICE, \"Invalid 'Cause: %s' in manager action Hangup\\n\", cause);\n\t\t\t/* keep going, better to hangup without cause than to not hang up at all */\n\t\t\tcausecode = 0; /* do not set channel's hangupcause */\n\t\t}\n\t}\n\n\t/************************************************/\n\t/* Regular explicit match channel byname hangup */\n\n\tif (name_or_regex[0] != '/') {\n\t\tif (!(c = ast_channel_get_by_name(name_or_regex))) {\n\t\t\tast_log(LOG_NOTICE, \"Request to hangup non-existent channel: %s\\n\",\n\t\t\t\tname_or_regex);\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tast_verb(3, \"%sManager '%s' from %s, hanging up channel: %s\\n\",\n\t\t\t(s->session->managerid ? \"HTTP \" : \"\"),\n\t\t\ts->session->username,\n\t\t\tast_sockaddr_stringify_addr(&s->session->addr),\n\t\t\tast_channel_name(c));\n\n\t\thangup_handler(c, causecode);\n\t\tc = ast_channel_unref(c);\n\n\t\tastman_send_ack(s, m, \"Channel Hungup\");\n\n\t\treturn 0;\n\t}\n\n\t/***********************************************/\n\t/* find and hangup any channels matching regex */\n\n\tregex_string = ast_str_create(strlen(name_or_regex));\n\tif (!regex_string) {\n\t\tastman_send_error(s, m, \"Memory Allocation Failure\");\n\t\treturn 0;\n\t}\n\n\t/* Make \"/regex/\" into \"regex\" */\n\tif (ast_regex_string_to_regex_pattern(name_or_regex, &regex_string) != 0) {\n\t\tastman_send_error(s, m, \"Regex format invalid, Channel param should be /regex/\");\n\t\tast_free(regex_string);\n\t\treturn 0;\n\t}\n\n\t/* if regex compilation fails, hangup fails */\n\tif (regcomp(&regexbuf, ast_str_buffer(regex_string), REG_EXTENDED | REG_NOSUB)) {\n\t\tastman_send_error_va(s, m, \"Regex compile failed on: %s\", name_or_regex);\n\t\tast_free(regex_string);\n\t\treturn 0;\n\t}\n\n\tastman_send_listack(s, m, \"Channels hung up will follow\", \"start\");\n\n\titer = ast_channel_iterator_all_new();\n\tif (iter) {\n\t\tfor (; (c = ast_channel_iterator_next(iter)); ast_channel_unref(c)) {\n\t\t\tif (regexec(&regexbuf, ast_channel_name(c), 0, NULL, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tast_verb(3, \"%sManager '%s' from %s, hanging up channel: %s\\n\",\n\t\t\t\t(s->session->managerid ? \"HTTP \" : \"\"),\n\t\t\t\ts->session->username,\n\t\t\t\tast_sockaddr_stringify_addr(&s->session->addr),\n\t\t\t\tast_channel_name(c));\n\n\t\t\thangup_handler(c, causecode);\n\t\t\tchannels_matched++;\n\n\t\t\tastman_append(s,\n\t\t\t\t\"Event: ChannelHungup\\r\\n\"\n\t\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\t\"%s\"\n\t\t\t\t\"\\r\\n\", ast_channel_name(c), idText);\n\t\t}\n\t\tast_channel_iterator_destroy(iter);\n\t}\n\n\tregfree(&regexbuf);\n\tast_free(regex_string);\n\n\tastman_send_list_complete(s, m, \"ChannelsHungupListComplete\", channels_matched);\n\n\treturn 0;\n}\n\nstatic int action_hangup(struct mansession *s, const struct message *m)\n{\n\treturn ast_manager_hangup_helper(s, m,\n\t\tast_channel_softhangup_withcause_locked, NULL);\n}\n\nstatic int action_setvar(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c = NULL;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *varname = astman_get_header(m, \"Variable\");\n\tconst char *varval = astman_get_header(m, \"Value\");\n\tint res = 0;\n\n\tif (ast_strlen_zero(varname)) {\n\t\tastman_send_error(s, m, \"No variable specified\");\n\t\treturn 0;\n\t}\n\n\tif (!ast_strlen_zero(name)) {\n\t\tif (!(c = ast_channel_get_by_name(name))) {\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tres = pbx_builtin_setvar_helper(c, varname, S_OR(varval, \"\"));\n\n\tif (c) {\n\t\tc = ast_channel_unref(c);\n\t}\n\tif (res == 0) {\n\t\tastman_send_ack(s, m, \"Variable Set\");\n\t} else {\n\t\tastman_send_error(s, m, \"Variable not set\");\n\t}\n\treturn 0;\n}\n\nstatic int action_getvar(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c = NULL;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *varname = astman_get_header(m, \"Variable\");\n\tchar *varval;\n\tchar workspace[1024];\n\n\tif (ast_strlen_zero(varname)) {\n\t\tastman_send_error(s, m, \"No variable specified\");\n\t\treturn 0;\n\t}\n\n\t/* We don't want users with insufficient permissions using certain functions. */\n\tif (!(function_capable_string_allowed_with_auths(varname, s->session->writeperm))) {\n\t\tastman_send_error(s, m, \"GetVar Access Forbidden: Variable\");\n\t\treturn 0;\n\t}\n\n\tif (!ast_strlen_zero(name)) {\n\t\tif (!(c = ast_channel_get_by_name(name))) {\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tworkspace[0] = '\\0';\n\tif (varname[strlen(varname) - 1] == ')') {\n\t\tif (!c) {\n\t\t\tc = ast_dummy_channel_alloc();\n\t\t\tif (c) {\n\t\t\t\tast_func_read(c, (char *) varname, workspace, sizeof(workspace));\n\t\t\t} else\n\t\t\t\tast_log(LOG_ERROR, \"Unable to allocate bogus channel for variable substitution.  Function results may be blank.\\n\");\n\t\t} else {\n\t\t\tast_func_read(c, (char *) varname, workspace, sizeof(workspace));\n\t\t}\n\t\tvarval = workspace;\n\t} else {\n\t\tpbx_retrieve_variable(c, varname, &varval, workspace, sizeof(workspace), NULL);\n\t}\n\n\tif (c) {\n\t\tc = ast_channel_unref(c);\n\t}\n\n\tastman_start_ack(s, m);\n\tastman_append(s, \"Variable: %s\\r\\nValue: %s\\r\\n\\r\\n\", varname, S_OR(varval, \"\"));\n\n\treturn 0;\n}\n\nstatic void generate_status(struct mansession *s, struct ast_channel *chan, char **vars, int varc, int all_variables, char *id_text, int *count)\n{\n\tstruct timeval now;\n\tlong elapsed_seconds;\n\tstruct ast_bridge *bridge;\n\tRAII_VAR(struct ast_str *, variable_str, NULL, ast_free);\n\tstruct ast_str *write_transpath = ast_str_alloca(256);\n\tstruct ast_str *read_transpath = ast_str_alloca(256);\n\tstruct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);\n\tstruct ast_party_id effective_id;\n\tint i;\n\tRAII_VAR(struct ast_channel_snapshot *, snapshot,\n\t\tast_channel_snapshot_get_latest(ast_channel_uniqueid(chan)),\n\t\tao2_cleanup);\n\tRAII_VAR(struct ast_str *, snapshot_str, NULL, ast_free);\n\n\tif (!snapshot) {\n\t\treturn;\n\t}\n\n\tsnapshot_str = ast_manager_build_channel_state_string(snapshot);\n\tif (!snapshot_str) {\n\t\treturn;\n\t}\n\n\tif (all_variables) {\n\t\tvariable_str = ast_str_create(2048);\n\t} else {\n\t\tvariable_str = ast_str_create(1024);\n\t}\n\tif (!variable_str) {\n\t\treturn;\n\t}\n\n\tnow = ast_tvnow();\n\telapsed_seconds = ast_tvdiff_sec(now, ast_channel_creationtime(chan));\n\n\t/* Even if all_variables has been specified, explicitly requested variables\n\t * may be global variables or dialplan functions */\n\tfor (i = 0; i < varc; i++) {\n\t\tchar valbuf[512], *ret = NULL;\n\n\t\tif (vars[i][strlen(vars[i]) - 1] == ')') {\n\t\t\tif (ast_func_read(chan, vars[i], valbuf, sizeof(valbuf)) < 0) {\n\t\t\t\tvalbuf[0] = '\\0';\n\t\t\t}\n\t\t\tret = valbuf;\n\t\t} else {\n\t\t\tpbx_retrieve_variable(chan, vars[i], &ret, valbuf, sizeof(valbuf), NULL);\n\t\t}\n\n\t\tast_str_append(&variable_str, 0, \"Variable: %s=%s\\r\\n\", vars[i], ret);\n\t}\n\n\t/* Walk all channel variables and add them */\n\tif (all_variables) {\n\t\tstruct ast_var_t *variables;\n\n\t\tAST_LIST_TRAVERSE(ast_channel_varshead(chan), variables, entries) {\n\t\t\tast_str_append(&variable_str, 0, \"Variable: %s=%s\\r\\n\",\n\t\t\t\tast_var_name(variables), ast_var_value(variables));\n\t\t}\n\t}\n\n\tbridge = ast_channel_get_bridge(chan);\n\teffective_id = ast_channel_connected_effective_id(chan);\n\n\tastman_append(s,\n\t\t\"Event: Status\\r\\n\"\n\t\t\"Privilege: Call\\r\\n\"\n\t\t\"%s\"\n\t\t\"Type: %s\\r\\n\"\n\t\t\"DNID: %s\\r\\n\"\n\t\t\"EffectiveConnectedLineNum: %s\\r\\n\"\n\t\t\"EffectiveConnectedLineName: %s\\r\\n\"\n\t\t\"TimeToHangup: %ld\\r\\n\"\n\t\t\"BridgeID: %s\\r\\n\"\n\t\t\"Application: %s\\r\\n\"\n\t\t\"Data: %s\\r\\n\"\n\t\t\"Nativeformats: %s\\r\\n\"\n\t\t\"Readformat: %s\\r\\n\"\n\t\t\"Readtrans: %s\\r\\n\"\n\t\t\"Writeformat: %s\\r\\n\"\n\t\t\"Writetrans: %s\\r\\n\"\n\t\t\"Callgroup: %llu\\r\\n\"\n\t\t\"Pickupgroup: %llu\\r\\n\"\n\t\t\"Seconds: %ld\\r\\n\"\n\t\t\"%s\"\n\t\t\"%s\"\n\t\t\"\\r\\n\",\n\t\tast_str_buffer(snapshot_str),\n\t\tast_channel_tech(chan)->type,\n\t\tS_OR(ast_channel_dialed(chan)->number.str, \"\"),\n\t\tS_COR(effective_id.number.valid, effective_id.number.str, \"<unknown>\"),\n\t\tS_COR(effective_id.name.valid, effective_id.name.str, \"<unknown>\"),\n\t\t(long)ast_channel_whentohangup(chan)->tv_sec,\n\t\tbridge ? bridge->uniqueid : \"\",\n\t\tast_channel_appl(chan),\n\t\tast_channel_data(chan),\n\t\tast_format_cap_get_names(ast_channel_nativeformats(chan), &codec_buf),\n\t\tast_format_get_name(ast_channel_readformat(chan)),\n\t\tast_translate_path_to_str(ast_channel_readtrans(chan), &read_transpath),\n\t\tast_format_get_name(ast_channel_writeformat(chan)),\n\t\tast_translate_path_to_str(ast_channel_writetrans(chan), &write_transpath),\n\t\tast_channel_callgroup(chan),\n\t\tast_channel_pickupgroup(chan),\n\t\t(long)elapsed_seconds,\n\t\tast_str_buffer(variable_str),\n\t\tid_text);\n\t++*count;\n\n\tao2_cleanup(bridge);\n}\n\n/*! \\brief Manager \"status\" command to show channels */\nstatic int action_status(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *chan_variables = astman_get_header(m, \"Variables\");\n\tconst char *all_chan_variables = astman_get_header(m, \"AllVariables\");\n\tint all_variables = 0;\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tchar *variables = ast_strdupa(S_OR(chan_variables, \"\"));\n\tstruct ast_channel *chan;\n\tint channels = 0;\n\tint all = ast_strlen_zero(name); /* set if we want all channels */\n\tchar id_text[256];\n\tstruct ast_channel_iterator *it_chans = NULL;\n\tAST_DECLARE_APP_ARGS(vars,\n\t\tAST_APP_ARG(name)[100];\n\t);\n\n\tif (!ast_strlen_zero(all_chan_variables)) {\n\t\tall_variables = ast_true(all_chan_variables);\n\t}\n\n\tif (!(function_capable_string_allowed_with_auths(variables, s->session->writeperm))) {\n\t\tastman_send_error(s, m, \"Status Access Forbidden: Variables\");\n\t\treturn 0;\n\t}\n\n\tif (all) {\n\t\tif (!(it_chans = ast_channel_iterator_all_new())) {\n\t\t\tastman_send_error(s, m, \"Memory Allocation Failure\");\n\t\t\treturn 1;\n\t\t}\n\t\tchan = ast_channel_iterator_next(it_chans);\n\t} else {\n\t\tchan = ast_channel_get_by_name(name);\n\t\tif (!chan) {\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tastman_send_listack(s, m, \"Channel status will follow\", \"start\");\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(id_text, sizeof(id_text), \"ActionID: %s\\r\\n\", id);\n\t} else {\n\t\tid_text[0] = '\\0';\n\t}\n\n\tif (!ast_strlen_zero(chan_variables)) {\n\t\tAST_STANDARD_APP_ARGS(vars, variables);\n\t}\n\n\t/* if we look by name, we break after the first iteration */\n\tfor (; chan; all ? chan = ast_channel_iterator_next(it_chans) : 0) {\n\t\tast_channel_lock(chan);\n\n\t\tgenerate_status(s, chan, vars.name, vars.argc, all_variables, id_text, &channels);\n\n\t\tast_channel_unlock(chan);\n\t\tchan = ast_channel_unref(chan);\n\t}\n\n\tif (it_chans) {\n\t\tast_channel_iterator_destroy(it_chans);\n\t}\n\n\tastman_send_list_complete_start(s, m, \"StatusComplete\", channels);\n\tastman_append(s, \"Items: %d\\r\\n\", channels);\n\tastman_send_list_complete_end(s);\n\n\treturn 0;\n}\n\n/*!\n * \\brief Queue a given read action containing a payload onto a channel\n *\n * This queues a READ_ACTION control frame that contains a given \"payload\", or\n * data to be triggered and handled on the channel's read side. This ensures\n * the \"action\" is handled by the channel's media reading thread.\n *\n * \\param chan The channel to queue the action on\n * \\param payload The read action's payload\n * \\param payload_size The size of the given payload\n * \\param action The type of read action to queue\n *\n * \\retval -1 on error\n * \\retval 0 on success\n */\nstatic int queue_read_action_payload(struct ast_channel *chan, const unsigned char *payload,\n\tsize_t payload_size, enum ast_frame_read_action action)\n{\n\tstruct ast_control_read_action_payload *obj;\n\tsize_t obj_size;\n\tint res;\n\n\tobj_size = payload_size + sizeof(*obj);\n\n\tobj = ast_malloc(obj_size);\n\tif (!obj) {\n\t\treturn -1;\n\t}\n\n\tobj->action = action;\n\tobj->payload_size = payload_size;\n\tmemcpy(obj->payload, payload, payload_size);\n\n\tres = ast_queue_control_data(chan, AST_CONTROL_READ_ACTION, obj, obj_size);\n\n\tast_free(obj);\n\treturn res;\n}\n\n/*!\n * \\brief Queue a read action to send a text message\n *\n * \\param chan The channel to queue the action on\n * \\param body The body of the message\n *\n * \\retval -1 on error\n * \\retval 0 on success\n */\nstatic int queue_sendtext(struct ast_channel *chan, const char *body)\n{\n\treturn queue_read_action_payload(chan, (const unsigned char *)body,\n\t\tstrlen(body) + 1, AST_FRAME_READ_ACTION_SEND_TEXT);\n}\n\n/*!\n * \\brief Queue a read action to send a text data message\n *\n * \\param chan The channel to queue the action on\n * \\param body The body of the message\n * \\param content_type The message's content type\n *\n * \\retval -1 on error\n * \\retval 0 on success\n */\nstatic int queue_sendtext_data(struct ast_channel *chan, const char *body,\n\tconst char *content_type)\n{\n\tint res;\n\tstruct ast_msg_data *obj;\n\n\tobj = ast_msg_data_alloc2(AST_MSG_DATA_SOURCE_TYPE_UNKNOWN,\n\t\t\t\t\t\t\tNULL, NULL, content_type, body);\n\tif (!obj) {\n\t\treturn -1;\n\t}\n\n\tres = queue_read_action_payload(chan, (const unsigned char *)obj,\n\t\tast_msg_data_get_length(obj), AST_FRAME_READ_ACTION_SEND_TEXT_DATA);\n\n\tast_free(obj);\n\treturn res;\n}\n\nstatic int action_sendtext(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *textmsg = astman_get_header(m, \"Message\");\n\tconst char *content_type = astman_get_header(m, \"Content-Type\");\n\tint res;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(textmsg)) {\n\t\tastman_send_error(s, m, \"No Message specified\");\n\t\treturn 0;\n\t}\n\n\tc = ast_channel_get_by_name(name);\n\tif (!c) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the \"extra\" data is not available, then send using \"string\" only.\n\t * Doing such maintains backward compatibilities.\n\t */\n\tres = ast_strlen_zero(content_type) ? queue_sendtext(c, textmsg) :\n\t\tqueue_sendtext_data(c, textmsg, content_type);\n\n\tast_channel_unref(c);\n\n\tif (res >= 0) {\n\t\tastman_send_ack(s, m, \"Success\");\n\t} else {\n\t\tastman_send_error(s, m, \"Failure\");\n\t}\n\n\treturn 0;\n}\n\n/*! \\brief  action_redirect: The redirect manager command */\nstatic int action_redirect(struct mansession *s, const struct message *m)\n{\n\tchar buf[256];\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *name2 = astman_get_header(m, \"ExtraChannel\");\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *exten2 = astman_get_header(m, \"ExtraExten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tconst char *context2 = astman_get_header(m, \"ExtraContext\");\n\tconst char *priority = astman_get_header(m, \"Priority\");\n\tconst char *priority2 = astman_get_header(m, \"ExtraPriority\");\n\tstruct ast_channel *chan;\n\tstruct ast_channel *chan2;\n\tint pi = 0;\n\tint pi2 = 0;\n\tint res;\n\tint chan1_wait = 0;\n\tint chan2_wait = 0;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"Channel not specified\");\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(context)) {\n\t\tastman_send_error(s, m, \"Context not specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(exten)) {\n\t\tastman_send_error(s, m, \"Exten not specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(priority)) {\n\t\tastman_send_error(s, m, \"Priority not specified\");\n\t\treturn 0;\n\t}\n\tif (sscanf(priority, \"%30d\", &pi) != 1) {\n\t\tpi = ast_findlabel_extension(NULL, context, exten, priority, NULL);\n\t}\n\tif (pi < 1) {\n\t\tastman_send_error(s, m, \"Priority is invalid\");\n\t\treturn 0;\n\t}\n\n\tif (!ast_strlen_zero(name2) && !ast_strlen_zero(context2)) {\n\t\t/* We have an ExtraChannel and an ExtraContext */\n\t\tif (ast_strlen_zero(exten2)) {\n\t\t\tastman_send_error(s, m, \"ExtraExten not specified\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (ast_strlen_zero(priority2)) {\n\t\t\tastman_send_error(s, m, \"ExtraPriority not specified\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (sscanf(priority2, \"%30d\", &pi2) != 1) {\n\t\t\tpi2 = ast_findlabel_extension(NULL, context2, exten2, priority2, NULL);\n\t\t}\n\t\tif (pi2 < 1) {\n\t\t\tastman_send_error(s, m, \"ExtraPriority is invalid\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tchan = ast_channel_get_by_name(name);\n\tif (!chan) {\n\t\tsnprintf(buf, sizeof(buf), \"Channel does not exist: %s\", name);\n\t\tastman_send_error(s, m, buf);\n\t\treturn 0;\n\t}\n\tif (ast_check_hangup_locked(chan)) {\n\t\tastman_send_error(s, m, \"Redirect failed, channel not up.\");\n\t\tchan = ast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(name2)) {\n\t\t/* Single channel redirect in progress. */\n\t\tres = ast_async_goto(chan, context, exten, pi);\n\t\tif (!res) {\n\t\t\tastman_send_ack(s, m, \"Redirect successful\");\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Redirect failed\");\n\t\t}\n\t\tchan = ast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\n\tchan2 = ast_channel_get_by_name(name2);\n\tif (!chan2) {\n\t\tsnprintf(buf, sizeof(buf), \"ExtraChannel does not exist: %s\", name2);\n\t\tastman_send_error(s, m, buf);\n\t\tchan = ast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\tif (ast_check_hangup_locked(chan2)) {\n\t\tastman_send_error(s, m, \"Redirect failed, extra channel not up.\");\n\t\tchan2 = ast_channel_unref(chan2);\n\t\tchan = ast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\n\t/* Dual channel redirect in progress. */\n\tast_channel_lock(chan);\n\tif (ast_channel_is_bridged(chan)) {\n\t\tast_set_flag(ast_channel_flags(chan), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);\n\t\tchan1_wait = 1;\n\t}\n\tast_channel_unlock(chan);\n\n\tast_channel_lock(chan2);\n\tif (ast_channel_is_bridged(chan2)) {\n\t\tast_set_flag(ast_channel_flags(chan2), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);\n\t\tchan2_wait = 1;\n\t}\n\tast_channel_unlock(chan2);\n\n\tres = ast_async_goto(chan, context, exten, pi);\n\tif (!res) {\n\t\tif (!ast_strlen_zero(context2)) {\n\t\t\tres = ast_async_goto(chan2, context2, exten2, pi2);\n\t\t} else {\n\t\t\tres = ast_async_goto(chan2, context, exten, pi);\n\t\t}\n\t\tif (!res) {\n\t\t\tastman_send_ack(s, m, \"Dual Redirect successful\");\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Secondary redirect failed\");\n\t\t}\n\t} else {\n\t\tastman_send_error(s, m, \"Redirect failed\");\n\t}\n\n\t/* Release the bridge wait. */\n\tif (chan1_wait) {\n\t\tast_channel_clear_flag(chan, AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);\n\t}\n\tif (chan2_wait) {\n\t\tast_channel_clear_flag(chan2, AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);\n\t}\n\n\tchan2 = ast_channel_unref(chan2);\n\tchan = ast_channel_unref(chan);\n\treturn 0;\n}\n\nstatic int action_blind_transfer(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tstruct ast_channel *chan;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(exten)) {\n\t\tastman_send_error(s, m, \"No extension specified\");\n\t\treturn 0;\n\t}\n\n\tchan = ast_channel_get_by_name(name);\n\tif (!chan) {\n\t\tastman_send_error(s, m, \"Channel specified does not exist\");\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(context)) {\n\t\tcontext = ast_channel_context(chan);\n\t}\n\n\tswitch (ast_bridge_transfer_blind(1, chan, exten, context, NULL, NULL)) {\n\tcase AST_BRIDGE_TRANSFER_NOT_PERMITTED:\n\t\tastman_send_error(s, m, \"Transfer not permitted\");\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_INVALID:\n\t\tastman_send_error(s, m, \"Transfer invalid\");\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_FAIL:\n\t\tastman_send_error(s, m, \"Transfer failed\");\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_SUCCESS:\n\t\tastman_send_ack(s, m, \"Transfer succeeded\");\n\t\tbreak;\n\t}\n\n\tast_channel_unref(chan);\n\treturn 0;\n}\n\nstatic int action_atxfer(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tstruct ast_channel *chan = NULL;\n\tchar feature_code[AST_FEATURE_MAX_LEN];\n\tconst char *digit;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(exten)) {\n\t\tastman_send_error(s, m, \"No extension specified\");\n\t\treturn 0;\n\t}\n\n\tif (!(chan = ast_channel_get_by_name(name))) {\n\t\tastman_send_error(s, m, \"Channel specified does not exist\");\n\t\treturn 0;\n\t}\n\n\tast_channel_lock(chan);\n\tif (ast_get_builtin_feature(chan, \"atxfer\", feature_code, sizeof(feature_code)) ||\n\t\t\tast_strlen_zero(feature_code)) {\n\t\tast_channel_unlock(chan);\n\t\tastman_send_error(s, m, \"No attended transfer feature code found\");\n\t\tast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\tast_channel_unlock(chan);\n\n\tif (!ast_strlen_zero(context)) {\n\t\tpbx_builtin_setvar_helper(chan, \"TRANSFER_CONTEXT\", context);\n\t}\n\n\tfor (digit = feature_code; *digit; ++digit) {\n\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = *digit };\n\t\tast_queue_frame(chan, &f);\n\t}\n\n\tfor (digit = exten; *digit; ++digit) {\n\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = *digit };\n\t\tast_queue_frame(chan, &f);\n\t}\n\n\tchan = ast_channel_unref(chan);\n\n\tastman_send_ack(s, m, \"Atxfer successfully queued\");\n\n\treturn 0;\n}\n\nstatic int action_cancel_atxfer(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tstruct ast_channel *chan = NULL;\n\tchar *feature_code;\n\tconst char *digit;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (!(chan = ast_channel_get_by_name(name))) {\n\t\tastman_send_error(s, m, \"Channel specified does not exist\");\n\t\treturn 0;\n\t}\n\n\tast_channel_lock(chan);\n\tfeature_code = ast_get_chan_features_atxferabort(chan);\n\tast_channel_unlock(chan);\n\n\tif (!feature_code) {\n\t\tastman_send_error(s, m, \"No disconnect feature code found\");\n\t\tast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\n\tfor (digit = feature_code; *digit; ++digit) {\n\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = *digit };\n\t\tast_queue_frame(chan, &f);\n\t}\n\tast_free(feature_code);\n\n\tchan = ast_channel_unref(chan);\n\n\tastman_send_ack(s, m, \"CancelAtxfer successfully queued\");\n\n\treturn 0;\n}\n\n\nstatic int check_blacklist(const char *cmd)\n{\n\tchar *cmd_copy, *cur_cmd;\n\tchar *cmd_words[AST_MAX_CMD_LEN] = { NULL, };\n\tint i;\n\n\tcmd_copy = ast_strdupa(cmd);\n\tfor (i = 0; i < MAX_BLACKLIST_CMD_LEN && (cur_cmd = strsep(&cmd_copy, \" \")); i++) {\n\t\tcur_cmd = ast_strip(cur_cmd);\n\t\tif (ast_strlen_zero(cur_cmd)) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd_words[i] = cur_cmd;\n\t}\n\n\tfor (i = 0; i < ARRAY_LEN(command_blacklist); i++) {\n\t\tint j, match = 1;\n\n\t\tfor (j = 0; command_blacklist[i].words[j]; j++) {\n\t\t\tif (ast_strlen_zero(cmd_words[j]) || strcasecmp(cmd_words[j], command_blacklist[i].words[j])) {\n\t\t\t\tmatch = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*! \\brief  Manager command \"command\" - execute CLI command */\nstatic int action_command(struct mansession *s, const struct message *m)\n{\n\tconst char *cmd = astman_get_header(m, \"Command\");\n\tchar *buf = NULL, *final_buf = NULL, *delim, *output;\n\tchar template[] = \"/tmp/ast-ami-XXXXXX\";\t/* template for temporary file */\n\tint fd, ret;\n\toff_t len;\n\n\tif (ast_strlen_zero(cmd)) {\n\t\tastman_send_error(s, m, \"No command provided\");\n\t\treturn 0;\n\t}\n\n\tif (check_blacklist(cmd)) {\n\t\tastman_send_error(s, m, \"Command blacklisted\");\n\t\treturn 0;\n\t}\n\n\tif ((fd = mkstemp(template)) < 0) {\n\t\tastman_send_error_va(s, m, \"Failed to create temporary file: %s\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tret = ast_cli_command(fd, cmd);\n\tastman_send_response_full(s, m, ret == RESULT_SUCCESS ? \"Success\" : \"Error\", MSG_MOREDATA, NULL);\n\n\t/* Determine number of characters available */\n\tif ((len = lseek(fd, 0, SEEK_END)) < 0) {\n\t\tastman_append(s, \"Message: Failed to determine number of characters: %s\\r\\n\", strerror(errno));\n\t\tgoto action_command_cleanup;\n\t}\n\n\t/* This has a potential to overflow the stack.  Hence, use the heap. */\n\tbuf = ast_malloc(len + 1);\n\tfinal_buf = ast_malloc(len + 1);\n\n\tif (!buf || !final_buf) {\n\t\tastman_append(s, \"Message: Memory allocation failure\\r\\n\");\n\t\tgoto action_command_cleanup;\n\t}\n\n\tif (lseek(fd, 0, SEEK_SET) < 0) {\n\t\tastman_append(s, \"Message: Failed to set position on temporary file: %s\\r\\n\", strerror(errno));\n\t\tgoto action_command_cleanup;\n\t}\n\n\tif (read(fd, buf, len) < 0) {\n\t\tastman_append(s, \"Message: Failed to read from temporary file: %s\\r\\n\", strerror(errno));\n\t\tgoto action_command_cleanup;\n\t}\n\n\tbuf[len] = '\\0';\n\tterm_strip(final_buf, buf, len);\n\tfinal_buf[len] = '\\0';\n\n\t/* Trim trailing newline */\n\tif (len && final_buf[len - 1] == '\\n') {\n\t\tfinal_buf[len - 1] = '\\0';\n\t}\n\n\tastman_append(s, \"Message: Command output follows\\r\\n\");\n\n\tdelim = final_buf;\n\twhile ((output = strsep(&delim, \"\\n\"))) {\n\t\tastman_append(s, \"Output: %s\\r\\n\", output);\n\t}\n\naction_command_cleanup:\n\tastman_append(s, \"\\r\\n\");\n\n\tclose(fd);\n\tunlink(template);\n\n\tast_free(buf);\n\tast_free(final_buf);\n\n\treturn 0;\n}\n\n/*! \\brief helper function for originate */\nstruct fast_originate_helper {\n\tint timeout;\n\tstruct ast_format_cap *cap;\t\t\t\t/*!< Codecs used for a call */\n\tint early_media;\n\tAST_DECLARE_STRING_FIELDS (\n\t\tAST_STRING_FIELD(tech);\n\t\t/*! data can contain a channel name, extension number, username, password, etc. */\n\t\tAST_STRING_FIELD(data);\n\t\tAST_STRING_FIELD(app);\n\t\tAST_STRING_FIELD(appdata);\n\t\tAST_STRING_FIELD(cid_name);\n\t\tAST_STRING_FIELD(cid_num);\n\t\tAST_STRING_FIELD(context);\n\t\tAST_STRING_FIELD(exten);\n\t\tAST_STRING_FIELD(idtext);\n\t\tAST_STRING_FIELD(account);\n\t\tAST_STRING_FIELD(channelid);\n\t\tAST_STRING_FIELD(otherchannelid);\n\t);\n\tint priority;\n\tstruct ast_variable *vars;\n};\n\n/*!\n * \\internal\n *\n * \\param doomed Struct to destroy.\n */\nstatic void destroy_fast_originate_helper(struct fast_originate_helper *doomed)\n{\n\tao2_cleanup(doomed->cap);\n\tast_variables_destroy(doomed->vars);\n\tast_string_field_free_memory(doomed);\n\tast_free(doomed);\n}\n\nstatic void *fast_originate(void *data)\n{\n\tstruct fast_originate_helper *in = data;\n\tint res;\n\tint reason = 0;\n\tstruct ast_channel *chan = NULL, *chans[1];\n\tchar requested_channel[AST_CHANNEL_NAME];\n\tstruct ast_assigned_ids assignedids = {\n\t\t.uniqueid = in->channelid,\n\t\t.uniqueid2 = in->otherchannelid\n\t};\n\n\tif (!ast_strlen_zero(in->app)) {\n\t\tres = ast_pbx_outgoing_app(in->tech, in->cap, in->data,\n\t\t\tin->timeout, in->app, in->appdata, &reason,\n\t\t\tAST_OUTGOING_WAIT,\n\t\t\tS_OR(in->cid_num, NULL),\n\t\t\tS_OR(in->cid_name, NULL),\n\t\t\tin->vars, in->account, &chan, &assignedids);\n\t} else {\n\t\tres = ast_pbx_outgoing_exten(in->tech, in->cap, in->data,\n\t\t\tin->timeout, in->context, in->exten, in->priority, &reason,\n\t\t\tAST_OUTGOING_WAIT,\n\t\t\tS_OR(in->cid_num, NULL),\n\t\t\tS_OR(in->cid_name, NULL),\n\t\t\tin->vars, in->account, &chan, in->early_media, &assignedids);\n\t}\n\n\tif (!chan) {\n\t\tsnprintf(requested_channel, AST_CHANNEL_NAME, \"%s/%s\", in->tech, in->data);\n\t}\n\t/* Tell the manager what happened with the channel */\n\tchans[0] = chan;\n\tif (!ast_strlen_zero(in->app)) {\n\t\tast_manager_event_multichan(EVENT_FLAG_CALL, \"OriginateResponse\", chan ? 1 : 0, chans,\n\t\t\t\"%s\"\n\t\t\t\"Response: %s\\r\\n\"\n\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\"Application: %s\\r\\n\"\n\t\t\t\"Data: %s\\r\\n\"\n\t\t\t\"Reason: %d\\r\\n\"\n\t\t\t\"Uniqueid: %s\\r\\n\"\n\t\t\t\"CallerIDNum: %s\\r\\n\"\n\t\t\t\"CallerIDName: %s\\r\\n\",\n\t\t\tin->idtext, res ? \"Failure\" : \"Success\",\n\t\t\tchan ? ast_channel_name(chan) : requested_channel,\n\t\t\tin->app, in->appdata, reason,\n\t\t\tchan ? ast_channel_uniqueid(chan) : S_OR(in->channelid, \"<unknown>\"),\n\t\t\tS_OR(in->cid_num, \"<unknown>\"),\n\t\t\tS_OR(in->cid_name, \"<unknown>\")\n\t\t\t);\n\t} else {\n\t\tast_manager_event_multichan(EVENT_FLAG_CALL, \"OriginateResponse\", chan ? 1 : 0, chans,\n\t\t\t\"%s\"\n\t\t\t\"Response: %s\\r\\n\"\n\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\"Context: %s\\r\\n\"\n\t\t\t\"Exten: %s\\r\\n\"\n\t\t\t\"Reason: %d\\r\\n\"\n\t\t\t\"Uniqueid: %s\\r\\n\"\n\t\t\t\"CallerIDNum: %s\\r\\n\"\n\t\t\t\"CallerIDName: %s\\r\\n\",\n\t\t\tin->idtext, res ? \"Failure\" : \"Success\",\n\t\t\tchan ? ast_channel_name(chan) : requested_channel,\n\t\t\tin->context, in->exten, reason,\n\t\t\tchan ? ast_channel_uniqueid(chan) : S_OR(in->channelid, \"<unknown>\"),\n\t\t\tS_OR(in->cid_num, \"<unknown>\"),\n\t\t\tS_OR(in->cid_name, \"<unknown>\")\n\t\t\t);\n\t}\n\n\t/* Locked and ref'd by ast_pbx_outgoing_exten or ast_pbx_outgoing_app */\n\tif (chan) {\n\t\tast_channel_unlock(chan);\n\t\tast_channel_unref(chan);\n\t}\n\tdestroy_fast_originate_helper(in);\n\treturn NULL;\n}\n\nstatic int aocmessage_get_unit_entry(const struct message *m, struct ast_aoc_unit_entry *entry, unsigned int entry_num)\n{\n\tconst char *unitamount;\n\tconst char *unittype;\n\tstruct ast_str *str = ast_str_alloca(32);\n\n\tmemset(entry, 0, sizeof(*entry));\n\n\tast_str_set(&str, 0, \"UnitAmount(%u)\", entry_num);\n\tunitamount = astman_get_header(m, ast_str_buffer(str));\n\n\tast_str_set(&str, 0, \"UnitType(%u)\", entry_num);\n\tunittype = astman_get_header(m, ast_str_buffer(str));\n\n\tif (!ast_strlen_zero(unitamount) && (sscanf(unitamount, \"%30u\", &entry->amount) == 1)) {\n\t\tentry->valid_amount = 1;\n\t}\n\n\tif (!ast_strlen_zero(unittype) && sscanf(unittype, \"%30u\", &entry->type) == 1) {\n\t\tentry->valid_type = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ast_aoc_decoded *action_aoc_de_message(struct mansession *s, const struct message *m)\n{\n\tconst char *msgtype = astman_get_header(m, \"MsgType\");\n\tconst char *chargetype = astman_get_header(m, \"ChargeType\");\n\tconst char *currencyname = astman_get_header(m, \"CurrencyName\");\n\tconst char *currencyamount = astman_get_header(m, \"CurrencyAmount\");\n\tconst char *mult = astman_get_header(m, \"CurrencyMultiplier\");\n\tconst char *totaltype = astman_get_header(m, \"TotalType\");\n\tconst char *aocbillingid = astman_get_header(m, \"AOCBillingId\");\n\tconst char *association_id= astman_get_header(m, \"ChargingAssociationId\");\n\tconst char *association_num = astman_get_header(m, \"ChargingAssociationNumber\");\n\tconst char *association_plan = astman_get_header(m, \"ChargingAssociationPlan\");\n\n\tenum ast_aoc_type _msgtype;\n\tenum ast_aoc_charge_type _chargetype;\n\tenum ast_aoc_currency_multiplier _mult = AST_AOC_MULT_ONE;\n\tenum ast_aoc_total_type _totaltype = AST_AOC_TOTAL;\n\tenum ast_aoc_billing_id _billingid = AST_AOC_BILLING_NA;\n\tunsigned int _currencyamount = 0;\n\tint _association_id = 0;\n\tunsigned int _association_plan = 0;\n\n\tstruct ast_aoc_decoded *decoded = NULL;\n\n\tif (ast_strlen_zero(chargetype)) {\n\t\tastman_send_error(s, m, \"ChargeType not specified\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\t_msgtype = strcasecmp(msgtype, \"d\") ? AST_AOC_E : AST_AOC_D;\n\n\tif (!strcasecmp(chargetype, \"NA\")) {\n\t\t_chargetype = AST_AOC_CHARGE_NA;\n\t} else if (!strcasecmp(chargetype, \"Free\")) {\n\t\t_chargetype = AST_AOC_CHARGE_FREE;\n\t} else if (!strcasecmp(chargetype, \"Currency\")) {\n\t\t_chargetype = AST_AOC_CHARGE_CURRENCY;\n\t} else if (!strcasecmp(chargetype, \"Unit\")) {\n\t\t_chargetype = AST_AOC_CHARGE_UNIT;\n\t} else {\n\t\tastman_send_error(s, m, \"Invalid ChargeType\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (_chargetype == AST_AOC_CHARGE_CURRENCY) {\n\n\t\tif (ast_strlen_zero(currencyamount) || (sscanf(currencyamount, \"%30u\", &_currencyamount) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid CurrencyAmount, CurrencyAmount is a required when ChargeType is Currency\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (ast_strlen_zero(mult)) {\n\t\t\tastman_send_error(s, m, \"ChargeMultiplier unspecified, ChargeMultiplier is required when ChargeType is Currency.\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t} else if (!strcasecmp(mult, \"onethousandth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONETHOUSANDTH;\n\t\t} else if (!strcasecmp(mult, \"onehundredth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONEHUNDREDTH;\n\t\t} else if (!strcasecmp(mult, \"onetenth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONETENTH;\n\t\t} else if (!strcasecmp(mult, \"one\")) {\n\t\t\t_mult = AST_AOC_MULT_ONE;\n\t\t} else if (!strcasecmp(mult, \"ten\")) {\n\t\t\t_mult = AST_AOC_MULT_TEN;\n\t\t} else if (!strcasecmp(mult, \"hundred\")) {\n\t\t\t_mult = AST_AOC_MULT_HUNDRED;\n\t\t} else if (!strcasecmp(mult, \"thousand\")) {\n\t\t\t_mult = AST_AOC_MULT_THOUSAND;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid ChargeMultiplier\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\t/* create decoded object and start setting values */\n\tif (!(decoded = ast_aoc_create(_msgtype, _chargetype, 0))) {\n\t\t\tastman_send_error(s, m, \"Message Creation Failed\");\n\t\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (_msgtype == AST_AOC_D) {\n\t\tif (!ast_strlen_zero(totaltype) && !strcasecmp(totaltype, \"subtotal\")) {\n\t\t\t_totaltype = AST_AOC_SUBTOTAL;\n\t\t}\n\n\t\tif (ast_strlen_zero(aocbillingid)) {\n\t\t\t/* ignore this is optional */\n\t\t} else if (!strcasecmp(aocbillingid, \"Normal\")) {\n\t\t\t_billingid = AST_AOC_BILLING_NORMAL;\n\t\t} else if (!strcasecmp(aocbillingid, \"ReverseCharge\")) {\n\t\t\t_billingid = AST_AOC_BILLING_REVERSE_CHARGE;\n\t\t} else if (!strcasecmp(aocbillingid, \"CreditCard\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CREDIT_CARD;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid AOC-D AOCBillingId\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t} else {\n\t\tif (ast_strlen_zero(aocbillingid)) {\n\t\t\t/* ignore this is optional */\n\t\t} else if (!strcasecmp(aocbillingid, \"Normal\")) {\n\t\t\t_billingid = AST_AOC_BILLING_NORMAL;\n\t\t} else if (!strcasecmp(aocbillingid, \"ReverseCharge\")) {\n\t\t\t_billingid = AST_AOC_BILLING_REVERSE_CHARGE;\n\t\t} else if (!strcasecmp(aocbillingid, \"CreditCard\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CREDIT_CARD;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallFwdUnconditional\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_FWD_UNCONDITIONAL;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallFwdBusy\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_FWD_BUSY;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallFwdNoReply\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_FWD_NO_REPLY;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallDeflection\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_DEFLECTION;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallTransfer\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_TRANSFER;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid AOC-E AOCBillingId\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (!ast_strlen_zero(association_id) && (sscanf(association_id, \"%30d\", &_association_id) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid ChargingAssociationId\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t\tif (!ast_strlen_zero(association_plan) && (sscanf(association_plan, \"%30u\", &_association_plan) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid ChargingAssociationPlan\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (_association_id) {\n\t\t\tast_aoc_set_association_id(decoded, _association_id);\n\t\t} else if (!ast_strlen_zero(association_num)) {\n\t\t\tast_aoc_set_association_number(decoded, association_num, _association_plan);\n\t\t}\n\t}\n\n\tif (_chargetype == AST_AOC_CHARGE_CURRENCY) {\n\t\tast_aoc_set_currency_info(decoded, _currencyamount, _mult, ast_strlen_zero(currencyname) ? NULL : currencyname);\n\t} else if (_chargetype == AST_AOC_CHARGE_UNIT) {\n\t\tstruct ast_aoc_unit_entry entry;\n\t\tint i;\n\n\t\t/* multiple unit entries are possible, lets get them all */\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tif (aocmessage_get_unit_entry(m, &entry, i)) {\n\t\t\t\tbreak; /* that's the end then */\n\t\t\t}\n\n\t\t\tast_aoc_add_unit_entry(decoded, entry.valid_amount, entry.amount, entry.valid_type, entry.type);\n\t\t}\n\n\t\t/* at least one unit entry is required */\n\t\tif (!i) {\n\t\t\tastman_send_error(s, m, \"Invalid UnitAmount(0), At least one valid unit entry is required when ChargeType is set to Unit\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t}\n\n\tast_aoc_set_billing_id(decoded, _billingid);\n\tast_aoc_set_total_type(decoded, _totaltype);\n\n\treturn decoded;\n\naocmessage_cleanup:\n\n\tast_aoc_destroy_decoded(decoded);\n\treturn NULL;\n}\n\nstatic int action_aoc_s_submessage(struct mansession *s, const struct message *m,\n\t\tstruct ast_aoc_decoded *decoded)\n{\n\tconst char *chargeditem = __astman_get_header(m, \"ChargedItem\", GET_HEADER_LAST_MATCH);\n\tconst char *ratetype = __astman_get_header(m, \"RateType\", GET_HEADER_LAST_MATCH);\n\tconst char *currencyname = __astman_get_header(m, \"CurrencyName\", GET_HEADER_LAST_MATCH);\n\tconst char *currencyamount = __astman_get_header(m, \"CurrencyAmount\", GET_HEADER_LAST_MATCH);\n\tconst char *mult = __astman_get_header(m, \"CurrencyMultiplier\", GET_HEADER_LAST_MATCH);\n\tconst char *time = __astman_get_header(m, \"Time\", GET_HEADER_LAST_MATCH);\n\tconst char *timescale = __astman_get_header(m, \"TimeScale\", GET_HEADER_LAST_MATCH);\n\tconst char *granularity = __astman_get_header(m, \"Granularity\", GET_HEADER_LAST_MATCH);\n\tconst char *granularitytimescale = __astman_get_header(m, \"GranularityTimeScale\", GET_HEADER_LAST_MATCH);\n\tconst char *chargingtype = __astman_get_header(m, \"ChargingType\", GET_HEADER_LAST_MATCH);\n\tconst char *volumeunit = __astman_get_header(m, \"VolumeUnit\", GET_HEADER_LAST_MATCH);\n\tconst char *code = __astman_get_header(m, \"Code\", GET_HEADER_LAST_MATCH);\n\n\tenum ast_aoc_s_charged_item _chargeditem;\n\tenum ast_aoc_s_rate_type _ratetype;\n\tenum ast_aoc_currency_multiplier _mult = AST_AOC_MULT_ONE;\n\tunsigned int _currencyamount = 0;\n\tunsigned int _code;\n\tunsigned int _time = 0;\n\tenum ast_aoc_time_scale _scale = 0;\n\tunsigned int _granularity = 0;\n\tenum ast_aoc_time_scale _granularity_time_scale = AST_AOC_TIME_SCALE_MINUTE;\n\tint _step = 0;\n\tenum ast_aoc_volume_unit _volumeunit = 0;\n\n\tif (ast_strlen_zero(chargeditem)) {\n\t\tastman_send_error(s, m, \"ChargedItem not specified\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (ast_strlen_zero(ratetype)) {\n\t\tastman_send_error(s, m, \"RateType not specified\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (!strcasecmp(chargeditem, \"NA\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_NA;\n\t} else if (!strcasecmp(chargeditem, \"SpecialArrangement\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_SPECIAL_ARRANGEMENT;\n\t} else if (!strcasecmp(chargeditem, \"BasicCommunication\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_BASIC_COMMUNICATION;\n\t} else if (!strcasecmp(chargeditem, \"CallAttempt\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_CALL_ATTEMPT;\n\t} else if (!strcasecmp(chargeditem, \"CallSetup\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_CALL_SETUP;\n\t} else if (!strcasecmp(chargeditem, \"UserUserInfo\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_USER_USER_INFO;\n\t} else if (!strcasecmp(chargeditem, \"SupplementaryService\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_SUPPLEMENTARY_SERVICE;\n\t} else {\n\t\tastman_send_error(s, m, \"Invalid ChargedItem\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (!strcasecmp(ratetype, \"NA\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_NA;\n\t} else if (!strcasecmp(ratetype, \"Free\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_FREE;\n\t} else if (!strcasecmp(ratetype, \"FreeFromBeginning\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_FREE_FROM_BEGINNING;\n\t} else if (!strcasecmp(ratetype, \"Duration\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_DURATION;\n\t} else if (!strcasecmp(ratetype, \"Flat\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_FLAT;\n\t} else if (!strcasecmp(ratetype, \"Volume\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_VOLUME;\n\t} else if (!strcasecmp(ratetype, \"SpecialCode\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_SPECIAL_CODE;\n\t} else {\n\t\tastman_send_error(s, m, \"Invalid RateType\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (_ratetype > AST_AOC_RATE_TYPE_FREE_FROM_BEGINNING) {\n\t\tif (ast_strlen_zero(currencyamount) || (sscanf(currencyamount, \"%30u\",\n\t\t\t\t&_currencyamount) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid CurrencyAmount, CurrencyAmount is a required when RateType is non-free\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (ast_strlen_zero(mult)) {\n\t\t\tastman_send_error(s, m, \"ChargeMultiplier unspecified, ChargeMultiplier is required when ChargeType is Currency.\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t} else if (!strcasecmp(mult, \"onethousandth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONETHOUSANDTH;\n\t\t} else if (!strcasecmp(mult, \"onehundredth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONEHUNDREDTH;\n\t\t} else if (!strcasecmp(mult, \"onetenth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONETENTH;\n\t\t} else if (!strcasecmp(mult, \"one\")) {\n\t\t\t_mult = AST_AOC_MULT_ONE;\n\t\t} else if (!strcasecmp(mult, \"ten\")) {\n\t\t\t_mult = AST_AOC_MULT_TEN;\n\t\t} else if (!strcasecmp(mult, \"hundred\")) {\n\t\t\t_mult = AST_AOC_MULT_HUNDRED;\n\t\t} else if (!strcasecmp(mult, \"thousand\")) {\n\t\t\t_mult = AST_AOC_MULT_THOUSAND;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid ChargeMultiplier\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\tif (_ratetype == AST_AOC_RATE_TYPE_DURATION) {\n\t\tif (ast_strlen_zero(timescale)) {\n\t\t\tastman_send_error(s, m, \"TimeScale unspecified, TimeScale is required when RateType is Duration.\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t} else if (!strcasecmp(timescale, \"onehundredthsecond\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_HUNDREDTH_SECOND;\n\t\t} else if (!strcasecmp(timescale, \"onetenthsecond\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_TENTH_SECOND;\n\t\t} else if (!strcasecmp(timescale, \"second\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_SECOND;\n\t\t} else if (!strcasecmp(timescale, \"tenseconds\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_TEN_SECOND;\n\t\t} else if (!strcasecmp(timescale, \"minute\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_MINUTE;\n\t\t} else if (!strcasecmp(timescale, \"hour\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_HOUR;\n\t\t} else if (!strcasecmp(timescale, \"day\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_DAY;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid TimeScale\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (ast_strlen_zero(time) || (sscanf(time, \"%30u\", &_time) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid Time, Time is a required when RateType is Duration\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (!ast_strlen_zero(granularity)) {\n\t\t\tif ((sscanf(time, \"%30u\", &_granularity) != 1)) {\n\t\t\t\tastman_send_error(s, m, \"Invalid Granularity\");\n\t\t\t\tgoto aocmessage_cleanup;\n\t\t\t}\n\n\t\t\tif (ast_strlen_zero(granularitytimescale)) {\n\t\t\t\tastman_send_error(s, m, \"Invalid GranularityTimeScale, GranularityTimeScale is a required when Granularity is specified\");\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"onehundredthsecond\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_HUNDREDTH_SECOND;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"onetenthsecond\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_TENTH_SECOND;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"second\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_SECOND;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"tenseconds\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_TEN_SECOND;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"minute\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_MINUTE;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"hour\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_HOUR;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"day\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_DAY;\n\t\t\t} else {\n\t\t\t\tastman_send_error(s, m, \"Invalid GranularityTimeScale\");\n\t\t\t\tgoto aocmessage_cleanup;\n\t\t\t}\n\t\t}\n\n\t\tif (ast_strlen_zero(chargingtype) || strcasecmp(chargingtype, \"continuouscharging\") == 0) {\n\t\t\t_step = 0;\n\t\t} else if (strcasecmp(chargingtype, \"stepfunction\") == 0 ) {\n\t\t\t_step = 1;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid ChargingType\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\tif (_ratetype == AST_AOC_RATE_TYPE_VOLUME) {\n\t\tif (ast_strlen_zero(volumeunit)) {\n\t\t\tastman_send_error(s, m, \"VolumeUnit unspecified, VolumeUnit is required when RateType is Volume.\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t} else if (!strcasecmp(timescale, \"octet\")) {\n\t\t\t_volumeunit = AST_AOC_VOLUME_UNIT_OCTET;\n\t\t} else if (!strcasecmp(timescale, \"segment\")) {\n\t\t\t_volumeunit = AST_AOC_VOLUME_UNIT_SEGMENT;\n\t\t} else if (!strcasecmp(timescale, \"message\")) {\n\t\t\t_volumeunit = AST_AOC_VOLUME_UNIT_MESSAGE;\n\t\t}else {\n\t\t\tastman_send_error(s, m, \"Invalid VolumeUnit\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\tif (_chargeditem == AST_AOC_CHARGED_ITEM_SPECIAL_ARRANGEMENT\n\t\t\t|| _ratetype == AST_AOC_RATE_TYPE_SPECIAL_CODE) {\n\t\tif (ast_strlen_zero(code) || (sscanf(code, \"%30u\", &_code) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid Code, Code is a required when ChargedItem is SpecialArrangement and when RateType is SpecialCode\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\tif (_chargeditem == AST_AOC_CHARGED_ITEM_SPECIAL_ARRANGEMENT) {\n\t\tast_aoc_s_add_special_arrangement(decoded, _code);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_DURATION) {\n\t\tast_aoc_s_add_rate_duration(decoded, _chargeditem, _currencyamount, _mult,\n\t\t\tcurrencyname, _time, _scale, _granularity, _granularity_time_scale, _step);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_FLAT) {\n\t\tast_aoc_s_add_rate_flat(decoded, _chargeditem, _currencyamount, _mult,\n\t\t\t\tcurrencyname);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_VOLUME) {\n\t\tast_aoc_s_add_rate_volume(decoded, _chargeditem, _volumeunit, _currencyamount,\n\t\t\t_mult, currencyname);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_SPECIAL_CODE) {\n\t\tast_aoc_s_add_rate_special_charge_code(decoded, _chargeditem, _code);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_FREE) {\n\t\tast_aoc_s_add_rate_free(decoded, _chargeditem, 0);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_FREE_FROM_BEGINNING) {\n\t\tast_aoc_s_add_rate_free(decoded, _chargeditem, 1);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_NA) {\n\t\tast_aoc_s_add_rate_na(decoded, _chargeditem);\n\t}\n\n\treturn 0;\n\naocmessage_cleanup:\n\n\treturn -1;\n}\n\nstatic struct ast_aoc_decoded *action_aoc_s_message(struct mansession *s,\n\t\tconst struct message *m)\n{\n\tstruct ast_aoc_decoded *decoded = NULL;\n\tint hdrlen;\n\tint x;\n\tstatic const char hdr[] = \"ChargedItem:\";\n\tstruct message sm = { 0 };\n\tint rates = 0;\n\n\tif (!(decoded = ast_aoc_create(AST_AOC_S, 0, 0))) {\n\t\tastman_send_error(s, m, \"Message Creation Failed\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\thdrlen = strlen(hdr);\n\tfor (x = 0; x < m->hdrcount; x++) {\n\t\tif (strncasecmp(hdr, m->headers[x], hdrlen) == 0) {\n\t\t\tif (rates > ast_aoc_s_get_count(decoded)) {\n\t\t\t\tif (action_aoc_s_submessage(s, &sm, decoded) == -1) {\n\t\t\t\t\tgoto aocmessage_cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++rates;\n\t\t}\n\n\t\tsm.headers[sm.hdrcount] = m->headers[x];\n\t\t++sm.hdrcount;\n\t}\n\tif (rates > ast_aoc_s_get_count(decoded)) {\n\t\tif (action_aoc_s_submessage(s, &sm, decoded) == -1) {\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\treturn decoded;\n\naocmessage_cleanup:\n\n\tast_aoc_destroy_decoded(decoded);\n\treturn NULL;\n}\n\nstatic int action_aocmessage(struct mansession *s, const struct message *m)\n{\n\tconst char *msgtype = astman_get_header(m, \"MsgType\");\n\tconst char *channel = astman_get_header(m, \"Channel\");\n\tconst char *pchannel = astman_get_header(m, \"ChannelPrefix\");\n\n\tstruct ast_channel *chan = NULL;\n\n\tstruct ast_aoc_decoded *decoded = NULL;\n\tstruct ast_aoc_encoded *encoded = NULL;\n\tsize_t encoded_size = 0;\n\n\tif (ast_strlen_zero(channel) && ast_strlen_zero(pchannel)) {\n\t\tastman_send_error(s, m, \"Channel and PartialChannel are not specified. Specify at least one of these.\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (!(chan = ast_channel_get_by_name(channel)) && !ast_strlen_zero(pchannel)) {\n\t\tchan = ast_channel_get_by_name_prefix(pchannel, strlen(pchannel));\n\t}\n\n\tif (!chan) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (strcasecmp(msgtype, \"d\") == 0 || strcasecmp(msgtype, \"e\") == 0) {\n\t\tdecoded = action_aoc_de_message(s, m);\n\t}\n\telse if (strcasecmp(msgtype, \"s\") == 0) {\n\t\tdecoded = action_aoc_s_message(s, m);\n\t}\n\telse {\n\t\tastman_send_error(s, m, \"Invalid MsgType\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (!decoded) {\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif ((encoded = ast_aoc_encode(decoded, &encoded_size, chan))\n\t\t\t&& !ast_indicate_data(chan, AST_CONTROL_AOC, encoded, encoded_size)) {\n\t\tastman_send_ack(s, m, \"AOC Message successfully queued on channel\");\n\t} else {\n\t\tastman_send_error(s, m, \"Error encoding AOC message, could not queue onto channel\");\n\t}\n\naocmessage_cleanup:\n\n\tast_aoc_destroy_decoded(decoded);\n\tast_aoc_destroy_encoded(encoded);\n\n\tif (chan) {\n\t\tchan = ast_channel_unref(chan);\n\t}\n\treturn 0;\n}\n\nstatic int action_originate(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tconst char *priority = astman_get_header(m, \"Priority\");\n\tconst char *timeout = astman_get_header(m, \"Timeout\");\n\tconst char *callerid = astman_get_header(m, \"CallerID\");\n\tconst char *account = astman_get_header(m, \"Account\");\n\tconst char *app = astman_get_header(m, \"Application\");\n\tconst char *appdata = astman_get_header(m, \"Data\");\n\tconst char *async = astman_get_header(m, \"Async\");\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tconst char *codecs = astman_get_header(m, \"Codecs\");\n\tconst char *early_media = astman_get_header(m, \"Earlymedia\");\n\tstruct ast_assigned_ids assignedids = {\n\t\t.uniqueid = astman_get_header(m, \"ChannelId\"),\n\t\t.uniqueid2 = astman_get_header(m, \"OtherChannelId\"),\n\t};\n\tstruct ast_variable *vars = NULL;\n\tchar *tech, *data;\n\tchar *l = NULL, *n = NULL;\n\tint pi = 0;\n\tint res;\n\tint to = 30000;\n\tint reason = 0;\n\tchar tmp[256];\n\tchar tmp2[256];\n\tstruct ast_format_cap *cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\tpthread_t th;\n\tint bridge_early = 0;\n\n\tif (!cap) {\n\t\tastman_send_error(s, m, \"Internal Error. Memory allocation failure.\");\n\t\treturn 0;\n\t}\n\tast_format_cap_append(cap, ast_format_slin, 0);\n\n\tif ((assignedids.uniqueid && AST_MAX_PUBLIC_UNIQUEID < strlen(assignedids.uniqueid))\n\t\t|| (assignedids.uniqueid2 && AST_MAX_PUBLIC_UNIQUEID < strlen(assignedids.uniqueid2))) {\n\t\tastman_send_error_va(s, m, \"Uniqueid length exceeds maximum of %d\\n\",\n\t\t\tAST_MAX_PUBLIC_UNIQUEID);\n\t\tres = 0;\n\t\tgoto fast_orig_cleanup;\n\t}\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"Channel not specified\");\n\t\tres = 0;\n\t\tgoto fast_orig_cleanup;\n\t}\n\tif (!ast_strlen_zero(priority) && (sscanf(priority, \"%30d\", &pi) != 1)) {\n\t\tif ((pi = ast_findlabel_extension(NULL, context, exten, priority, NULL)) < 1) {\n\t\t\tastman_send_error(s, m, \"Invalid priority\");\n\t\t\tres = 0;\n\t\t\tgoto fast_orig_cleanup;\n\t\t}\n\t}\n\tif (!ast_strlen_zero(timeout) && (sscanf(timeout, \"%30d\", &to) != 1)) {\n\t\tastman_send_error(s, m, \"Invalid timeout\");\n\t\tres = 0;\n\t\tgoto fast_orig_cleanup;\n\t}\n\tast_copy_string(tmp, name, sizeof(tmp));\n\ttech = tmp;\n\tdata = strchr(tmp, '/');\n\tif (!data) {\n\t\tastman_send_error(s, m, \"Invalid channel\");\n\t\tres = 0;\n\t\tgoto fast_orig_cleanup;\n\t}\n\t*data++ = '\\0';\n\tast_copy_string(tmp2, callerid, sizeof(tmp2));\n\tast_callerid_parse(tmp2, &n, &l);\n\tif (n) {\n\t\tif (ast_strlen_zero(n)) {\n\t\t\tn = NULL;\n\t\t}\n\t}\n\tif (l) {\n\t\tast_shrink_phone_number(l);\n\t\tif (ast_strlen_zero(l)) {\n\t\t\tl = NULL;\n\t\t}\n\t}\n\tif (!ast_strlen_zero(codecs)) {\n\t\tast_format_cap_remove_by_type(cap, AST_MEDIA_TYPE_UNKNOWN);\n\t\tast_format_cap_update_by_allow_disallow(cap, codecs, 1);\n\t}\n\n\tif (!ast_strlen_zero(app) && s->session) {\n\t\tint bad_appdata = 0;\n\t\t/* To run the System application (or anything else that goes to\n\t\t * shell), you must have the additional System privilege */\n\t\tif (!(s->session->writeperm & EVENT_FLAG_SYSTEM)\n\t\t\t&& (\n\t\t\t\tstrcasestr(app, \"system\") ||      /* System(rm -rf /)\n\t\t\t\t                                     TrySystem(rm -rf /)       */\n\t\t\t\tstrcasestr(app, \"exec\") ||        /* Exec(System(rm -rf /))\n\t\t\t\t                                     TryExec(System(rm -rf /)) */\n\t\t\t\tstrcasestr(app, \"agi\") ||         /* AGI(/bin/rm,-rf /)\n\t\t\t\t                                     EAGI(/bin/rm,-rf /)       */\n\t\t\t\tstrcasestr(app, \"mixmonitor\") ||  /* MixMonitor(blah,,rm -rf)  */\n\t\t\t\tstrcasestr(app, \"externalivr\") || /* ExternalIVR(rm -rf)       */\n\t\t\t\tstrcasestr(app, \"originate\") ||   /* Originate(Local/1234,app,System,rm -rf) */\n\t\t\t\t(strstr(appdata, \"SHELL\") && (bad_appdata = 1)) ||       /* NoOp(${SHELL(rm -rf /)})  */\n\t\t\t\t(strstr(appdata, \"EVAL\") && (bad_appdata = 1))           /* NoOp(${EVAL(${some_var_containing_SHELL})}) */\n\t\t\t\t)) {\n\t\t\tchar error_buf[64];\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Originate Access Forbidden: %s\", bad_appdata ? \"Data\" : \"Application\");\n\t\t\tastman_send_error(s, m, error_buf);\n\t\t\tres = 0;\n\t\t\tgoto fast_orig_cleanup;\n\t\t}\n\t}\n\n\t/* Check early if the extension exists. If not, we need to bail out here. */\n\tif (exten && context && pi) {\n\t\tif (! ast_exists_extension(NULL, context, exten, pi, l)) {\n\t\t\t/* The extension does not exist. */\n\t\t\tastman_send_error(s, m, \"Extension does not exist.\");\n\t\t\tres = 0;\n\t\t\tgoto fast_orig_cleanup;\n\t\t}\n\t}\n\n\t/* Allocate requested channel variables */\n\tvars = astman_get_variables(m);\n\tif (s->session && s->session->chanvars) {\n\t\tstruct ast_variable *v, *old;\n\t\told = vars;\n\t\tvars = NULL;\n\n\t\t/* The variables in the AMI originate action are appended at the end of the list, to override any user variables that apply */\n\n\t\tvars = ast_variables_dup(s->session->chanvars);\n\t\tif (old) {\n\t\t\tfor (v = vars; v->next; v = v->next );\n\t\t\tv->next = old;\t/* Append originate variables at end of list */\n\t\t}\n\t}\n\n\t/* For originate async - we can bridge in early media stage */\n\tbridge_early = ast_true(early_media);\n\n\tif (ast_true(async)) {\n\t\tstruct fast_originate_helper *fast;\n\n\t\tfast = ast_calloc(1, sizeof(*fast));\n\t\tif (!fast || ast_string_field_init(fast, 252)) {\n\t\t\tast_free(fast);\n\t\t\tast_variables_destroy(vars);\n\t\t\tres = -1;\n\t\t} else {\n\t\t\tif (!ast_strlen_zero(id)) {\n\t\t\t\tast_string_field_build(fast, idtext, \"ActionID: %s\\r\\n\", id);\n\t\t\t}\n\t\t\tast_string_field_set(fast, tech, tech);\n\t\t\tast_string_field_set(fast, data, data);\n\t\t\tast_string_field_set(fast, app, app);\n\t\t\tast_string_field_set(fast, appdata, appdata);\n\t\t\tast_string_field_set(fast, cid_num, l);\n\t\t\tast_string_field_set(fast, cid_name, n);\n\t\t\tast_string_field_set(fast, context, context);\n\t\t\tast_string_field_set(fast, exten, exten);\n\t\t\tast_string_field_set(fast, account, account);\n\t\t\tast_string_field_set(fast, channelid, assignedids.uniqueid);\n\t\t\tast_string_field_set(fast, otherchannelid, assignedids.uniqueid2);\n\t\t\tfast->vars = vars;\n\t\t\tfast->cap = cap;\n\t\t\tcap = NULL; /* transfered originate helper the capabilities structure.  It is now responsible for freeing it. */\n\t\t\tfast->timeout = to;\n\t\t\tfast->early_media = bridge_early;\n\t\t\tfast->priority = pi;\n\t\t\tif (ast_pthread_create_detached(&th, NULL, fast_originate, fast)) {\n\t\t\t\tdestroy_fast_originate_helper(fast);\n\t\t\t\tres = -1;\n\t\t\t} else {\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\t} else if (!ast_strlen_zero(app)) {\n\t\tres = ast_pbx_outgoing_app(tech, cap, data, to, app, appdata, &reason,\n\t\t\t\tAST_OUTGOING_WAIT, l, n, vars, account, NULL,\n\t\t\t\tassignedids.uniqueid ? &assignedids : NULL);\n\t\tast_variables_destroy(vars);\n\t} else {\n\t\tif (exten && context && pi) {\n\t\t\tres = ast_pbx_outgoing_exten(tech, cap, data, to,\n\t\t\t\t\tcontext, exten, pi, &reason, AST_OUTGOING_WAIT,\n\t\t\t\t\tl, n, vars, account, NULL, bridge_early,\n\t\t\t\t\tassignedids.uniqueid ? &assignedids : NULL);\n\t\t\tast_variables_destroy(vars);\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Originate with 'Exten' requires 'Context' and 'Priority'\");\n\t\t\tast_variables_destroy(vars);\n\t\t\tres = 0;\n\t\t\tgoto fast_orig_cleanup;\n\t\t}\n\t}\n\tif (!res) {\n\t\tastman_send_ack(s, m, \"Originate successfully queued\");\n\t} else {\n\t\tastman_send_error(s, m, \"Originate failed\");\n\t}\n\nfast_orig_cleanup:\n\tao2_cleanup(cap);\n\treturn 0;\n}\n\nstatic int action_mailboxstatus(struct mansession *s, const struct message *m)\n{\n\tconst char *mailbox = astman_get_header(m, \"Mailbox\");\n\tint ret;\n\n\tif (ast_strlen_zero(mailbox)) {\n\t\tastman_send_error(s, m, \"Mailbox not specified\");\n\t\treturn 0;\n\t}\n\tret = ast_app_has_voicemail(mailbox, NULL);\n\tastman_start_ack(s, m);\n\tastman_append(s, \"Message: Mailbox Status\\r\\n\"\n\t\t\t \"Mailbox: %s\\r\\n\"\n\t\t\t \"Waiting: %d\\r\\n\\r\\n\", mailbox, ret);\n\treturn 0;\n}\n\nstatic int action_mailboxcount(struct mansession *s, const struct message *m)\n{\n\tconst char *mailbox = astman_get_header(m, \"Mailbox\");\n\tint newmsgs = 0, oldmsgs = 0, urgentmsgs = 0;;\n\n\tif (ast_strlen_zero(mailbox)) {\n\t\tastman_send_error(s, m, \"Mailbox not specified\");\n\t\treturn 0;\n\t}\n\tast_app_inboxcount2(mailbox, &urgentmsgs, &newmsgs, &oldmsgs);\n\tastman_start_ack(s, m);\n\tastman_append(s,   \"Message: Mailbox Message Count\\r\\n\"\n\t\t\t   \"Mailbox: %s\\r\\n\"\n\t\t\t   \"UrgMessages: %d\\r\\n\"\n\t\t\t   \"NewMessages: %d\\r\\n\"\n\t\t\t   \"OldMessages: %d\\r\\n\"\n\t\t\t   \"\\r\\n\",\n\t\t\t   mailbox, urgentmsgs, newmsgs, oldmsgs);\n\treturn 0;\n}\n\nstatic int action_extensionstate(struct mansession *s, const struct message *m)\n{\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tchar hint[256];\n\tint status;\n\n\tif (ast_strlen_zero(exten)) {\n\t\tastman_send_error(s, m, \"Extension not specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(context)) {\n\t\tcontext = \"default\";\n\t}\n\tstatus = ast_extension_state(NULL, context, exten);\n\thint[0] = '\\0';\n\tast_get_hint(hint, sizeof(hint), NULL, 0, NULL, context, exten);\n\tastman_start_ack(s, m);\n\tastman_append(s, \"Message: Extension Status\\r\\n\"\n\t\t\"Exten: %s\\r\\n\"\n\t\t\"Context: %s\\r\\n\"\n\t\t\"Hint: %s\\r\\n\"\n\t\t\"Status: %d\\r\\n\"\n\t\t\"StatusText: %s\\r\\n\"\n\t\t\"\\r\\n\",\n\t\texten, context, hint, status,\n\t\tast_extension_state2str(status));\n\treturn 0;\n}\n\nstatic int action_presencestate(struct mansession *s, const struct message *m)\n{\n\tconst char *provider = astman_get_header(m, \"Provider\");\n\tenum ast_presence_state state;\n\tchar *subtype;\n\tchar *message;\n\n\tif (ast_strlen_zero(provider)) {\n\t\tastman_send_error(s, m, \"No provider specified\");\n\t\treturn 0;\n\t}\n\n\tstate = ast_presence_state(provider, &subtype, &message);\n\tif (state == AST_PRESENCE_INVALID) {\n\t\tastman_send_error_va(s, m, \"Invalid provider %s or provider in invalid state\", provider);\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\tastman_append(s, \"Message: Presence State\\r\\n\"\n\t                 \"State: %s\\r\\n\", ast_presence_state2str(state));\n\n\tif (!ast_strlen_zero(subtype)) {\n\t\tastman_append(s, \"Subtype: %s\\r\\n\", subtype);\n\t}\n\n\tif (!ast_strlen_zero(message)) {\n\t\t/* XXX The Message header here is deprecated as it\n\t\t * duplicates the action response header 'Message'.\n\t\t * Remove it in the next major revision of AMI.\n\t\t */\n\t\tastman_append(s, \"Message: %s\\r\\n\"\n\t\t                 \"PresenceMessage: %s\\r\\n\",\n\t\t                 message, message);\n\t}\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\nstatic int action_timeout(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tdouble timeout = atof(astman_get_header(m, \"Timeout\"));\n\tstruct timeval when = { timeout, 0 };\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (!timeout || timeout < 0) {\n\t\tastman_send_error(s, m, \"No timeout specified\");\n\t\treturn 0;\n\t}\n\n\tif (!(c = ast_channel_get_by_name(name))) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\treturn 0;\n\t}\n\n\twhen.tv_usec = (timeout - when.tv_sec) * 1000000.0;\n\n\tast_channel_lock(c);\n\tast_channel_setwhentohangup_tv(c, when);\n\tast_channel_unlock(c);\n\tc = ast_channel_unref(c);\n\n\tastman_send_ack(s, m, \"Timeout Set\");\n\n\treturn 0;\n}\n\nstatic int whitefilter_cmp_fn(void *obj, void *arg, void *data, int flags)\n{\n\tregex_t *regex_filter = obj;\n\tconst char *eventdata = arg;\n\tint *result = data;\n\n\tif (!regexec(regex_filter, eventdata, 0, NULL, 0)) {\n\t\t*result = 1;\n\t\treturn (CMP_MATCH | CMP_STOP);\n\t}\n\n\treturn 0;\n}\n\nstatic int blackfilter_cmp_fn(void *obj, void *arg, void *data, int flags)\n{\n\tregex_t *regex_filter = obj;\n\tconst char *eventdata = arg;\n\tint *result = data;\n\n\tif (!regexec(regex_filter, eventdata, 0, NULL, 0)) {\n\t\t*result = 0;\n\t\treturn (CMP_MATCH | CMP_STOP);\n\t}\n\n\t*result = 1;\n\treturn 0;\n}\n\n/*!\n * \\brief Manager command to add an event filter to a manager session\n * \\see For more details look at manager_add_filter\n */\nstatic int action_filter(struct mansession *s, const struct message *m)\n{\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *operation = astman_get_header(m, \"Operation\");\n\tint res;\n\n\tif (!strcasecmp(operation, \"Add\")) {\n\t\tres = manager_add_filter(filter, s->session->whitefilters, s->session->blackfilters);\n\n\t        if (res != FILTER_SUCCESS) {\n\t\t        if (res == FILTER_ALLOC_FAILED) {\n\t\t\t\tastman_send_error(s, m, \"Internal Error. Failed to allocate regex for filter\");\n\t\t                return 0;\n\t\t        } else if (res == FILTER_COMPILE_FAIL) {\n\t\t\t\tastman_send_error(s, m, \"Filter did not compile.  Check the syntax of the filter given.\");\n\t\t                return 0;\n\t\t        } else {\n\t\t\t\tastman_send_error(s, m, \"Internal Error. Failed adding filter.\");\n\t\t                return 0;\n\t                }\n\t\t}\n\n\t\tastman_send_ack(s, m, \"Success\");\n\t\treturn 0;\n\t}\n\n\tastman_send_error(s, m, \"Unknown operation\");\n\treturn 0;\n}\n\n/*!\n * \\brief Add an event filter to a manager session\n *\n * \\param filter_pattern  Filter syntax to add, see below for syntax\n * \\param whitefilters, blackfilters\n *\n * \\return FILTER_ALLOC_FAILED   Memory allocation failure\n * \\return FILTER_COMPILE_FAIL   If the filter did not compile\n * \\return FILTER_SUCCESS        Success\n *\n * Filter will be used to match against each line of a manager event\n * Filter can be any valid regular expression\n * Filter can be a valid regular expression prefixed with !, which will add the filter as a black filter\n *\n * Examples:\n * \\code\n *   filter_pattern = \"Event: Newchannel\"\n *   filter_pattern = \"Event: New.*\"\n *   filter_pattern = \"!Channel: DAHDI.*\"\n * \\endcode\n *\n */\nstatic enum add_filter_result manager_add_filter(const char *filter_pattern, struct ao2_container *whitefilters, struct ao2_container *blackfilters) {\n\tregex_t *new_filter = ao2_t_alloc(sizeof(*new_filter), event_filter_destructor, \"event_filter allocation\");\n\tint is_blackfilter;\n\n\tif (!new_filter) {\n\t\treturn FILTER_ALLOC_FAILED;\n\t}\n\n\tif (filter_pattern[0] == '!') {\n\t\tis_blackfilter = 1;\n\t\tfilter_pattern++;\n\t} else {\n\t\tis_blackfilter = 0;\n\t}\n\n\tif (regcomp(new_filter, filter_pattern, REG_EXTENDED | REG_NOSUB)) {\n\t\tao2_t_ref(new_filter, -1, \"failed to make regex\");\n\t\treturn FILTER_COMPILE_FAIL;\n\t}\n\n\tif (is_blackfilter) {\n\t\tao2_t_link(blackfilters, new_filter, \"link new filter into black user container\");\n\t} else {\n\t\tao2_t_link(whitefilters, new_filter, \"link new filter into white user container\");\n\t}\n\n\tao2_ref(new_filter, -1);\n\n\treturn FILTER_SUCCESS;\n}\n\nstatic int match_filter(struct mansession *s, char *eventdata)\n{\n\tint result = 0;\n\n\tif (manager_debug) {\n\t\tast_verbose(\"<-- Examining AMI event: -->\\n%s\\n\", eventdata);\n\t} else {\n\t\tast_debug(4, \"Examining AMI event:\\n%s\\n\", eventdata);\n\t}\n\tif (!ao2_container_count(s->session->whitefilters) && !ao2_container_count(s->session->blackfilters)) {\n\t\treturn 1; /* no filtering means match all */\n\t} else if (ao2_container_count(s->session->whitefilters) && !ao2_container_count(s->session->blackfilters)) {\n\t\t/* white filters only: implied black all filter processed first, then white filters */\n\t\tao2_t_callback_data(s->session->whitefilters, OBJ_NODATA, whitefilter_cmp_fn, eventdata, &result, \"find filter in session filter container\");\n\t} else if (!ao2_container_count(s->session->whitefilters) && ao2_container_count(s->session->blackfilters)) {\n\t\t/* black filters only: implied white all filter processed first, then black filters */\n\t\tao2_t_callback_data(s->session->blackfilters, OBJ_NODATA, blackfilter_cmp_fn, eventdata, &result, \"find filter in session filter container\");\n\t} else {\n\t\t/* white and black filters: implied black all filter processed first, then white filters, and lastly black filters */\n\t\tao2_t_callback_data(s->session->whitefilters, OBJ_NODATA, whitefilter_cmp_fn, eventdata, &result, \"find filter in session filter container\");\n\t\tif (result) {\n\t\t\tresult = 0;\n\t\t\tao2_t_callback_data(s->session->blackfilters, OBJ_NODATA, blackfilter_cmp_fn, eventdata, &result, \"find filter in session filter container\");\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*!\n * Send any applicable events to the client listening on this socket.\n * Wait only for a finite time on each event, and drop all events whether\n * they are successfully sent or not.\n */\nstatic int process_events(struct mansession *s)\n{\n\tint ret = 0;\n\n\tao2_lock(s->session);\n\tif (s->session->stream != NULL) {\n\t\tstruct eventqent *eqe = s->session->last_ev;\n\n\t\twhile ((eqe = advance_event(eqe))) {\n\t\t\tif (eqe->category == EVENT_FLAG_SHUTDOWN) {\n\t\t\t\tast_debug(3, \"Received CloseSession event\\n\");\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t\tif (!ret && s->session->authenticated &&\n\t\t\t    (s->session->readperm & eqe->category) == eqe->category &&\n\t\t\t    (s->session->send_events & eqe->category) == eqe->category) {\n\t\t\t\t\tif (match_filter(s, eqe->eventdata)) {\n\t\t\t\t\t\tif (send_string(s, eqe->eventdata) < 0 || s->write_error)\n\t\t\t\t\t\t\tret = -1;\t/* don't send more */\n\t\t\t\t\t}\n\t\t\t}\n\t\t\ts->session->last_ev = eqe;\n\t\t}\n\t}\n\tao2_unlock(s->session);\n\treturn ret;\n}\n\nstatic int action_userevent(struct mansession *s, const struct message *m)\n{\n\tconst char *event = astman_get_header(m, \"UserEvent\");\n\tstruct ast_str *body = ast_str_thread_get(&userevent_buf, 16);\n\tint x;\n\n\tast_str_reset(body);\n\n\tfor (x = 0; x < m->hdrcount; x++) {\n\t\tif (strncasecmp(\"UserEvent:\", m->headers[x], strlen(\"UserEvent:\")) &&\n\t\t\t\tstrncasecmp(\"Action:\", m->headers[x], strlen(\"Action:\"))) {\n\t\t\tast_str_append(&body, 0, \"%s\\r\\n\", m->headers[x]);\n\t\t}\n\t}\n\n\tastman_send_ack(s, m, \"Event Sent\");\n\tmanager_event(EVENT_FLAG_USER, \"UserEvent\", \"UserEvent: %s\\r\\n%s\", event, ast_str_buffer(body));\n\treturn 0;\n}\n\n/*! \\brief Show PBX core settings information */\nstatic int action_coresettings(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tchar idText[150];\n\n\tif (!ast_strlen_zero(actionid)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", actionid);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tastman_append(s, \"Response: Success\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"AMIversion: %s\\r\\n\"\n\t\t\t\"AsteriskVersion: %s\\r\\n\"\n\t\t\t\"SystemName: %s\\r\\n\"\n\t\t\t\"CoreMaxCalls: %d\\r\\n\"\n\t\t\t\"CoreMaxLoadAvg: %f\\r\\n\"\n\t\t\t\"CoreRunUser: %s\\r\\n\"\n\t\t\t\"CoreRunGroup: %s\\r\\n\"\n\t\t\t\"CoreMaxFilehandles: %d\\r\\n\"\n\t\t\t\"CoreRealTimeEnabled: %s\\r\\n\"\n\t\t\t\"CoreCDRenabled: %s\\r\\n\"\n\t\t\t\"CoreHTTPenabled: %s\\r\\n\"\n\t\t\t\"SoundsSearchCustomDir: %s\\r\\n\"\n\t\t\t\"\\r\\n\",\n\t\t\tidText,\n\t\t\tAMI_VERSION,\n\t\t\tast_get_version(),\n\t\t\tast_config_AST_SYSTEM_NAME,\n\t\t\tast_option_maxcalls,\n\t\t\tast_option_maxload,\n\t\t\tast_config_AST_RUN_USER,\n\t\t\tast_config_AST_RUN_GROUP,\n\t\t\tast_option_maxfiles,\n\t\t\tAST_CLI_YESNO(ast_realtime_enabled()),\n\t\t\tAST_CLI_YESNO(ast_cdr_is_enabled()),\n\t\t\tAST_CLI_YESNO(ast_webmanager_check_enabled()),\n\t\t\tAST_CLI_YESNO(ast_opt_sounds_search_custom)\n\t\t\t);\n\treturn 0;\n}\n\n/*! \\brief Show PBX core status information */\nstatic int action_corestatus(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tchar idText[150];\n\tchar startuptime[150], startupdate[150];\n\tchar reloadtime[150], reloaddate[150];\n\tstruct ast_tm tm;\n\n\tif (!ast_strlen_zero(actionid)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", actionid);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tast_localtime(&ast_startuptime, &tm, NULL);\n\tast_strftime(startuptime, sizeof(startuptime), \"%H:%M:%S\", &tm);\n\tast_strftime(startupdate, sizeof(startupdate), \"%Y-%m-%d\", &tm);\n\tast_localtime(&ast_lastreloadtime, &tm, NULL);\n\tast_strftime(reloadtime, sizeof(reloadtime), \"%H:%M:%S\", &tm);\n\tast_strftime(reloaddate, sizeof(reloaddate), \"%Y-%m-%d\", &tm);\n\n\tastman_append(s, \"Response: Success\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"CoreStartupDate: %s\\r\\n\"\n\t\t\t\"CoreStartupTime: %s\\r\\n\"\n\t\t\t\"CoreReloadDate: %s\\r\\n\"\n\t\t\t\"CoreReloadTime: %s\\r\\n\"\n\t\t\t\"CoreCurrentCalls: %d\\r\\n\"\n\t\t\t\"\\r\\n\",\n\t\t\tidText,\n\t\t\tstartupdate,\n\t\t\tstartuptime,\n\t\t\treloaddate,\n\t\t\treloadtime,\n\t\t\tast_active_channels()\n\t\t\t);\n\treturn 0;\n}\n\n/*! \\brief Send a reload event */\nstatic int action_reload(struct mansession *s, const struct message *m)\n{\n\tconst char *module = astman_get_header(m, \"Module\");\n\tenum ast_module_reload_result res = ast_module_reload(S_OR(module, NULL));\n\n\tswitch (res) {\n\tcase AST_MODULE_RELOAD_NOT_FOUND:\n\t\tastman_send_error(s, m, \"No such module\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_NOT_IMPLEMENTED:\n\t\tastman_send_error(s, m, \"Module does not support reload\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_ERROR:\n\t\tastman_send_error(s, m, \"An unknown error occurred\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_IN_PROGRESS:\n\t\tastman_send_error(s, m, \"A reload is in progress\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_UNINITIALIZED:\n\t\tastman_send_error(s, m, \"Module not initialized\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_QUEUED:\n\tcase AST_MODULE_RELOAD_SUCCESS:\n\t\t/* Treat a queued request as success */\n\t\tastman_send_ack(s, m, \"Module Reloaded\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/*! \\brief  Manager command \"CoreShowChannels\" - List currently defined channels\n *          and some information about them. */\nstatic int action_coreshowchannels(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tchar idText[256];\n\tint numchans = 0;\n\tstruct ao2_container *channels;\n\tstruct ao2_iterator it_chans;\n\tstruct ast_channel_snapshot *cs;\n\n\tif (!ast_strlen_zero(actionid)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", actionid);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tchannels = ast_channel_cache_by_name();\n\n\tastman_send_listack(s, m, \"Channels will follow\", \"start\");\n\n\tit_chans = ao2_iterator_init(channels, 0);\n\tfor (; (cs = ao2_iterator_next(&it_chans)); ao2_ref(cs, -1)) {\n\t\tstruct ast_str *built = ast_manager_build_channel_state_string_prefix(cs, \"\");\n\t\tchar durbuf[16] = \"\";\n\n\t\tif (!built) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ast_tvzero(cs->base->creationtime)) {\n\t\t\tint duration, durh, durm, durs;\n\n\t\t\tduration = (int)(ast_tvdiff_ms(ast_tvnow(), cs->base->creationtime) / 1000);\n\t\t\tdurh = duration / 3600;\n\t\t\tdurm = (duration % 3600) / 60;\n\t\t\tdurs = duration % 60;\n\t\t\tsnprintf(durbuf, sizeof(durbuf), \"%02d:%02d:%02d\", durh, durm, durs);\n\t\t}\n\n\t\tastman_append(s,\n\t\t\t\"Event: CoreShowChannel\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"%s\"\n\t\t\t\"Application: %s\\r\\n\"\n\t\t\t\"ApplicationData: %s\\r\\n\"\n\t\t\t\"Duration: %s\\r\\n\"\n\t\t\t\"BridgeId: %s\\r\\n\"\n\t\t\t\"\\r\\n\",\n\t\t\tidText,\n\t\t\tast_str_buffer(built),\n\t\t\tcs->dialplan->appl,\n\t\t\tcs->dialplan->data,\n\t\t\tdurbuf,\n\t\t\tcs->bridge->id);\n\n\t\tnumchans++;\n\n\t\tast_free(built);\n\t}\n\tao2_iterator_destroy(&it_chans);\n\n\tastman_send_list_complete(s, m, \"CoreShowChannelsComplete\", numchans);\n\n\tao2_ref(channels, -1);\n\treturn 0;\n}\n\n/*! \\brief Helper function to add a channel name to the vector */\nstatic int coreshowchannelmap_add_to_map(struct ao2_container *c, const char *s)\n{\n\tchar *str;\n\n\tstr = ast_strdup(s);\n\tif (!str) {\n\t\tast_log(LOG_ERROR, \"Unable to append channel to channel map\\n\");\n\t\treturn 1;\n\t}\n\n\t/* If this is a duplicate, it will be ignored */\n\tast_str_container_add(c, str);\n\n\treturn 0;\n}\n\n/*! \\brief Recursive function to get all channels in a bridge. Follow local channels as well */\nstatic int coreshowchannelmap_add_connected_channels(struct ao2_container *channel_map,\n\tstruct ast_channel_snapshot *channel_snapshot, struct ast_bridge_snapshot *bridge_snapshot)\n{\n\tint res = 0;\n\tstruct ao2_iterator iter;\n\tchar *current_channel_uid;\n\n\titer = ao2_iterator_init(bridge_snapshot->channels, 0);\n\twhile ((current_channel_uid = ao2_iterator_next(&iter))) {\n\t\tstruct ast_channel_snapshot *current_channel_snapshot;\n\t\tint add_channel_res;\n\n\t\t/* Don't add the original channel to the list - it's either already in there,\n\t\t * or it's the channel we want the map for */\n\t\tif (!strcmp(current_channel_uid, channel_snapshot->base->uniqueid)) {\n\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcurrent_channel_snapshot = ast_channel_snapshot_get_latest(current_channel_uid);\n\t\tif (!current_channel_snapshot) {\n\t\t\tast_debug(5, \"Unable to get channel snapshot\\n\");\n\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tadd_channel_res = coreshowchannelmap_add_to_map(channel_map, current_channel_snapshot->base->name);\n\t\tif (add_channel_res) {\n\t\t\tres = 1;\n\t\t\tao2_ref(current_channel_snapshot, -1);\n\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If this is a local channel that we haven't seen yet, let's go ahead and find out what else is connected to it */\n\t\tif (ast_begins_with(current_channel_snapshot->base->name, \"Local\")) {\n\t\t\tstruct ast_channel_snapshot *other_local_snapshot;\n\t\t\tstruct ast_bridge_snapshot *other_bridge_snapshot;\n\t\t\tint size = strlen(current_channel_snapshot->base->name);\n\t\t\tchar other_local[size + 1];\n\n\t\t\t/* Don't copy the trailing number - set it to 1 or 2, whichever one it currently is not */\n\t\t\tast_copy_string(other_local, current_channel_snapshot->base->name, size);\n\t\t\tother_local[size - 1] = ast_ends_with(current_channel_snapshot->base->name, \"1\") ? '2' : '1';\n\t\t\tother_local[size] = '\\0';\n\n\t\t\tother_local_snapshot = ast_channel_snapshot_get_latest_by_name(other_local);\n\t\t\tif (!other_local_snapshot) {\n\t\t\t\tast_debug(5, \"Unable to get other local channel snapshot\\n\");\n\t\t\t\tao2_ref(current_channel_snapshot, -1);\n\t\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (coreshowchannelmap_add_to_map(channel_map, other_local_snapshot->base->name)) {\n\t\t\t\tres = 1;\n\t\t\t\tao2_ref(current_channel_snapshot, -1);\n\t\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\t\tao2_ref(other_local_snapshot, -1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tother_bridge_snapshot = ast_bridge_get_snapshot_by_uniqueid(other_local_snapshot->bridge->id);\n\t\t\tif (other_bridge_snapshot) {\n\t\t\t\tres = coreshowchannelmap_add_connected_channels(channel_map, other_local_snapshot, other_bridge_snapshot);\n\t\t\t}\n\n\t\t\tao2_ref(current_channel_snapshot, -1);\n\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\tao2_ref(other_local_snapshot, -1);\n\t\t\tao2_ref(other_bridge_snapshot, -1);\n\n\t\t\tif (res) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tao2_iterator_destroy(&iter);\n\n\treturn res;\n}\n\n/*! \\brief  Manager command \"CoreShowChannelMap\" - Lists all channels connected to\n *          the specified channel. */\nstatic int action_coreshowchannelmap(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tconst char *channel_name = astman_get_header(m, \"Channel\");\n\tchar *current_channel_name;\n\tchar id_text[256];\n\tint total = 0;\n\tstruct ao2_container *channel_map;\n\tstruct ao2_iterator i;\n\tRAII_VAR(struct ast_bridge_snapshot *, bridge_snapshot, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_channel_snapshot *, channel_snapshot, NULL, ao2_cleanup);\n\n\tif (!ast_strlen_zero(actionid)) {\n\t\tsnprintf(id_text, sizeof(id_text), \"ActionID: %s\\r\\n\", actionid);\n\t} else {\n\t\tid_text[0] = '\\0';\n\t}\n\n\tif (ast_strlen_zero(channel_name)) {\n\t\tastman_send_error(s, m, \"CoreShowChannelMap requires a channel.\\n\");\n\t\treturn 0;\n\t}\n\n\tchannel_snapshot = ast_channel_snapshot_get_latest_by_name(channel_name);\n\tif (!channel_snapshot) {\n\t\tastman_send_error(s, m, \"Could not get channel snapshot\\n\");\n\t\treturn 0;\n\t}\n\n\tbridge_snapshot = ast_bridge_get_snapshot_by_uniqueid(channel_snapshot->bridge->id);\n\tif (!bridge_snapshot) {\n\t\tastman_send_listack(s, m, \"Channel map will follow\", \"start\");\n\t\tastman_send_list_complete_start(s, m, \"CoreShowChannelMapComplete\", 0);\n\t\tastman_send_list_complete_end(s);\n\t\treturn 0;\n\t}\n\n\tchannel_map = ast_str_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK | AO2_CONTAINER_ALLOC_OPT_DUPS_OBJ_REJECT, 1);\n\tif (!channel_map) {\n\t\tastman_send_error(s, m, \"Could not create channel map\\n\");\n\t\treturn 0;\n\t}\n\n\tastman_send_listack(s, m, \"Channel map will follow\", \"start\");\n\n\tif (coreshowchannelmap_add_connected_channels(channel_map, channel_snapshot, bridge_snapshot)) {\n\t\tastman_send_error(s, m, \"Could not complete channel map\\n\");\n\t\tao2_ref(channel_map, -1);\n\t\treturn 0;\n\t}\n\n\ti = ao2_iterator_init(channel_map, 0);\n\twhile ((current_channel_name = ao2_iterator_next(&i))) {\n\t\tastman_append(s,\n\t\t\t\"Event: CoreShowChannelMap\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\"ConnectedChannel: %s\\r\\n\\n\",\n\t\t\tid_text,\n\t\t\tchannel_name,\n\t\t\tcurrent_channel_name);\n\t\ttotal++;\n\t}\n\tao2_iterator_destroy(&i);\n\n\tao2_ref(channel_map, -1);\n\tastman_send_list_complete_start(s, m, \"CoreShowChannelMapComplete\", total);\n\tastman_send_list_complete_end(s);\n\n\treturn 0;\n}\n\n/*! \\brief  Manager command \"LoggerRotate\" - reloads and rotates the logger in\n *          the same manner as the CLI command 'logger rotate'. */\nstatic int action_loggerrotate(struct mansession *s, const struct message *m)\n{\n\tif (ast_logger_rotate()) {\n\t\tastman_send_error(s, m, \"Failed to reload the logger and rotate log files\");\n\t\treturn 0;\n\t}\n\n\tastman_send_ack(s, m, \"Reloaded the logger and rotated log files\");\n\treturn 0;\n}\n\n/*! \\brief Manager function to check if module is loaded */\nstatic int manager_modulecheck(struct mansession *s, const struct message *m)\n{\n\tconst char *module = astman_get_header(m, \"Module\");\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\n\tast_debug(1, \"**** ModuleCheck .so file %s\\n\", module);\n\tif (!ast_module_check(module)) {\n\t\tastman_send_error(s, m, \"Module not loaded\");\n\t\treturn 0;\n\t}\n\n\tastman_append(s, \"Response: Success\\r\\n\");\n\n\tif (!ast_strlen_zero(id)) {\n\t\tastman_append(s, \"ActionID: %s\\r\\n\", id);\n\t}\n\n#if !defined(LOW_MEMORY)\n\t/* When we switched from subversion to git we lost the ability to\n\t * retrieve the 'ASTERISK_FILE_VERSION' from that file, but we retain\n\t * the response header here for backwards compatibility. */\n\tastman_append(s, \"Version: \\r\\n\");\n#endif\n\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\nstatic int manager_moduleload(struct mansession *s, const struct message *m)\n{\n\tint res;\n\tconst char *module = astman_get_header(m, \"Module\");\n\tconst char *loadtype = astman_get_header(m, \"LoadType\");\n\n\tif (!loadtype || strlen(loadtype) == 0) {\n\t\tastman_send_error(s, m, \"Incomplete ModuleLoad action.\");\n\t}\n\tif ((!module || strlen(module) == 0) && strcasecmp(loadtype, \"reload\") != 0) {\n\t\tastman_send_error(s, m, \"Need module name\");\n\t}\n\n\tif (!strcasecmp(loadtype, \"load\")) {\n\t\tres = ast_load_resource(module);\n\t\tif (res) {\n\t\t\tastman_send_error(s, m, \"Could not load module.\");\n\t\t} else {\n\t\t\tastman_send_ack(s, m, \"Module loaded.\");\n\t\t}\n\t} else if (!strcasecmp(loadtype, \"unload\")) {\n\t\tres = ast_unload_resource(module, AST_FORCE_SOFT);\n\t\tif (res) {\n\t\t\tastman_send_error(s, m, \"Could not unload module.\");\n\t\t} else {\n\t\t\tastman_send_ack(s, m, \"Module unloaded.\");\n\t\t}\n\t} else if (!strcasecmp(loadtype, \"reload\")) {\n\t\t/* TODO: Unify the ack/error messages here with action_reload */\n\t\tif (!ast_strlen_zero(module)) {\n\t\t\tenum ast_module_reload_result reload_res = ast_module_reload(module);\n\n\t\t\tswitch (reload_res) {\n\t\t\tcase AST_MODULE_RELOAD_NOT_FOUND:\n\t\t\t\tastman_send_error(s, m, \"No such module.\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_NOT_IMPLEMENTED:\n\t\t\t\tastman_send_error(s, m, \"Module does not support reload action.\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_ERROR:\n\t\t\t\tastman_send_error(s, m, \"An unknown error occurred\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_IN_PROGRESS:\n\t\t\t\tastman_send_error(s, m, \"A reload is in progress\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_UNINITIALIZED:\n\t\t\t\tastman_send_error(s, m, \"Module not initialized\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_QUEUED:\n\t\t\tcase AST_MODULE_RELOAD_SUCCESS:\n\t\t\t\t/* Treat a queued request as success */\n\t\t\t\tastman_send_ack(s, m, \"Module reloaded.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tast_module_reload(NULL);\t/* Reload all modules */\n\t\t\tastman_send_ack(s, m, \"All modules reloaded\");\n\t\t}\n\t} else\n\t\tastman_send_error(s, m, \"Incomplete ModuleLoad action.\");\n\treturn 0;\n}\n\nstatic void log_action(const struct message *m, const char *action)\n{\n\tstruct ast_str *buf;\n\tint x;\n\n\tif (!manager_debug) {\n\t\treturn;\n\t}\n\n\tbuf = ast_str_create(256);\n\tif (!buf) {\n\t\treturn;\n\t}\n\n\tfor (x = 0; x < m->hdrcount; ++x) {\n\t\tif (!strncasecmp(m->headers[x], \"Secret\", 6)) {\n\t\t\tast_str_append(&buf, 0, \"Secret: <redacted from logging>\\n\");\n\t\t} else {\n\t\t\tast_str_append(&buf, 0, \"%s\\n\", m->headers[x]);\n\t\t}\n\t}\n\n\tast_verbose(\"<--- Examining AMI action: -->\\n%s\\n\", ast_str_buffer(buf));\n\tast_free(buf);\n}\n\n/*\n * Done with the action handlers here, we start with the code in charge\n * of accepting connections and serving them.\n * accept_thread() forks a new thread for each connection, session_do(),\n * which in turn calls get_input() repeatedly until a full message has\n * been accumulated, and then invokes process_message() to pass it to\n * the appropriate handler.\n */\n\n/*! \\brief\n * Process an AMI message, performing desired action.\n * Return 0 on success, -1 on error that require the session to be destroyed.\n */\nstatic int process_message(struct mansession *s, const struct message *m)\n{\n\tint ret = 0;\n\tstruct manager_action *act_found;\n\tstruct ast_manager_user *user = NULL;\n\tconst char *username;\n\tconst char *action;\n\n\taction = __astman_get_header(m, \"Action\", GET_HEADER_SKIP_EMPTY);\n\tif (ast_strlen_zero(action)) {\n\t\treport_req_bad_format(s, \"NONE\");\n\t\tmansession_lock(s);\n\t\tastman_send_error(s, m, \"Missing action in request\");\n\t\tmansession_unlock(s);\n\t\treturn 0;\n\t}\n\n\tlog_action(m, action);\n\n\tif (ast_shutting_down()) {\n\t\tast_log(LOG_ERROR, \"Unable to process manager action '%s'. Asterisk is shutting down.\\n\", action);\n\t\tmansession_lock(s);\n\t\tastman_send_error(s, m, \"Asterisk is shutting down\");\n\t\tmansession_unlock(s);\n\t\treturn 0;\n\t}\n\n\tif (!s->session->authenticated\n\t\t&& strcasecmp(action, \"Login\")\n\t\t&& strcasecmp(action, \"Logoff\")\n\t\t&& strcasecmp(action, \"Challenge\")) {\n\t\tif (!s->session->authenticated) {\n\t\t\treport_req_not_allowed(s, action);\n\t\t}\n\t\tmansession_lock(s);\n\t\tastman_send_error(s, m, \"Permission denied\");\n\t\tmansession_unlock(s);\n\t\treturn 0;\n\t}\n\n\tif (!s->session->authenticated\n\t\t&& (!strcasecmp(action, \"Login\")\n\t\t\t|| !strcasecmp(action, \"Challenge\"))) {\n\t\tusername = astman_get_header(m, \"Username\");\n\n\t\tif (!ast_strlen_zero(username) && check_manager_session_inuse(username)) {\n\t\t\tAST_RWLIST_WRLOCK(&users);\n\t\t\tuser = get_manager_by_name_locked(username);\n\t\t\tif (user && !user->allowmultiplelogin) {\n\t\t\t\tAST_RWLIST_UNLOCK(&users);\n\t\t\t\treport_session_limit(s);\n\t\t\t\tsleep(1);\n\t\t\t\tmansession_lock(s);\n\t\t\t\tastman_send_error(s, m, \"Login Already In Use\");\n\t\t\t\tmansession_unlock(s);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tAST_RWLIST_UNLOCK(&users);\n\t\t}\n\t}\n\n\tact_found = action_find(action);\n\tif (act_found) {\n\t\t/* Found the requested AMI action. */\n\t\tint acted = 0;\n\n\t\tif ((s->session->writeperm & act_found->authority)\n\t\t\t|| act_found->authority == 0) {\n\t\t\t/* We have the authority to execute the action. */\n\t\t\tret = -1;\n\t\t\tao2_lock(act_found);\n\t\t\tif (act_found->registered && act_found->func) {\n\t\t\t\tstruct ast_module *mod_ref = ast_module_running_ref(act_found->module);\n\n\t\t\t\tao2_unlock(act_found);\n\t\t\t\tif (mod_ref || !act_found->module) {\n\t\t\t\t\tast_debug(1, \"Running action '%s'\\n\", act_found->action);\n\t\t\t\t\tret = act_found->func(s, m);\n\t\t\t\t\tacted = 1;\n\t\t\t\t\tast_module_unref(mod_ref);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tao2_unlock(act_found);\n\t\t\t}\n\t\t}\n\t\tif (!acted) {\n\t\t\t/*\n\t\t\t * We did not execute the action because access was denied, it\n\t\t\t * was no longer registered, or no action was really registered.\n\t\t\t * Complain about it and leave.\n\t\t\t */\n\t\t\treport_req_not_allowed(s, action);\n\t\t\tmansession_lock(s);\n\t\t\tastman_send_error(s, m, \"Permission denied\");\n\t\t\tmansession_unlock(s);\n\t\t}\n\t\tao2_t_ref(act_found, -1, \"done with found action object\");\n\t} else {\n\t\tchar buf[512];\n\n\t\treport_req_bad_format(s, action);\n\t\tsnprintf(buf, sizeof(buf), \"Invalid/unknown command: %s. Use Action: ListCommands to show available commands.\", action);\n\t\tmansession_lock(s);\n\t\tastman_send_error(s, m, buf);\n\t\tmansession_unlock(s);\n\t}\n\tif (ret) {\n\t\treturn ret;\n\t}\n\t/* Once done with our message, deliver any pending events unless the\n\t   requester doesn't want them as part of this response.\n\t*/\n\tif (ast_strlen_zero(astman_get_header(m, \"SuppressEvents\"))) {\n\t\treturn process_events(s);\n\t} else {\n\t\treturn ret;\n\t}\n}\n\n/*!\n * Read one full line (including crlf) from the manager socket.\n * \\note \\verbatim\n * \\r\\n is the only valid terminator for the line.\n * (Note that, later, '\\0' will be considered as the end-of-line marker,\n * so everything between the '\\0' and the '\\r\\n' will not be used).\n * Also note that we assume output to have at least \"maxlen\" space.\n * \\endverbatim\n */\nstatic int get_input(struct mansession *s, char *output)\n{\n\tint res, x;\n\tint maxlen = sizeof(s->session->inbuf) - 1;\n\tchar *src = s->session->inbuf;\n\tint timeout = -1;\n\ttime_t now;\n\n\t/*\n\t * Look for \\r\\n within the buffer. If found, copy to the output\n\t * buffer and return, trimming the \\r\\n (not used afterwards).\n\t */\n\tfor (x = 0; x < s->session->inlen; x++) {\n\t\tint cr;\t/* set if we have \\r */\n\t\tif (src[x] == '\\r' && x+1 < s->session->inlen && src[x + 1] == '\\n') {\n\t\t\tcr = 2;\t/* Found. Update length to include \\r\\n */\n\t\t} else if (src[x] == '\\n') {\n\t\t\tcr = 1;\t/* also accept \\n only */\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(output, src, x);\t/*... but trim \\r\\n */\n\t\toutput[x] = '\\0';\t\t/* terminate the string */\n\t\tx += cr;\t\t\t/* number of bytes used */\n\t\ts->session->inlen -= x;\t\t\t/* remaining size */\n\t\tmemmove(src, src + x, s->session->inlen); /* remove used bytes */\n\t\treturn 1;\n\t}\n\tif (s->session->inlen >= maxlen) {\n\t\t/* no crlf found, and buffer full - sorry, too long for us\n\t\t * keep the last character in case we are in the middle of a CRLF. */\n\t\tast_log(LOG_WARNING, \"Discarding message from %s. Line too long: %.25s...\\n\", ast_sockaddr_stringify_addr(&s->session->addr), src);\n\t\tsrc[0] = src[s->session->inlen - 1];\n\t\ts->session->inlen = 1;\n\t\ts->parsing = MESSAGE_LINE_TOO_LONG;\n\t}\n\tres = 0;\n\twhile (res == 0) {\n\t\t/* calculate a timeout if we are not authenticated */\n\t\tif (!s->session->authenticated) {\n\t\t\tif(time(&now) == -1) {\n\t\t\t\tast_log(LOG_ERROR, \"error executing time(): %s\\n\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\ttimeout = (authtimeout - (now - s->session->authstart)) * 1000;\n\t\t\tif (timeout < 0) {\n\t\t\t\t/* we have timed out */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tast_mutex_lock(&s->session->notify_lock);\n\t\tif (s->session->pending_event) {\n\t\t\ts->session->pending_event = 0;\n\t\t\tast_mutex_unlock(&s->session->notify_lock);\n\t\t\treturn 0;\n\t\t}\n\t\ts->session->waiting_thread = pthread_self();\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\n\t\tres = ast_wait_for_input(ast_iostream_get_fd(s->session->stream), timeout);\n\n\t\tast_mutex_lock(&s->session->notify_lock);\n\t\ts->session->waiting_thread = AST_PTHREADT_NULL;\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\t}\n\tif (res < 0) {\n\t\t/* If we get a signal from some other thread (typically because\n\t\t * there are new events queued), return 0 to notify the caller.\n\t\t */\n\t\tif (errno == EINTR || errno == EAGAIN) {\n\t\t\treturn 0;\n\t\t}\n\t\tast_log(LOG_WARNING, \"poll() returned error: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tao2_lock(s->session);\n\tres = ast_iostream_read(s->session->stream, src + s->session->inlen, maxlen - s->session->inlen);\n\tif (res < 1) {\n\t\tres = -1;\t/* error return */\n\t} else {\n\t\ts->session->inlen += res;\n\t\tsrc[s->session->inlen] = '\\0';\n\t\tres = 0;\n\t}\n\tao2_unlock(s->session);\n\treturn res;\n}\n\n/*!\n * \\internal\n * \\brief Error handling for sending parse errors. This function handles locking, and clearing the\n * parse error flag.\n *\n * \\param s AMI session to process action request.\n * \\param m Message that's in error.\n * \\param error Error message to send.\n */\nstatic void handle_parse_error(struct mansession *s, struct message *m, char *error)\n{\n\tmansession_lock(s);\n\tastman_send_error(s, m, error);\n\ts->parsing = MESSAGE_OKAY;\n\tmansession_unlock(s);\n}\n\n/*!\n * \\internal\n * \\brief Read and process an AMI action request.\n *\n * \\param s AMI session to process action request.\n *\n * \\retval 0 Retain AMI connection for next command.\n * \\retval -1 Drop AMI connection due to logoff or connection error.\n */\nstatic int do_message(struct mansession *s)\n{\n\tstruct message m = { 0 };\n\tchar header_buf[sizeof(s->session->inbuf)] = { '\\0' };\n\tint res;\n\tint hdr_loss;\n\ttime_t now;\n\n\thdr_loss = 0;\n\tfor (;;) {\n\t\t/* Check if any events are pending and do them if needed */\n\t\tif (process_events(s)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tres = get_input(s, header_buf);\n\t\tif (res == 0) {\n\t\t\t/* No input line received. */\n\t\t\tif (!s->session->authenticated) {\n\t\t\t\tif (time(&now) == -1) {\n\t\t\t\t\tast_log(LOG_ERROR, \"error executing time(): %s\\n\", strerror(errno));\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (now - s->session->authstart > authtimeout) {\n\t\t\t\t\tif (displayconnects) {\n\t\t\t\t\t\tast_verb(2, \"Client from %s, failed to authenticate in %d seconds\\n\", ast_sockaddr_stringify_addr(&s->session->addr), authtimeout);\n\t\t\t\t\t}\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (res > 0) {\n\t\t\t/* Input line received. */\n\t\t\tif (ast_strlen_zero(header_buf)) {\n\t\t\t\tif (hdr_loss) {\n\t\t\t\t\tmansession_lock(s);\n\t\t\t\t\tastman_send_error(s, &m, \"Too many lines in message or allocation failure\");\n\t\t\t\t\tmansession_unlock(s);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tswitch (s->parsing) {\n\t\t\t\t\tcase MESSAGE_OKAY:\n\t\t\t\t\t\tres = process_message(s, &m) ? -1 : 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MESSAGE_LINE_TOO_LONG:\n\t\t\t\t\t\thandle_parse_error(s, &m, \"Failed to parse message: line too long\");\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (m.hdrcount < ARRAY_LEN(m.headers)) {\n\t\t\t\tm.headers[m.hdrcount] = ast_strdup(header_buf);\n\t\t\t\tif (!m.headers[m.hdrcount]) {\n\t\t\t\t\t/* Allocation failure. */\n\t\t\t\t\thdr_loss = 1;\n\t\t\t\t} else {\n\t\t\t\t\t++m.hdrcount;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Too many lines in message. */\n\t\t\t\thdr_loss = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Input error. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tastman_free_headers(&m);\n\n\treturn res;\n}\n\n/*! \\brief The body of the individual manager session.\n * Call get_input() to read one line at a time\n * (or be woken up on new events), collect the lines in a\n * message until found an empty line, and execute the request.\n * In any case, deliver events asynchronously through process_events()\n * (called from here if no line is available, or at the end of\n * process_message(). )\n */\nstatic void *session_do(void *data)\n{\n\tstruct ast_tcptls_session_instance *ser = data;\n\tstruct mansession_session *session;\n\tstruct mansession s = {\n\t\t.tcptls_session = data,\n\t};\n\tint res;\n\tint arg = 1;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tif (ast_atomic_fetchadd_int(&unauth_sessions, +1) >= authlimit) {\n\t\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\t\tgoto done;\n\t}\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tsession = build_mansession(&ser_remote_address_tmp);\n\n\tif (session == NULL) {\n\t\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\t\tgoto done;\n\t}\n\n\t/* here we set TCP_NODELAY on the socket to disable Nagle's algorithm.\n\t * This is necessary to prevent delays (caused by buffering) as we\n\t * write to the socket in bits and pieces. */\n\tif (setsockopt(ast_iostream_get_fd(ser->stream), IPPROTO_TCP, TCP_NODELAY, (char *) &arg, sizeof(arg)) < 0) {\n\t\tast_log(LOG_WARNING, \"Failed to set TCP_NODELAY on manager connection: %s\\n\", strerror(errno));\n\t}\n\tast_iostream_nonblock(ser->stream);\n\n\tao2_lock(session);\n\t/* Hook to the tail of the event queue */\n\tsession->last_ev = grab_last();\n\n\tast_mutex_init(&s.lock);\n\n\t/* these fields duplicate those in the 'ser' structure */\n\tsession->stream = s.stream = ser->stream;\n\tast_sockaddr_copy(&session->addr, &ser_remote_address_tmp);\n\ts.session = session;\n\n\tAST_LIST_HEAD_INIT_NOLOCK(&session->datastores);\n\n\tif(time(&session->authstart) == -1) {\n\t\tast_log(LOG_ERROR, \"error executing time(): %s; disconnecting client\\n\", strerror(errno));\n\t\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\t\tao2_unlock(session);\n\t\tsession_destroy(session);\n\t\tgoto done;\n\t}\n\tao2_unlock(session);\n\n\t/*\n\t * We cannot let the stream exclusively wait for data to arrive.\n\t * We have to wake up the task to send async events.\n\t */\n\tast_iostream_set_exclusive_input(ser->stream, 0);\n\n\tast_iostream_set_timeout_sequence(ser->stream,\n\t\tast_tvnow(), authtimeout * 1000);\n\n\tastman_append(&s, \"Asterisk Call Manager/%s\\r\\n\", AMI_VERSION);\t/* welcome prompt */\n\tfor (;;) {\n\t\tif ((res = do_message(&s)) < 0 || s.write_error) {\n\t\t\tbreak;\n\t\t}\n\t\tif (session->authenticated) {\n\t\t\tast_iostream_set_timeout_disable(ser->stream);\n\t\t}\n\t}\n\t/* session is over, explain why and terminate */\n\tif (session->authenticated) {\n\t\tif (manager_displayconnects(session)) {\n\t\t\tast_verb(2, \"Manager '%s' logged off from %s\\n\", session->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t}\n\t} else {\n\t\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\t\tif (displayconnects) {\n\t\t\tast_verb(2, \"Connect attempt from '%s' unable to authenticate\\n\", ast_sockaddr_stringify_addr(&session->addr));\n\t\t}\n\t}\n\n\tsession_destroy(session);\n\n\tast_mutex_destroy(&s.lock);\ndone:\n\tao2_ref(ser, -1);\n\tser = NULL;\n\treturn NULL;\n}\n\n/*! \\brief remove at most n_max stale session from the list. */\nstatic int purge_sessions(int n_max)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *session;\n\ttime_t now = time(NULL);\n\tstruct ao2_iterator i;\n\tint purged = 0;\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn 0;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i)) && n_max > 0) {\n\t\tao2_lock(session);\n\t\tif (session->sessiontimeout && (now > session->sessiontimeout) && !session->inuse) {\n\t\t\tif (session->authenticated\n\t\t\t\t&& VERBOSITY_ATLEAST(2)\n\t\t\t\t&& manager_displayconnects(session)) {\n\t\t\t\tast_verb(2, \"HTTP Manager '%s' timed out from %s\\n\",\n\t\t\t\t\tsession->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t\t}\n\t\t\tao2_unlock(session);\n\t\t\tsession_destroy(session);\n\t\t\tn_max--;\n\t\t\tpurged++;\n\t\t} else {\n\t\t\tao2_unlock(session);\n\t\t\tunref_mansession(session);\n\t\t}\n\t}\n\tao2_iterator_destroy(&i);\n\treturn purged;\n}\n\n/*! \\brief\n * events are appended to a queue from where they\n * can be dispatched to clients.\n */\nstatic int append_event(const char *str, int category)\n{\n\tstruct eventqent *tmp = ast_malloc(sizeof(*tmp) + strlen(str));\n\tstatic int seq;\t/* sequence number */\n\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\t/* need to init all fields, because ast_malloc() does not */\n\ttmp->usecount = 0;\n\ttmp->category = category;\n\ttmp->seq = ast_atomic_fetchadd_int(&seq, 1);\n\ttmp->tv = ast_tvnow();\n\tAST_RWLIST_NEXT(tmp, eq_next) = NULL;\n\tstrcpy(tmp->eventdata, str);\n\n\tAST_RWLIST_WRLOCK(&all_events);\n\tAST_RWLIST_INSERT_TAIL(&all_events, tmp, eq_next);\n\tAST_RWLIST_UNLOCK(&all_events);\n\n\treturn 0;\n}\n\nstatic void append_channel_vars(struct ast_str **pbuf, struct ast_channel *chan)\n{\n\tstruct varshead *vars;\n\tstruct ast_var_t *var;\n\n\tvars = ast_channel_get_manager_vars(chan);\n\tif (!vars) {\n\t\treturn;\n\t}\n\n\tAST_LIST_TRAVERSE(vars, var, entries) {\n\t\tast_str_append(pbuf, 0, \"ChanVariable(%s): %s=%s\\r\\n\", ast_channel_name(chan), var->name, var->value);\n\t}\n\tao2_ref(vars, -1);\n}\n\n/* XXX see if can be moved inside the function */\nAST_THREADSTORAGE(manager_event_buf);\n#define MANAGER_EVENT_BUF_INITSIZE   256\n\nstatic int __attribute__((format(printf, 9, 0))) __manager_event_sessions_va(\n\tstruct ao2_container *sessions,\n\tint category,\n\tconst char *event,\n\tint chancount,\n\tstruct ast_channel **chans,\n\tconst char *file,\n\tint line,\n\tconst char *func,\n\tconst char *fmt,\n\tva_list ap)\n{\n\tstruct ast_str *auth = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\tconst char *cat_str;\n\tstruct timeval now;\n\tstruct ast_str *buf;\n\tint i;\n\n\tif (!ast_strlen_zero(manager_disabledevents)) {\n\t\tif (ast_in_delimited_string(event, manager_disabledevents, ',')) {\n\t\t\tast_debug(3, \"AMI Event '%s' is globally disabled, skipping\\n\", event);\n\t\t\t/* Event is globally disabled */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbuf = ast_str_thread_get(&manager_event_buf, MANAGER_EVENT_BUF_INITSIZE);\n\tif (!buf) {\n\t\treturn -1;\n\t}\n\n\tcat_str = authority_to_str(category, &auth);\n\tast_str_set(&buf, 0,\n\t\t\"Event: %s\\r\\n\"\n\t\t\"Privilege: %s\\r\\n\",\n\t\tevent, cat_str);\n\n\tif (timestampevents) {\n\t\tnow = ast_tvnow();\n\t\tast_str_append(&buf, 0,\n\t\t\t\"Timestamp: %ld.%06lu\\r\\n\",\n\t\t\t(long)now.tv_sec, (unsigned long) now.tv_usec);\n\t}\n\tif (manager_debug) {\n\t\tstatic int seq;\n\n\t\tast_str_append(&buf, 0,\n\t\t\t\"SequenceNumber: %d\\r\\n\",\n\t\t\tast_atomic_fetchadd_int(&seq, 1));\n\t\tast_str_append(&buf, 0,\n\t\t\t\"File: %s\\r\\n\"\n\t\t\t\"Line: %d\\r\\n\"\n\t\t\t\"Func: %s\\r\\n\",\n\t\t\tfile, line, func);\n\t}\n\tif (!ast_strlen_zero(ast_config_AST_SYSTEM_NAME)) {\n\t\tast_str_append(&buf, 0,\n\t\t\t\"SystemName: %s\\r\\n\",\n\t\t\tast_config_AST_SYSTEM_NAME);\n\t}\n\n\tast_str_append_va(&buf, 0, fmt, ap);\n\tfor (i = 0; i < chancount; i++) {\n\t\tappend_channel_vars(&buf, chans[i]);\n\t}\n\n\tast_str_append(&buf, 0, \"\\r\\n\");\n\n\tappend_event(ast_str_buffer(buf), category);\n\n\t/* Wake up any sleeping sessions */\n\tif (sessions) {\n\t\tstruct ao2_iterator iter;\n\t\tstruct mansession_session *session;\n\n\t\titer = ao2_iterator_init(sessions, 0);\n\t\twhile ((session = ao2_iterator_next(&iter))) {\n\t\t\tast_mutex_lock(&session->notify_lock);\n\t\t\tif (session->waiting_thread != AST_PTHREADT_NULL) {\n\t\t\t\tpthread_kill(session->waiting_thread, SIGURG);\n\t\t\t} else {\n\t\t\t\t/* We have an event to process, but the mansession is\n\t\t\t\t * not waiting for it. We still need to indicate that there\n\t\t\t\t * is an event waiting so that get_input processes the pending\n\t\t\t\t * event instead of polling.\n\t\t\t\t */\n\t\t\t\tsession->pending_event = 1;\n\t\t\t}\n\t\t\tast_mutex_unlock(&session->notify_lock);\n\t\t\tunref_mansession(session);\n\t\t}\n\t\tao2_iterator_destroy(&iter);\n\t}\n\n\tif (category != EVENT_FLAG_SHUTDOWN && !AST_RWLIST_EMPTY(&manager_hooks)) {\n\t\tstruct manager_custom_hook *hook;\n\n\t\tAST_RWLIST_RDLOCK(&manager_hooks);\n\t\tAST_RWLIST_TRAVERSE(&manager_hooks, hook, list) {\n\t\t\thook->helper(category, event, ast_str_buffer(buf));\n\t\t}\n\t\tAST_RWLIST_UNLOCK(&manager_hooks);\n\t}\n\n\treturn 0;\n}\n\nstatic int __attribute__((format(printf, 9, 0))) __manager_event_sessions(\n\tstruct ao2_container *sessions,\n\tint category,\n\tconst char *event,\n\tint chancount,\n\tstruct ast_channel **chans,\n\tconst char *file,\n\tint line,\n\tconst char *func,\n\tconst char *fmt,\n\t...)\n{\n\tva_list ap;\n\tint res;\n\n\tva_start(ap, fmt);\n\tres = __manager_event_sessions_va(sessions, category, event, chancount, chans,\n\t\tfile, line, func, fmt, ap);\n\tva_end(ap);\n\treturn res;\n}\n\nint __ast_manager_event_multichan(int category, const char *event, int chancount,\n\tstruct ast_channel **chans, const char *file, int line, const char *func,\n\tconst char *fmt, ...)\n{\n\tstruct ao2_container *sessions = ao2_global_obj_ref(mgr_sessions);\n\tva_list ap;\n\tint res;\n\n\tif (!any_manager_listeners(sessions)) {\n\t\t/* Nobody is listening */\n\t\tao2_cleanup(sessions);\n\t\treturn 0;\n\t}\n\n\tva_start(ap, fmt);\n\tres = __manager_event_sessions_va(sessions, category, event, chancount, chans,\n\t\tfile, line, func, fmt, ap);\n\tva_end(ap);\n\tao2_cleanup(sessions);\n\treturn res;\n}\n\n/*! \\brief\n * support functions to register/unregister AMI action handlers,\n */\nint ast_manager_unregister(const char *action)\n{\n\tstruct manager_action *cur;\n\n\tAST_RWLIST_WRLOCK(&actions);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&actions, cur, list) {\n\t\tif (!strcasecmp(action, cur->action)) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&actions);\n\n\tif (cur) {\n\t\t/*\n\t\t * We have removed the action object from the container so we\n\t\t * are no longer in a hurry.\n\t\t */\n\t\tao2_lock(cur);\n\t\tcur->registered = 0;\n\t\tao2_unlock(cur);\n\n\t\tao2_t_ref(cur, -1, \"action object removed from list\");\n\t\tast_verb(2, \"Manager unregistered action %s\\n\", action);\n\t}\n\n\treturn 0;\n}\n\nstatic int manager_state_cb(const char *context, const char *exten, struct ast_state_cb_info *info, void *data)\n{\n\t/* Notify managers of change */\n\tchar hint[512];\n\n\thint[0] = '\\0';\n\tast_get_hint(hint, sizeof(hint), NULL, 0, NULL, context, exten);\n\n\tswitch(info->reason) {\n\tcase AST_HINT_UPDATE_DEVICE:\n\t\tmanager_event(EVENT_FLAG_CALL, \"ExtensionStatus\",\n\t\t\t\"Exten: %s\\r\\n\"\n\t\t\t\"Context: %s\\r\\n\"\n\t\t\t\"Hint: %s\\r\\n\"\n\t\t\t\"Status: %d\\r\\n\"\n\t\t\t\"StatusText: %s\\r\\n\",\n\t\t\texten,\n\t\t\tcontext,\n\t\t\thint,\n\t\t\tinfo->exten_state,\n\t\t\tast_extension_state2str(info->exten_state));\n\t\tbreak;\n\tcase AST_HINT_UPDATE_PRESENCE:\n\t\tmanager_event(EVENT_FLAG_CALL, \"PresenceStatus\",\n\t\t\t\"Exten: %s\\r\\n\"\n\t\t\t\"Context: %s\\r\\n\"\n\t\t\t\"Hint: %s\\r\\n\"\n\t\t\t\"Status: %s\\r\\n\"\n\t\t\t\"Subtype: %s\\r\\n\"\n\t\t\t\"Message: %s\\r\\n\",\n\t\t\texten,\n\t\t\tcontext,\n\t\t\thint,\n\t\t\tast_presence_state2str(info->presence_state),\n\t\t\tinfo->presence_subtype,\n\t\t\tinfo->presence_message);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ast_manager_register_struct(struct manager_action *act)\n{\n\tstruct manager_action *cur, *prev = NULL;\n\n\tAST_RWLIST_WRLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tint ret;\n\n\t\tret = strcasecmp(cur->action, act->action);\n\t\tif (ret == 0) {\n\t\t\tast_log(LOG_WARNING, \"Manager: Action '%s' already registered\\n\", act->action);\n\t\t\tAST_RWLIST_UNLOCK(&actions);\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret > 0) { /* Insert these alphabetically */\n\t\t\tbreak;\n\t\t}\n\t\tprev = cur;\n\t}\n\n\tao2_t_ref(act, +1, \"action object added to list\");\n\tact->registered = 1;\n\tif (prev) {\n\t\tAST_RWLIST_INSERT_AFTER(&actions, prev, act, list);\n\t} else {\n\t\tAST_RWLIST_INSERT_HEAD(&actions, act, list);\n\t}\n\n\tast_verb(2, \"Manager registered action %s\\n\", act->action);\n\n\tAST_RWLIST_UNLOCK(&actions);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Destroy the registered AMI action object.\n *\n * \\param obj Object to destroy.\n */\nstatic void action_destroy(void *obj)\n{\n\tstruct manager_action *doomed = obj;\n\n\tif (doomed->synopsis) {\n\t\t/* The string fields were initialized. */\n\t\tast_string_field_free_memory(doomed);\n\t}\n\tao2_cleanup(doomed->final_response);\n\tao2_cleanup(doomed->list_responses);\n}\n\n/*! \\brief register a new command with manager, including online help. This is\n\tthe preferred way to register a manager command */\nint ast_manager_register2(const char *action, int auth, int (*func)(struct mansession *s, const struct message *m), struct ast_module *module, const char *synopsis, const char *description)\n{\n\tstruct manager_action *cur;\n\n\tcur = ao2_t_alloc(sizeof(*cur), action_destroy, action);\n\tif (!cur) {\n\t\treturn -1;\n\t}\n\tif (ast_string_field_init(cur, 128)) {\n\t\tao2_t_ref(cur, -1, \"action object creation failed\");\n\t\treturn -1;\n\t}\n\n\tcur->action = action;\n\tcur->authority = auth;\n\tcur->func = func;\n\tcur->module = module;\n#ifdef AST_XML_DOCS\n\tif (ast_strlen_zero(synopsis) && ast_strlen_zero(description)) {\n\t\tchar *tmpxml;\n\n\t\ttmpxml = ast_xmldoc_build_synopsis(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, synopsis, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\ttmpxml = ast_xmldoc_build_syntax(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, syntax, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\ttmpxml = ast_xmldoc_build_description(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, description, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\ttmpxml = ast_xmldoc_build_seealso(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, seealso, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\ttmpxml = ast_xmldoc_build_arguments(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, arguments, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\tcur->final_response = ast_xmldoc_build_final_response(\"manager\", action, NULL);\n\t\tcur->list_responses = ast_xmldoc_build_list_responses(\"manager\", action, NULL);\n\n\t\tcur->docsrc = AST_XML_DOC;\n\t} else\n#endif\n\t{\n\t\tast_string_field_set(cur, synopsis, synopsis);\n\t\tast_string_field_set(cur, description, description);\n#ifdef AST_XML_DOCS\n\t\tcur->docsrc = AST_STATIC_DOC;\n#endif\n\t}\n\tif (ast_manager_register_struct(cur)) {\n\t\tao2_t_ref(cur, -1, \"action object registration failed\");\n\t\treturn -1;\n\t}\n\n\tao2_t_ref(cur, -1, \"action object registration successful\");\n\treturn 0;\n}\n/*! @}\n END Doxygen group */\n\n/*\n * The following are support functions for AMI-over-http.\n * The common entry point is generic_http_callback(),\n * which extracts HTTP header and URI fields and reformats\n * them into AMI messages, locates a proper session\n * (using the mansession_id Cookie or GET variable),\n * and calls process_message() as for regular AMI clients.\n * When done, the output (which goes to a temporary file)\n * is read back into a buffer and reformatted as desired,\n * then fed back to the client over the original socket.\n */\n\nenum output_format {\n\tFORMAT_RAW,\n\tFORMAT_HTML,\n\tFORMAT_XML,\n};\n\nstatic const char * const contenttype[] = {\n\t[FORMAT_RAW] = \"plain\",\n\t[FORMAT_HTML] = \"html\",\n\t[FORMAT_XML] =  \"xml\",\n};\n\n/*!\n * locate an http session in the list. The search key (ident) is\n * the value of the mansession_id cookie (0 is not valid and means\n * a session on the AMI socket).\n */\nstatic struct mansession_session *find_session(uint32_t ident, int incinuse)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *session;\n\tstruct ao2_iterator i;\n\n\tif (ident == 0) {\n\t\treturn NULL;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn NULL;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i))) {\n\t\tao2_lock(session);\n\t\tif (session->managerid == ident && !session->needdestroy) {\n\t\t\tast_atomic_fetchadd_int(&session->inuse, incinuse ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\t\tao2_unlock(session);\n\t\tunref_mansession(session);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn session;\n}\n\n/*!\n * locate an http session in the list.\n * The search keys (nonce) and (username) is value from received\n * \"Authorization\" http header.\n * As well as in find_session() function, the value of the nonce can't be zero.\n * (0 meansi, that the session used for AMI socket connection).\n * Flag (stale) is set, if client used valid, but old, nonce value.\n *\n */\nstatic struct mansession_session *find_session_by_nonce(const char *username, unsigned long nonce, int *stale)\n{\n\tstruct mansession_session *session;\n\tstruct ao2_container *sessions;\n\tstruct ao2_iterator i;\n\n\tif (nonce == 0 || username == NULL || stale == NULL) {\n\t\treturn NULL;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn NULL;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i))) {\n\t\tao2_lock(session);\n\t\tif (!strcasecmp(session->username, username) && session->managerid == nonce) {\n\t\t\t*stale = 0;\n\t\t\tbreak;\n\t\t} else if (!strcasecmp(session->username, username) && session->oldnonce == nonce) {\n\t\t\t*stale = 1;\n\t\t\tbreak;\n\t\t}\n\t\tao2_unlock(session);\n\t\tunref_mansession(session);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn session;\n}\n\nint astman_is_authed(uint32_t ident)\n{\n\tint authed;\n\tstruct mansession_session *session;\n\n\tif (!(session = find_session(ident, 0)))\n\t\treturn 0;\n\n\tauthed = (session->authenticated != 0);\n\n\tao2_unlock(session);\n\tunref_mansession(session);\n\n\treturn authed;\n}\n\nint astman_verify_session_readpermissions(uint32_t ident, int perm)\n{\n\tint result = 0;\n\tstruct mansession_session *session;\n\tstruct ao2_container *sessions;\n\tstruct ao2_iterator i;\n\n\tif (ident == 0) {\n\t\treturn 0;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn 0;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i))) {\n\t\tao2_lock(session);\n\t\tif ((session->managerid == ident) && (session->readperm & perm)) {\n\t\t\tresult = 1;\n\t\t\tao2_unlock(session);\n\t\t\tunref_mansession(session);\n\t\t\tbreak;\n\t\t}\n\t\tao2_unlock(session);\n\t\tunref_mansession(session);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn result;\n}\n\nint astman_verify_session_writepermissions(uint32_t ident, int perm)\n{\n\tint result = 0;\n\tstruct mansession_session *session;\n\tstruct ao2_container *sessions;\n\tstruct ao2_iterator i;\n\n\tif (ident == 0) {\n\t\treturn 0;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn 0;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i))) {\n\t\tao2_lock(session);\n\t\tif ((session->managerid == ident) && (session->writeperm & perm)) {\n\t\t\tresult = 1;\n\t\t\tao2_unlock(session);\n\t\t\tunref_mansession(session);\n\t\t\tbreak;\n\t\t}\n\t\tao2_unlock(session);\n\t\tunref_mansession(session);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn result;\n}\n\n/*\n * convert to xml with various conversion:\n * mode & 1\t-> lowercase;\n * mode & 2\t-> replace non-alphanumeric chars with underscore\n */\nstatic void xml_copy_escape(struct ast_str **out, const char *src, int mode)\n{\n\t/* store in a local buffer to avoid calling ast_str_append too often */\n\tchar buf[256];\n\tchar *dst = buf;\n\tconst char *save = src;\n\tint space = sizeof(buf);\n\t/* repeat until done and nothing to flush */\n\tfor ( ; *src || dst != buf ; src++) {\n\t\tif (*src == '\\0' || space < 10) {\t/* flush */\n\t\t\t*dst++ = '\\0';\n\t\t\tast_str_append(out, 0, \"%s\", buf);\n\t\t\tdst = buf;\n\t\t\tspace = sizeof(buf);\n\t\t\tif (*src == '\\0') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (mode & 2) {\n\t\t\tif (save == src && isdigit(*src)) {\n\t\t\t\t/* The first character of an XML attribute cannot be a digit */\n\t\t\t\t*dst++ = '_';\n\t\t\t\t*dst++ = *src;\n\t\t\t\tspace -= 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (!isalnum(*src)) {\n\t\t\t\t/* Replace non-alphanumeric with an underscore */\n\t\t\t\t*dst++ = '_';\n\t\t\t\tspace--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (*src) {\n\t\tcase '<':\n\t\t\tstrcpy(dst, \"&lt;\");\n\t\t\tdst += 4;\n\t\t\tspace -= 4;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tstrcpy(dst, \"&gt;\");\n\t\t\tdst += 4;\n\t\t\tspace -= 4;\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tstrcpy(dst, \"&quot;\");\n\t\t\tdst += 6;\n\t\t\tspace -= 6;\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tstrcpy(dst, \"&apos;\");\n\t\t\tdst += 6;\n\t\t\tspace -= 6;\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tstrcpy(dst, \"&amp;\");\n\t\t\tdst += 5;\n\t\t\tspace -= 5;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*dst++ = mode ? tolower(*src) : *src;\n\t\t\tspace--;\n\t\t}\n\t}\n}\n\nstruct variable_count {\n\tchar *varname;\n\tint count;\n};\n\nstatic int variable_count_hash_fn(const void *vvc, const int flags)\n{\n\tconst struct variable_count *vc = vvc;\n\n\treturn ast_str_hash(vc->varname);\n}\n\nstatic int variable_count_cmp_fn(void *obj, void *vstr, int flags)\n{\n\t/* Due to the simplicity of struct variable_count, it makes no difference\n\t * if you pass in objects or strings, the same operation applies. This is\n\t * due to the fact that the hash occurs on the first element, which means\n\t * the address of both the struct and the string are exactly the same. */\n\tstruct variable_count *vc = obj;\n\tchar *str = vstr;\n\treturn !strcmp(vc->varname, str) ? CMP_MATCH | CMP_STOP : 0;\n}\n\n/*! \\brief Convert the input into XML or HTML.\n * The input is supposed to be a sequence of lines of the form\n *\tName: value\n * optionally followed by a blob of unformatted text.\n * A blank line is a section separator. Basically, this is a\n * mixture of the format of Manager Interface and CLI commands.\n * The unformatted text is considered as a single value of a field\n * named 'Opaque-data'.\n *\n * At the moment the output format is the following (but it may\n * change depending on future requirements so don't count too\n * much on it when writing applications):\n *\n * General: the unformatted text is used as a value of\n * XML output:  to be completed\n *\n * \\verbatim\n *   Each section is within <response type=\"object\" id=\"xxx\">\n *   where xxx is taken from ajaxdest variable or defaults to unknown\n *   Each row is reported as an attribute Name=\"value\" of an XML\n *   entity named from the variable ajaxobjtype, default to \"generic\"\n * \\endverbatim\n *\n * HTML output:\n *   each Name-value pair is output as a single row of a two-column table.\n *   Sections (blank lines in the input) are separated by a <HR>\n *\n */\nstatic void xml_translate(struct ast_str **out, char *in, struct ast_variable *get_vars, enum output_format format)\n{\n\tstruct ast_variable *v;\n\tconst char *dest = NULL;\n\tchar *var, *val;\n\tconst char *objtype = NULL;\n\tint in_data = 0;\t/* parsing data */\n\tint inobj = 0;\n\tint xml = (format == FORMAT_XML);\n\tstruct variable_count *vc = NULL;\n\tstruct ao2_container *vco = NULL;\n\n\tif (xml) {\n\t\t/* dest and objtype need only for XML format */\n\t\tfor (v = get_vars; v; v = v->next) {\n\t\t\tif (!strcasecmp(v->name, \"ajaxdest\")) {\n\t\t\t\tdest = v->value;\n\t\t\t} else if (!strcasecmp(v->name, \"ajaxobjtype\")) {\n\t\t\t\tobjtype = v->value;\n\t\t\t}\n\t\t}\n\t\tif (ast_strlen_zero(dest)) {\n\t\t\tdest = \"unknown\";\n\t\t}\n\t\tif (ast_strlen_zero(objtype)) {\n\t\t\tobjtype = \"generic\";\n\t\t}\n\t}\n\n\t/* we want to stop when we find an empty line */\n\twhile (in && *in) {\n\t\tval = strsep(&in, \"\\r\\n\");\t/* mark start and end of line */\n\t\tif (in && *in == '\\n') {\t/* remove trailing \\n if any */\n\t\t\tin++;\n\t\t}\n\t\tast_trim_blanks(val);\n\t\tast_debug(5, \"inobj %d in_data %d line <%s>\\n\", inobj, in_data, val);\n\t\tif (ast_strlen_zero(val)) {\n\t\t\t/* empty line */\n\t\t\tif (in_data) {\n\t\t\t\t/* close data in Opaque mode */\n\t\t\t\tast_str_append(out, 0, xml ? \"'\" : \"</td></tr>\\n\");\n\t\t\t\tin_data = 0;\n\t\t\t}\n\n\t\t\tif (inobj) {\n\t\t\t\t/* close block */\n\t\t\t\tast_str_append(out, 0, xml ? \" /></response>\\n\" :\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\"><hr></td></tr>\\r\\n\");\n\t\t\t\tinobj = 0;\n\t\t\t\tao2_ref(vco, -1);\n\t\t\t\tvco = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!inobj) {\n\t\t\t/* start new block */\n\t\t\tif (xml) {\n\t\t\t\tast_str_append(out, 0, \"<response type='object' id='%s'><%s\", dest, objtype);\n\t\t\t}\n\t\t\tvco = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_MUTEX, 0, 37,\n\t\t\t\tvariable_count_hash_fn, NULL, variable_count_cmp_fn);\n\t\t\tinobj = 1;\n\t\t}\n\n\t\tif (in_data) {\n\t\t\t/* Process data field in Opaque mode. This is a\n\t\t\t * followup, so we re-add line feeds. */\n\t\t\tast_str_append(out, 0, xml ? \"\\n\" : \"<br>\\n\");\n\t\t\txml_copy_escape(out, val, 0);   /* data field */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We expect \"Name: value\" line here */\n\t\tvar = strsep(&val, \":\");\n\t\tif (val) {\n\t\t\t/* found the field name */\n\t\t\tval = ast_skip_blanks(val);\n\t\t\tast_trim_blanks(var);\n\t\t} else {\n\t\t\t/* field name not found, switch to opaque mode */\n\t\t\tval = var;\n\t\t\tvar = \"Opaque-data\";\n\t\t\tin_data = 1;\n\t\t}\n\n\n\t\tast_str_append(out, 0, xml ? \" \" : \"<tr><td>\");\n\t\tif ((vc = ao2_find(vco, var, 0))) {\n\t\t\tvc->count++;\n\t\t} else {\n\t\t\t/* Create a new entry for this one */\n\t\t\tvc = ao2_alloc(sizeof(*vc), NULL);\n\t\t\tvc->varname = var;\n\t\t\tvc->count = 1;\n\t\t\tao2_link(vco, vc);\n\t\t}\n\n\t\txml_copy_escape(out, var, xml ? 1 | 2 : 0); /* data name */\n\t\tif (vc->count > 1) {\n\t\t\tast_str_append(out, 0, \"-%d\", vc->count);\n\t\t}\n\t\tao2_ref(vc, -1);\n\t\tast_str_append(out, 0, xml ? \"='\" : \"</td><td>\");\n\t\txml_copy_escape(out, val, 0);\t/* data field */\n\t\tif (!in_data || !*in) {\n\t\t\tast_str_append(out, 0, xml ? \"'\" : \"</td></tr>\\n\");\n\t\t}\n\t}\n\n\tif (inobj) {\n\t\tast_str_append(out, 0, xml ? \" /></response>\\n\" :\n\t\t\t\"<tr><td colspan=\\\"2\\\"><hr></td></tr>\\r\\n\");\n\t\tao2_ref(vco, -1);\n\t}\n}\n\nstatic void close_mansession_file(struct mansession *s)\n{\n\tif (s->stream) {\n\t\tast_iostream_close(s->stream);\n\t\ts->stream = NULL;\n\t} else {\n\t\tast_log(LOG_ERROR, \"Attempted to close file/file descriptor on mansession without a valid file or file descriptor.\\n\");\n\t}\n}\n\nstatic void process_output(struct mansession *s, struct ast_str **out, struct ast_variable *params, enum output_format format)\n{\n\tchar *buf;\n\toff_t l;\n\tint fd;\n\n\tif (!s->stream)\n\t\treturn;\n\n\t/* Ensure buffer is NULL-terminated */\n\tast_iostream_write(s->stream, \"\", 1);\n\n\tfd = ast_iostream_get_fd(s->stream);\n\n\tl = lseek(fd, 0, SEEK_CUR);\n\tif (l > 0) {\n\t\tif (MAP_FAILED == (buf = mmap(NULL, l, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0))) {\n\t\t\tast_log(LOG_WARNING, \"mmap failed.  Manager output was not processed\\n\");\n\t\t} else {\n\t\t\tif (format == FORMAT_XML || format == FORMAT_HTML) {\n\t\t\t\txml_translate(out, buf, params, format);\n\t\t\t} else {\n\t\t\t\tast_str_append(out, 0, \"%s\", buf);\n\t\t\t}\n\t\t\tmunmap(buf, l);\n\t\t}\n\t} else if (format == FORMAT_XML || format == FORMAT_HTML) {\n\t\txml_translate(out, \"\", params, format);\n\t}\n\n\tclose_mansession_file(s);\n}\n\nstatic int generic_http_callback(struct ast_tcptls_session_instance *ser,\n\t\t\t\t\t     enum ast_http_method method,\n\t\t\t\t\t     enum output_format format,\n\t\t\t\t\t     const struct ast_sockaddr *remote_address, const char *uri,\n\t\t\t\t\t     struct ast_variable *get_params,\n\t\t\t\t\t     struct ast_variable *headers)\n{\n\tstruct mansession s = { .session = NULL, .tcptls_session = ser };\n\tstruct mansession_session *session = NULL;\n\tuint32_t ident;\n\tint fd;\n\tint blastaway = 0;\n\tstruct ast_variable *params = get_params;\n\tchar template[] = \"/tmp/ast-http-XXXXXX\";\t/* template for temporary file */\n\tstruct ast_str *http_header = NULL, *out = NULL;\n\tstruct message m = { 0 };\n\n\tif (method != AST_HTTP_GET && method != AST_HTTP_HEAD && method != AST_HTTP_POST) {\n\t\tast_http_error(ser, 501, \"Not Implemented\", \"Attempt to use unimplemented / unsupported method\");\n\t\treturn 0;\n\t}\n\n\tident = ast_http_manid_from_vars(headers);\n\n\tif (!(session = find_session(ident, 1))) {\n\n\t\t/**/\n\t\t/* Create new session.\n\t\t * While it is not in the list we don't need any locking\n\t\t */\n\t\tif (!(session = build_mansession(remote_address))) {\n\t\t\tast_http_request_close_on_completion(ser);\n\t\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (out of memory)\");\n\t\t\treturn 0;\n\t\t}\n\t\tao2_lock(session);\n\t\tsession->send_events = 0;\n\t\tsession->inuse = 1;\n\t\t/*!\n\t\t * \\note There is approximately a 1 in 1.8E19 chance that the following\n\t\t * calculation will produce 0, which is an invalid ID, but due to the\n\t\t * properties of the rand() function (and the constancy of s), that\n\t\t * won't happen twice in a row.\n\t\t */\n\t\twhile ((session->managerid = ast_random() ^ (unsigned long) session) == 0) {\n\t\t}\n\t\tsession->last_ev = grab_last();\n\t\tAST_LIST_HEAD_INIT_NOLOCK(&session->datastores);\n\t}\n\tao2_unlock(session);\n\n\thttp_header = ast_str_create(128);\n\tout = ast_str_create(2048);\n\n\tast_mutex_init(&s.lock);\n\n\tif (http_header == NULL || out == NULL) {\n\t\tast_http_request_close_on_completion(ser);\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (ast_str_create() out of memory)\");\n\t\tgoto generic_callback_out;\n\t}\n\n\ts.session = session;\n\tfd = mkstemp(template);\t/* create a temporary file for command output */\n\tunlink(template);\n\tif (fd <= -1) {\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (mkstemp failed)\");\n\t\tgoto generic_callback_out;\n\t}\n\ts.stream = ast_iostream_from_fd(&fd);\n\tif (!s.stream) {\n\t\tast_log(LOG_WARNING, \"HTTP Manager, fdopen failed: %s!\\n\", strerror(errno));\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (fdopen failed)\");\n\t\tclose(fd);\n\t\tgoto generic_callback_out;\n\t}\n\n\tif (method == AST_HTTP_POST) {\n\t\tparams = ast_http_get_post_vars(ser, headers);\n\t\tif (!params) {\n\t\t\tswitch (errno) {\n\t\t\tcase EFBIG:\n\t\t\t\tast_http_error(ser, 413, \"Request Entity Too Large\", \"Body too large\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto generic_callback_out;\n\t\t\tcase ENOMEM:\n\t\t\t\tast_http_request_close_on_completion(ser);\n\t\t\t\tast_http_error(ser, 500, \"Server Error\", \"Out of memory\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto generic_callback_out;\n\t\t\tcase EIO:\n\t\t\t\tast_http_error(ser, 400, \"Bad Request\", \"Error parsing request body\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto generic_callback_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tastman_append_headers(&m, params);\n\n\tif (process_message(&s, &m)) {\n\t\tif (session->authenticated) {\n\t\t\tif (manager_displayconnects(session)) {\n\t\t\t\tast_verb(2, \"HTTP Manager '%s' logged off from %s\\n\", session->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t\t}\n\t\t} else {\n\t\t\tif (displayconnects) {\n\t\t\t\tast_verb(2, \"HTTP Connect attempt from '%s' unable to authenticate\\n\", ast_sockaddr_stringify_addr(&session->addr));\n\t\t\t}\n\t\t}\n\t\tsession->needdestroy = 1;\n\t}\n\n\tastman_free_headers(&m);\n\n\tast_str_append(&http_header, 0,\n\t\t\"Content-type: text/%s\\r\\n\"\n\t\t\"Set-Cookie: mansession_id=\\\"%08x\\\"; Version=1; Max-Age=%d\\r\\n\"\n\t\t\"Pragma: SuppressEvents\\r\\n\",\n\t\tcontenttype[format],\n\t\tsession->managerid, httptimeout);\n\n\tif (format == FORMAT_XML) {\n\t\tast_str_append(&out, 0, \"<ajax-response>\\n\");\n\t} else if (format == FORMAT_HTML) {\n\t\t/*\n\t\t * When handling AMI-over-HTTP in HTML format, we provide a simple form for\n\t\t * debugging purposes. This HTML code should not be here, we\n\t\t * should read from some config file...\n\t\t */\n\n#define ROW_FMT\t\"<tr><td colspan=\\\"2\\\" bgcolor=\\\"#f1f1ff\\\">%s</td></tr>\\r\\n\"\n#define TEST_STRING \\\n\t\"<form action=\\\"manager\\\" method=\\\"post\\\">\\n\\\n\tAction: <select name=\\\"action\\\">\\n\\\n\t\t<option value=\\\"\\\">-----&gt;</option>\\n\\\n\t\t<option value=\\\"login\\\">login</option>\\n\\\n\t\t<option value=\\\"command\\\">Command</option>\\n\\\n\t\t<option value=\\\"waitevent\\\">waitevent</option>\\n\\\n\t\t<option value=\\\"listcommands\\\">listcommands</option>\\n\\\n\t</select>\\n\\\n\tor <input name=\\\"action\\\"><br/>\\n\\\n\tCLI Command <input name=\\\"command\\\"><br>\\n\\\n\tuser <input name=\\\"username\\\"> pass <input type=\\\"password\\\" name=\\\"secret\\\"><br>\\n\\\n\t<input type=\\\"submit\\\">\\n</form>\\n\"\n\n\t\tast_str_append(&out, 0, \"<title>Asterisk&trade; Manager Interface</title>\");\n\t\tast_str_append(&out, 0, \"<body bgcolor=\\\"#ffffff\\\"><table align=center bgcolor=\\\"#f1f1f1\\\" width=\\\"500\\\">\\r\\n\");\n\t\tast_str_append(&out, 0, ROW_FMT, \"<h1>Manager Tester</h1>\");\n\t\tast_str_append(&out, 0, ROW_FMT, TEST_STRING);\n\t}\n\n\tprocess_output(&s, &out, params, format);\n\n\tif (format == FORMAT_XML) {\n\t\tast_str_append(&out, 0, \"</ajax-response>\\n\");\n\t} else if (format == FORMAT_HTML) {\n\t\tast_str_append(&out, 0, \"</table></body>\\r\\n\");\n\t}\n\n\tao2_lock(session);\n\t/* Reset HTTP timeout.  If we're not authenticated, keep it extremely short */\n\tsession->sessiontimeout = time(NULL) + ((session->authenticated || httptimeout < 5) ? httptimeout : 5);\n\n\tif (session->needdestroy) {\n\t\tif (session->inuse == 1) {\n\t\t\tast_debug(1, \"Need destroy, doing it now!\\n\");\n\t\t\tblastaway = 1;\n\t\t} else {\n\t\t\tast_debug(1, \"Need destroy, but can't do it yet!\\n\");\n\t\t\tast_mutex_lock(&session->notify_lock);\n\t\t\tif (session->waiting_thread != AST_PTHREADT_NULL) {\n\t\t\t\tpthread_kill(session->waiting_thread, SIGURG);\n\t\t\t}\n\t\t\tast_mutex_unlock(&session->notify_lock);\n\t\t\tsession->inuse--;\n\t\t}\n\t} else {\n\t\tsession->inuse--;\n\t}\n\tao2_unlock(session);\n\n\tast_http_send(ser, method, 200, NULL, http_header, out, 0, 0);\n\thttp_header = NULL;\n\tout = NULL;\n\ngeneric_callback_out:\n\tast_mutex_destroy(&s.lock);\n\n\t/* Clear resource */\n\n\tif (method == AST_HTTP_POST && params) {\n\t\tast_variables_destroy(params);\n\t}\n\tast_free(http_header);\n\tast_free(out);\n\n\tif (session) {\n\t\tif (blastaway) {\n\t\t\tsession_destroy(session);\n\t\t} else {\n\t\t\tif (session->stream) {\n\t\t\t\tast_iostream_close(session->stream);\n\t\t\t\tsession->stream = NULL;\n\t\t\t}\n\t\t\tunref_mansession(session);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int auth_http_callback(struct ast_tcptls_session_instance *ser,\n\t\t\t\t\t     enum ast_http_method method,\n\t\t\t\t\t     enum output_format format,\n\t\t\t\t\t     const struct ast_sockaddr *remote_address, const char *uri,\n\t\t\t\t\t     struct ast_variable *get_params,\n\t\t\t\t\t     struct ast_variable *headers)\n{\n\tstruct mansession_session *session = NULL;\n\tstruct mansession s = { .session = NULL, .tcptls_session = ser };\n\tstruct ast_variable *v, *params = get_params;\n\tchar template[] = \"/tmp/ast-http-XXXXXX\";\t/* template for temporary file */\n\tstruct ast_str *http_header = NULL, *out = NULL;\n\tsize_t result_size;\n\tstruct message m = { 0 };\n\tint fd;\n\n\ttime_t time_now = time(NULL);\n\tunsigned long nonce = 0, nc;\n\tstruct ast_http_digest d = { NULL, };\n\tstruct ast_manager_user *user = NULL;\n\tint stale = 0;\n\tchar resp_hash[256]=\"\";\n\t/* Cache for user data */\n\tchar u_username[80];\n\tint u_readperm;\n\tint u_writeperm;\n\tint u_writetimeout;\n\tint u_displayconnects;\n\n\tif (method != AST_HTTP_GET && method != AST_HTTP_HEAD && method != AST_HTTP_POST) {\n\t\tast_http_error(ser, 501, \"Not Implemented\", \"Attempt to use unimplemented / unsupported method\");\n\t\treturn 0;\n\t}\n\n\t/* Find \"Authorization: \" header */\n\tfor (v = headers; v; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"Authorization\")) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!v || ast_strlen_zero(v->value)) {\n\t\tgoto out_401; /* Authorization Header not present - send auth request */\n\t}\n\n\t/* Digest found - parse */\n\tif (ast_string_field_init(&d, 128)) {\n\t\tast_http_request_close_on_completion(ser);\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (out of memory)\");\n\t\treturn 0;\n\t}\n\n\tif (ast_parse_digest(v->value, &d, 0, 1)) {\n\t\t/* Error in Digest - send new one */\n\t\tnonce = 0;\n\t\tgoto out_401;\n\t}\n\tif (sscanf(d.nonce, \"%30lx\", &nonce) != 1) {\n\t\tast_log(LOG_WARNING, \"Received incorrect nonce in Digest <%s>\\n\", d.nonce);\n\t\tnonce = 0;\n\t\tgoto out_401;\n\t}\n\n\tAST_RWLIST_WRLOCK(&users);\n\tuser = get_manager_by_name_locked(d.username);\n\tif(!user) {\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\tast_log(LOG_NOTICE, \"%s tried to authenticate with nonexistent user '%s'\\n\", ast_sockaddr_stringify_addr(&session->addr), d.username);\n\t\tnonce = 0;\n\t\tgoto out_401;\n\t}\n\n\t/* --- We have User for this auth, now check ACL */\n\tif (user->acl && !ast_apply_acl(user->acl, remote_address, \"Manager User ACL:\")) {\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\tast_log(LOG_NOTICE, \"%s failed to pass IP ACL as '%s'\\n\", ast_sockaddr_stringify_addr(&session->addr), d.username);\n\t\tast_http_request_close_on_completion(ser);\n\t\tast_http_error(ser, 403, \"Permission denied\", \"Permission denied\");\n\t\treturn 0;\n\t}\n\n\t/* --- We have auth, so check it */\n\n\t/* compute the expected response to compare with what we received */\n\t{\n\t\tchar *a2;\n\t\t/* ast_md5_hash outputs 32 characters plus NULL terminator. */\n\t\tchar a2_hash[33];\n\t\tchar resp[256];\n\n\t\t/* XXX Now request method are hardcoded in A2 */\n\t\tif (ast_asprintf(&a2, \"%s:%s\", ast_get_http_method(method), d.uri) < 0) {\n\t\t\tAST_RWLIST_UNLOCK(&users);\n\t\t\tast_http_request_close_on_completion(ser);\n\t\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (out of memory)\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tast_md5_hash(a2_hash, a2);\n\t\tast_free(a2);\n\n\t\tif (d.qop) {\n\t\t\t/* RFC 2617 */\n\t\t\tsnprintf(resp, sizeof(resp), \"%s:%08lx:%s:%s:auth:%s\", user->a1_hash, nonce, d.nc, d.cnonce, a2_hash);\n\t\t}  else {\n\t\t\t/* RFC 2069 */\n\t\t\tsnprintf(resp, sizeof(resp), \"%s:%08lx:%s\", user->a1_hash, nonce, a2_hash);\n\t\t}\n\t\tast_md5_hash(resp_hash, resp);\n\t}\n\n\tif (strncasecmp(d.response, resp_hash, strlen(resp_hash))) {\n\t\t/* Something was wrong, so give the client to try with a new challenge */\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\tnonce = 0;\n\t\tgoto out_401;\n\t}\n\n\t/*\n\t * User are pass Digest authentication.\n\t * Now, cache the user data and unlock user list.\n\t */\n\tast_copy_string(u_username, user->username, sizeof(u_username));\n\tu_readperm = user->readperm;\n\tu_writeperm = user->writeperm;\n\tu_displayconnects = user->displayconnects;\n\tu_writetimeout = user->writetimeout;\n\tAST_RWLIST_UNLOCK(&users);\n\n\tif (!(session = find_session_by_nonce(d.username, nonce, &stale))) {\n\t\t/*\n\t\t * Create new session.\n\t\t * While it is not in the list we don't need any locking\n\t\t */\n\t\tif (!(session = build_mansession(remote_address))) {\n\t\t\tast_http_request_close_on_completion(ser);\n\t\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (out of memory)\");\n\t\t\treturn 0;\n\t\t}\n\t\tao2_lock(session);\n\n\t\tast_copy_string(session->username, u_username, sizeof(session->username));\n\t\tsession->managerid = nonce;\n\t\tsession->last_ev = grab_last();\n\t\tAST_LIST_HEAD_INIT_NOLOCK(&session->datastores);\n\n\t\tsession->readperm = u_readperm;\n\t\tsession->writeperm = u_writeperm;\n\t\tsession->writetimeout = u_writetimeout;\n\n\t\tif (u_displayconnects) {\n\t\t\tast_verb(2, \"HTTP Manager '%s' logged in from %s\\n\", session->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t}\n\t\tsession->noncetime = session->sessionstart = time_now;\n\t\tsession->authenticated = 1;\n\t} else if (stale) {\n\t\t/*\n\t\t * Session found, but nonce is stale.\n\t\t *\n\t\t * This could be because an old request (w/old nonce) arrived.\n\t\t *\n\t\t * This may be as the result of http proxy usage (separate delay or\n\t\t * multipath) or in a situation where a page was refreshed too quickly\n\t\t * (seen in Firefox).\n\t\t *\n\t\t * In this situation, we repeat the 401 auth with the current nonce\n\t\t * value.\n\t\t */\n\t\tnonce = session->managerid;\n\t\tao2_unlock(session);\n\t\tstale = 1;\n\t\tgoto out_401;\n\t} else {\n\t\tsscanf(d.nc, \"%30lx\", &nc);\n\t\tif (session->nc >= nc || ((time_now - session->noncetime) > 62) ) {\n\t\t\t/*\n\t\t\t * Nonce time expired (> 2 minutes) or something wrong with nonce\n\t\t\t * counter.\n\t\t\t *\n\t\t\t * Create new nonce key and resend Digest auth request. Old nonce\n\t\t\t * is saved for stale checking...\n\t\t\t */\n\t\t\tsession->nc = 0; /* Reset nonce counter */\n\t\t\tsession->oldnonce = session->managerid;\n\t\t\tnonce = session->managerid = ast_random();\n\t\t\tsession->noncetime = time_now;\n\t\t\tao2_unlock(session);\n\t\t\tstale = 1;\n\t\t\tgoto out_401;\n\t\t} else {\n\t\t\tsession->nc = nc; /* All OK, save nonce counter */\n\t\t}\n\t}\n\n\n\t/* Reset session timeout. */\n\tsession->sessiontimeout = time(NULL) + (httptimeout > 5 ? httptimeout : 5);\n\tao2_unlock(session);\n\n\tast_mutex_init(&s.lock);\n\ts.session = session;\n\tfd = mkstemp(template);\t/* create a temporary file for command output */\n\tunlink(template);\n\tif (fd <= -1) {\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (mkstemp failed)\");\n\t\tgoto auth_callback_out;\n\t}\n\ts.stream = ast_iostream_from_fd(&fd);\n\tif (!s.stream) {\n\t\tast_log(LOG_WARNING, \"HTTP Manager, fdopen failed: %s!\\n\", strerror(errno));\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (fdopen failed)\");\n\t\tclose(fd);\n\t\tgoto auth_callback_out;\n\t}\n\n\tif (method == AST_HTTP_POST) {\n\t\tparams = ast_http_get_post_vars(ser, headers);\n\t\tif (!params) {\n\t\t\tswitch (errno) {\n\t\t\tcase EFBIG:\n\t\t\t\tast_http_error(ser, 413, \"Request Entity Too Large\", \"Body too large\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto auth_callback_out;\n\t\t\tcase ENOMEM:\n\t\t\t\tast_http_request_close_on_completion(ser);\n\t\t\t\tast_http_error(ser, 500, \"Server Error\", \"Out of memory\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto auth_callback_out;\n\t\t\tcase EIO:\n\t\t\t\tast_http_error(ser, 400, \"Bad Request\", \"Error parsing request body\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto auth_callback_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tastman_append_headers(&m, params);\n\n\tif (process_message(&s, &m)) {\n\t\tif (u_displayconnects) {\n\t\t\tast_verb(2, \"HTTP Manager '%s' logged off from %s\\n\", session->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t}\n\n\t\tsession->needdestroy = 1;\n\t}\n\n\tastman_free_headers(&m);\n\n\tresult_size = lseek(ast_iostream_get_fd(s.stream), 0, SEEK_CUR); /* Calculate approx. size of result */\n\n\thttp_header = ast_str_create(80);\n\tout = ast_str_create(result_size * 2 + 512);\n\tif (http_header == NULL || out == NULL) {\n\t\tast_http_request_close_on_completion(ser);\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (ast_str_create() out of memory)\");\n\t\tclose_mansession_file(&s);\n\t\tgoto auth_callback_out;\n\t}\n\n\tast_str_append(&http_header, 0, \"Content-type: text/%s\\r\\n\", contenttype[format]);\n\n\tif (format == FORMAT_XML) {\n\t\tast_str_append(&out, 0, \"<ajax-response>\\n\");\n\t} else if (format == FORMAT_HTML) {\n\t\tast_str_append(&out, 0,\n\t\t\"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\r\\n\"\n\t\t\"<html><head>\\r\\n\"\n\t\t\"<title>Asterisk&trade; Manager Interface</title>\\r\\n\"\n\t\t\"</head><body style=\\\"background-color: #ffffff;\\\">\\r\\n\"\n\t\t\"<form method=\\\"POST\\\">\\r\\n\"\n\t\t\"<table align=\\\"center\\\" style=\\\"background-color: #f1f1f1;\\\" width=\\\"500\\\">\\r\\n\"\n\t\t\"<tr><th colspan=\\\"2\\\" style=\\\"background-color: #f1f1ff;\\\"><h1>Manager Tester</h1></th></tr>\\r\\n\"\n\t\t\"<tr><th colspan=\\\"2\\\" style=\\\"background-color: #f1f1ff;\\\">Action: <input name=\\\"action\\\" /> Cmd: <input name=\\\"command\\\" /><br>\"\n\t\t\"<input type=\\\"submit\\\" value=\\\"Send request\\\" /></th></tr>\\r\\n\");\n\t}\n\n\tprocess_output(&s, &out, params, format);\n\n\tif (format == FORMAT_XML) {\n\t\tast_str_append(&out, 0, \"</ajax-response>\\n\");\n\t} else if (format == FORMAT_HTML) {\n\t\tast_str_append(&out, 0, \"</table></form></body></html>\\r\\n\");\n\t}\n\n\tast_http_send(ser, method, 200, NULL, http_header, out, 0, 0);\n\thttp_header = NULL;\n\tout = NULL;\n\nauth_callback_out:\n\tast_mutex_destroy(&s.lock);\n\n\t/* Clear resources and unlock manager session */\n\tif (method == AST_HTTP_POST && params) {\n\t\tast_variables_destroy(params);\n\t}\n\n\tast_free(http_header);\n\tast_free(out);\n\n\tao2_lock(session);\n\tif (session->stream) {\n\t\tast_iostream_close(session->stream);\n\t\tsession->stream = NULL;\n\t}\n\tao2_unlock(session);\n\n\tif (session->needdestroy) {\n\t\tast_debug(1, \"Need destroy, doing it now!\\n\");\n\t\tsession_destroy(session);\n\t}\n\tast_string_field_free_memory(&d);\n\treturn 0;\n\nout_401:\n\tif (!nonce) {\n\t\tnonce = ast_random();\n\t}\n\n\tast_http_auth(ser, global_realm, nonce, nonce, stale, NULL);\n\tast_string_field_free_memory(&d);\n\treturn 0;\n}\n\nstatic int manager_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params,  struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = generic_http_callback(ser, method, FORMAT_HTML, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic int mxml_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params, struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = generic_http_callback(ser, method, FORMAT_XML, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic int rawman_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params, struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = generic_http_callback(ser, method, FORMAT_RAW, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic struct ast_http_uri rawmanuri = {\n\t.description = \"Raw HTTP Manager Event Interface\",\n\t.uri = \"rawman\",\n\t.callback = rawman_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\nstatic struct ast_http_uri manageruri = {\n\t.description = \"HTML Manager Event Interface\",\n\t.uri = \"manager\",\n\t.callback = manager_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\nstatic struct ast_http_uri managerxmluri = {\n\t.description = \"XML Manager Event Interface\",\n\t.uri = \"mxml\",\n\t.callback = mxml_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\n\n/* Callback with Digest authentication */\nstatic int auth_manager_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params,  struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = auth_http_callback(ser, method, FORMAT_HTML, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic int auth_mxml_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params, struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = auth_http_callback(ser, method, FORMAT_XML, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic int auth_rawman_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params, struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = auth_http_callback(ser, method, FORMAT_RAW, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic struct ast_http_uri arawmanuri = {\n\t.description = \"Raw HTTP Manager Event Interface w/Digest authentication\",\n\t.uri = \"arawman\",\n\t.has_subtree = 0,\n\t.callback = auth_rawman_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\nstatic struct ast_http_uri amanageruri = {\n\t.description = \"HTML Manager Event Interface w/Digest authentication\",\n\t.uri = \"amanager\",\n\t.has_subtree = 0,\n\t.callback = auth_manager_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\nstatic struct ast_http_uri amanagerxmluri = {\n\t.description = \"XML Manager Event Interface w/Digest authentication\",\n\t.uri = \"amxml\",\n\t.has_subtree = 0,\n\t.callback = auth_mxml_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\n/*! \\brief Get number of logged in sessions for a login name */\nstatic int get_manager_sessions_cb(void *obj, void *arg, void *data, int flags)\n{\n\tstruct mansession_session *session = obj;\n\tconst char *login = (char *)arg;\n\tint *no_sessions = data;\n\n\tif (strcasecmp(session->username, login) == 0) {\n\t\t(*no_sessions)++;\n\t}\n\n\treturn 0;\n}\n\n\n/*! \\brief  ${AMI_CLIENT()} Dialplan function - reads manager client data */\nstatic int function_amiclient(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tstruct ast_manager_user *user = NULL;\n\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(name);\n\t\tAST_APP_ARG(param);\n\t);\n\n\n\tif (ast_strlen_zero(data) ) {\n\t\tast_log(LOG_WARNING, \"AMI_CLIENT() requires two arguments: AMI_CLIENT(<name>[,<arg>])\\n\");\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\targs.name = ast_strip(args.name);\n\targs.param = ast_strip(args.param);\n\n\tAST_RWLIST_RDLOCK(&users);\n\tif (!(user = get_manager_by_name_locked(args.name))) {\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\tast_log(LOG_ERROR, \"There's no manager user called : \\\"%s\\\"\\n\", args.name);\n\t\treturn -1;\n\t}\n\tAST_RWLIST_UNLOCK(&users);\n\n\tif (!strcasecmp(args.param, \"sessions\")) {\n\t\tint no_sessions = 0;\n\t\tstruct ao2_container *sessions;\n\n\t\tsessions = ao2_global_obj_ref(mgr_sessions);\n\t\tif (sessions) {\n\t\t\tao2_callback_data(sessions, 0, get_manager_sessions_cb, /*login name*/ data, &no_sessions);\n\t\t\tao2_ref(sessions, -1);\n\t\t}\n\t\tsnprintf(buf, len, \"%d\", no_sessions);\n\t} else {\n\t\tast_log(LOG_ERROR, \"Invalid arguments provided to function AMI_CLIENT: %s\\n\", args.param);\n\t\treturn -1;\n\n\t}\n\n\treturn 0;\n}\n\n\n/*! \\brief description of AMI_CLIENT dialplan function */\nstatic struct ast_custom_function managerclient_function = {\n\t.name = \"AMI_CLIENT\",\n\t.read = function_amiclient,\n\t.read_max = 12,\n};\n\nstatic int webregged = 0;\n\n/*! \\brief cleanup code called at each iteration of server_root,\n * guaranteed to happen every 5 seconds at most\n */\nstatic void purge_old_stuff(void *data)\n{\n\tstruct ast_tcptls_session_args *ser = data;\n\t/* purge_sessions will return the number of sessions actually purged,\n\t * up to a maximum of it's arguments, purge one at a time, keeping a\n\t * purge interval of 1ms as long as we purged a session, otherwise\n\t * revert to a purge check every 5s\n\t */\n\tif (purge_sessions(1) == 1) {\n\t\tser->poll_timeout = 1;\n\t} else {\n\t\tser->poll_timeout = 5000;\n\t}\n\tpurge_events();\n}\n\nstatic struct ast_tls_config ami_tls_cfg;\nstatic struct ast_tcptls_session_args ami_desc = {\n\t.accept_fd = -1,\n\t.master = AST_PTHREADT_NULL,\n\t.tls_cfg = NULL,\n\t.poll_timeout = 5000,\t/* wake up every 5 seconds */\n\t.periodic_fn = purge_old_stuff,\n\t.name = \"AMI server\",\n\t.accept_fn = ast_tcptls_server_root,\t/* thread doing the accept() */\n\t.worker_fn = session_do,\t/* thread handling the session */\n};\n\nstatic struct ast_tcptls_session_args amis_desc = {\n\t.accept_fd = -1,\n\t.master = AST_PTHREADT_NULL,\n\t.tls_cfg = &ami_tls_cfg,\n\t.poll_timeout = -1,\t/* the other does the periodic cleanup */\n\t.name = \"AMI TLS server\",\n\t.accept_fn = ast_tcptls_server_root,\t/* thread doing the accept() */\n\t.worker_fn = session_do,\t/* thread handling the session */\n};\n\n/*! \\brief CLI command manager show settings */\nstatic char *handle_manager_show_settings(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show settings\";\n\t\te->usage =\n\t\t\t\"Usage: manager show settings\\n\"\n\t\t\t\"       Provides detailed list of the configuration of the Manager.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n#define FORMAT \"  %-25.25s  %-15.55s\\n\"\n#define FORMAT2 \"  %-25.25s  %-15d\\n\"\n#define FORMAT3 \"  %-25.25s  %s\\n\"\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tast_cli(a->fd, \"\\nGlobal Settings:\\n\");\n\tast_cli(a->fd, \"----------------\\n\");\n\tast_cli(a->fd, FORMAT, \"Manager (AMI):\", AST_CLI_YESNO(manager_enabled));\n\tast_cli(a->fd, FORMAT, \"Web Manager (AMI/HTTP):\", AST_CLI_YESNO(webmanager_enabled));\n\tast_cli(a->fd, FORMAT, \"TCP Bindaddress:\", manager_enabled != 0 ? ast_sockaddr_stringify(&ami_desc.local_address) : \"Disabled\");\n\tast_cli(a->fd, FORMAT2, \"HTTP Timeout (seconds):\", httptimeout);\n\tast_cli(a->fd, FORMAT, \"TLS Enable:\", AST_CLI_YESNO(ami_tls_cfg.enabled));\n\tast_cli(a->fd, FORMAT, \"TLS Bindaddress:\", ami_tls_cfg.enabled != 0 ? ast_sockaddr_stringify(&amis_desc.local_address) : \"Disabled\");\n\tast_cli(a->fd, FORMAT, \"TLS Certfile:\", ami_tls_cfg.certfile);\n\tast_cli(a->fd, FORMAT, \"TLS Privatekey:\", ami_tls_cfg.pvtfile);\n\tast_cli(a->fd, FORMAT, \"TLS Cipher:\", ami_tls_cfg.cipher);\n\tast_cli(a->fd, FORMAT, \"Allow multiple login:\", AST_CLI_YESNO(allowmultiplelogin));\n\tast_cli(a->fd, FORMAT, \"Display connects:\", AST_CLI_YESNO(displayconnects));\n\tast_cli(a->fd, FORMAT, \"Timestamp events:\", AST_CLI_YESNO(timestampevents));\n\tast_cli(a->fd, FORMAT3, \"Channel vars:\", S_OR(manager_channelvars, \"\"));\n\tast_cli(a->fd, FORMAT3, \"Disabled events:\", S_OR(manager_disabledevents, \"\"));\n\tast_cli(a->fd, FORMAT, \"Debug:\", AST_CLI_YESNO(manager_debug));\n#undef FORMAT\n#undef FORMAT2\n#undef FORMAT3\n\n\treturn CLI_SUCCESS;\n}\n\n#ifdef AST_XML_DOCS\n\nstatic int ast_xml_doc_item_cmp_fn(const void *a, const void *b)\n{\n\tstruct ast_xml_doc_item **item_a = (struct ast_xml_doc_item **)a;\n\tstruct ast_xml_doc_item **item_b = (struct ast_xml_doc_item **)b;\n\treturn strcmp((*item_a)->name, (*item_b)->name);\n}\n\nstatic char *handle_manager_show_events(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ao2_container *events;\n\tstruct ao2_iterator *it_events;\n\tstruct ast_xml_doc_item *item;\n\tstruct ast_xml_doc_item **items;\n\tstruct ast_str *buffer;\n\tint i = 0, totalitems = 0;\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show events\";\n\t\te->usage =\n\t\t\t\"Usage: manager show events\\n\"\n\t\t\t\t\"\tPrints a listing of the available Asterisk manager interface events.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tbuffer = ast_str_create(128);\n\tif (!buffer) {\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tevents = ao2_global_obj_ref(event_docs);\n\tif (!events) {\n\t\tast_cli(a->fd, \"No manager event documentation loaded\\n\");\n\t\tast_free(buffer);\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tao2_lock(events);\n\tif (!(it_events = ao2_callback(events, OBJ_MULTIPLE | OBJ_NOLOCK, NULL, NULL))) {\n\t\tao2_unlock(events);\n\t\tast_log(AST_LOG_ERROR, \"Unable to create iterator for events container\\n\");\n\t\tast_free(buffer);\n\t\tao2_ref(events, -1);\n\t\treturn CLI_SUCCESS;\n\t}\n\tif (!(items = ast_calloc(sizeof(struct ast_xml_doc_item *), ao2_container_count(events)))) {\n\t\tao2_unlock(events);\n\t\tast_log(AST_LOG_ERROR, \"Unable to create temporary sorting array for events\\n\");\n\t\tao2_iterator_destroy(it_events);\n\t\tast_free(buffer);\n\t\tao2_ref(events, -1);\n\t\treturn CLI_SUCCESS;\n\t}\n\tao2_unlock(events);\n\n\twhile ((item = ao2_iterator_next(it_events))) {\n\t\titems[totalitems++] = item;\n\t\tao2_ref(item, -1);\n\t}\n\n\tqsort(items, totalitems, sizeof(struct ast_xml_doc_item *), ast_xml_doc_item_cmp_fn);\n\n\tast_cli(a->fd, \"Events:\\n\");\n\tast_cli(a->fd, \"  --------------------  --------------------  --------------------  \\n\");\n\tfor (i = 0; i < totalitems; i++) {\n\t\tast_str_append(&buffer, 0, \"  %-20.20s\", items[i]->name);\n\t\tif ((i + 1) % 3 == 0) {\n\t\t\tast_cli(a->fd, \"%s\\n\", ast_str_buffer(buffer));\n\t\t\tast_str_set(&buffer, 0, \"%s\", \"\");\n\t\t}\n\t}\n\tif ((i + 1) % 3 != 0) {\n\t\tast_cli(a->fd, \"%s\\n\", ast_str_buffer(buffer));\n\t}\n\n\tao2_iterator_destroy(it_events);\n\tast_free(items);\n\tao2_ref(events, -1);\n\tast_free(buffer);\n\n\treturn CLI_SUCCESS;\n}\n\nstatic void print_event_instance(struct ast_cli_args *a, struct ast_xml_doc_item *instance)\n{\n\tchar syntax_title[64], description_title[64], synopsis_title[64], seealso_title[64], arguments_title[64];\n\n\tterm_color(synopsis_title, \"[Synopsis]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(description_title, \"[Description]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(syntax_title, \"[Syntax]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(seealso_title, \"[See Also]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(arguments_title, \"[Arguments]\\n\", COLOR_MAGENTA, 0, 40);\n\n\tif (!ast_strlen_zero(ast_str_buffer(instance->synopsis))) {\n\t\tchar *synopsis = ast_xmldoc_printable(ast_str_buffer(instance->synopsis), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", synopsis_title, synopsis);\n\t\tast_free(synopsis);\n\t}\n\tif (!ast_strlen_zero(ast_str_buffer(instance->syntax))) {\n\t\tchar *syntax = ast_xmldoc_printable(ast_str_buffer(instance->syntax), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", syntax_title, syntax);\n\t\tast_free(syntax);\n\t}\n\tif (!ast_strlen_zero(ast_str_buffer(instance->description))) {\n\t\tchar *description = ast_xmldoc_printable(ast_str_buffer(instance->description), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", description_title, description);\n\t\tast_free(description);\n\t}\n\tif (!ast_strlen_zero(ast_str_buffer(instance->arguments))) {\n\t\tchar *arguments = ast_xmldoc_printable(ast_str_buffer(instance->arguments), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", arguments_title, arguments);\n\t\tast_free(arguments);\n\t}\n\tif (!ast_strlen_zero(ast_str_buffer(instance->seealso))) {\n\t\tchar *seealso = ast_xmldoc_printable(ast_str_buffer(instance->seealso), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", seealso_title, seealso);\n\t\tast_free(seealso);\n\t}\n}\n\nstatic char *handle_manager_show_event(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tRAII_VAR(struct ao2_container *, events, NULL, ao2_cleanup);\n\tstruct ao2_iterator it_events;\n\tstruct ast_xml_doc_item *item, *temp;\n\tint length;\n\n\tif (cmd == CLI_INIT) {\n\t\te->command = \"manager show event\";\n\t\te->usage =\n\t\t\t\"Usage: manager show event <eventname>\\n\"\n\t\t\t\"       Provides a detailed description a Manager interface event.\\n\";\n\t\treturn NULL;\n\t}\n\n\tevents = ao2_global_obj_ref(event_docs);\n\tif (!events) {\n\t\tast_cli(a->fd, \"No manager event documentation loaded\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tif (cmd == CLI_GENERATE) {\n\t\tif (a->pos != 3) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tlength = strlen(a->word);\n\t\tit_events = ao2_iterator_init(events, 0);\n\t\twhile ((item = ao2_iterator_next(&it_events))) {\n\t\t\tif (!strncasecmp(a->word, item->name, length)) {\n\t\t\t\tif (ast_cli_completion_add(ast_strdup(item->name))) {\n\t\t\t\t\tao2_ref(item, -1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tao2_ref(item, -1);\n\t\t}\n\t\tao2_iterator_destroy(&it_events);\n\n\t\treturn NULL;\n\t}\n\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tif (!(item = ao2_find(events, a->argv[3], OBJ_KEY))) {\n\t\tast_cli(a->fd, \"Could not find event '%s'\\n\", a->argv[3]);\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tast_cli(a->fd, \"Event: %s\\n\", a->argv[3]);\n\tfor (temp = item; temp; temp = AST_LIST_NEXT(temp, next)) {\n\t\tprint_event_instance(a, temp);\n\t}\n\n\tao2_ref(item, -1);\n\treturn CLI_SUCCESS;\n}\n\n#endif\n\nstatic struct ast_cli_entry cli_manager[] = {\n\tAST_CLI_DEFINE(handle_showmancmd, \"Show a manager interface command\"),\n\tAST_CLI_DEFINE(handle_showmancmds, \"List manager interface commands\"),\n\tAST_CLI_DEFINE(handle_showmanconn, \"List connected manager interface users\"),\n\tAST_CLI_DEFINE(handle_showmaneventq, \"List manager interface queued events\"),\n\tAST_CLI_DEFINE(handle_showmanagers, \"List configured manager users\"),\n\tAST_CLI_DEFINE(handle_showmanager, \"Display information on a specific manager user\"),\n\tAST_CLI_DEFINE(handle_mandebug, \"Show, enable, disable debugging of the manager code\"),\n\tAST_CLI_DEFINE(handle_manager_reload, \"Reload manager configurations\"),\n\tAST_CLI_DEFINE(handle_manager_show_settings, \"Show manager global settings\"),\n#ifdef AST_XML_DOCS\n\tAST_CLI_DEFINE(handle_manager_show_events, \"List manager interface events\"),\n\tAST_CLI_DEFINE(handle_manager_show_event, \"Show a manager interface event\"),\n#endif\n};\n\n/*!\n * \\internal\n * \\brief Load the config channelvars variable.\n *\n * \\param var Config variable to load.\n */\nstatic void load_channelvars(struct ast_variable *var)\n{\n\tchar *parse = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(vars)[MAX_VARS];\n\t);\n\n\tast_free(manager_channelvars);\n\tmanager_channelvars = ast_strdup(var->value);\n\n\t/* parse the setting */\n\tparse = ast_strdupa(manager_channelvars);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\n\tast_channel_set_manager_vars(args.argc, args.vars);\n}\n\n/*!\n * \\internal\n * \\brief Load the config disabledevents variable.\n *\n * \\param var Config variable to load.\n */\nstatic void load_disabledevents(struct ast_variable *var)\n{\n\tast_free(manager_disabledevents);\n\tmanager_disabledevents = ast_strdup(var->value);\n}\n\n/*!\n * \\internal\n * \\brief Free a user record.  Should already be removed from the list\n */\nstatic void manager_free_user(struct ast_manager_user *user)\n{\n\tast_free(user->a1_hash);\n\tast_free(user->secret);\n\tif (user->whitefilters) {\n\t\tao2_t_ref(user->whitefilters, -1, \"decrement ref for white container, should be last one\");\n\t}\n\tif (user->blackfilters) {\n\t\tao2_t_ref(user->blackfilters, -1, \"decrement ref for black container, should be last one\");\n\t}\n\tuser->acl = ast_free_acl_list(user->acl);\n\tast_variables_destroy(user->chanvars);\n\tast_free(user);\n}\n\n/*!\n * \\internal\n * \\brief Clean up resources on Asterisk shutdown\n */\nstatic void manager_shutdown(void)\n{\n\tstruct ast_manager_user *user;\n\n\t/* This event is not actually transmitted, but causes all TCP sessions to be closed */\n\tmanager_event(EVENT_FLAG_SHUTDOWN, \"CloseSession\", \"CloseSession: true\\r\\n\");\n\n\tast_manager_unregister(\"Ping\");\n\tast_manager_unregister(\"Events\");\n\tast_manager_unregister(\"Logoff\");\n\tast_manager_unregister(\"Login\");\n\tast_manager_unregister(\"Challenge\");\n\tast_manager_unregister(\"Hangup\");\n\tast_manager_unregister(\"Status\");\n\tast_manager_unregister(\"Setvar\");\n\tast_manager_unregister(\"Getvar\");\n\tast_manager_unregister(\"GetConfig\");\n\tast_manager_unregister(\"GetConfigJSON\");\n\tast_manager_unregister(\"UpdateConfig\");\n\tast_manager_unregister(\"CreateConfig\");\n\tast_manager_unregister(\"ListCategories\");\n\tast_manager_unregister(\"Redirect\");\n\tast_manager_unregister(\"Atxfer\");\n\tast_manager_unregister(\"CancelAtxfer\");\n\tast_manager_unregister(\"Originate\");\n\tast_manager_unregister(\"Command\");\n\tast_manager_unregister(\"ExtensionState\");\n\tast_manager_unregister(\"PresenceState\");\n\tast_manager_unregister(\"AbsoluteTimeout\");\n\tast_manager_unregister(\"MailboxStatus\");\n\tast_manager_unregister(\"MailboxCount\");\n\tast_manager_unregister(\"ListCommands\");\n\tast_manager_unregister(\"SendText\");\n\tast_manager_unregister(\"UserEvent\");\n\tast_manager_unregister(\"WaitEvent\");\n\tast_manager_unregister(\"CoreSettings\");\n\tast_manager_unregister(\"CoreStatus\");\n\tast_manager_unregister(\"Reload\");\n\tast_manager_unregister(\"LoggerRotate\");\n\tast_manager_unregister(\"CoreShowChannels\");\n\tast_manager_unregister(\"CoreShowChannelMap\");\n\tast_manager_unregister(\"ModuleLoad\");\n\tast_manager_unregister(\"ModuleCheck\");\n\tast_manager_unregister(\"AOCMessage\");\n\tast_manager_unregister(\"Filter\");\n\tast_manager_unregister(\"BlindTransfer\");\n\tast_custom_function_unregister(&managerclient_function);\n\tast_cli_unregister_multiple(cli_manager, ARRAY_LEN(cli_manager));\n\n#ifdef AST_XML_DOCS\n\tao2_t_global_obj_release(event_docs, \"Dispose of event_docs\");\n#endif\n\n#ifdef TEST_FRAMEWORK\n\tstasis_forward_cancel(test_suite_forwarder);\n\ttest_suite_forwarder = NULL;\n#endif\n\n\tif (stasis_router) {\n\t\tstasis_message_router_unsubscribe_and_join(stasis_router);\n\t\tstasis_router = NULL;\n\t}\n\tstasis_forward_cancel(rtp_topic_forwarder);\n\trtp_topic_forwarder = NULL;\n\tstasis_forward_cancel(security_topic_forwarder);\n\tsecurity_topic_forwarder = NULL;\n\tao2_cleanup(manager_topic);\n\tmanager_topic = NULL;\n\tSTASIS_MESSAGE_TYPE_CLEANUP(ast_manager_get_generic_type);\n\n\tast_tcptls_server_stop(&ami_desc);\n\tast_tcptls_server_stop(&amis_desc);\n\n\tast_free(ami_tls_cfg.certfile);\n\tami_tls_cfg.certfile = NULL;\n\tast_free(ami_tls_cfg.pvtfile);\n\tami_tls_cfg.pvtfile = NULL;\n\tast_free(ami_tls_cfg.cipher);\n\tami_tls_cfg.cipher = NULL;\n\tast_free(ami_tls_cfg.cafile);\n\tami_tls_cfg.cafile = NULL;\n\tast_free(ami_tls_cfg.capath);\n\tami_tls_cfg.capath = NULL;\n\n\tao2_global_obj_release(mgr_sessions);\n\n\twhile ((user = AST_LIST_REMOVE_HEAD(&users, list))) {\n\t\tmanager_free_user(user);\n\t}\n\tacl_change_stasis_unsubscribe();\n\n\tast_free(manager_channelvars);\n\tast_free(manager_disabledevents);\n}\n\n\n/*! \\brief Initialize all \\ref stasis topics and routers used by the various\n * sub-components of AMI\n */\nstatic int manager_subscriptions_init(void)\n{\n\tint res = 0;\n\n\trtp_topic_forwarder = stasis_forward_all(ast_rtp_topic(), manager_topic);\n\tif (!rtp_topic_forwarder) {\n\t\treturn -1;\n\t}\n\n\tsecurity_topic_forwarder = stasis_forward_all(ast_security_topic(), manager_topic);\n\tif (!security_topic_forwarder) {\n\t\treturn -1;\n\t}\n\n\tstasis_router = stasis_message_router_create(manager_topic);\n\tif (!stasis_router) {\n\t\treturn -1;\n\t}\n\tstasis_message_router_set_congestion_limits(stasis_router, -1,\n\t\t6 * AST_TASKPROCESSOR_HIGH_WATER_LEVEL);\n\n\tstasis_message_router_set_formatters_default(stasis_router,\n\t\tmanager_default_msg_cb, NULL, STASIS_SUBSCRIPTION_FORMATTER_AMI);\n\n\tres |= stasis_message_router_add(stasis_router,\n\t\tast_manager_get_generic_type(), manager_generic_msg_cb, NULL);\n\n\tif (res != 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int subscribe_all(void)\n{\n\tif (manager_subscriptions_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager subscriptions\\n\");\n\t\treturn -1;\n\t}\n\tif (manager_system_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager system handling\\n\");\n\t\treturn -1;\n\t}\n\tif (manager_channels_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager channel handling\\n\");\n\t\treturn -1;\n\t}\n\tif (manager_mwi_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager MWI handling\\n\");\n\t\treturn -1;\n\t}\n\tif (manager_bridging_init()) {\n\t\treturn -1;\n\t}\n\tif (manager_endpoints_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager endpoints handling\\n\");\n\t\treturn -1;\n\t}\n\n\tsubscribed = 1;\n\treturn 0;\n}\n\nstatic void manager_set_defaults(void)\n{\n\tmanager_enabled = 0;\n\tdisplayconnects = 1;\n\tbroken_events_action = 0;\n\tauthtimeout = 30;\n\tauthlimit = 50;\n\tmanager_debug = 0;\t\t/* Debug disabled by default */\n\n\t/* default values */\n\tast_copy_string(global_realm, S_OR(ast_config_AST_SYSTEM_NAME, DEFAULT_REALM),\n\t\tsizeof(global_realm));\n\tast_sockaddr_setnull(&ami_desc.local_address);\n\tast_sockaddr_setnull(&amis_desc.local_address);\n\n\tami_tls_cfg.enabled = 0;\n\tast_free(ami_tls_cfg.certfile);\n\tami_tls_cfg.certfile = ast_strdup(AST_CERTFILE);\n\tast_free(ami_tls_cfg.pvtfile);\n\tami_tls_cfg.pvtfile = ast_strdup(\"\");\n\tast_free(ami_tls_cfg.cipher);\n\tami_tls_cfg.cipher = ast_strdup(\"\");\n\tast_free(ami_tls_cfg.cafile);\n\tami_tls_cfg.cafile = ast_strdup(\"\");\n\tast_free(ami_tls_cfg.capath);\n\tami_tls_cfg.capath = ast_strdup(\"\");\n}\n\nstatic int __init_manager(int reload, int by_external_config)\n{\n\tstruct ast_config *ucfg = NULL, *cfg = NULL;\n\tconst char *val;\n\tchar *cat = NULL;\n\tint newhttptimeout = 60;\n\tstruct ast_manager_user *user = NULL;\n\tstruct ast_variable *var;\n\tstruct ast_flags config_flags = { (reload && !by_external_config) ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\tchar a1[256];\n\tchar a1_hash[256];\n\tstruct ast_sockaddr ami_desc_local_address_tmp;\n\tstruct ast_sockaddr amis_desc_local_address_tmp;\n\tint tls_was_enabled = 0;\n\tint acl_subscription_flag = 0;\n\n\tif (!reload) {\n\t\tstruct ao2_container *sessions;\n#ifdef AST_XML_DOCS\n\t\tstruct ao2_container *temp_event_docs;\n#endif\n\t\tint res;\n\n\t\tres = STASIS_MESSAGE_TYPE_INIT(ast_manager_get_generic_type);\n\t\tif (res != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tmanager_topic = stasis_topic_create(\"manager:core\");\n\t\tif (!manager_topic) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Register default actions */\n\t\tast_manager_register_xml_core(\"Ping\", 0, action_ping);\n\t\tast_manager_register_xml_core(\"Events\", 0, action_events);\n\t\tast_manager_register_xml_core(\"Logoff\", 0, action_logoff);\n\t\tast_manager_register_xml_core(\"Login\", 0, action_login);\n\t\tast_manager_register_xml_core(\"Challenge\", 0, action_challenge);\n\t\tast_manager_register_xml_core(\"Hangup\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CALL, action_hangup);\n\t\tast_manager_register_xml_core(\"Status\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_status);\n\t\tast_manager_register_xml_core(\"Setvar\", EVENT_FLAG_CALL, action_setvar);\n\t\tast_manager_register_xml_core(\"Getvar\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_getvar);\n\t\tast_manager_register_xml_core(\"GetConfig\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CONFIG, action_getconfig);\n\t\tast_manager_register_xml_core(\"GetConfigJSON\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CONFIG, action_getconfigjson);\n\t\tast_manager_register_xml_core(\"UpdateConfig\", EVENT_FLAG_CONFIG, action_updateconfig);\n\t\tast_manager_register_xml_core(\"CreateConfig\", EVENT_FLAG_CONFIG, action_createconfig);\n\t\tast_manager_register_xml_core(\"ListCategories\", EVENT_FLAG_CONFIG, action_listcategories);\n\t\tast_manager_register_xml_core(\"Redirect\", EVENT_FLAG_CALL, action_redirect);\n\t\tast_manager_register_xml_core(\"Atxfer\", EVENT_FLAG_CALL, action_atxfer);\n\t\tast_manager_register_xml_core(\"CancelAtxfer\", EVENT_FLAG_CALL, action_cancel_atxfer);\n\t\tast_manager_register_xml_core(\"Originate\", EVENT_FLAG_ORIGINATE, action_originate);\n\t\tast_manager_register_xml_core(\"Command\", EVENT_FLAG_COMMAND, action_command);\n\t\tast_manager_register_xml_core(\"ExtensionState\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_extensionstate);\n\t\tast_manager_register_xml_core(\"PresenceState\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_presencestate);\n\t\tast_manager_register_xml_core(\"AbsoluteTimeout\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CALL, action_timeout);\n\t\tast_manager_register_xml_core(\"MailboxStatus\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_mailboxstatus);\n\t\tast_manager_register_xml_core(\"MailboxCount\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_mailboxcount);\n\t\tast_manager_register_xml_core(\"ListCommands\", 0, action_listcommands);\n\t\tast_manager_register_xml_core(\"SendText\", EVENT_FLAG_CALL, action_sendtext);\n\t\tast_manager_register_xml_core(\"UserEvent\", EVENT_FLAG_USER, action_userevent);\n\t\tast_manager_register_xml_core(\"WaitEvent\", 0, action_waitevent);\n\t\tast_manager_register_xml_core(\"CoreSettings\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_coresettings);\n\t\tast_manager_register_xml_core(\"CoreStatus\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_corestatus);\n\t\tast_manager_register_xml_core(\"Reload\", EVENT_FLAG_CONFIG | EVENT_FLAG_SYSTEM, action_reload);\n\t\tast_manager_register_xml_core(\"LoggerRotate\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_loggerrotate);\n\t\tast_manager_register_xml_core(\"CoreShowChannels\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_coreshowchannels);\n\t\tast_manager_register_xml_core(\"CoreShowChannelMap\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_coreshowchannelmap);\n\t\tast_manager_register_xml_core(\"ModuleLoad\", EVENT_FLAG_SYSTEM, manager_moduleload);\n\t\tast_manager_register_xml_core(\"ModuleCheck\", EVENT_FLAG_SYSTEM, manager_modulecheck);\n\t\tast_manager_register_xml_core(\"AOCMessage\", EVENT_FLAG_AOC, action_aocmessage);\n\t\tast_manager_register_xml_core(\"Filter\", EVENT_FLAG_SYSTEM, action_filter);\n\t\tast_manager_register_xml_core(\"BlindTransfer\", EVENT_FLAG_CALL, action_blind_transfer);\n\n#ifdef TEST_FRAMEWORK\n\t\ttest_suite_forwarder = stasis_forward_all(ast_test_suite_topic(), manager_topic);\n#endif\n\n\t\tast_cli_register_multiple(cli_manager, ARRAY_LEN(cli_manager));\n\t\t__ast_custom_function_register(&managerclient_function, NULL);\n\t\tast_extension_state_add(NULL, NULL, manager_state_cb, NULL);\n\n\t\t/* Append placeholder event so master_eventq never runs dry */\n\t\tif (append_event(\"Event: Placeholder\\r\\n\\r\\n\", 0)) {\n\t\t\treturn -1;\n\t\t}\n\n#ifdef AST_XML_DOCS\n\t\ttemp_event_docs = ast_xmldoc_build_documentation(\"managerEvent\");\n\t\tif (temp_event_docs) {\n\t\t\tao2_t_global_obj_replace_unref(event_docs, temp_event_docs, \"Toss old event docs\");\n\t\t\tao2_t_ref(temp_event_docs, -1, \"Remove creation ref - container holds only ref now\");\n\t\t}\n#endif\n\n\t\t/* If you have a NULL hash fn, you only need a single bucket */\n\t\tsessions = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, mansession_cmp_fn);\n\t\tif (!sessions) {\n\t\t\treturn -1;\n\t\t}\n\t\tao2_global_obj_replace_unref(mgr_sessions, sessions);\n\t\tao2_ref(sessions, -1);\n\n\t\t/* Initialize all settings before first configuration load. */\n\t\tmanager_set_defaults();\n\t}\n\n\tcfg = ast_config_load2(\"manager.conf\", \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEUNCHANGED) {\n\t\treturn 0;\n\t} else if (!cfg || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_NOTICE, \"Unable to open AMI configuration manager.conf, or configuration is invalid.\\n\");\n\t\treturn 0;\n\t}\n\n\t/* If this wasn't performed due to a forced reload (because those can be created by ACL change events, we need to unsubscribe to ACL change events. */\n\tif (!by_external_config) {\n\t\tacl_change_stasis_unsubscribe();\n\t}\n\n\tif (reload) {\n\t\t/* Reset all settings before reloading configuration */\n\t\ttls_was_enabled = ami_tls_cfg.enabled;\n\t\tmanager_set_defaults();\n\t}\n\n\tast_sockaddr_parse(&ami_desc_local_address_tmp, \"[::]\", 0);\n\tast_sockaddr_set_port(&ami_desc_local_address_tmp, DEFAULT_MANAGER_PORT);\n\n\tfor (var = ast_variable_browse(cfg, \"general\"); var; var = var->next) {\n\t\tval = var->value;\n\n\t\t/* read tls config options while preventing unsupported options from being set */\n\t\tif (strcasecmp(var->name, \"tlscafile\")\n\t\t\t&& strcasecmp(var->name, \"tlscapath\")\n\t\t\t&& strcasecmp(var->name, \"tlscadir\")\n\t\t\t&& strcasecmp(var->name, \"tlsverifyclient\")\n\t\t\t&& strcasecmp(var->name, \"tlsdontverifyserver\")\n\t\t\t&& strcasecmp(var->name, \"tlsclientmethod\")\n\t\t\t&& strcasecmp(var->name, \"sslclientmethod\")\n\t\t\t&& !ast_tls_read_conf(&ami_tls_cfg, &amis_desc, var->name, val)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcasecmp(var->name, \"enabled\")) {\n\t\t\tmanager_enabled = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"webenabled\")) {\n\t\t\twebmanager_enabled = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"port\")) {\n\t\t\tint bindport;\n\t\t\tif (ast_parse_arg(val, PARSE_UINT32|PARSE_IN_RANGE, &bindport, 1024, 65535)) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid port number '%s'\\n\", val);\n\t\t\t}\n\t\t\tast_sockaddr_set_port(&ami_desc_local_address_tmp, bindport);\n\t\t} else if (!strcasecmp(var->name, \"bindaddr\")) {\n\t\t\t/* remember port if it has already been set */\n\t\t\tint setport = ast_sockaddr_port(&ami_desc_local_address_tmp);\n\n\t\t\tif (ast_parse_arg(val, PARSE_ADDR|PARSE_PORT_IGNORE, NULL)) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid address '%s' specified, default '%s' will be used\\n\", val,\n\t\t\t\t\t\tast_sockaddr_stringify_addr(&ami_desc_local_address_tmp));\n\t\t\t} else {\n\t\t\t\tast_sockaddr_parse(&ami_desc_local_address_tmp, val, PARSE_PORT_IGNORE);\n\t\t\t}\n\n\t\t\tif (setport) {\n\t\t\t\tast_sockaddr_set_port(&ami_desc_local_address_tmp, setport);\n\t\t\t}\n\n\t\t} else if (!strcasecmp(var->name, \"brokeneventsaction\")) {\n\t\t\tbroken_events_action = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"allowmultiplelogin\")) {\n\t\t\tallowmultiplelogin = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"displayconnects\")) {\n\t\t\tdisplayconnects = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"timestampevents\")) {\n\t\t\ttimestampevents = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"debug\")) {\n\t\t\tmanager_debug = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"httptimeout\")) {\n\t\t\tnewhttptimeout = atoi(val);\n\t\t} else if (!strcasecmp(var->name, \"authtimeout\")) {\n\t\t\tint timeout = atoi(var->value);\n\n\t\t\tif (timeout < 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid authtimeout value '%s', using default value\\n\", var->value);\n\t\t\t} else {\n\t\t\t\tauthtimeout = timeout;\n\t\t\t}\n\t\t} else if (!strcasecmp(var->name, \"authlimit\")) {\n\t\t\tint limit = atoi(var->value);\n\n\t\t\tif (limit < 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid authlimit value '%s', using default value\\n\", var->value);\n\t\t\t} else {\n\t\t\t\tauthlimit = limit;\n\t\t\t}\n\t\t} else if (!strcasecmp(var->name, \"channelvars\")) {\n\t\t\tload_channelvars(var);\n\t\t} else if (!strcasecmp(var->name, \"disabledevents\")) {\n\t\t\tload_disabledevents(var);\n\t\t} else {\n\t\t\tast_log(LOG_NOTICE, \"Invalid keyword <%s> = <%s> in manager.conf [general]\\n\",\n\t\t\t\tvar->name, val);\n\t\t}\n\t}\n\n\tif (manager_enabled && !subscribed) {\n\t\tif (subscribe_all() != 0) {\n\t\t\tast_log(LOG_ERROR, \"Manager subscription error\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tast_sockaddr_copy(&amis_desc_local_address_tmp, &amis_desc.local_address);\n\n\t/* if the amis address has not been set, default is the same as non secure ami */\n\tif (ast_sockaddr_isnull(&amis_desc_local_address_tmp)) {\n\t\tast_sockaddr_copy(&amis_desc_local_address_tmp, &ami_desc_local_address_tmp);\n\t}\n\n\t/* if the amis address was not set, it will have non-secure ami port set; if\n\t   amis address was set, we need to check that a port was set or not, if not\n\t   use the default tls port */\n\tif (ast_sockaddr_port(&amis_desc_local_address_tmp) == 0 ||\n\t\t\t(ast_sockaddr_port(&ami_desc_local_address_tmp) == ast_sockaddr_port(&amis_desc_local_address_tmp))) {\n\n\t\tast_sockaddr_set_port(&amis_desc_local_address_tmp, DEFAULT_MANAGER_TLS_PORT);\n\t}\n\n\tif (manager_enabled) {\n\t\tast_sockaddr_copy(&ami_desc.local_address, &ami_desc_local_address_tmp);\n\t\tast_sockaddr_copy(&amis_desc.local_address, &amis_desc_local_address_tmp);\n\t}\n\n\tAST_RWLIST_WRLOCK(&users);\n\n\t/* First, get users from users.conf */\n\tucfg = ast_config_load2(\"users.conf\", \"manager\", config_flags);\n\tif (ucfg && (ucfg != CONFIG_STATUS_FILEUNCHANGED) && ucfg != CONFIG_STATUS_FILEINVALID) {\n\t\tconst char *hasmanager;\n\t\tint genhasmanager = ast_true(ast_variable_retrieve(ucfg, \"general\", \"hasmanager\"));\n\n\t\twhile ((cat = ast_category_browse(ucfg, cat))) {\n\t\t\tif (!strcasecmp(cat, \"general\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thasmanager = ast_variable_retrieve(ucfg, cat, \"hasmanager\");\n\t\t\tif ((!hasmanager && genhasmanager) || ast_true(hasmanager)) {\n\t\t\t\tconst char *user_secret = ast_variable_retrieve(ucfg, cat, \"secret\");\n\t\t\t\tconst char *user_read = ast_variable_retrieve(ucfg, cat, \"read\");\n\t\t\t\tconst char *user_write = ast_variable_retrieve(ucfg, cat, \"write\");\n\t\t\t\tconst char *user_displayconnects = ast_variable_retrieve(ucfg, cat, \"displayconnects\");\n\t\t\t\tconst char *user_allowmultiplelogin = ast_variable_retrieve(ucfg, cat, \"allowmultiplelogin\");\n\t\t\t\tconst char *user_writetimeout = ast_variable_retrieve(ucfg, cat, \"writetimeout\");\n\n\t\t\t\t/* Look for an existing entry,\n\t\t\t\t * if none found - create one and add it to the list\n\t\t\t\t */\n\t\t\t\tif (!(user = get_manager_by_name_locked(cat))) {\n\t\t\t\t\tif (!(user = ast_calloc(1, sizeof(*user)))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy name over */\n\t\t\t\t\tast_copy_string(user->username, cat, sizeof(user->username));\n\t\t\t\t\t/* Insert into list */\n\t\t\t\t\tAST_LIST_INSERT_TAIL(&users, user, list);\n\t\t\t\t\tuser->acl = NULL;\n\t\t\t\t\tuser->keep = 1;\n\t\t\t\t\tuser->readperm = -1;\n\t\t\t\t\tuser->writeperm = -1;\n\t\t\t\t\t/* Default displayconnect from [general] */\n\t\t\t\t\tuser->displayconnects = displayconnects;\n\t\t\t\t\t/* Default allowmultiplelogin from [general] */\n\t\t\t\t\tuser->allowmultiplelogin = allowmultiplelogin;\n\t\t\t\t\tuser->writetimeout = 100;\n\t\t\t\t}\n\n\t\t\t\tif (!user_secret) {\n\t\t\t\t\tuser_secret = ast_variable_retrieve(ucfg, \"general\", \"secret\");\n\t\t\t\t}\n\t\t\t\tif (!user_read) {\n\t\t\t\t\tuser_read = ast_variable_retrieve(ucfg, \"general\", \"read\");\n\t\t\t\t}\n\t\t\t\tif (!user_write) {\n\t\t\t\t\tuser_write = ast_variable_retrieve(ucfg, \"general\", \"write\");\n\t\t\t\t}\n\t\t\t\tif (!user_displayconnects) {\n\t\t\t\t\tuser_displayconnects = ast_variable_retrieve(ucfg, \"general\", \"displayconnects\");\n\t\t\t\t}\n\t\t\t\tif (!user_allowmultiplelogin) {\n\t\t\t\t\tuser_allowmultiplelogin = ast_variable_retrieve(ucfg, \"general\", \"allowmultiplelogin\");\n\t\t\t\t}\n\t\t\t\tif (!user_writetimeout) {\n\t\t\t\t\tuser_writetimeout = ast_variable_retrieve(ucfg, \"general\", \"writetimeout\");\n\t\t\t\t}\n\n\t\t\t\tif (!ast_strlen_zero(user_secret)) {\n\t\t\t\t\tast_free(user->secret);\n\t\t\t\t\tuser->secret = ast_strdup(user_secret);\n\t\t\t\t}\n\n\t\t\t\tif (user_read) {\n\t\t\t\t\tuser->readperm = get_perm(user_read);\n\t\t\t\t}\n\t\t\t\tif (user_write) {\n\t\t\t\t\tuser->writeperm = get_perm(user_write);\n\t\t\t\t}\n\t\t\t\tif (user_displayconnects) {\n\t\t\t\t\tuser->displayconnects = ast_true(user_displayconnects);\n\t\t\t\t}\n\t\t\t\tif (user_allowmultiplelogin) {\n\t\t\t\t\tuser->allowmultiplelogin = ast_true(user_allowmultiplelogin);\n\t\t\t\t}\n\t\t\t\tif (user_writetimeout) {\n\t\t\t\t\tint value = atoi(user_writetimeout);\n\t\t\t\t\tif (value < 100) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Invalid writetimeout value '%d' in users.conf\\n\", value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuser->writetimeout = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tast_config_destroy(ucfg);\n\t}\n\n\t/* cat is NULL here in any case */\n\n\twhile ((cat = ast_category_browse(cfg, cat))) {\n\t\tstruct ast_acl_list *oldacl;\n\n\t\tif (!strcasecmp(cat, \"general\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Look for an existing entry, if none found - create one and add it to the list */\n\t\tif (!(user = get_manager_by_name_locked(cat))) {\n\t\t\tif (!(user = ast_calloc(1, sizeof(*user)))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Copy name over */\n\t\t\tast_copy_string(user->username, cat, sizeof(user->username));\n\n\t\t\tuser->acl = NULL;\n\t\t\tuser->readperm = 0;\n\t\t\tuser->writeperm = 0;\n\t\t\t/* Default displayconnect from [general] */\n\t\t\tuser->displayconnects = displayconnects;\n\t\t\t/* Default allowmultiplelogin from [general] */\n\t\t\tuser->allowmultiplelogin = allowmultiplelogin;\n\t\t\tuser->writetimeout = 100;\n\t\t\tuser->whitefilters = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, NULL);\n\t\t\tuser->blackfilters = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, NULL);\n\t\t\tif (!user->whitefilters || !user->blackfilters) {\n\t\t\t\tmanager_free_user(user);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Insert into list */\n\t\t\tAST_RWLIST_INSERT_TAIL(&users, user, list);\n\t\t} else {\n\t\t\tao2_t_callback(user->whitefilters, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL, \"unlink all white filters\");\n\t\t\tao2_t_callback(user->blackfilters, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL, \"unlink all black filters\");\n\t\t}\n\n\t\t/* Make sure we keep this user and don't destroy it during cleanup */\n\t\tuser->keep = 1;\n\t\toldacl = user->acl;\n\t\tuser->acl = NULL;\n\t\tast_variables_destroy(user->chanvars);\n\n\t\tvar = ast_variable_browse(cfg, cat);\n\t\tfor (; var; var = var->next) {\n\t\t\tif (!strcasecmp(var->name, \"secret\")) {\n\t\t\t\tast_free(user->secret);\n\t\t\t\tuser->secret = ast_strdup(var->value);\n\t\t\t} else if (!strcasecmp(var->name, \"deny\") ||\n\t\t\t\t       !strcasecmp(var->name, \"permit\") ||\n\t\t\t\t       !strcasecmp(var->name, \"acl\")) {\n\t\t\t\tint acl_error = 0;\n\n\t\t\t\tast_append_acl(var->name, var->value, &user->acl, &acl_error, &acl_subscription_flag);\n\t\t\t\tif (acl_error) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Invalid ACL '%s' for manager user '%s' on line %d. Deleting user\\n\",\n\t\t\t\t\t\tvar->value, user->username, var->lineno);\n\t\t\t\t\tuser->keep = 0;\n\t\t\t\t}\n\t\t\t}  else if (!strcasecmp(var->name, \"read\") ) {\n\t\t\t\tuser->readperm = get_perm(var->value);\n\t\t\t}  else if (!strcasecmp(var->name, \"write\") ) {\n\t\t\t\tuser->writeperm = get_perm(var->value);\n\t\t\t}  else if (!strcasecmp(var->name, \"displayconnects\") ) {\n\t\t\t\tuser->displayconnects = ast_true(var->value);\n\t\t\t}  else if (!strcasecmp(var->name, \"allowmultiplelogin\") ) {\n\t\t\t\tuser->allowmultiplelogin = ast_true(var->value);\n\t\t\t} else if (!strcasecmp(var->name, \"writetimeout\")) {\n\t\t\t\tint value = atoi(var->value);\n\t\t\t\tif (value < 100) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Invalid writetimeout value '%s' at line %d\\n\", var->value, var->lineno);\n\t\t\t\t} else {\n\t\t\t\t\tuser->writetimeout = value;\n\t\t\t\t}\n\t\t\t} else if (!strcasecmp(var->name, \"setvar\")) {\n\t\t\t\tstruct ast_variable *tmpvar;\n\t\t\t\tchar varbuf[256];\n\t\t\t\tchar *varval;\n\t\t\t\tchar *varname;\n\n\t\t\t\tast_copy_string(varbuf, var->value, sizeof(varbuf));\n\t\t\t\tvarname = varbuf;\n\n\t\t\t\tif ((varval = strchr(varname,'='))) {\n\t\t\t\t\t*varval++ = '\\0';\n\t\t\t\t\tif ((tmpvar = ast_variable_new(varname, varval, \"\"))) {\n\t\t\t\t\t\ttmpvar->next = user->chanvars;\n\t\t\t\t\t\tuser->chanvars = tmpvar;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcasecmp(var->name, \"eventfilter\")) {\n\t\t\t\tconst char *value = var->value;\n\t\t\t\tmanager_add_filter(value, user->whitefilters, user->blackfilters);\n\t\t\t} else {\n\t\t\t\tast_debug(1, \"%s is an unknown option.\\n\", var->name);\n\t\t\t}\n\t\t}\n\n\t\toldacl = ast_free_acl_list(oldacl);\n\t}\n\tast_config_destroy(cfg);\n\n\t/* Check the flag for named ACL event subscription and if we need to, register a subscription. */\n\tif (acl_subscription_flag && !by_external_config) {\n\t\tacl_change_stasis_subscribe();\n\t}\n\n\t/* Perform cleanup - essentially prune out old users that no longer exist */\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&users, user, list) {\n\t\tif (user->keep) {\t/* valid record. clear flag for the next round */\n\t\t\tuser->keep = 0;\n\n\t\t\t/* Calculate A1 for Digest auth */\n\t\t\tsnprintf(a1, sizeof(a1), \"%s:%s:%s\", user->username, global_realm, user->secret);\n\t\t\tast_md5_hash(a1_hash,a1);\n\t\t\tast_free(user->a1_hash);\n\t\t\tuser->a1_hash = ast_strdup(a1_hash);\n\t\t\tcontinue;\n\t\t}\n\t\t/* We do not need to keep this user so take them out of the list */\n\t\tAST_RWLIST_REMOVE_CURRENT(list);\n\t\tast_debug(4, \"Pruning user '%s'\\n\", user->username);\n\t\tmanager_free_user(user);\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\n\tAST_RWLIST_UNLOCK(&users);\n\n\tif (webmanager_enabled && manager_enabled) {\n\t\tif (!webregged) {\n\t\t\tast_http_uri_link(&rawmanuri);\n\t\t\tast_http_uri_link(&manageruri);\n\t\t\tast_http_uri_link(&managerxmluri);\n\n\t\t\tast_http_uri_link(&arawmanuri);\n\t\t\tast_http_uri_link(&amanageruri);\n\t\t\tast_http_uri_link(&amanagerxmluri);\n\t\t\twebregged = 1;\n\t\t}\n\t} else {\n\t\tif (webregged) {\n\t\t\tast_http_uri_unlink(&rawmanuri);\n\t\t\tast_http_uri_unlink(&manageruri);\n\t\t\tast_http_uri_unlink(&managerxmluri);\n\n\t\t\tast_http_uri_unlink(&arawmanuri);\n\t\t\tast_http_uri_unlink(&amanageruri);\n\t\t\tast_http_uri_unlink(&amanagerxmluri);\n\t\t\twebregged = 0;\n\t\t}\n\t}\n\n\tif (newhttptimeout > 0) {\n\t\thttptimeout = newhttptimeout;\n\t}\n\n\tast_tcptls_server_start(&ami_desc);\n\tif (tls_was_enabled && !ami_tls_cfg.enabled) {\n\t\tast_tcptls_server_stop(&amis_desc);\n\t} else if (ast_ssl_setup(amis_desc.tls_cfg)) {\n\t\tast_tcptls_server_start(&amis_desc);\n\t}\n\n\treturn 0;\n}\n\nstatic void acl_change_stasis_cb(void *data, struct stasis_subscription *sub,\n\tstruct stasis_message *message)\n{\n\tif (stasis_message_type(message) != ast_named_acl_change_type()) {\n\t\treturn;\n\t}\n\n\t/* For now, this is going to be performed simply and just execute a forced reload. */\n\tast_log(LOG_NOTICE, \"Reloading manager in response to ACL change event.\\n\");\n\t__init_manager(1, 1);\n}\n\nstatic int unload_module(void)\n{\n\treturn 0;\n}\n\nstatic int load_module(void)\n{\n\tast_register_cleanup(manager_shutdown);\n\n\treturn __init_manager(0, 0) ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_SUCCESS;\n}\n\nstatic int reload_module(void)\n{\n\treturn __init_manager(1, 0);\n}\n\nint astman_datastore_add(struct mansession *s, struct ast_datastore *datastore)\n{\n\tAST_LIST_INSERT_HEAD(&s->session->datastores, datastore, entry);\n\n\treturn 0;\n}\n\nint astman_datastore_remove(struct mansession *s, struct ast_datastore *datastore)\n{\n\treturn AST_LIST_REMOVE(&s->session->datastores, datastore, entry) ? 0 : -1;\n}\n\nstruct ast_datastore *astman_datastore_find(struct mansession *s, const struct ast_datastore_info *info, const char *uid)\n{\n\tstruct ast_datastore *datastore = NULL;\n\n\tif (info == NULL)\n\t\treturn NULL;\n\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&s->session->datastores, datastore, entry) {\n\t\tif (datastore->info != info) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (uid == NULL) {\n\t\t\t/* matched by type only */\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((datastore->uid != NULL) && !strcasecmp(uid, datastore->uid)) {\n\t\t\t/* Matched by type AND uid */\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\n\treturn datastore;\n}\n\nint ast_str_append_event_header(struct ast_str **fields_string,\n\tconst char *header, const char *value)\n{\n\tif (!*fields_string) {\n\t\t*fields_string = ast_str_create(128);\n\t\tif (!*fields_string) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn (ast_str_append(fields_string, 0, \"%s: %s\\r\\n\", header, value) < 0) ? -1 : 0;\n}\n\nstatic void manager_event_blob_dtor(void *obj)\n{\n\tstruct ast_manager_event_blob *ev = obj;\n\n\tast_string_field_free_memory(ev);\n}\n\nstruct ast_manager_event_blob *\n__attribute__((format(printf, 3, 4)))\nast_manager_event_blob_create(\n\tint event_flags,\n\tconst char *manager_event,\n\tconst char *extra_fields_fmt,\n\t...)\n{\n\tstruct ast_manager_event_blob *ev;\n\tva_list argp;\n\n\tast_assert(extra_fields_fmt != NULL);\n\tast_assert(manager_event != NULL);\n\n\tev = ao2_alloc_options(sizeof(*ev), manager_event_blob_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!ev) {\n\t\treturn NULL;\n\t}\n\n\tif (ast_string_field_init(ev, 20)) {\n\t\tao2_ref(ev, -1);\n\t\treturn NULL;\n\t}\n\n\tev->manager_event = manager_event;\n\tev->event_flags = event_flags;\n\n\tva_start(argp, extra_fields_fmt);\n\tast_string_field_ptr_build_va(ev, &ev->extra_fields, extra_fields_fmt, argp);\n\tva_end(argp);\n\n\treturn ev;\n}\n\nAST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_GLOBAL_SYMBOLS | AST_MODFLAG_LOAD_ORDER, \"Asterisk Manager Interface\",\n\t.support_level = AST_MODULE_SUPPORT_CORE,\n\t.load = load_module,\n\t.unload = unload_module,\n\t.reload = reload_module,\n\t.load_pri = AST_MODPRI_CORE,\n\t.requires = \"extconfig,acl,http\",\n);\n"], "fixing_code": ["/*\n * Asterisk -- An open source telephony toolkit.\n *\n * Copyright (C) 1999 - 2006, Digium, Inc.\n *\n * Mark Spencer <markster@digium.com>\n *\n * See http://www.asterisk.org for more information about\n * the Asterisk project. Please do not directly contact\n * any of the maintainers of this project for assistance;\n * the project provides a web site, mailing lists and IRC\n * channels for your use.\n *\n * This program is free software, distributed under the terms of\n * the GNU General Public License Version 2. See the LICENSE file\n * at the top of the source tree.\n */\n\n/*! \\file\n *\n * \\brief The Asterisk Management Interface - AMI\n *\n * \\author Mark Spencer <markster@digium.com>\n *\n * OpenSSL http://www.openssl.org - for AMI/SSL\n *\n * At the moment this file contains a number of functions, namely:\n *\n * - data structures storing AMI state\n * - AMI-related API functions, used by internal asterisk components\n * - handlers for AMI-related CLI functions\n * - handlers for AMI functions (available through the AMI socket)\n * - the code for the main AMI listener thread and individual session threads\n * - the http handlers invoked for AMI-over-HTTP by the threads in main/http.c\n *\n * \\ref amiconf\n */\n\n/*! \\li \\ref manager.c uses the configuration file \\ref manager.conf and \\ref users.conf\n * \\addtogroup configuration_file\n */\n\n/*! \\page manager.conf manager.conf\n * \\verbinclude manager.conf.sample\n */\n\n/*! \\page users.conf users.conf\n * \\verbinclude users.conf.sample\n */\n\n/*** MODULEINFO\n\t<support_level>core</support_level>\n ***/\n\n#include \"asterisk.h\"\n\n#include \"asterisk/paths.h\"\t/* use various ast_config_AST_* */\n#include <ctype.h>\n#include <sys/time.h>\n#include <signal.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <regex.h>\n\n#include \"asterisk/channel.h\"\n#include \"asterisk/file.h\"\n#include \"asterisk/manager.h\"\n#include \"asterisk/module.h\"\n#include \"asterisk/config.h\"\n#include \"asterisk/callerid.h\"\n#include \"asterisk/core_local.h\"\n#include \"asterisk/lock.h\"\n#include \"asterisk/cli.h\"\n#include \"asterisk/app.h\"\n#include \"asterisk/mwi.h\"\n#include \"asterisk/pbx.h\"\n#include \"asterisk/md5.h\"\n#include \"asterisk/acl.h\"\n#include \"asterisk/utils.h\"\n#include \"asterisk/tcptls.h\"\n#include \"asterisk/http.h\"\n#include \"asterisk/ast_version.h\"\n#include \"asterisk/threadstorage.h\"\n#include \"asterisk/linkedlists.h\"\n#include \"asterisk/term.h\"\n#include \"asterisk/astobj2.h\"\n#include \"asterisk/features.h\"\n#include \"asterisk/security_events.h\"\n#include \"asterisk/aoc.h\"\n#include \"asterisk/strings.h\"\n#include \"asterisk/stringfields.h\"\n#include \"asterisk/presencestate.h\"\n#include \"asterisk/stasis_message_router.h\"\n#include \"asterisk/stasis_channels.h\"\n#include \"asterisk/stasis_bridges.h\"\n#include \"asterisk/test.h\"\n#include \"asterisk/json.h\"\n#include \"asterisk/bridge.h\"\n#include \"asterisk/features_config.h\"\n#include \"asterisk/rtp_engine.h\"\n#include \"asterisk/format_cache.h\"\n#include \"asterisk/translate.h\"\n#include \"asterisk/taskprocessor.h\"\n#include \"asterisk/message.h\"\n\n/*** DOCUMENTATION\n\t<manager name=\"Ping\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tKeepalive command.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>A 'Ping' action will elicit a 'Pong' response. Used to keep the\n\t\t\tmanager connection open.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Events\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tControl Event Flow.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"EventMask\" required=\"true\">\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"on\">\n\t\t\t\t\t\t<para>If all events should be sent.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t\t<enum name=\"off\">\n\t\t\t\t\t\t<para>If no events should be sent.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t\t<enum name=\"system,call,log,...\">\n\t\t\t\t\t\t<para>To select which flags events should have to be sent.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Enable/Disable sending of events to this manager client.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Logoff\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tLogoff Manager.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Logoff the current manager session.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Login</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Login\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tLogin Manager.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"ActionID\">\n\t\t\t\t<para>ActionID for this transaction. Will be returned.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Username\" required=\"true\">\n\t\t\t\t<para>Username to login with as specified in manager.conf.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Secret\">\n\t\t\t\t<para>Secret to login with as specified in manager.conf.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Login Manager.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Logoff</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Challenge\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGenerate Challenge for MD5 Auth.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"AuthType\" required=\"true\">\n\t\t\t\t<para>Digest algorithm to use in the challenge. Valid values are:</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"MD5\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Generate a challenge for MD5 authentication.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Hangup\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tHangup channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>The exact channel name to be hungup, or to use a regular expression, set this parameter to: /regex/</para>\n\t\t\t\t<para>Example exact channel: SIP/provider-0000012a</para>\n\t\t\t\t<para>Example regular expression: /^SIP/provider-.*$/</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Cause\">\n\t\t\t\t<para>Numeric hangup cause.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Hangup a channel.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Status\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList channel status.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"false\">\n\t\t\t\t<para>The name of the channel to query for status.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Variables\">\n\t\t\t\t<para>Comma <literal>,</literal> separated list of variable to include.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"AllVariables\">\n\t\t\t\t<para>If set to \"true\", the Status event will include all channel variables for\n\t\t\t\tthe requested channel(s).</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"true\"/>\n\t\t\t\t\t<enum name=\"false\"/>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Will return the status information of each channel along with the\n\t\t\tvalue for the specified channel variables.</para>\n\t\t</description>\n\t\t<responses>\n\t\t\t<list-elements>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/managerEvent[@name='Status'])\" />\n\t\t\t</list-elements>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/managerEvent[@name='StatusComplete'])\" />\n\t\t</responses>\n\t</manager>\n\t<managerEvent language=\"en_US\" name=\"Status\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised in response to a Status command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"ActionID\" required=\"false\"/>\n\t\t\t\t<channel_snapshot/>\n\t\t\t\t<parameter name=\"Type\">\n\t\t\t\t\t<para>Type of channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"DNID\">\n\t\t\t\t\t<para>Dialed number identifier</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"EffectiveConnectedLineNum\">\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"EffectiveConnectedLineName\">\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"TimeToHangup\">\n\t\t\t\t\t<para>Absolute lifetime of the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"BridgeID\">\n\t\t\t\t\t<para>Identifier of the bridge the channel is in, may be empty if not in one</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Application\">\n\t\t\t\t\t<para>Application currently executing on the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Data\">\n\t\t\t\t\t<para>Data given to the currently executing channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Nativeformats\">\n\t\t\t\t\t<para>Media formats the connected party is willing to send or receive</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Readformat\">\n\t\t\t\t\t<para>Media formats that frames from the channel are received in</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Readtrans\">\n\t\t\t\t\t<para>Translation path for media received in native formats</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Writeformat\">\n\t\t\t\t\t<para>Media formats that frames to the channel are accepted in</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Writetrans\">\n\t\t\t\t\t<para>Translation path for media sent to the connected party</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Callgroup\">\n\t\t\t\t\t<para>Configured call group on the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Pickupgroup\">\n\t\t\t\t\t<para>Configured pickup group on the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Seconds\">\n\t\t\t\t\t<para>Number of seconds the channel has been active</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">Status</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<managerEvent language=\"en_US\" name=\"StatusComplete\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised in response to a Status command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"Items\">\n\t\t\t\t\t<para>Number of Status events returned</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">Status</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<manager name=\"Setvar\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSets a channel variable or function value.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\">\n\t\t\t\t<para>Channel to set variable for.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Variable\" required=\"true\">\n\t\t\t\t<para>Variable name, function or expression.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Value\" required=\"true\">\n\t\t\t\t<para>Variable or function value.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This command can be used to set the value of channel variables or dialplan\n\t\t\tfunctions.</para>\n\t\t\t<note>\n\t\t\t\t<para>If a channel name is not provided then the variable is considered global.</para>\n\t\t\t</note>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Getvar</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Getvar\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGets a channel variable or function value.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\">\n\t\t\t\t<para>Channel to read variable from.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Variable\" required=\"true\">\n\t\t\t\t<para>Variable name, function or expression.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Get the value of a channel variable or function return.</para>\n\t\t\t<note>\n\t\t\t\t<para>If a channel name is not provided then the variable is considered global.</para>\n\t\t\t</note>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Setvar</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"GetConfig\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tRetrieve configuration.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Filename\" required=\"true\">\n\t\t\t\t<para>Configuration filename (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Category\">\n\t\t\t\t<para>Category in configuration file.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Filter\">\n\t\t\t\t<para>A comma separated list of\n\t\t\t\t<replaceable>name_regex</replaceable>=<replaceable>value_regex</replaceable>\n\t\t\t\texpressions which will cause only categories whose variables match all expressions\n\t\t\t\tto be considered.  The special variable name <literal>TEMPLATES</literal>\n\t\t\t\tcan be used to control whether templates are included.  Passing\n\t\t\t\t<literal>include</literal> as the value will include templates\n\t\t\t\talong with normal categories. Passing\n\t\t\t\t<literal>restrict</literal> as the value will restrict the operation to\n\t\t\t\tONLY templates.  Not specifying a <literal>TEMPLATES</literal> expression\n\t\t\t\tresults in the default behavior which is to not include templates.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will dump the contents of a configuration\n\t\t\tfile by category and contents or optionally by specified category only.\n\t\t\tIn the case where a category name is non-unique, a filter may be specified\n\t\t\tto match only categories with matching variable values.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfigJSON</ref>\n\t\t\t<ref type=\"manager\">UpdateConfig</ref>\n\t\t\t<ref type=\"manager\">CreateConfig</ref>\n\t\t\t<ref type=\"manager\">ListCategories</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"GetConfigJSON\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tRetrieve configuration (JSON format).\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Filename\" required=\"true\">\n\t\t\t\t<para>Configuration filename (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Category\">\n\t\t\t\t<para>Category in configuration file.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Filter\">\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='GetConfig']/syntax/parameter[@name='Filter']/para[1])\" />\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will dump the contents of a configuration file by category\n\t\t\tand contents in JSON format or optionally by specified category only.\n\t\t\tThis only makes sense to be used using rawman over the HTTP interface.\n\t\t\tIn the case where a category name is non-unique, a filter may be specified\n\t\t\tto match only categories with matching variable values.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfig</ref>\n\t\t\t<ref type=\"manager\">UpdateConfig</ref>\n\t\t\t<ref type=\"manager\">CreateConfig</ref>\n\t\t\t<ref type=\"manager\">ListCategories</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"UpdateConfig\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tUpdate basic configuration.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"SrcFilename\" required=\"true\">\n\t\t\t\t<para>Configuration filename to read (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"DstFilename\" required=\"true\">\n\t\t\t\t<para>Configuration filename to write (e.g. <filename>foo.conf</filename>)</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Reload\">\n\t\t\t\t<para>Whether or not a reload should take place (or name of specific module).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"PreserveEffectiveContext\">\n\t\t\t\t<para>Whether the effective category contents should be preserved on template change. Default is true (pre 13.2 behavior).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Action-000000\">\n\t\t\t\t<para>Action to take.</para>\n\t\t\t\t<para>0's represent 6 digit number beginning with 000000.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"NewCat\" />\n\t\t\t\t\t<enum name=\"RenameCat\" />\n\t\t\t\t\t<enum name=\"DelCat\" />\n\t\t\t\t\t<enum name=\"EmptyCat\" />\n\t\t\t\t\t<enum name=\"Update\" />\n\t\t\t\t\t<enum name=\"Delete\" />\n\t\t\t\t\t<enum name=\"Append\" />\n\t\t\t\t\t<enum name=\"Insert\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Cat-000000\">\n\t\t\t\t<para>Category to operate on.</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Var-000000\">\n\t\t\t\t<para>Variable to work on.</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Value-000000\">\n\t\t\t\t<para>Value to work on.</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Match-000000\">\n\t\t\t\t<para>Extra match required to match line.</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Line-000000\">\n\t\t\t\t<para>Line in category to operate on (used with delete and insert actions).</para>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Options-000000\">\n\t\t\t\t<para>A comma separated list of action-specific options.</para>\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"NewCat\"><para>One or more of the following... </para>\n\t\t\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t\t\t<enum name=\"allowdups\"><para>Allow duplicate category names.</para></enum>\n\t\t\t\t\t\t\t\t<enum name=\"template\"><para>This category is a template.</para></enum>\n\t\t\t\t\t\t\t\t<enum name=\"inherit=&quot;template[,...]&quot;\"><para>Templates from which to inherit.</para></enum>\n\t\t\t\t\t\t\t</enumlist>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t</enumlist>\n\t\t\t\t\t<para> </para>\n\t\t\t\t\t\t<para>The following actions share the same options...</para>\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"RenameCat\"/>\n\t\t\t\t\t\t<enum name=\"DelCat\"/>\n\t\t\t\t\t\t<enum name=\"EmptyCat\"/>\n\t\t\t\t\t\t<enum name=\"Update\"/>\n\t\t\t\t\t\t<enum name=\"Delete\"/>\n\t\t\t\t\t\t<enum name=\"Append\"/>\n\t\t\t\t\t\t<enum name=\"Insert\"><para> </para>\n\t\t\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t\t\t<enum name=\"catfilter=&quot;&lt;expression&gt;[,...]&quot;\"><para> </para>\n\t\t\t\t\t\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='GetConfig']/syntax/parameter[@name='Filter']/para[1])\" />\n\t\t\t\t\t\t\t\t\t<para><literal>catfilter</literal> is most useful when a file\n\t\t\t\t\t\t\t\t\tcontains multiple categories with the same name and you wish to\n\t\t\t\t\t\t\t\t\toperate on specific ones instead of all of them.</para>\n\t\t\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t\t</enumlist>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t</enumlist>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='UpdateConfig']/syntax/parameter[@name='Action-000000']/para[2])\" />\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will modify, create, or delete configuration elements\n\t\t\tin Asterisk configuration files.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfig</ref>\n\t\t\t<ref type=\"manager\">GetConfigJSON</ref>\n\t\t\t<ref type=\"manager\">CreateConfig</ref>\n\t\t\t<ref type=\"manager\">ListCategories</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"CreateConfig\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCreates an empty file in the configuration directory.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Filename\" required=\"true\">\n\t\t\t\t<para>The configuration filename to create (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will create an empty file in the configuration\n\t\t\tdirectory. This action is intended to be used before an UpdateConfig\n\t\t\taction.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfig</ref>\n\t\t\t<ref type=\"manager\">GetConfigJSON</ref>\n\t\t\t<ref type=\"manager\">UpdateConfig</ref>\n\t\t\t<ref type=\"manager\">ListCategories</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"ListCategories\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList categories in configuration file.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Filename\" required=\"true\">\n\t\t\t\t<para>Configuration filename (e.g. <filename>foo.conf</filename>).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will dump the categories in a given file.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">GetConfig</ref>\n\t\t\t<ref type=\"manager\">GetConfigJSON</ref>\n\t\t\t<ref type=\"manager\">UpdateConfig</ref>\n\t\t\t<ref type=\"manager\">CreateConfig</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Redirect\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tRedirect (transfer) a call.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Channel to redirect.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ExtraChannel\">\n\t\t\t\t<para>Second call leg to transfer (optional).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Exten\" required=\"true\">\n\t\t\t\t<para>Extension to transfer to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ExtraExten\">\n\t\t\t\t<para>Extension to transfer extrachannel to (optional).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\" required=\"true\">\n\t\t\t\t<para>Context to transfer to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ExtraContext\">\n\t\t\t\t<para>Context to transfer extrachannel to (optional).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Priority\" required=\"true\">\n\t\t\t\t<para>Priority to transfer to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ExtraPriority\">\n\t\t\t\t<para>Priority to transfer extrachannel to (optional).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Redirect (transfer) a call.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">BlindTransfer</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Atxfer\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tAttended transfer.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Transferer's channel.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Exten\" required=\"true\">\n\t\t\t\t<para>Extension to transfer to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\">\n\t\t\t\t<para>Context to transfer to.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Attended transfer.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">AttendedTransfer</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"CancelAtxfer\" language=\"en_US\">\n\t\t<since>\n\t\t\t<version>13.18.0</version>\n\t\t\t<version>14.7.0</version>\n\t\t\t<version>15.1.0</version>\n\t\t\t<version>16.0.0</version>\n\t\t</since>\n\t\t<synopsis>\n\t\t\tCancel an attended transfer.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>The transferer channel.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Cancel an attended transfer. Note, this uses the configured cancel attended transfer\n\t\t\tfeature option (atxferabort) to cancel the transfer. If not available this action will fail.\n\t\t\t</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">AttendedTransfer</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"Originate\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tOriginate a call.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Channel name to call.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Exten\">\n\t\t\t\t<para>Extension to use (requires <literal>Context</literal> and\n\t\t\t\t<literal>Priority</literal>)</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\">\n\t\t\t\t<para>Context to use (requires <literal>Exten</literal> and\n\t\t\t\t<literal>Priority</literal>)</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Priority\">\n\t\t\t\t<para>Priority to use (requires <literal>Exten</literal> and\n\t\t\t\t<literal>Context</literal>)</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Application\">\n\t\t\t\t<para>Application to execute.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Data\">\n\t\t\t\t<para>Data to use (requires <literal>Application</literal>).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Timeout\" default=\"30000\">\n\t\t\t\t<para>How long to wait for call to be answered (in ms.).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"CallerID\">\n\t\t\t\t<para>Caller ID to be set on the outgoing channel.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Variable\">\n\t\t\t\t<para>Channel variable to set, multiple Variable: headers are allowed.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Account\">\n\t\t\t\t<para>Account code.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"EarlyMedia\">\n\t\t\t\t<para>Set to <literal>true</literal> to force call bridge on early media..</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Async\">\n\t\t\t\t<para>Set to <literal>true</literal> for fast origination.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Codecs\">\n\t\t\t\t<para>Comma-separated list of codecs to use for this call.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChannelId\">\n\t\t\t\t<para>Channel UniqueId to be set on the channel.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"OtherChannelId\">\n\t\t\t\t<para>Channel UniqueId to be set on the second local channel.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Generates an outgoing call to a\n\t\t\t<replaceable>Extension</replaceable>/<replaceable>Context</replaceable>/<replaceable>Priority</replaceable>\n\t\t\tor <replaceable>Application</replaceable>/<replaceable>Data</replaceable></para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">OriginateResponse</ref>\n\t\t</see-also>\n\t</manager>\n\t<managerEvent language=\"en_US\" name=\"OriginateResponse\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised in response to an Originate command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"ActionID\" required=\"false\"/>\n\t\t\t\t<parameter name=\"Response\">\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"Failure\"/>\n\t\t\t\t\t\t<enum name=\"Success\"/>\n\t\t\t\t\t</enumlist>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Channel\"/>\n\t\t\t\t<parameter name=\"Context\"/>\n\t\t\t\t<parameter name=\"Exten\"/>\n\t\t\t\t<parameter name=\"Application\"/>\n\t\t\t\t<parameter name=\"Data\"/>\n\t\t\t\t<parameter name=\"Reason\"/>\n\t\t\t\t<parameter name=\"Uniqueid\"/>\n\t\t\t\t<parameter name=\"CallerIDNum\"/>\n\t\t\t\t<parameter name=\"CallerIDName\"/>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">Originate</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<manager name=\"Command\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tExecute Asterisk CLI Command.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Command\" required=\"true\">\n\t\t\t\t<para>Asterisk CLI command to run.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Run a CLI command.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"ExtensionState\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck Extension Status.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Exten\" required=\"true\">\n\t\t\t\t<para>Extension to check state on.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\" required=\"true\">\n\t\t\t\t<para>Context for extension.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Report the extension state for given extension. If the extension has a hint,\n\t\t\twill use devicestate to check the status of the device connected to the extension.</para>\n\t\t\t<para>Will return an <literal>Extension Status</literal> message. The response will include\n\t\t\tthe hint for the extension and the status.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">ExtensionStatus</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"PresenceState\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck Presence State\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Provider\" required=\"true\">\n\t\t\t\t<para>Presence Provider to check the state of</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Report the presence state for the given presence provider.</para>\n\t\t\t<para>Will return a <literal>Presence State</literal> message. The response will include the\n\t\t\tpresence state and, if set, a presence subtype and custom message.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">PresenceStatus</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"AbsoluteTimeout\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSet absolute timeout.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Channel name to hangup.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Timeout\" required=\"true\">\n\t\t\t\t<para>Maximum duration of the call (sec).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Hangup a channel after a certain time. Acknowledges set time with\n\t\t\t<literal>Timeout Set</literal> message.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"MailboxStatus\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck mailbox.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Mailbox\" required=\"true\">\n\t\t\t\t<para>Full mailbox ID <replaceable>mailbox</replaceable>@<replaceable>vm-context</replaceable>.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Checks a voicemail account for status.</para>\n\t\t\t<para>Returns whether there are messages waiting.</para>\n\t\t\t<para>Message: Mailbox Status.</para>\n\t\t\t<para>Mailbox: <replaceable>mailboxid</replaceable>.</para>\n\t\t\t<para>Waiting: <literal>0</literal> if messages waiting, <literal>1</literal>\n\t\t\tif no messages waiting.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">MailboxCount</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"MailboxCount\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck Mailbox Message Count.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Mailbox\" required=\"true\">\n\t\t\t\t<para>Full mailbox ID <replaceable>mailbox</replaceable>@<replaceable>vm-context</replaceable>.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Checks a voicemail account for new messages.</para>\n\t\t\t<para>Returns number of urgent, new and old messages.</para>\n\t\t\t<para>Message: Mailbox Message Count</para>\n\t\t\t<para>Mailbox: <replaceable>mailboxid</replaceable></para>\n\t\t\t<para>UrgentMessages: <replaceable>count</replaceable></para>\n\t\t\t<para>NewMessages: <replaceable>count</replaceable></para>\n\t\t\t<para>OldMessages: <replaceable>count</replaceable></para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">MailboxStatus</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"ListCommands\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList available manager commands.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Returns the action name and synopsis for every action that\n\t\t\tis available to the user.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"SendText\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSends a text message to channel. A content type\tcan be optionally specified. If not set\n\t\t\tit is set to an empty string allowing a custom handler to default it as it sees fit.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t\t<para>Channel to send message to.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Message\" required=\"true\">\n\t\t\t\t<para>Message to send.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Content-Type\" required=\"false\" default=\"\">\n\t\t\t\t<para>The type of content in the message</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Sends A Text Message to a channel while in a call.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"application\">SendText</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"UserEvent\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSend an arbitrary event.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"UserEvent\" required=\"true\">\n\t\t\t\t<para>Event string to send.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Header1\">\n\t\t\t\t<para>Content1.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"HeaderN\">\n\t\t\t\t<para>ContentN.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Send an event to manager sessions.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">UserEvent</ref>\n\t\t\t<ref type=\"application\">UserEvent</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"WaitEvent\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tWait for an event to occur.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Timeout\" required=\"true\">\n\t\t\t\t<para>Maximum time (in seconds) to wait for events, <literal>-1</literal> means forever.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>This action will elicit a <literal>Success</literal> response. Whenever\n\t\t\ta manager event is queued. Once WaitEvent has been called on an HTTP manager\n\t\t\tsession, events will be generated and queued.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"CoreSettings\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tShow PBX core settings (version etc).\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Query for Core PBX settings.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"CoreStatus\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tShow PBX core status variables.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Query for Core PBX status.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"Reload\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tSend a reload event.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Module\">\n\t\t\t\t<para>Name of the module to reload.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Send a reload event.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">ModuleLoad</ref>\n\t\t</see-also>\n\t</manager>\n\t<managerEvent language=\"en_US\" name=\"CoreShowChannel\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised in response to a CoreShowChannels command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t\t<channel_snapshot/>\n\t\t\t\t<parameter name=\"BridgeId\">\n\t\t\t\t\t<para>Identifier of the bridge the channel is in, may be empty if not in one</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Application\">\n\t\t\t\t\t<para>Application currently executing on the channel</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"ApplicationData\">\n\t\t\t\t\t<para>Data given to the currently executing application</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Duration\">\n\t\t\t\t\t<para>The amount of time the channel has existed</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">CoreShowChannels</ref>\n\t\t\t\t<ref type=\"managerEvent\">CoreShowChannelsComplete</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<managerEvent language=\"en_US\" name=\"CoreShowChannelsComplete\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised at the end of the CoreShowChannel list produced by the CoreShowChannels command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t\t<parameter name=\"EventList\">\n\t\t\t\t\t<para>Conveys the status of the command reponse list</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"ListItems\">\n\t\t\t\t\t<para>The total number of list items produced</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">CoreShowChannels</ref>\n\t\t\t\t<ref type=\"managerEvent\">CoreShowChannel</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<manager name=\"CoreShowChannels\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList currently active channels.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>List currently defined channels and some information about them.</para>\n\t\t</description>\n\t\t<responses>\n\t\t\t<list-elements>\n\t\t\t\t<xi:include xpointer=\"xpointer(/docs/managerEvent[@name='CoreShowChannel'])\" />\n\t\t\t</list-elements>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/managerEvent[@name='CoreShowChannelsComplete'])\" />\n\t\t</responses>\n\t</manager>\n\t<managerEvent language=\"en_US\" name=\"CoreShowChannelMapComplete\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised at the end of the CoreShowChannelMap list produced by the CoreShowChannelMap command.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"EventList\">\n\t\t\t\t\t<para>Conveys the status of the command response list</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"ListItems\">\n\t\t\t\t\t<para>The total number of list items produced</para>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<manager name=\"CoreShowChannelMap\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tList all channels connected to the specified channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"Channel\">\n\t\t\t\t<para>The channel to get the mapping for. Requires a channel name.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>List all channels currently connected to the specified channel. This can be any channel, including\n\t\t\tLocal channels, and Local channels will be followed through to their other half.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"LoggerRotate\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tReload and rotate the Asterisk logger.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Reload and rotate the logger. Analogous to the CLI command 'logger rotate'.</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"ModuleLoad\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tModule management.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Module\">\n\t\t\t\t<para>Asterisk module name (including .so extension) or subsystem identifier:</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"cdr\" />\n\t\t\t\t\t<enum name=\"dnsmgr\" />\n\t\t\t\t\t<enum name=\"extconfig\" />\n\t\t\t\t\t<enum name=\"enum\" />\n\t\t\t\t\t<enum name=\"acl\" />\n\t\t\t\t\t<enum name=\"manager\" />\n\t\t\t\t\t<enum name=\"http\" />\n\t\t\t\t\t<enum name=\"logger\" />\n\t\t\t\t\t<enum name=\"features\" />\n\t\t\t\t\t<enum name=\"dsp\" />\n\t\t\t\t\t<enum name=\"udptl\" />\n\t\t\t\t\t<enum name=\"indications\" />\n\t\t\t\t\t<enum name=\"cel\" />\n\t\t\t\t\t<enum name=\"plc\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"LoadType\" required=\"true\">\n\t\t\t\t<para>The operation to be done on module. Subsystem identifiers may only\n\t\t\t\tbe reloaded.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"load\" />\n\t\t\t\t\t<enum name=\"unload\" />\n\t\t\t\t\t<enum name=\"reload\" />\n\t\t\t\t</enumlist>\n\t\t\t\t<para>If no module is specified for a <literal>reload</literal> loadtype,\n\t\t\t\tall modules are reloaded.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Loads, unloads or reloads an Asterisk module in a running system.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Reload</ref>\n\t\t\t<ref type=\"manager\">ModuleCheck</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"ModuleCheck\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tCheck if module is loaded.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Module\" required=\"true\">\n\t\t\t\t<para>Asterisk module name (not including extension).</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Checks if Asterisk module is loaded. Will return Success/Failure.\n\t\t\tAn empty Version header is also returned (which doesn't contain\n\t\t\tthe module revision number).</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">ModuleLoad</ref>\n\t\t</see-also>\n\t</manager>\n\t<manager name=\"AOCMessage\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGenerate an Advice of Charge message on a channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Channel\">\n\t\t\t\t<para>Channel name to generate the AOC message on.\n\t\t\t\tThis value is required unless ChannelPrefix is given.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChannelPrefix\">\n\t\t\t\t<para>Partial channel prefix.  By using this option one can match the beginning part\n\t\t\t\tof a channel name without having to put the entire name in.  For example\n\t\t\t\tif a channel name is SIP/snom-00000001 and this value is set to SIP/snom, then\n\t\t\t\tthat channel matches and the message will be sent.  Note however that only\n\t\t\t\tthe first matched channel has the message sent on it. </para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"MsgType\" required=\"true\">\n\t\t\t\t<para>Defines what type of AOC message to create, AOC-S, AOC-D or AOC-E</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"S\" />\n\t\t\t\t\t<enum name=\"D\" />\n\t\t\t\t\t<enum name=\"E\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargeType\">\n\t\t\t\t<para>Defines what kind of charge this message represents for AOC-D and AOC-E.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"NA\" />\n\t\t\t\t\t<enum name=\"FREE\" />\n\t\t\t\t\t<enum name=\"Currency\" />\n\t\t\t\t\t<enum name=\"Unit\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"UnitAmount(0)\">\n\t\t\t\t<para>This represents the amount of units charged. The ETSI AOC standard specifies that\n\t\t\t\tthis value along with the optional UnitType value are entries in a list.  To accommodate this\n\t\t\t\tthese values take an index value starting at 0 which can be used to generate this list of\n\t\t\t\tunit entries.  For Example, If two unit entires were required this could be achieved by setting the\n\t\t\t\tparamter UnitAmount(0)=1234 and UnitAmount(1)=5678.  Note that UnitAmount at index 0 is\n\t\t\t\trequired when ChargeType=Unit, all other entries in the list are optional.\n\t\t\t\t</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"UnitType(0)\">\n\t\t\t\t<para>Defines the type of unit.  ETSI AOC standard specifies this as an integer\n\t\t\t\tvalue between 1 and 16, but this value is left open to accept any positive\n\t\t\t\tinteger.  Like the UnitAmount parameter, this value represents a list entry\n\t\t\t\tand has an index parameter that starts at 0.\n\t\t\t\t</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"CurrencyName\">\n\t\t\t\t<para>Specifies the currency's name.  Note that this value is truncated after 10 characters.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"CurrencyAmount\">\n\t\t\t\t<para>Specifies the charge unit amount as a positive integer.\n\t\t\t\tThis value is required when ChargeType==Currency (AOC-D or AOC-E) or\n\t\t\t\tRateType==Duration/Flat/Volume (AOC-S).</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"CurrencyMultiplier\">\n\t\t\t\t<para>Specifies the currency multiplier.\n\t\t\t\tThis value is required when CurrencyAmount is given.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"OneThousandth\" />\n\t\t\t\t\t<enum name=\"OneHundredth\" />\n\t\t\t\t\t<enum name=\"OneTenth\" />\n\t\t\t\t\t<enum name=\"One\" />\n\t\t\t\t\t<enum name=\"Ten\" />\n\t\t\t\t\t<enum name=\"Hundred\" />\n\t\t\t\t\t<enum name=\"Thousand\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"TotalType\" default=\"Total\">\n\t\t\t\t<para>Defines what kind of AOC-D total is represented.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"Total\" />\n\t\t\t\t\t<enum name=\"SubTotal\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"AOCBillingId\">\n\t\t\t\t<para>Represents a billing ID associated with an AOC-D or AOC-E message. Note\n\t\t\t\tthat only the first 3 items of the enum are valid AOC-D billing IDs</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"Normal\" />\n\t\t\t\t\t<enum name=\"ReverseCharge\" />\n\t\t\t\t\t<enum name=\"CreditCard\" />\n\t\t\t\t\t<enum name=\"CallFwdUnconditional\" />\n\t\t\t\t\t<enum name=\"CallFwdBusy\" />\n\t\t\t\t\t<enum name=\"CallFwdNoReply\" />\n\t\t\t\t\t<enum name=\"CallDeflection\" />\n\t\t\t\t\t<enum name=\"CallTransfer\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargingAssociationId\">\n\t\t\t\t<para>Charging association identifier.  This is optional for AOC-E and can be\n\t\t\t\tset to any value between -32768 and 32767</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargingAssociationNumber\">\n\t\t\t\t<para>Represents the charging association party number.  This value is optional\n\t\t\t\tfor AOC-E.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargingAssociationPlan\">\n\t\t\t\t<para>Integer representing the charging plan associated with the ChargingAssociationNumber.\n\t\t\t\tThe value is bits 7 through 1 of the Q.931 octet containing the type-of-number and\n\t\t\t\tnumbering-plan-identification fields.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargedItem\">\n\t\t\t\t<para>Defines what part of the call is charged in AOC-S. Usually this is set to\n\t\t\t\tBasicCommunication, which refers to the time after the call is answered, but establishment\n\t\t\t\t(CallAttempt) or successful establishment (CallSetup) of a call can also be used.\n\t\t\t\tOther options are available, but these generally do not carry enough information to actually\n\t\t\t\tcalculate the price of a call.\n\t\t\t\tIt is possible to have multiple ChargedItem entries for a single call -- for example to\n\t\t\t\tcharge for both the establishment of the call and the actual call. In this case, each\n\t\t\t\tChargedItem is described by a ChargedItem: header and all other headers that follow it up to\n\t\t\t\tthe next ChargedItem: header.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"NA\" />\n\t\t\t\t\t<enum name=\"SpecialArrangement\" />\n\t\t\t\t\t<enum name=\"BasicCommunication\" />\n\t\t\t\t\t<enum name=\"CallAttempt\" />\n\t\t\t\t\t<enum name=\"CallSetup\" />\n\t\t\t\t\t<enum name=\"UserUserInfo\" />\n\t\t\t\t\t<enum name=\"SupplementaryService\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"RateType\">\n\t\t\t\t<para>Defines how an AOC-S ChargedItem is charged.\n\t\t\t\tThe Duration option is only available when ChargedItem==BasicCommunication.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"NA\" />\n\t\t\t\t\t<enum name=\"Free\" />\n\t\t\t\t\t<enum name=\"FreeFromBeginning\" />\n\t\t\t\t\t<enum name=\"Duration\" />\n\t\t\t\t\t<enum name=\"Flat\" />\n\t\t\t\t\t<enum name=\"Volume\" />\n\t\t\t\t\t<enum name=\"SpecialCode\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Time\">\n\t\t\t\t<para>Specifies a positive integer which is the amount of time is paid for by one\n\t\t\t\tCurrencyAmount.\n\t\t\t\tThis value is required when RateType==Duration.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"TimeScale\">\n\t\t\t\t<para>Specifies the time multiplier.\n\t\t\t\tThis value is required when Time is given.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"OneHundredthSecond\" />\n\t\t\t\t\t<enum name=\"OneTenthSecond\" />\n\t\t\t\t\t<enum name=\"Second\" />\n\t\t\t\t\t<enum name=\"TenSeconds\" />\n\t\t\t\t\t<enum name=\"Minute\" />\n\t\t\t\t\t<enum name=\"Hour\" />\n\t\t\t\t\t<enum name=\"Day\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Granularity\">\n\t\t\t\t<para>Specifies a positive integer which is the size of the charged time increments.\n\t\t\t\tThis value is optional when RateType==Duration and ChargingType==StepFunction.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"GranularityTimeScale\">\n\t\t\t\t<para>Specifies the granularity time multiplier.\n\t\t\t\tThis value is required when Granularity is given.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"OneHundredthSecond\" />\n\t\t\t\t\t<enum name=\"OneTenthSecond\" />\n\t\t\t\t\t<enum name=\"Second\" />\n\t\t\t\t\t<enum name=\"TenSeconds\" />\n\t\t\t\t\t<enum name=\"Minute\" />\n\t\t\t\t\t<enum name=\"Hour\" />\n\t\t\t\t\t<enum name=\"Day\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"ChargingType\">\n\t\t\t\t<para>Specifies whether the charge increases continuously with time or in increments of\n\t\t\t\tTime or, if provided, Granularity.\n\t\t\t\tThis value is required when RateType==Duration.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"ContinuousCharging\" />\n\t\t\t\t\t<enum name=\"StepFunction\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"VolumeUnit\">\n\t\t\t\t<para>Specifies the quantity of which one unit is paid for by one CurrencyAmount.\n\t\t\t\tThis value is required when RateType==Volume.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"Octet\" />\n\t\t\t\t\t<enum name=\"Segment\" />\n\t\t\t\t\t<enum name=\"Message\" />\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Code\">\n\t\t\t\t<para>Specifies the charging code, which can be set to a value between 1 and 10.\n\t\t\t\tThis value is required when ChargedItem==SpecialArrangement or RateType==SpecialCode.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Generates an AOC-S, AOC-D or AOC-E message on a channel.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"managerEvent\">AOC-S</ref>\n\t\t\t<ref type=\"managerEvent\">AOC-D</ref>\n\t\t\t<ref type=\"managerEvent\">AOC-E</ref>\n\t\t</see-also>\n\t</manager>\n\t<function name=\"AMI_CLIENT\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tChecks attributes of manager accounts\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"loginname\" required=\"true\">\n\t\t\t\t<para>Login name, specified in manager.conf</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"field\" required=\"true\">\n\t\t\t\t<para>The manager account attribute to return</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"sessions\"><para>The number of sessions for this AMI account</para></enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>\n\t\t\t\tCurrently, the only supported  parameter is \"sessions\" which will return the current number of\n\t\t\t\tactive sessions for this AMI account.\n\t\t\t</para>\n\t\t</description>\n\t</function>\n\t<manager name=\"Filter\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tDynamically add filters for the current manager session.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<xi:include xpointer=\"xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])\" />\n\t\t\t<parameter name=\"Operation\">\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"Add\">\n\t\t\t\t\t\t<para>Add a filter.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Filter\">\n\t\t\t\t<para>Filters can be whitelist or blacklist</para>\n\t\t\t\t<para>Example whitelist filter: \"Event: Newchannel\"</para>\n\t\t\t\t<para>Example blacklist filter: \"!Channel: DAHDI.*\"</para>\n\t\t\t\t<para>This filter option is used to whitelist or blacklist events per user to be\n\t\t\t\treported with regular expressions and are allowed if both the regex matches\n\t\t\t\tand the user has read access as defined in manager.conf. Filters are assumed to be for whitelisting\n\t\t\t\tunless preceeded by an exclamation point, which marks it as being black.\n\t\t\t\tEvaluation of the filters is as follows:</para>\n\t\t\t\t<para>- If no filters are configured all events are reported as normal.</para>\n\t\t\t\t<para>- If there are white filters only: implied black all filter processed first, then white filters.</para>\n\t\t\t\t<para>- If there are black filters only: implied white all filter processed first, then black filters.</para>\n\t\t\t\t<para>- If there are both white and black filters: implied black all filter processed first, then white\n\t\t\t\tfilters, and lastly black filters.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>The filters added are only used for the current session.\n\t\t\tOnce the connection is closed the filters are removed.</para>\n\t\t\t<para>This comand requires the system permission because\n\t\t\tthis command can be used to create filters that may bypass\n\t\t\tfilters defined in manager.conf</para>\n\t\t</description>\n\t</manager>\n\t<manager name=\"BlindTransfer\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tBlind transfer channel(s) to the given destination\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"Channel\" required=\"true\">\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Context\">\n\t\t\t</parameter>\n\t\t\t<parameter name=\"Exten\">\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Redirect all channels currently bridged to the specified channel to the specified destination.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"manager\">Redirect</ref>\n\t\t\t<ref type=\"managerEvent\">BlindTransfer</ref>\n\t\t</see-also>\n\t</manager>\n\t<managerEvent name=\"ExtensionStatus\" language=\"en_US\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised when a hint changes due to a device state change.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"Exten\">\n\t\t\t\t\t<para>Name of the extension.</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Context\">\n\t\t\t\t\t<para>Context that owns the extension.</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Hint\">\n\t\t\t\t\t<para>Hint set for the extension</para>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"Status\">\n\t\t\t\t\t<para>Numerical value of the extension status. Extension\n\t\t\t\t\tstatus is determined by the combined device state of all items\n\t\t\t\t\tcontained in the hint.</para>\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"-2\">\n\t\t\t\t\t\t\t<para>The extension was removed from the dialplan.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"-1\">\n\t\t\t\t\t\t\t<para>The extension's hint was removed from the dialplan.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"0\">\n\t\t\t\t\t\t\t<para><literal>Idle</literal> - Related device(s) are in an idle\n\t\t\t\t\t\t\tstate.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"1\">\n\t\t\t\t\t\t\t<para><literal>InUse</literal> - Related device(s) are in active\n\t\t\t\t\t\t\tcalls but may take more calls.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"2\">\n\t\t\t\t\t\t\t<para><literal>Busy</literal> - Related device(s) are in active\n\t\t\t\t\t\t\tcalls and may not take any more calls.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"4\">\n\t\t\t\t\t\t\t<para><literal>Unavailable</literal> - Related device(s) are\n\t\t\t\t\t\t\tnot reachable.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"8\">\n\t\t\t\t\t\t\t<para><literal>Ringing</literal> - Related device(s) are\n\t\t\t\t\t\t\tcurrently ringing.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"9\">\n\t\t\t\t\t\t\t<para><literal>InUse&amp;Ringing</literal> - Related device(s)\n\t\t\t\t\t\t\tare currently ringing and in active calls.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"16\">\n\t\t\t\t\t\t\t<para><literal>Hold</literal> - Related device(s) are\n\t\t\t\t\t\t\tcurrently on hold.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t\t<enum name=\"17\">\n\t\t\t\t\t\t\t<para><literal>InUse&amp;Hold</literal> - Related device(s)\n\t\t\t\t\t\t\tare currently on hold and in active calls.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t</enumlist>\n\t\t\t\t</parameter>\n\t\t\t\t<parameter name=\"StatusText\">\n\t\t\t\t\t<para>Text representation of <literal>Status</literal>.</para>\n\t\t\t\t\t<enumlist>\n\t\t\t\t\t\t<enum name=\"Idle\" />\n\t\t\t\t\t\t<enum name=\"InUse\" />\n\t\t\t\t\t\t<enum name=\"Busy\" />\n\t\t\t\t\t\t<enum name=\"Unavailable\" />\n\t\t\t\t\t\t<enum name=\"Ringing\" />\n\t\t\t\t\t\t<enum name=\"InUse&amp;Ringing\" />\n\t\t\t\t\t\t<enum name=\"Hold\" />\n\t\t\t\t\t\t<enum name=\"InUse&amp;Hold\" />\n\t\t\t\t\t\t<enum name=\"Unknown\">\n\t\t\t\t\t\t\t<para>Status does not match any of the above values.</para>\n\t\t\t\t\t\t</enum>\n\t\t\t\t\t</enumlist>\n\t\t\t\t</parameter>\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">ExtensionState</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n\t<managerEvent name=\"PresenceStatus\" language=\"en_US\">\n\t\t<managerEventInstance class=\"EVENT_FLAG_CALL\">\n\t\t\t<synopsis>Raised when a hint changes due to a presence state change.</synopsis>\n\t\t\t<syntax>\n\t\t\t\t<parameter name=\"Exten\" />\n\t\t\t\t<parameter name=\"Context\" />\n\t\t\t\t<parameter name=\"Hint\" />\n\t\t\t\t<parameter name=\"Status\" />\n\t\t\t\t<parameter name=\"Subtype\" />\n\t\t\t\t<parameter name=\"Message\" />\n\t\t\t</syntax>\n\t\t\t<see-also>\n\t\t\t\t<ref type=\"manager\">PresenceState</ref>\n\t\t\t</see-also>\n\t\t</managerEventInstance>\n\t</managerEvent>\n ***/\n\n/*! \\addtogroup Group_AMI AMI functions\n*/\n/*! @{\n Doxygen group */\n\nenum error_type {\n\tUNKNOWN_ACTION = 1,\n\tUNKNOWN_CATEGORY,\n\tUNSPECIFIED_CATEGORY,\n\tUNSPECIFIED_ARGUMENT,\n\tFAILURE_ALLOCATION,\n\tFAILURE_NEWCAT,\n\tFAILURE_DELCAT,\n\tFAILURE_EMPTYCAT,\n\tFAILURE_UPDATE,\n\tFAILURE_DELETE,\n\tFAILURE_APPEND,\n\tFAILURE_TEMPLATE\n};\n\nenum add_filter_result {\n\tFILTER_SUCCESS,\n\tFILTER_ALLOC_FAILED,\n\tFILTER_COMPILE_FAIL,\n};\n\n/*!\n * Linked list of events.\n * Global events are appended to the list by append_event().\n * The usecount is the number of stored pointers to the element,\n * excluding the list pointers. So an element that is only in\n * the list has a usecount of 0, not 1.\n *\n * Clients have a pointer to the last event processed, and for each\n * of these clients we track the usecount of the elements.\n * If we have a pointer to an entry in the list, it is safe to navigate\n * it forward because elements will not be deleted, but only appended.\n * The worst that can happen is seeing the pointer still NULL.\n *\n * When the usecount of an element drops to 0, and the element is the\n * first in the list, we can remove it. Removal is done within the\n * main thread, which is woken up for the purpose.\n *\n * For simplicity of implementation, we make sure the list is never empty.\n */\nstruct eventqent {\n\tint usecount;\t\t/*!< # of clients who still need the event */\n\tint category;\n\tunsigned int seq;\t/*!< sequence number */\n\tstruct timeval tv;  /*!< When event was allocated */\n\tAST_RWLIST_ENTRY(eventqent) eq_next;\n\tchar eventdata[1];\t/*!< really variable size, allocated by append_event() */\n};\n\nstatic AST_RWLIST_HEAD_STATIC(all_events, eventqent);\n\nstatic int displayconnects = 1;\nstatic int allowmultiplelogin = 1;\nstatic int timestampevents;\nstatic int httptimeout = 60;\nstatic int broken_events_action = 0;\nstatic int manager_enabled = 0;\nstatic int subscribed = 0;\nstatic int webmanager_enabled = 0;\nstatic int manager_debug = 0;\t/*!< enable some debugging code in the manager */\nstatic int authtimeout;\nstatic int authlimit;\nstatic char *manager_channelvars;\nstatic char *manager_disabledevents;\n\n#define DEFAULT_REALM\t\t\"asterisk\"\nstatic char global_realm[MAXHOSTNAMELEN];\t/*!< Default realm */\n\nstatic int unauth_sessions = 0;\nstatic struct stasis_subscription *acl_change_sub;\n\n/*! \\brief A \\ref stasis_topic that all topics AMI cares about will be forwarded to */\nstatic struct stasis_topic *manager_topic;\n\n/*! \\brief The \\ref stasis_message_router for all \\ref stasis messages */\nstatic struct stasis_message_router *stasis_router;\n\n/*! \\brief The \\ref stasis_subscription for forwarding the RTP topic to the AMI topic */\nstatic struct stasis_forward *rtp_topic_forwarder;\n\n/*! \\brief The \\ref stasis_subscription for forwarding the Security topic to the AMI topic */\nstatic struct stasis_forward *security_topic_forwarder;\n\n/*!\n * \\brief Set to true (non-zero) to globally allow all dangerous AMI actions to run\n */\nstatic int live_dangerously;\n\n#ifdef TEST_FRAMEWORK\n/*! \\brief The \\ref stasis_subscription for forwarding the Test topic to the AMI topic */\nstatic struct stasis_forward *test_suite_forwarder;\n#endif\n\n#define MGR_SHOW_TERMINAL_WIDTH 80\n\n#define MAX_VARS 128\n\n/*! \\brief Fake event class used to end sessions at shutdown */\n#define EVENT_FLAG_SHUTDOWN -1\n\n/*! \\brief\n * Descriptor for a manager session, either on the AMI socket or over HTTP.\n *\n * \\note\n * AMI session have managerid == 0; the entry is created upon a connect,\n * and destroyed with the socket.\n * HTTP sessions have managerid != 0, the value is used as a search key\n * to lookup sessions (using the mansession_id cookie, or nonce key from\n * Digest Authentication http header).\n */\n#define MAX_BLACKLIST_CMD_LEN 2\nstatic const struct {\n\tconst char *words[AST_MAX_CMD_LEN];\n} command_blacklist[] = {\n\t{{ \"module\", \"load\", NULL }},\n\t{{ \"module\", \"unload\", NULL }},\n\t{{ \"restart\", \"gracefully\", NULL }},\n};\n\nstatic void acl_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message);\n\nstatic void acl_change_stasis_subscribe(void)\n{\n\tif (!acl_change_sub) {\n\t\tacl_change_sub = stasis_subscribe(ast_security_topic(),\n\t\t\tacl_change_stasis_cb, NULL);\n\t\tstasis_subscription_accept_message_type(acl_change_sub, ast_named_acl_change_type());\n\t\tstasis_subscription_set_filter(acl_change_sub, STASIS_SUBSCRIPTION_FILTER_SELECTIVE);\n\t}\n}\n\nstatic void acl_change_stasis_unsubscribe(void)\n{\n\tacl_change_sub = stasis_unsubscribe_and_join(acl_change_sub);\n}\n\n/* In order to understand what the heck is going on with the\n * mansession_session and mansession structs, we need to have a bit of a history\n * lesson.\n *\n * In the beginning, there was the mansession. The mansession contained data that was\n * intrinsic to a manager session, such as the time that it started, the name of the logged-in\n * user, etc. In addition to these parameters were the f and fd parameters. For typical manager\n * sessions, these were used to represent the TCP socket over which the AMI session was taking\n * place. It makes perfect sense for these fields to be a part of the session-specific data since\n * the session actually defines this information.\n *\n * Then came the HTTP AMI sessions. With these, the f and fd fields need to be opened and closed\n * for every single action that occurs. Thus the f and fd fields aren't really specific to the session\n * but rather to the action that is being executed. Because a single session may execute many commands\n * at once, some sort of safety needed to be added in order to be sure that we did not end up with fd\n * leaks from one action overwriting the f and fd fields used by a previous action before the previous action\n * has had a chance to properly close its handles.\n *\n * The initial idea to solve this was to use thread synchronization, but this prevented multiple actions\n * from being run at the same time in a single session. Some manager actions may block for a long time, thus\n * creating a large queue of actions to execute. In addition, this fix did not address the basic architectural\n * issue that for HTTP manager sessions, the f and fd variables are not really a part of the session, but are\n * part of the action instead.\n *\n * The new idea was to create a structure on the stack for each HTTP Manager action. This structure would\n * contain the action-specific information, such as which file to write to. In order to maintain expectations\n * of action handlers and not have to change the public API of the manager code, we would need to name this\n * new stacked structure 'mansession' and contain within it the old mansession struct that we used to use.\n * We renamed the old mansession struct 'mansession_session' to hopefully convey that what is in this structure\n * is session-specific data. The structure that it is wrapped in, called a 'mansession' really contains action-specific\n * data.\n */\nstruct mansession_session {\n\t\t\t\t/*! \\todo XXX need to document which fields it is protecting */\n\tstruct ast_sockaddr addr;\t/*!< address we are connecting from */\n\tstruct ast_iostream *stream;\t/*!< AMI stream */\n\tint inuse;\t\t/*!< number of HTTP sessions using this entry */\n\tint needdestroy;\t/*!< Whether an HTTP session should be destroyed */\n\tpthread_t waiting_thread;\t/*!< Sleeping thread using this descriptor */\n\tuint32_t managerid;\t/*!< Unique manager identifier, 0 for AMI sessions */\n\ttime_t sessionstart;    /*!< Session start time */\n\tstruct timeval sessionstart_tv; /*!< Session start time */\n\ttime_t sessiontimeout;\t/*!< Session timeout if HTTP */\n\tchar username[80];\t/*!< Logged in username */\n\tchar challenge[10];\t/*!< Authentication challenge */\n\tint authenticated;\t/*!< Authentication status */\n\tint readperm;\t\t/*!< Authorization for reading */\n\tint writeperm;\t\t/*!< Authorization for writing */\n\tchar inbuf[1025];\t/*!< Buffer -  we use the extra byte to add a '\\\\0' and simplify parsing */\n\tint inlen;\t\t/*!< number of buffered bytes */\n\tstruct ao2_container *whitefilters;\t/*!< Manager event filters - white list */\n\tstruct ao2_container *blackfilters;\t/*!< Manager event filters - black list */\n\tstruct ast_variable *chanvars;  /*!< Channel variables to set for originate */\n\tint send_events;\t/*!<  XXX what ? */\n\tstruct eventqent *last_ev;\t/*!< last event processed. */\n\tint writetimeout;\t/*!< Timeout for ast_carefulwrite() */\n\ttime_t authstart;\n\tint pending_event;         /*!< Pending events indicator in case when waiting_thread is NULL */\n\ttime_t noncetime;\t/*!< Timer for nonce value expiration */\n\tunsigned long oldnonce;\t/*!< Stale nonce value */\n\tunsigned long nc;\t/*!< incremental  nonce counter */\n\tast_mutex_t notify_lock; /*!< Lock for notifying this session of events */\n\tAST_LIST_HEAD_NOLOCK(mansession_datastores, ast_datastore) datastores; /*!< Data stores on the session */\n\tAST_LIST_ENTRY(mansession_session) list;\n};\n\nenum mansession_message_parsing {\n\tMESSAGE_OKAY,\n\tMESSAGE_LINE_TOO_LONG\n};\n\n/*! \\brief In case you didn't read that giant block of text above the mansession_session struct, the\n * \\ref mansession is named this solely to keep the API the same in Asterisk. This structure really\n * represents data that is different from Manager action to Manager action. The mansession_session pointer\n * contained within points to session-specific data.\n */\nstruct mansession {\n\tstruct mansession_session *session;\n\tstruct ast_iostream *stream;\n\tstruct ast_tcptls_session_instance *tcptls_session;\n\tenum mansession_message_parsing parsing;\n\tunsigned int write_error:1;\n\tstruct manager_custom_hook *hook;\n\tast_mutex_t lock;\n};\n\n/*! Active manager connection sessions container. */\nstatic AO2_GLOBAL_OBJ_STATIC(mgr_sessions);\n\n/*! \\brief user descriptor, as read from the config file.\n *\n * \\note It is still missing some fields -- e.g. we can have multiple permit and deny\n * lines which are not supported here, and readperm/writeperm/writetimeout\n * are not stored.\n */\nstruct ast_manager_user {\n\tchar username[80];\n\tchar *secret;\t\t\t/*!< Secret for logging in */\n\tint readperm;\t\t\t/*!< Authorization for reading */\n\tint writeperm;\t\t\t/*!< Authorization for writing */\n\tint writetimeout;\t\t/*!< Per user Timeout for ast_carefulwrite() */\n\tint displayconnects;\t\t/*!< XXX unused */\n\tint allowmultiplelogin; /*!< Per user option*/\n\tint keep;\t\t\t/*!< mark entries created on a reload */\n\tstruct ao2_container *whitefilters; /*!< Manager event filters - white list */\n\tstruct ao2_container *blackfilters; /*!< Manager event filters - black list */\n\tstruct ast_acl_list *acl;       /*!< ACL setting */\n\tchar *a1_hash;\t\t\t/*!< precalculated A1 for Digest auth */\n\tstruct ast_variable *chanvars;  /*!< Channel variables to set for originate */\n\tAST_RWLIST_ENTRY(ast_manager_user) list;\n};\n\n/*! \\brief list of users found in the config file */\nstatic AST_RWLIST_HEAD_STATIC(users, ast_manager_user);\n\n/*! \\brief list of actions registered */\nstatic AST_RWLIST_HEAD_STATIC(actions, manager_action);\n\n/*! \\brief list of hooks registered */\nstatic AST_RWLIST_HEAD_STATIC(manager_hooks, manager_custom_hook);\n\n#ifdef AST_XML_DOCS\n/*! \\brief A container of event documentation nodes */\nstatic AO2_GLOBAL_OBJ_STATIC(event_docs);\n#endif\n\nstatic int __attribute__((format(printf, 9, 0))) __manager_event_sessions(\n\tstruct ao2_container *sessions,\n\tint category,\n\tconst char *event,\n\tint chancount,\n\tstruct ast_channel **chans,\n\tconst char *file,\n\tint line,\n\tconst char *func,\n\tconst char *fmt,\n\t...);\nstatic enum add_filter_result manager_add_filter(const char *filter_pattern, struct ao2_container *whitefilters, struct ao2_container *blackfilters);\n\nstatic int match_filter(struct mansession *s, char *eventdata);\n\n/*!\n * @{ \\brief Define AMI message types.\n */\nSTASIS_MESSAGE_TYPE_DEFN(ast_manager_get_generic_type);\n/*! @} */\n\n/*!\n * \\internal\n * \\brief Find a registered action object.\n *\n * \\param name Name of AMI action to find.\n *\n * \\return Reffed action found or NULL\n */\nstatic struct manager_action *action_find(const char *name)\n{\n\tstruct manager_action *act;\n\n\tAST_RWLIST_RDLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, act, list) {\n\t\tif (!strcasecmp(name, act->action)) {\n\t\t\tao2_t_ref(act, +1, \"found action object\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&actions);\n\n\treturn act;\n}\n\nstruct stasis_topic *ast_manager_get_topic(void)\n{\n\treturn manager_topic;\n}\n\nstruct stasis_message_router *ast_manager_get_message_router(void)\n{\n\treturn stasis_router;\n}\n\nstatic void manager_json_value_str_append(struct ast_json *value, const char *key,\n\t\t\t\t\t  struct ast_str **res)\n{\n\tswitch (ast_json_typeof(value)) {\n\tcase AST_JSON_STRING:\n\t\tast_str_append(res, 0, \"%s: %s\\r\\n\", key, ast_json_string_get(value));\n\t\tbreak;\n\tcase AST_JSON_INTEGER:\n\t\tast_str_append(res, 0, \"%s: %jd\\r\\n\", key, ast_json_integer_get(value));\n\t\tbreak;\n\tcase AST_JSON_TRUE:\n\t\tast_str_append(res, 0, \"%s: True\\r\\n\", key);\n\t\tbreak;\n\tcase AST_JSON_FALSE:\n\t\tast_str_append(res, 0, \"%s: False\\r\\n\", key);\n\t\tbreak;\n\tdefault:\n\t\tast_str_append(res, 0, \"%s: \\r\\n\", key);\n\t\tbreak;\n\t}\n}\n\nstatic void manager_json_to_ast_str(struct ast_json *obj, const char *key,\n\t\t\t\t    struct ast_str **res, key_exclusion_cb exclusion_cb);\n\nstatic void manager_json_array_with_key(struct ast_json *obj, const char* key,\n\t\t\t\t\tsize_t index, struct ast_str **res,\n\t\t\t\t\tkey_exclusion_cb exclusion_cb)\n{\n\tstruct ast_str *key_str = ast_str_alloca(64);\n\tast_str_set(&key_str, 0, \"%s(%zu)\", key, index);\n\tmanager_json_to_ast_str(obj, ast_str_buffer(key_str),\n\t\t\t\tres, exclusion_cb);\n}\n\nstatic void manager_json_obj_with_key(struct ast_json *obj, const char* key,\n\t\t\t\t      const char *parent_key, struct ast_str **res,\n\t\t\t\t      key_exclusion_cb exclusion_cb)\n{\n\tif (parent_key) {\n\t\tstruct ast_str *key_str = ast_str_alloca(64);\n\t\tast_str_set(&key_str, 0, \"%s/%s\", parent_key, key);\n\t\tmanager_json_to_ast_str(obj, ast_str_buffer(key_str),\n\t\t\t\t\tres, exclusion_cb);\n\t\treturn;\n\t}\n\n\tmanager_json_to_ast_str(obj, key, res, exclusion_cb);\n}\n\nvoid manager_json_to_ast_str(struct ast_json *obj, const char *key,\n\t\t\t     struct ast_str **res, key_exclusion_cb exclusion_cb)\n{\n\tstruct ast_json_iter *i;\n\n\t/* If obj or res is not given, just return */\n\tif (!obj || !res) {\n\t\treturn;\n\t}\n\n\tif (!*res && !(*res = ast_str_create(1024))) {\n\t\treturn;\n\t}\n\n\tif (exclusion_cb && key && exclusion_cb(key)) {\n\t\treturn;\n\t}\n\n\tif (ast_json_typeof(obj) != AST_JSON_OBJECT &&\n\t    ast_json_typeof(obj) != AST_JSON_ARRAY) {\n\t\tmanager_json_value_str_append(obj, key, res);\n\t\treturn;\n\t}\n\n\tif (ast_json_typeof(obj) == AST_JSON_ARRAY) {\n\t\tsize_t j;\n\t\tfor (j = 0; j < ast_json_array_size(obj); ++j) {\n\t\t\tmanager_json_array_with_key(ast_json_array_get(obj, j),\n\t\t\t\t\t\t    key, j, res, exclusion_cb);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = ast_json_object_iter(obj); i;\n\t     i = ast_json_object_iter_next(obj, i)) {\n\t\tmanager_json_obj_with_key(ast_json_object_iter_value(i),\n\t\t\t\t\t  ast_json_object_iter_key(i),\n\t\t\t\t\t  key, res, exclusion_cb);\n\t}\n}\n\nstruct ast_str *ast_manager_str_from_json_object(struct ast_json *blob, key_exclusion_cb exclusion_cb)\n{\n\tstruct ast_str *res = ast_str_create(1024);\n\n\tif (!ast_json_is_null(blob)) {\n\t   manager_json_to_ast_str(blob, NULL, &res, exclusion_cb);\n\t}\n\n\treturn res;\n}\n\n#define manager_event_sessions(sessions, category, event, contents , ...)\t\\\n\t__manager_event_sessions(sessions, category, event, 0, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__, contents , ## __VA_ARGS__)\n\n#define any_manager_listeners(sessions)\t\\\n\t((sessions && ao2_container_count(sessions)) || !AST_RWLIST_EMPTY(&manager_hooks))\n\nstatic void manager_default_msg_cb(void *data, struct stasis_subscription *sub,\n\t\t\t\t    struct stasis_message *message)\n{\n\tstruct ao2_container *sessions;\n\tstruct ast_manager_event_blob *ev;\n\n\tif (!stasis_message_can_be_ami(message)) {\n\t\t/* Not an AMI message; disregard */\n\t\treturn;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!any_manager_listeners(sessions)) {\n\t\t/* Nobody is listening */\n\t\tao2_cleanup(sessions);\n\t\treturn;\n\t}\n\n\tev = stasis_message_to_ami(message);\n\tif (!ev) {\n\t\t/* Conversion failure */\n\t\tao2_cleanup(sessions);\n\t\treturn;\n\t}\n\n\tmanager_event_sessions(sessions, ev->event_flags, ev->manager_event,\n\t\t\"%s\", ev->extra_fields);\n\tao2_ref(ev, -1);\n\tao2_cleanup(sessions);\n}\n\nstatic void manager_generic_msg_cb(void *data, struct stasis_subscription *sub,\n\t\t\t\t    struct stasis_message *message)\n{\n\tstruct ast_json_payload *payload;\n\tint class_type;\n\tconst char *type;\n\tstruct ast_json *event;\n\tstruct ast_str *event_buffer;\n\tstruct ao2_container *sessions;\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!any_manager_listeners(sessions)) {\n\t\t/* Nobody is listening */\n\t\tao2_cleanup(sessions);\n\t\treturn;\n\t}\n\n\tpayload = stasis_message_data(message);\n\tclass_type = ast_json_integer_get(ast_json_object_get(payload->json, \"class_type\"));\n\ttype = ast_json_string_get(ast_json_object_get(payload->json, \"type\"));\n\tevent = ast_json_object_get(payload->json, \"event\");\n\n\tevent_buffer = ast_manager_str_from_json_object(event, NULL);\n\tif (!event_buffer) {\n\t\tast_log(AST_LOG_WARNING, \"Error while creating payload for event %s\\n\", type);\n\t\tao2_cleanup(sessions);\n\t\treturn;\n\t}\n\tmanager_event_sessions(sessions, class_type, type,\n\t\t\"%s\", ast_str_buffer(event_buffer));\n\tast_free(event_buffer);\n\tao2_cleanup(sessions);\n}\n\nvoid ast_manager_publish_event(const char *type, int class_type, struct ast_json *obj)\n{\n\tRAII_VAR(struct ast_json *, event_info, NULL, ast_json_unref);\n\tRAII_VAR(struct ast_json_payload *, payload, NULL, ao2_cleanup);\n\tRAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);\n\n\tif (!obj || !ast_manager_get_generic_type()) {\n\t\treturn;\n\t}\n\n\tast_json_ref(obj);\n\tevent_info = ast_json_pack(\"{s: s, s: i, s: o}\",\n\t\t\t\"type\", type,\n\t\t\t\"class_type\", class_type,\n\t\t\t\"event\", obj);\n\tif (!event_info) {\n\t\treturn;\n\t}\n\n\tpayload = ast_json_payload_create(event_info);\n\tif (!payload) {\n\t\treturn;\n\t}\n\tmessage = stasis_message_create(ast_manager_get_generic_type(), payload);\n\tif (!message) {\n\t\treturn;\n\t}\n\tstasis_publish(ast_manager_get_topic(), message);\n}\n\n/*! \\brief Add a custom hook to be called when an event is fired */\nvoid ast_manager_register_hook(struct manager_custom_hook *hook)\n{\n\tAST_RWLIST_WRLOCK(&manager_hooks);\n\tAST_RWLIST_INSERT_TAIL(&manager_hooks, hook, list);\n\tAST_RWLIST_UNLOCK(&manager_hooks);\n}\n\n/*! \\brief Delete a custom hook to be called when an event is fired */\nvoid ast_manager_unregister_hook(struct manager_custom_hook *hook)\n{\n\tAST_RWLIST_WRLOCK(&manager_hooks);\n\tAST_RWLIST_REMOVE(&manager_hooks, hook, list);\n\tAST_RWLIST_UNLOCK(&manager_hooks);\n}\n\nint ast_manager_check_enabled(void)\n{\n\treturn manager_enabled;\n}\n\nint ast_webmanager_check_enabled(void)\n{\n\treturn (webmanager_enabled && manager_enabled);\n}\n\n/*!\n * Grab a reference to the last event, update usecount as needed.\n * Can handle a NULL pointer.\n */\nstatic struct eventqent *grab_last(void)\n{\n\tstruct eventqent *ret;\n\n\tAST_RWLIST_WRLOCK(&all_events);\n\tret = AST_RWLIST_LAST(&all_events);\n\t/* the list is never empty now, but may become so when\n\t * we optimize it in the future, so be prepared.\n\t */\n\tif (ret) {\n\t\tast_atomic_fetchadd_int(&ret->usecount, 1);\n\t}\n\tAST_RWLIST_UNLOCK(&all_events);\n\treturn ret;\n}\n\n/*!\n * Purge unused events. Remove elements from the head\n * as long as their usecount is 0 and there is a next element.\n */\nstatic void purge_events(void)\n{\n\tstruct eventqent *ev;\n\tstruct timeval now = ast_tvnow();\n\n\tAST_RWLIST_WRLOCK(&all_events);\n\twhile ( (ev = AST_RWLIST_FIRST(&all_events)) &&\n\t    ev->usecount == 0 && AST_RWLIST_NEXT(ev, eq_next)) {\n\t\tAST_RWLIST_REMOVE_HEAD(&all_events, eq_next);\n\t\tast_free(ev);\n\t}\n\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&all_events, ev, eq_next) {\n\t\t/* Never release the last event */\n\t\tif (!AST_RWLIST_NEXT(ev, eq_next)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* 2.5 times whatever the HTTP timeout is (maximum 2.5 hours) is the maximum time that we will definitely cache an event */\n\t\tif (ev->usecount == 0 && ast_tvdiff_sec(now, ev->tv) > (httptimeout > 3600 ? 3600 : httptimeout) * 2.5) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(eq_next);\n\t\t\tast_free(ev);\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&all_events);\n}\n\n/*!\n * helper functions to convert back and forth between\n * string and numeric representation of set of flags\n */\nstatic const struct permalias {\n\tint num;\n\tconst char *label;\n} perms[] = {\n\t{ EVENT_FLAG_SYSTEM, \"system\" },\n\t{ EVENT_FLAG_CALL, \"call\" },\n\t{ EVENT_FLAG_LOG, \"log\" },\n\t{ EVENT_FLAG_VERBOSE, \"verbose\" },\n\t{ EVENT_FLAG_COMMAND, \"command\" },\n\t{ EVENT_FLAG_AGENT, \"agent\" },\n\t{ EVENT_FLAG_USER, \"user\" },\n\t{ EVENT_FLAG_CONFIG, \"config\" },\n\t{ EVENT_FLAG_DTMF, \"dtmf\" },\n\t{ EVENT_FLAG_REPORTING, \"reporting\" },\n\t{ EVENT_FLAG_CDR, \"cdr\" },\n\t{ EVENT_FLAG_DIALPLAN, \"dialplan\" },\n\t{ EVENT_FLAG_ORIGINATE, \"originate\" },\n\t{ EVENT_FLAG_AGI, \"agi\" },\n\t{ EVENT_FLAG_CC, \"cc\" },\n\t{ EVENT_FLAG_AOC, \"aoc\" },\n\t{ EVENT_FLAG_TEST, \"test\" },\n\t{ EVENT_FLAG_SECURITY, \"security\" },\n\t{ EVENT_FLAG_MESSAGE, \"message\" },\n\t{ INT_MAX, \"all\" },\n\t{ 0, \"none\" },\n};\n\n/*! Maximum string length of the AMI authority permission string buildable from perms[]. */\n#define MAX_AUTH_PERM_STRING\t150\n\n/*! \\brief Checks to see if a string which can be used to evaluate functions should be rejected */\nstatic int function_capable_string_allowed_with_auths(const char *evaluating, int writepermlist)\n{\n\tif (!(writepermlist & EVENT_FLAG_SYSTEM)\n\t\t&& (\n\t\t\tstrstr(evaluating, \"SHELL\") ||       /* NoOp(${SHELL(rm -rf /)})  */\n\t\t\tstrstr(evaluating, \"EVAL\")           /* NoOp(${EVAL(${some_var_containing_SHELL})}) */\n\t\t)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*! \\brief Convert authority code to a list of options for a user. This will only\n * display those authority codes that have an explicit match on authority */\nstatic const char *user_authority_to_str(int authority, struct ast_str **res)\n{\n\tint i;\n\tchar *sep = \"\";\n\n\tast_str_reset(*res);\n\tfor (i = 0; i < ARRAY_LEN(perms) - 1; i++) {\n\t\tif ((authority & perms[i].num) == perms[i].num) {\n\t\t\tast_str_append(res, 0, \"%s%s\", sep, perms[i].label);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n\n\tif (ast_str_strlen(*res) == 0) {\n\t\t/* replace empty string with something sensible */\n\t\tast_str_append(res, 0, \"<none>\");\n\t}\n\n\treturn ast_str_buffer(*res);\n}\n\n\n/*! \\brief Convert authority code to a list of options. Note that the EVENT_FLAG_ALL\n * authority will always be returned. */\nstatic const char *authority_to_str(int authority, struct ast_str **res)\n{\n\tint i;\n\tchar *sep = \"\";\n\n\tast_str_reset(*res);\n\tif (authority != EVENT_FLAG_SHUTDOWN) {\n\t\tfor (i = 0; i < ARRAY_LEN(perms) - 1; i++) {\n\t\t\tif (authority & perms[i].num) {\n\t\t\t\tast_str_append(res, 0, \"%s%s\", sep, perms[i].label);\n\t\t\t\tsep = \",\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ast_str_strlen(*res) == 0) {\n\t\t/* replace empty string with something sensible */\n\t\tast_str_append(res, 0, \"<none>\");\n\t}\n\n\treturn ast_str_buffer(*res);\n}\n\n/*! Tells you if smallstr exists inside bigstr\n   which is delim by delim and uses no buf or stringsep\n   ast_instring(\"this|that|more\",\"this\",'|') == 1;\n\n   feel free to move this to app.c -anthm */\nstatic int ast_instring(const char *bigstr, const char *smallstr, const char delim)\n{\n\tconst char *val = bigstr, *next;\n\n\tdo {\n\t\tif ((next = strchr(val, delim))) {\n\t\t\tif (!strncmp(val, smallstr, (next - val))) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\treturn !strcmp(smallstr, val);\n\t\t}\n\t} while (*(val = (next + 1)));\n\n\treturn 0;\n}\n\nstatic int get_perm(const char *instr)\n{\n\tint x = 0, ret = 0;\n\n\tif (!instr) {\n\t\treturn 0;\n\t}\n\n\tfor (x = 0; x < ARRAY_LEN(perms); x++) {\n\t\tif (ast_instring(instr, perms[x].label, ',')) {\n\t\t\tret |= perms[x].num;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/*!\n * A number returns itself, false returns 0, true returns all flags,\n * other strings return the flags that are set.\n */\nstatic int strings_to_mask(const char *string)\n{\n\tconst char *p;\n\n\tif (ast_strlen_zero(string)) {\n\t\treturn -1;\n\t}\n\n\tfor (p = string; *p; p++) {\n\t\tif (*p < '0' || *p > '9') {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!*p) { /* all digits */\n\t\treturn atoi(string);\n\t}\n\tif (ast_false(string)) {\n\t\treturn 0;\n\t}\n\tif (ast_true(string)) {\t/* all permissions */\n\t\tint x, ret = 0;\n\t\tfor (x = 0; x < ARRAY_LEN(perms); x++) {\n\t\t\tret |= perms[x].num;\n\t\t}\n\t\treturn ret;\n\t}\n\treturn get_perm(string);\n}\n\n/*! \\brief Unreference manager session object.\n     If no more references, then go ahead and delete it */\nstatic struct mansession_session *unref_mansession(struct mansession_session *s)\n{\n\tint refcount = ao2_ref(s, -1);\n\tif (manager_debug) {\n\t\tast_debug(1, \"Mansession: %p refcount now %d\\n\", s, refcount - 1);\n\t}\n\treturn NULL;\n}\n\nstatic void event_filter_destructor(void *obj)\n{\n\tregex_t *regex_filter = obj;\n\tregfree(regex_filter);\n}\n\nstatic void session_destructor(void *obj)\n{\n\tstruct mansession_session *session = obj;\n\tstruct eventqent *eqe = session->last_ev;\n\tstruct ast_datastore *datastore;\n\n\t/* Get rid of each of the data stores on the session */\n\twhile ((datastore = AST_LIST_REMOVE_HEAD(&session->datastores, entry))) {\n\t\t/* Free the data store */\n\t\tast_datastore_free(datastore);\n\t}\n\n\tif (eqe) {\n\t\tast_atomic_fetchadd_int(&eqe->usecount, -1);\n\t}\n\tif (session->chanvars) {\n\t\tast_variables_destroy(session->chanvars);\n\t}\n\n\tif (session->whitefilters) {\n\t\tao2_t_ref(session->whitefilters, -1, \"decrement ref for white container, should be last one\");\n\t}\n\n\tif (session->blackfilters) {\n\t\tao2_t_ref(session->blackfilters, -1, \"decrement ref for black container, should be last one\");\n\t}\n\n\tast_mutex_destroy(&session->notify_lock);\n}\n\n/*! \\brief Allocate manager session structure and add it to the list of sessions */\nstatic struct mansession_session *build_mansession(const struct ast_sockaddr *addr)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *newsession;\n\n\tnewsession = ao2_alloc(sizeof(*newsession), session_destructor);\n\tif (!newsession) {\n\t\treturn NULL;\n\t}\n\n\tnewsession->whitefilters = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, NULL);\n\tnewsession->blackfilters = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, NULL);\n\tif (!newsession->whitefilters || !newsession->blackfilters) {\n\t\tao2_ref(newsession, -1);\n\t\treturn NULL;\n\t}\n\n\tnewsession->waiting_thread = AST_PTHREADT_NULL;\n\tnewsession->writetimeout = 100;\n\tnewsession->send_events = -1;\n\tast_sockaddr_copy(&newsession->addr, addr);\n\n\tast_mutex_init(&newsession->notify_lock);\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (sessions) {\n\t\tao2_link(sessions, newsession);\n\t\tao2_ref(sessions, -1);\n\t}\n\n\treturn newsession;\n}\n\nstatic int mansession_cmp_fn(void *obj, void *arg, int flags)\n{\n\tstruct mansession_session *s = obj;\n\tchar *str = arg;\n\treturn !strcasecmp(s->username, str) ? CMP_MATCH : 0;\n}\n\nstatic void session_destroy(struct mansession_session *s)\n{\n\tstruct ao2_container *sessions;\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (sessions) {\n\t\tao2_unlink(sessions, s);\n\t\tao2_ref(sessions, -1);\n\t}\n\tunref_mansession(s);\n}\n\n\nstatic int check_manager_session_inuse(const char *name)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *session;\n\tint inuse = 0;\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (sessions) {\n\t\tsession = ao2_find(sessions, (char *) name, 0);\n\t\tao2_ref(sessions, -1);\n\t\tif (session) {\n\t\t\tunref_mansession(session);\n\t\t\tinuse = 1;\n\t\t}\n\t}\n\treturn inuse;\n}\n\n\n/*!\n * lookup an entry in the list of registered users.\n * must be called with the list lock held.\n */\nstatic struct ast_manager_user *get_manager_by_name_locked(const char *name)\n{\n\tstruct ast_manager_user *user = NULL;\n\n\tAST_RWLIST_TRAVERSE(&users, user, list) {\n\t\tif (!strcasecmp(user->username, name)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn user;\n}\n\n/*! \\brief Get displayconnects config option.\n *  \\param session manager session to get parameter from.\n *  \\return displayconnects config option value.\n */\nstatic int manager_displayconnects(struct mansession_session *session)\n{\n\tstruct ast_manager_user *user = NULL;\n\tint ret = 0;\n\n\tAST_RWLIST_RDLOCK(&users);\n\tif ((user = get_manager_by_name_locked(session->username))) {\n\t\tret = user->displayconnects;\n\t}\n\tAST_RWLIST_UNLOCK(&users);\n\n\treturn ret;\n}\n\n#ifdef AST_XML_DOCS\nstatic void print_event_instance(struct ast_cli_args *a, struct ast_xml_doc_item *instance);\n#endif\n\nstatic char *handle_showmancmd(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct manager_action *cur;\n\tstruct ast_str *authority;\n\tint num;\n\tint l;\n\tconst char *auth_str;\n#ifdef AST_XML_DOCS\n\tchar syntax_title[64], description_title[64], synopsis_title[64], seealso_title[64];\n\tchar arguments_title[64], privilege_title[64], final_response_title[64], list_responses_title[64];\n#endif\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show command\";\n\t\te->usage =\n\t\t\t\"Usage: manager show command <actionname> [<actionname> [<actionname> [...]]]\\n\"\n\t\t\t\"\tShows the detailed description for a specific Asterisk manager interface command.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tl = strlen(a->word);\n\t\tAST_RWLIST_RDLOCK(&actions);\n\t\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\t\tif (!strncasecmp(a->word, cur->action, l)) {\n\t\t\t\tif (ast_cli_completion_add(ast_strdup(cur->action))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAST_RWLIST_UNLOCK(&actions);\n\t\treturn NULL;\n\t}\n\tif (a->argc < 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tauthority = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\n#ifdef AST_XML_DOCS\n\t/* setup the titles */\n\tterm_color(synopsis_title, \"[Synopsis]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(description_title, \"[Description]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(syntax_title, \"[Syntax]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(seealso_title, \"[See Also]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(arguments_title, \"[Arguments]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(privilege_title, \"[Privilege]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(final_response_title, \"[Final Response]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(list_responses_title, \"[List Responses]\\n\", COLOR_MAGENTA, 0, 40);\n#endif\n\n\tAST_RWLIST_RDLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tfor (num = 3; num < a->argc; num++) {\n\t\t\tif (!strcasecmp(cur->action, a->argv[num])) {\n\t\t\t\tauth_str = authority_to_str(cur->authority, &authority);\n\n#ifdef AST_XML_DOCS\n\t\t\t\tif (cur->docsrc == AST_XML_DOC) {\n\t\t\t\t\tchar *syntax = ast_xmldoc_printable(S_OR(cur->syntax, \"Not available\"), 1);\n\t\t\t\t\tchar *synopsis = ast_xmldoc_printable(S_OR(cur->synopsis, \"Not available\"), 1);\n\t\t\t\t\tchar *description = ast_xmldoc_printable(S_OR(cur->description, \"Not available\"), 1);\n\t\t\t\t\tchar *arguments = ast_xmldoc_printable(S_OR(cur->arguments, \"Not available\"), 1);\n\t\t\t\t\tchar *seealso = ast_xmldoc_printable(S_OR(cur->seealso, \"Not available\"), 1);\n\t\t\t\t\tchar *privilege = ast_xmldoc_printable(S_OR(auth_str, \"Not available\"), 1);\n\t\t\t\t\tchar *responses = ast_xmldoc_printable(\"None\", 1);\n\n\t\t\t\t\tif (!syntax || !synopsis || !description || !arguments\n\t\t\t\t\t\t\t|| !seealso || !privilege || !responses) {\n\t\t\t\t\t\tast_free(syntax);\n\t\t\t\t\t\tast_free(synopsis);\n\t\t\t\t\t\tast_free(description);\n\t\t\t\t\t\tast_free(arguments);\n\t\t\t\t\t\tast_free(seealso);\n\t\t\t\t\t\tast_free(privilege);\n\t\t\t\t\t\tast_free(responses);\n\t\t\t\t\t\tast_cli(a->fd, \"Allocation failure.\\n\");\n\t\t\t\t\t\tAST_RWLIST_UNLOCK(&actions);\n\n\t\t\t\t\t\treturn CLI_FAILURE;\n\t\t\t\t\t}\n\n\t\t\t\t\tast_cli(a->fd, \"%s%s\\n\\n%s%s\\n\\n%s%s\\n\\n%s%s\\n\\n%s%s\\n\\n%s%s\\n\\n%s\",\n\t\t\t\t\t\tsyntax_title, syntax,\n\t\t\t\t\t\tsynopsis_title, synopsis,\n\t\t\t\t\t\tdescription_title, description,\n\t\t\t\t\t\targuments_title, arguments,\n\t\t\t\t\t\tseealso_title, seealso,\n\t\t\t\t\t\tprivilege_title, privilege,\n\t\t\t\t\t\tlist_responses_title);\n\n\t\t\t\t\tif (!cur->list_responses) {\n\t\t\t\t\t\tast_cli(a->fd, \"%s\\n\\n\", responses);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstruct ast_xml_doc_item *temp;\n\t\t\t\t\t\tfor (temp = cur->list_responses; temp; temp = AST_LIST_NEXT(temp, next)) {\n\t\t\t\t\t\t\tast_cli(a->fd, \"Event: %s\\n\", temp->name);\n\t\t\t\t\t\t\tprint_event_instance(a, temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tast_cli(a->fd, \"%s\", final_response_title);\n\n\t\t\t\t\tif (!cur->final_response) {\n\t\t\t\t\t\tast_cli(a->fd, \"%s\\n\\n\", responses);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_cli(a->fd, \"Event: %s\\n\", cur->final_response->name);\n\t\t\t\t\t\tprint_event_instance(a, cur->final_response);\n\t\t\t\t\t}\n\n\t\t\t\t\tast_free(syntax);\n\t\t\t\t\tast_free(synopsis);\n\t\t\t\t\tast_free(description);\n\t\t\t\t\tast_free(arguments);\n\t\t\t\t\tast_free(seealso);\n\t\t\t\t\tast_free(privilege);\n\t\t\t\t\tast_free(responses);\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tast_cli(a->fd, \"Action: %s\\nSynopsis: %s\\nPrivilege: %s\\n%s\\n\",\n\t\t\t\t\t\tcur->action, cur->synopsis,\n\t\t\t\t\t\tauth_str,\n\t\t\t\t\t\tS_OR(cur->description, \"\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&actions);\n\n\treturn CLI_SUCCESS;\n}\n\nstatic char *handle_mandebug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager set debug [on|off]\";\n\t\te->usage = \"Usage: manager set debug [on|off]\\n\tShow, enable, disable debugging of the manager code.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tif (a->argc == 3) {\n\t\tast_cli(a->fd, \"manager debug is %s\\n\", manager_debug? \"on\" : \"off\");\n\t} else if (a->argc == 4) {\n\t\tif (!strcasecmp(a->argv[3], \"on\")) {\n\t\t\tmanager_debug = 1;\n\t\t} else if (!strcasecmp(a->argv[3], \"off\")) {\n\t\t\tmanager_debug = 0;\n\t\t} else {\n\t\t\treturn CLI_SHOWUSAGE;\n\t\t}\n\t}\n\treturn CLI_SUCCESS;\n}\n\nstatic char *handle_showmanager(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_manager_user *user = NULL;\n\tint l;\n\tstruct ast_str *rauthority = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\tstruct ast_str *wauthority = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\tstruct ast_variable *v;\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show user\";\n\t\te->usage =\n\t\t\t\" Usage: manager show user <user>\\n\"\n\t\t\t\"        Display all information related to the manager user specified.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\tl = strlen(a->word);\n\t\tif (a->pos != 3) {\n\t\t\treturn NULL;\n\t\t}\n\t\tAST_RWLIST_RDLOCK(&users);\n\t\tAST_RWLIST_TRAVERSE(&users, user, list) {\n\t\t\tif (!strncasecmp(a->word, user->username, l)) {\n\t\t\t\tif (ast_cli_completion_add(ast_strdup(user->username))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\treturn NULL;\n\t}\n\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tAST_RWLIST_RDLOCK(&users);\n\n\tif (!(user = get_manager_by_name_locked(a->argv[3]))) {\n\t\tast_cli(a->fd, \"There is no manager called %s\\n\", a->argv[3]);\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tast_cli(a->fd, \"\\n\");\n\tast_cli(a->fd,\n\t\t\"          username: %s\\n\"\n\t\t\"            secret: %s\\n\"\n\t\t\"               ACL: %s\\n\"\n\t\t\"         read perm: %s\\n\"\n\t\t\"        write perm: %s\\n\"\n\t\t\"   displayconnects: %s\\n\"\n\t\t\"allowmultiplelogin: %s\\n\",\n\t\tS_OR(user->username, \"(N/A)\"),\n\t\t(user->secret ? \"<Set>\" : \"(N/A)\"),\n\t\t((user->acl && !ast_acl_list_is_empty(user->acl)) ? \"yes\" : \"no\"),\n\t\tuser_authority_to_str(user->readperm, &rauthority),\n\t\tuser_authority_to_str(user->writeperm, &wauthority),\n\t\t(user->displayconnects ? \"yes\" : \"no\"),\n\t\t(user->allowmultiplelogin ? \"yes\" : \"no\"));\n\tast_cli(a->fd, \"         Variables: \\n\");\n\t\tfor (v = user->chanvars ; v ; v = v->next) {\n\t\t\tast_cli(a->fd, \"                 %s = %s\\n\", v->name, v->value);\n\t\t}\n\tif (!ast_acl_list_is_empty(user->acl)) {\n\t\tast_acl_output(a->fd, user->acl, NULL);\n\t}\n\n\tAST_RWLIST_UNLOCK(&users);\n\n\treturn CLI_SUCCESS;\n}\n\nstatic char *handle_showmanagers(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ast_manager_user *user = NULL;\n\tint count_amu = 0;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show users\";\n\t\te->usage =\n\t\t\t\"Usage: manager show users\\n\"\n\t\t\t\"       Prints a listing of all managers that are currently configured on that\\n\"\n\t\t\t\" system.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tAST_RWLIST_RDLOCK(&users);\n\n\t/* If there are no users, print out something along those lines */\n\tif (AST_RWLIST_EMPTY(&users)) {\n\t\tast_cli(a->fd, \"There are no manager users.\\n\");\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tast_cli(a->fd, \"\\nusername\\n--------\\n\");\n\n\tAST_RWLIST_TRAVERSE(&users, user, list) {\n\t\tast_cli(a->fd, \"%s\\n\", user->username);\n\t\tcount_amu++;\n\t}\n\n\tAST_RWLIST_UNLOCK(&users);\n\n\tast_cli(a->fd,\"-------------------\\n\"\n\t\t      \"%d manager users configured.\\n\", count_amu);\n\treturn CLI_SUCCESS;\n}\n\n/*! \\brief  CLI command  manager list commands */\nstatic char *handle_showmancmds(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct manager_action *cur;\n\tint name_len = 1;\n\tint space_remaining;\n#define HSMC_FORMAT \"  %-*.*s  %-.*s\\n\"\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show commands\";\n\t\te->usage =\n\t\t\t\"Usage: manager show commands\\n\"\n\t\t\t\"\tPrints a listing of all the available Asterisk manager interface commands.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tAST_RWLIST_RDLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tint incoming_len = strlen(cur->action);\n\t\tif (incoming_len > name_len) {\n\t\t\tname_len = incoming_len;\n\t\t}\n\t}\n\n\tspace_remaining = MGR_SHOW_TERMINAL_WIDTH - name_len - 4;\n\tif (space_remaining < 0) {\n\t\tspace_remaining = 0;\n\t}\n\n\tast_cli(a->fd, HSMC_FORMAT, name_len, name_len, \"Action\", space_remaining, \"Synopsis\");\n\tast_cli(a->fd, HSMC_FORMAT, name_len, name_len, \"------\", space_remaining, \"--------\");\n\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tast_cli(a->fd, HSMC_FORMAT, name_len, name_len, cur->action, space_remaining, cur->synopsis);\n\t}\n\tAST_RWLIST_UNLOCK(&actions);\n\n\treturn CLI_SUCCESS;\n}\n\n/*! \\brief CLI command manager list connected */\nstatic char *handle_showmanconn(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *session;\n\ttime_t now = time(NULL);\n#define HSMCONN_FORMAT1 \"  %-15.15s  %-55.55s  %-10.10s  %-10.10s  %-8.8s  %-8.8s  %-10.10s  %-10.10s\\n\"\n#define HSMCONN_FORMAT2 \"  %-15.15s  %-55.55s  %-10d  %-10d  %-8d  %-8d  %-10.10d  %-10.10d\\n\"\n\tint count = 0;\n\tstruct ao2_iterator i;\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show connected\";\n\t\te->usage =\n\t\t\t\"Usage: manager show connected\\n\"\n\t\t\t\"\tPrints a listing of the users that are currently connected to the\\n\"\n\t\t\t\"Asterisk manager interface.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\n\tast_cli(a->fd, HSMCONN_FORMAT1, \"Username\", \"IP Address\", \"Start\", \"Elapsed\", \"FileDes\", \"HttpCnt\", \"ReadPerms\", \"WritePerms\");\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (sessions) {\n\t\ti = ao2_iterator_init(sessions, 0);\n\t\tao2_ref(sessions, -1);\n\t\twhile ((session = ao2_iterator_next(&i))) {\n\t\t\tao2_lock(session);\n\t\t\tast_cli(a->fd, HSMCONN_FORMAT2, session->username,\n\t\t\t\tast_sockaddr_stringify_addr(&session->addr),\n\t\t\t\t(int) (session->sessionstart),\n\t\t\t\t(int) (now - session->sessionstart),\n\t\t\t\tsession->stream ? ast_iostream_get_fd(session->stream) : -1,\n\t\t\t\tsession->inuse,\n\t\t\t\tsession->readperm,\n\t\t\t\tsession->writeperm);\n\t\t\tcount++;\n\t\t\tao2_unlock(session);\n\t\t\tunref_mansession(session);\n\t\t}\n\t\tao2_iterator_destroy(&i);\n\t}\n\tast_cli(a->fd, \"%d users connected.\\n\", count);\n\n\treturn CLI_SUCCESS;\n}\n\n/*! \\brief CLI command manager list eventq */\n/* Should change to \"manager show connected\" */\nstatic char *handle_showmaneventq(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct eventqent *s;\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show eventq\";\n\t\te->usage =\n\t\t\t\"Usage: manager show eventq\\n\"\n\t\t\t\"\tPrints a listing of all events pending in the Asterisk manger\\n\"\n\t\t\t\"event queue.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tAST_RWLIST_RDLOCK(&all_events);\n\tAST_RWLIST_TRAVERSE(&all_events, s, eq_next) {\n\t\tast_cli(a->fd, \"Usecount: %d\\n\", s->usecount);\n\t\tast_cli(a->fd, \"Category: %d\\n\", s->category);\n\t\tast_cli(a->fd, \"Event:\\n%s\", s->eventdata);\n\t}\n\tAST_RWLIST_UNLOCK(&all_events);\n\n\treturn CLI_SUCCESS;\n}\n\nstatic int reload_module(void);\n\n/*! \\brief CLI command manager reload */\nstatic char *handle_manager_reload(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager reload\";\n\t\te->usage =\n\t\t\t\"Usage: manager reload\\n\"\n\t\t\t\"       Reloads the manager configuration.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc > 2) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\treload_module();\n\treturn CLI_SUCCESS;\n}\n\nstatic struct eventqent *advance_event(struct eventqent *e)\n{\n\tstruct eventqent *next;\n\n\tAST_RWLIST_RDLOCK(&all_events);\n\tif ((next = AST_RWLIST_NEXT(e, eq_next))) {\n\t\tast_atomic_fetchadd_int(&next->usecount, 1);\n\t\tast_atomic_fetchadd_int(&e->usecount, -1);\n\t}\n\tAST_RWLIST_UNLOCK(&all_events);\n\treturn next;\n}\n\n#define\tGET_HEADER_FIRST_MATCH\t0\n#define\tGET_HEADER_LAST_MATCH\t1\n#define\tGET_HEADER_SKIP_EMPTY\t2\n\n/*!\n * \\brief Return a matching header value.\n *\n * \\details\n * Generic function to return either the first or the last\n * matching header from a list of variables, possibly skipping\n * empty strings.\n *\n * \\note At the moment there is only one use of this function in\n * this file, so we make it static.\n *\n * \\note Never returns NULL.\n */\nstatic const char *__astman_get_header(const struct message *m, char *var, int mode)\n{\n\tint x, l = strlen(var);\n\tconst char *result = \"\";\n\n\tif (!m) {\n\t\treturn result;\n\t}\n\n\tfor (x = 0; x < m->hdrcount; x++) {\n\t\tconst char *h = m->headers[x];\n\t\tif (!strncasecmp(var, h, l) && h[l] == ':') {\n\t\t\tconst char *value = h + l + 1;\n\t\t\tvalue = ast_skip_blanks(value); /* ignore leading spaces in the value */\n\t\t\t/* found a potential candidate */\n\t\t\tif ((mode & GET_HEADER_SKIP_EMPTY) && ast_strlen_zero(value)) {\n\t\t\t\tcontinue;\t/* not interesting */\n\t\t\t}\n\t\t\tif (mode & GET_HEADER_LAST_MATCH) {\n\t\t\t\tresult = value;\t/* record the last match so far */\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*!\n * \\brief Return the first matching variable from an array.\n *\n * \\note This is the legacy function and is implemented in\n * therms of __astman_get_header().\n *\n * \\note Never returns NULL.\n */\nconst char *astman_get_header(const struct message *m, char *var)\n{\n\treturn __astman_get_header(m, var, GET_HEADER_FIRST_MATCH);\n}\n\n/*!\n * \\brief Append additional headers into the message structure from params.\n *\n * \\note You likely want to initialize m->hdrcount to 0 before calling this.\n */\nstatic void astman_append_headers(struct message *m, const struct ast_variable *params)\n{\n\tconst struct ast_variable *v;\n\n\tfor (v = params; v && m->hdrcount < ARRAY_LEN(m->headers); v = v->next) {\n\t\tif (ast_asprintf((char**)&m->headers[m->hdrcount], \"%s: %s\", v->name, v->value) > -1) {\n\t\t\t++m->hdrcount;\n\t\t}\n\t}\n}\n\n/*!\n * \\brief Free headers inside message structure, but not the message structure itself.\n */\nstatic void astman_free_headers(struct message *m)\n{\n\twhile (m->hdrcount) {\n\t\t--m->hdrcount;\n\t\tast_free((void *) m->headers[m->hdrcount]);\n\t\tm->headers[m->hdrcount] = NULL;\n\t}\n}\n\n/*!\n * \\internal\n * \\brief Process one \"Variable:\" header value string.\n *\n * \\param head Current list of AMI variables to get new values added.\n * \\param hdr_val Header value string to process.\n *\n * \\return New variable list head.\n */\nstatic struct ast_variable *man_do_variable_value(struct ast_variable *head, const char *hdr_val)\n{\n\tchar *parse;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(vars)[64];\n\t);\n\n\thdr_val = ast_skip_blanks(hdr_val); /* ignore leading spaces in the value */\n\tparse = ast_strdupa(hdr_val);\n\n\t/* Break the header value string into name=val pair items. */\n\tAST_STANDARD_APP_ARGS(args, parse);\n\tif (args.argc) {\n\t\tint y;\n\n\t\t/* Process each name=val pair item. */\n\t\tfor (y = 0; y < args.argc; y++) {\n\t\t\tstruct ast_variable *cur;\n\t\t\tchar *var;\n\t\t\tchar *val;\n\n\t\t\tif (!args.vars[y]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar = val = args.vars[y];\n\t\t\tstrsep(&val, \"=\");\n\n\t\t\t/* XXX We may wish to trim whitespace from the strings. */\n\t\t\tif (!val || ast_strlen_zero(var)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Create new variable list node and prepend it to the list. */\n\t\t\tcur = ast_variable_new(var, val, \"\");\n\t\t\tif (cur) {\n\t\t\t\tcur->next = head;\n\t\t\t\thead = cur;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn head;\n}\n\nstruct ast_variable *astman_get_variables(const struct message *m)\n{\n\treturn astman_get_variables_order(m, ORDER_REVERSE);\n}\n\nstruct ast_variable *astman_get_variables_order(const struct message *m,\n\tenum variable_orders order)\n{\n\tint varlen;\n\tint x;\n\tstruct ast_variable *head = NULL;\n\n\tstatic const char var_hdr[] = \"Variable:\";\n\n\t/* Process all \"Variable:\" headers. */\n\tvarlen = strlen(var_hdr);\n\tfor (x = 0; x < m->hdrcount; x++) {\n\t\tif (strncasecmp(var_hdr, m->headers[x], varlen)) {\n\t\t\tcontinue;\n\t\t}\n\t\thead = man_do_variable_value(head, m->headers[x] + varlen);\n\t}\n\n\tif (order == ORDER_NATURAL) {\n\t\thead = ast_variables_reverse(head);\n\t}\n\n\treturn head;\n}\n\n/*! \\brief access for hooks to send action messages to ami */\nint ast_hook_send_action(struct manager_custom_hook *hook, const char *msg)\n{\n\tconst char *action;\n\tint ret = 0;\n\tstruct manager_action *act_found;\n\tstruct mansession s = {.session = NULL, };\n\tstruct message m = { 0 };\n\tchar *dup_str;\n\tchar *src;\n\tint x = 0;\n\tint curlen;\n\n\tif (hook == NULL) {\n\t\treturn -1;\n\t}\n\n\t/* Create our own copy of the AMI action msg string. */\n\tsrc = dup_str = ast_strdup(msg);\n\tif (!dup_str) {\n\t\treturn -1;\n\t}\n\n\t/* convert msg string to message struct */\n\tcurlen = strlen(src);\n\tfor (x = 0; x < curlen; x++) {\n\t\tint cr;\t/* set if we have \\r */\n\t\tif (src[x] == '\\r' && x+1 < curlen && src[x+1] == '\\n')\n\t\t\tcr = 2;\t/* Found. Update length to include \\r\\n */\n\t\telse if (src[x] == '\\n')\n\t\t\tcr = 1;\t/* also accept \\n only */\n\t\telse\n\t\t\tcontinue;\n\t\t/* don't keep empty lines */\n\t\tif (x && m.hdrcount < ARRAY_LEN(m.headers)) {\n\t\t\t/* ... but trim \\r\\n and terminate the header string */\n\t\t\tsrc[x] = '\\0';\n\t\t\tm.headers[m.hdrcount++] = src;\n\t\t}\n\t\tx += cr;\n\t\tcurlen -= x;\t\t/* remaining size */\n\t\tsrc += x;\t\t/* update pointer */\n\t\tx = -1;\t\t\t/* reset loop */\n\t}\n\n\taction = astman_get_header(&m, \"Action\");\n\n\tdo {\n\t\tif (!strcasecmp(action, \"login\")) {\n\t\t\tbreak;\n\t\t}\n\n\t\tact_found = action_find(action);\n\t\tif (!act_found) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * we have to simulate a session for this action request\n\t\t * to be able to pass it down for processing\n\t\t * This is necessary to meet the previous design of manager.c\n\t\t */\n\t\ts.hook = hook;\n\n\t\tret = -1;\n\t\tao2_lock(act_found);\n\t\tif (act_found->registered && act_found->func) {\n\t\t\tstruct ast_module *mod_ref = ast_module_running_ref(act_found->module);\n\n\t\t\tao2_unlock(act_found);\n\t\t\t/* If the action is in a module it must be running. */\n\t\t\tif (!act_found->module || mod_ref) {\n\t\t\t\tret = act_found->func(&s, &m);\n\t\t\t\tast_module_unref(mod_ref);\n\t\t\t}\n\t\t} else {\n\t\t\tao2_unlock(act_found);\n\t\t}\n\t\tao2_t_ref(act_found, -1, \"done with found action object\");\n\t} while (0);\n\n\tast_free(dup_str);\n\treturn ret;\n}\n\n/*!\n * helper function to send a string to the socket.\n * Return -1 on error (e.g. buffer full).\n */\nstatic int send_string(struct mansession *s, char *string)\n{\n\tstruct ast_iostream *stream;\n\tint len, res;\n\n\t/* It's a result from one of the hook's action invocation */\n\tif (s->hook) {\n\t\t/*\n\t\t * to send responses, we're using the same function\n\t\t * as for receiving events. We call the event \"HookResponse\"\n\t\t */\n\t\ts->hook->helper(EVENT_FLAG_HOOKRESPONSE, \"HookResponse\", string);\n\t\treturn 0;\n\t}\n\n\tstream = s->stream ? s->stream : s->session->stream;\n\n\tlen = strlen(string);\n\tast_iostream_set_timeout_inactivity(stream, s->session->writetimeout);\n\tres = ast_iostream_write(stream, string, len);\n\tast_iostream_set_timeout_disable(stream);\n\n\tif (res < len) {\n\t\ts->write_error = 1;\n\t}\n\n\treturn res;\n}\n\n/*!\n * \\brief thread local buffer for astman_append\n *\n * \\note This can not be defined within the astman_append() function\n *       because it declares a couple of functions that get used to\n *       initialize the thread local storage key.\n */\nAST_THREADSTORAGE(astman_append_buf);\n\nAST_THREADSTORAGE(userevent_buf);\n\n/*! \\brief initial allocated size for the astman_append_buf and astman_send_*_va */\n#define ASTMAN_APPEND_BUF_INITSIZE   256\n\nstatic void astman_flush(struct mansession *s, struct ast_str *buf)\n{\n\tif (s->hook || (s->tcptls_session && s->tcptls_session->stream)) {\n\t\tsend_string(s, ast_str_buffer(buf));\n\t} else {\n\t\tast_verbose(\"No connection stream in astman_append, should not happen\\n\");\n\t}\n}\n\n/*!\n * utility functions for creating AMI replies\n */\nvoid astman_append(struct mansession *s, const char *fmt, ...)\n{\n\tint res;\n\tva_list ap;\n\tstruct ast_str *buf;\n\n\tif (!(buf = ast_str_thread_get(&astman_append_buf, ASTMAN_APPEND_BUF_INITSIZE))) {\n\t\treturn;\n\t}\n\n\tva_start(ap, fmt);\n\tres = ast_str_set_va(&buf, 0, fmt, ap);\n\tva_end(ap);\n\tif (res == AST_DYNSTR_BUILD_FAILED) {\n\t\treturn;\n\t}\n\n\tif (s->hook || (s->tcptls_session != NULL && s->tcptls_session->stream != NULL)) {\n\t\tsend_string(s, ast_str_buffer(buf));\n\t} else {\n\t\tast_verbose(\"No connection stream in astman_append, should not happen\\n\");\n\t}\n}\n\n/*! \\note NOTE: XXX this comment is unclear and possibly wrong.\n   Callers of astman_send_error(), astman_send_response() or astman_send_ack() must EITHER\n   hold the session lock _or_ be running in an action callback (in which case s->session->busy will\n   be non-zero). In either of these cases, there is no need to lock-protect the session's\n   fd, since no other output will be sent (events will be queued), and no input will\n   be read until either the current action finishes or get_input() obtains the session\n   lock.\n */\n\n/*! \\todo XXX MSG_MOREDATA should go to a header file. */\n#define MSG_MOREDATA\t((char *)astman_send_response)\n\n/*! \\brief send a response with an optional message,\n * and terminate it with an empty line.\n * m is used only to grab the 'ActionID' field.\n *\n * Use the explicit constant MSG_MOREDATA to remove the empty line.\n * XXX MSG_MOREDATA should go to a header file.\n */\nstatic void astman_send_response_full(struct mansession *s, const struct message *m, char *resp, char *msg, char *listflag)\n{\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tstruct ast_str *buf;\n\n\tbuf = ast_str_thread_get(&astman_append_buf, ASTMAN_APPEND_BUF_INITSIZE);\n\tif (!buf) {\n\t\treturn;\n\t}\n\n\tast_str_set(&buf, 0, \"Response: %s\\r\\n\", resp);\n\n\tif (!ast_strlen_zero(id)) {\n\t\tast_str_append(&buf, 0, \"ActionID: %s\\r\\n\", id);\n\t}\n\n\tif (listflag) {\n\t\t/* Start, complete, cancelled */\n\t\tast_str_append(&buf, 0, \"EventList: %s\\r\\n\", listflag);\n\t}\n\n\tif (msg != MSG_MOREDATA) {\n\t\tif (msg) {\n\t\t\tast_str_append(&buf, 0, \"Message: %s\\r\\n\", msg);\n\t\t}\n\t\tast_str_append(&buf, 0, \"\\r\\n\");\n\t}\n\n\tastman_flush(s, buf);\n}\n\nvoid astman_send_response(struct mansession *s, const struct message *m, char *resp, char *msg)\n{\n\tastman_send_response_full(s, m, resp, msg, NULL);\n}\n\nvoid astman_send_error(struct mansession *s, const struct message *m, char *error)\n{\n\tastman_send_response_full(s, m, \"Error\", error, NULL);\n}\n\nvoid astman_send_error_va(struct mansession *s, const struct message *m, const char *fmt, ...)\n{\n\tint res;\n\tva_list ap;\n\tstruct ast_str *buf;\n\tchar *msg;\n\n\tif (!(buf = ast_str_thread_get(&astman_append_buf, ASTMAN_APPEND_BUF_INITSIZE))) {\n\t\treturn;\n\t}\n\n\tva_start(ap, fmt);\n\tres = ast_str_set_va(&buf, 0, fmt, ap);\n\tva_end(ap);\n\tif (res == AST_DYNSTR_BUILD_FAILED) {\n\t\treturn;\n\t}\n\n\t/* astman_append will use the same underlying buffer, so copy the message out\n\t * before sending the response */\n\tmsg = ast_str_buffer(buf);\n\tif (msg) {\n\t\tmsg = ast_strdupa(msg);\n\t}\n\tastman_send_response_full(s, m, \"Error\", msg, NULL);\n}\n\nvoid astman_send_ack(struct mansession *s, const struct message *m, char *msg)\n{\n\tastman_send_response_full(s, m, \"Success\", msg, NULL);\n}\n\nstatic void astman_start_ack(struct mansession *s, const struct message *m)\n{\n\tastman_send_response_full(s, m, \"Success\", MSG_MOREDATA, NULL);\n}\n\nvoid astman_send_listack(struct mansession *s, const struct message *m, char *msg, char *listflag)\n{\n\tastman_send_response_full(s, m, \"Success\", msg, listflag);\n}\n\nstatic struct ast_str *astman_send_list_complete_start_common(struct mansession *s, const struct message *m, const char *event_name, int count)\n{\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tstruct ast_str *buf;\n\n\tbuf = ast_str_thread_get(&astman_append_buf, ASTMAN_APPEND_BUF_INITSIZE);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tast_str_set(&buf, 0, \"Event: %s\\r\\n\", event_name);\n\tif (!ast_strlen_zero(id)) {\n\t\tast_str_append(&buf, 0, \"ActionID: %s\\r\\n\", id);\n\t}\n\tast_str_append(&buf, 0,\n\t\t\"EventList: Complete\\r\\n\"\n\t\t\"ListItems: %d\\r\\n\",\n\t\tcount);\n\n\treturn buf;\n}\n\nstatic void astman_send_list_complete(struct mansession *s, const struct message *m, const char *event_name, int count)\n{\n\tstruct ast_str *buf = astman_send_list_complete_start_common(s, m, event_name, count);\n\tif (buf) {\n\t\tast_str_append(&buf, 0, \"\\r\\n\");\n\t\tastman_flush(s, buf);\n\t}\n}\n\nvoid astman_send_list_complete_start(struct mansession *s, const struct message *m, const char *event_name, int count)\n{\n\tstruct ast_str *buf = astman_send_list_complete_start_common(s, m, event_name, count);\n\tif (buf) {\n\t\tastman_flush(s, buf);\n\t}\n}\n\nvoid astman_send_list_complete_end(struct mansession *s)\n{\n\tastman_append(s, \"\\r\\n\");\n}\n\n/*! \\brief Lock the 'mansession' structure. */\nstatic void mansession_lock(struct mansession *s)\n{\n\tast_mutex_lock(&s->lock);\n}\n\n/*! \\brief Unlock the 'mansession' structure. */\nstatic void mansession_unlock(struct mansession *s)\n{\n\tast_mutex_unlock(&s->lock);\n}\n\n/*! \\brief\n   Rather than braindead on,off this now can also accept a specific int mask value\n   or a ',' delim list of mask strings (the same as manager.conf) -anthm\n*/\nstatic int set_eventmask(struct mansession *s, const char *eventmask)\n{\n\tint maskint = strings_to_mask(eventmask);\n\n\tao2_lock(s->session);\n\tif (maskint >= 0) {\n\t\ts->session->send_events = maskint;\n\t}\n\tao2_unlock(s->session);\n\n\treturn maskint;\n}\n\nstatic enum ast_transport mansession_get_transport(const struct mansession *s)\n{\n\treturn s->tcptls_session->parent->tls_cfg ? AST_TRANSPORT_TLS :\n\t\t\tAST_TRANSPORT_TCP;\n}\n\nstatic void report_invalid_user(const struct mansession *s, const char *username)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_inval_acct_id inval_acct_id = {\n\t\t.common.event_type = AST_SECURITY_EVENT_INVAL_ACCT_ID,\n\t\t.common.version    = AST_SECURITY_EVENT_INVAL_ACCT_ID_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s);\n\n\tast_security_event_report(AST_SEC_EVT(&inval_acct_id));\n}\n\nstatic void report_failed_acl(const struct mansession *s, const char *username)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_failed_acl failed_acl_event = {\n\t\t.common.event_type = AST_SECURITY_EVENT_FAILED_ACL,\n\t\t.common.version    = AST_SECURITY_EVENT_FAILED_ACL_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&failed_acl_event));\n}\n\nstatic void report_inval_password(const struct mansession *s, const char *username)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_inval_password inval_password = {\n\t\t.common.event_type = AST_SECURITY_EVENT_INVAL_PASSWORD,\n\t\t.common.version    = AST_SECURITY_EVENT_INVAL_PASSWORD_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&inval_password));\n}\n\nstatic void report_auth_success(const struct mansession *s)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_successful_auth successful_auth = {\n\t\t.common.event_type = AST_SECURITY_EVENT_SUCCESSFUL_AUTH,\n\t\t.common.version    = AST_SECURITY_EVENT_SUCCESSFUL_AUTH_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&successful_auth));\n}\n\nstatic void report_req_not_allowed(const struct mansession *s, const char *action)\n{\n\tchar session_id[32];\n\tchar request_type[64];\n\tstruct ast_security_event_req_not_allowed req_not_allowed = {\n\t\t.common.event_type = AST_SECURITY_EVENT_REQ_NOT_ALLOWED,\n\t\t.common.version    = AST_SECURITY_EVENT_REQ_NOT_ALLOWED_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\n\t\t.request_type      = request_type,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\tsnprintf(request_type, sizeof(request_type), \"Action: %s\", action);\n\n\tast_security_event_report(AST_SEC_EVT(&req_not_allowed));\n}\n\nstatic void report_req_bad_format(const struct mansession *s, const char *action)\n{\n\tchar session_id[32];\n\tchar request_type[64];\n\tstruct ast_security_event_req_bad_format req_bad_format = {\n\t\t.common.event_type = AST_SECURITY_EVENT_REQ_BAD_FORMAT,\n\t\t.common.version    = AST_SECURITY_EVENT_REQ_BAD_FORMAT_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\n\t\t.request_type      = request_type,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\tsnprintf(request_type, sizeof(request_type), \"Action: %s\", action);\n\n\tast_security_event_report(AST_SEC_EVT(&req_bad_format));\n}\n\nstatic void report_failed_challenge_response(const struct mansession *s,\n\t\tconst char *response, const char *expected_response)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_chal_resp_failed chal_resp_failed = {\n\t\t.common.event_type = AST_SECURITY_EVENT_CHAL_RESP_FAILED,\n\t\t.common.version    = AST_SECURITY_EVENT_CHAL_RESP_FAILED_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\n\t\t.challenge         = s->session->challenge,\n\t\t.response          = response,\n\t\t.expected_response = expected_response,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&chal_resp_failed));\n}\n\nstatic void report_session_limit(const struct mansession *s)\n{\n\tchar session_id[32];\n\tstruct ast_security_event_session_limit session_limit = {\n\t\t.common.event_type = AST_SECURITY_EVENT_SESSION_LIMIT,\n\t\t.common.version    = AST_SECURITY_EVENT_SESSION_LIMIT_VERSION,\n\t\t.common.service    = \"AMI\",\n\t\t.common.account_id = s->session->username,\n\t\t.common.session_tv = &s->session->sessionstart_tv,\n\t\t.common.local_addr = {\n\t\t\t.addr      = &s->tcptls_session->parent->local_address,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.remote_addr = {\n\t\t\t.addr      = &s->session->addr,\n\t\t\t.transport = mansession_get_transport(s),\n\t\t},\n\t\t.common.session_id = session_id,\n\t};\n\n\tsnprintf(session_id, sizeof(session_id), \"%p\", s->session);\n\n\tast_security_event_report(AST_SEC_EVT(&session_limit));\n}\n\n/*\n * Here we start with action_ handlers for AMI actions,\n * and the internal functions used by them.\n * Generally, the handlers are called action_foo()\n */\n\n/* helper function for action_login() */\nstatic int authenticate(struct mansession *s, const struct message *m)\n{\n\tconst char *username = astman_get_header(m, \"Username\");\n\tconst char *password = astman_get_header(m, \"Secret\");\n\tint error = -1;\n\tstruct ast_manager_user *user = NULL;\n\tregex_t *regex_filter;\n\tstruct ao2_iterator filter_iter;\n\n\tif (ast_strlen_zero(username)) {\t/* missing username */\n\t\treturn -1;\n\t}\n\n\t/* locate user in locked state */\n\tAST_RWLIST_WRLOCK(&users);\n\n\tif (!(user = get_manager_by_name_locked(username))) {\n\t\treport_invalid_user(s, username);\n\t\tast_log(LOG_NOTICE, \"%s tried to authenticate with nonexistent user '%s'\\n\", ast_sockaddr_stringify_addr(&s->session->addr), username);\n\t} else if (user->acl && (ast_apply_acl(user->acl, &s->session->addr, \"Manager User ACL: \") == AST_SENSE_DENY)) {\n\t\treport_failed_acl(s, username);\n\t\tast_log(LOG_NOTICE, \"%s failed to pass IP ACL as '%s'\\n\", ast_sockaddr_stringify_addr(&s->session->addr), username);\n\t} else if (!strcasecmp(astman_get_header(m, \"AuthType\"), \"MD5\")) {\n\t\tconst char *key = astman_get_header(m, \"Key\");\n\t\tif (!ast_strlen_zero(key) && !ast_strlen_zero(s->session->challenge) && user->secret) {\n\t\t\tint x;\n\t\t\tint len = 0;\n\t\t\tchar md5key[256] = \"\";\n\t\t\tstruct MD5Context md5;\n\t\t\tunsigned char digest[16];\n\n\t\t\tMD5Init(&md5);\n\t\t\tMD5Update(&md5, (unsigned char *) s->session->challenge, strlen(s->session->challenge));\n\t\t\tMD5Update(&md5, (unsigned char *) user->secret, strlen(user->secret));\n\t\t\tMD5Final(digest, &md5);\n\t\t\tfor (x = 0; x < 16; x++)\n\t\t\t\tlen += sprintf(md5key + len, \"%02hhx\", digest[x]);\n\t\t\tif (!strcmp(md5key, key)) {\n\t\t\t\terror = 0;\n\t\t\t} else {\n\t\t\t\treport_failed_challenge_response(s, key, md5key);\n\t\t\t}\n\t\t} else {\n\t\t\tast_debug(1, \"MD5 authentication is not possible.  challenge: '%s'\\n\",\n\t\t\t\tS_OR(s->session->challenge, \"\"));\n\t\t}\n\t} else if (user->secret) {\n\t\tif (!strcmp(password, user->secret)) {\n\t\t\terror = 0;\n\t\t} else {\n\t\t\treport_inval_password(s, username);\n\t\t}\n\t}\n\n\tif (error) {\n\t\tast_log(LOG_NOTICE, \"%s failed to authenticate as '%s'\\n\", ast_sockaddr_stringify_addr(&s->session->addr), username);\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\treturn -1;\n\t}\n\n\t/* auth complete */\n\n\t/* All of the user parameters are copied to the session so that in the event\n\t* of a reload and a configuration change, the session parameters are not\n\t* changed. */\n\tast_copy_string(s->session->username, username, sizeof(s->session->username));\n\ts->session->readperm = user->readperm;\n\ts->session->writeperm = user->writeperm;\n\ts->session->writetimeout = user->writetimeout;\n\tif (user->chanvars) {\n\t\ts->session->chanvars = ast_variables_dup(user->chanvars);\n\t}\n\n\tfilter_iter = ao2_iterator_init(user->whitefilters, 0);\n\twhile ((regex_filter = ao2_iterator_next(&filter_iter))) {\n\t\tao2_t_link(s->session->whitefilters, regex_filter, \"add white user filter to session\");\n\t\tao2_t_ref(regex_filter, -1, \"remove iterator ref\");\n\t}\n\tao2_iterator_destroy(&filter_iter);\n\n\tfilter_iter = ao2_iterator_init(user->blackfilters, 0);\n\twhile ((regex_filter = ao2_iterator_next(&filter_iter))) {\n\t\tao2_t_link(s->session->blackfilters, regex_filter, \"add black user filter to session\");\n\t\tao2_t_ref(regex_filter, -1, \"remove iterator ref\");\n\t}\n\tao2_iterator_destroy(&filter_iter);\n\n\ts->session->sessionstart = time(NULL);\n\ts->session->sessionstart_tv = ast_tvnow();\n\tset_eventmask(s, astman_get_header(m, \"Events\"));\n\n\treport_auth_success(s);\n\n\tAST_RWLIST_UNLOCK(&users);\n\treturn 0;\n}\n\nstatic int action_ping(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tstruct timeval now = ast_tvnow();\n\n\tastman_append(s, \"Response: Success\\r\\n\");\n\tif (!ast_strlen_zero(actionid)){\n\t\tastman_append(s, \"ActionID: %s\\r\\n\", actionid);\n\t}\n\tastman_append(\n\t\ts,\n\t\t\"Ping: Pong\\r\\n\"\n\t\t\"Timestamp: %ld.%06lu\\r\\n\"\n\t\t\"\\r\\n\",\n\t\t(long) now.tv_sec, (unsigned long) now.tv_usec);\n\treturn 0;\n}\n\nvoid astman_live_dangerously(int new_live_dangerously)\n{\n\tif (new_live_dangerously && !live_dangerously)\n\t{\n\t\tast_log(LOG_WARNING, \"Manager Configuration load protection disabled.\\n\");\n\t}\n\n\tif (!new_live_dangerously && live_dangerously)\n\t{\n\t\tast_log(LOG_NOTICE, \"Manager Configuration load protection enabled.\\n\");\n\t}\n\tlive_dangerously = new_live_dangerously;\n}\n\n/**\n * \\brief Check if a file is restricted or not\n *\n * \\return 0 on success\n * \\return 1 on restricted file\n * \\return -1 on failure\n */\nstatic int restrictedFile(const char *filename)\n{\n\tchar *stripped_filename;\n\tRAII_VAR(char *, path, NULL, ast_free);\n\tRAII_VAR(char *, real_path, NULL, ast_free);\n\n\tif (live_dangerously) {\n\t\treturn 0;\n\t}\n\n\tstripped_filename = ast_strip(ast_strdupa(filename));\n\n\t/* If the file path starts with '/', don't prepend ast_config_AST_CONFIG_DIR */\n\tif (stripped_filename[0] == '/') {\n\t\treal_path = realpath(stripped_filename, NULL);\n\t} else {\n\t\tif (ast_asprintf(&path, \"%s/%s\", ast_config_AST_CONFIG_DIR, stripped_filename) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treal_path = realpath(path, NULL);\n\t}\n\n\tif (!real_path) {\n\t\treturn -1;\n\t}\n\n\tif (!ast_begins_with(real_path, ast_config_AST_CONFIG_DIR)) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tint ret = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tret = restrictedFile(fn);\n\tif (ret == 1) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t} else if (ret == -1) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\nstatic int action_listcategories(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *match = astman_get_header(m, \"Match\");\n\tstruct ast_category *category = NULL;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\tint catcount = 0;\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (!(cfg = ast_config_load2(fn, \"manager\", config_flags))) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((category = ast_category_browse_filtered(cfg, NULL, category, match))) {\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, ast_category_get_name(category));\n\t\tcatcount++;\n\t}\n\n\tif (catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"Error: no categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\n/*! The amount of space in out must be at least ( 2 * strlen(in) + 1 ) */\nstatic void json_escape(char *out, const char *in)\n{\n\tfor (; *in; in++) {\n\t\tif (*in == '\\\\' || *in == '\\\"') {\n\t\t\t*out++ = '\\\\';\n\t\t}\n\t\t*out++ = *in;\n\t}\n\t*out = '\\0';\n}\n\n/*!\n * \\internal\n * \\brief Append a JSON escaped string to the manager stream.\n *\n * \\param s AMI stream to append a string.\n * \\param str String to append to the stream after JSON escaping it.\n */\nstatic void astman_append_json(struct mansession *s, const char *str)\n{\n\tchar *buf;\n\n\tbuf = ast_alloca(2 * strlen(str) + 1);\n\tjson_escape(buf, str);\n\tastman_append(s, \"%s\", buf);\n}\n\nstatic int action_getconfigjson(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tstruct ast_category *cur_category = NULL;\n\tconst char *category_name;\n\tstruct ast_variable *v;\n\tint comma1 = 0;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tif (!(cfg = ast_config_load2(fn, \"manager\", config_flags))) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\tastman_append(s, \"JSON: {\");\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tint comma2 = 0;\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tastman_append(s, \"%s\\\"\", comma1 ? \",\" : \"\");\n\t\tastman_append_json(s, category_name);\n\t\tastman_append(s, \"\\\":{\");\n\t\tcomma1 = 1;\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"\\\"istemplate\\\":1\");\n\t\t\tcomma2 = 1;\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"%s\", comma2 ? \",\" : \"\");\n\t\t\tastman_append(s, \"\\\"templates\\\":\\\"%s\\\"\", ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t\tcomma2 = 1;\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"%s\\\"\", comma2 ? \",\" : \"\");\n\t\t\tastman_append_json(s, v->name);\n\t\t\tastman_append(s, \"\\\":\\\"\");\n\t\t\tastman_append_json(s, v->value);\n\t\t\tastman_append(s, \"\\\"\");\n\t\t\tcomma2 = 1;\n\t\t}\n\n\t\tastman_append(s, \"}\");\n\t}\n\tastman_append(s, \"}\\r\\n\\r\\n\");\n\n\tast_config_destroy(cfg);\n\n\treturn 0;\n}\n\n/*! \\brief helper function for action_updateconfig */\nstatic enum error_type handle_updates(struct mansession *s, const struct message *m, struct ast_config *cfg, const char *dfn)\n{\n\tint x;\n\tchar hdr[40];\n\tconst char *action, *cat, *var, *value, *match, *line, *options;\n\tstruct ast_variable *v;\n\tstruct ast_str *str1 = ast_str_create(16), *str2 = ast_str_create(16);\n\tenum error_type result = 0;\n\n\tfor (x = 0; x < 100000; x++) {\t/* 100000 = the max number of allowed updates + 1 */\n\t\tunsigned int object = 0;\n\t\tchar *dupoptions;\n\t\tint allowdups = 0;\n\t\tint istemplate = 0;\n\t\tint ignoreerror = 0;\n\t\tRAII_VAR(char *, inherit, NULL, ast_free);\n\t\tRAII_VAR(char *, catfilter, NULL, ast_free);\n\t\tchar *token;\n\t\tint foundvar = 0;\n\t\tint foundcat = 0;\n\t\tstruct ast_category *category = NULL;\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Action-%06d\", x);\n\t\taction = astman_get_header(m, hdr);\n\t\tif (ast_strlen_zero(action))\t\t/* breaks the for loop if no action header */\n\t\t\tbreak;\t\t\t\t\t\t\t/* this could cause problems if actions come in misnumbered */\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Cat-%06d\", x);\n\t\tcat = astman_get_header(m, hdr);\n\t\tif (ast_strlen_zero(cat)) {\t\t/* every action needs a category */\n\t\t\tresult =  UNSPECIFIED_CATEGORY;\n\t\t\tbreak;\n\t\t}\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Var-%06d\", x);\n\t\tvar = astman_get_header(m, hdr);\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Value-%06d\", x);\n\t\tvalue = astman_get_header(m, hdr);\n\n\t\tif (!ast_strlen_zero(value) && *value == '>') {\n\t\t\tobject = 1;\n\t\t\tvalue++;\n\t\t}\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Match-%06d\", x);\n\t\tmatch = astman_get_header(m, hdr);\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Line-%06d\", x);\n\t\tline = astman_get_header(m, hdr);\n\n\t\tsnprintf(hdr, sizeof(hdr), \"Options-%06d\", x);\n\t\toptions = astman_get_header(m, hdr);\n\t\tif (!ast_strlen_zero(options)) {\n\t\t\tchar copy[strlen(options) + 1];\n\t\t\tstrcpy(copy, options); /* safe */\n\t\t\tdupoptions = copy;\n\t\t\twhile ((token = ast_strsep(&dupoptions, ',', AST_STRSEP_STRIP))) {\n\t\t\t\tif (!strcasecmp(\"allowdups\", token)) {\n\t\t\t\t\tallowdups = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!strcasecmp(\"template\", token)) {\n\t\t\t\t\tistemplate = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!strcasecmp(\"ignoreerror\", token)) {\n\t\t\t\t\tignoreerror = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ast_begins_with(token, \"inherit\")) {\n\t\t\t\t\tchar *c = ast_strsep(&token, '=', AST_STRSEP_STRIP);\n\t\t\t\t\tc = ast_strsep(&token, '=', AST_STRSEP_STRIP);\n\t\t\t\t\tif (c) {\n\t\t\t\t\t\tinherit = ast_strdup(c);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ast_begins_with(token, \"catfilter\")) {\n\t\t\t\t\tchar *c = ast_strsep(&token, '=', AST_STRSEP_STRIP);\n\t\t\t\t\tc = ast_strsep(&token, '=', AST_STRSEP_STRIP);\n\t\t\t\t\tif (c) {\n\t\t\t\t\t\tcatfilter = ast_strdup(c);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!strcasecmp(action, \"newcat\")) {\n\t\t\tstruct ast_category *template;\n\t\t\tchar *tmpl_name = NULL;\n\n\t\t\tif (!allowdups) {\n\t\t\t\tif (ast_category_get(cfg, cat, \"TEMPLATES=include\")) {\n\t\t\t\t\tif (ignoreerror) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = FAILURE_NEWCAT;\t/* already exist */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (istemplate) {\n\t\t\t\tcategory = ast_category_new_template(cat, dfn, -1);\n\t\t\t} else {\n\t\t\t\tcategory = ast_category_new(cat, dfn, -1);\n\t\t\t}\n\n\t\t\tif (!category) {\n\t\t\t\tresult = FAILURE_ALLOCATION;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (inherit) {\n\t\t\t\twhile ((tmpl_name = ast_strsep(&inherit, ',', AST_STRSEP_STRIP))) {\n\t\t\t\t\tif ((template = ast_category_get(cfg, tmpl_name, \"TEMPLATES=restrict\"))) {\n\t\t\t\t\t\tif (ast_category_inherit(category, template)) {\n\t\t\t\t\t\t\tresult = FAILURE_ALLOCATION;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tast_category_destroy(category);\n\t\t\t\t\t\tcategory = NULL;\n\t\t\t\t\t\tresult = FAILURE_TEMPLATE;\t/* template not found */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (category != NULL) {\n\t\t\t\tif (ast_strlen_zero(match)) {\n\t\t\t\t\tast_category_append(cfg, category);\n\t\t\t\t} else {\n\t\t\t\t\tif (ast_category_insert(cfg, category, match)) {\n\t\t\t\t\t\tast_category_destroy(category);\n\t\t\t\t\t\tresult = FAILURE_NEWCAT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"renamecat\")) {\n\t\t\tif (ast_strlen_zero(value)) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tast_category_rename(category, value);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"delcat\")) {\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tcategory = ast_category_delete(cfg, category);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat && !ignoreerror) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"emptycat\")) {\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tast_category_empty(category);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"update\")) {\n\t\t\tif (ast_strlen_zero(var)) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\tfoundvar = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tif (!ast_variable_update(category, var, value, match, object)) {\n\t\t\t\t\tfoundvar = 1;\n\t\t\t\t}\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!foundvar) {\n\t\t\t\tresult = FAILURE_UPDATE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"delete\")) {\n\t\t\tif ((ast_strlen_zero(var) && ast_strlen_zero(line))) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\tfoundvar = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tif (!ast_variable_delete(category, var, match, line)) {\n\t\t\t\t\tfoundvar = 1;\n\t\t\t\t}\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!foundvar && !ignoreerror) {\n\t\t\t\tresult = FAILURE_UPDATE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"append\")) {\n\t\t\tif (ast_strlen_zero(var)) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tif (!(v = ast_variable_new(var, value, dfn))) {\n\t\t\t\t\tresult = FAILURE_ALLOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (object || (match && !strcasecmp(match, \"object\"))) {\n\t\t\t\t\tv->object = 1;\n\t\t\t\t}\n\t\t\t\tast_variable_append(category, v);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strcasecmp(action, \"insert\")) {\n\t\t\tif (ast_strlen_zero(var) || ast_strlen_zero(line)) {\n\t\t\t\tresult = UNSPECIFIED_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfoundcat = 0;\n\t\t\twhile ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {\n\t\t\t\tif (!(v = ast_variable_new(var, value, dfn))) {\n\t\t\t\t\tresult = FAILURE_ALLOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tast_variable_insert(category, v, line);\n\t\t\t\tfoundcat = 1;\n\t\t\t}\n\n\t\t\tif (!foundcat) {\n\t\t\t\tresult = UNKNOWN_CATEGORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tast_log(LOG_WARNING, \"Action-%06d: %s not handled\\n\", x, action);\n\t\t\tresult = UNKNOWN_ACTION;\n\t\t\tbreak;\n\t\t}\n\t}\n\tast_free(str1);\n\tast_free(str2);\n\treturn result;\n}\n\nstatic int action_updateconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *sfn = astman_get_header(m, \"SrcFilename\");\n\tconst char *dfn = astman_get_header(m, \"DstFilename\");\n\tint res;\n\tconst char *rld = astman_get_header(m, \"Reload\");\n\tint preserve_effective_context = CONFIG_SAVE_FLAG_PRESERVE_EFFECTIVE_CONTEXT;\n\tconst char *preserve_effective_context_string = astman_get_header(m, \"PreserveEffectiveContext\");\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\tenum error_type result;\n\n\tif (ast_strlen_zero(sfn) || ast_strlen_zero(dfn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\tif (restrictedFile(sfn) || restrictedFile(dfn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\tif (!(cfg = ast_config_load2(sfn, \"manager\", config_flags))) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\tresult = handle_updates(s, m, cfg, dfn);\n\tif (!result) {\n\t\tast_include_rename(cfg, sfn, dfn); /* change the include references from dfn to sfn, so things match up */\n\t\tif (!ast_strlen_zero(preserve_effective_context_string) && !ast_true(preserve_effective_context_string)) {\n\t\t\tpreserve_effective_context = CONFIG_SAVE_FLAG_NONE;\n\t\t}\n\t\tres = ast_config_text_file_save2(dfn, cfg, \"Manager\", preserve_effective_context);\n\t\tast_config_destroy(cfg);\n\t\tif (res) {\n\t\t\tastman_send_error(s, m, \"Save of config failed\");\n\t\t\treturn 0;\n\t\t}\n\t\tastman_send_ack(s, m, NULL);\n\t\tif (!ast_strlen_zero(rld)) {\n\t\t\tif (ast_true(rld)) {\n\t\t\t\trld = NULL;\n\t\t\t}\n\t\t\tast_module_reload(rld);\n\t\t}\n\t} else {\n\t\tast_config_destroy(cfg);\n\t\tswitch(result) {\n\t\tcase UNKNOWN_ACTION:\n\t\t\tastman_send_error(s, m, \"Unknown action command\");\n\t\t\tbreak;\n\t\tcase UNKNOWN_CATEGORY:\n\t\t\tastman_send_error(s, m, \"Given category does not exist\");\n\t\t\tbreak;\n\t\tcase UNSPECIFIED_CATEGORY:\n\t\t\tastman_send_error(s, m, \"Category not specified\");\n\t\t\tbreak;\n\t\tcase UNSPECIFIED_ARGUMENT:\n\t\t\tastman_send_error(s, m, \"Problem with category, value, or line (if required)\");\n\t\t\tbreak;\n\t\tcase FAILURE_ALLOCATION:\n\t\t\tastman_send_error(s, m, \"Memory allocation failure, this should not happen\");\n\t\t\tbreak;\n\t\tcase FAILURE_NEWCAT:\n\t\t\tastman_send_error(s, m, \"Create category did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_DELCAT:\n\t\t\tastman_send_error(s, m, \"Delete category did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_EMPTYCAT:\n\t\t\tastman_send_error(s, m, \"Empty category did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_UPDATE:\n\t\t\tastman_send_error(s, m, \"Update did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_DELETE:\n\t\t\tastman_send_error(s, m, \"Delete did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_APPEND:\n\t\t\tastman_send_error(s, m, \"Append did not complete successfully\");\n\t\t\tbreak;\n\t\tcase FAILURE_TEMPLATE:\n\t\t\tastman_send_error(s, m, \"Template category not found\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int action_createconfig(struct mansession *s, const struct message *m)\n{\n\tint fd;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tstruct ast_str *filepath = ast_str_alloca(PATH_MAX);\n\tast_str_set(&filepath, 0, \"%s/\", ast_config_AST_CONFIG_DIR);\n\tast_str_append(&filepath, 0, \"%s\", fn);\n\n\tif ((fd = open(ast_str_buffer(filepath), O_CREAT | O_EXCL, AST_FILE_MODE)) != -1) {\n\t\tclose(fd);\n\t\tastman_send_ack(s, m, \"New configuration file created successfully\");\n\t} else {\n\t\tastman_send_error(s, m, strerror(errno));\n\t}\n\n\treturn 0;\n}\n\nstatic int action_waitevent(struct mansession *s, const struct message *m)\n{\n\tconst char *timeouts = astman_get_header(m, \"Timeout\");\n\tint timeout = -1;\n\tint x;\n\tint needexit = 0;\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tchar idText[256];\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", id);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tif (!ast_strlen_zero(timeouts)) {\n\t\tsscanf(timeouts, \"%30i\", &timeout);\n\t\tif (timeout < -1) {\n\t\t\ttimeout = -1;\n\t\t}\n\t\t/* XXX maybe put an upper bound, or prevent the use of 0 ? */\n\t}\n\n\tast_mutex_lock(&s->session->notify_lock);\n\tif (s->session->waiting_thread != AST_PTHREADT_NULL) {\n\t\tpthread_kill(s->session->waiting_thread, SIGURG);\n\t}\n\tast_mutex_unlock(&s->session->notify_lock);\n\n\tao2_lock(s->session);\n\n\tif (s->session->managerid) { /* AMI-over-HTTP session */\n\t\t/*\n\t\t * Make sure the timeout is within the expire time of the session,\n\t\t * as the client will likely abort the request if it does not see\n\t\t * data coming after some amount of time.\n\t\t */\n\t\ttime_t now = time(NULL);\n\t\tint max = s->session->sessiontimeout - now - 10;\n\n\t\tif (max < 0) {\t/* We are already late. Strange but possible. */\n\t\t\tmax = 0;\n\t\t}\n\t\tif (timeout < 0 || timeout > max) {\n\t\t\ttimeout = max;\n\t\t}\n\t\tif (!s->session->send_events) {\t/* make sure we record events */\n\t\t\ts->session->send_events = -1;\n\t\t}\n\t}\n\tao2_unlock(s->session);\n\n\tast_mutex_lock(&s->session->notify_lock);\n\ts->session->waiting_thread = pthread_self();\t/* let new events wake up this thread */\n\tast_mutex_unlock(&s->session->notify_lock);\n\tast_debug(1, \"Starting waiting for an event!\\n\");\n\n\tfor (x = 0; x < timeout || timeout < 0; x++) {\n\t\tao2_lock(s->session);\n\t\tif (AST_RWLIST_NEXT(s->session->last_ev, eq_next)) {\n\t\t\tneedexit = 1;\n\t\t}\n\t\tif (s->session->needdestroy) {\n\t\t\tneedexit = 1;\n\t\t}\n\t\tao2_unlock(s->session);\n\t\t/* We can have multiple HTTP session point to the same mansession entry.\n\t\t * The way we deal with it is not very nice: newcomers kick out the previous\n\t\t * HTTP session. XXX this needs to be improved.\n\t\t */\n\t\tast_mutex_lock(&s->session->notify_lock);\n\t\tif (s->session->waiting_thread != pthread_self()) {\n\t\t\tneedexit = 1;\n\t\t}\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\t\tif (needexit) {\n\t\t\tbreak;\n\t\t}\n\t\tif (s->session->managerid == 0) {\t/* AMI session */\n\t\t\tif (ast_wait_for_input(ast_iostream_get_fd(s->session->stream), 1000)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\t/* HTTP session */\n\t\t\tsleep(1);\n\t\t}\n\t}\n\tast_debug(1, \"Finished waiting for an event!\\n\");\n\n\tast_mutex_lock(&s->session->notify_lock);\n\tif (s->session->waiting_thread == pthread_self()) {\n\t\tstruct eventqent *eqe = s->session->last_ev;\n\n\t\ts->session->waiting_thread = AST_PTHREADT_NULL;\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\n\t\tao2_lock(s->session);\n\t\tastman_send_response(s, m, \"Success\", \"Waiting for Event completed.\");\n\t\twhile ((eqe = advance_event(eqe))) {\n\t\t\tif (((s->session->readperm & eqe->category) == eqe->category)\n\t\t\t\t&& ((s->session->send_events & eqe->category) == eqe->category)\n\t\t\t\t&& match_filter(s, eqe->eventdata)) {\n\t\t\t\tastman_append(s, \"%s\", eqe->eventdata);\n\t\t\t}\n\t\t\ts->session->last_ev = eqe;\n\t\t}\n\t\tastman_append(s,\n\t\t\t\"Event: WaitEventComplete\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"\\r\\n\", idText);\n\t\tao2_unlock(s->session);\n\t} else {\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\t\tast_debug(1, \"Abandoning event request!\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int action_listcommands(struct mansession *s, const struct message *m)\n{\n\tstruct manager_action *cur;\n\tstruct ast_str *temp = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\n\tastman_start_ack(s, m);\n\tAST_RWLIST_RDLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tif ((s->session->writeperm & cur->authority) || cur->authority == 0) {\n\t\t\tastman_append(s, \"%s: %s (Priv: %s)\\r\\n\",\n\t\t\t\tcur->action, cur->synopsis, authority_to_str(cur->authority, &temp));\n\t\t}\n\t}\n\tAST_RWLIST_UNLOCK(&actions);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\nstatic int action_events(struct mansession *s, const struct message *m)\n{\n\tconst char *mask = astman_get_header(m, \"EventMask\");\n\tint res, x;\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tchar id_text[256];\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(id_text, sizeof(id_text), \"ActionID: %s\\r\\n\", id);\n\t} else {\n\t\tid_text[0] = '\\0';\n\t}\n\n\tres = set_eventmask(s, mask);\n\tif (broken_events_action) {\n\t\t/* if this option is set we should not return a response on\n\t\t * error, or when all events are set */\n\n\t\tif (res > 0) {\n\t\t\tfor (x = 0; x < ARRAY_LEN(perms); x++) {\n\t\t\t\tif (!strcasecmp(perms[x].label, \"all\") && res == perms[x].num) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tastman_append(s, \"Response: Success\\r\\n%s\"\n\t\t\t\t\t \"Events: On\\r\\n\\r\\n\", id_text);\n\t\t} else if (res == 0)\n\t\t\tastman_append(s, \"Response: Success\\r\\n%s\"\n\t\t\t\t\t \"Events: Off\\r\\n\\r\\n\", id_text);\n\t\treturn 0;\n\t}\n\n\tif (res > 0)\n\t\tastman_append(s, \"Response: Success\\r\\n%s\"\n\t\t\t\t \"Events: On\\r\\n\\r\\n\", id_text);\n\telse if (res == 0)\n\t\tastman_append(s, \"Response: Success\\r\\n%s\"\n\t\t\t\t \"Events: Off\\r\\n\\r\\n\", id_text);\n\telse\n\t\tastman_send_error(s, m, \"Invalid event mask\");\n\n\treturn 0;\n}\n\nstatic int action_logoff(struct mansession *s, const struct message *m)\n{\n\tastman_send_response(s, m, \"Goodbye\", \"Thanks for all the fish.\");\n\treturn -1;\n}\n\nstatic int action_login(struct mansession *s, const struct message *m)\n{\n\n\t/* still authenticated - don't process again */\n\tif (s->session->authenticated) {\n\t\tastman_send_ack(s, m, \"Already authenticated\");\n\t\treturn 0;\n\t}\n\n\tif (authenticate(s, m)) {\n\t\tsleep(1);\n\t\tastman_send_error(s, m, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\ts->session->authenticated = 1;\n\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\tif (manager_displayconnects(s->session)) {\n\t\tast_verb(2, \"%sManager '%s' logged on from %s\\n\", (s->session->managerid ? \"HTTP \" : \"\"), s->session->username, ast_sockaddr_stringify_addr(&s->session->addr));\n\t}\n\tastman_send_ack(s, m, \"Authentication accepted\");\n\tif ((s->session->send_events & EVENT_FLAG_SYSTEM)\n\t\t&& (s->session->readperm & EVENT_FLAG_SYSTEM)\n\t\t&& ast_test_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {\n\t\tstruct ast_str *auth = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\t\tconst char *cat_str = authority_to_str(EVENT_FLAG_SYSTEM, &auth);\n\t\tlong uptime = 0;\n\t\tlong lastreloaded = 0;\n\t\tstruct timeval tmp;\n\t\tstruct timeval curtime = ast_tvnow();\n\n\t\tif (ast_startuptime.tv_sec) {\n\t\t\ttmp = ast_tvsub(curtime, ast_startuptime);\n\t\t\tuptime = tmp.tv_sec;\n\t\t}\n\n\t\tif (ast_lastreloadtime.tv_sec) {\n\t\t\ttmp = ast_tvsub(curtime, ast_lastreloadtime);\n\t\t\tlastreloaded = tmp.tv_sec;\n\t\t}\n\n\t\tastman_append(s, \"Event: FullyBooted\\r\\n\"\n\t\t\t\"Privilege: %s\\r\\n\"\n\t\t\t\"Uptime: %ld\\r\\n\"\n\t\t\t\"LastReload: %ld\\r\\n\"\n\t\t\t\"Status: Fully Booted\\r\\n\\r\\n\", cat_str, uptime, lastreloaded);\n\t}\n\treturn 0;\n}\n\nstatic int action_challenge(struct mansession *s, const struct message *m)\n{\n\tconst char *authtype = astman_get_header(m, \"AuthType\");\n\n\tif (!strcasecmp(authtype, \"MD5\")) {\n\t\tif (ast_strlen_zero(s->session->challenge)) {\n\t\t\tsnprintf(s->session->challenge, sizeof(s->session->challenge), \"%ld\", ast_random());\n\t\t}\n\t\tmansession_lock(s);\n\t\tastman_start_ack(s, m);\n\t\tastman_append(s, \"Challenge: %s\\r\\n\\r\\n\", s->session->challenge);\n\t\tmansession_unlock(s);\n\t} else {\n\t\tastman_send_error(s, m, \"Must specify AuthType\");\n\t}\n\treturn 0;\n}\n\nint ast_manager_hangup_helper(struct mansession *s,\n\tconst struct message *m, manager_hangup_handler_t hangup_handler,\n\tmanager_hangup_cause_validator_t cause_validator)\n{\n\tstruct ast_channel *c = NULL;\n\tint causecode = 0; /* all values <= 0 mean 'do not set hangupcause in channel' */\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tconst char *name_or_regex = astman_get_header(m, \"Channel\");\n\tconst char *cause = astman_get_header(m, \"Cause\");\n\tchar idText[256];\n\tregex_t regexbuf;\n\tstruct ast_channel_iterator *iter = NULL;\n\tstruct ast_str *regex_string;\n\tint channels_matched = 0;\n\n\tif (ast_strlen_zero(name_or_regex)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", id);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tif (cause_validator) {\n\t\tcausecode = cause_validator(name_or_regex, cause);\n\t} else if (!ast_strlen_zero(cause)) {\n\t\tchar *endptr;\n\t\tcausecode = strtol(cause, &endptr, 10);\n\t\tif (causecode < 0 || causecode > 127 || *endptr != '\\0') {\n\t\t\tast_log(LOG_NOTICE, \"Invalid 'Cause: %s' in manager action Hangup\\n\", cause);\n\t\t\t/* keep going, better to hangup without cause than to not hang up at all */\n\t\t\tcausecode = 0; /* do not set channel's hangupcause */\n\t\t}\n\t}\n\n\t/************************************************/\n\t/* Regular explicit match channel byname hangup */\n\n\tif (name_or_regex[0] != '/') {\n\t\tif (!(c = ast_channel_get_by_name(name_or_regex))) {\n\t\t\tast_log(LOG_NOTICE, \"Request to hangup non-existent channel: %s\\n\",\n\t\t\t\tname_or_regex);\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tast_verb(3, \"%sManager '%s' from %s, hanging up channel: %s\\n\",\n\t\t\t(s->session->managerid ? \"HTTP \" : \"\"),\n\t\t\ts->session->username,\n\t\t\tast_sockaddr_stringify_addr(&s->session->addr),\n\t\t\tast_channel_name(c));\n\n\t\thangup_handler(c, causecode);\n\t\tc = ast_channel_unref(c);\n\n\t\tastman_send_ack(s, m, \"Channel Hungup\");\n\n\t\treturn 0;\n\t}\n\n\t/***********************************************/\n\t/* find and hangup any channels matching regex */\n\n\tregex_string = ast_str_create(strlen(name_or_regex));\n\tif (!regex_string) {\n\t\tastman_send_error(s, m, \"Memory Allocation Failure\");\n\t\treturn 0;\n\t}\n\n\t/* Make \"/regex/\" into \"regex\" */\n\tif (ast_regex_string_to_regex_pattern(name_or_regex, &regex_string) != 0) {\n\t\tastman_send_error(s, m, \"Regex format invalid, Channel param should be /regex/\");\n\t\tast_free(regex_string);\n\t\treturn 0;\n\t}\n\n\t/* if regex compilation fails, hangup fails */\n\tif (regcomp(&regexbuf, ast_str_buffer(regex_string), REG_EXTENDED | REG_NOSUB)) {\n\t\tastman_send_error_va(s, m, \"Regex compile failed on: %s\", name_or_regex);\n\t\tast_free(regex_string);\n\t\treturn 0;\n\t}\n\n\tastman_send_listack(s, m, \"Channels hung up will follow\", \"start\");\n\n\titer = ast_channel_iterator_all_new();\n\tif (iter) {\n\t\tfor (; (c = ast_channel_iterator_next(iter)); ast_channel_unref(c)) {\n\t\t\tif (regexec(&regexbuf, ast_channel_name(c), 0, NULL, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tast_verb(3, \"%sManager '%s' from %s, hanging up channel: %s\\n\",\n\t\t\t\t(s->session->managerid ? \"HTTP \" : \"\"),\n\t\t\t\ts->session->username,\n\t\t\t\tast_sockaddr_stringify_addr(&s->session->addr),\n\t\t\t\tast_channel_name(c));\n\n\t\t\thangup_handler(c, causecode);\n\t\t\tchannels_matched++;\n\n\t\t\tastman_append(s,\n\t\t\t\t\"Event: ChannelHungup\\r\\n\"\n\t\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\t\"%s\"\n\t\t\t\t\"\\r\\n\", ast_channel_name(c), idText);\n\t\t}\n\t\tast_channel_iterator_destroy(iter);\n\t}\n\n\tregfree(&regexbuf);\n\tast_free(regex_string);\n\n\tastman_send_list_complete(s, m, \"ChannelsHungupListComplete\", channels_matched);\n\n\treturn 0;\n}\n\nstatic int action_hangup(struct mansession *s, const struct message *m)\n{\n\treturn ast_manager_hangup_helper(s, m,\n\t\tast_channel_softhangup_withcause_locked, NULL);\n}\n\nstatic int action_setvar(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c = NULL;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *varname = astman_get_header(m, \"Variable\");\n\tconst char *varval = astman_get_header(m, \"Value\");\n\tint res = 0;\n\n\tif (ast_strlen_zero(varname)) {\n\t\tastman_send_error(s, m, \"No variable specified\");\n\t\treturn 0;\n\t}\n\n\tif (!ast_strlen_zero(name)) {\n\t\tif (!(c = ast_channel_get_by_name(name))) {\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tres = pbx_builtin_setvar_helper(c, varname, S_OR(varval, \"\"));\n\n\tif (c) {\n\t\tc = ast_channel_unref(c);\n\t}\n\tif (res == 0) {\n\t\tastman_send_ack(s, m, \"Variable Set\");\n\t} else {\n\t\tastman_send_error(s, m, \"Variable not set\");\n\t}\n\treturn 0;\n}\n\nstatic int action_getvar(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c = NULL;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *varname = astman_get_header(m, \"Variable\");\n\tchar *varval;\n\tchar workspace[1024];\n\n\tif (ast_strlen_zero(varname)) {\n\t\tastman_send_error(s, m, \"No variable specified\");\n\t\treturn 0;\n\t}\n\n\t/* We don't want users with insufficient permissions using certain functions. */\n\tif (!(function_capable_string_allowed_with_auths(varname, s->session->writeperm))) {\n\t\tastman_send_error(s, m, \"GetVar Access Forbidden: Variable\");\n\t\treturn 0;\n\t}\n\n\tif (!ast_strlen_zero(name)) {\n\t\tif (!(c = ast_channel_get_by_name(name))) {\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tworkspace[0] = '\\0';\n\tif (varname[strlen(varname) - 1] == ')') {\n\t\tif (!c) {\n\t\t\tc = ast_dummy_channel_alloc();\n\t\t\tif (c) {\n\t\t\t\tast_func_read(c, (char *) varname, workspace, sizeof(workspace));\n\t\t\t} else\n\t\t\t\tast_log(LOG_ERROR, \"Unable to allocate bogus channel for variable substitution.  Function results may be blank.\\n\");\n\t\t} else {\n\t\t\tast_func_read(c, (char *) varname, workspace, sizeof(workspace));\n\t\t}\n\t\tvarval = workspace;\n\t} else {\n\t\tpbx_retrieve_variable(c, varname, &varval, workspace, sizeof(workspace), NULL);\n\t}\n\n\tif (c) {\n\t\tc = ast_channel_unref(c);\n\t}\n\n\tastman_start_ack(s, m);\n\tastman_append(s, \"Variable: %s\\r\\nValue: %s\\r\\n\\r\\n\", varname, S_OR(varval, \"\"));\n\n\treturn 0;\n}\n\nstatic void generate_status(struct mansession *s, struct ast_channel *chan, char **vars, int varc, int all_variables, char *id_text, int *count)\n{\n\tstruct timeval now;\n\tlong elapsed_seconds;\n\tstruct ast_bridge *bridge;\n\tRAII_VAR(struct ast_str *, variable_str, NULL, ast_free);\n\tstruct ast_str *write_transpath = ast_str_alloca(256);\n\tstruct ast_str *read_transpath = ast_str_alloca(256);\n\tstruct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);\n\tstruct ast_party_id effective_id;\n\tint i;\n\tRAII_VAR(struct ast_channel_snapshot *, snapshot,\n\t\tast_channel_snapshot_get_latest(ast_channel_uniqueid(chan)),\n\t\tao2_cleanup);\n\tRAII_VAR(struct ast_str *, snapshot_str, NULL, ast_free);\n\n\tif (!snapshot) {\n\t\treturn;\n\t}\n\n\tsnapshot_str = ast_manager_build_channel_state_string(snapshot);\n\tif (!snapshot_str) {\n\t\treturn;\n\t}\n\n\tif (all_variables) {\n\t\tvariable_str = ast_str_create(2048);\n\t} else {\n\t\tvariable_str = ast_str_create(1024);\n\t}\n\tif (!variable_str) {\n\t\treturn;\n\t}\n\n\tnow = ast_tvnow();\n\telapsed_seconds = ast_tvdiff_sec(now, ast_channel_creationtime(chan));\n\n\t/* Even if all_variables has been specified, explicitly requested variables\n\t * may be global variables or dialplan functions */\n\tfor (i = 0; i < varc; i++) {\n\t\tchar valbuf[512], *ret = NULL;\n\n\t\tif (vars[i][strlen(vars[i]) - 1] == ')') {\n\t\t\tif (ast_func_read(chan, vars[i], valbuf, sizeof(valbuf)) < 0) {\n\t\t\t\tvalbuf[0] = '\\0';\n\t\t\t}\n\t\t\tret = valbuf;\n\t\t} else {\n\t\t\tpbx_retrieve_variable(chan, vars[i], &ret, valbuf, sizeof(valbuf), NULL);\n\t\t}\n\n\t\tast_str_append(&variable_str, 0, \"Variable: %s=%s\\r\\n\", vars[i], ret);\n\t}\n\n\t/* Walk all channel variables and add them */\n\tif (all_variables) {\n\t\tstruct ast_var_t *variables;\n\n\t\tAST_LIST_TRAVERSE(ast_channel_varshead(chan), variables, entries) {\n\t\t\tast_str_append(&variable_str, 0, \"Variable: %s=%s\\r\\n\",\n\t\t\t\tast_var_name(variables), ast_var_value(variables));\n\t\t}\n\t}\n\n\tbridge = ast_channel_get_bridge(chan);\n\teffective_id = ast_channel_connected_effective_id(chan);\n\n\tastman_append(s,\n\t\t\"Event: Status\\r\\n\"\n\t\t\"Privilege: Call\\r\\n\"\n\t\t\"%s\"\n\t\t\"Type: %s\\r\\n\"\n\t\t\"DNID: %s\\r\\n\"\n\t\t\"EffectiveConnectedLineNum: %s\\r\\n\"\n\t\t\"EffectiveConnectedLineName: %s\\r\\n\"\n\t\t\"TimeToHangup: %ld\\r\\n\"\n\t\t\"BridgeID: %s\\r\\n\"\n\t\t\"Application: %s\\r\\n\"\n\t\t\"Data: %s\\r\\n\"\n\t\t\"Nativeformats: %s\\r\\n\"\n\t\t\"Readformat: %s\\r\\n\"\n\t\t\"Readtrans: %s\\r\\n\"\n\t\t\"Writeformat: %s\\r\\n\"\n\t\t\"Writetrans: %s\\r\\n\"\n\t\t\"Callgroup: %llu\\r\\n\"\n\t\t\"Pickupgroup: %llu\\r\\n\"\n\t\t\"Seconds: %ld\\r\\n\"\n\t\t\"%s\"\n\t\t\"%s\"\n\t\t\"\\r\\n\",\n\t\tast_str_buffer(snapshot_str),\n\t\tast_channel_tech(chan)->type,\n\t\tS_OR(ast_channel_dialed(chan)->number.str, \"\"),\n\t\tS_COR(effective_id.number.valid, effective_id.number.str, \"<unknown>\"),\n\t\tS_COR(effective_id.name.valid, effective_id.name.str, \"<unknown>\"),\n\t\t(long)ast_channel_whentohangup(chan)->tv_sec,\n\t\tbridge ? bridge->uniqueid : \"\",\n\t\tast_channel_appl(chan),\n\t\tast_channel_data(chan),\n\t\tast_format_cap_get_names(ast_channel_nativeformats(chan), &codec_buf),\n\t\tast_format_get_name(ast_channel_readformat(chan)),\n\t\tast_translate_path_to_str(ast_channel_readtrans(chan), &read_transpath),\n\t\tast_format_get_name(ast_channel_writeformat(chan)),\n\t\tast_translate_path_to_str(ast_channel_writetrans(chan), &write_transpath),\n\t\tast_channel_callgroup(chan),\n\t\tast_channel_pickupgroup(chan),\n\t\t(long)elapsed_seconds,\n\t\tast_str_buffer(variable_str),\n\t\tid_text);\n\t++*count;\n\n\tao2_cleanup(bridge);\n}\n\n/*! \\brief Manager \"status\" command to show channels */\nstatic int action_status(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *chan_variables = astman_get_header(m, \"Variables\");\n\tconst char *all_chan_variables = astman_get_header(m, \"AllVariables\");\n\tint all_variables = 0;\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tchar *variables = ast_strdupa(S_OR(chan_variables, \"\"));\n\tstruct ast_channel *chan;\n\tint channels = 0;\n\tint all = ast_strlen_zero(name); /* set if we want all channels */\n\tchar id_text[256];\n\tstruct ast_channel_iterator *it_chans = NULL;\n\tAST_DECLARE_APP_ARGS(vars,\n\t\tAST_APP_ARG(name)[100];\n\t);\n\n\tif (!ast_strlen_zero(all_chan_variables)) {\n\t\tall_variables = ast_true(all_chan_variables);\n\t}\n\n\tif (!(function_capable_string_allowed_with_auths(variables, s->session->writeperm))) {\n\t\tastman_send_error(s, m, \"Status Access Forbidden: Variables\");\n\t\treturn 0;\n\t}\n\n\tif (all) {\n\t\tif (!(it_chans = ast_channel_iterator_all_new())) {\n\t\t\tastman_send_error(s, m, \"Memory Allocation Failure\");\n\t\t\treturn 1;\n\t\t}\n\t\tchan = ast_channel_iterator_next(it_chans);\n\t} else {\n\t\tchan = ast_channel_get_by_name(name);\n\t\tif (!chan) {\n\t\t\tastman_send_error(s, m, \"No such channel\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tastman_send_listack(s, m, \"Channel status will follow\", \"start\");\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(id_text, sizeof(id_text), \"ActionID: %s\\r\\n\", id);\n\t} else {\n\t\tid_text[0] = '\\0';\n\t}\n\n\tif (!ast_strlen_zero(chan_variables)) {\n\t\tAST_STANDARD_APP_ARGS(vars, variables);\n\t}\n\n\t/* if we look by name, we break after the first iteration */\n\tfor (; chan; all ? chan = ast_channel_iterator_next(it_chans) : 0) {\n\t\tast_channel_lock(chan);\n\n\t\tgenerate_status(s, chan, vars.name, vars.argc, all_variables, id_text, &channels);\n\n\t\tast_channel_unlock(chan);\n\t\tchan = ast_channel_unref(chan);\n\t}\n\n\tif (it_chans) {\n\t\tast_channel_iterator_destroy(it_chans);\n\t}\n\n\tastman_send_list_complete_start(s, m, \"StatusComplete\", channels);\n\tastman_append(s, \"Items: %d\\r\\n\", channels);\n\tastman_send_list_complete_end(s);\n\n\treturn 0;\n}\n\n/*!\n * \\brief Queue a given read action containing a payload onto a channel\n *\n * This queues a READ_ACTION control frame that contains a given \"payload\", or\n * data to be triggered and handled on the channel's read side. This ensures\n * the \"action\" is handled by the channel's media reading thread.\n *\n * \\param chan The channel to queue the action on\n * \\param payload The read action's payload\n * \\param payload_size The size of the given payload\n * \\param action The type of read action to queue\n *\n * \\retval -1 on error\n * \\retval 0 on success\n */\nstatic int queue_read_action_payload(struct ast_channel *chan, const unsigned char *payload,\n\tsize_t payload_size, enum ast_frame_read_action action)\n{\n\tstruct ast_control_read_action_payload *obj;\n\tsize_t obj_size;\n\tint res;\n\n\tobj_size = payload_size + sizeof(*obj);\n\n\tobj = ast_malloc(obj_size);\n\tif (!obj) {\n\t\treturn -1;\n\t}\n\n\tobj->action = action;\n\tobj->payload_size = payload_size;\n\tmemcpy(obj->payload, payload, payload_size);\n\n\tres = ast_queue_control_data(chan, AST_CONTROL_READ_ACTION, obj, obj_size);\n\n\tast_free(obj);\n\treturn res;\n}\n\n/*!\n * \\brief Queue a read action to send a text message\n *\n * \\param chan The channel to queue the action on\n * \\param body The body of the message\n *\n * \\retval -1 on error\n * \\retval 0 on success\n */\nstatic int queue_sendtext(struct ast_channel *chan, const char *body)\n{\n\treturn queue_read_action_payload(chan, (const unsigned char *)body,\n\t\tstrlen(body) + 1, AST_FRAME_READ_ACTION_SEND_TEXT);\n}\n\n/*!\n * \\brief Queue a read action to send a text data message\n *\n * \\param chan The channel to queue the action on\n * \\param body The body of the message\n * \\param content_type The message's content type\n *\n * \\retval -1 on error\n * \\retval 0 on success\n */\nstatic int queue_sendtext_data(struct ast_channel *chan, const char *body,\n\tconst char *content_type)\n{\n\tint res;\n\tstruct ast_msg_data *obj;\n\n\tobj = ast_msg_data_alloc2(AST_MSG_DATA_SOURCE_TYPE_UNKNOWN,\n\t\t\t\t\t\t\tNULL, NULL, content_type, body);\n\tif (!obj) {\n\t\treturn -1;\n\t}\n\n\tres = queue_read_action_payload(chan, (const unsigned char *)obj,\n\t\tast_msg_data_get_length(obj), AST_FRAME_READ_ACTION_SEND_TEXT_DATA);\n\n\tast_free(obj);\n\treturn res;\n}\n\nstatic int action_sendtext(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *textmsg = astman_get_header(m, \"Message\");\n\tconst char *content_type = astman_get_header(m, \"Content-Type\");\n\tint res;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(textmsg)) {\n\t\tastman_send_error(s, m, \"No Message specified\");\n\t\treturn 0;\n\t}\n\n\tc = ast_channel_get_by_name(name);\n\tif (!c) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the \"extra\" data is not available, then send using \"string\" only.\n\t * Doing such maintains backward compatibilities.\n\t */\n\tres = ast_strlen_zero(content_type) ? queue_sendtext(c, textmsg) :\n\t\tqueue_sendtext_data(c, textmsg, content_type);\n\n\tast_channel_unref(c);\n\n\tif (res >= 0) {\n\t\tastman_send_ack(s, m, \"Success\");\n\t} else {\n\t\tastman_send_error(s, m, \"Failure\");\n\t}\n\n\treturn 0;\n}\n\n/*! \\brief  action_redirect: The redirect manager command */\nstatic int action_redirect(struct mansession *s, const struct message *m)\n{\n\tchar buf[256];\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *name2 = astman_get_header(m, \"ExtraChannel\");\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *exten2 = astman_get_header(m, \"ExtraExten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tconst char *context2 = astman_get_header(m, \"ExtraContext\");\n\tconst char *priority = astman_get_header(m, \"Priority\");\n\tconst char *priority2 = astman_get_header(m, \"ExtraPriority\");\n\tstruct ast_channel *chan;\n\tstruct ast_channel *chan2;\n\tint pi = 0;\n\tint pi2 = 0;\n\tint res;\n\tint chan1_wait = 0;\n\tint chan2_wait = 0;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"Channel not specified\");\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(context)) {\n\t\tastman_send_error(s, m, \"Context not specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(exten)) {\n\t\tastman_send_error(s, m, \"Exten not specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(priority)) {\n\t\tastman_send_error(s, m, \"Priority not specified\");\n\t\treturn 0;\n\t}\n\tif (sscanf(priority, \"%30d\", &pi) != 1) {\n\t\tpi = ast_findlabel_extension(NULL, context, exten, priority, NULL);\n\t}\n\tif (pi < 1) {\n\t\tastman_send_error(s, m, \"Priority is invalid\");\n\t\treturn 0;\n\t}\n\n\tif (!ast_strlen_zero(name2) && !ast_strlen_zero(context2)) {\n\t\t/* We have an ExtraChannel and an ExtraContext */\n\t\tif (ast_strlen_zero(exten2)) {\n\t\t\tastman_send_error(s, m, \"ExtraExten not specified\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (ast_strlen_zero(priority2)) {\n\t\t\tastman_send_error(s, m, \"ExtraPriority not specified\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (sscanf(priority2, \"%30d\", &pi2) != 1) {\n\t\t\tpi2 = ast_findlabel_extension(NULL, context2, exten2, priority2, NULL);\n\t\t}\n\t\tif (pi2 < 1) {\n\t\t\tastman_send_error(s, m, \"ExtraPriority is invalid\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tchan = ast_channel_get_by_name(name);\n\tif (!chan) {\n\t\tsnprintf(buf, sizeof(buf), \"Channel does not exist: %s\", name);\n\t\tastman_send_error(s, m, buf);\n\t\treturn 0;\n\t}\n\tif (ast_check_hangup_locked(chan)) {\n\t\tastman_send_error(s, m, \"Redirect failed, channel not up.\");\n\t\tchan = ast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(name2)) {\n\t\t/* Single channel redirect in progress. */\n\t\tres = ast_async_goto(chan, context, exten, pi);\n\t\tif (!res) {\n\t\t\tastman_send_ack(s, m, \"Redirect successful\");\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Redirect failed\");\n\t\t}\n\t\tchan = ast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\n\tchan2 = ast_channel_get_by_name(name2);\n\tif (!chan2) {\n\t\tsnprintf(buf, sizeof(buf), \"ExtraChannel does not exist: %s\", name2);\n\t\tastman_send_error(s, m, buf);\n\t\tchan = ast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\tif (ast_check_hangup_locked(chan2)) {\n\t\tastman_send_error(s, m, \"Redirect failed, extra channel not up.\");\n\t\tchan2 = ast_channel_unref(chan2);\n\t\tchan = ast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\n\t/* Dual channel redirect in progress. */\n\tast_channel_lock(chan);\n\tif (ast_channel_is_bridged(chan)) {\n\t\tast_set_flag(ast_channel_flags(chan), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);\n\t\tchan1_wait = 1;\n\t}\n\tast_channel_unlock(chan);\n\n\tast_channel_lock(chan2);\n\tif (ast_channel_is_bridged(chan2)) {\n\t\tast_set_flag(ast_channel_flags(chan2), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);\n\t\tchan2_wait = 1;\n\t}\n\tast_channel_unlock(chan2);\n\n\tres = ast_async_goto(chan, context, exten, pi);\n\tif (!res) {\n\t\tif (!ast_strlen_zero(context2)) {\n\t\t\tres = ast_async_goto(chan2, context2, exten2, pi2);\n\t\t} else {\n\t\t\tres = ast_async_goto(chan2, context, exten, pi);\n\t\t}\n\t\tif (!res) {\n\t\t\tastman_send_ack(s, m, \"Dual Redirect successful\");\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Secondary redirect failed\");\n\t\t}\n\t} else {\n\t\tastman_send_error(s, m, \"Redirect failed\");\n\t}\n\n\t/* Release the bridge wait. */\n\tif (chan1_wait) {\n\t\tast_channel_clear_flag(chan, AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);\n\t}\n\tif (chan2_wait) {\n\t\tast_channel_clear_flag(chan2, AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);\n\t}\n\n\tchan2 = ast_channel_unref(chan2);\n\tchan = ast_channel_unref(chan);\n\treturn 0;\n}\n\nstatic int action_blind_transfer(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tstruct ast_channel *chan;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(exten)) {\n\t\tastman_send_error(s, m, \"No extension specified\");\n\t\treturn 0;\n\t}\n\n\tchan = ast_channel_get_by_name(name);\n\tif (!chan) {\n\t\tastman_send_error(s, m, \"Channel specified does not exist\");\n\t\treturn 0;\n\t}\n\n\tif (ast_strlen_zero(context)) {\n\t\tcontext = ast_channel_context(chan);\n\t}\n\n\tswitch (ast_bridge_transfer_blind(1, chan, exten, context, NULL, NULL)) {\n\tcase AST_BRIDGE_TRANSFER_NOT_PERMITTED:\n\t\tastman_send_error(s, m, \"Transfer not permitted\");\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_INVALID:\n\t\tastman_send_error(s, m, \"Transfer invalid\");\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_FAIL:\n\t\tastman_send_error(s, m, \"Transfer failed\");\n\t\tbreak;\n\tcase AST_BRIDGE_TRANSFER_SUCCESS:\n\t\tastman_send_ack(s, m, \"Transfer succeeded\");\n\t\tbreak;\n\t}\n\n\tast_channel_unref(chan);\n\treturn 0;\n}\n\nstatic int action_atxfer(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tstruct ast_channel *chan = NULL;\n\tchar feature_code[AST_FEATURE_MAX_LEN];\n\tconst char *digit;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(exten)) {\n\t\tastman_send_error(s, m, \"No extension specified\");\n\t\treturn 0;\n\t}\n\n\tif (!(chan = ast_channel_get_by_name(name))) {\n\t\tastman_send_error(s, m, \"Channel specified does not exist\");\n\t\treturn 0;\n\t}\n\n\tast_channel_lock(chan);\n\tif (ast_get_builtin_feature(chan, \"atxfer\", feature_code, sizeof(feature_code)) ||\n\t\t\tast_strlen_zero(feature_code)) {\n\t\tast_channel_unlock(chan);\n\t\tastman_send_error(s, m, \"No attended transfer feature code found\");\n\t\tast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\tast_channel_unlock(chan);\n\n\tif (!ast_strlen_zero(context)) {\n\t\tpbx_builtin_setvar_helper(chan, \"TRANSFER_CONTEXT\", context);\n\t}\n\n\tfor (digit = feature_code; *digit; ++digit) {\n\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = *digit };\n\t\tast_queue_frame(chan, &f);\n\t}\n\n\tfor (digit = exten; *digit; ++digit) {\n\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = *digit };\n\t\tast_queue_frame(chan, &f);\n\t}\n\n\tchan = ast_channel_unref(chan);\n\n\tastman_send_ack(s, m, \"Atxfer successfully queued\");\n\n\treturn 0;\n}\n\nstatic int action_cancel_atxfer(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tstruct ast_channel *chan = NULL;\n\tchar *feature_code;\n\tconst char *digit;\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (!(chan = ast_channel_get_by_name(name))) {\n\t\tastman_send_error(s, m, \"Channel specified does not exist\");\n\t\treturn 0;\n\t}\n\n\tast_channel_lock(chan);\n\tfeature_code = ast_get_chan_features_atxferabort(chan);\n\tast_channel_unlock(chan);\n\n\tif (!feature_code) {\n\t\tastman_send_error(s, m, \"No disconnect feature code found\");\n\t\tast_channel_unref(chan);\n\t\treturn 0;\n\t}\n\n\tfor (digit = feature_code; *digit; ++digit) {\n\t\tstruct ast_frame f = { AST_FRAME_DTMF, .subclass.integer = *digit };\n\t\tast_queue_frame(chan, &f);\n\t}\n\tast_free(feature_code);\n\n\tchan = ast_channel_unref(chan);\n\n\tastman_send_ack(s, m, \"CancelAtxfer successfully queued\");\n\n\treturn 0;\n}\n\n\nstatic int check_blacklist(const char *cmd)\n{\n\tchar *cmd_copy, *cur_cmd;\n\tchar *cmd_words[AST_MAX_CMD_LEN] = { NULL, };\n\tint i;\n\n\tcmd_copy = ast_strdupa(cmd);\n\tfor (i = 0; i < MAX_BLACKLIST_CMD_LEN && (cur_cmd = strsep(&cmd_copy, \" \")); i++) {\n\t\tcur_cmd = ast_strip(cur_cmd);\n\t\tif (ast_strlen_zero(cur_cmd)) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd_words[i] = cur_cmd;\n\t}\n\n\tfor (i = 0; i < ARRAY_LEN(command_blacklist); i++) {\n\t\tint j, match = 1;\n\n\t\tfor (j = 0; command_blacklist[i].words[j]; j++) {\n\t\t\tif (ast_strlen_zero(cmd_words[j]) || strcasecmp(cmd_words[j], command_blacklist[i].words[j])) {\n\t\t\t\tmatch = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*! \\brief  Manager command \"command\" - execute CLI command */\nstatic int action_command(struct mansession *s, const struct message *m)\n{\n\tconst char *cmd = astman_get_header(m, \"Command\");\n\tchar *buf = NULL, *final_buf = NULL, *delim, *output;\n\tchar template[] = \"/tmp/ast-ami-XXXXXX\";\t/* template for temporary file */\n\tint fd, ret;\n\toff_t len;\n\n\tif (ast_strlen_zero(cmd)) {\n\t\tastman_send_error(s, m, \"No command provided\");\n\t\treturn 0;\n\t}\n\n\tif (check_blacklist(cmd)) {\n\t\tastman_send_error(s, m, \"Command blacklisted\");\n\t\treturn 0;\n\t}\n\n\tif ((fd = mkstemp(template)) < 0) {\n\t\tastman_send_error_va(s, m, \"Failed to create temporary file: %s\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tret = ast_cli_command(fd, cmd);\n\tastman_send_response_full(s, m, ret == RESULT_SUCCESS ? \"Success\" : \"Error\", MSG_MOREDATA, NULL);\n\n\t/* Determine number of characters available */\n\tif ((len = lseek(fd, 0, SEEK_END)) < 0) {\n\t\tastman_append(s, \"Message: Failed to determine number of characters: %s\\r\\n\", strerror(errno));\n\t\tgoto action_command_cleanup;\n\t}\n\n\t/* This has a potential to overflow the stack.  Hence, use the heap. */\n\tbuf = ast_malloc(len + 1);\n\tfinal_buf = ast_malloc(len + 1);\n\n\tif (!buf || !final_buf) {\n\t\tastman_append(s, \"Message: Memory allocation failure\\r\\n\");\n\t\tgoto action_command_cleanup;\n\t}\n\n\tif (lseek(fd, 0, SEEK_SET) < 0) {\n\t\tastman_append(s, \"Message: Failed to set position on temporary file: %s\\r\\n\", strerror(errno));\n\t\tgoto action_command_cleanup;\n\t}\n\n\tif (read(fd, buf, len) < 0) {\n\t\tastman_append(s, \"Message: Failed to read from temporary file: %s\\r\\n\", strerror(errno));\n\t\tgoto action_command_cleanup;\n\t}\n\n\tbuf[len] = '\\0';\n\tterm_strip(final_buf, buf, len);\n\tfinal_buf[len] = '\\0';\n\n\t/* Trim trailing newline */\n\tif (len && final_buf[len - 1] == '\\n') {\n\t\tfinal_buf[len - 1] = '\\0';\n\t}\n\n\tastman_append(s, \"Message: Command output follows\\r\\n\");\n\n\tdelim = final_buf;\n\twhile ((output = strsep(&delim, \"\\n\"))) {\n\t\tastman_append(s, \"Output: %s\\r\\n\", output);\n\t}\n\naction_command_cleanup:\n\tastman_append(s, \"\\r\\n\");\n\n\tclose(fd);\n\tunlink(template);\n\n\tast_free(buf);\n\tast_free(final_buf);\n\n\treturn 0;\n}\n\n/*! \\brief helper function for originate */\nstruct fast_originate_helper {\n\tint timeout;\n\tstruct ast_format_cap *cap;\t\t\t\t/*!< Codecs used for a call */\n\tint early_media;\n\tAST_DECLARE_STRING_FIELDS (\n\t\tAST_STRING_FIELD(tech);\n\t\t/*! data can contain a channel name, extension number, username, password, etc. */\n\t\tAST_STRING_FIELD(data);\n\t\tAST_STRING_FIELD(app);\n\t\tAST_STRING_FIELD(appdata);\n\t\tAST_STRING_FIELD(cid_name);\n\t\tAST_STRING_FIELD(cid_num);\n\t\tAST_STRING_FIELD(context);\n\t\tAST_STRING_FIELD(exten);\n\t\tAST_STRING_FIELD(idtext);\n\t\tAST_STRING_FIELD(account);\n\t\tAST_STRING_FIELD(channelid);\n\t\tAST_STRING_FIELD(otherchannelid);\n\t);\n\tint priority;\n\tstruct ast_variable *vars;\n};\n\n/*!\n * \\internal\n *\n * \\param doomed Struct to destroy.\n */\nstatic void destroy_fast_originate_helper(struct fast_originate_helper *doomed)\n{\n\tao2_cleanup(doomed->cap);\n\tast_variables_destroy(doomed->vars);\n\tast_string_field_free_memory(doomed);\n\tast_free(doomed);\n}\n\nstatic void *fast_originate(void *data)\n{\n\tstruct fast_originate_helper *in = data;\n\tint res;\n\tint reason = 0;\n\tstruct ast_channel *chan = NULL, *chans[1];\n\tchar requested_channel[AST_CHANNEL_NAME];\n\tstruct ast_assigned_ids assignedids = {\n\t\t.uniqueid = in->channelid,\n\t\t.uniqueid2 = in->otherchannelid\n\t};\n\n\tif (!ast_strlen_zero(in->app)) {\n\t\tres = ast_pbx_outgoing_app(in->tech, in->cap, in->data,\n\t\t\tin->timeout, in->app, in->appdata, &reason,\n\t\t\tAST_OUTGOING_WAIT,\n\t\t\tS_OR(in->cid_num, NULL),\n\t\t\tS_OR(in->cid_name, NULL),\n\t\t\tin->vars, in->account, &chan, &assignedids);\n\t} else {\n\t\tres = ast_pbx_outgoing_exten(in->tech, in->cap, in->data,\n\t\t\tin->timeout, in->context, in->exten, in->priority, &reason,\n\t\t\tAST_OUTGOING_WAIT,\n\t\t\tS_OR(in->cid_num, NULL),\n\t\t\tS_OR(in->cid_name, NULL),\n\t\t\tin->vars, in->account, &chan, in->early_media, &assignedids);\n\t}\n\n\tif (!chan) {\n\t\tsnprintf(requested_channel, AST_CHANNEL_NAME, \"%s/%s\", in->tech, in->data);\n\t}\n\t/* Tell the manager what happened with the channel */\n\tchans[0] = chan;\n\tif (!ast_strlen_zero(in->app)) {\n\t\tast_manager_event_multichan(EVENT_FLAG_CALL, \"OriginateResponse\", chan ? 1 : 0, chans,\n\t\t\t\"%s\"\n\t\t\t\"Response: %s\\r\\n\"\n\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\"Application: %s\\r\\n\"\n\t\t\t\"Data: %s\\r\\n\"\n\t\t\t\"Reason: %d\\r\\n\"\n\t\t\t\"Uniqueid: %s\\r\\n\"\n\t\t\t\"CallerIDNum: %s\\r\\n\"\n\t\t\t\"CallerIDName: %s\\r\\n\",\n\t\t\tin->idtext, res ? \"Failure\" : \"Success\",\n\t\t\tchan ? ast_channel_name(chan) : requested_channel,\n\t\t\tin->app, in->appdata, reason,\n\t\t\tchan ? ast_channel_uniqueid(chan) : S_OR(in->channelid, \"<unknown>\"),\n\t\t\tS_OR(in->cid_num, \"<unknown>\"),\n\t\t\tS_OR(in->cid_name, \"<unknown>\")\n\t\t\t);\n\t} else {\n\t\tast_manager_event_multichan(EVENT_FLAG_CALL, \"OriginateResponse\", chan ? 1 : 0, chans,\n\t\t\t\"%s\"\n\t\t\t\"Response: %s\\r\\n\"\n\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\"Context: %s\\r\\n\"\n\t\t\t\"Exten: %s\\r\\n\"\n\t\t\t\"Reason: %d\\r\\n\"\n\t\t\t\"Uniqueid: %s\\r\\n\"\n\t\t\t\"CallerIDNum: %s\\r\\n\"\n\t\t\t\"CallerIDName: %s\\r\\n\",\n\t\t\tin->idtext, res ? \"Failure\" : \"Success\",\n\t\t\tchan ? ast_channel_name(chan) : requested_channel,\n\t\t\tin->context, in->exten, reason,\n\t\t\tchan ? ast_channel_uniqueid(chan) : S_OR(in->channelid, \"<unknown>\"),\n\t\t\tS_OR(in->cid_num, \"<unknown>\"),\n\t\t\tS_OR(in->cid_name, \"<unknown>\")\n\t\t\t);\n\t}\n\n\t/* Locked and ref'd by ast_pbx_outgoing_exten or ast_pbx_outgoing_app */\n\tif (chan) {\n\t\tast_channel_unlock(chan);\n\t\tast_channel_unref(chan);\n\t}\n\tdestroy_fast_originate_helper(in);\n\treturn NULL;\n}\n\nstatic int aocmessage_get_unit_entry(const struct message *m, struct ast_aoc_unit_entry *entry, unsigned int entry_num)\n{\n\tconst char *unitamount;\n\tconst char *unittype;\n\tstruct ast_str *str = ast_str_alloca(32);\n\n\tmemset(entry, 0, sizeof(*entry));\n\n\tast_str_set(&str, 0, \"UnitAmount(%u)\", entry_num);\n\tunitamount = astman_get_header(m, ast_str_buffer(str));\n\n\tast_str_set(&str, 0, \"UnitType(%u)\", entry_num);\n\tunittype = astman_get_header(m, ast_str_buffer(str));\n\n\tif (!ast_strlen_zero(unitamount) && (sscanf(unitamount, \"%30u\", &entry->amount) == 1)) {\n\t\tentry->valid_amount = 1;\n\t}\n\n\tif (!ast_strlen_zero(unittype) && sscanf(unittype, \"%30u\", &entry->type) == 1) {\n\t\tentry->valid_type = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ast_aoc_decoded *action_aoc_de_message(struct mansession *s, const struct message *m)\n{\n\tconst char *msgtype = astman_get_header(m, \"MsgType\");\n\tconst char *chargetype = astman_get_header(m, \"ChargeType\");\n\tconst char *currencyname = astman_get_header(m, \"CurrencyName\");\n\tconst char *currencyamount = astman_get_header(m, \"CurrencyAmount\");\n\tconst char *mult = astman_get_header(m, \"CurrencyMultiplier\");\n\tconst char *totaltype = astman_get_header(m, \"TotalType\");\n\tconst char *aocbillingid = astman_get_header(m, \"AOCBillingId\");\n\tconst char *association_id= astman_get_header(m, \"ChargingAssociationId\");\n\tconst char *association_num = astman_get_header(m, \"ChargingAssociationNumber\");\n\tconst char *association_plan = astman_get_header(m, \"ChargingAssociationPlan\");\n\n\tenum ast_aoc_type _msgtype;\n\tenum ast_aoc_charge_type _chargetype;\n\tenum ast_aoc_currency_multiplier _mult = AST_AOC_MULT_ONE;\n\tenum ast_aoc_total_type _totaltype = AST_AOC_TOTAL;\n\tenum ast_aoc_billing_id _billingid = AST_AOC_BILLING_NA;\n\tunsigned int _currencyamount = 0;\n\tint _association_id = 0;\n\tunsigned int _association_plan = 0;\n\n\tstruct ast_aoc_decoded *decoded = NULL;\n\n\tif (ast_strlen_zero(chargetype)) {\n\t\tastman_send_error(s, m, \"ChargeType not specified\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\t_msgtype = strcasecmp(msgtype, \"d\") ? AST_AOC_E : AST_AOC_D;\n\n\tif (!strcasecmp(chargetype, \"NA\")) {\n\t\t_chargetype = AST_AOC_CHARGE_NA;\n\t} else if (!strcasecmp(chargetype, \"Free\")) {\n\t\t_chargetype = AST_AOC_CHARGE_FREE;\n\t} else if (!strcasecmp(chargetype, \"Currency\")) {\n\t\t_chargetype = AST_AOC_CHARGE_CURRENCY;\n\t} else if (!strcasecmp(chargetype, \"Unit\")) {\n\t\t_chargetype = AST_AOC_CHARGE_UNIT;\n\t} else {\n\t\tastman_send_error(s, m, \"Invalid ChargeType\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (_chargetype == AST_AOC_CHARGE_CURRENCY) {\n\n\t\tif (ast_strlen_zero(currencyamount) || (sscanf(currencyamount, \"%30u\", &_currencyamount) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid CurrencyAmount, CurrencyAmount is a required when ChargeType is Currency\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (ast_strlen_zero(mult)) {\n\t\t\tastman_send_error(s, m, \"ChargeMultiplier unspecified, ChargeMultiplier is required when ChargeType is Currency.\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t} else if (!strcasecmp(mult, \"onethousandth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONETHOUSANDTH;\n\t\t} else if (!strcasecmp(mult, \"onehundredth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONEHUNDREDTH;\n\t\t} else if (!strcasecmp(mult, \"onetenth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONETENTH;\n\t\t} else if (!strcasecmp(mult, \"one\")) {\n\t\t\t_mult = AST_AOC_MULT_ONE;\n\t\t} else if (!strcasecmp(mult, \"ten\")) {\n\t\t\t_mult = AST_AOC_MULT_TEN;\n\t\t} else if (!strcasecmp(mult, \"hundred\")) {\n\t\t\t_mult = AST_AOC_MULT_HUNDRED;\n\t\t} else if (!strcasecmp(mult, \"thousand\")) {\n\t\t\t_mult = AST_AOC_MULT_THOUSAND;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid ChargeMultiplier\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\t/* create decoded object and start setting values */\n\tif (!(decoded = ast_aoc_create(_msgtype, _chargetype, 0))) {\n\t\t\tastman_send_error(s, m, \"Message Creation Failed\");\n\t\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (_msgtype == AST_AOC_D) {\n\t\tif (!ast_strlen_zero(totaltype) && !strcasecmp(totaltype, \"subtotal\")) {\n\t\t\t_totaltype = AST_AOC_SUBTOTAL;\n\t\t}\n\n\t\tif (ast_strlen_zero(aocbillingid)) {\n\t\t\t/* ignore this is optional */\n\t\t} else if (!strcasecmp(aocbillingid, \"Normal\")) {\n\t\t\t_billingid = AST_AOC_BILLING_NORMAL;\n\t\t} else if (!strcasecmp(aocbillingid, \"ReverseCharge\")) {\n\t\t\t_billingid = AST_AOC_BILLING_REVERSE_CHARGE;\n\t\t} else if (!strcasecmp(aocbillingid, \"CreditCard\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CREDIT_CARD;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid AOC-D AOCBillingId\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t} else {\n\t\tif (ast_strlen_zero(aocbillingid)) {\n\t\t\t/* ignore this is optional */\n\t\t} else if (!strcasecmp(aocbillingid, \"Normal\")) {\n\t\t\t_billingid = AST_AOC_BILLING_NORMAL;\n\t\t} else if (!strcasecmp(aocbillingid, \"ReverseCharge\")) {\n\t\t\t_billingid = AST_AOC_BILLING_REVERSE_CHARGE;\n\t\t} else if (!strcasecmp(aocbillingid, \"CreditCard\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CREDIT_CARD;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallFwdUnconditional\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_FWD_UNCONDITIONAL;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallFwdBusy\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_FWD_BUSY;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallFwdNoReply\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_FWD_NO_REPLY;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallDeflection\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_DEFLECTION;\n\t\t} else if (!strcasecmp(aocbillingid, \"CallTransfer\")) {\n\t\t\t_billingid = AST_AOC_BILLING_CALL_TRANSFER;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid AOC-E AOCBillingId\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (!ast_strlen_zero(association_id) && (sscanf(association_id, \"%30d\", &_association_id) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid ChargingAssociationId\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t\tif (!ast_strlen_zero(association_plan) && (sscanf(association_plan, \"%30u\", &_association_plan) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid ChargingAssociationPlan\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (_association_id) {\n\t\t\tast_aoc_set_association_id(decoded, _association_id);\n\t\t} else if (!ast_strlen_zero(association_num)) {\n\t\t\tast_aoc_set_association_number(decoded, association_num, _association_plan);\n\t\t}\n\t}\n\n\tif (_chargetype == AST_AOC_CHARGE_CURRENCY) {\n\t\tast_aoc_set_currency_info(decoded, _currencyamount, _mult, ast_strlen_zero(currencyname) ? NULL : currencyname);\n\t} else if (_chargetype == AST_AOC_CHARGE_UNIT) {\n\t\tstruct ast_aoc_unit_entry entry;\n\t\tint i;\n\n\t\t/* multiple unit entries are possible, lets get them all */\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tif (aocmessage_get_unit_entry(m, &entry, i)) {\n\t\t\t\tbreak; /* that's the end then */\n\t\t\t}\n\n\t\t\tast_aoc_add_unit_entry(decoded, entry.valid_amount, entry.amount, entry.valid_type, entry.type);\n\t\t}\n\n\t\t/* at least one unit entry is required */\n\t\tif (!i) {\n\t\t\tastman_send_error(s, m, \"Invalid UnitAmount(0), At least one valid unit entry is required when ChargeType is set to Unit\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t}\n\n\tast_aoc_set_billing_id(decoded, _billingid);\n\tast_aoc_set_total_type(decoded, _totaltype);\n\n\treturn decoded;\n\naocmessage_cleanup:\n\n\tast_aoc_destroy_decoded(decoded);\n\treturn NULL;\n}\n\nstatic int action_aoc_s_submessage(struct mansession *s, const struct message *m,\n\t\tstruct ast_aoc_decoded *decoded)\n{\n\tconst char *chargeditem = __astman_get_header(m, \"ChargedItem\", GET_HEADER_LAST_MATCH);\n\tconst char *ratetype = __astman_get_header(m, \"RateType\", GET_HEADER_LAST_MATCH);\n\tconst char *currencyname = __astman_get_header(m, \"CurrencyName\", GET_HEADER_LAST_MATCH);\n\tconst char *currencyamount = __astman_get_header(m, \"CurrencyAmount\", GET_HEADER_LAST_MATCH);\n\tconst char *mult = __astman_get_header(m, \"CurrencyMultiplier\", GET_HEADER_LAST_MATCH);\n\tconst char *time = __astman_get_header(m, \"Time\", GET_HEADER_LAST_MATCH);\n\tconst char *timescale = __astman_get_header(m, \"TimeScale\", GET_HEADER_LAST_MATCH);\n\tconst char *granularity = __astman_get_header(m, \"Granularity\", GET_HEADER_LAST_MATCH);\n\tconst char *granularitytimescale = __astman_get_header(m, \"GranularityTimeScale\", GET_HEADER_LAST_MATCH);\n\tconst char *chargingtype = __astman_get_header(m, \"ChargingType\", GET_HEADER_LAST_MATCH);\n\tconst char *volumeunit = __astman_get_header(m, \"VolumeUnit\", GET_HEADER_LAST_MATCH);\n\tconst char *code = __astman_get_header(m, \"Code\", GET_HEADER_LAST_MATCH);\n\n\tenum ast_aoc_s_charged_item _chargeditem;\n\tenum ast_aoc_s_rate_type _ratetype;\n\tenum ast_aoc_currency_multiplier _mult = AST_AOC_MULT_ONE;\n\tunsigned int _currencyamount = 0;\n\tunsigned int _code;\n\tunsigned int _time = 0;\n\tenum ast_aoc_time_scale _scale = 0;\n\tunsigned int _granularity = 0;\n\tenum ast_aoc_time_scale _granularity_time_scale = AST_AOC_TIME_SCALE_MINUTE;\n\tint _step = 0;\n\tenum ast_aoc_volume_unit _volumeunit = 0;\n\n\tif (ast_strlen_zero(chargeditem)) {\n\t\tastman_send_error(s, m, \"ChargedItem not specified\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (ast_strlen_zero(ratetype)) {\n\t\tastman_send_error(s, m, \"RateType not specified\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (!strcasecmp(chargeditem, \"NA\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_NA;\n\t} else if (!strcasecmp(chargeditem, \"SpecialArrangement\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_SPECIAL_ARRANGEMENT;\n\t} else if (!strcasecmp(chargeditem, \"BasicCommunication\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_BASIC_COMMUNICATION;\n\t} else if (!strcasecmp(chargeditem, \"CallAttempt\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_CALL_ATTEMPT;\n\t} else if (!strcasecmp(chargeditem, \"CallSetup\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_CALL_SETUP;\n\t} else if (!strcasecmp(chargeditem, \"UserUserInfo\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_USER_USER_INFO;\n\t} else if (!strcasecmp(chargeditem, \"SupplementaryService\")) {\n\t\t_chargeditem = AST_AOC_CHARGED_ITEM_SUPPLEMENTARY_SERVICE;\n\t} else {\n\t\tastman_send_error(s, m, \"Invalid ChargedItem\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (!strcasecmp(ratetype, \"NA\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_NA;\n\t} else if (!strcasecmp(ratetype, \"Free\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_FREE;\n\t} else if (!strcasecmp(ratetype, \"FreeFromBeginning\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_FREE_FROM_BEGINNING;\n\t} else if (!strcasecmp(ratetype, \"Duration\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_DURATION;\n\t} else if (!strcasecmp(ratetype, \"Flat\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_FLAT;\n\t} else if (!strcasecmp(ratetype, \"Volume\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_VOLUME;\n\t} else if (!strcasecmp(ratetype, \"SpecialCode\")) {\n\t\t_ratetype = AST_AOC_RATE_TYPE_SPECIAL_CODE;\n\t} else {\n\t\tastman_send_error(s, m, \"Invalid RateType\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (_ratetype > AST_AOC_RATE_TYPE_FREE_FROM_BEGINNING) {\n\t\tif (ast_strlen_zero(currencyamount) || (sscanf(currencyamount, \"%30u\",\n\t\t\t\t&_currencyamount) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid CurrencyAmount, CurrencyAmount is a required when RateType is non-free\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (ast_strlen_zero(mult)) {\n\t\t\tastman_send_error(s, m, \"ChargeMultiplier unspecified, ChargeMultiplier is required when ChargeType is Currency.\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t} else if (!strcasecmp(mult, \"onethousandth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONETHOUSANDTH;\n\t\t} else if (!strcasecmp(mult, \"onehundredth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONEHUNDREDTH;\n\t\t} else if (!strcasecmp(mult, \"onetenth\")) {\n\t\t\t_mult = AST_AOC_MULT_ONETENTH;\n\t\t} else if (!strcasecmp(mult, \"one\")) {\n\t\t\t_mult = AST_AOC_MULT_ONE;\n\t\t} else if (!strcasecmp(mult, \"ten\")) {\n\t\t\t_mult = AST_AOC_MULT_TEN;\n\t\t} else if (!strcasecmp(mult, \"hundred\")) {\n\t\t\t_mult = AST_AOC_MULT_HUNDRED;\n\t\t} else if (!strcasecmp(mult, \"thousand\")) {\n\t\t\t_mult = AST_AOC_MULT_THOUSAND;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid ChargeMultiplier\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\tif (_ratetype == AST_AOC_RATE_TYPE_DURATION) {\n\t\tif (ast_strlen_zero(timescale)) {\n\t\t\tastman_send_error(s, m, \"TimeScale unspecified, TimeScale is required when RateType is Duration.\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t} else if (!strcasecmp(timescale, \"onehundredthsecond\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_HUNDREDTH_SECOND;\n\t\t} else if (!strcasecmp(timescale, \"onetenthsecond\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_TENTH_SECOND;\n\t\t} else if (!strcasecmp(timescale, \"second\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_SECOND;\n\t\t} else if (!strcasecmp(timescale, \"tenseconds\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_TEN_SECOND;\n\t\t} else if (!strcasecmp(timescale, \"minute\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_MINUTE;\n\t\t} else if (!strcasecmp(timescale, \"hour\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_HOUR;\n\t\t} else if (!strcasecmp(timescale, \"day\")) {\n\t\t\t_scale = AST_AOC_TIME_SCALE_DAY;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid TimeScale\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (ast_strlen_zero(time) || (sscanf(time, \"%30u\", &_time) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid Time, Time is a required when RateType is Duration\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\n\t\tif (!ast_strlen_zero(granularity)) {\n\t\t\tif ((sscanf(time, \"%30u\", &_granularity) != 1)) {\n\t\t\t\tastman_send_error(s, m, \"Invalid Granularity\");\n\t\t\t\tgoto aocmessage_cleanup;\n\t\t\t}\n\n\t\t\tif (ast_strlen_zero(granularitytimescale)) {\n\t\t\t\tastman_send_error(s, m, \"Invalid GranularityTimeScale, GranularityTimeScale is a required when Granularity is specified\");\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"onehundredthsecond\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_HUNDREDTH_SECOND;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"onetenthsecond\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_TENTH_SECOND;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"second\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_SECOND;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"tenseconds\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_TEN_SECOND;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"minute\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_MINUTE;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"hour\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_HOUR;\n\t\t\t} else if (!strcasecmp(granularitytimescale, \"day\")) {\n\t\t\t\t_granularity_time_scale = AST_AOC_TIME_SCALE_DAY;\n\t\t\t} else {\n\t\t\t\tastman_send_error(s, m, \"Invalid GranularityTimeScale\");\n\t\t\t\tgoto aocmessage_cleanup;\n\t\t\t}\n\t\t}\n\n\t\tif (ast_strlen_zero(chargingtype) || strcasecmp(chargingtype, \"continuouscharging\") == 0) {\n\t\t\t_step = 0;\n\t\t} else if (strcasecmp(chargingtype, \"stepfunction\") == 0 ) {\n\t\t\t_step = 1;\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Invalid ChargingType\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\tif (_ratetype == AST_AOC_RATE_TYPE_VOLUME) {\n\t\tif (ast_strlen_zero(volumeunit)) {\n\t\t\tastman_send_error(s, m, \"VolumeUnit unspecified, VolumeUnit is required when RateType is Volume.\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t} else if (!strcasecmp(timescale, \"octet\")) {\n\t\t\t_volumeunit = AST_AOC_VOLUME_UNIT_OCTET;\n\t\t} else if (!strcasecmp(timescale, \"segment\")) {\n\t\t\t_volumeunit = AST_AOC_VOLUME_UNIT_SEGMENT;\n\t\t} else if (!strcasecmp(timescale, \"message\")) {\n\t\t\t_volumeunit = AST_AOC_VOLUME_UNIT_MESSAGE;\n\t\t}else {\n\t\t\tastman_send_error(s, m, \"Invalid VolumeUnit\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\tif (_chargeditem == AST_AOC_CHARGED_ITEM_SPECIAL_ARRANGEMENT\n\t\t\t|| _ratetype == AST_AOC_RATE_TYPE_SPECIAL_CODE) {\n\t\tif (ast_strlen_zero(code) || (sscanf(code, \"%30u\", &_code) != 1)) {\n\t\t\tastman_send_error(s, m, \"Invalid Code, Code is a required when ChargedItem is SpecialArrangement and when RateType is SpecialCode\");\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\tif (_chargeditem == AST_AOC_CHARGED_ITEM_SPECIAL_ARRANGEMENT) {\n\t\tast_aoc_s_add_special_arrangement(decoded, _code);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_DURATION) {\n\t\tast_aoc_s_add_rate_duration(decoded, _chargeditem, _currencyamount, _mult,\n\t\t\tcurrencyname, _time, _scale, _granularity, _granularity_time_scale, _step);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_FLAT) {\n\t\tast_aoc_s_add_rate_flat(decoded, _chargeditem, _currencyamount, _mult,\n\t\t\t\tcurrencyname);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_VOLUME) {\n\t\tast_aoc_s_add_rate_volume(decoded, _chargeditem, _volumeunit, _currencyamount,\n\t\t\t_mult, currencyname);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_SPECIAL_CODE) {\n\t\tast_aoc_s_add_rate_special_charge_code(decoded, _chargeditem, _code);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_FREE) {\n\t\tast_aoc_s_add_rate_free(decoded, _chargeditem, 0);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_FREE_FROM_BEGINNING) {\n\t\tast_aoc_s_add_rate_free(decoded, _chargeditem, 1);\n\t} else if (_ratetype == AST_AOC_RATE_TYPE_NA) {\n\t\tast_aoc_s_add_rate_na(decoded, _chargeditem);\n\t}\n\n\treturn 0;\n\naocmessage_cleanup:\n\n\treturn -1;\n}\n\nstatic struct ast_aoc_decoded *action_aoc_s_message(struct mansession *s,\n\t\tconst struct message *m)\n{\n\tstruct ast_aoc_decoded *decoded = NULL;\n\tint hdrlen;\n\tint x;\n\tstatic const char hdr[] = \"ChargedItem:\";\n\tstruct message sm = { 0 };\n\tint rates = 0;\n\n\tif (!(decoded = ast_aoc_create(AST_AOC_S, 0, 0))) {\n\t\tastman_send_error(s, m, \"Message Creation Failed\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\thdrlen = strlen(hdr);\n\tfor (x = 0; x < m->hdrcount; x++) {\n\t\tif (strncasecmp(hdr, m->headers[x], hdrlen) == 0) {\n\t\t\tif (rates > ast_aoc_s_get_count(decoded)) {\n\t\t\t\tif (action_aoc_s_submessage(s, &sm, decoded) == -1) {\n\t\t\t\t\tgoto aocmessage_cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++rates;\n\t\t}\n\n\t\tsm.headers[sm.hdrcount] = m->headers[x];\n\t\t++sm.hdrcount;\n\t}\n\tif (rates > ast_aoc_s_get_count(decoded)) {\n\t\tif (action_aoc_s_submessage(s, &sm, decoded) == -1) {\n\t\t\tgoto aocmessage_cleanup;\n\t\t}\n\t}\n\n\treturn decoded;\n\naocmessage_cleanup:\n\n\tast_aoc_destroy_decoded(decoded);\n\treturn NULL;\n}\n\nstatic int action_aocmessage(struct mansession *s, const struct message *m)\n{\n\tconst char *msgtype = astman_get_header(m, \"MsgType\");\n\tconst char *channel = astman_get_header(m, \"Channel\");\n\tconst char *pchannel = astman_get_header(m, \"ChannelPrefix\");\n\n\tstruct ast_channel *chan = NULL;\n\n\tstruct ast_aoc_decoded *decoded = NULL;\n\tstruct ast_aoc_encoded *encoded = NULL;\n\tsize_t encoded_size = 0;\n\n\tif (ast_strlen_zero(channel) && ast_strlen_zero(pchannel)) {\n\t\tastman_send_error(s, m, \"Channel and PartialChannel are not specified. Specify at least one of these.\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (!(chan = ast_channel_get_by_name(channel)) && !ast_strlen_zero(pchannel)) {\n\t\tchan = ast_channel_get_by_name_prefix(pchannel, strlen(pchannel));\n\t}\n\n\tif (!chan) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (strcasecmp(msgtype, \"d\") == 0 || strcasecmp(msgtype, \"e\") == 0) {\n\t\tdecoded = action_aoc_de_message(s, m);\n\t}\n\telse if (strcasecmp(msgtype, \"s\") == 0) {\n\t\tdecoded = action_aoc_s_message(s, m);\n\t}\n\telse {\n\t\tastman_send_error(s, m, \"Invalid MsgType\");\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif (!decoded) {\n\t\tgoto aocmessage_cleanup;\n\t}\n\n\tif ((encoded = ast_aoc_encode(decoded, &encoded_size, chan))\n\t\t\t&& !ast_indicate_data(chan, AST_CONTROL_AOC, encoded, encoded_size)) {\n\t\tastman_send_ack(s, m, \"AOC Message successfully queued on channel\");\n\t} else {\n\t\tastman_send_error(s, m, \"Error encoding AOC message, could not queue onto channel\");\n\t}\n\naocmessage_cleanup:\n\n\tast_aoc_destroy_decoded(decoded);\n\tast_aoc_destroy_encoded(encoded);\n\n\tif (chan) {\n\t\tchan = ast_channel_unref(chan);\n\t}\n\treturn 0;\n}\n\nstatic int action_originate(struct mansession *s, const struct message *m)\n{\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tconst char *priority = astman_get_header(m, \"Priority\");\n\tconst char *timeout = astman_get_header(m, \"Timeout\");\n\tconst char *callerid = astman_get_header(m, \"CallerID\");\n\tconst char *account = astman_get_header(m, \"Account\");\n\tconst char *app = astman_get_header(m, \"Application\");\n\tconst char *appdata = astman_get_header(m, \"Data\");\n\tconst char *async = astman_get_header(m, \"Async\");\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\tconst char *codecs = astman_get_header(m, \"Codecs\");\n\tconst char *early_media = astman_get_header(m, \"Earlymedia\");\n\tstruct ast_assigned_ids assignedids = {\n\t\t.uniqueid = astman_get_header(m, \"ChannelId\"),\n\t\t.uniqueid2 = astman_get_header(m, \"OtherChannelId\"),\n\t};\n\tstruct ast_variable *vars = NULL;\n\tchar *tech, *data;\n\tchar *l = NULL, *n = NULL;\n\tint pi = 0;\n\tint res;\n\tint to = 30000;\n\tint reason = 0;\n\tchar tmp[256];\n\tchar tmp2[256];\n\tstruct ast_format_cap *cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\tpthread_t th;\n\tint bridge_early = 0;\n\n\tif (!cap) {\n\t\tastman_send_error(s, m, \"Internal Error. Memory allocation failure.\");\n\t\treturn 0;\n\t}\n\tast_format_cap_append(cap, ast_format_slin, 0);\n\n\tif ((assignedids.uniqueid && AST_MAX_PUBLIC_UNIQUEID < strlen(assignedids.uniqueid))\n\t\t|| (assignedids.uniqueid2 && AST_MAX_PUBLIC_UNIQUEID < strlen(assignedids.uniqueid2))) {\n\t\tastman_send_error_va(s, m, \"Uniqueid length exceeds maximum of %d\\n\",\n\t\t\tAST_MAX_PUBLIC_UNIQUEID);\n\t\tres = 0;\n\t\tgoto fast_orig_cleanup;\n\t}\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"Channel not specified\");\n\t\tres = 0;\n\t\tgoto fast_orig_cleanup;\n\t}\n\tif (!ast_strlen_zero(priority) && (sscanf(priority, \"%30d\", &pi) != 1)) {\n\t\tif ((pi = ast_findlabel_extension(NULL, context, exten, priority, NULL)) < 1) {\n\t\t\tastman_send_error(s, m, \"Invalid priority\");\n\t\t\tres = 0;\n\t\t\tgoto fast_orig_cleanup;\n\t\t}\n\t}\n\tif (!ast_strlen_zero(timeout) && (sscanf(timeout, \"%30d\", &to) != 1)) {\n\t\tastman_send_error(s, m, \"Invalid timeout\");\n\t\tres = 0;\n\t\tgoto fast_orig_cleanup;\n\t}\n\tast_copy_string(tmp, name, sizeof(tmp));\n\ttech = tmp;\n\tdata = strchr(tmp, '/');\n\tif (!data) {\n\t\tastman_send_error(s, m, \"Invalid channel\");\n\t\tres = 0;\n\t\tgoto fast_orig_cleanup;\n\t}\n\t*data++ = '\\0';\n\tast_copy_string(tmp2, callerid, sizeof(tmp2));\n\tast_callerid_parse(tmp2, &n, &l);\n\tif (n) {\n\t\tif (ast_strlen_zero(n)) {\n\t\t\tn = NULL;\n\t\t}\n\t}\n\tif (l) {\n\t\tast_shrink_phone_number(l);\n\t\tif (ast_strlen_zero(l)) {\n\t\t\tl = NULL;\n\t\t}\n\t}\n\tif (!ast_strlen_zero(codecs)) {\n\t\tast_format_cap_remove_by_type(cap, AST_MEDIA_TYPE_UNKNOWN);\n\t\tast_format_cap_update_by_allow_disallow(cap, codecs, 1);\n\t}\n\n\tif (!ast_strlen_zero(app) && s->session) {\n\t\tint bad_appdata = 0;\n\t\t/* To run the System application (or anything else that goes to\n\t\t * shell), you must have the additional System privilege */\n\t\tif (!(s->session->writeperm & EVENT_FLAG_SYSTEM)\n\t\t\t&& (\n\t\t\t\tstrcasestr(app, \"system\") ||      /* System(rm -rf /)\n\t\t\t\t                                     TrySystem(rm -rf /)       */\n\t\t\t\tstrcasestr(app, \"exec\") ||        /* Exec(System(rm -rf /))\n\t\t\t\t                                     TryExec(System(rm -rf /)) */\n\t\t\t\tstrcasestr(app, \"agi\") ||         /* AGI(/bin/rm,-rf /)\n\t\t\t\t                                     EAGI(/bin/rm,-rf /)       */\n\t\t\t\tstrcasestr(app, \"mixmonitor\") ||  /* MixMonitor(blah,,rm -rf)  */\n\t\t\t\tstrcasestr(app, \"externalivr\") || /* ExternalIVR(rm -rf)       */\n\t\t\t\tstrcasestr(app, \"originate\") ||   /* Originate(Local/1234,app,System,rm -rf) */\n\t\t\t\t(strstr(appdata, \"SHELL\") && (bad_appdata = 1)) ||       /* NoOp(${SHELL(rm -rf /)})  */\n\t\t\t\t(strstr(appdata, \"EVAL\") && (bad_appdata = 1))           /* NoOp(${EVAL(${some_var_containing_SHELL})}) */\n\t\t\t\t)) {\n\t\t\tchar error_buf[64];\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Originate Access Forbidden: %s\", bad_appdata ? \"Data\" : \"Application\");\n\t\t\tastman_send_error(s, m, error_buf);\n\t\t\tres = 0;\n\t\t\tgoto fast_orig_cleanup;\n\t\t}\n\t}\n\n\t/* Check early if the extension exists. If not, we need to bail out here. */\n\tif (exten && context && pi) {\n\t\tif (! ast_exists_extension(NULL, context, exten, pi, l)) {\n\t\t\t/* The extension does not exist. */\n\t\t\tastman_send_error(s, m, \"Extension does not exist.\");\n\t\t\tres = 0;\n\t\t\tgoto fast_orig_cleanup;\n\t\t}\n\t}\n\n\t/* Allocate requested channel variables */\n\tvars = astman_get_variables(m);\n\tif (s->session && s->session->chanvars) {\n\t\tstruct ast_variable *v, *old;\n\t\told = vars;\n\t\tvars = NULL;\n\n\t\t/* The variables in the AMI originate action are appended at the end of the list, to override any user variables that apply */\n\n\t\tvars = ast_variables_dup(s->session->chanvars);\n\t\tif (old) {\n\t\t\tfor (v = vars; v->next; v = v->next );\n\t\t\tv->next = old;\t/* Append originate variables at end of list */\n\t\t}\n\t}\n\n\t/* For originate async - we can bridge in early media stage */\n\tbridge_early = ast_true(early_media);\n\n\tif (ast_true(async)) {\n\t\tstruct fast_originate_helper *fast;\n\n\t\tfast = ast_calloc(1, sizeof(*fast));\n\t\tif (!fast || ast_string_field_init(fast, 252)) {\n\t\t\tast_free(fast);\n\t\t\tast_variables_destroy(vars);\n\t\t\tres = -1;\n\t\t} else {\n\t\t\tif (!ast_strlen_zero(id)) {\n\t\t\t\tast_string_field_build(fast, idtext, \"ActionID: %s\\r\\n\", id);\n\t\t\t}\n\t\t\tast_string_field_set(fast, tech, tech);\n\t\t\tast_string_field_set(fast, data, data);\n\t\t\tast_string_field_set(fast, app, app);\n\t\t\tast_string_field_set(fast, appdata, appdata);\n\t\t\tast_string_field_set(fast, cid_num, l);\n\t\t\tast_string_field_set(fast, cid_name, n);\n\t\t\tast_string_field_set(fast, context, context);\n\t\t\tast_string_field_set(fast, exten, exten);\n\t\t\tast_string_field_set(fast, account, account);\n\t\t\tast_string_field_set(fast, channelid, assignedids.uniqueid);\n\t\t\tast_string_field_set(fast, otherchannelid, assignedids.uniqueid2);\n\t\t\tfast->vars = vars;\n\t\t\tfast->cap = cap;\n\t\t\tcap = NULL; /* transfered originate helper the capabilities structure.  It is now responsible for freeing it. */\n\t\t\tfast->timeout = to;\n\t\t\tfast->early_media = bridge_early;\n\t\t\tfast->priority = pi;\n\t\t\tif (ast_pthread_create_detached(&th, NULL, fast_originate, fast)) {\n\t\t\t\tdestroy_fast_originate_helper(fast);\n\t\t\t\tres = -1;\n\t\t\t} else {\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\t} else if (!ast_strlen_zero(app)) {\n\t\tres = ast_pbx_outgoing_app(tech, cap, data, to, app, appdata, &reason,\n\t\t\t\tAST_OUTGOING_WAIT, l, n, vars, account, NULL,\n\t\t\t\tassignedids.uniqueid ? &assignedids : NULL);\n\t\tast_variables_destroy(vars);\n\t} else {\n\t\tif (exten && context && pi) {\n\t\t\tres = ast_pbx_outgoing_exten(tech, cap, data, to,\n\t\t\t\t\tcontext, exten, pi, &reason, AST_OUTGOING_WAIT,\n\t\t\t\t\tl, n, vars, account, NULL, bridge_early,\n\t\t\t\t\tassignedids.uniqueid ? &assignedids : NULL);\n\t\t\tast_variables_destroy(vars);\n\t\t} else {\n\t\t\tastman_send_error(s, m, \"Originate with 'Exten' requires 'Context' and 'Priority'\");\n\t\t\tast_variables_destroy(vars);\n\t\t\tres = 0;\n\t\t\tgoto fast_orig_cleanup;\n\t\t}\n\t}\n\tif (!res) {\n\t\tastman_send_ack(s, m, \"Originate successfully queued\");\n\t} else {\n\t\tastman_send_error(s, m, \"Originate failed\");\n\t}\n\nfast_orig_cleanup:\n\tao2_cleanup(cap);\n\treturn 0;\n}\n\nstatic int action_mailboxstatus(struct mansession *s, const struct message *m)\n{\n\tconst char *mailbox = astman_get_header(m, \"Mailbox\");\n\tint ret;\n\n\tif (ast_strlen_zero(mailbox)) {\n\t\tastman_send_error(s, m, \"Mailbox not specified\");\n\t\treturn 0;\n\t}\n\tret = ast_app_has_voicemail(mailbox, NULL);\n\tastman_start_ack(s, m);\n\tastman_append(s, \"Message: Mailbox Status\\r\\n\"\n\t\t\t \"Mailbox: %s\\r\\n\"\n\t\t\t \"Waiting: %d\\r\\n\\r\\n\", mailbox, ret);\n\treturn 0;\n}\n\nstatic int action_mailboxcount(struct mansession *s, const struct message *m)\n{\n\tconst char *mailbox = astman_get_header(m, \"Mailbox\");\n\tint newmsgs = 0, oldmsgs = 0, urgentmsgs = 0;;\n\n\tif (ast_strlen_zero(mailbox)) {\n\t\tastman_send_error(s, m, \"Mailbox not specified\");\n\t\treturn 0;\n\t}\n\tast_app_inboxcount2(mailbox, &urgentmsgs, &newmsgs, &oldmsgs);\n\tastman_start_ack(s, m);\n\tastman_append(s,   \"Message: Mailbox Message Count\\r\\n\"\n\t\t\t   \"Mailbox: %s\\r\\n\"\n\t\t\t   \"UrgMessages: %d\\r\\n\"\n\t\t\t   \"NewMessages: %d\\r\\n\"\n\t\t\t   \"OldMessages: %d\\r\\n\"\n\t\t\t   \"\\r\\n\",\n\t\t\t   mailbox, urgentmsgs, newmsgs, oldmsgs);\n\treturn 0;\n}\n\nstatic int action_extensionstate(struct mansession *s, const struct message *m)\n{\n\tconst char *exten = astman_get_header(m, \"Exten\");\n\tconst char *context = astman_get_header(m, \"Context\");\n\tchar hint[256];\n\tint status;\n\n\tif (ast_strlen_zero(exten)) {\n\t\tastman_send_error(s, m, \"Extension not specified\");\n\t\treturn 0;\n\t}\n\tif (ast_strlen_zero(context)) {\n\t\tcontext = \"default\";\n\t}\n\tstatus = ast_extension_state(NULL, context, exten);\n\thint[0] = '\\0';\n\tast_get_hint(hint, sizeof(hint), NULL, 0, NULL, context, exten);\n\tastman_start_ack(s, m);\n\tastman_append(s, \"Message: Extension Status\\r\\n\"\n\t\t\"Exten: %s\\r\\n\"\n\t\t\"Context: %s\\r\\n\"\n\t\t\"Hint: %s\\r\\n\"\n\t\t\"Status: %d\\r\\n\"\n\t\t\"StatusText: %s\\r\\n\"\n\t\t\"\\r\\n\",\n\t\texten, context, hint, status,\n\t\tast_extension_state2str(status));\n\treturn 0;\n}\n\nstatic int action_presencestate(struct mansession *s, const struct message *m)\n{\n\tconst char *provider = astman_get_header(m, \"Provider\");\n\tenum ast_presence_state state;\n\tchar *subtype;\n\tchar *message;\n\n\tif (ast_strlen_zero(provider)) {\n\t\tastman_send_error(s, m, \"No provider specified\");\n\t\treturn 0;\n\t}\n\n\tstate = ast_presence_state(provider, &subtype, &message);\n\tif (state == AST_PRESENCE_INVALID) {\n\t\tastman_send_error_va(s, m, \"Invalid provider %s or provider in invalid state\", provider);\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\tastman_append(s, \"Message: Presence State\\r\\n\"\n\t                 \"State: %s\\r\\n\", ast_presence_state2str(state));\n\n\tif (!ast_strlen_zero(subtype)) {\n\t\tastman_append(s, \"Subtype: %s\\r\\n\", subtype);\n\t}\n\n\tif (!ast_strlen_zero(message)) {\n\t\t/* XXX The Message header here is deprecated as it\n\t\t * duplicates the action response header 'Message'.\n\t\t * Remove it in the next major revision of AMI.\n\t\t */\n\t\tastman_append(s, \"Message: %s\\r\\n\"\n\t\t                 \"PresenceMessage: %s\\r\\n\",\n\t\t                 message, message);\n\t}\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\nstatic int action_timeout(struct mansession *s, const struct message *m)\n{\n\tstruct ast_channel *c;\n\tconst char *name = astman_get_header(m, \"Channel\");\n\tdouble timeout = atof(astman_get_header(m, \"Timeout\"));\n\tstruct timeval when = { timeout, 0 };\n\n\tif (ast_strlen_zero(name)) {\n\t\tastman_send_error(s, m, \"No channel specified\");\n\t\treturn 0;\n\t}\n\n\tif (!timeout || timeout < 0) {\n\t\tastman_send_error(s, m, \"No timeout specified\");\n\t\treturn 0;\n\t}\n\n\tif (!(c = ast_channel_get_by_name(name))) {\n\t\tastman_send_error(s, m, \"No such channel\");\n\t\treturn 0;\n\t}\n\n\twhen.tv_usec = (timeout - when.tv_sec) * 1000000.0;\n\n\tast_channel_lock(c);\n\tast_channel_setwhentohangup_tv(c, when);\n\tast_channel_unlock(c);\n\tc = ast_channel_unref(c);\n\n\tastman_send_ack(s, m, \"Timeout Set\");\n\n\treturn 0;\n}\n\nstatic int whitefilter_cmp_fn(void *obj, void *arg, void *data, int flags)\n{\n\tregex_t *regex_filter = obj;\n\tconst char *eventdata = arg;\n\tint *result = data;\n\n\tif (!regexec(regex_filter, eventdata, 0, NULL, 0)) {\n\t\t*result = 1;\n\t\treturn (CMP_MATCH | CMP_STOP);\n\t}\n\n\treturn 0;\n}\n\nstatic int blackfilter_cmp_fn(void *obj, void *arg, void *data, int flags)\n{\n\tregex_t *regex_filter = obj;\n\tconst char *eventdata = arg;\n\tint *result = data;\n\n\tif (!regexec(regex_filter, eventdata, 0, NULL, 0)) {\n\t\t*result = 0;\n\t\treturn (CMP_MATCH | CMP_STOP);\n\t}\n\n\t*result = 1;\n\treturn 0;\n}\n\n/*!\n * \\brief Manager command to add an event filter to a manager session\n * \\see For more details look at manager_add_filter\n */\nstatic int action_filter(struct mansession *s, const struct message *m)\n{\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *operation = astman_get_header(m, \"Operation\");\n\tint res;\n\n\tif (!strcasecmp(operation, \"Add\")) {\n\t\tres = manager_add_filter(filter, s->session->whitefilters, s->session->blackfilters);\n\n\t        if (res != FILTER_SUCCESS) {\n\t\t        if (res == FILTER_ALLOC_FAILED) {\n\t\t\t\tastman_send_error(s, m, \"Internal Error. Failed to allocate regex for filter\");\n\t\t                return 0;\n\t\t        } else if (res == FILTER_COMPILE_FAIL) {\n\t\t\t\tastman_send_error(s, m, \"Filter did not compile.  Check the syntax of the filter given.\");\n\t\t                return 0;\n\t\t        } else {\n\t\t\t\tastman_send_error(s, m, \"Internal Error. Failed adding filter.\");\n\t\t                return 0;\n\t                }\n\t\t}\n\n\t\tastman_send_ack(s, m, \"Success\");\n\t\treturn 0;\n\t}\n\n\tastman_send_error(s, m, \"Unknown operation\");\n\treturn 0;\n}\n\n/*!\n * \\brief Add an event filter to a manager session\n *\n * \\param filter_pattern  Filter syntax to add, see below for syntax\n * \\param whitefilters, blackfilters\n *\n * \\return FILTER_ALLOC_FAILED   Memory allocation failure\n * \\return FILTER_COMPILE_FAIL   If the filter did not compile\n * \\return FILTER_SUCCESS        Success\n *\n * Filter will be used to match against each line of a manager event\n * Filter can be any valid regular expression\n * Filter can be a valid regular expression prefixed with !, which will add the filter as a black filter\n *\n * Examples:\n * \\code\n *   filter_pattern = \"Event: Newchannel\"\n *   filter_pattern = \"Event: New.*\"\n *   filter_pattern = \"!Channel: DAHDI.*\"\n * \\endcode\n *\n */\nstatic enum add_filter_result manager_add_filter(const char *filter_pattern, struct ao2_container *whitefilters, struct ao2_container *blackfilters) {\n\tregex_t *new_filter = ao2_t_alloc(sizeof(*new_filter), event_filter_destructor, \"event_filter allocation\");\n\tint is_blackfilter;\n\n\tif (!new_filter) {\n\t\treturn FILTER_ALLOC_FAILED;\n\t}\n\n\tif (filter_pattern[0] == '!') {\n\t\tis_blackfilter = 1;\n\t\tfilter_pattern++;\n\t} else {\n\t\tis_blackfilter = 0;\n\t}\n\n\tif (regcomp(new_filter, filter_pattern, REG_EXTENDED | REG_NOSUB)) {\n\t\tao2_t_ref(new_filter, -1, \"failed to make regex\");\n\t\treturn FILTER_COMPILE_FAIL;\n\t}\n\n\tif (is_blackfilter) {\n\t\tao2_t_link(blackfilters, new_filter, \"link new filter into black user container\");\n\t} else {\n\t\tao2_t_link(whitefilters, new_filter, \"link new filter into white user container\");\n\t}\n\n\tao2_ref(new_filter, -1);\n\n\treturn FILTER_SUCCESS;\n}\n\nstatic int match_filter(struct mansession *s, char *eventdata)\n{\n\tint result = 0;\n\n\tif (manager_debug) {\n\t\tast_verbose(\"<-- Examining AMI event: -->\\n%s\\n\", eventdata);\n\t} else {\n\t\tast_debug(4, \"Examining AMI event:\\n%s\\n\", eventdata);\n\t}\n\tif (!ao2_container_count(s->session->whitefilters) && !ao2_container_count(s->session->blackfilters)) {\n\t\treturn 1; /* no filtering means match all */\n\t} else if (ao2_container_count(s->session->whitefilters) && !ao2_container_count(s->session->blackfilters)) {\n\t\t/* white filters only: implied black all filter processed first, then white filters */\n\t\tao2_t_callback_data(s->session->whitefilters, OBJ_NODATA, whitefilter_cmp_fn, eventdata, &result, \"find filter in session filter container\");\n\t} else if (!ao2_container_count(s->session->whitefilters) && ao2_container_count(s->session->blackfilters)) {\n\t\t/* black filters only: implied white all filter processed first, then black filters */\n\t\tao2_t_callback_data(s->session->blackfilters, OBJ_NODATA, blackfilter_cmp_fn, eventdata, &result, \"find filter in session filter container\");\n\t} else {\n\t\t/* white and black filters: implied black all filter processed first, then white filters, and lastly black filters */\n\t\tao2_t_callback_data(s->session->whitefilters, OBJ_NODATA, whitefilter_cmp_fn, eventdata, &result, \"find filter in session filter container\");\n\t\tif (result) {\n\t\t\tresult = 0;\n\t\t\tao2_t_callback_data(s->session->blackfilters, OBJ_NODATA, blackfilter_cmp_fn, eventdata, &result, \"find filter in session filter container\");\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*!\n * Send any applicable events to the client listening on this socket.\n * Wait only for a finite time on each event, and drop all events whether\n * they are successfully sent or not.\n */\nstatic int process_events(struct mansession *s)\n{\n\tint ret = 0;\n\n\tao2_lock(s->session);\n\tif (s->session->stream != NULL) {\n\t\tstruct eventqent *eqe = s->session->last_ev;\n\n\t\twhile ((eqe = advance_event(eqe))) {\n\t\t\tif (eqe->category == EVENT_FLAG_SHUTDOWN) {\n\t\t\t\tast_debug(3, \"Received CloseSession event\\n\");\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t\tif (!ret && s->session->authenticated &&\n\t\t\t    (s->session->readperm & eqe->category) == eqe->category &&\n\t\t\t    (s->session->send_events & eqe->category) == eqe->category) {\n\t\t\t\t\tif (match_filter(s, eqe->eventdata)) {\n\t\t\t\t\t\tif (send_string(s, eqe->eventdata) < 0 || s->write_error)\n\t\t\t\t\t\t\tret = -1;\t/* don't send more */\n\t\t\t\t\t}\n\t\t\t}\n\t\t\ts->session->last_ev = eqe;\n\t\t}\n\t}\n\tao2_unlock(s->session);\n\treturn ret;\n}\n\nstatic int action_userevent(struct mansession *s, const struct message *m)\n{\n\tconst char *event = astman_get_header(m, \"UserEvent\");\n\tstruct ast_str *body = ast_str_thread_get(&userevent_buf, 16);\n\tint x;\n\n\tast_str_reset(body);\n\n\tfor (x = 0; x < m->hdrcount; x++) {\n\t\tif (strncasecmp(\"UserEvent:\", m->headers[x], strlen(\"UserEvent:\")) &&\n\t\t\t\tstrncasecmp(\"Action:\", m->headers[x], strlen(\"Action:\"))) {\n\t\t\tast_str_append(&body, 0, \"%s\\r\\n\", m->headers[x]);\n\t\t}\n\t}\n\n\tastman_send_ack(s, m, \"Event Sent\");\n\tmanager_event(EVENT_FLAG_USER, \"UserEvent\", \"UserEvent: %s\\r\\n%s\", event, ast_str_buffer(body));\n\treturn 0;\n}\n\n/*! \\brief Show PBX core settings information */\nstatic int action_coresettings(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tchar idText[150];\n\n\tif (!ast_strlen_zero(actionid)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", actionid);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tastman_append(s, \"Response: Success\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"AMIversion: %s\\r\\n\"\n\t\t\t\"AsteriskVersion: %s\\r\\n\"\n\t\t\t\"SystemName: %s\\r\\n\"\n\t\t\t\"CoreMaxCalls: %d\\r\\n\"\n\t\t\t\"CoreMaxLoadAvg: %f\\r\\n\"\n\t\t\t\"CoreRunUser: %s\\r\\n\"\n\t\t\t\"CoreRunGroup: %s\\r\\n\"\n\t\t\t\"CoreMaxFilehandles: %d\\r\\n\"\n\t\t\t\"CoreRealTimeEnabled: %s\\r\\n\"\n\t\t\t\"CoreCDRenabled: %s\\r\\n\"\n\t\t\t\"CoreHTTPenabled: %s\\r\\n\"\n\t\t\t\"SoundsSearchCustomDir: %s\\r\\n\"\n\t\t\t\"\\r\\n\",\n\t\t\tidText,\n\t\t\tAMI_VERSION,\n\t\t\tast_get_version(),\n\t\t\tast_config_AST_SYSTEM_NAME,\n\t\t\tast_option_maxcalls,\n\t\t\tast_option_maxload,\n\t\t\tast_config_AST_RUN_USER,\n\t\t\tast_config_AST_RUN_GROUP,\n\t\t\tast_option_maxfiles,\n\t\t\tAST_CLI_YESNO(ast_realtime_enabled()),\n\t\t\tAST_CLI_YESNO(ast_cdr_is_enabled()),\n\t\t\tAST_CLI_YESNO(ast_webmanager_check_enabled()),\n\t\t\tAST_CLI_YESNO(ast_opt_sounds_search_custom)\n\t\t\t);\n\treturn 0;\n}\n\n/*! \\brief Show PBX core status information */\nstatic int action_corestatus(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tchar idText[150];\n\tchar startuptime[150], startupdate[150];\n\tchar reloadtime[150], reloaddate[150];\n\tstruct ast_tm tm;\n\n\tif (!ast_strlen_zero(actionid)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", actionid);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tast_localtime(&ast_startuptime, &tm, NULL);\n\tast_strftime(startuptime, sizeof(startuptime), \"%H:%M:%S\", &tm);\n\tast_strftime(startupdate, sizeof(startupdate), \"%Y-%m-%d\", &tm);\n\tast_localtime(&ast_lastreloadtime, &tm, NULL);\n\tast_strftime(reloadtime, sizeof(reloadtime), \"%H:%M:%S\", &tm);\n\tast_strftime(reloaddate, sizeof(reloaddate), \"%Y-%m-%d\", &tm);\n\n\tastman_append(s, \"Response: Success\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"CoreStartupDate: %s\\r\\n\"\n\t\t\t\"CoreStartupTime: %s\\r\\n\"\n\t\t\t\"CoreReloadDate: %s\\r\\n\"\n\t\t\t\"CoreReloadTime: %s\\r\\n\"\n\t\t\t\"CoreCurrentCalls: %d\\r\\n\"\n\t\t\t\"\\r\\n\",\n\t\t\tidText,\n\t\t\tstartupdate,\n\t\t\tstartuptime,\n\t\t\treloaddate,\n\t\t\treloadtime,\n\t\t\tast_active_channels()\n\t\t\t);\n\treturn 0;\n}\n\n/*! \\brief Send a reload event */\nstatic int action_reload(struct mansession *s, const struct message *m)\n{\n\tconst char *module = astman_get_header(m, \"Module\");\n\tenum ast_module_reload_result res = ast_module_reload(S_OR(module, NULL));\n\n\tswitch (res) {\n\tcase AST_MODULE_RELOAD_NOT_FOUND:\n\t\tastman_send_error(s, m, \"No such module\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_NOT_IMPLEMENTED:\n\t\tastman_send_error(s, m, \"Module does not support reload\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_ERROR:\n\t\tastman_send_error(s, m, \"An unknown error occurred\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_IN_PROGRESS:\n\t\tastman_send_error(s, m, \"A reload is in progress\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_UNINITIALIZED:\n\t\tastman_send_error(s, m, \"Module not initialized\");\n\t\tbreak;\n\tcase AST_MODULE_RELOAD_QUEUED:\n\tcase AST_MODULE_RELOAD_SUCCESS:\n\t\t/* Treat a queued request as success */\n\t\tastman_send_ack(s, m, \"Module Reloaded\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/*! \\brief  Manager command \"CoreShowChannels\" - List currently defined channels\n *          and some information about them. */\nstatic int action_coreshowchannels(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tchar idText[256];\n\tint numchans = 0;\n\tstruct ao2_container *channels;\n\tstruct ao2_iterator it_chans;\n\tstruct ast_channel_snapshot *cs;\n\n\tif (!ast_strlen_zero(actionid)) {\n\t\tsnprintf(idText, sizeof(idText), \"ActionID: %s\\r\\n\", actionid);\n\t} else {\n\t\tidText[0] = '\\0';\n\t}\n\n\tchannels = ast_channel_cache_by_name();\n\n\tastman_send_listack(s, m, \"Channels will follow\", \"start\");\n\n\tit_chans = ao2_iterator_init(channels, 0);\n\tfor (; (cs = ao2_iterator_next(&it_chans)); ao2_ref(cs, -1)) {\n\t\tstruct ast_str *built = ast_manager_build_channel_state_string_prefix(cs, \"\");\n\t\tchar durbuf[16] = \"\";\n\n\t\tif (!built) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ast_tvzero(cs->base->creationtime)) {\n\t\t\tint duration, durh, durm, durs;\n\n\t\t\tduration = (int)(ast_tvdiff_ms(ast_tvnow(), cs->base->creationtime) / 1000);\n\t\t\tdurh = duration / 3600;\n\t\t\tdurm = (duration % 3600) / 60;\n\t\t\tdurs = duration % 60;\n\t\t\tsnprintf(durbuf, sizeof(durbuf), \"%02d:%02d:%02d\", durh, durm, durs);\n\t\t}\n\n\t\tastman_append(s,\n\t\t\t\"Event: CoreShowChannel\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"%s\"\n\t\t\t\"Application: %s\\r\\n\"\n\t\t\t\"ApplicationData: %s\\r\\n\"\n\t\t\t\"Duration: %s\\r\\n\"\n\t\t\t\"BridgeId: %s\\r\\n\"\n\t\t\t\"\\r\\n\",\n\t\t\tidText,\n\t\t\tast_str_buffer(built),\n\t\t\tcs->dialplan->appl,\n\t\t\tcs->dialplan->data,\n\t\t\tdurbuf,\n\t\t\tcs->bridge->id);\n\n\t\tnumchans++;\n\n\t\tast_free(built);\n\t}\n\tao2_iterator_destroy(&it_chans);\n\n\tastman_send_list_complete(s, m, \"CoreShowChannelsComplete\", numchans);\n\n\tao2_ref(channels, -1);\n\treturn 0;\n}\n\n/*! \\brief Helper function to add a channel name to the vector */\nstatic int coreshowchannelmap_add_to_map(struct ao2_container *c, const char *s)\n{\n\tchar *str;\n\n\tstr = ast_strdup(s);\n\tif (!str) {\n\t\tast_log(LOG_ERROR, \"Unable to append channel to channel map\\n\");\n\t\treturn 1;\n\t}\n\n\t/* If this is a duplicate, it will be ignored */\n\tast_str_container_add(c, str);\n\n\treturn 0;\n}\n\n/*! \\brief Recursive function to get all channels in a bridge. Follow local channels as well */\nstatic int coreshowchannelmap_add_connected_channels(struct ao2_container *channel_map,\n\tstruct ast_channel_snapshot *channel_snapshot, struct ast_bridge_snapshot *bridge_snapshot)\n{\n\tint res = 0;\n\tstruct ao2_iterator iter;\n\tchar *current_channel_uid;\n\n\titer = ao2_iterator_init(bridge_snapshot->channels, 0);\n\twhile ((current_channel_uid = ao2_iterator_next(&iter))) {\n\t\tstruct ast_channel_snapshot *current_channel_snapshot;\n\t\tint add_channel_res;\n\n\t\t/* Don't add the original channel to the list - it's either already in there,\n\t\t * or it's the channel we want the map for */\n\t\tif (!strcmp(current_channel_uid, channel_snapshot->base->uniqueid)) {\n\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcurrent_channel_snapshot = ast_channel_snapshot_get_latest(current_channel_uid);\n\t\tif (!current_channel_snapshot) {\n\t\t\tast_debug(5, \"Unable to get channel snapshot\\n\");\n\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tadd_channel_res = coreshowchannelmap_add_to_map(channel_map, current_channel_snapshot->base->name);\n\t\tif (add_channel_res) {\n\t\t\tres = 1;\n\t\t\tao2_ref(current_channel_snapshot, -1);\n\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If this is a local channel that we haven't seen yet, let's go ahead and find out what else is connected to it */\n\t\tif (ast_begins_with(current_channel_snapshot->base->name, \"Local\")) {\n\t\t\tstruct ast_channel_snapshot *other_local_snapshot;\n\t\t\tstruct ast_bridge_snapshot *other_bridge_snapshot;\n\t\t\tint size = strlen(current_channel_snapshot->base->name);\n\t\t\tchar other_local[size + 1];\n\n\t\t\t/* Don't copy the trailing number - set it to 1 or 2, whichever one it currently is not */\n\t\t\tast_copy_string(other_local, current_channel_snapshot->base->name, size);\n\t\t\tother_local[size - 1] = ast_ends_with(current_channel_snapshot->base->name, \"1\") ? '2' : '1';\n\t\t\tother_local[size] = '\\0';\n\n\t\t\tother_local_snapshot = ast_channel_snapshot_get_latest_by_name(other_local);\n\t\t\tif (!other_local_snapshot) {\n\t\t\t\tast_debug(5, \"Unable to get other local channel snapshot\\n\");\n\t\t\t\tao2_ref(current_channel_snapshot, -1);\n\t\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (coreshowchannelmap_add_to_map(channel_map, other_local_snapshot->base->name)) {\n\t\t\t\tres = 1;\n\t\t\t\tao2_ref(current_channel_snapshot, -1);\n\t\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\t\tao2_ref(other_local_snapshot, -1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tother_bridge_snapshot = ast_bridge_get_snapshot_by_uniqueid(other_local_snapshot->bridge->id);\n\t\t\tif (other_bridge_snapshot) {\n\t\t\t\tres = coreshowchannelmap_add_connected_channels(channel_map, other_local_snapshot, other_bridge_snapshot);\n\t\t\t}\n\n\t\t\tao2_ref(current_channel_snapshot, -1);\n\t\t\tao2_ref(current_channel_uid, -1);\n\t\t\tao2_ref(other_local_snapshot, -1);\n\t\t\tao2_ref(other_bridge_snapshot, -1);\n\n\t\t\tif (res) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tao2_iterator_destroy(&iter);\n\n\treturn res;\n}\n\n/*! \\brief  Manager command \"CoreShowChannelMap\" - Lists all channels connected to\n *          the specified channel. */\nstatic int action_coreshowchannelmap(struct mansession *s, const struct message *m)\n{\n\tconst char *actionid = astman_get_header(m, \"ActionID\");\n\tconst char *channel_name = astman_get_header(m, \"Channel\");\n\tchar *current_channel_name;\n\tchar id_text[256];\n\tint total = 0;\n\tstruct ao2_container *channel_map;\n\tstruct ao2_iterator i;\n\tRAII_VAR(struct ast_bridge_snapshot *, bridge_snapshot, NULL, ao2_cleanup);\n\tRAII_VAR(struct ast_channel_snapshot *, channel_snapshot, NULL, ao2_cleanup);\n\n\tif (!ast_strlen_zero(actionid)) {\n\t\tsnprintf(id_text, sizeof(id_text), \"ActionID: %s\\r\\n\", actionid);\n\t} else {\n\t\tid_text[0] = '\\0';\n\t}\n\n\tif (ast_strlen_zero(channel_name)) {\n\t\tastman_send_error(s, m, \"CoreShowChannelMap requires a channel.\\n\");\n\t\treturn 0;\n\t}\n\n\tchannel_snapshot = ast_channel_snapshot_get_latest_by_name(channel_name);\n\tif (!channel_snapshot) {\n\t\tastman_send_error(s, m, \"Could not get channel snapshot\\n\");\n\t\treturn 0;\n\t}\n\n\tbridge_snapshot = ast_bridge_get_snapshot_by_uniqueid(channel_snapshot->bridge->id);\n\tif (!bridge_snapshot) {\n\t\tastman_send_listack(s, m, \"Channel map will follow\", \"start\");\n\t\tastman_send_list_complete_start(s, m, \"CoreShowChannelMapComplete\", 0);\n\t\tastman_send_list_complete_end(s);\n\t\treturn 0;\n\t}\n\n\tchannel_map = ast_str_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK | AO2_CONTAINER_ALLOC_OPT_DUPS_OBJ_REJECT, 1);\n\tif (!channel_map) {\n\t\tastman_send_error(s, m, \"Could not create channel map\\n\");\n\t\treturn 0;\n\t}\n\n\tastman_send_listack(s, m, \"Channel map will follow\", \"start\");\n\n\tif (coreshowchannelmap_add_connected_channels(channel_map, channel_snapshot, bridge_snapshot)) {\n\t\tastman_send_error(s, m, \"Could not complete channel map\\n\");\n\t\tao2_ref(channel_map, -1);\n\t\treturn 0;\n\t}\n\n\ti = ao2_iterator_init(channel_map, 0);\n\twhile ((current_channel_name = ao2_iterator_next(&i))) {\n\t\tastman_append(s,\n\t\t\t\"Event: CoreShowChannelMap\\r\\n\"\n\t\t\t\"%s\"\n\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\"ConnectedChannel: %s\\r\\n\\n\",\n\t\t\tid_text,\n\t\t\tchannel_name,\n\t\t\tcurrent_channel_name);\n\t\ttotal++;\n\t}\n\tao2_iterator_destroy(&i);\n\n\tao2_ref(channel_map, -1);\n\tastman_send_list_complete_start(s, m, \"CoreShowChannelMapComplete\", total);\n\tastman_send_list_complete_end(s);\n\n\treturn 0;\n}\n\n/*! \\brief  Manager command \"LoggerRotate\" - reloads and rotates the logger in\n *          the same manner as the CLI command 'logger rotate'. */\nstatic int action_loggerrotate(struct mansession *s, const struct message *m)\n{\n\tif (ast_logger_rotate()) {\n\t\tastman_send_error(s, m, \"Failed to reload the logger and rotate log files\");\n\t\treturn 0;\n\t}\n\n\tastman_send_ack(s, m, \"Reloaded the logger and rotated log files\");\n\treturn 0;\n}\n\n/*! \\brief Manager function to check if module is loaded */\nstatic int manager_modulecheck(struct mansession *s, const struct message *m)\n{\n\tconst char *module = astman_get_header(m, \"Module\");\n\tconst char *id = astman_get_header(m, \"ActionID\");\n\n\tast_debug(1, \"**** ModuleCheck .so file %s\\n\", module);\n\tif (!ast_module_check(module)) {\n\t\tastman_send_error(s, m, \"Module not loaded\");\n\t\treturn 0;\n\t}\n\n\tastman_append(s, \"Response: Success\\r\\n\");\n\n\tif (!ast_strlen_zero(id)) {\n\t\tastman_append(s, \"ActionID: %s\\r\\n\", id);\n\t}\n\n#if !defined(LOW_MEMORY)\n\t/* When we switched from subversion to git we lost the ability to\n\t * retrieve the 'ASTERISK_FILE_VERSION' from that file, but we retain\n\t * the response header here for backwards compatibility. */\n\tastman_append(s, \"Version: \\r\\n\");\n#endif\n\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}\n\nstatic int manager_moduleload(struct mansession *s, const struct message *m)\n{\n\tint res;\n\tconst char *module = astman_get_header(m, \"Module\");\n\tconst char *loadtype = astman_get_header(m, \"LoadType\");\n\n\tif (!loadtype || strlen(loadtype) == 0) {\n\t\tastman_send_error(s, m, \"Incomplete ModuleLoad action.\");\n\t}\n\tif ((!module || strlen(module) == 0) && strcasecmp(loadtype, \"reload\") != 0) {\n\t\tastman_send_error(s, m, \"Need module name\");\n\t}\n\n\tif (!strcasecmp(loadtype, \"load\")) {\n\t\tres = ast_load_resource(module);\n\t\tif (res) {\n\t\t\tastman_send_error(s, m, \"Could not load module.\");\n\t\t} else {\n\t\t\tastman_send_ack(s, m, \"Module loaded.\");\n\t\t}\n\t} else if (!strcasecmp(loadtype, \"unload\")) {\n\t\tres = ast_unload_resource(module, AST_FORCE_SOFT);\n\t\tif (res) {\n\t\t\tastman_send_error(s, m, \"Could not unload module.\");\n\t\t} else {\n\t\t\tastman_send_ack(s, m, \"Module unloaded.\");\n\t\t}\n\t} else if (!strcasecmp(loadtype, \"reload\")) {\n\t\t/* TODO: Unify the ack/error messages here with action_reload */\n\t\tif (!ast_strlen_zero(module)) {\n\t\t\tenum ast_module_reload_result reload_res = ast_module_reload(module);\n\n\t\t\tswitch (reload_res) {\n\t\t\tcase AST_MODULE_RELOAD_NOT_FOUND:\n\t\t\t\tastman_send_error(s, m, \"No such module.\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_NOT_IMPLEMENTED:\n\t\t\t\tastman_send_error(s, m, \"Module does not support reload action.\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_ERROR:\n\t\t\t\tastman_send_error(s, m, \"An unknown error occurred\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_IN_PROGRESS:\n\t\t\t\tastman_send_error(s, m, \"A reload is in progress\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_UNINITIALIZED:\n\t\t\t\tastman_send_error(s, m, \"Module not initialized\");\n\t\t\t\tbreak;\n\t\t\tcase AST_MODULE_RELOAD_QUEUED:\n\t\t\tcase AST_MODULE_RELOAD_SUCCESS:\n\t\t\t\t/* Treat a queued request as success */\n\t\t\t\tastman_send_ack(s, m, \"Module reloaded.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tast_module_reload(NULL);\t/* Reload all modules */\n\t\t\tastman_send_ack(s, m, \"All modules reloaded\");\n\t\t}\n\t} else\n\t\tastman_send_error(s, m, \"Incomplete ModuleLoad action.\");\n\treturn 0;\n}\n\nstatic void log_action(const struct message *m, const char *action)\n{\n\tstruct ast_str *buf;\n\tint x;\n\n\tif (!manager_debug) {\n\t\treturn;\n\t}\n\n\tbuf = ast_str_create(256);\n\tif (!buf) {\n\t\treturn;\n\t}\n\n\tfor (x = 0; x < m->hdrcount; ++x) {\n\t\tif (!strncasecmp(m->headers[x], \"Secret\", 6)) {\n\t\t\tast_str_append(&buf, 0, \"Secret: <redacted from logging>\\n\");\n\t\t} else {\n\t\t\tast_str_append(&buf, 0, \"%s\\n\", m->headers[x]);\n\t\t}\n\t}\n\n\tast_verbose(\"<--- Examining AMI action: -->\\n%s\\n\", ast_str_buffer(buf));\n\tast_free(buf);\n}\n\n/*\n * Done with the action handlers here, we start with the code in charge\n * of accepting connections and serving them.\n * accept_thread() forks a new thread for each connection, session_do(),\n * which in turn calls get_input() repeatedly until a full message has\n * been accumulated, and then invokes process_message() to pass it to\n * the appropriate handler.\n */\n\n/*! \\brief\n * Process an AMI message, performing desired action.\n * Return 0 on success, -1 on error that require the session to be destroyed.\n */\nstatic int process_message(struct mansession *s, const struct message *m)\n{\n\tint ret = 0;\n\tstruct manager_action *act_found;\n\tstruct ast_manager_user *user = NULL;\n\tconst char *username;\n\tconst char *action;\n\n\taction = __astman_get_header(m, \"Action\", GET_HEADER_SKIP_EMPTY);\n\tif (ast_strlen_zero(action)) {\n\t\treport_req_bad_format(s, \"NONE\");\n\t\tmansession_lock(s);\n\t\tastman_send_error(s, m, \"Missing action in request\");\n\t\tmansession_unlock(s);\n\t\treturn 0;\n\t}\n\n\tlog_action(m, action);\n\n\tif (ast_shutting_down()) {\n\t\tast_log(LOG_ERROR, \"Unable to process manager action '%s'. Asterisk is shutting down.\\n\", action);\n\t\tmansession_lock(s);\n\t\tastman_send_error(s, m, \"Asterisk is shutting down\");\n\t\tmansession_unlock(s);\n\t\treturn 0;\n\t}\n\n\tif (!s->session->authenticated\n\t\t&& strcasecmp(action, \"Login\")\n\t\t&& strcasecmp(action, \"Logoff\")\n\t\t&& strcasecmp(action, \"Challenge\")) {\n\t\tif (!s->session->authenticated) {\n\t\t\treport_req_not_allowed(s, action);\n\t\t}\n\t\tmansession_lock(s);\n\t\tastman_send_error(s, m, \"Permission denied\");\n\t\tmansession_unlock(s);\n\t\treturn 0;\n\t}\n\n\tif (!s->session->authenticated\n\t\t&& (!strcasecmp(action, \"Login\")\n\t\t\t|| !strcasecmp(action, \"Challenge\"))) {\n\t\tusername = astman_get_header(m, \"Username\");\n\n\t\tif (!ast_strlen_zero(username) && check_manager_session_inuse(username)) {\n\t\t\tAST_RWLIST_WRLOCK(&users);\n\t\t\tuser = get_manager_by_name_locked(username);\n\t\t\tif (user && !user->allowmultiplelogin) {\n\t\t\t\tAST_RWLIST_UNLOCK(&users);\n\t\t\t\treport_session_limit(s);\n\t\t\t\tsleep(1);\n\t\t\t\tmansession_lock(s);\n\t\t\t\tastman_send_error(s, m, \"Login Already In Use\");\n\t\t\t\tmansession_unlock(s);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tAST_RWLIST_UNLOCK(&users);\n\t\t}\n\t}\n\n\tact_found = action_find(action);\n\tif (act_found) {\n\t\t/* Found the requested AMI action. */\n\t\tint acted = 0;\n\n\t\tif ((s->session->writeperm & act_found->authority)\n\t\t\t|| act_found->authority == 0) {\n\t\t\t/* We have the authority to execute the action. */\n\t\t\tret = -1;\n\t\t\tao2_lock(act_found);\n\t\t\tif (act_found->registered && act_found->func) {\n\t\t\t\tstruct ast_module *mod_ref = ast_module_running_ref(act_found->module);\n\n\t\t\t\tao2_unlock(act_found);\n\t\t\t\tif (mod_ref || !act_found->module) {\n\t\t\t\t\tast_debug(1, \"Running action '%s'\\n\", act_found->action);\n\t\t\t\t\tret = act_found->func(s, m);\n\t\t\t\t\tacted = 1;\n\t\t\t\t\tast_module_unref(mod_ref);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tao2_unlock(act_found);\n\t\t\t}\n\t\t}\n\t\tif (!acted) {\n\t\t\t/*\n\t\t\t * We did not execute the action because access was denied, it\n\t\t\t * was no longer registered, or no action was really registered.\n\t\t\t * Complain about it and leave.\n\t\t\t */\n\t\t\treport_req_not_allowed(s, action);\n\t\t\tmansession_lock(s);\n\t\t\tastman_send_error(s, m, \"Permission denied\");\n\t\t\tmansession_unlock(s);\n\t\t}\n\t\tao2_t_ref(act_found, -1, \"done with found action object\");\n\t} else {\n\t\tchar buf[512];\n\n\t\treport_req_bad_format(s, action);\n\t\tsnprintf(buf, sizeof(buf), \"Invalid/unknown command: %s. Use Action: ListCommands to show available commands.\", action);\n\t\tmansession_lock(s);\n\t\tastman_send_error(s, m, buf);\n\t\tmansession_unlock(s);\n\t}\n\tif (ret) {\n\t\treturn ret;\n\t}\n\t/* Once done with our message, deliver any pending events unless the\n\t   requester doesn't want them as part of this response.\n\t*/\n\tif (ast_strlen_zero(astman_get_header(m, \"SuppressEvents\"))) {\n\t\treturn process_events(s);\n\t} else {\n\t\treturn ret;\n\t}\n}\n\n/*!\n * Read one full line (including crlf) from the manager socket.\n * \\note \\verbatim\n * \\r\\n is the only valid terminator for the line.\n * (Note that, later, '\\0' will be considered as the end-of-line marker,\n * so everything between the '\\0' and the '\\r\\n' will not be used).\n * Also note that we assume output to have at least \"maxlen\" space.\n * \\endverbatim\n */\nstatic int get_input(struct mansession *s, char *output)\n{\n\tint res, x;\n\tint maxlen = sizeof(s->session->inbuf) - 1;\n\tchar *src = s->session->inbuf;\n\tint timeout = -1;\n\ttime_t now;\n\n\t/*\n\t * Look for \\r\\n within the buffer. If found, copy to the output\n\t * buffer and return, trimming the \\r\\n (not used afterwards).\n\t */\n\tfor (x = 0; x < s->session->inlen; x++) {\n\t\tint cr;\t/* set if we have \\r */\n\t\tif (src[x] == '\\r' && x+1 < s->session->inlen && src[x + 1] == '\\n') {\n\t\t\tcr = 2;\t/* Found. Update length to include \\r\\n */\n\t\t} else if (src[x] == '\\n') {\n\t\t\tcr = 1;\t/* also accept \\n only */\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(output, src, x);\t/*... but trim \\r\\n */\n\t\toutput[x] = '\\0';\t\t/* terminate the string */\n\t\tx += cr;\t\t\t/* number of bytes used */\n\t\ts->session->inlen -= x;\t\t\t/* remaining size */\n\t\tmemmove(src, src + x, s->session->inlen); /* remove used bytes */\n\t\treturn 1;\n\t}\n\tif (s->session->inlen >= maxlen) {\n\t\t/* no crlf found, and buffer full - sorry, too long for us\n\t\t * keep the last character in case we are in the middle of a CRLF. */\n\t\tast_log(LOG_WARNING, \"Discarding message from %s. Line too long: %.25s...\\n\", ast_sockaddr_stringify_addr(&s->session->addr), src);\n\t\tsrc[0] = src[s->session->inlen - 1];\n\t\ts->session->inlen = 1;\n\t\ts->parsing = MESSAGE_LINE_TOO_LONG;\n\t}\n\tres = 0;\n\twhile (res == 0) {\n\t\t/* calculate a timeout if we are not authenticated */\n\t\tif (!s->session->authenticated) {\n\t\t\tif(time(&now) == -1) {\n\t\t\t\tast_log(LOG_ERROR, \"error executing time(): %s\\n\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\ttimeout = (authtimeout - (now - s->session->authstart)) * 1000;\n\t\t\tif (timeout < 0) {\n\t\t\t\t/* we have timed out */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tast_mutex_lock(&s->session->notify_lock);\n\t\tif (s->session->pending_event) {\n\t\t\ts->session->pending_event = 0;\n\t\t\tast_mutex_unlock(&s->session->notify_lock);\n\t\t\treturn 0;\n\t\t}\n\t\ts->session->waiting_thread = pthread_self();\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\n\t\tres = ast_wait_for_input(ast_iostream_get_fd(s->session->stream), timeout);\n\n\t\tast_mutex_lock(&s->session->notify_lock);\n\t\ts->session->waiting_thread = AST_PTHREADT_NULL;\n\t\tast_mutex_unlock(&s->session->notify_lock);\n\t}\n\tif (res < 0) {\n\t\t/* If we get a signal from some other thread (typically because\n\t\t * there are new events queued), return 0 to notify the caller.\n\t\t */\n\t\tif (errno == EINTR || errno == EAGAIN) {\n\t\t\treturn 0;\n\t\t}\n\t\tast_log(LOG_WARNING, \"poll() returned error: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tao2_lock(s->session);\n\tres = ast_iostream_read(s->session->stream, src + s->session->inlen, maxlen - s->session->inlen);\n\tif (res < 1) {\n\t\tres = -1;\t/* error return */\n\t} else {\n\t\ts->session->inlen += res;\n\t\tsrc[s->session->inlen] = '\\0';\n\t\tres = 0;\n\t}\n\tao2_unlock(s->session);\n\treturn res;\n}\n\n/*!\n * \\internal\n * \\brief Error handling for sending parse errors. This function handles locking, and clearing the\n * parse error flag.\n *\n * \\param s AMI session to process action request.\n * \\param m Message that's in error.\n * \\param error Error message to send.\n */\nstatic void handle_parse_error(struct mansession *s, struct message *m, char *error)\n{\n\tmansession_lock(s);\n\tastman_send_error(s, m, error);\n\ts->parsing = MESSAGE_OKAY;\n\tmansession_unlock(s);\n}\n\n/*!\n * \\internal\n * \\brief Read and process an AMI action request.\n *\n * \\param s AMI session to process action request.\n *\n * \\retval 0 Retain AMI connection for next command.\n * \\retval -1 Drop AMI connection due to logoff or connection error.\n */\nstatic int do_message(struct mansession *s)\n{\n\tstruct message m = { 0 };\n\tchar header_buf[sizeof(s->session->inbuf)] = { '\\0' };\n\tint res;\n\tint hdr_loss;\n\ttime_t now;\n\n\thdr_loss = 0;\n\tfor (;;) {\n\t\t/* Check if any events are pending and do them if needed */\n\t\tif (process_events(s)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tres = get_input(s, header_buf);\n\t\tif (res == 0) {\n\t\t\t/* No input line received. */\n\t\t\tif (!s->session->authenticated) {\n\t\t\t\tif (time(&now) == -1) {\n\t\t\t\t\tast_log(LOG_ERROR, \"error executing time(): %s\\n\", strerror(errno));\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (now - s->session->authstart > authtimeout) {\n\t\t\t\t\tif (displayconnects) {\n\t\t\t\t\t\tast_verb(2, \"Client from %s, failed to authenticate in %d seconds\\n\", ast_sockaddr_stringify_addr(&s->session->addr), authtimeout);\n\t\t\t\t\t}\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (res > 0) {\n\t\t\t/* Input line received. */\n\t\t\tif (ast_strlen_zero(header_buf)) {\n\t\t\t\tif (hdr_loss) {\n\t\t\t\t\tmansession_lock(s);\n\t\t\t\t\tastman_send_error(s, &m, \"Too many lines in message or allocation failure\");\n\t\t\t\t\tmansession_unlock(s);\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tswitch (s->parsing) {\n\t\t\t\t\tcase MESSAGE_OKAY:\n\t\t\t\t\t\tres = process_message(s, &m) ? -1 : 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MESSAGE_LINE_TOO_LONG:\n\t\t\t\t\t\thandle_parse_error(s, &m, \"Failed to parse message: line too long\");\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (m.hdrcount < ARRAY_LEN(m.headers)) {\n\t\t\t\tm.headers[m.hdrcount] = ast_strdup(header_buf);\n\t\t\t\tif (!m.headers[m.hdrcount]) {\n\t\t\t\t\t/* Allocation failure. */\n\t\t\t\t\thdr_loss = 1;\n\t\t\t\t} else {\n\t\t\t\t\t++m.hdrcount;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Too many lines in message. */\n\t\t\t\thdr_loss = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Input error. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tastman_free_headers(&m);\n\n\treturn res;\n}\n\n/*! \\brief The body of the individual manager session.\n * Call get_input() to read one line at a time\n * (or be woken up on new events), collect the lines in a\n * message until found an empty line, and execute the request.\n * In any case, deliver events asynchronously through process_events()\n * (called from here if no line is available, or at the end of\n * process_message(). )\n */\nstatic void *session_do(void *data)\n{\n\tstruct ast_tcptls_session_instance *ser = data;\n\tstruct mansession_session *session;\n\tstruct mansession s = {\n\t\t.tcptls_session = data,\n\t};\n\tint res;\n\tint arg = 1;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tif (ast_atomic_fetchadd_int(&unauth_sessions, +1) >= authlimit) {\n\t\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\t\tgoto done;\n\t}\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tsession = build_mansession(&ser_remote_address_tmp);\n\n\tif (session == NULL) {\n\t\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\t\tgoto done;\n\t}\n\n\t/* here we set TCP_NODELAY on the socket to disable Nagle's algorithm.\n\t * This is necessary to prevent delays (caused by buffering) as we\n\t * write to the socket in bits and pieces. */\n\tif (setsockopt(ast_iostream_get_fd(ser->stream), IPPROTO_TCP, TCP_NODELAY, (char *) &arg, sizeof(arg)) < 0) {\n\t\tast_log(LOG_WARNING, \"Failed to set TCP_NODELAY on manager connection: %s\\n\", strerror(errno));\n\t}\n\tast_iostream_nonblock(ser->stream);\n\n\tao2_lock(session);\n\t/* Hook to the tail of the event queue */\n\tsession->last_ev = grab_last();\n\n\tast_mutex_init(&s.lock);\n\n\t/* these fields duplicate those in the 'ser' structure */\n\tsession->stream = s.stream = ser->stream;\n\tast_sockaddr_copy(&session->addr, &ser_remote_address_tmp);\n\ts.session = session;\n\n\tAST_LIST_HEAD_INIT_NOLOCK(&session->datastores);\n\n\tif(time(&session->authstart) == -1) {\n\t\tast_log(LOG_ERROR, \"error executing time(): %s; disconnecting client\\n\", strerror(errno));\n\t\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\t\tao2_unlock(session);\n\t\tsession_destroy(session);\n\t\tgoto done;\n\t}\n\tao2_unlock(session);\n\n\t/*\n\t * We cannot let the stream exclusively wait for data to arrive.\n\t * We have to wake up the task to send async events.\n\t */\n\tast_iostream_set_exclusive_input(ser->stream, 0);\n\n\tast_iostream_set_timeout_sequence(ser->stream,\n\t\tast_tvnow(), authtimeout * 1000);\n\n\tastman_append(&s, \"Asterisk Call Manager/%s\\r\\n\", AMI_VERSION);\t/* welcome prompt */\n\tfor (;;) {\n\t\tif ((res = do_message(&s)) < 0 || s.write_error) {\n\t\t\tbreak;\n\t\t}\n\t\tif (session->authenticated) {\n\t\t\tast_iostream_set_timeout_disable(ser->stream);\n\t\t}\n\t}\n\t/* session is over, explain why and terminate */\n\tif (session->authenticated) {\n\t\tif (manager_displayconnects(session)) {\n\t\t\tast_verb(2, \"Manager '%s' logged off from %s\\n\", session->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t}\n\t} else {\n\t\tast_atomic_fetchadd_int(&unauth_sessions, -1);\n\t\tif (displayconnects) {\n\t\t\tast_verb(2, \"Connect attempt from '%s' unable to authenticate\\n\", ast_sockaddr_stringify_addr(&session->addr));\n\t\t}\n\t}\n\n\tsession_destroy(session);\n\n\tast_mutex_destroy(&s.lock);\ndone:\n\tao2_ref(ser, -1);\n\tser = NULL;\n\treturn NULL;\n}\n\n/*! \\brief remove at most n_max stale session from the list. */\nstatic int purge_sessions(int n_max)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *session;\n\ttime_t now = time(NULL);\n\tstruct ao2_iterator i;\n\tint purged = 0;\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn 0;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i)) && n_max > 0) {\n\t\tao2_lock(session);\n\t\tif (session->sessiontimeout && (now > session->sessiontimeout) && !session->inuse) {\n\t\t\tif (session->authenticated\n\t\t\t\t&& VERBOSITY_ATLEAST(2)\n\t\t\t\t&& manager_displayconnects(session)) {\n\t\t\t\tast_verb(2, \"HTTP Manager '%s' timed out from %s\\n\",\n\t\t\t\t\tsession->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t\t}\n\t\t\tao2_unlock(session);\n\t\t\tsession_destroy(session);\n\t\t\tn_max--;\n\t\t\tpurged++;\n\t\t} else {\n\t\t\tao2_unlock(session);\n\t\t\tunref_mansession(session);\n\t\t}\n\t}\n\tao2_iterator_destroy(&i);\n\treturn purged;\n}\n\n/*! \\brief\n * events are appended to a queue from where they\n * can be dispatched to clients.\n */\nstatic int append_event(const char *str, int category)\n{\n\tstruct eventqent *tmp = ast_malloc(sizeof(*tmp) + strlen(str));\n\tstatic int seq;\t/* sequence number */\n\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\t/* need to init all fields, because ast_malloc() does not */\n\ttmp->usecount = 0;\n\ttmp->category = category;\n\ttmp->seq = ast_atomic_fetchadd_int(&seq, 1);\n\ttmp->tv = ast_tvnow();\n\tAST_RWLIST_NEXT(tmp, eq_next) = NULL;\n\tstrcpy(tmp->eventdata, str);\n\n\tAST_RWLIST_WRLOCK(&all_events);\n\tAST_RWLIST_INSERT_TAIL(&all_events, tmp, eq_next);\n\tAST_RWLIST_UNLOCK(&all_events);\n\n\treturn 0;\n}\n\nstatic void append_channel_vars(struct ast_str **pbuf, struct ast_channel *chan)\n{\n\tstruct varshead *vars;\n\tstruct ast_var_t *var;\n\n\tvars = ast_channel_get_manager_vars(chan);\n\tif (!vars) {\n\t\treturn;\n\t}\n\n\tAST_LIST_TRAVERSE(vars, var, entries) {\n\t\tast_str_append(pbuf, 0, \"ChanVariable(%s): %s=%s\\r\\n\", ast_channel_name(chan), var->name, var->value);\n\t}\n\tao2_ref(vars, -1);\n}\n\n/* XXX see if can be moved inside the function */\nAST_THREADSTORAGE(manager_event_buf);\n#define MANAGER_EVENT_BUF_INITSIZE   256\n\nstatic int __attribute__((format(printf, 9, 0))) __manager_event_sessions_va(\n\tstruct ao2_container *sessions,\n\tint category,\n\tconst char *event,\n\tint chancount,\n\tstruct ast_channel **chans,\n\tconst char *file,\n\tint line,\n\tconst char *func,\n\tconst char *fmt,\n\tva_list ap)\n{\n\tstruct ast_str *auth = ast_str_alloca(MAX_AUTH_PERM_STRING);\n\tconst char *cat_str;\n\tstruct timeval now;\n\tstruct ast_str *buf;\n\tint i;\n\n\tif (!ast_strlen_zero(manager_disabledevents)) {\n\t\tif (ast_in_delimited_string(event, manager_disabledevents, ',')) {\n\t\t\tast_debug(3, \"AMI Event '%s' is globally disabled, skipping\\n\", event);\n\t\t\t/* Event is globally disabled */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbuf = ast_str_thread_get(&manager_event_buf, MANAGER_EVENT_BUF_INITSIZE);\n\tif (!buf) {\n\t\treturn -1;\n\t}\n\n\tcat_str = authority_to_str(category, &auth);\n\tast_str_set(&buf, 0,\n\t\t\"Event: %s\\r\\n\"\n\t\t\"Privilege: %s\\r\\n\",\n\t\tevent, cat_str);\n\n\tif (timestampevents) {\n\t\tnow = ast_tvnow();\n\t\tast_str_append(&buf, 0,\n\t\t\t\"Timestamp: %ld.%06lu\\r\\n\",\n\t\t\t(long)now.tv_sec, (unsigned long) now.tv_usec);\n\t}\n\tif (manager_debug) {\n\t\tstatic int seq;\n\n\t\tast_str_append(&buf, 0,\n\t\t\t\"SequenceNumber: %d\\r\\n\",\n\t\t\tast_atomic_fetchadd_int(&seq, 1));\n\t\tast_str_append(&buf, 0,\n\t\t\t\"File: %s\\r\\n\"\n\t\t\t\"Line: %d\\r\\n\"\n\t\t\t\"Func: %s\\r\\n\",\n\t\t\tfile, line, func);\n\t}\n\tif (!ast_strlen_zero(ast_config_AST_SYSTEM_NAME)) {\n\t\tast_str_append(&buf, 0,\n\t\t\t\"SystemName: %s\\r\\n\",\n\t\t\tast_config_AST_SYSTEM_NAME);\n\t}\n\n\tast_str_append_va(&buf, 0, fmt, ap);\n\tfor (i = 0; i < chancount; i++) {\n\t\tappend_channel_vars(&buf, chans[i]);\n\t}\n\n\tast_str_append(&buf, 0, \"\\r\\n\");\n\n\tappend_event(ast_str_buffer(buf), category);\n\n\t/* Wake up any sleeping sessions */\n\tif (sessions) {\n\t\tstruct ao2_iterator iter;\n\t\tstruct mansession_session *session;\n\n\t\titer = ao2_iterator_init(sessions, 0);\n\t\twhile ((session = ao2_iterator_next(&iter))) {\n\t\t\tast_mutex_lock(&session->notify_lock);\n\t\t\tif (session->waiting_thread != AST_PTHREADT_NULL) {\n\t\t\t\tpthread_kill(session->waiting_thread, SIGURG);\n\t\t\t} else {\n\t\t\t\t/* We have an event to process, but the mansession is\n\t\t\t\t * not waiting for it. We still need to indicate that there\n\t\t\t\t * is an event waiting so that get_input processes the pending\n\t\t\t\t * event instead of polling.\n\t\t\t\t */\n\t\t\t\tsession->pending_event = 1;\n\t\t\t}\n\t\t\tast_mutex_unlock(&session->notify_lock);\n\t\t\tunref_mansession(session);\n\t\t}\n\t\tao2_iterator_destroy(&iter);\n\t}\n\n\tif (category != EVENT_FLAG_SHUTDOWN && !AST_RWLIST_EMPTY(&manager_hooks)) {\n\t\tstruct manager_custom_hook *hook;\n\n\t\tAST_RWLIST_RDLOCK(&manager_hooks);\n\t\tAST_RWLIST_TRAVERSE(&manager_hooks, hook, list) {\n\t\t\thook->helper(category, event, ast_str_buffer(buf));\n\t\t}\n\t\tAST_RWLIST_UNLOCK(&manager_hooks);\n\t}\n\n\treturn 0;\n}\n\nstatic int __attribute__((format(printf, 9, 0))) __manager_event_sessions(\n\tstruct ao2_container *sessions,\n\tint category,\n\tconst char *event,\n\tint chancount,\n\tstruct ast_channel **chans,\n\tconst char *file,\n\tint line,\n\tconst char *func,\n\tconst char *fmt,\n\t...)\n{\n\tva_list ap;\n\tint res;\n\n\tva_start(ap, fmt);\n\tres = __manager_event_sessions_va(sessions, category, event, chancount, chans,\n\t\tfile, line, func, fmt, ap);\n\tva_end(ap);\n\treturn res;\n}\n\nint __ast_manager_event_multichan(int category, const char *event, int chancount,\n\tstruct ast_channel **chans, const char *file, int line, const char *func,\n\tconst char *fmt, ...)\n{\n\tstruct ao2_container *sessions = ao2_global_obj_ref(mgr_sessions);\n\tva_list ap;\n\tint res;\n\n\tif (!any_manager_listeners(sessions)) {\n\t\t/* Nobody is listening */\n\t\tao2_cleanup(sessions);\n\t\treturn 0;\n\t}\n\n\tva_start(ap, fmt);\n\tres = __manager_event_sessions_va(sessions, category, event, chancount, chans,\n\t\tfile, line, func, fmt, ap);\n\tva_end(ap);\n\tao2_cleanup(sessions);\n\treturn res;\n}\n\n/*! \\brief\n * support functions to register/unregister AMI action handlers,\n */\nint ast_manager_unregister(const char *action)\n{\n\tstruct manager_action *cur;\n\n\tAST_RWLIST_WRLOCK(&actions);\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&actions, cur, list) {\n\t\tif (!strcasecmp(action, cur->action)) {\n\t\t\tAST_RWLIST_REMOVE_CURRENT(list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\tAST_RWLIST_UNLOCK(&actions);\n\n\tif (cur) {\n\t\t/*\n\t\t * We have removed the action object from the container so we\n\t\t * are no longer in a hurry.\n\t\t */\n\t\tao2_lock(cur);\n\t\tcur->registered = 0;\n\t\tao2_unlock(cur);\n\n\t\tao2_t_ref(cur, -1, \"action object removed from list\");\n\t\tast_verb(2, \"Manager unregistered action %s\\n\", action);\n\t}\n\n\treturn 0;\n}\n\nstatic int manager_state_cb(const char *context, const char *exten, struct ast_state_cb_info *info, void *data)\n{\n\t/* Notify managers of change */\n\tchar hint[512];\n\n\thint[0] = '\\0';\n\tast_get_hint(hint, sizeof(hint), NULL, 0, NULL, context, exten);\n\n\tswitch(info->reason) {\n\tcase AST_HINT_UPDATE_DEVICE:\n\t\tmanager_event(EVENT_FLAG_CALL, \"ExtensionStatus\",\n\t\t\t\"Exten: %s\\r\\n\"\n\t\t\t\"Context: %s\\r\\n\"\n\t\t\t\"Hint: %s\\r\\n\"\n\t\t\t\"Status: %d\\r\\n\"\n\t\t\t\"StatusText: %s\\r\\n\",\n\t\t\texten,\n\t\t\tcontext,\n\t\t\thint,\n\t\t\tinfo->exten_state,\n\t\t\tast_extension_state2str(info->exten_state));\n\t\tbreak;\n\tcase AST_HINT_UPDATE_PRESENCE:\n\t\tmanager_event(EVENT_FLAG_CALL, \"PresenceStatus\",\n\t\t\t\"Exten: %s\\r\\n\"\n\t\t\t\"Context: %s\\r\\n\"\n\t\t\t\"Hint: %s\\r\\n\"\n\t\t\t\"Status: %s\\r\\n\"\n\t\t\t\"Subtype: %s\\r\\n\"\n\t\t\t\"Message: %s\\r\\n\",\n\t\t\texten,\n\t\t\tcontext,\n\t\t\thint,\n\t\t\tast_presence_state2str(info->presence_state),\n\t\t\tinfo->presence_subtype,\n\t\t\tinfo->presence_message);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ast_manager_register_struct(struct manager_action *act)\n{\n\tstruct manager_action *cur, *prev = NULL;\n\n\tAST_RWLIST_WRLOCK(&actions);\n\tAST_RWLIST_TRAVERSE(&actions, cur, list) {\n\t\tint ret;\n\n\t\tret = strcasecmp(cur->action, act->action);\n\t\tif (ret == 0) {\n\t\t\tast_log(LOG_WARNING, \"Manager: Action '%s' already registered\\n\", act->action);\n\t\t\tAST_RWLIST_UNLOCK(&actions);\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret > 0) { /* Insert these alphabetically */\n\t\t\tbreak;\n\t\t}\n\t\tprev = cur;\n\t}\n\n\tao2_t_ref(act, +1, \"action object added to list\");\n\tact->registered = 1;\n\tif (prev) {\n\t\tAST_RWLIST_INSERT_AFTER(&actions, prev, act, list);\n\t} else {\n\t\tAST_RWLIST_INSERT_HEAD(&actions, act, list);\n\t}\n\n\tast_verb(2, \"Manager registered action %s\\n\", act->action);\n\n\tAST_RWLIST_UNLOCK(&actions);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Destroy the registered AMI action object.\n *\n * \\param obj Object to destroy.\n */\nstatic void action_destroy(void *obj)\n{\n\tstruct manager_action *doomed = obj;\n\n\tif (doomed->synopsis) {\n\t\t/* The string fields were initialized. */\n\t\tast_string_field_free_memory(doomed);\n\t}\n\tao2_cleanup(doomed->final_response);\n\tao2_cleanup(doomed->list_responses);\n}\n\n/*! \\brief register a new command with manager, including online help. This is\n\tthe preferred way to register a manager command */\nint ast_manager_register2(const char *action, int auth, int (*func)(struct mansession *s, const struct message *m), struct ast_module *module, const char *synopsis, const char *description)\n{\n\tstruct manager_action *cur;\n\n\tcur = ao2_t_alloc(sizeof(*cur), action_destroy, action);\n\tif (!cur) {\n\t\treturn -1;\n\t}\n\tif (ast_string_field_init(cur, 128)) {\n\t\tao2_t_ref(cur, -1, \"action object creation failed\");\n\t\treturn -1;\n\t}\n\n\tcur->action = action;\n\tcur->authority = auth;\n\tcur->func = func;\n\tcur->module = module;\n#ifdef AST_XML_DOCS\n\tif (ast_strlen_zero(synopsis) && ast_strlen_zero(description)) {\n\t\tchar *tmpxml;\n\n\t\ttmpxml = ast_xmldoc_build_synopsis(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, synopsis, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\ttmpxml = ast_xmldoc_build_syntax(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, syntax, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\ttmpxml = ast_xmldoc_build_description(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, description, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\ttmpxml = ast_xmldoc_build_seealso(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, seealso, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\ttmpxml = ast_xmldoc_build_arguments(\"manager\", action, NULL);\n\t\tast_string_field_set(cur, arguments, tmpxml);\n\t\tast_free(tmpxml);\n\n\t\tcur->final_response = ast_xmldoc_build_final_response(\"manager\", action, NULL);\n\t\tcur->list_responses = ast_xmldoc_build_list_responses(\"manager\", action, NULL);\n\n\t\tcur->docsrc = AST_XML_DOC;\n\t} else\n#endif\n\t{\n\t\tast_string_field_set(cur, synopsis, synopsis);\n\t\tast_string_field_set(cur, description, description);\n#ifdef AST_XML_DOCS\n\t\tcur->docsrc = AST_STATIC_DOC;\n#endif\n\t}\n\tif (ast_manager_register_struct(cur)) {\n\t\tao2_t_ref(cur, -1, \"action object registration failed\");\n\t\treturn -1;\n\t}\n\n\tao2_t_ref(cur, -1, \"action object registration successful\");\n\treturn 0;\n}\n/*! @}\n END Doxygen group */\n\n/*\n * The following are support functions for AMI-over-http.\n * The common entry point is generic_http_callback(),\n * which extracts HTTP header and URI fields and reformats\n * them into AMI messages, locates a proper session\n * (using the mansession_id Cookie or GET variable),\n * and calls process_message() as for regular AMI clients.\n * When done, the output (which goes to a temporary file)\n * is read back into a buffer and reformatted as desired,\n * then fed back to the client over the original socket.\n */\n\nenum output_format {\n\tFORMAT_RAW,\n\tFORMAT_HTML,\n\tFORMAT_XML,\n};\n\nstatic const char * const contenttype[] = {\n\t[FORMAT_RAW] = \"plain\",\n\t[FORMAT_HTML] = \"html\",\n\t[FORMAT_XML] =  \"xml\",\n};\n\n/*!\n * locate an http session in the list. The search key (ident) is\n * the value of the mansession_id cookie (0 is not valid and means\n * a session on the AMI socket).\n */\nstatic struct mansession_session *find_session(uint32_t ident, int incinuse)\n{\n\tstruct ao2_container *sessions;\n\tstruct mansession_session *session;\n\tstruct ao2_iterator i;\n\n\tif (ident == 0) {\n\t\treturn NULL;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn NULL;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i))) {\n\t\tao2_lock(session);\n\t\tif (session->managerid == ident && !session->needdestroy) {\n\t\t\tast_atomic_fetchadd_int(&session->inuse, incinuse ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\t\tao2_unlock(session);\n\t\tunref_mansession(session);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn session;\n}\n\n/*!\n * locate an http session in the list.\n * The search keys (nonce) and (username) is value from received\n * \"Authorization\" http header.\n * As well as in find_session() function, the value of the nonce can't be zero.\n * (0 meansi, that the session used for AMI socket connection).\n * Flag (stale) is set, if client used valid, but old, nonce value.\n *\n */\nstatic struct mansession_session *find_session_by_nonce(const char *username, unsigned long nonce, int *stale)\n{\n\tstruct mansession_session *session;\n\tstruct ao2_container *sessions;\n\tstruct ao2_iterator i;\n\n\tif (nonce == 0 || username == NULL || stale == NULL) {\n\t\treturn NULL;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn NULL;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i))) {\n\t\tao2_lock(session);\n\t\tif (!strcasecmp(session->username, username) && session->managerid == nonce) {\n\t\t\t*stale = 0;\n\t\t\tbreak;\n\t\t} else if (!strcasecmp(session->username, username) && session->oldnonce == nonce) {\n\t\t\t*stale = 1;\n\t\t\tbreak;\n\t\t}\n\t\tao2_unlock(session);\n\t\tunref_mansession(session);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn session;\n}\n\nint astman_is_authed(uint32_t ident)\n{\n\tint authed;\n\tstruct mansession_session *session;\n\n\tif (!(session = find_session(ident, 0)))\n\t\treturn 0;\n\n\tauthed = (session->authenticated != 0);\n\n\tao2_unlock(session);\n\tunref_mansession(session);\n\n\treturn authed;\n}\n\nint astman_verify_session_readpermissions(uint32_t ident, int perm)\n{\n\tint result = 0;\n\tstruct mansession_session *session;\n\tstruct ao2_container *sessions;\n\tstruct ao2_iterator i;\n\n\tif (ident == 0) {\n\t\treturn 0;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn 0;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i))) {\n\t\tao2_lock(session);\n\t\tif ((session->managerid == ident) && (session->readperm & perm)) {\n\t\t\tresult = 1;\n\t\t\tao2_unlock(session);\n\t\t\tunref_mansession(session);\n\t\t\tbreak;\n\t\t}\n\t\tao2_unlock(session);\n\t\tunref_mansession(session);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn result;\n}\n\nint astman_verify_session_writepermissions(uint32_t ident, int perm)\n{\n\tint result = 0;\n\tstruct mansession_session *session;\n\tstruct ao2_container *sessions;\n\tstruct ao2_iterator i;\n\n\tif (ident == 0) {\n\t\treturn 0;\n\t}\n\n\tsessions = ao2_global_obj_ref(mgr_sessions);\n\tif (!sessions) {\n\t\treturn 0;\n\t}\n\ti = ao2_iterator_init(sessions, 0);\n\tao2_ref(sessions, -1);\n\twhile ((session = ao2_iterator_next(&i))) {\n\t\tao2_lock(session);\n\t\tif ((session->managerid == ident) && (session->writeperm & perm)) {\n\t\t\tresult = 1;\n\t\t\tao2_unlock(session);\n\t\t\tunref_mansession(session);\n\t\t\tbreak;\n\t\t}\n\t\tao2_unlock(session);\n\t\tunref_mansession(session);\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn result;\n}\n\n/*\n * convert to xml with various conversion:\n * mode & 1\t-> lowercase;\n * mode & 2\t-> replace non-alphanumeric chars with underscore\n */\nstatic void xml_copy_escape(struct ast_str **out, const char *src, int mode)\n{\n\t/* store in a local buffer to avoid calling ast_str_append too often */\n\tchar buf[256];\n\tchar *dst = buf;\n\tconst char *save = src;\n\tint space = sizeof(buf);\n\t/* repeat until done and nothing to flush */\n\tfor ( ; *src || dst != buf ; src++) {\n\t\tif (*src == '\\0' || space < 10) {\t/* flush */\n\t\t\t*dst++ = '\\0';\n\t\t\tast_str_append(out, 0, \"%s\", buf);\n\t\t\tdst = buf;\n\t\t\tspace = sizeof(buf);\n\t\t\tif (*src == '\\0') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (mode & 2) {\n\t\t\tif (save == src && isdigit(*src)) {\n\t\t\t\t/* The first character of an XML attribute cannot be a digit */\n\t\t\t\t*dst++ = '_';\n\t\t\t\t*dst++ = *src;\n\t\t\t\tspace -= 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (!isalnum(*src)) {\n\t\t\t\t/* Replace non-alphanumeric with an underscore */\n\t\t\t\t*dst++ = '_';\n\t\t\t\tspace--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (*src) {\n\t\tcase '<':\n\t\t\tstrcpy(dst, \"&lt;\");\n\t\t\tdst += 4;\n\t\t\tspace -= 4;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tstrcpy(dst, \"&gt;\");\n\t\t\tdst += 4;\n\t\t\tspace -= 4;\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tstrcpy(dst, \"&quot;\");\n\t\t\tdst += 6;\n\t\t\tspace -= 6;\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tstrcpy(dst, \"&apos;\");\n\t\t\tdst += 6;\n\t\t\tspace -= 6;\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tstrcpy(dst, \"&amp;\");\n\t\t\tdst += 5;\n\t\t\tspace -= 5;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*dst++ = mode ? tolower(*src) : *src;\n\t\t\tspace--;\n\t\t}\n\t}\n}\n\nstruct variable_count {\n\tchar *varname;\n\tint count;\n};\n\nstatic int variable_count_hash_fn(const void *vvc, const int flags)\n{\n\tconst struct variable_count *vc = vvc;\n\n\treturn ast_str_hash(vc->varname);\n}\n\nstatic int variable_count_cmp_fn(void *obj, void *vstr, int flags)\n{\n\t/* Due to the simplicity of struct variable_count, it makes no difference\n\t * if you pass in objects or strings, the same operation applies. This is\n\t * due to the fact that the hash occurs on the first element, which means\n\t * the address of both the struct and the string are exactly the same. */\n\tstruct variable_count *vc = obj;\n\tchar *str = vstr;\n\treturn !strcmp(vc->varname, str) ? CMP_MATCH | CMP_STOP : 0;\n}\n\n/*! \\brief Convert the input into XML or HTML.\n * The input is supposed to be a sequence of lines of the form\n *\tName: value\n * optionally followed by a blob of unformatted text.\n * A blank line is a section separator. Basically, this is a\n * mixture of the format of Manager Interface and CLI commands.\n * The unformatted text is considered as a single value of a field\n * named 'Opaque-data'.\n *\n * At the moment the output format is the following (but it may\n * change depending on future requirements so don't count too\n * much on it when writing applications):\n *\n * General: the unformatted text is used as a value of\n * XML output:  to be completed\n *\n * \\verbatim\n *   Each section is within <response type=\"object\" id=\"xxx\">\n *   where xxx is taken from ajaxdest variable or defaults to unknown\n *   Each row is reported as an attribute Name=\"value\" of an XML\n *   entity named from the variable ajaxobjtype, default to \"generic\"\n * \\endverbatim\n *\n * HTML output:\n *   each Name-value pair is output as a single row of a two-column table.\n *   Sections (blank lines in the input) are separated by a <HR>\n *\n */\nstatic void xml_translate(struct ast_str **out, char *in, struct ast_variable *get_vars, enum output_format format)\n{\n\tstruct ast_variable *v;\n\tconst char *dest = NULL;\n\tchar *var, *val;\n\tconst char *objtype = NULL;\n\tint in_data = 0;\t/* parsing data */\n\tint inobj = 0;\n\tint xml = (format == FORMAT_XML);\n\tstruct variable_count *vc = NULL;\n\tstruct ao2_container *vco = NULL;\n\n\tif (xml) {\n\t\t/* dest and objtype need only for XML format */\n\t\tfor (v = get_vars; v; v = v->next) {\n\t\t\tif (!strcasecmp(v->name, \"ajaxdest\")) {\n\t\t\t\tdest = v->value;\n\t\t\t} else if (!strcasecmp(v->name, \"ajaxobjtype\")) {\n\t\t\t\tobjtype = v->value;\n\t\t\t}\n\t\t}\n\t\tif (ast_strlen_zero(dest)) {\n\t\t\tdest = \"unknown\";\n\t\t}\n\t\tif (ast_strlen_zero(objtype)) {\n\t\t\tobjtype = \"generic\";\n\t\t}\n\t}\n\n\t/* we want to stop when we find an empty line */\n\twhile (in && *in) {\n\t\tval = strsep(&in, \"\\r\\n\");\t/* mark start and end of line */\n\t\tif (in && *in == '\\n') {\t/* remove trailing \\n if any */\n\t\t\tin++;\n\t\t}\n\t\tast_trim_blanks(val);\n\t\tast_debug(5, \"inobj %d in_data %d line <%s>\\n\", inobj, in_data, val);\n\t\tif (ast_strlen_zero(val)) {\n\t\t\t/* empty line */\n\t\t\tif (in_data) {\n\t\t\t\t/* close data in Opaque mode */\n\t\t\t\tast_str_append(out, 0, xml ? \"'\" : \"</td></tr>\\n\");\n\t\t\t\tin_data = 0;\n\t\t\t}\n\n\t\t\tif (inobj) {\n\t\t\t\t/* close block */\n\t\t\t\tast_str_append(out, 0, xml ? \" /></response>\\n\" :\n\t\t\t\t\t\"<tr><td colspan=\\\"2\\\"><hr></td></tr>\\r\\n\");\n\t\t\t\tinobj = 0;\n\t\t\t\tao2_ref(vco, -1);\n\t\t\t\tvco = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!inobj) {\n\t\t\t/* start new block */\n\t\t\tif (xml) {\n\t\t\t\tast_str_append(out, 0, \"<response type='object' id='%s'><%s\", dest, objtype);\n\t\t\t}\n\t\t\tvco = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_MUTEX, 0, 37,\n\t\t\t\tvariable_count_hash_fn, NULL, variable_count_cmp_fn);\n\t\t\tinobj = 1;\n\t\t}\n\n\t\tif (in_data) {\n\t\t\t/* Process data field in Opaque mode. This is a\n\t\t\t * followup, so we re-add line feeds. */\n\t\t\tast_str_append(out, 0, xml ? \"\\n\" : \"<br>\\n\");\n\t\t\txml_copy_escape(out, val, 0);   /* data field */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We expect \"Name: value\" line here */\n\t\tvar = strsep(&val, \":\");\n\t\tif (val) {\n\t\t\t/* found the field name */\n\t\t\tval = ast_skip_blanks(val);\n\t\t\tast_trim_blanks(var);\n\t\t} else {\n\t\t\t/* field name not found, switch to opaque mode */\n\t\t\tval = var;\n\t\t\tvar = \"Opaque-data\";\n\t\t\tin_data = 1;\n\t\t}\n\n\n\t\tast_str_append(out, 0, xml ? \" \" : \"<tr><td>\");\n\t\tif ((vc = ao2_find(vco, var, 0))) {\n\t\t\tvc->count++;\n\t\t} else {\n\t\t\t/* Create a new entry for this one */\n\t\t\tvc = ao2_alloc(sizeof(*vc), NULL);\n\t\t\tvc->varname = var;\n\t\t\tvc->count = 1;\n\t\t\tao2_link(vco, vc);\n\t\t}\n\n\t\txml_copy_escape(out, var, xml ? 1 | 2 : 0); /* data name */\n\t\tif (vc->count > 1) {\n\t\t\tast_str_append(out, 0, \"-%d\", vc->count);\n\t\t}\n\t\tao2_ref(vc, -1);\n\t\tast_str_append(out, 0, xml ? \"='\" : \"</td><td>\");\n\t\txml_copy_escape(out, val, 0);\t/* data field */\n\t\tif (!in_data || !*in) {\n\t\t\tast_str_append(out, 0, xml ? \"'\" : \"</td></tr>\\n\");\n\t\t}\n\t}\n\n\tif (inobj) {\n\t\tast_str_append(out, 0, xml ? \" /></response>\\n\" :\n\t\t\t\"<tr><td colspan=\\\"2\\\"><hr></td></tr>\\r\\n\");\n\t\tao2_ref(vco, -1);\n\t}\n}\n\nstatic void close_mansession_file(struct mansession *s)\n{\n\tif (s->stream) {\n\t\tast_iostream_close(s->stream);\n\t\ts->stream = NULL;\n\t} else {\n\t\tast_log(LOG_ERROR, \"Attempted to close file/file descriptor on mansession without a valid file or file descriptor.\\n\");\n\t}\n}\n\nstatic void process_output(struct mansession *s, struct ast_str **out, struct ast_variable *params, enum output_format format)\n{\n\tchar *buf;\n\toff_t l;\n\tint fd;\n\n\tif (!s->stream)\n\t\treturn;\n\n\t/* Ensure buffer is NULL-terminated */\n\tast_iostream_write(s->stream, \"\", 1);\n\n\tfd = ast_iostream_get_fd(s->stream);\n\n\tl = lseek(fd, 0, SEEK_CUR);\n\tif (l > 0) {\n\t\tif (MAP_FAILED == (buf = mmap(NULL, l, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0))) {\n\t\t\tast_log(LOG_WARNING, \"mmap failed.  Manager output was not processed\\n\");\n\t\t} else {\n\t\t\tif (format == FORMAT_XML || format == FORMAT_HTML) {\n\t\t\t\txml_translate(out, buf, params, format);\n\t\t\t} else {\n\t\t\t\tast_str_append(out, 0, \"%s\", buf);\n\t\t\t}\n\t\t\tmunmap(buf, l);\n\t\t}\n\t} else if (format == FORMAT_XML || format == FORMAT_HTML) {\n\t\txml_translate(out, \"\", params, format);\n\t}\n\n\tclose_mansession_file(s);\n}\n\nstatic int generic_http_callback(struct ast_tcptls_session_instance *ser,\n\t\t\t\t\t     enum ast_http_method method,\n\t\t\t\t\t     enum output_format format,\n\t\t\t\t\t     const struct ast_sockaddr *remote_address, const char *uri,\n\t\t\t\t\t     struct ast_variable *get_params,\n\t\t\t\t\t     struct ast_variable *headers)\n{\n\tstruct mansession s = { .session = NULL, .tcptls_session = ser };\n\tstruct mansession_session *session = NULL;\n\tuint32_t ident;\n\tint fd;\n\tint blastaway = 0;\n\tstruct ast_variable *params = get_params;\n\tchar template[] = \"/tmp/ast-http-XXXXXX\";\t/* template for temporary file */\n\tstruct ast_str *http_header = NULL, *out = NULL;\n\tstruct message m = { 0 };\n\n\tif (method != AST_HTTP_GET && method != AST_HTTP_HEAD && method != AST_HTTP_POST) {\n\t\tast_http_error(ser, 501, \"Not Implemented\", \"Attempt to use unimplemented / unsupported method\");\n\t\treturn 0;\n\t}\n\n\tident = ast_http_manid_from_vars(headers);\n\n\tif (!(session = find_session(ident, 1))) {\n\n\t\t/**/\n\t\t/* Create new session.\n\t\t * While it is not in the list we don't need any locking\n\t\t */\n\t\tif (!(session = build_mansession(remote_address))) {\n\t\t\tast_http_request_close_on_completion(ser);\n\t\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (out of memory)\");\n\t\t\treturn 0;\n\t\t}\n\t\tao2_lock(session);\n\t\tsession->send_events = 0;\n\t\tsession->inuse = 1;\n\t\t/*!\n\t\t * \\note There is approximately a 1 in 1.8E19 chance that the following\n\t\t * calculation will produce 0, which is an invalid ID, but due to the\n\t\t * properties of the rand() function (and the constancy of s), that\n\t\t * won't happen twice in a row.\n\t\t */\n\t\twhile ((session->managerid = ast_random() ^ (unsigned long) session) == 0) {\n\t\t}\n\t\tsession->last_ev = grab_last();\n\t\tAST_LIST_HEAD_INIT_NOLOCK(&session->datastores);\n\t}\n\tao2_unlock(session);\n\n\thttp_header = ast_str_create(128);\n\tout = ast_str_create(2048);\n\n\tast_mutex_init(&s.lock);\n\n\tif (http_header == NULL || out == NULL) {\n\t\tast_http_request_close_on_completion(ser);\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (ast_str_create() out of memory)\");\n\t\tgoto generic_callback_out;\n\t}\n\n\ts.session = session;\n\tfd = mkstemp(template);\t/* create a temporary file for command output */\n\tunlink(template);\n\tif (fd <= -1) {\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (mkstemp failed)\");\n\t\tgoto generic_callback_out;\n\t}\n\ts.stream = ast_iostream_from_fd(&fd);\n\tif (!s.stream) {\n\t\tast_log(LOG_WARNING, \"HTTP Manager, fdopen failed: %s!\\n\", strerror(errno));\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (fdopen failed)\");\n\t\tclose(fd);\n\t\tgoto generic_callback_out;\n\t}\n\n\tif (method == AST_HTTP_POST) {\n\t\tparams = ast_http_get_post_vars(ser, headers);\n\t\tif (!params) {\n\t\t\tswitch (errno) {\n\t\t\tcase EFBIG:\n\t\t\t\tast_http_error(ser, 413, \"Request Entity Too Large\", \"Body too large\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto generic_callback_out;\n\t\t\tcase ENOMEM:\n\t\t\t\tast_http_request_close_on_completion(ser);\n\t\t\t\tast_http_error(ser, 500, \"Server Error\", \"Out of memory\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto generic_callback_out;\n\t\t\tcase EIO:\n\t\t\t\tast_http_error(ser, 400, \"Bad Request\", \"Error parsing request body\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto generic_callback_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tastman_append_headers(&m, params);\n\n\tif (process_message(&s, &m)) {\n\t\tif (session->authenticated) {\n\t\t\tif (manager_displayconnects(session)) {\n\t\t\t\tast_verb(2, \"HTTP Manager '%s' logged off from %s\\n\", session->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t\t}\n\t\t} else {\n\t\t\tif (displayconnects) {\n\t\t\t\tast_verb(2, \"HTTP Connect attempt from '%s' unable to authenticate\\n\", ast_sockaddr_stringify_addr(&session->addr));\n\t\t\t}\n\t\t}\n\t\tsession->needdestroy = 1;\n\t}\n\n\tastman_free_headers(&m);\n\n\tast_str_append(&http_header, 0,\n\t\t\"Content-type: text/%s\\r\\n\"\n\t\t\"Set-Cookie: mansession_id=\\\"%08x\\\"; Version=1; Max-Age=%d\\r\\n\"\n\t\t\"Pragma: SuppressEvents\\r\\n\",\n\t\tcontenttype[format],\n\t\tsession->managerid, httptimeout);\n\n\tif (format == FORMAT_XML) {\n\t\tast_str_append(&out, 0, \"<ajax-response>\\n\");\n\t} else if (format == FORMAT_HTML) {\n\t\t/*\n\t\t * When handling AMI-over-HTTP in HTML format, we provide a simple form for\n\t\t * debugging purposes. This HTML code should not be here, we\n\t\t * should read from some config file...\n\t\t */\n\n#define ROW_FMT\t\"<tr><td colspan=\\\"2\\\" bgcolor=\\\"#f1f1ff\\\">%s</td></tr>\\r\\n\"\n#define TEST_STRING \\\n\t\"<form action=\\\"manager\\\" method=\\\"post\\\">\\n\\\n\tAction: <select name=\\\"action\\\">\\n\\\n\t\t<option value=\\\"\\\">-----&gt;</option>\\n\\\n\t\t<option value=\\\"login\\\">login</option>\\n\\\n\t\t<option value=\\\"command\\\">Command</option>\\n\\\n\t\t<option value=\\\"waitevent\\\">waitevent</option>\\n\\\n\t\t<option value=\\\"listcommands\\\">listcommands</option>\\n\\\n\t</select>\\n\\\n\tor <input name=\\\"action\\\"><br/>\\n\\\n\tCLI Command <input name=\\\"command\\\"><br>\\n\\\n\tuser <input name=\\\"username\\\"> pass <input type=\\\"password\\\" name=\\\"secret\\\"><br>\\n\\\n\t<input type=\\\"submit\\\">\\n</form>\\n\"\n\n\t\tast_str_append(&out, 0, \"<title>Asterisk&trade; Manager Interface</title>\");\n\t\tast_str_append(&out, 0, \"<body bgcolor=\\\"#ffffff\\\"><table align=center bgcolor=\\\"#f1f1f1\\\" width=\\\"500\\\">\\r\\n\");\n\t\tast_str_append(&out, 0, ROW_FMT, \"<h1>Manager Tester</h1>\");\n\t\tast_str_append(&out, 0, ROW_FMT, TEST_STRING);\n\t}\n\n\tprocess_output(&s, &out, params, format);\n\n\tif (format == FORMAT_XML) {\n\t\tast_str_append(&out, 0, \"</ajax-response>\\n\");\n\t} else if (format == FORMAT_HTML) {\n\t\tast_str_append(&out, 0, \"</table></body>\\r\\n\");\n\t}\n\n\tao2_lock(session);\n\t/* Reset HTTP timeout.  If we're not authenticated, keep it extremely short */\n\tsession->sessiontimeout = time(NULL) + ((session->authenticated || httptimeout < 5) ? httptimeout : 5);\n\n\tif (session->needdestroy) {\n\t\tif (session->inuse == 1) {\n\t\t\tast_debug(1, \"Need destroy, doing it now!\\n\");\n\t\t\tblastaway = 1;\n\t\t} else {\n\t\t\tast_debug(1, \"Need destroy, but can't do it yet!\\n\");\n\t\t\tast_mutex_lock(&session->notify_lock);\n\t\t\tif (session->waiting_thread != AST_PTHREADT_NULL) {\n\t\t\t\tpthread_kill(session->waiting_thread, SIGURG);\n\t\t\t}\n\t\t\tast_mutex_unlock(&session->notify_lock);\n\t\t\tsession->inuse--;\n\t\t}\n\t} else {\n\t\tsession->inuse--;\n\t}\n\tao2_unlock(session);\n\n\tast_http_send(ser, method, 200, NULL, http_header, out, 0, 0);\n\thttp_header = NULL;\n\tout = NULL;\n\ngeneric_callback_out:\n\tast_mutex_destroy(&s.lock);\n\n\t/* Clear resource */\n\n\tif (method == AST_HTTP_POST && params) {\n\t\tast_variables_destroy(params);\n\t}\n\tast_free(http_header);\n\tast_free(out);\n\n\tif (session) {\n\t\tif (blastaway) {\n\t\t\tsession_destroy(session);\n\t\t} else {\n\t\t\tif (session->stream) {\n\t\t\t\tast_iostream_close(session->stream);\n\t\t\t\tsession->stream = NULL;\n\t\t\t}\n\t\t\tunref_mansession(session);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int auth_http_callback(struct ast_tcptls_session_instance *ser,\n\t\t\t\t\t     enum ast_http_method method,\n\t\t\t\t\t     enum output_format format,\n\t\t\t\t\t     const struct ast_sockaddr *remote_address, const char *uri,\n\t\t\t\t\t     struct ast_variable *get_params,\n\t\t\t\t\t     struct ast_variable *headers)\n{\n\tstruct mansession_session *session = NULL;\n\tstruct mansession s = { .session = NULL, .tcptls_session = ser };\n\tstruct ast_variable *v, *params = get_params;\n\tchar template[] = \"/tmp/ast-http-XXXXXX\";\t/* template for temporary file */\n\tstruct ast_str *http_header = NULL, *out = NULL;\n\tsize_t result_size;\n\tstruct message m = { 0 };\n\tint fd;\n\n\ttime_t time_now = time(NULL);\n\tunsigned long nonce = 0, nc;\n\tstruct ast_http_digest d = { NULL, };\n\tstruct ast_manager_user *user = NULL;\n\tint stale = 0;\n\tchar resp_hash[256]=\"\";\n\t/* Cache for user data */\n\tchar u_username[80];\n\tint u_readperm;\n\tint u_writeperm;\n\tint u_writetimeout;\n\tint u_displayconnects;\n\n\tif (method != AST_HTTP_GET && method != AST_HTTP_HEAD && method != AST_HTTP_POST) {\n\t\tast_http_error(ser, 501, \"Not Implemented\", \"Attempt to use unimplemented / unsupported method\");\n\t\treturn 0;\n\t}\n\n\t/* Find \"Authorization: \" header */\n\tfor (v = headers; v; v = v->next) {\n\t\tif (!strcasecmp(v->name, \"Authorization\")) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!v || ast_strlen_zero(v->value)) {\n\t\tgoto out_401; /* Authorization Header not present - send auth request */\n\t}\n\n\t/* Digest found - parse */\n\tif (ast_string_field_init(&d, 128)) {\n\t\tast_http_request_close_on_completion(ser);\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (out of memory)\");\n\t\treturn 0;\n\t}\n\n\tif (ast_parse_digest(v->value, &d, 0, 1)) {\n\t\t/* Error in Digest - send new one */\n\t\tnonce = 0;\n\t\tgoto out_401;\n\t}\n\tif (sscanf(d.nonce, \"%30lx\", &nonce) != 1) {\n\t\tast_log(LOG_WARNING, \"Received incorrect nonce in Digest <%s>\\n\", d.nonce);\n\t\tnonce = 0;\n\t\tgoto out_401;\n\t}\n\n\tAST_RWLIST_WRLOCK(&users);\n\tuser = get_manager_by_name_locked(d.username);\n\tif(!user) {\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\tast_log(LOG_NOTICE, \"%s tried to authenticate with nonexistent user '%s'\\n\", ast_sockaddr_stringify_addr(&session->addr), d.username);\n\t\tnonce = 0;\n\t\tgoto out_401;\n\t}\n\n\t/* --- We have User for this auth, now check ACL */\n\tif (user->acl && !ast_apply_acl(user->acl, remote_address, \"Manager User ACL:\")) {\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\tast_log(LOG_NOTICE, \"%s failed to pass IP ACL as '%s'\\n\", ast_sockaddr_stringify_addr(&session->addr), d.username);\n\t\tast_http_request_close_on_completion(ser);\n\t\tast_http_error(ser, 403, \"Permission denied\", \"Permission denied\");\n\t\treturn 0;\n\t}\n\n\t/* --- We have auth, so check it */\n\n\t/* compute the expected response to compare with what we received */\n\t{\n\t\tchar *a2;\n\t\t/* ast_md5_hash outputs 32 characters plus NULL terminator. */\n\t\tchar a2_hash[33];\n\t\tchar resp[256];\n\n\t\t/* XXX Now request method are hardcoded in A2 */\n\t\tif (ast_asprintf(&a2, \"%s:%s\", ast_get_http_method(method), d.uri) < 0) {\n\t\t\tAST_RWLIST_UNLOCK(&users);\n\t\t\tast_http_request_close_on_completion(ser);\n\t\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (out of memory)\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tast_md5_hash(a2_hash, a2);\n\t\tast_free(a2);\n\n\t\tif (d.qop) {\n\t\t\t/* RFC 2617 */\n\t\t\tsnprintf(resp, sizeof(resp), \"%s:%08lx:%s:%s:auth:%s\", user->a1_hash, nonce, d.nc, d.cnonce, a2_hash);\n\t\t}  else {\n\t\t\t/* RFC 2069 */\n\t\t\tsnprintf(resp, sizeof(resp), \"%s:%08lx:%s\", user->a1_hash, nonce, a2_hash);\n\t\t}\n\t\tast_md5_hash(resp_hash, resp);\n\t}\n\n\tif (strncasecmp(d.response, resp_hash, strlen(resp_hash))) {\n\t\t/* Something was wrong, so give the client to try with a new challenge */\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\tnonce = 0;\n\t\tgoto out_401;\n\t}\n\n\t/*\n\t * User are pass Digest authentication.\n\t * Now, cache the user data and unlock user list.\n\t */\n\tast_copy_string(u_username, user->username, sizeof(u_username));\n\tu_readperm = user->readperm;\n\tu_writeperm = user->writeperm;\n\tu_displayconnects = user->displayconnects;\n\tu_writetimeout = user->writetimeout;\n\tAST_RWLIST_UNLOCK(&users);\n\n\tif (!(session = find_session_by_nonce(d.username, nonce, &stale))) {\n\t\t/*\n\t\t * Create new session.\n\t\t * While it is not in the list we don't need any locking\n\t\t */\n\t\tif (!(session = build_mansession(remote_address))) {\n\t\t\tast_http_request_close_on_completion(ser);\n\t\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (out of memory)\");\n\t\t\treturn 0;\n\t\t}\n\t\tao2_lock(session);\n\n\t\tast_copy_string(session->username, u_username, sizeof(session->username));\n\t\tsession->managerid = nonce;\n\t\tsession->last_ev = grab_last();\n\t\tAST_LIST_HEAD_INIT_NOLOCK(&session->datastores);\n\n\t\tsession->readperm = u_readperm;\n\t\tsession->writeperm = u_writeperm;\n\t\tsession->writetimeout = u_writetimeout;\n\n\t\tif (u_displayconnects) {\n\t\t\tast_verb(2, \"HTTP Manager '%s' logged in from %s\\n\", session->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t}\n\t\tsession->noncetime = session->sessionstart = time_now;\n\t\tsession->authenticated = 1;\n\t} else if (stale) {\n\t\t/*\n\t\t * Session found, but nonce is stale.\n\t\t *\n\t\t * This could be because an old request (w/old nonce) arrived.\n\t\t *\n\t\t * This may be as the result of http proxy usage (separate delay or\n\t\t * multipath) or in a situation where a page was refreshed too quickly\n\t\t * (seen in Firefox).\n\t\t *\n\t\t * In this situation, we repeat the 401 auth with the current nonce\n\t\t * value.\n\t\t */\n\t\tnonce = session->managerid;\n\t\tao2_unlock(session);\n\t\tstale = 1;\n\t\tgoto out_401;\n\t} else {\n\t\tsscanf(d.nc, \"%30lx\", &nc);\n\t\tif (session->nc >= nc || ((time_now - session->noncetime) > 62) ) {\n\t\t\t/*\n\t\t\t * Nonce time expired (> 2 minutes) or something wrong with nonce\n\t\t\t * counter.\n\t\t\t *\n\t\t\t * Create new nonce key and resend Digest auth request. Old nonce\n\t\t\t * is saved for stale checking...\n\t\t\t */\n\t\t\tsession->nc = 0; /* Reset nonce counter */\n\t\t\tsession->oldnonce = session->managerid;\n\t\t\tnonce = session->managerid = ast_random();\n\t\t\tsession->noncetime = time_now;\n\t\t\tao2_unlock(session);\n\t\t\tstale = 1;\n\t\t\tgoto out_401;\n\t\t} else {\n\t\t\tsession->nc = nc; /* All OK, save nonce counter */\n\t\t}\n\t}\n\n\n\t/* Reset session timeout. */\n\tsession->sessiontimeout = time(NULL) + (httptimeout > 5 ? httptimeout : 5);\n\tao2_unlock(session);\n\n\tast_mutex_init(&s.lock);\n\ts.session = session;\n\tfd = mkstemp(template);\t/* create a temporary file for command output */\n\tunlink(template);\n\tif (fd <= -1) {\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (mkstemp failed)\");\n\t\tgoto auth_callback_out;\n\t}\n\ts.stream = ast_iostream_from_fd(&fd);\n\tif (!s.stream) {\n\t\tast_log(LOG_WARNING, \"HTTP Manager, fdopen failed: %s!\\n\", strerror(errno));\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (fdopen failed)\");\n\t\tclose(fd);\n\t\tgoto auth_callback_out;\n\t}\n\n\tif (method == AST_HTTP_POST) {\n\t\tparams = ast_http_get_post_vars(ser, headers);\n\t\tif (!params) {\n\t\t\tswitch (errno) {\n\t\t\tcase EFBIG:\n\t\t\t\tast_http_error(ser, 413, \"Request Entity Too Large\", \"Body too large\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto auth_callback_out;\n\t\t\tcase ENOMEM:\n\t\t\t\tast_http_request_close_on_completion(ser);\n\t\t\t\tast_http_error(ser, 500, \"Server Error\", \"Out of memory\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto auth_callback_out;\n\t\t\tcase EIO:\n\t\t\t\tast_http_error(ser, 400, \"Bad Request\", \"Error parsing request body\");\n\t\t\t\tclose_mansession_file(&s);\n\t\t\t\tgoto auth_callback_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tastman_append_headers(&m, params);\n\n\tif (process_message(&s, &m)) {\n\t\tif (u_displayconnects) {\n\t\t\tast_verb(2, \"HTTP Manager '%s' logged off from %s\\n\", session->username, ast_sockaddr_stringify_addr(&session->addr));\n\t\t}\n\n\t\tsession->needdestroy = 1;\n\t}\n\n\tastman_free_headers(&m);\n\n\tresult_size = lseek(ast_iostream_get_fd(s.stream), 0, SEEK_CUR); /* Calculate approx. size of result */\n\n\thttp_header = ast_str_create(80);\n\tout = ast_str_create(result_size * 2 + 512);\n\tif (http_header == NULL || out == NULL) {\n\t\tast_http_request_close_on_completion(ser);\n\t\tast_http_error(ser, 500, \"Server Error\", \"Internal Server Error (ast_str_create() out of memory)\");\n\t\tclose_mansession_file(&s);\n\t\tgoto auth_callback_out;\n\t}\n\n\tast_str_append(&http_header, 0, \"Content-type: text/%s\\r\\n\", contenttype[format]);\n\n\tif (format == FORMAT_XML) {\n\t\tast_str_append(&out, 0, \"<ajax-response>\\n\");\n\t} else if (format == FORMAT_HTML) {\n\t\tast_str_append(&out, 0,\n\t\t\"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\r\\n\"\n\t\t\"<html><head>\\r\\n\"\n\t\t\"<title>Asterisk&trade; Manager Interface</title>\\r\\n\"\n\t\t\"</head><body style=\\\"background-color: #ffffff;\\\">\\r\\n\"\n\t\t\"<form method=\\\"POST\\\">\\r\\n\"\n\t\t\"<table align=\\\"center\\\" style=\\\"background-color: #f1f1f1;\\\" width=\\\"500\\\">\\r\\n\"\n\t\t\"<tr><th colspan=\\\"2\\\" style=\\\"background-color: #f1f1ff;\\\"><h1>Manager Tester</h1></th></tr>\\r\\n\"\n\t\t\"<tr><th colspan=\\\"2\\\" style=\\\"background-color: #f1f1ff;\\\">Action: <input name=\\\"action\\\" /> Cmd: <input name=\\\"command\\\" /><br>\"\n\t\t\"<input type=\\\"submit\\\" value=\\\"Send request\\\" /></th></tr>\\r\\n\");\n\t}\n\n\tprocess_output(&s, &out, params, format);\n\n\tif (format == FORMAT_XML) {\n\t\tast_str_append(&out, 0, \"</ajax-response>\\n\");\n\t} else if (format == FORMAT_HTML) {\n\t\tast_str_append(&out, 0, \"</table></form></body></html>\\r\\n\");\n\t}\n\n\tast_http_send(ser, method, 200, NULL, http_header, out, 0, 0);\n\thttp_header = NULL;\n\tout = NULL;\n\nauth_callback_out:\n\tast_mutex_destroy(&s.lock);\n\n\t/* Clear resources and unlock manager session */\n\tif (method == AST_HTTP_POST && params) {\n\t\tast_variables_destroy(params);\n\t}\n\n\tast_free(http_header);\n\tast_free(out);\n\n\tao2_lock(session);\n\tif (session->stream) {\n\t\tast_iostream_close(session->stream);\n\t\tsession->stream = NULL;\n\t}\n\tao2_unlock(session);\n\n\tif (session->needdestroy) {\n\t\tast_debug(1, \"Need destroy, doing it now!\\n\");\n\t\tsession_destroy(session);\n\t}\n\tast_string_field_free_memory(&d);\n\treturn 0;\n\nout_401:\n\tif (!nonce) {\n\t\tnonce = ast_random();\n\t}\n\n\tast_http_auth(ser, global_realm, nonce, nonce, stale, NULL);\n\tast_string_field_free_memory(&d);\n\treturn 0;\n}\n\nstatic int manager_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params,  struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = generic_http_callback(ser, method, FORMAT_HTML, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic int mxml_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params, struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = generic_http_callback(ser, method, FORMAT_XML, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic int rawman_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params, struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = generic_http_callback(ser, method, FORMAT_RAW, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic struct ast_http_uri rawmanuri = {\n\t.description = \"Raw HTTP Manager Event Interface\",\n\t.uri = \"rawman\",\n\t.callback = rawman_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\nstatic struct ast_http_uri manageruri = {\n\t.description = \"HTML Manager Event Interface\",\n\t.uri = \"manager\",\n\t.callback = manager_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\nstatic struct ast_http_uri managerxmluri = {\n\t.description = \"XML Manager Event Interface\",\n\t.uri = \"mxml\",\n\t.callback = mxml_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\n\n/* Callback with Digest authentication */\nstatic int auth_manager_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params,  struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = auth_http_callback(ser, method, FORMAT_HTML, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic int auth_mxml_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params, struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = auth_http_callback(ser, method, FORMAT_XML, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic int auth_rawman_http_callback(struct ast_tcptls_session_instance *ser, const struct ast_http_uri *urih, const char *uri, enum ast_http_method method, struct ast_variable *get_params, struct ast_variable *headers)\n{\n\tint retval;\n\tstruct ast_sockaddr ser_remote_address_tmp;\n\n\tast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);\n\tretval = auth_http_callback(ser, method, FORMAT_RAW, &ser_remote_address_tmp, uri, get_params, headers);\n\tast_sockaddr_copy(&ser->remote_address, &ser_remote_address_tmp);\n\treturn retval;\n}\n\nstatic struct ast_http_uri arawmanuri = {\n\t.description = \"Raw HTTP Manager Event Interface w/Digest authentication\",\n\t.uri = \"arawman\",\n\t.has_subtree = 0,\n\t.callback = auth_rawman_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\nstatic struct ast_http_uri amanageruri = {\n\t.description = \"HTML Manager Event Interface w/Digest authentication\",\n\t.uri = \"amanager\",\n\t.has_subtree = 0,\n\t.callback = auth_manager_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\nstatic struct ast_http_uri amanagerxmluri = {\n\t.description = \"XML Manager Event Interface w/Digest authentication\",\n\t.uri = \"amxml\",\n\t.has_subtree = 0,\n\t.callback = auth_mxml_http_callback,\n\t.data = NULL,\n\t.key = __FILE__,\n};\n\n/*! \\brief Get number of logged in sessions for a login name */\nstatic int get_manager_sessions_cb(void *obj, void *arg, void *data, int flags)\n{\n\tstruct mansession_session *session = obj;\n\tconst char *login = (char *)arg;\n\tint *no_sessions = data;\n\n\tif (strcasecmp(session->username, login) == 0) {\n\t\t(*no_sessions)++;\n\t}\n\n\treturn 0;\n}\n\n\n/*! \\brief  ${AMI_CLIENT()} Dialplan function - reads manager client data */\nstatic int function_amiclient(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)\n{\n\tstruct ast_manager_user *user = NULL;\n\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(name);\n\t\tAST_APP_ARG(param);\n\t);\n\n\n\tif (ast_strlen_zero(data) ) {\n\t\tast_log(LOG_WARNING, \"AMI_CLIENT() requires two arguments: AMI_CLIENT(<name>[,<arg>])\\n\");\n\t\treturn -1;\n\t}\n\tAST_STANDARD_APP_ARGS(args, data);\n\targs.name = ast_strip(args.name);\n\targs.param = ast_strip(args.param);\n\n\tAST_RWLIST_RDLOCK(&users);\n\tif (!(user = get_manager_by_name_locked(args.name))) {\n\t\tAST_RWLIST_UNLOCK(&users);\n\t\tast_log(LOG_ERROR, \"There's no manager user called : \\\"%s\\\"\\n\", args.name);\n\t\treturn -1;\n\t}\n\tAST_RWLIST_UNLOCK(&users);\n\n\tif (!strcasecmp(args.param, \"sessions\")) {\n\t\tint no_sessions = 0;\n\t\tstruct ao2_container *sessions;\n\n\t\tsessions = ao2_global_obj_ref(mgr_sessions);\n\t\tif (sessions) {\n\t\t\tao2_callback_data(sessions, 0, get_manager_sessions_cb, /*login name*/ data, &no_sessions);\n\t\t\tao2_ref(sessions, -1);\n\t\t}\n\t\tsnprintf(buf, len, \"%d\", no_sessions);\n\t} else {\n\t\tast_log(LOG_ERROR, \"Invalid arguments provided to function AMI_CLIENT: %s\\n\", args.param);\n\t\treturn -1;\n\n\t}\n\n\treturn 0;\n}\n\n\n/*! \\brief description of AMI_CLIENT dialplan function */\nstatic struct ast_custom_function managerclient_function = {\n\t.name = \"AMI_CLIENT\",\n\t.read = function_amiclient,\n\t.read_max = 12,\n};\n\nstatic int webregged = 0;\n\n/*! \\brief cleanup code called at each iteration of server_root,\n * guaranteed to happen every 5 seconds at most\n */\nstatic void purge_old_stuff(void *data)\n{\n\tstruct ast_tcptls_session_args *ser = data;\n\t/* purge_sessions will return the number of sessions actually purged,\n\t * up to a maximum of it's arguments, purge one at a time, keeping a\n\t * purge interval of 1ms as long as we purged a session, otherwise\n\t * revert to a purge check every 5s\n\t */\n\tif (purge_sessions(1) == 1) {\n\t\tser->poll_timeout = 1;\n\t} else {\n\t\tser->poll_timeout = 5000;\n\t}\n\tpurge_events();\n}\n\nstatic struct ast_tls_config ami_tls_cfg;\nstatic struct ast_tcptls_session_args ami_desc = {\n\t.accept_fd = -1,\n\t.master = AST_PTHREADT_NULL,\n\t.tls_cfg = NULL,\n\t.poll_timeout = 5000,\t/* wake up every 5 seconds */\n\t.periodic_fn = purge_old_stuff,\n\t.name = \"AMI server\",\n\t.accept_fn = ast_tcptls_server_root,\t/* thread doing the accept() */\n\t.worker_fn = session_do,\t/* thread handling the session */\n};\n\nstatic struct ast_tcptls_session_args amis_desc = {\n\t.accept_fd = -1,\n\t.master = AST_PTHREADT_NULL,\n\t.tls_cfg = &ami_tls_cfg,\n\t.poll_timeout = -1,\t/* the other does the periodic cleanup */\n\t.name = \"AMI TLS server\",\n\t.accept_fn = ast_tcptls_server_root,\t/* thread doing the accept() */\n\t.worker_fn = session_do,\t/* thread handling the session */\n};\n\n/*! \\brief CLI command manager show settings */\nstatic char *handle_manager_show_settings(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show settings\";\n\t\te->usage =\n\t\t\t\"Usage: manager show settings\\n\"\n\t\t\t\"       Provides detailed list of the configuration of the Manager.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n#define FORMAT \"  %-25.25s  %-15.55s\\n\"\n#define FORMAT2 \"  %-25.25s  %-15d\\n\"\n#define FORMAT3 \"  %-25.25s  %s\\n\"\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\tast_cli(a->fd, \"\\nGlobal Settings:\\n\");\n\tast_cli(a->fd, \"----------------\\n\");\n\tast_cli(a->fd, FORMAT, \"Manager (AMI):\", AST_CLI_YESNO(manager_enabled));\n\tast_cli(a->fd, FORMAT, \"Web Manager (AMI/HTTP):\", AST_CLI_YESNO(webmanager_enabled));\n\tast_cli(a->fd, FORMAT, \"TCP Bindaddress:\", manager_enabled != 0 ? ast_sockaddr_stringify(&ami_desc.local_address) : \"Disabled\");\n\tast_cli(a->fd, FORMAT2, \"HTTP Timeout (seconds):\", httptimeout);\n\tast_cli(a->fd, FORMAT, \"TLS Enable:\", AST_CLI_YESNO(ami_tls_cfg.enabled));\n\tast_cli(a->fd, FORMAT, \"TLS Bindaddress:\", ami_tls_cfg.enabled != 0 ? ast_sockaddr_stringify(&amis_desc.local_address) : \"Disabled\");\n\tast_cli(a->fd, FORMAT, \"TLS Certfile:\", ami_tls_cfg.certfile);\n\tast_cli(a->fd, FORMAT, \"TLS Privatekey:\", ami_tls_cfg.pvtfile);\n\tast_cli(a->fd, FORMAT, \"TLS Cipher:\", ami_tls_cfg.cipher);\n\tast_cli(a->fd, FORMAT, \"Allow multiple login:\", AST_CLI_YESNO(allowmultiplelogin));\n\tast_cli(a->fd, FORMAT, \"Display connects:\", AST_CLI_YESNO(displayconnects));\n\tast_cli(a->fd, FORMAT, \"Timestamp events:\", AST_CLI_YESNO(timestampevents));\n\tast_cli(a->fd, FORMAT3, \"Channel vars:\", S_OR(manager_channelvars, \"\"));\n\tast_cli(a->fd, FORMAT3, \"Disabled events:\", S_OR(manager_disabledevents, \"\"));\n\tast_cli(a->fd, FORMAT, \"Debug:\", AST_CLI_YESNO(manager_debug));\n#undef FORMAT\n#undef FORMAT2\n#undef FORMAT3\n\n\treturn CLI_SUCCESS;\n}\n\n#ifdef AST_XML_DOCS\n\nstatic int ast_xml_doc_item_cmp_fn(const void *a, const void *b)\n{\n\tstruct ast_xml_doc_item **item_a = (struct ast_xml_doc_item **)a;\n\tstruct ast_xml_doc_item **item_b = (struct ast_xml_doc_item **)b;\n\treturn strcmp((*item_a)->name, (*item_b)->name);\n}\n\nstatic char *handle_manager_show_events(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tstruct ao2_container *events;\n\tstruct ao2_iterator *it_events;\n\tstruct ast_xml_doc_item *item;\n\tstruct ast_xml_doc_item **items;\n\tstruct ast_str *buffer;\n\tint i = 0, totalitems = 0;\n\n\tswitch (cmd) {\n\tcase CLI_INIT:\n\t\te->command = \"manager show events\";\n\t\te->usage =\n\t\t\t\"Usage: manager show events\\n\"\n\t\t\t\t\"\tPrints a listing of the available Asterisk manager interface events.\\n\";\n\t\treturn NULL;\n\tcase CLI_GENERATE:\n\t\treturn NULL;\n\t}\n\tif (a->argc != 3) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tbuffer = ast_str_create(128);\n\tif (!buffer) {\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tevents = ao2_global_obj_ref(event_docs);\n\tif (!events) {\n\t\tast_cli(a->fd, \"No manager event documentation loaded\\n\");\n\t\tast_free(buffer);\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tao2_lock(events);\n\tif (!(it_events = ao2_callback(events, OBJ_MULTIPLE | OBJ_NOLOCK, NULL, NULL))) {\n\t\tao2_unlock(events);\n\t\tast_log(AST_LOG_ERROR, \"Unable to create iterator for events container\\n\");\n\t\tast_free(buffer);\n\t\tao2_ref(events, -1);\n\t\treturn CLI_SUCCESS;\n\t}\n\tif (!(items = ast_calloc(sizeof(struct ast_xml_doc_item *), ao2_container_count(events)))) {\n\t\tao2_unlock(events);\n\t\tast_log(AST_LOG_ERROR, \"Unable to create temporary sorting array for events\\n\");\n\t\tao2_iterator_destroy(it_events);\n\t\tast_free(buffer);\n\t\tao2_ref(events, -1);\n\t\treturn CLI_SUCCESS;\n\t}\n\tao2_unlock(events);\n\n\twhile ((item = ao2_iterator_next(it_events))) {\n\t\titems[totalitems++] = item;\n\t\tao2_ref(item, -1);\n\t}\n\n\tqsort(items, totalitems, sizeof(struct ast_xml_doc_item *), ast_xml_doc_item_cmp_fn);\n\n\tast_cli(a->fd, \"Events:\\n\");\n\tast_cli(a->fd, \"  --------------------  --------------------  --------------------  \\n\");\n\tfor (i = 0; i < totalitems; i++) {\n\t\tast_str_append(&buffer, 0, \"  %-20.20s\", items[i]->name);\n\t\tif ((i + 1) % 3 == 0) {\n\t\t\tast_cli(a->fd, \"%s\\n\", ast_str_buffer(buffer));\n\t\t\tast_str_set(&buffer, 0, \"%s\", \"\");\n\t\t}\n\t}\n\tif ((i + 1) % 3 != 0) {\n\t\tast_cli(a->fd, \"%s\\n\", ast_str_buffer(buffer));\n\t}\n\n\tao2_iterator_destroy(it_events);\n\tast_free(items);\n\tao2_ref(events, -1);\n\tast_free(buffer);\n\n\treturn CLI_SUCCESS;\n}\n\nstatic void print_event_instance(struct ast_cli_args *a, struct ast_xml_doc_item *instance)\n{\n\tchar syntax_title[64], description_title[64], synopsis_title[64], seealso_title[64], arguments_title[64];\n\n\tterm_color(synopsis_title, \"[Synopsis]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(description_title, \"[Description]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(syntax_title, \"[Syntax]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(seealso_title, \"[See Also]\\n\", COLOR_MAGENTA, 0, 40);\n\tterm_color(arguments_title, \"[Arguments]\\n\", COLOR_MAGENTA, 0, 40);\n\n\tif (!ast_strlen_zero(ast_str_buffer(instance->synopsis))) {\n\t\tchar *synopsis = ast_xmldoc_printable(ast_str_buffer(instance->synopsis), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", synopsis_title, synopsis);\n\t\tast_free(synopsis);\n\t}\n\tif (!ast_strlen_zero(ast_str_buffer(instance->syntax))) {\n\t\tchar *syntax = ast_xmldoc_printable(ast_str_buffer(instance->syntax), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", syntax_title, syntax);\n\t\tast_free(syntax);\n\t}\n\tif (!ast_strlen_zero(ast_str_buffer(instance->description))) {\n\t\tchar *description = ast_xmldoc_printable(ast_str_buffer(instance->description), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", description_title, description);\n\t\tast_free(description);\n\t}\n\tif (!ast_strlen_zero(ast_str_buffer(instance->arguments))) {\n\t\tchar *arguments = ast_xmldoc_printable(ast_str_buffer(instance->arguments), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", arguments_title, arguments);\n\t\tast_free(arguments);\n\t}\n\tif (!ast_strlen_zero(ast_str_buffer(instance->seealso))) {\n\t\tchar *seealso = ast_xmldoc_printable(ast_str_buffer(instance->seealso), 1);\n\t\tast_cli(a->fd, \"%s%s\\n\\n\", seealso_title, seealso);\n\t\tast_free(seealso);\n\t}\n}\n\nstatic char *handle_manager_show_event(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)\n{\n\tRAII_VAR(struct ao2_container *, events, NULL, ao2_cleanup);\n\tstruct ao2_iterator it_events;\n\tstruct ast_xml_doc_item *item, *temp;\n\tint length;\n\n\tif (cmd == CLI_INIT) {\n\t\te->command = \"manager show event\";\n\t\te->usage =\n\t\t\t\"Usage: manager show event <eventname>\\n\"\n\t\t\t\"       Provides a detailed description a Manager interface event.\\n\";\n\t\treturn NULL;\n\t}\n\n\tevents = ao2_global_obj_ref(event_docs);\n\tif (!events) {\n\t\tast_cli(a->fd, \"No manager event documentation loaded\\n\");\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tif (cmd == CLI_GENERATE) {\n\t\tif (a->pos != 3) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tlength = strlen(a->word);\n\t\tit_events = ao2_iterator_init(events, 0);\n\t\twhile ((item = ao2_iterator_next(&it_events))) {\n\t\t\tif (!strncasecmp(a->word, item->name, length)) {\n\t\t\t\tif (ast_cli_completion_add(ast_strdup(item->name))) {\n\t\t\t\t\tao2_ref(item, -1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tao2_ref(item, -1);\n\t\t}\n\t\tao2_iterator_destroy(&it_events);\n\n\t\treturn NULL;\n\t}\n\n\tif (a->argc != 4) {\n\t\treturn CLI_SHOWUSAGE;\n\t}\n\n\tif (!(item = ao2_find(events, a->argv[3], OBJ_KEY))) {\n\t\tast_cli(a->fd, \"Could not find event '%s'\\n\", a->argv[3]);\n\t\treturn CLI_SUCCESS;\n\t}\n\n\tast_cli(a->fd, \"Event: %s\\n\", a->argv[3]);\n\tfor (temp = item; temp; temp = AST_LIST_NEXT(temp, next)) {\n\t\tprint_event_instance(a, temp);\n\t}\n\n\tao2_ref(item, -1);\n\treturn CLI_SUCCESS;\n}\n\n#endif\n\nstatic struct ast_cli_entry cli_manager[] = {\n\tAST_CLI_DEFINE(handle_showmancmd, \"Show a manager interface command\"),\n\tAST_CLI_DEFINE(handle_showmancmds, \"List manager interface commands\"),\n\tAST_CLI_DEFINE(handle_showmanconn, \"List connected manager interface users\"),\n\tAST_CLI_DEFINE(handle_showmaneventq, \"List manager interface queued events\"),\n\tAST_CLI_DEFINE(handle_showmanagers, \"List configured manager users\"),\n\tAST_CLI_DEFINE(handle_showmanager, \"Display information on a specific manager user\"),\n\tAST_CLI_DEFINE(handle_mandebug, \"Show, enable, disable debugging of the manager code\"),\n\tAST_CLI_DEFINE(handle_manager_reload, \"Reload manager configurations\"),\n\tAST_CLI_DEFINE(handle_manager_show_settings, \"Show manager global settings\"),\n#ifdef AST_XML_DOCS\n\tAST_CLI_DEFINE(handle_manager_show_events, \"List manager interface events\"),\n\tAST_CLI_DEFINE(handle_manager_show_event, \"Show a manager interface event\"),\n#endif\n};\n\n/*!\n * \\internal\n * \\brief Load the config channelvars variable.\n *\n * \\param var Config variable to load.\n */\nstatic void load_channelvars(struct ast_variable *var)\n{\n\tchar *parse = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(vars)[MAX_VARS];\n\t);\n\n\tast_free(manager_channelvars);\n\tmanager_channelvars = ast_strdup(var->value);\n\n\t/* parse the setting */\n\tparse = ast_strdupa(manager_channelvars);\n\tAST_STANDARD_APP_ARGS(args, parse);\n\n\tast_channel_set_manager_vars(args.argc, args.vars);\n}\n\n/*!\n * \\internal\n * \\brief Load the config disabledevents variable.\n *\n * \\param var Config variable to load.\n */\nstatic void load_disabledevents(struct ast_variable *var)\n{\n\tast_free(manager_disabledevents);\n\tmanager_disabledevents = ast_strdup(var->value);\n}\n\n/*!\n * \\internal\n * \\brief Free a user record.  Should already be removed from the list\n */\nstatic void manager_free_user(struct ast_manager_user *user)\n{\n\tast_free(user->a1_hash);\n\tast_free(user->secret);\n\tif (user->whitefilters) {\n\t\tao2_t_ref(user->whitefilters, -1, \"decrement ref for white container, should be last one\");\n\t}\n\tif (user->blackfilters) {\n\t\tao2_t_ref(user->blackfilters, -1, \"decrement ref for black container, should be last one\");\n\t}\n\tuser->acl = ast_free_acl_list(user->acl);\n\tast_variables_destroy(user->chanvars);\n\tast_free(user);\n}\n\n/*!\n * \\internal\n * \\brief Clean up resources on Asterisk shutdown\n */\nstatic void manager_shutdown(void)\n{\n\tstruct ast_manager_user *user;\n\n\t/* This event is not actually transmitted, but causes all TCP sessions to be closed */\n\tmanager_event(EVENT_FLAG_SHUTDOWN, \"CloseSession\", \"CloseSession: true\\r\\n\");\n\n\tast_manager_unregister(\"Ping\");\n\tast_manager_unregister(\"Events\");\n\tast_manager_unregister(\"Logoff\");\n\tast_manager_unregister(\"Login\");\n\tast_manager_unregister(\"Challenge\");\n\tast_manager_unregister(\"Hangup\");\n\tast_manager_unregister(\"Status\");\n\tast_manager_unregister(\"Setvar\");\n\tast_manager_unregister(\"Getvar\");\n\tast_manager_unregister(\"GetConfig\");\n\tast_manager_unregister(\"GetConfigJSON\");\n\tast_manager_unregister(\"UpdateConfig\");\n\tast_manager_unregister(\"CreateConfig\");\n\tast_manager_unregister(\"ListCategories\");\n\tast_manager_unregister(\"Redirect\");\n\tast_manager_unregister(\"Atxfer\");\n\tast_manager_unregister(\"CancelAtxfer\");\n\tast_manager_unregister(\"Originate\");\n\tast_manager_unregister(\"Command\");\n\tast_manager_unregister(\"ExtensionState\");\n\tast_manager_unregister(\"PresenceState\");\n\tast_manager_unregister(\"AbsoluteTimeout\");\n\tast_manager_unregister(\"MailboxStatus\");\n\tast_manager_unregister(\"MailboxCount\");\n\tast_manager_unregister(\"ListCommands\");\n\tast_manager_unregister(\"SendText\");\n\tast_manager_unregister(\"UserEvent\");\n\tast_manager_unregister(\"WaitEvent\");\n\tast_manager_unregister(\"CoreSettings\");\n\tast_manager_unregister(\"CoreStatus\");\n\tast_manager_unregister(\"Reload\");\n\tast_manager_unregister(\"LoggerRotate\");\n\tast_manager_unregister(\"CoreShowChannels\");\n\tast_manager_unregister(\"CoreShowChannelMap\");\n\tast_manager_unregister(\"ModuleLoad\");\n\tast_manager_unregister(\"ModuleCheck\");\n\tast_manager_unregister(\"AOCMessage\");\n\tast_manager_unregister(\"Filter\");\n\tast_manager_unregister(\"BlindTransfer\");\n\tast_custom_function_unregister(&managerclient_function);\n\tast_cli_unregister_multiple(cli_manager, ARRAY_LEN(cli_manager));\n\n#ifdef AST_XML_DOCS\n\tao2_t_global_obj_release(event_docs, \"Dispose of event_docs\");\n#endif\n\n#ifdef TEST_FRAMEWORK\n\tstasis_forward_cancel(test_suite_forwarder);\n\ttest_suite_forwarder = NULL;\n#endif\n\n\tif (stasis_router) {\n\t\tstasis_message_router_unsubscribe_and_join(stasis_router);\n\t\tstasis_router = NULL;\n\t}\n\tstasis_forward_cancel(rtp_topic_forwarder);\n\trtp_topic_forwarder = NULL;\n\tstasis_forward_cancel(security_topic_forwarder);\n\tsecurity_topic_forwarder = NULL;\n\tao2_cleanup(manager_topic);\n\tmanager_topic = NULL;\n\tSTASIS_MESSAGE_TYPE_CLEANUP(ast_manager_get_generic_type);\n\n\tast_tcptls_server_stop(&ami_desc);\n\tast_tcptls_server_stop(&amis_desc);\n\n\tast_free(ami_tls_cfg.certfile);\n\tami_tls_cfg.certfile = NULL;\n\tast_free(ami_tls_cfg.pvtfile);\n\tami_tls_cfg.pvtfile = NULL;\n\tast_free(ami_tls_cfg.cipher);\n\tami_tls_cfg.cipher = NULL;\n\tast_free(ami_tls_cfg.cafile);\n\tami_tls_cfg.cafile = NULL;\n\tast_free(ami_tls_cfg.capath);\n\tami_tls_cfg.capath = NULL;\n\n\tao2_global_obj_release(mgr_sessions);\n\n\twhile ((user = AST_LIST_REMOVE_HEAD(&users, list))) {\n\t\tmanager_free_user(user);\n\t}\n\tacl_change_stasis_unsubscribe();\n\n\tast_free(manager_channelvars);\n\tast_free(manager_disabledevents);\n}\n\n\n/*! \\brief Initialize all \\ref stasis topics and routers used by the various\n * sub-components of AMI\n */\nstatic int manager_subscriptions_init(void)\n{\n\tint res = 0;\n\n\trtp_topic_forwarder = stasis_forward_all(ast_rtp_topic(), manager_topic);\n\tif (!rtp_topic_forwarder) {\n\t\treturn -1;\n\t}\n\n\tsecurity_topic_forwarder = stasis_forward_all(ast_security_topic(), manager_topic);\n\tif (!security_topic_forwarder) {\n\t\treturn -1;\n\t}\n\n\tstasis_router = stasis_message_router_create(manager_topic);\n\tif (!stasis_router) {\n\t\treturn -1;\n\t}\n\tstasis_message_router_set_congestion_limits(stasis_router, -1,\n\t\t6 * AST_TASKPROCESSOR_HIGH_WATER_LEVEL);\n\n\tstasis_message_router_set_formatters_default(stasis_router,\n\t\tmanager_default_msg_cb, NULL, STASIS_SUBSCRIPTION_FORMATTER_AMI);\n\n\tres |= stasis_message_router_add(stasis_router,\n\t\tast_manager_get_generic_type(), manager_generic_msg_cb, NULL);\n\n\tif (res != 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int subscribe_all(void)\n{\n\tif (manager_subscriptions_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager subscriptions\\n\");\n\t\treturn -1;\n\t}\n\tif (manager_system_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager system handling\\n\");\n\t\treturn -1;\n\t}\n\tif (manager_channels_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager channel handling\\n\");\n\t\treturn -1;\n\t}\n\tif (manager_mwi_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager MWI handling\\n\");\n\t\treturn -1;\n\t}\n\tif (manager_bridging_init()) {\n\t\treturn -1;\n\t}\n\tif (manager_endpoints_init()) {\n\t\tast_log(AST_LOG_ERROR, \"Failed to initialize manager endpoints handling\\n\");\n\t\treturn -1;\n\t}\n\n\tsubscribed = 1;\n\treturn 0;\n}\n\nstatic void manager_set_defaults(void)\n{\n\tmanager_enabled = 0;\n\tdisplayconnects = 1;\n\tbroken_events_action = 0;\n\tauthtimeout = 30;\n\tauthlimit = 50;\n\tmanager_debug = 0;\t\t/* Debug disabled by default */\n\n\t/* default values */\n\tast_copy_string(global_realm, S_OR(ast_config_AST_SYSTEM_NAME, DEFAULT_REALM),\n\t\tsizeof(global_realm));\n\tast_sockaddr_setnull(&ami_desc.local_address);\n\tast_sockaddr_setnull(&amis_desc.local_address);\n\n\tami_tls_cfg.enabled = 0;\n\tast_free(ami_tls_cfg.certfile);\n\tami_tls_cfg.certfile = ast_strdup(AST_CERTFILE);\n\tast_free(ami_tls_cfg.pvtfile);\n\tami_tls_cfg.pvtfile = ast_strdup(\"\");\n\tast_free(ami_tls_cfg.cipher);\n\tami_tls_cfg.cipher = ast_strdup(\"\");\n\tast_free(ami_tls_cfg.cafile);\n\tami_tls_cfg.cafile = ast_strdup(\"\");\n\tast_free(ami_tls_cfg.capath);\n\tami_tls_cfg.capath = ast_strdup(\"\");\n}\n\nstatic int __init_manager(int reload, int by_external_config)\n{\n\tstruct ast_config *ucfg = NULL, *cfg = NULL;\n\tconst char *val;\n\tchar *cat = NULL;\n\tint newhttptimeout = 60;\n\tstruct ast_manager_user *user = NULL;\n\tstruct ast_variable *var;\n\tstruct ast_flags config_flags = { (reload && !by_external_config) ? CONFIG_FLAG_FILEUNCHANGED : 0 };\n\tchar a1[256];\n\tchar a1_hash[256];\n\tstruct ast_sockaddr ami_desc_local_address_tmp;\n\tstruct ast_sockaddr amis_desc_local_address_tmp;\n\tint tls_was_enabled = 0;\n\tint acl_subscription_flag = 0;\n\n\tif (!reload) {\n\t\tstruct ao2_container *sessions;\n#ifdef AST_XML_DOCS\n\t\tstruct ao2_container *temp_event_docs;\n#endif\n\t\tint res;\n\n\t\tres = STASIS_MESSAGE_TYPE_INIT(ast_manager_get_generic_type);\n\t\tif (res != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tmanager_topic = stasis_topic_create(\"manager:core\");\n\t\tif (!manager_topic) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Register default actions */\n\t\tast_manager_register_xml_core(\"Ping\", 0, action_ping);\n\t\tast_manager_register_xml_core(\"Events\", 0, action_events);\n\t\tast_manager_register_xml_core(\"Logoff\", 0, action_logoff);\n\t\tast_manager_register_xml_core(\"Login\", 0, action_login);\n\t\tast_manager_register_xml_core(\"Challenge\", 0, action_challenge);\n\t\tast_manager_register_xml_core(\"Hangup\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CALL, action_hangup);\n\t\tast_manager_register_xml_core(\"Status\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_status);\n\t\tast_manager_register_xml_core(\"Setvar\", EVENT_FLAG_CALL, action_setvar);\n\t\tast_manager_register_xml_core(\"Getvar\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_getvar);\n\t\tast_manager_register_xml_core(\"GetConfig\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CONFIG, action_getconfig);\n\t\tast_manager_register_xml_core(\"GetConfigJSON\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CONFIG, action_getconfigjson);\n\t\tast_manager_register_xml_core(\"UpdateConfig\", EVENT_FLAG_CONFIG, action_updateconfig);\n\t\tast_manager_register_xml_core(\"CreateConfig\", EVENT_FLAG_CONFIG, action_createconfig);\n\t\tast_manager_register_xml_core(\"ListCategories\", EVENT_FLAG_CONFIG, action_listcategories);\n\t\tast_manager_register_xml_core(\"Redirect\", EVENT_FLAG_CALL, action_redirect);\n\t\tast_manager_register_xml_core(\"Atxfer\", EVENT_FLAG_CALL, action_atxfer);\n\t\tast_manager_register_xml_core(\"CancelAtxfer\", EVENT_FLAG_CALL, action_cancel_atxfer);\n\t\tast_manager_register_xml_core(\"Originate\", EVENT_FLAG_ORIGINATE, action_originate);\n\t\tast_manager_register_xml_core(\"Command\", EVENT_FLAG_COMMAND, action_command);\n\t\tast_manager_register_xml_core(\"ExtensionState\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_extensionstate);\n\t\tast_manager_register_xml_core(\"PresenceState\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_presencestate);\n\t\tast_manager_register_xml_core(\"AbsoluteTimeout\", EVENT_FLAG_SYSTEM | EVENT_FLAG_CALL, action_timeout);\n\t\tast_manager_register_xml_core(\"MailboxStatus\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_mailboxstatus);\n\t\tast_manager_register_xml_core(\"MailboxCount\", EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_mailboxcount);\n\t\tast_manager_register_xml_core(\"ListCommands\", 0, action_listcommands);\n\t\tast_manager_register_xml_core(\"SendText\", EVENT_FLAG_CALL, action_sendtext);\n\t\tast_manager_register_xml_core(\"UserEvent\", EVENT_FLAG_USER, action_userevent);\n\t\tast_manager_register_xml_core(\"WaitEvent\", 0, action_waitevent);\n\t\tast_manager_register_xml_core(\"CoreSettings\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_coresettings);\n\t\tast_manager_register_xml_core(\"CoreStatus\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_corestatus);\n\t\tast_manager_register_xml_core(\"Reload\", EVENT_FLAG_CONFIG | EVENT_FLAG_SYSTEM, action_reload);\n\t\tast_manager_register_xml_core(\"LoggerRotate\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_loggerrotate);\n\t\tast_manager_register_xml_core(\"CoreShowChannels\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_coreshowchannels);\n\t\tast_manager_register_xml_core(\"CoreShowChannelMap\", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, action_coreshowchannelmap);\n\t\tast_manager_register_xml_core(\"ModuleLoad\", EVENT_FLAG_SYSTEM, manager_moduleload);\n\t\tast_manager_register_xml_core(\"ModuleCheck\", EVENT_FLAG_SYSTEM, manager_modulecheck);\n\t\tast_manager_register_xml_core(\"AOCMessage\", EVENT_FLAG_AOC, action_aocmessage);\n\t\tast_manager_register_xml_core(\"Filter\", EVENT_FLAG_SYSTEM, action_filter);\n\t\tast_manager_register_xml_core(\"BlindTransfer\", EVENT_FLAG_CALL, action_blind_transfer);\n\n#ifdef TEST_FRAMEWORK\n\t\ttest_suite_forwarder = stasis_forward_all(ast_test_suite_topic(), manager_topic);\n#endif\n\n\t\tast_cli_register_multiple(cli_manager, ARRAY_LEN(cli_manager));\n\t\t__ast_custom_function_register(&managerclient_function, NULL);\n\t\tast_extension_state_add(NULL, NULL, manager_state_cb, NULL);\n\n\t\t/* Append placeholder event so master_eventq never runs dry */\n\t\tif (append_event(\"Event: Placeholder\\r\\n\\r\\n\", 0)) {\n\t\t\treturn -1;\n\t\t}\n\n#ifdef AST_XML_DOCS\n\t\ttemp_event_docs = ast_xmldoc_build_documentation(\"managerEvent\");\n\t\tif (temp_event_docs) {\n\t\t\tao2_t_global_obj_replace_unref(event_docs, temp_event_docs, \"Toss old event docs\");\n\t\t\tao2_t_ref(temp_event_docs, -1, \"Remove creation ref - container holds only ref now\");\n\t\t}\n#endif\n\n\t\t/* If you have a NULL hash fn, you only need a single bucket */\n\t\tsessions = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, mansession_cmp_fn);\n\t\tif (!sessions) {\n\t\t\treturn -1;\n\t\t}\n\t\tao2_global_obj_replace_unref(mgr_sessions, sessions);\n\t\tao2_ref(sessions, -1);\n\n\t\t/* Initialize all settings before first configuration load. */\n\t\tmanager_set_defaults();\n\t}\n\n\tcfg = ast_config_load2(\"manager.conf\", \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEUNCHANGED) {\n\t\treturn 0;\n\t} else if (!cfg || cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tast_log(LOG_NOTICE, \"Unable to open AMI configuration manager.conf, or configuration is invalid.\\n\");\n\t\treturn 0;\n\t}\n\n\t/* If this wasn't performed due to a forced reload (because those can be created by ACL change events, we need to unsubscribe to ACL change events. */\n\tif (!by_external_config) {\n\t\tacl_change_stasis_unsubscribe();\n\t}\n\n\tif (reload) {\n\t\t/* Reset all settings before reloading configuration */\n\t\ttls_was_enabled = ami_tls_cfg.enabled;\n\t\tmanager_set_defaults();\n\t}\n\n\tast_sockaddr_parse(&ami_desc_local_address_tmp, \"[::]\", 0);\n\tast_sockaddr_set_port(&ami_desc_local_address_tmp, DEFAULT_MANAGER_PORT);\n\n\tfor (var = ast_variable_browse(cfg, \"general\"); var; var = var->next) {\n\t\tval = var->value;\n\n\t\t/* read tls config options while preventing unsupported options from being set */\n\t\tif (strcasecmp(var->name, \"tlscafile\")\n\t\t\t&& strcasecmp(var->name, \"tlscapath\")\n\t\t\t&& strcasecmp(var->name, \"tlscadir\")\n\t\t\t&& strcasecmp(var->name, \"tlsverifyclient\")\n\t\t\t&& strcasecmp(var->name, \"tlsdontverifyserver\")\n\t\t\t&& strcasecmp(var->name, \"tlsclientmethod\")\n\t\t\t&& strcasecmp(var->name, \"sslclientmethod\")\n\t\t\t&& !ast_tls_read_conf(&ami_tls_cfg, &amis_desc, var->name, val)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcasecmp(var->name, \"enabled\")) {\n\t\t\tmanager_enabled = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"webenabled\")) {\n\t\t\twebmanager_enabled = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"port\")) {\n\t\t\tint bindport;\n\t\t\tif (ast_parse_arg(val, PARSE_UINT32|PARSE_IN_RANGE, &bindport, 1024, 65535)) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid port number '%s'\\n\", val);\n\t\t\t}\n\t\t\tast_sockaddr_set_port(&ami_desc_local_address_tmp, bindport);\n\t\t} else if (!strcasecmp(var->name, \"bindaddr\")) {\n\t\t\t/* remember port if it has already been set */\n\t\t\tint setport = ast_sockaddr_port(&ami_desc_local_address_tmp);\n\n\t\t\tif (ast_parse_arg(val, PARSE_ADDR|PARSE_PORT_IGNORE, NULL)) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid address '%s' specified, default '%s' will be used\\n\", val,\n\t\t\t\t\t\tast_sockaddr_stringify_addr(&ami_desc_local_address_tmp));\n\t\t\t} else {\n\t\t\t\tast_sockaddr_parse(&ami_desc_local_address_tmp, val, PARSE_PORT_IGNORE);\n\t\t\t}\n\n\t\t\tif (setport) {\n\t\t\t\tast_sockaddr_set_port(&ami_desc_local_address_tmp, setport);\n\t\t\t}\n\n\t\t} else if (!strcasecmp(var->name, \"brokeneventsaction\")) {\n\t\t\tbroken_events_action = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"allowmultiplelogin\")) {\n\t\t\tallowmultiplelogin = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"displayconnects\")) {\n\t\t\tdisplayconnects = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"timestampevents\")) {\n\t\t\ttimestampevents = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"debug\")) {\n\t\t\tmanager_debug = ast_true(val);\n\t\t} else if (!strcasecmp(var->name, \"httptimeout\")) {\n\t\t\tnewhttptimeout = atoi(val);\n\t\t} else if (!strcasecmp(var->name, \"authtimeout\")) {\n\t\t\tint timeout = atoi(var->value);\n\n\t\t\tif (timeout < 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid authtimeout value '%s', using default value\\n\", var->value);\n\t\t\t} else {\n\t\t\t\tauthtimeout = timeout;\n\t\t\t}\n\t\t} else if (!strcasecmp(var->name, \"authlimit\")) {\n\t\t\tint limit = atoi(var->value);\n\n\t\t\tif (limit < 1) {\n\t\t\t\tast_log(LOG_WARNING, \"Invalid authlimit value '%s', using default value\\n\", var->value);\n\t\t\t} else {\n\t\t\t\tauthlimit = limit;\n\t\t\t}\n\t\t} else if (!strcasecmp(var->name, \"channelvars\")) {\n\t\t\tload_channelvars(var);\n\t\t} else if (!strcasecmp(var->name, \"disabledevents\")) {\n\t\t\tload_disabledevents(var);\n\t\t} else {\n\t\t\tast_log(LOG_NOTICE, \"Invalid keyword <%s> = <%s> in manager.conf [general]\\n\",\n\t\t\t\tvar->name, val);\n\t\t}\n\t}\n\n\tif (manager_enabled && !subscribed) {\n\t\tif (subscribe_all() != 0) {\n\t\t\tast_log(LOG_ERROR, \"Manager subscription error\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tast_sockaddr_copy(&amis_desc_local_address_tmp, &amis_desc.local_address);\n\n\t/* if the amis address has not been set, default is the same as non secure ami */\n\tif (ast_sockaddr_isnull(&amis_desc_local_address_tmp)) {\n\t\tast_sockaddr_copy(&amis_desc_local_address_tmp, &ami_desc_local_address_tmp);\n\t}\n\n\t/* if the amis address was not set, it will have non-secure ami port set; if\n\t   amis address was set, we need to check that a port was set or not, if not\n\t   use the default tls port */\n\tif (ast_sockaddr_port(&amis_desc_local_address_tmp) == 0 ||\n\t\t\t(ast_sockaddr_port(&ami_desc_local_address_tmp) == ast_sockaddr_port(&amis_desc_local_address_tmp))) {\n\n\t\tast_sockaddr_set_port(&amis_desc_local_address_tmp, DEFAULT_MANAGER_TLS_PORT);\n\t}\n\n\tif (manager_enabled) {\n\t\tast_sockaddr_copy(&ami_desc.local_address, &ami_desc_local_address_tmp);\n\t\tast_sockaddr_copy(&amis_desc.local_address, &amis_desc_local_address_tmp);\n\t}\n\n\tAST_RWLIST_WRLOCK(&users);\n\n\t/* First, get users from users.conf */\n\tucfg = ast_config_load2(\"users.conf\", \"manager\", config_flags);\n\tif (ucfg && (ucfg != CONFIG_STATUS_FILEUNCHANGED) && ucfg != CONFIG_STATUS_FILEINVALID) {\n\t\tconst char *hasmanager;\n\t\tint genhasmanager = ast_true(ast_variable_retrieve(ucfg, \"general\", \"hasmanager\"));\n\n\t\twhile ((cat = ast_category_browse(ucfg, cat))) {\n\t\t\tif (!strcasecmp(cat, \"general\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thasmanager = ast_variable_retrieve(ucfg, cat, \"hasmanager\");\n\t\t\tif ((!hasmanager && genhasmanager) || ast_true(hasmanager)) {\n\t\t\t\tconst char *user_secret = ast_variable_retrieve(ucfg, cat, \"secret\");\n\t\t\t\tconst char *user_read = ast_variable_retrieve(ucfg, cat, \"read\");\n\t\t\t\tconst char *user_write = ast_variable_retrieve(ucfg, cat, \"write\");\n\t\t\t\tconst char *user_displayconnects = ast_variable_retrieve(ucfg, cat, \"displayconnects\");\n\t\t\t\tconst char *user_allowmultiplelogin = ast_variable_retrieve(ucfg, cat, \"allowmultiplelogin\");\n\t\t\t\tconst char *user_writetimeout = ast_variable_retrieve(ucfg, cat, \"writetimeout\");\n\n\t\t\t\t/* Look for an existing entry,\n\t\t\t\t * if none found - create one and add it to the list\n\t\t\t\t */\n\t\t\t\tif (!(user = get_manager_by_name_locked(cat))) {\n\t\t\t\t\tif (!(user = ast_calloc(1, sizeof(*user)))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy name over */\n\t\t\t\t\tast_copy_string(user->username, cat, sizeof(user->username));\n\t\t\t\t\t/* Insert into list */\n\t\t\t\t\tAST_LIST_INSERT_TAIL(&users, user, list);\n\t\t\t\t\tuser->acl = NULL;\n\t\t\t\t\tuser->keep = 1;\n\t\t\t\t\tuser->readperm = -1;\n\t\t\t\t\tuser->writeperm = -1;\n\t\t\t\t\t/* Default displayconnect from [general] */\n\t\t\t\t\tuser->displayconnects = displayconnects;\n\t\t\t\t\t/* Default allowmultiplelogin from [general] */\n\t\t\t\t\tuser->allowmultiplelogin = allowmultiplelogin;\n\t\t\t\t\tuser->writetimeout = 100;\n\t\t\t\t}\n\n\t\t\t\tif (!user_secret) {\n\t\t\t\t\tuser_secret = ast_variable_retrieve(ucfg, \"general\", \"secret\");\n\t\t\t\t}\n\t\t\t\tif (!user_read) {\n\t\t\t\t\tuser_read = ast_variable_retrieve(ucfg, \"general\", \"read\");\n\t\t\t\t}\n\t\t\t\tif (!user_write) {\n\t\t\t\t\tuser_write = ast_variable_retrieve(ucfg, \"general\", \"write\");\n\t\t\t\t}\n\t\t\t\tif (!user_displayconnects) {\n\t\t\t\t\tuser_displayconnects = ast_variable_retrieve(ucfg, \"general\", \"displayconnects\");\n\t\t\t\t}\n\t\t\t\tif (!user_allowmultiplelogin) {\n\t\t\t\t\tuser_allowmultiplelogin = ast_variable_retrieve(ucfg, \"general\", \"allowmultiplelogin\");\n\t\t\t\t}\n\t\t\t\tif (!user_writetimeout) {\n\t\t\t\t\tuser_writetimeout = ast_variable_retrieve(ucfg, \"general\", \"writetimeout\");\n\t\t\t\t}\n\n\t\t\t\tif (!ast_strlen_zero(user_secret)) {\n\t\t\t\t\tast_free(user->secret);\n\t\t\t\t\tuser->secret = ast_strdup(user_secret);\n\t\t\t\t}\n\n\t\t\t\tif (user_read) {\n\t\t\t\t\tuser->readperm = get_perm(user_read);\n\t\t\t\t}\n\t\t\t\tif (user_write) {\n\t\t\t\t\tuser->writeperm = get_perm(user_write);\n\t\t\t\t}\n\t\t\t\tif (user_displayconnects) {\n\t\t\t\t\tuser->displayconnects = ast_true(user_displayconnects);\n\t\t\t\t}\n\t\t\t\tif (user_allowmultiplelogin) {\n\t\t\t\t\tuser->allowmultiplelogin = ast_true(user_allowmultiplelogin);\n\t\t\t\t}\n\t\t\t\tif (user_writetimeout) {\n\t\t\t\t\tint value = atoi(user_writetimeout);\n\t\t\t\t\tif (value < 100) {\n\t\t\t\t\t\tast_log(LOG_WARNING, \"Invalid writetimeout value '%d' in users.conf\\n\", value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuser->writetimeout = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tast_config_destroy(ucfg);\n\t}\n\n\t/* cat is NULL here in any case */\n\n\twhile ((cat = ast_category_browse(cfg, cat))) {\n\t\tstruct ast_acl_list *oldacl;\n\n\t\tif (!strcasecmp(cat, \"general\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Look for an existing entry, if none found - create one and add it to the list */\n\t\tif (!(user = get_manager_by_name_locked(cat))) {\n\t\t\tif (!(user = ast_calloc(1, sizeof(*user)))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Copy name over */\n\t\t\tast_copy_string(user->username, cat, sizeof(user->username));\n\n\t\t\tuser->acl = NULL;\n\t\t\tuser->readperm = 0;\n\t\t\tuser->writeperm = 0;\n\t\t\t/* Default displayconnect from [general] */\n\t\t\tuser->displayconnects = displayconnects;\n\t\t\t/* Default allowmultiplelogin from [general] */\n\t\t\tuser->allowmultiplelogin = allowmultiplelogin;\n\t\t\tuser->writetimeout = 100;\n\t\t\tuser->whitefilters = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, NULL);\n\t\t\tuser->blackfilters = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0, NULL, NULL);\n\t\t\tif (!user->whitefilters || !user->blackfilters) {\n\t\t\t\tmanager_free_user(user);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Insert into list */\n\t\t\tAST_RWLIST_INSERT_TAIL(&users, user, list);\n\t\t} else {\n\t\t\tao2_t_callback(user->whitefilters, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL, \"unlink all white filters\");\n\t\t\tao2_t_callback(user->blackfilters, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL, \"unlink all black filters\");\n\t\t}\n\n\t\t/* Make sure we keep this user and don't destroy it during cleanup */\n\t\tuser->keep = 1;\n\t\toldacl = user->acl;\n\t\tuser->acl = NULL;\n\t\tast_variables_destroy(user->chanvars);\n\n\t\tvar = ast_variable_browse(cfg, cat);\n\t\tfor (; var; var = var->next) {\n\t\t\tif (!strcasecmp(var->name, \"secret\")) {\n\t\t\t\tast_free(user->secret);\n\t\t\t\tuser->secret = ast_strdup(var->value);\n\t\t\t} else if (!strcasecmp(var->name, \"deny\") ||\n\t\t\t\t       !strcasecmp(var->name, \"permit\") ||\n\t\t\t\t       !strcasecmp(var->name, \"acl\")) {\n\t\t\t\tint acl_error = 0;\n\n\t\t\t\tast_append_acl(var->name, var->value, &user->acl, &acl_error, &acl_subscription_flag);\n\t\t\t\tif (acl_error) {\n\t\t\t\t\tast_log(LOG_ERROR, \"Invalid ACL '%s' for manager user '%s' on line %d. Deleting user\\n\",\n\t\t\t\t\t\tvar->value, user->username, var->lineno);\n\t\t\t\t\tuser->keep = 0;\n\t\t\t\t}\n\t\t\t}  else if (!strcasecmp(var->name, \"read\") ) {\n\t\t\t\tuser->readperm = get_perm(var->value);\n\t\t\t}  else if (!strcasecmp(var->name, \"write\") ) {\n\t\t\t\tuser->writeperm = get_perm(var->value);\n\t\t\t}  else if (!strcasecmp(var->name, \"displayconnects\") ) {\n\t\t\t\tuser->displayconnects = ast_true(var->value);\n\t\t\t}  else if (!strcasecmp(var->name, \"allowmultiplelogin\") ) {\n\t\t\t\tuser->allowmultiplelogin = ast_true(var->value);\n\t\t\t} else if (!strcasecmp(var->name, \"writetimeout\")) {\n\t\t\t\tint value = atoi(var->value);\n\t\t\t\tif (value < 100) {\n\t\t\t\t\tast_log(LOG_WARNING, \"Invalid writetimeout value '%s' at line %d\\n\", var->value, var->lineno);\n\t\t\t\t} else {\n\t\t\t\t\tuser->writetimeout = value;\n\t\t\t\t}\n\t\t\t} else if (!strcasecmp(var->name, \"setvar\")) {\n\t\t\t\tstruct ast_variable *tmpvar;\n\t\t\t\tchar varbuf[256];\n\t\t\t\tchar *varval;\n\t\t\t\tchar *varname;\n\n\t\t\t\tast_copy_string(varbuf, var->value, sizeof(varbuf));\n\t\t\t\tvarname = varbuf;\n\n\t\t\t\tif ((varval = strchr(varname,'='))) {\n\t\t\t\t\t*varval++ = '\\0';\n\t\t\t\t\tif ((tmpvar = ast_variable_new(varname, varval, \"\"))) {\n\t\t\t\t\t\ttmpvar->next = user->chanvars;\n\t\t\t\t\t\tuser->chanvars = tmpvar;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcasecmp(var->name, \"eventfilter\")) {\n\t\t\t\tconst char *value = var->value;\n\t\t\t\tmanager_add_filter(value, user->whitefilters, user->blackfilters);\n\t\t\t} else {\n\t\t\t\tast_debug(1, \"%s is an unknown option.\\n\", var->name);\n\t\t\t}\n\t\t}\n\n\t\toldacl = ast_free_acl_list(oldacl);\n\t}\n\tast_config_destroy(cfg);\n\n\t/* Check the flag for named ACL event subscription and if we need to, register a subscription. */\n\tif (acl_subscription_flag && !by_external_config) {\n\t\tacl_change_stasis_subscribe();\n\t}\n\n\t/* Perform cleanup - essentially prune out old users that no longer exist */\n\tAST_RWLIST_TRAVERSE_SAFE_BEGIN(&users, user, list) {\n\t\tif (user->keep) {\t/* valid record. clear flag for the next round */\n\t\t\tuser->keep = 0;\n\n\t\t\t/* Calculate A1 for Digest auth */\n\t\t\tsnprintf(a1, sizeof(a1), \"%s:%s:%s\", user->username, global_realm, user->secret);\n\t\t\tast_md5_hash(a1_hash,a1);\n\t\t\tast_free(user->a1_hash);\n\t\t\tuser->a1_hash = ast_strdup(a1_hash);\n\t\t\tcontinue;\n\t\t}\n\t\t/* We do not need to keep this user so take them out of the list */\n\t\tAST_RWLIST_REMOVE_CURRENT(list);\n\t\tast_debug(4, \"Pruning user '%s'\\n\", user->username);\n\t\tmanager_free_user(user);\n\t}\n\tAST_RWLIST_TRAVERSE_SAFE_END;\n\n\tAST_RWLIST_UNLOCK(&users);\n\n\tif (webmanager_enabled && manager_enabled) {\n\t\tif (!webregged) {\n\t\t\tast_http_uri_link(&rawmanuri);\n\t\t\tast_http_uri_link(&manageruri);\n\t\t\tast_http_uri_link(&managerxmluri);\n\n\t\t\tast_http_uri_link(&arawmanuri);\n\t\t\tast_http_uri_link(&amanageruri);\n\t\t\tast_http_uri_link(&amanagerxmluri);\n\t\t\twebregged = 1;\n\t\t}\n\t} else {\n\t\tif (webregged) {\n\t\t\tast_http_uri_unlink(&rawmanuri);\n\t\t\tast_http_uri_unlink(&manageruri);\n\t\t\tast_http_uri_unlink(&managerxmluri);\n\n\t\t\tast_http_uri_unlink(&arawmanuri);\n\t\t\tast_http_uri_unlink(&amanageruri);\n\t\t\tast_http_uri_unlink(&amanagerxmluri);\n\t\t\twebregged = 0;\n\t\t}\n\t}\n\n\tif (newhttptimeout > 0) {\n\t\thttptimeout = newhttptimeout;\n\t}\n\n\tast_tcptls_server_start(&ami_desc);\n\tif (tls_was_enabled && !ami_tls_cfg.enabled) {\n\t\tast_tcptls_server_stop(&amis_desc);\n\t} else if (ast_ssl_setup(amis_desc.tls_cfg)) {\n\t\tast_tcptls_server_start(&amis_desc);\n\t}\n\n\treturn 0;\n}\n\nstatic void acl_change_stasis_cb(void *data, struct stasis_subscription *sub,\n\tstruct stasis_message *message)\n{\n\tif (stasis_message_type(message) != ast_named_acl_change_type()) {\n\t\treturn;\n\t}\n\n\t/* For now, this is going to be performed simply and just execute a forced reload. */\n\tast_log(LOG_NOTICE, \"Reloading manager in response to ACL change event.\\n\");\n\t__init_manager(1, 1);\n}\n\nstatic int unload_module(void)\n{\n\treturn 0;\n}\n\nstatic int load_module(void)\n{\n\tast_register_cleanup(manager_shutdown);\n\n\treturn __init_manager(0, 0) ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_SUCCESS;\n}\n\nstatic int reload_module(void)\n{\n\treturn __init_manager(1, 0);\n}\n\nint astman_datastore_add(struct mansession *s, struct ast_datastore *datastore)\n{\n\tAST_LIST_INSERT_HEAD(&s->session->datastores, datastore, entry);\n\n\treturn 0;\n}\n\nint astman_datastore_remove(struct mansession *s, struct ast_datastore *datastore)\n{\n\treturn AST_LIST_REMOVE(&s->session->datastores, datastore, entry) ? 0 : -1;\n}\n\nstruct ast_datastore *astman_datastore_find(struct mansession *s, const struct ast_datastore_info *info, const char *uid)\n{\n\tstruct ast_datastore *datastore = NULL;\n\n\tif (info == NULL)\n\t\treturn NULL;\n\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&s->session->datastores, datastore, entry) {\n\t\tif (datastore->info != info) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (uid == NULL) {\n\t\t\t/* matched by type only */\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((datastore->uid != NULL) && !strcasecmp(uid, datastore->uid)) {\n\t\t\t/* Matched by type AND uid */\n\t\t\tbreak;\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\n\treturn datastore;\n}\n\nint ast_str_append_event_header(struct ast_str **fields_string,\n\tconst char *header, const char *value)\n{\n\tif (!*fields_string) {\n\t\t*fields_string = ast_str_create(128);\n\t\tif (!*fields_string) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn (ast_str_append(fields_string, 0, \"%s: %s\\r\\n\", header, value) < 0) ? -1 : 0;\n}\n\nstatic void manager_event_blob_dtor(void *obj)\n{\n\tstruct ast_manager_event_blob *ev = obj;\n\n\tast_string_field_free_memory(ev);\n}\n\nstruct ast_manager_event_blob *\n__attribute__((format(printf, 3, 4)))\nast_manager_event_blob_create(\n\tint event_flags,\n\tconst char *manager_event,\n\tconst char *extra_fields_fmt,\n\t...)\n{\n\tstruct ast_manager_event_blob *ev;\n\tva_list argp;\n\n\tast_assert(extra_fields_fmt != NULL);\n\tast_assert(manager_event != NULL);\n\n\tev = ao2_alloc_options(sizeof(*ev), manager_event_blob_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);\n\tif (!ev) {\n\t\treturn NULL;\n\t}\n\n\tif (ast_string_field_init(ev, 20)) {\n\t\tao2_ref(ev, -1);\n\t\treturn NULL;\n\t}\n\n\tev->manager_event = manager_event;\n\tev->event_flags = event_flags;\n\n\tva_start(argp, extra_fields_fmt);\n\tast_string_field_ptr_build_va(ev, &ev->extra_fields, extra_fields_fmt, argp);\n\tva_end(argp);\n\n\treturn ev;\n}\n\nAST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_GLOBAL_SYMBOLS | AST_MODFLAG_LOAD_ORDER, \"Asterisk Manager Interface\",\n\t.support_level = AST_MODULE_SUPPORT_CORE,\n\t.load = load_module,\n\t.unload = unload_module,\n\t.reload = reload_module,\n\t.load_pri = AST_MODPRI_CORE,\n\t.requires = \"extconfig,acl,http\",\n);\n"], "filenames": ["main/manager.c"], "buggy_code_start_loc": [3754], "buggy_code_end_loc": [3783], "fixing_code_start_loc": [3755], "fixing_code_end_loc": [3820], "type": "CWE-22", "message": "Asterisk is an open source private branch exchange and telephony toolkit. In Asterisk prior to versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, it is possible to read any arbitrary file even when the `live_dangerously` is not enabled. This allows arbitrary files to be read. Asterisk versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, contain a fix for this issue.", "other": {"cve": {"id": "CVE-2023-49294", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-14T20:15:52.730", "lastModified": "2023-12-29T00:15:49.930", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Asterisk is an open source private branch exchange and telephony toolkit. In Asterisk prior to versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, it is possible to read any arbitrary file even when the `live_dangerously` is not enabled. This allows arbitrary files to be read. Asterisk versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, contain a fix for this issue."}, {"lang": "es", "value": "Asterisk es un conjunto de herramientas de telefon\u00eda y centralita privada de c\u00f3digo abierto. En Asterisk anterior a las versiones 18.20.1, 20.5.1 y 21.0.1, as\u00ed como en Certified-Asterisco anterior a 18.9-cert6, es posible leer cualquier archivo arbitrario incluso cuando `live_dangerfully` no est\u00e1 habilitado. Esto permite leer archivos arbitrarios. Las versiones de Asterisk 18.20.1, 20.5.1 y 21.0.1, as\u00ed como el asterisco certificado anterior a 18.9-cert6, contienen una soluci\u00f3n para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:*:*:*:*:*:*:*:*", "versionEndExcluding": "18.20.1", "matchCriteriaId": "A49E9157-3440-47C5-B730-B1F3BE7240C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "19.0.0", "versionEndExcluding": "20.5.1", "matchCriteriaId": "FCA06EB6-E31A-43B2-A750-186255114B8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:21.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D3E690E3-3E92-42ED-87DD-1C6B838A3FF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:*:*:*:*:*:*:*", "matchCriteriaId": "2AFE2011-05AA-45A6-A561-65C6C664DA7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "C1117AA4-CE6B-479B-9995-A9F71C430663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc1:*:*:*:*:*:*", "matchCriteriaId": "775041BD-5C86-42B6-8B34-E1D5171B3D87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc2:*:*:*:*:*:*", "matchCriteriaId": "55EC2877-2FF5-4777-B118-E764A94BCE56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc3:*:*:*:*:*:*", "matchCriteriaId": "EB0392C9-A5E9-4D71-8B8D-63FB96E055A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc4:*:*:*:*:*:*", "matchCriteriaId": "09AF962D-D4BB-40BA-B435-A59E4402931C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "559D1063-7F37-44F8-B5C6-94758B675FDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "185B2B4B-B246-4379-906B-9BDA7CDD4400"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "73D3592D-3CE5-4462-9FE8-4BCB54E74B5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B3CCE9E0-5DC4-43A2-96DB-9ABEA60EC157"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "1EAD713A-CBA2-40C3-9DE3-5366827F18C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "A5F5A8B7-29C9-403C-9561-7B3E96F9FCA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert10:*:*:*:*:*:*", "matchCriteriaId": "F9B96A53-2263-463C-9CCA-0F29865FE500"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert11:*:*:*:*:*:*", "matchCriteriaId": "A53049F1-8551-453E-834A-68826A7AA959"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert12:*:*:*:*:*:*", "matchCriteriaId": "B224A4E9-4B6B-4187-B0D6-E4BAE2637960"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "9501DBFF-516D-4F26-BBF6-1B453EE2A630"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "9D3E9AC0-C0B4-4E87-8D48-2B688D28B678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert4:*:*:*:*:*:*", "matchCriteriaId": "1A8628F6-F8D1-4C0C-BD89-8E2EEF19A5F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert5:*:*:*:*:*:*", "matchCriteriaId": "E27A6FD1-9321-4C9E-B32B-D6330CD3DC92"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert6:*:*:*:*:*:*", "matchCriteriaId": "B6BF5EDB-9D17-453D-A22E-FDDC4DCDD85B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert7:*:*:*:*:*:*", "matchCriteriaId": "4C75A21E-5D05-434B-93DE-8DAC4DD3E587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert8:*:*:*:*:*:*", "matchCriteriaId": "1D725758-C9F5-4DB2-8C45-CC052518D3FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert9:*:*:*:*:*:*", "matchCriteriaId": "B5E2AECC-B681-4EA5-9DE5-2086BB37A5F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert1:*:*:*:*:*:*", "matchCriteriaId": "79EEB5E5-B79E-454B-8DCD-3272BA337A9E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert2:*:*:*:*:*:*", "matchCriteriaId": "892BAE5D-A64E-4FE0-9A99-8C07F342A042"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert3:*:*:*:*:*:*", "matchCriteriaId": "1A716A45-7075-4CA6-9EF5-2DD088248A5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert4:*:*:*:*:*:*", "matchCriteriaId": "80EFA05B-E22D-49CE-BDD6-5C7123F1C12B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert5:*:*:*:*:*:*", "matchCriteriaId": "20FD475F-2B46-47C9-B535-1561E29CB7A1"}]}]}], "references": [{"url": "https://github.com/asterisk/asterisk/blob/master/main/manager.c#L3757", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/asterisk/asterisk/commit/424be345639d75c6cb7d0bd2da5f0f407dbd0bd5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/asterisk/asterisk/security/advisories/GHSA-8857-hfmw-vg8f", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/12/msg00019.html", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/asterisk/asterisk/commit/424be345639d75c6cb7d0bd2da5f0f407dbd0bd5"}}