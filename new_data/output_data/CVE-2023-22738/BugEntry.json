{"buggy_code": ["# -*- coding: utf-8 -*-\nimport logging\nimport sqlalchemy.exc\n\nfrom http import HTTPStatus\nfrom flask import g, request\nfrom flask_restful import reqparse\n\nfrom vantage6.common import logger_name\nfrom vantage6.server import db\nfrom vantage6.server.permission import (\n    Scope as S,\n    Operation as P,\n    PermissionManager\n)\nfrom vantage6.server.resource import (\n    with_user,\n    ServicesResources\n)\nfrom vantage6.server.resource.pagination import Pagination\nfrom vantage6.server.resource.common._schema import UserSchema\n\n\nmodule_name = logger_name(__name__)\nlog = logging.getLogger(module_name)\n\n\ndef setup(api, api_base, services):\n    path = \"/\".join([api_base, module_name])\n    log.info(f'Setting up \"{path}\" and subdirectories')\n\n    api.add_resource(\n        Users,\n        path,\n        endpoint='user_without_id',\n        methods=('GET', 'POST'),\n        resource_class_kwargs=services\n    )\n    api.add_resource(\n        User,\n        path + '/<int:id>',\n        endpoint='user_with_id',\n        methods=('GET', 'PATCH', 'DELETE'),\n        resource_class_kwargs=services\n    )\n\n\n# ------------------------------------------------------------------------------\n# Permissions\n# ------------------------------------------------------------------------------\ndef permissions(permissions: PermissionManager):\n    add = permissions.appender(module_name)\n    add(S.GLOBAL, P.VIEW,\n        description='View any user')\n    add(S.ORGANIZATION, P.VIEW,\n        description='View users from your organization')\n    add(S.GLOBAL, P.CREATE,\n        description='Create a new user for any organization')\n    add(S.ORGANIZATION, P.CREATE,\n        description='Create a new user for your organization')\n    add(S.GLOBAL, P.EDIT,\n        description='Edit any user')\n    add(S.ORGANIZATION, P.EDIT,\n        description='Edit users from your organization')\n    add(S.OWN, P.EDIT,\n        description='Edit your own info')\n    add(S.GLOBAL, P.DELETE,\n        description='Delete any user')\n    add(S.ORGANIZATION, P.DELETE,\n        description='Delete users from your organization')\n    add(S.OWN, P.DELETE,\n        description='Delete your own account')\n\n\n# ------------------------------------------------------------------------------\n# Resources / API's\n# ------------------------------------------------------------------------------\nuser_schema = UserSchema()\n\n\nclass UserBase(ServicesResources):\n\n    def __init__(self, socketio, mail, api, permissions, config):\n        super().__init__(socketio, mail, api, permissions, config)\n        self.r = getattr(self.permissions, module_name)\n\n\nclass Users(UserBase):\n\n    @with_user\n    def get(self):\n        \"\"\"List users\n        ---\n        description: >-\n            Returns a list of users that you are allowed to see.\n\n            ### Permission Table\\n\n            |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n            Description|\\n\n            |--|--|--|--|--|--|\\n\n            |User|Global|View|\u274c|\u274c|View any user details|\\n\n            |User|Organization|View|\u274c|\u274c|View users from your organization|\\n\n\n            Accessible to users.\n\n        parameters:\n          - in: query\n            name: username\n            schema:\n              type: string\n            description: >-\n              Name to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: organization_id\n            schema:\n              type: integer\n            description: Organization id\n          - in: query\n            name: firstname\n            schema:\n              type: string\n            description: >-\n              Name to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: lastname\n            schema:\n              type: string\n            description: >-\n              Name to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: email\n            schema:\n              type: string\n            description: >-\n              Email to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: role_id\n            schema:\n              type: integer\n            description: Role that is assigned to user\n          - in: query\n            name: rule_id\n            schema:\n              type: integer\n            description: Rule that is assigned to user\n          - in: query\n            name: last_seen_from\n            schema:\n              type: date (yyyy-mm-dd)\n            description: Show only users seen since this date\n          - in: query\n            name: last_seen_till\n            schema:\n              type: date (yyyy-mm-dd)\n            description: Show only users last seen before this date\n          - in: query\n            name: include\n            schema:\n              type: string\n            description: Include 'metadata' to get pagination metadata. Note\n              that this will put the actual data in an envelope.\n          - in: query\n            name: page\n            schema:\n              type: integer\n            description: Page number for pagination\n          - in: query\n            name: per_page\n            schema:\n              type: integer\n            description: Number of items per page\n\n        responses:\n          200:\n            description: Ok\n          401:\n            description: Unauthorized\n\n        security:\n            - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        args = request.args\n        q = g.session.query(db.User)\n\n        # filter by any field of this endpoint\n        for param in ['username', 'firstname', 'lastname', 'email']:\n            if param in args:\n                q = q.filter(getattr(db.User, param).like(args[param]))\n        if 'organization_id' in args:\n            q = q.filter(db.User.organization_id == args['organization_id'])\n        if 'last_seen_till' in args:\n            q = q.filter(db.User.last_seen <= args['last_seen_till'])\n        if 'last_seen_from' in args:\n            q = q.filter(db.User.last_seen >= args['last_seen_from'])\n\n        # find users with a particulare role or rule assigned\n        if 'role_id' in args:\n            q = q.join(db.Permission).join(db.Role)\\\n                 .filter(db.Role.id == args['role_id'])\n        if 'rule_id' in args:\n            q = q.join(db.UserPermission).join(db.Rule)\\\n                 .filter(db.Rule.id == args['rule_id'])\n\n        # check permissions and apply filter if neccessary\n        if not self.r.v_glo.can():\n            if self.r.v_org.can():\n                q = q.filter(db.User.organization_id == g.user.organization_id)\n            else:\n                return {'msg': 'You lack the permission to do that!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n        # paginate results\n        page = Pagination.from_query(q, request)\n\n        # model serialization\n        return self.response(page, user_schema)\n\n    @with_user\n    def post(self):\n        \"\"\"Create user\n        ---\n        description: >-\n          Creates new user from the request data to the users organization.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |User|Global|Create|\u274c|\u274c|Create a new user|\\n\n          |User|Organization|Create|\u274c|\u274c|Create a new user as part of your\n          organization|\\n\n\n          Accessible to users.\n\n        requestBody:\n          content:\n            application/json:\n              schema:\n                properties:\n                  username:\n                    type: string\n                    description: Unique username\n                  firstname:\n                    type: string\n                    description: First name\n                  lastname:\n                    type: string\n                    description: Last name\n                  password:\n                    type: string\n                    description: Password\n                  organization_id:\n                    type: integer\n                    description: Organization id to which user is assigned\n                  roles:\n                    type: array\n                    items:\n                      type: integer\n                    description: User's roles\n                  rules:\n                    type: array\n                    items:\n                      type: integer\n                    description: Extra rules for the user on top of the roles\n                  email:\n                    type: string\n                    description: Email address\n\n        responses:\n          201:\n            description: Ok\n          400:\n            description: Username or email already exists\n          401:\n            description: Unauthorized\n          404:\n            description: Organization id does not exist\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        parser = reqparse.RequestParser()\n        parser.add_argument(\"username\", type=str, required=True)\n        parser.add_argument(\"firstname\", type=str, required=True)\n        parser.add_argument(\"lastname\", type=str, required=True)\n        # TODO password should be send to the email, rather than setting it\n        parser.add_argument(\"password\", type=str, required=True)\n        parser.add_argument(\"email\", type=str, required=True)\n        parser.add_argument(\"organization_id\", type=int, required=False,\n                            help=\"This is only used if you're root\")\n        parser.add_argument(\"roles\", type=int, action=\"append\", required=False)\n        parser.add_argument(\"rules\", type=int, action=\"append\", required=False)\n        data = parser.parse_args()\n\n        # check unique constraints\n        if db.User.username_exists(data[\"username\"]):\n            return {\"msg\": \"username already exists.\"}, HTTPStatus.BAD_REQUEST\n\n        if db.User.exists(\"email\", data[\"email\"]):\n            return {\"msg\": \"email already exists.\"}, HTTPStatus.BAD_REQUEST\n\n        # check if the organization has been provided, if this is the case the\n        # user needs global permissions in case it is not their own\n        organization_id = g.user.organization_id\n        if data['organization_id']:\n            if data['organization_id'] != organization_id:\n                if self.r.c_glo.can():\n                    # check if organization exists\n                    org = db.Organization.get(data['organization_id'])\n                    if not org:\n                        return {'msg': \"Organization does not exist.\"}, \\\n                            HTTPStatus.NOT_FOUND\n                else:  # not-root user cant create users for other organization\n                    return {'msg': 'You lack the permission to do that!'}, \\\n                        HTTPStatus.UNAUTHORIZED\n            organization_id = data['organization_id']\n\n        # check that user is allowed to create users\n        if not (self.r.c_glo.can() or self.r.c_org.can()):\n            return {'msg': 'You lack the permission to do that!'}, \\\n                HTTPStatus.UNAUTHORIZED\n\n        # process the required roles. It is only possible to assign roles with\n        # rules that you already have permission to. This way we ensure you can\n        # never extend your power on your own.\n        potential_roles = data.get(\"roles\")\n        roles = []\n        if potential_roles:\n            for role in potential_roles:\n                role_ = db.Role.get(role)\n                if role_:\n                    denied = self.permissions.verify_user_rules(role_.rules)\n                    if denied:\n                        return denied, HTTPStatus.UNAUTHORIZED\n                    roles.append(role_)\n\n                    # validate that the assigned role is either a general role\n                    # or a role pertaining to that organization\n                    if (role_.organization and\n                            role_.organization.id != organization_id):\n                        return {'msg': (\n                            \"You can't assign that role as the role belongs to\"\n                            \" a different organization than the user.\"\n                        )}, HTTPStatus.UNAUTHORIZED\n\n        # You can only assign rules that you already have to others.\n        potential_rules = data[\"rules\"]\n        rules = []\n        if potential_rules:\n            rules = [db.Rule.get(rule) for rule in potential_rules\n                     if db.Rule.get(rule)]\n            denied = self.permissions.verify_user_rules(rules)\n            if denied:\n                return denied, HTTPStatus.UNAUTHORIZED\n\n        # Ok, looks like we got most of the security hazards out of the way\n        user = db.User(\n            username=data[\"username\"],\n            firstname=data[\"firstname\"],\n            lastname=data[\"lastname\"],\n            roles=roles,\n            rules=rules,\n            organization_id=organization_id,\n            email=data[\"email\"],\n            password=data[\"password\"]\n        )\n\n        # check if the password meets password criteria\n        msg = user.set_password(data[\"password\"])\n        if msg:\n            return {\"msg\": msg}, HTTPStatus.BAD_REQUEST\n\n        user.save()\n\n        return user_schema.dump(user).data, HTTPStatus.CREATED\n\n\nclass User(UserBase):\n\n    @with_user\n    def get(self, id):\n        \"\"\"Get user\n        ---\n        description: >-\n            Returns the user specified by the id.\\n\n\n            ### Permission Table\\n\n            |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n            Description|\\n\n            |-- |--|--|--|--|--|\\n\n            |User|Global|View|\u274c|\u274c|View any user details|\\n\n            |User|Organization|View|\u274c|\u274c|View users from your\n            organization|\\n\n            |User|Organization|Own|\u274c|\u274c|View details about your own user|\\n\n\n            Accessible to users.\n\n        parameters:\n            - in: path\n              name: id\n              schema:\n                type: integer\n              description: User id\n              required: true\n\n        responses:\n            200:\n                description: Ok\n            404:\n                description: User not found\n            401:\n                description: Unauthorized\n\n        security:\n            - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        user = db.User.get(id)\n        if not user:\n            return {\"msg\": f\"user id={id} is not found\"}, HTTPStatus.NOT_FOUND\n\n        same_user = g.user.id == user.id\n        same_org = g.user.organization.id == user.organization_id\n\n        # allow user to be returned if:\n        # 1. auth can see all users\n        # 2. auth can see organization users and user is within organization\n        # 3. auth is requesting own user details\n        if (\n            self.r.v_glo.can() or\n            (self.r.v_org.can() and same_org) or\n            same_user\n        ):\n            return user_schema.dump(user, many=False).data, HTTPStatus.OK\n        else:\n            return {'msg': 'You lack the permission to do that!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n    @with_user\n    def patch(self, id):\n        \"\"\"Update user\n        ---\n        description: >-\n          Update user information.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |User|Global|Edit|\u274c|\u274c|Edit any user|\\n\n          |User|Organization|Edit|\u274c|\u274c|Edit any user in your organization|\\n\n          |User|Own|Edit|\u274c|\u274c|Edit your own user account|\\n\n\n          Accessible to users.\n\n        requestBody:\n          content:\n            application/json:\n              schema:\n                properties:\n                  username:\n                    type: string\n                    description: Unique username\n                  firstname:\n                    type: string\n                    description: First name\n                  lastname:\n                    type: string\n                    description: Last name\n                  email:\n                    type: string\n                    description: Email address\n                  roles:\n                    type: array\n                    items:\n                      type: integer\n                    description: User's roles\n                  rules:\n                    type: array\n                    items:\n                      type: integer\n                    description: Extra rules for the user on top of the roles\n                  organization_id:\n                    type: integer\n                    description: Organization id of the user\n\n        parameters:\n          - in: path\n            name: id\n            schema:\n              type: integer\n            description: User id\n            required: true\n\n        responses:\n          200:\n            description: Ok\n          400:\n            description: User cannot be updated to contents of request body,\n              e.g. due to duplicate email address.\n          404:\n            description: User not found\n          401:\n            description: Unauthorized\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        user = db.User.get(id)\n\n        if not user:\n            return {\"msg\": f\"user id={id} not found\"}, \\\n                HTTPStatus.NOT_FOUND\n\n        if not self.r.e_glo.can():\n            if not (self.r.e_org.can() and user.organization ==\n                    g.user.organization):\n                if not (self.r.e_own.can() and user == g.user):\n                    return {'msg': 'You lack the permission to do that!'}, \\\n                        HTTPStatus.UNAUTHORIZED\n\n        parser = reqparse.RequestParser()\n        parser.add_argument(\"username\", type=str, required=False)\n        parser.add_argument(\"firstname\", type=str, required=False)\n        parser.add_argument(\"lastname\", type=str, required=False)\n        parser.add_argument(\"email\", type=str, required=False)\n        parser.add_argument(\"organization_id\", type=int, required=False)\n        data = parser.parse_args()\n\n        # check if user defined a password, which is deprecated\n        # FIXME BvB 22-06-29: with time, this check may be removed. Now it is\n        # here for backwards compatibility (if people have scripts using this,\n        # this makes them aware something changed)\n        request_json = request.get_json()\n        if request_json.get(\"password\"):\n            return {\"msg\": \"You cannot change your password here!\"}, \\\n                HTTPStatus.BAD_REQUEST\n\n        if data[\"username\"] is not None:\n            if data[\"username\"] == '':\n                return {\n                    \"msg\": \"Empty username is not allowed!\"\n                }, HTTPStatus.BAD_REQUEST\n            elif user.username != data[\"username\"]:\n                if db.User.exists(\"username\", data[\"username\"]):\n                    return {\n                        \"msg\": \"User with that username already exists\"\n                    }, HTTPStatus.BAD_REQUEST\n                elif user.id != g.user.id:\n                    return {\n                        \"msg\": \"You cannot change the username of another user\"\n                    }, HTTPStatus.BAD_REQUEST\n            user.username = data[\"username\"]\n        if data[\"firstname\"] is not None:\n            user.firstname = data[\"firstname\"]\n        if data[\"lastname\"] is not None:\n            user.lastname = data[\"lastname\"]\n        if data[\"email\"] is not None:\n            if data[\"email\"] == '':\n                return {\n                    \"msg\": \"Empty email is not allowed!\"\n                }, HTTPStatus.BAD_REQUEST\n            elif (user.email != data[\"email\"] and\n                    db.User.exists(\"email\", data[\"email\"])):\n                return {\n                    \"msg\": \"User with that email already exists.\"\n                }, HTTPStatus.BAD_REQUEST\n            user.email = data[\"email\"]\n\n        # request parser is awefull with lists\n        json_data = request.get_json()\n        if 'roles' in json_data:\n            # validate that these roles exist\n            roles = []\n            for role_id in json_data['roles']:\n                role = db.Role.get(role_id)\n                if not role:\n                    return {'msg': f'Role={role_id} can not be found!'}, \\\n                        HTTPStatus.NOT_FOUND\n                roles.append(role)\n\n            # validate that user is not changing their own roles\n            if user == g.user:\n                return {'msg': \"You can't changes your own roles!\"}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n            # validate that user can assign these\n            for role in roles:\n                denied = self.permissions.verify_user_rules(role.rules)\n                if denied:\n                    return denied, HTTPStatus.UNAUTHORIZED\n\n                # validate that the assigned role is either a general role or a\n                # role pertaining to that organization\n                if (role.organization and\n                        role.organization.id != user.organization_id):\n                    return {'msg': (\n                        \"You can't assign that role to that user as the role \"\n                        \"belongs to a different organization than the user \"\n                    )}, HTTPStatus.UNAUTHORIZED\n\n            # validate that user is not deleting roles they cannot assign\n            # e.g. an organization admin is not allowed to delete a root role\n            deleted_roles = [r for r in user.roles if r not in roles]\n            for role in deleted_roles:\n                denied = self.permissions.verify_user_rules(role.rules)\n                if denied:\n                    return {\"msg\": (\n                        f\"You are trying to delete the role {role.name} from \"\n                        \"this user but that is not allowed because they have \"\n                        f\"permissions you don't have: {denied['msg']} (and \"\n                        \"they do!)\"\n                    )}, HTTPStatus.UNAUTHORIZED\n\n            user.roles = roles\n\n        if 'rules' in json_data:\n            # validate that these rules exist\n            rules = []\n            for rule_id in json_data['rules']:\n                rule = db.Rule.get(rule_id)\n                if not rule:\n                    return {'msg': f'Rule={rule_id} can not be found!'}, \\\n                        HTTPStatus.NOT_FOUND\n                rules.append(rule)\n\n            # validate that user is not changing their own rules\n            if user == g.user:\n                return {'msg': \"You can't changes your own rules!\"}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n            # validate that user can assign these\n            denied = self.permissions.verify_user_rules(rules)\n            if denied:\n                return denied, HTTPStatus.UNAUTHORIZED\n\n            # validate that user is not deleting rules they do not have\n            # themselves\n            deleted_rules = [r for r in user.rules if r not in rules]\n            denied = self.permissions.verify_user_rules(deleted_rules)\n            if denied:\n                return {\"msg\": (\n                    f\"{denied['msg']}. You can't delete permissions for \"\n                    \"another user that you don't have yourself!\"\n                )}, HTTPStatus.UNAUTHORIZED\n\n            user.rules = rules\n\n        if data[\"organization_id\"] and \\\n                data[\"organization_id\"] != g.user.organization_id:\n            if not self.r.e_glo.can():\n                return {'msg': 'You lack the permission to do that!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            else:\n                # check that newly assigned organization exists\n                org = db.Organization.get(data['organization_id'])\n                if not org:\n                    return {'msg': 'Organization does not exist.'}, \\\n                        HTTPStatus.NOT_FOUND\n                else:\n                    log.warn(\n                        f'Running as root and assigning (new) '\n                        f'organization_id={data[\"organization_id\"]}'\n                    )\n                    user.organization_id = data[\"organization_id\"]\n\n        try:\n            user.save()\n        except sqlalchemy.exc.IntegrityError as e:\n            log.error(e)\n            user.session.rollback()\n            return {\n                \"msg\": \"User could not be updated with those parameters.\"\n            }, HTTPStatus.BAD_REQUEST\n            # TODO BvB 2021-08-27 return msg that user was not updated?\n\n        return user_schema.dump(user).data, HTTPStatus.OK\n\n    @with_user\n    def delete(self, id):\n        \"\"\"Remove user.\n        ---\n        description: >-\n          Delete a user account permanently.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |User|Global|Delete|\u274c|\u274c|Delete any user|\\n\n          |User|Organization|Delete|\u274c|\u274c|Delete users from your\n          organization|\\n\n          |User|Own|Delete|\u274c|\u274c|Delete your own account|\\n\n\n          Accessible to users.\n\n        parameters:\n          - in: path\n            name: id\n            schema:\n              type: integer\n            description: User id\n            required: true\n\n        responses:\n          200:\n            description: Ok\n          404:\n            description: User not found\n          401:\n            description: Unauthorized\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        user = db.User.get(id)\n        if not user:\n            return {\"msg\": f\"user id={id} not found\"}, \\\n                HTTPStatus.NOT_FOUND\n\n        if not self.r.d_glo.can():\n            if not (self.r.d_org.can() and user.organization ==\n                    g.user.organization):\n                if not (self.r.d_own.can() and user == g.user):\n                    return {'msg': 'You lack the permission to do that!'}, \\\n                        HTTPStatus.UNAUTHORIZED\n\n        user.delete()\n        log.info(f\"user id={id} is removed from the database\")\n        return {\"msg\": f\"user id={id} is removed from the database\"}, \\\n            HTTPStatus.OK\n"], "fixing_code": ["# -*- coding: utf-8 -*-\nimport logging\nimport sqlalchemy.exc\n\nfrom http import HTTPStatus\nfrom flask import g, request\nfrom flask_restful import reqparse\n\nfrom vantage6.common import logger_name\nfrom vantage6.server import db\nfrom vantage6.server.permission import (\n    Scope as S,\n    Operation as P,\n    PermissionManager\n)\nfrom vantage6.server.resource import (\n    with_user,\n    ServicesResources\n)\nfrom vantage6.server.resource.pagination import Pagination\nfrom vantage6.server.resource.common._schema import UserSchema\n\n\nmodule_name = logger_name(__name__)\nlog = logging.getLogger(module_name)\n\n\ndef setup(api, api_base, services):\n    path = \"/\".join([api_base, module_name])\n    log.info(f'Setting up \"{path}\" and subdirectories')\n\n    api.add_resource(\n        Users,\n        path,\n        endpoint='user_without_id',\n        methods=('GET', 'POST'),\n        resource_class_kwargs=services\n    )\n    api.add_resource(\n        User,\n        path + '/<int:id>',\n        endpoint='user_with_id',\n        methods=('GET', 'PATCH', 'DELETE'),\n        resource_class_kwargs=services\n    )\n\n\n# ------------------------------------------------------------------------------\n# Permissions\n# ------------------------------------------------------------------------------\ndef permissions(permissions: PermissionManager):\n    add = permissions.appender(module_name)\n    add(S.GLOBAL, P.VIEW,\n        description='View any user')\n    add(S.ORGANIZATION, P.VIEW,\n        description='View users from your organization')\n    add(S.GLOBAL, P.CREATE,\n        description='Create a new user for any organization')\n    add(S.ORGANIZATION, P.CREATE,\n        description='Create a new user for your organization')\n    add(S.GLOBAL, P.EDIT,\n        description='Edit any user')\n    add(S.ORGANIZATION, P.EDIT,\n        description='Edit users from your organization')\n    add(S.OWN, P.EDIT,\n        description='Edit your own info')\n    add(S.GLOBAL, P.DELETE,\n        description='Delete any user')\n    add(S.ORGANIZATION, P.DELETE,\n        description='Delete users from your organization')\n    add(S.OWN, P.DELETE,\n        description='Delete your own account')\n\n\n# ------------------------------------------------------------------------------\n# Resources / API's\n# ------------------------------------------------------------------------------\nuser_schema = UserSchema()\n\n\nclass UserBase(ServicesResources):\n\n    def __init__(self, socketio, mail, api, permissions, config):\n        super().__init__(socketio, mail, api, permissions, config)\n        self.r = getattr(self.permissions, module_name)\n\n\nclass Users(UserBase):\n\n    @with_user\n    def get(self):\n        \"\"\"List users\n        ---\n        description: >-\n            Returns a list of users that you are allowed to see.\n\n            ### Permission Table\\n\n            |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n            Description|\\n\n            |--|--|--|--|--|--|\\n\n            |User|Global|View|\u274c|\u274c|View any user details|\\n\n            |User|Organization|View|\u274c|\u274c|View users from your organization|\\n\n\n            Accessible to users.\n\n        parameters:\n          - in: query\n            name: username\n            schema:\n              type: string\n            description: >-\n              Name to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: organization_id\n            schema:\n              type: integer\n            description: Organization id\n          - in: query\n            name: firstname\n            schema:\n              type: string\n            description: >-\n              Name to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: lastname\n            schema:\n              type: string\n            description: >-\n              Name to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: email\n            schema:\n              type: string\n            description: >-\n              Email to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: role_id\n            schema:\n              type: integer\n            description: Role that is assigned to user\n          - in: query\n            name: rule_id\n            schema:\n              type: integer\n            description: Rule that is assigned to user\n          - in: query\n            name: last_seen_from\n            schema:\n              type: date (yyyy-mm-dd)\n            description: Show only users seen since this date\n          - in: query\n            name: last_seen_till\n            schema:\n              type: date (yyyy-mm-dd)\n            description: Show only users last seen before this date\n          - in: query\n            name: include\n            schema:\n              type: string\n            description: Include 'metadata' to get pagination metadata. Note\n              that this will put the actual data in an envelope.\n          - in: query\n            name: page\n            schema:\n              type: integer\n            description: Page number for pagination\n          - in: query\n            name: per_page\n            schema:\n              type: integer\n            description: Number of items per page\n\n        responses:\n          200:\n            description: Ok\n          401:\n            description: Unauthorized\n\n        security:\n            - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        args = request.args\n        q = g.session.query(db.User)\n\n        # filter by any field of this endpoint\n        for param in ['username', 'firstname', 'lastname', 'email']:\n            if param in args:\n                q = q.filter(getattr(db.User, param).like(args[param]))\n        if 'organization_id' in args:\n            q = q.filter(db.User.organization_id == args['organization_id'])\n        if 'last_seen_till' in args:\n            q = q.filter(db.User.last_seen <= args['last_seen_till'])\n        if 'last_seen_from' in args:\n            q = q.filter(db.User.last_seen >= args['last_seen_from'])\n\n        # find users with a particulare role or rule assigned\n        if 'role_id' in args:\n            q = q.join(db.Permission).join(db.Role)\\\n                 .filter(db.Role.id == args['role_id'])\n        if 'rule_id' in args:\n            q = q.join(db.UserPermission).join(db.Rule)\\\n                 .filter(db.Rule.id == args['rule_id'])\n\n        # check permissions and apply filter if neccessary\n        if not self.r.v_glo.can():\n            if self.r.v_org.can():\n                q = q.filter(db.User.organization_id == g.user.organization_id)\n            else:\n                return {'msg': 'You lack the permission to do that!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n        # paginate results\n        page = Pagination.from_query(q, request)\n\n        # model serialization\n        return self.response(page, user_schema)\n\n    @with_user\n    def post(self):\n        \"\"\"Create user\n        ---\n        description: >-\n          Creates new user from the request data to the users organization.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |User|Global|Create|\u274c|\u274c|Create a new user|\\n\n          |User|Organization|Create|\u274c|\u274c|Create a new user as part of your\n          organization|\\n\n\n          Accessible to users.\n\n        requestBody:\n          content:\n            application/json:\n              schema:\n                properties:\n                  username:\n                    type: string\n                    description: Unique username\n                  firstname:\n                    type: string\n                    description: First name\n                  lastname:\n                    type: string\n                    description: Last name\n                  password:\n                    type: string\n                    description: Password\n                  organization_id:\n                    type: integer\n                    description: Organization id to which user is assigned\n                  roles:\n                    type: array\n                    items:\n                      type: integer\n                    description: User's roles\n                  rules:\n                    type: array\n                    items:\n                      type: integer\n                    description: Extra rules for the user on top of the roles\n                  email:\n                    type: string\n                    description: Email address\n\n        responses:\n          201:\n            description: Ok\n          400:\n            description: Username or email already exists\n          401:\n            description: Unauthorized\n          404:\n            description: Organization id does not exist\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        parser = reqparse.RequestParser()\n        parser.add_argument(\"username\", type=str, required=True)\n        parser.add_argument(\"firstname\", type=str, required=True)\n        parser.add_argument(\"lastname\", type=str, required=True)\n        # TODO password should be send to the email, rather than setting it\n        parser.add_argument(\"password\", type=str, required=True)\n        parser.add_argument(\"email\", type=str, required=True)\n        parser.add_argument(\"organization_id\", type=int, required=False,\n                            help=\"This is only used if you're root\")\n        parser.add_argument(\"roles\", type=int, action=\"append\", required=False)\n        parser.add_argument(\"rules\", type=int, action=\"append\", required=False)\n        data = parser.parse_args()\n\n        # check unique constraints\n        if db.User.username_exists(data[\"username\"]):\n            return {\"msg\": \"username already exists.\"}, HTTPStatus.BAD_REQUEST\n\n        if db.User.exists(\"email\", data[\"email\"]):\n            return {\"msg\": \"email already exists.\"}, HTTPStatus.BAD_REQUEST\n\n        # check if the organization has been provided, if this is the case the\n        # user needs global permissions in case it is not their own\n        organization_id = g.user.organization_id\n        if data['organization_id']:\n            if data['organization_id'] != organization_id:\n                if self.r.c_glo.can():\n                    # check if organization exists\n                    org = db.Organization.get(data['organization_id'])\n                    if not org:\n                        return {'msg': \"Organization does not exist.\"}, \\\n                            HTTPStatus.NOT_FOUND\n                else:  # not-root user cant create users for other organization\n                    return {'msg': 'You lack the permission to do that!'}, \\\n                        HTTPStatus.UNAUTHORIZED\n            organization_id = data['organization_id']\n\n        # check that user is allowed to create users\n        if not (self.r.c_glo.can() or self.r.c_org.can()):\n            return {'msg': 'You lack the permission to do that!'}, \\\n                HTTPStatus.UNAUTHORIZED\n\n        # process the required roles. It is only possible to assign roles with\n        # rules that you already have permission to. This way we ensure you can\n        # never extend your power on your own.\n        potential_roles = data.get(\"roles\")\n        roles = []\n        if potential_roles:\n            for role in potential_roles:\n                role_ = db.Role.get(role)\n                if role_:\n                    denied = self.permissions.verify_user_rules(role_.rules)\n                    if denied:\n                        return denied, HTTPStatus.UNAUTHORIZED\n                    roles.append(role_)\n\n                    # validate that the assigned role is either a general role\n                    # or a role pertaining to that organization\n                    if (role_.organization and\n                            role_.organization.id != organization_id):\n                        return {'msg': (\n                            \"You can't assign that role as the role belongs to\"\n                            \" a different organization than the user.\"\n                        )}, HTTPStatus.UNAUTHORIZED\n\n        # You can only assign rules that you already have to others.\n        potential_rules = data[\"rules\"]\n        rules = []\n        if potential_rules:\n            rules = [db.Rule.get(rule) for rule in potential_rules\n                     if db.Rule.get(rule)]\n            denied = self.permissions.verify_user_rules(rules)\n            if denied:\n                return denied, HTTPStatus.UNAUTHORIZED\n\n        # Ok, looks like we got most of the security hazards out of the way\n        user = db.User(\n            username=data[\"username\"],\n            firstname=data[\"firstname\"],\n            lastname=data[\"lastname\"],\n            roles=roles,\n            rules=rules,\n            organization_id=organization_id,\n            email=data[\"email\"],\n            password=data[\"password\"]\n        )\n\n        # check if the password meets password criteria\n        msg = user.set_password(data[\"password\"])\n        if msg:\n            return {\"msg\": msg}, HTTPStatus.BAD_REQUEST\n\n        user.save()\n\n        return user_schema.dump(user).data, HTTPStatus.CREATED\n\n\nclass User(UserBase):\n\n    @with_user\n    def get(self, id):\n        \"\"\"Get user\n        ---\n        description: >-\n            Returns the user specified by the id.\\n\n\n            ### Permission Table\\n\n            |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n            Description|\\n\n            |-- |--|--|--|--|--|\\n\n            |User|Global|View|\u274c|\u274c|View any user details|\\n\n            |User|Organization|View|\u274c|\u274c|View users from your\n            organization|\\n\n            |User|Organization|Own|\u274c|\u274c|View details about your own user|\\n\n\n            Accessible to users.\n\n        parameters:\n            - in: path\n              name: id\n              schema:\n                type: integer\n              description: User id\n              required: true\n\n        responses:\n            200:\n                description: Ok\n            404:\n                description: User not found\n            401:\n                description: Unauthorized\n\n        security:\n            - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        user = db.User.get(id)\n        if not user:\n            return {\"msg\": f\"user id={id} is not found\"}, HTTPStatus.NOT_FOUND\n\n        same_user = g.user.id == user.id\n        same_org = g.user.organization.id == user.organization_id\n\n        # allow user to be returned if:\n        # 1. auth can see all users\n        # 2. auth can see organization users and user is within organization\n        # 3. auth is requesting own user details\n        if (\n            self.r.v_glo.can() or\n            (self.r.v_org.can() and same_org) or\n            same_user\n        ):\n            return user_schema.dump(user, many=False).data, HTTPStatus.OK\n        else:\n            return {'msg': 'You lack the permission to do that!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n    @with_user\n    def patch(self, id):\n        \"\"\"Update user\n        ---\n        description: >-\n          Update user information.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |User|Global|Edit|\u274c|\u274c|Edit any user|\\n\n          |User|Organization|Edit|\u274c|\u274c|Edit any user in your organization|\\n\n          |User|Own|Edit|\u274c|\u274c|Edit your own user account|\\n\n\n          Accessible to users.\n\n        requestBody:\n          content:\n            application/json:\n              schema:\n                properties:\n                  username:\n                    type: string\n                    description: Unique username\n                  firstname:\n                    type: string\n                    description: First name\n                  lastname:\n                    type: string\n                    description: Last name\n                  email:\n                    type: string\n                    description: Email address\n                  roles:\n                    type: array\n                    items:\n                      type: integer\n                    description: User's roles\n                  rules:\n                    type: array\n                    items:\n                      type: integer\n                    description: Extra rules for the user on top of the roles\n\n        parameters:\n          - in: path\n            name: id\n            schema:\n              type: integer\n            description: User id\n            required: true\n\n        responses:\n          200:\n            description: Ok\n          400:\n            description: User cannot be updated to contents of request body,\n              e.g. due to duplicate email address.\n          404:\n            description: User not found\n          401:\n            description: Unauthorized\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        user = db.User.get(id)\n\n        if not user:\n            return {\"msg\": f\"user id={id} not found\"}, \\\n                HTTPStatus.NOT_FOUND\n\n        if not self.r.e_glo.can():\n            if not (self.r.e_org.can() and user.organization ==\n                    g.user.organization):\n                if not (self.r.e_own.can() and user == g.user):\n                    return {'msg': 'You lack the permission to do that!'}, \\\n                        HTTPStatus.UNAUTHORIZED\n\n        parser = reqparse.RequestParser()\n        parser.add_argument(\"username\", type=str, required=False)\n        parser.add_argument(\"firstname\", type=str, required=False)\n        parser.add_argument(\"lastname\", type=str, required=False)\n        parser.add_argument(\"email\", type=str, required=False)\n        data = parser.parse_args()\n\n        # check if user defined a password, which is deprecated\n        # FIXME BvB 22-06-29: with time, this check may be removed. Now it is\n        # here for backwards compatibility (if people have scripts using this,\n        # this makes them aware something changed)\n        request_json = request.get_json()\n        if request_json.get(\"password\"):\n            return {\"msg\": \"You cannot change your password here!\"}, \\\n                HTTPStatus.BAD_REQUEST\n\n        if data[\"username\"] is not None:\n            if data[\"username\"] == '':\n                return {\n                    \"msg\": \"Empty username is not allowed!\"\n                }, HTTPStatus.BAD_REQUEST\n            elif user.username != data[\"username\"]:\n                if db.User.exists(\"username\", data[\"username\"]):\n                    return {\n                        \"msg\": \"User with that username already exists\"\n                    }, HTTPStatus.BAD_REQUEST\n                elif user.id != g.user.id:\n                    return {\n                        \"msg\": \"You cannot change the username of another user\"\n                    }, HTTPStatus.BAD_REQUEST\n            user.username = data[\"username\"]\n        if data[\"firstname\"] is not None:\n            user.firstname = data[\"firstname\"]\n        if data[\"lastname\"] is not None:\n            user.lastname = data[\"lastname\"]\n        if data[\"email\"] is not None:\n            if data[\"email\"] == '':\n                return {\n                    \"msg\": \"Empty email is not allowed!\"\n                }, HTTPStatus.BAD_REQUEST\n            elif (user.email != data[\"email\"] and\n                    db.User.exists(\"email\", data[\"email\"])):\n                return {\n                    \"msg\": \"User with that email already exists.\"\n                }, HTTPStatus.BAD_REQUEST\n            user.email = data[\"email\"]\n\n        # request parser is awefull with lists\n        json_data = request.get_json()\n        if 'roles' in json_data:\n            # validate that these roles exist\n            roles = []\n            for role_id in json_data['roles']:\n                role = db.Role.get(role_id)\n                if not role:\n                    return {'msg': f'Role={role_id} can not be found!'}, \\\n                        HTTPStatus.NOT_FOUND\n                roles.append(role)\n\n            # validate that user is not changing their own roles\n            if user == g.user:\n                return {'msg': \"You can't changes your own roles!\"}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n            # validate that user can assign these\n            for role in roles:\n                denied = self.permissions.verify_user_rules(role.rules)\n                if denied:\n                    return denied, HTTPStatus.UNAUTHORIZED\n\n                # validate that the assigned role is either a general role or a\n                # role pertaining to that organization\n                if (role.organization and\n                        role.organization.id != user.organization_id):\n                    return {'msg': (\n                        \"You can't assign that role to that user as the role \"\n                        \"belongs to a different organization than the user \"\n                    )}, HTTPStatus.UNAUTHORIZED\n\n            # validate that user is not deleting roles they cannot assign\n            # e.g. an organization admin is not allowed to delete a root role\n            deleted_roles = [r for r in user.roles if r not in roles]\n            for role in deleted_roles:\n                denied = self.permissions.verify_user_rules(role.rules)\n                if denied:\n                    return {\"msg\": (\n                        f\"You are trying to delete the role {role.name} from \"\n                        \"this user but that is not allowed because they have \"\n                        f\"permissions you don't have: {denied['msg']} (and \"\n                        \"they do!)\"\n                    )}, HTTPStatus.UNAUTHORIZED\n\n            user.roles = roles\n\n        if 'rules' in json_data:\n            # validate that these rules exist\n            rules = []\n            for rule_id in json_data['rules']:\n                rule = db.Rule.get(rule_id)\n                if not rule:\n                    return {'msg': f'Rule={rule_id} can not be found!'}, \\\n                        HTTPStatus.NOT_FOUND\n                rules.append(rule)\n\n            # validate that user is not changing their own rules\n            if user == g.user:\n                return {'msg': \"You can't changes your own rules!\"}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n            # validate that user can assign these\n            denied = self.permissions.verify_user_rules(rules)\n            if denied:\n                return denied, HTTPStatus.UNAUTHORIZED\n\n            # validate that user is not deleting rules they do not have\n            # themselves\n            deleted_rules = [r for r in user.rules if r not in rules]\n            denied = self.permissions.verify_user_rules(deleted_rules)\n            if denied:\n                return {\"msg\": (\n                    f\"{denied['msg']}. You can't delete permissions for \"\n                    \"another user that you don't have yourself!\"\n                )}, HTTPStatus.UNAUTHORIZED\n\n            user.rules = rules\n\n        try:\n            user.save()\n        except sqlalchemy.exc.IntegrityError as e:\n            log.error(e)\n            user.session.rollback()\n            return {\n                \"msg\": \"User could not be updated with those parameters.\"\n            }, HTTPStatus.BAD_REQUEST\n            # TODO BvB 2021-08-27 return msg that user was not updated?\n\n        return user_schema.dump(user).data, HTTPStatus.OK\n\n    @with_user\n    def delete(self, id):\n        \"\"\"Remove user.\n        ---\n        description: >-\n          Delete a user account permanently.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |User|Global|Delete|\u274c|\u274c|Delete any user|\\n\n          |User|Organization|Delete|\u274c|\u274c|Delete users from your\n          organization|\\n\n          |User|Own|Delete|\u274c|\u274c|Delete your own account|\\n\n\n          Accessible to users.\n\n        parameters:\n          - in: path\n            name: id\n            schema:\n              type: integer\n            description: User id\n            required: true\n\n        responses:\n          200:\n            description: Ok\n          404:\n            description: User not found\n          401:\n            description: Unauthorized\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"User\"]\n        \"\"\"\n        user = db.User.get(id)\n        if not user:\n            return {\"msg\": f\"user id={id} not found\"}, \\\n                HTTPStatus.NOT_FOUND\n\n        if not self.r.d_glo.can():\n            if not (self.r.d_org.can() and user.organization ==\n                    g.user.organization):\n                if not (self.r.d_own.can() and user == g.user):\n                    return {'msg': 'You lack the permission to do that!'}, \\\n                        HTTPStatus.UNAUTHORIZED\n\n        user.delete()\n        log.info(f\"user id={id} is removed from the database\")\n        return {\"msg\": f\"user id={id} is removed from the database\"}, \\\n            HTTPStatus.OK\n"], "filenames": ["vantage6-server/vantage6/server/resource/user.py"], "buggy_code_start_loc": [500], "buggy_code_end_loc": [686], "fixing_code_start_loc": [499], "fixing_code_end_loc": [663], "type": "CWE-281", "message": "vantage6 is a privacy preserving federated learning infrastructure for secure insight exchange. Assigning existing users to a different organizations is currently possible. It may lead to unintended access: if a user from organization A is accidentally assigned to organization B, they will retain their permissions and therefore might be able to access stuff they should not be allowed to access. This issue is patched in version 3.8.0.", "other": {"cve": {"id": "CVE-2023-22738", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-01T21:15:10.397", "lastModified": "2023-03-10T17:54:06.240", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vantage6 is a privacy preserving federated learning infrastructure for secure insight exchange. Assigning existing users to a different organizations is currently possible. It may lead to unintended access: if a user from organization A is accidentally assigned to organization B, they will retain their permissions and therefore might be able to access stuff they should not be allowed to access. This issue is patched in version 3.8.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 4.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-281"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-281"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vantage6:vantage6:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.1", "matchCriteriaId": "0C666F00-D4E9-450E-A197-6399C730A425"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vantage6:vantage6:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.7.0", "versionEndIncluding": "3.7.3", "matchCriteriaId": "BB9DA9E7-464C-4C7E-A663-364D95684297"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vantage6:vantage6:3.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "CFB8F275-E306-4985-983A-849D9B33272F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vantage6:vantage6:3.8.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B0A60FDE-7084-4EA3-9DAC-AA14A2FEF767"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vantage6:vantage6:3.8.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "402531F7-2FAA-4324-A423-A63924D09136"}]}]}], "references": [{"url": "https://github.com/vantage6/vantage6/commit/798aca1de142a4eca175ef51112e2235642f4f24", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vantage6/vantage6/security/advisories/GHSA-vvjv-97j8-94xh", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vantage6/vantage6/commit/798aca1de142a4eca175ef51112e2235642f4f24"}}