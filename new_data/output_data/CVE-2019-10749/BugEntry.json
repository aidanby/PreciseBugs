{"buggy_code": ["  'use strict';\n\nvar Utils = require('../../utils')\n  , SqlString = require('../../sql-string')\n  , Model = require('../../model')\n  , DataTypes = require('../../data-types')\n  , _ = require('lodash')\n  , util = require('util')\n  , Dottie = require('dottie')\n  , BelongsTo = require('../../associations/belongs-to')\n  , BelongsToMany = require('../../associations/belongs-to-many')\n  , HasMany = require('../../associations/has-many')\n  , uuid = require('uuid')\n  , semver = require('semver')\n  , deprecate = require('depd')('sequelize');\n\n/* istanbul ignore next */\nvar throwMethodUndefined = function(methodName) {\n  throw new Error('The method \"' + methodName + '\" is not defined! Please add it to your sql dialect.');\n};\n\nvar QueryGenerator = {\n  options: {},\n\n  extractTableDetails: function(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || 'public',\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || '.'\n    };\n  },\n\n  addSchema: function(param) {\n    var self = this;\n\n    if (!param.$schema) return param.tableName || param;\n\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param.$schema,\n      delimiter: param.$schemaDelimiter || '.',\n      toString: function() {\n        return self.quoteTable(this);\n      }\n    };\n  },\n\n  /*\n    Returns a query for dropping a schema\n  */\n  dropSchema: function(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  },\n\n  /*\n    Returns a query for creating a table.\n    Parameters:\n      - tableName: Name of the new table.\n      - attributes: An object with containing attribute-attributeType-pairs.\n                    Attributes should have the format:\n                    {attributeName: type, attr2: type2}\n                    --> e.g. {title: 'VARCHAR(255)'}\n      - options: An object with options.\n                 Defaults: { engine: 'InnoDB', charset: null }\n  */\n  /* istanbul ignore next */\n  createTableQuery: function(tableName, attributes, options) {\n    throwMethodUndefined('createTableQuery');\n  },\n\n  versionQuery: function(tableName, attributes, options) {\n    throwMethodUndefined('versionQuery');\n  },\n\n  describeTableQuery: function(tableName, schema, schemaDelimiter) {\n    var table = this.quoteTable(\n      this.addSchema({\n        tableName: tableName,\n        $schema: schema,\n        $schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return 'DESCRIBE ' + table + ';';\n  },\n\n  /*\n    Returns a query for dropping a table.\n  */\n  dropTableQuery: function(tableName, options) {\n    options = options || {};\n\n    var query = 'DROP TABLE IF EXISTS <%= table %>;';\n\n    return Utils._.template(query)({\n      table: this.quoteTable(tableName)\n    });\n  },\n\n  /*\n    Returns a rename table query.\n    Parameters:\n      - originalTableName: Name of the table before execution.\n      - futureTableName: Name of the table after execution.\n  */\n  renameTableQuery: function(before, after) {\n    var query = 'ALTER TABLE <%= before %> RENAME TO <%= after %>;';\n    return Utils._.template(query)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  },\n\n  /*\n    Returns a query, which gets all available table names in the database.\n  */\n  /* istanbul ignore next */\n  showTablesQuery: function() {\n    throwMethodUndefined('showTablesQuery');\n  },\n\n  /*\n    Returns a query, which adds an attribute to an existing table.\n    Parameters:\n      - tableName: Name of the existing table.\n      - attributes: A hash with attribute-attributeOptions-pairs.\n        - key: attributeName\n        - value: A hash with attribute specific options:\n          - type: DataType\n          - defaultValue: A String with the default value\n          - allowNull: Boolean\n  */\n  /* istanbul ignore next */\n  addColumnQuery: function(tableName, attributes) {\n    throwMethodUndefined('addColumnQuery');\n  },\n\n  /*\n    Returns a query, which removes an attribute from an existing table.\n    Parameters:\n      - tableName: Name of the existing table\n      - attributeName: Name of the obsolete attribute.\n  */\n  /* istanbul ignore next */\n  removeColumnQuery: function(tableName, attributeName) {\n    throwMethodUndefined('removeColumnQuery');\n  },\n\n  /*\n    Returns a query, which modifies an existing attribute from a table.\n    Parameters:\n      - tableName: Name of the existing table.\n      - attributes: A hash with attribute-attributeOptions-pairs.\n        - key: attributeName\n        - value: A hash with attribute specific options:\n          - type: DataType\n          - defaultValue: A String with the default value\n          - allowNull: Boolean\n  */\n  /* istanbul ignore next */\n  changeColumnQuery: function(tableName, attributes) {\n    throwMethodUndefined('changeColumnQuery');\n  },\n\n  /*\n    Returns a query, which renames an existing attribute.\n    Parameters:\n      - tableName: Name of an existing table.\n      - attrNameBefore: The name of the attribute, which shall be renamed.\n      - attrNameAfter: The name of the attribute, after renaming.\n  */\n  /* istanbul ignore next */\n  renameColumnQuery: function(tableName, attrNameBefore, attrNameAfter) {\n    throwMethodUndefined('renameColumnQuery');\n  },\n\n  /*\n    Returns an insert into command. Parameters: table name + hash of attribute-value-pairs.\n  */\n  insertQuery: function(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    var query\n      , valueQuery = '<%= tmpTable %>INSERT<%= ignore %> INTO <%= table %> (<%= attributes %>)<%= output %> VALUES (<%= values %>)'\n      , emptyQuery = '<%= tmpTable %>INSERT<%= ignore %> INTO <%= table %><%= output %>'\n      , outputFragment\n      , fields = []\n      , values = []\n      , key\n      , value\n      , identityWrapperRequired = false\n      , modelAttributeMap = {}\n      , tmpTable = ''         //tmpTable declaration for trigger\n      , selectFromTmp = ''    //Select statement for trigger\n      , tmpColumns = ''       //Columns for temp table for trigger\n      , outputColumns = ''    //Columns to capture into temp table for trigger\n      , attribute             //Model attribute holder\n      , modelKey;             //key for model\n\n    if (modelAttributes) {\n      Utils._.each(modelAttributes, function(attribute, key) {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this._dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this._dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (!!this._dialect.supports.returnValues.returning) {\n        valueQuery += ' RETURNING *';\n        emptyQuery += ' RETURNING *';\n      } else if (!!this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n            tmpTable = 'declare @tmp table (<%= columns %>); ';\n\n            for (modelKey in modelAttributes){\n              attribute = modelAttributes[modelKey];\n              if(!(attribute.type instanceof DataTypes.VIRTUAL)){\n                if (tmpColumns.length > 0){\n                  tmpColumns += ',';\n                  outputColumns += ',';\n                }\n\n                tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();\n                outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);\n              }\n            }\n\n            var replacement ={\n              columns : tmpColumns\n            };\n\n            tmpTable = Utils._.template(tmpTable)(replacement).trim();\n            outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';\n            selectFromTmp = ';select * from @tmp';\n\n            valueQuery += selectFromTmp;\n            emptyQuery += selectFromTmp;\n        }\n      }\n    }\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Mostly for internal use, so we expect the user to know what he's doing!\n      // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n      if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {\n        // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)\n        var delimiter = '$func_' + uuid.v4().replace(/-/g, '') + '$';\n\n        options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response <%= table %>, OUT sequelize_caught_exception text) RETURNS RECORD AS ' + delimiter +\n          ' BEGIN ' + valueQuery + ' INTO response; EXCEPTION ' + options.exception + ' END ' + delimiter +\n          ' LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()';\n      } else {\n        options.exception = 'WHEN unique_violation THEN NULL;';\n        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF <%= table %> AS $body$ BEGIN RETURN QUERY ' + valueQuery + '; EXCEPTION ' + options.exception + ' END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();';\n      }\n    }\n\n    if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {\n      valueQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;\n      emptyQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;\n    }\n\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (key in valueHash) {\n      if (valueHash.hasOwnProperty(key)) {\n        value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1,1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push('DEFAULT');\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          values.push(this.escape(value, (modelAttributeMap && modelAttributeMap[key]) || undefined, { context: 'INSERT' }));\n        }\n      }\n    }\n\n    var replacements = {\n      ignore: options.ignore ? this._dialect.supports.IGNORE : '',\n      table: this.quoteTable(table),\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: values.join(','),\n      tmpTable: tmpTable\n    };\n\n    query = (replacements.attributes.length ? valueQuery : emptyQuery) + ';';\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = [\n        'SET IDENTITY_INSERT', this.quoteTable(table), 'ON;',\n        query,\n        'SET IDENTITY_INSERT', this.quoteTable(table), 'OFF;',\n      ].join(' ');\n    }\n\n    return Utils._.template(query)(replacements);\n  },\n\n  /*\n    Returns an insert into command for multiple values.\n    Parameters: table name + list of hashes of attribute-value-pairs.\n  */\n  bulkInsertQuery: function(tableName, attrValueHashes, options, rawAttributes) {\n    options = options || {};\n    rawAttributes = rawAttributes || {};\n\n    var query = 'INSERT<%= ignoreDuplicates %> INTO <%= table %> (<%= attributes %>) VALUES <%= tuples %><%= onDuplicateKeyUpdate %><%= returning %>;'\n      , tuples = []\n      , serials = []\n      , allAttributes = []\n      , onDuplicateKeyUpdate = '';\n\n    attrValueHashes.forEach(function(attrValueHash) {\n      _.forOwn(attrValueHash, function(value, key) {\n        if (allAttributes.indexOf(key) === -1) {\n          allAttributes.push(key);\n        }\n\n        if (rawAttributes[key] && rawAttributes[key].autoIncrement === true) {\n          serials.push(key);\n        }\n      });\n    });\n\n    attrValueHashes.forEach(function(attrValueHash) {\n      tuples.push('(' +\n        allAttributes.map(function(key) {\n          if (this._dialect.supports.bulkDefault && serials.indexOf(key) !== -1) {\n            return attrValueHash[key] || 'DEFAULT';\n          }\n          return this.escape(attrValueHash[key], rawAttributes[key], { context: 'INSERT' });\n        }, this).join(',') +\n        ')');\n    }, this);\n\n    if (this._dialect.supports.updateOnDuplicate && options.updateOnDuplicate) {\n      onDuplicateKeyUpdate += ' ON DUPLICATE KEY UPDATE ' + options.updateOnDuplicate.map(function(attr) {\n        var field = rawAttributes && rawAttributes[attr] && rawAttributes[attr].field || attr;\n        var key = this.quoteIdentifier(field);\n        return key + '=VALUES(' + key + ')';\n      }, this).join(',');\n    }\n\n    var replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.ignoreDuplicates : '',\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map(function(attr) {\n        return this.quoteIdentifier(attr);\n      }, this).join(','),\n      tuples: tuples.join(','),\n      onDuplicateKeyUpdate: onDuplicateKeyUpdate,\n      returning: this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : ''\n    };\n\n    return _.template(query)(replacements);\n  },\n\n  /*\n    Returns an update query.\n    Parameters:\n      - tableName -> Name of the table\n      - values -> A hash with attribute-value-pairs\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n  */\n  updateQuery: function(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    var query\n      , values = []\n      , outputFragment\n      , modelAttributeMap = {}\n      , tmpTable = ''         //tmpTable declaration for trigger\n      , selectFromTmp = ''    //Select statement for trigger\n      , tmpColumns = ''       //Columns for temp table for trigger\n      , outputColumns = ''    //Columns to capture into temp table for trigger\n      , attribute             //Model attribute holder\n      , modelKey;             //key for model\n\n    query = '<%= tmpTable %>UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';\n\n    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n      query += ' LIMIT ' + this.escape(options.limit) + ' ';\n    }\n\n    if (this._dialect.supports.returnValues) {\n      if (!!this._dialect.supports.returnValues.output) {\n        // we always need this for mssql\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n            tmpTable = 'declare @tmp table (<%= columns %>); ';\n\n            for (modelKey in attributes){\n              attribute = attributes[modelKey];\n              if(!(attribute.type instanceof DataTypes.VIRTUAL)){\n                if (tmpColumns.length > 0){\n                  tmpColumns += ',';\n                  outputColumns += ',';\n                }\n\n                tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();\n                outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);\n              }\n            }\n\n            var replacement ={\n              columns : tmpColumns\n            };\n\n            tmpTable = Utils._.template(tmpTable)(replacement).trim();\n            outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';\n            selectFromTmp = ';select * from @tmp';\n\n            query += selectFromTmp;\n        }\n      } else if (this._dialect.supports.returnValues && options.returning) {\n        // ensure that the return output is properly mapped to model fields.\n        options.mapToModel = true;\n        query += ' RETURNING *';\n      }\n    }\n\n    if (attributes) {\n      Utils._.each(attributes, function(attribute, key) {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (var key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] &&\n          modelAttributeMap[key].autoIncrement === true &&\n          !this._dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      var value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value, (modelAttributeMap && modelAttributeMap[key] || undefined), { context: 'UPDATE' }));\n    }\n\n    var replacements = {\n      table: this.quoteTable(tableName),\n      values: values.join(','),\n      output: outputFragment,\n      where: this.whereQuery(where),\n      tmpTable: tmpTable\n    };\n\n    if (values.length === 0) {\n      return '';\n    }\n\n    return Utils._.template(query)(replacements).trim();\n  },\n\n  /*\n    Returns an upsert query.\n  */\n  upsertQuery: function (tableName, insertValues, updateValues, where, rawAttributes, options) {\n    throwMethodUndefined('upsertQuery');\n  },\n\n  /*\n    Returns a deletion query.\n    Parameters:\n      - tableName -> Name of the table\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n    Options:\n      - limit -> Maximaum count of lines to delete\n      - truncate -> boolean - whether to use an 'optimized' mechanism (i.e. TRUNCATE) if available,\n                              note that this should not be the default behaviour because TRUNCATE does not\n                              always play nicely (e.g. InnoDB tables with FK constraints)\n                              (@see http://dev.mysql.com/doc/refman/5.6/en/truncate-table.html).\n                              Note that truncate must ignore limit and where\n  */\n  /* istanbul ignore next */\n  deleteQuery: function(tableName, where, options) {\n    throwMethodUndefined('deleteQuery');\n  },\n\n  /*\n    Returns an update query.\n    Parameters:\n      - tableName -> Name of the table\n      - values -> A hash with attribute-value-pairs\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n  */\n  incrementQuery: function(tableName, attrValueHash, where, options) {\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);\n\n    var query\n      , key\n      , value\n      , values = []\n      , outputFragment;\n\n    query = 'UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';\n    if (this._dialect.supports.returnValues) {\n      if (!!this._dialect.supports.returnValues.returning) {\n        query += ' RETURNING *';\n      } else if (!!this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n      }\n    }\n\n    for (key in attrValueHash) {\n      value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.quoteIdentifier(key) + ' + ' + this.escape(value));\n    }\n\n    options = options || {};\n    for (key in options) {\n      value = options[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value));\n    }\n\n    var replacements = {\n      table: this.quoteTable(tableName),\n      values: values.join(','),\n      output: outputFragment,\n      where: this.whereQuery(where)\n    };\n\n    return Utils._.template(query)(replacements);\n  },\n\n  nameIndexes: function (indexes, rawTablename) {\n    return Utils._.map(indexes, function (index) {\n      if (!index.hasOwnProperty('name')) {\n        var onlyAttributeNames = index.fields.map(function(field) {\n          return (typeof field === 'string') ? field : (field.name || field.attribute);\n        }.bind(this));\n\n        index.name = Utils.inflection.underscore(rawTablename + '_' + onlyAttributeNames.join('_'));\n      }\n\n      return index;\n    });\n  },\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n  */\n  addIndexQuery: function(tableName, attributes, options, rawTablename) {\n    var fieldsSql;\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    // Backwards compatability\n    if (options.indexName) {\n      options.name = options.indexName;\n    }\n    if (options.indicesType) {\n      options.type = options.indicesType;\n    }\n    if (options.indexType || options.method) {\n      options.using = options.indexType || options.method;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && _.isString(options.prefix)) {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n      options.prefix = options.prefix.replace(/(\\\"|\\')/g, '');\n    }\n\n    fieldsSql = options.fields.map(function(field) {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      } else if (field._isSequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      } else {\n        var result = '';\n\n        if (field.attribute) {\n          field.name = field.attribute;\n        }\n\n        if (!field.name) {\n          throw new Error('The following index field has no name: ' + util.inspect(field));\n        }\n\n        result += this.quoteIdentifier(field.name);\n\n        if (this._dialect.supports.index.collate && field.collate) {\n          result += ' COLLATE ' + this.quoteIdentifier(field.collate);\n        }\n\n        if (this._dialect.supports.index.length && field.length) {\n          result += '(' + field.length + ')';\n        }\n\n        if (field.order) {\n          result += ' ' + field.order;\n        }\n\n        return result;\n      }\n    }.bind(this));\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = this.nameIndexes([options], options.prefix)[0];\n    }\n\n    options = Model.prototype.$conformIndex(options);\n\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    if (_.isString(tableName)) {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    var concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined\n      , ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        tableName,\n        concurrently,\n        'ADD'\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this._dialect.supports.indexViaAlter ? concurrently : undefined,\n      this.quoteIdentifiers(options.name),\n      this._dialect.supports.index.using === 1 && options.using ? 'USING ' + options.using : '',\n      !this._dialect.supports.indexViaAlter ? 'ON ' + tableName : undefined,\n      this._dialect.supports.index.using === 2 && options.using ? 'USING ' + options.using : '',\n      '(' + fieldsSql.join(', ') + (options.operator ? ' '+options.operator : '') + ')',\n      (this._dialect.supports.index.parser && options.parser ? 'WITH PARSER ' + options.parser : undefined),\n      (this._dialect.supports.index.where && options.where ? options.where : undefined)\n    );\n\n    return Utils._.compact(ind).join(' ');\n  },\n\n  /*\n    Returns a query listing indexes for a given table.\n    Parameters:\n      - tableName: Name of an existing table.\n      - options:\n        - database: Name of the database.\n  */\n  /* istanbul ignore next */\n  showIndexesQuery: function(tableName, options) {\n    throwMethodUndefined('showIndexesQuery');\n  },\n\n  /*\n    Returns a remove index query.\n    Parameters:\n      - tableName: Name of an existing table.\n      - indexNameOrAttributes: The name of the index as string or an array of attribute names.\n  */\n  /* istanbul ignore next */\n  removeIndexQuery: function(tableName, indexNameOrAttributes) {\n    throwMethodUndefined('removeIndexQuery');\n  },\n\n  /*\n    This method transforms an array of attribute hashes into equivalent\n    sql attribute definition.\n  */\n  /* istanbul ignore next */\n  attributesToSQL: function(attributes) {\n    throwMethodUndefined('attributesToSQL');\n  },\n\n  /*\n    Returns all auto increment fields of a factory.\n  */\n  /* istanbul ignore next */\n  findAutoIncrementField: function(factory) {\n    throwMethodUndefined('findAutoIncrementField');\n  },\n\n\n  quoteTable: function(param, as) {\n    var table = '';\n\n    if (as === true) {\n      as = param.as || param.name || param;\n    }\n\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += this.quoteIdentifier(param.schema) + '.';\n        }\n\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || '.');\n        }\n\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n\n\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n\n    if (as) {\n      table += ' AS ' + this.quoteIdentifier(as);\n    }\n    return table;\n  },\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model or an object {model: Model, as: String}, matching include\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n  */\n  quote: function(obj, parent, force) {\n    if (Utils._.isString(obj)) {\n      return this.quoteIdentifiers(obj, force);\n    } else if (Array.isArray(obj)) {\n      // loop through array, adding table names of models to quoted\n      // (checking associations to see if names should be singularised or not)\n      var tableNames = []\n        , parentAssociation\n        , len = obj.length\n        , item\n        , model\n        , as\n        , association;\n\n      for (var i = 0; i < len - 1; i++) {\n        item = obj[i];\n        if (item._modelAttribute || Utils._.isString(item) || item._isSequelizeMethod || 'raw' in item) {\n          break;\n        }\n\n        if (item instanceof Model) {\n          model = item;\n          as = undefined;\n        } else {\n          model = item.model;\n          as = item.as;\n        }\n\n        // check if model provided is through table\n        if (!as && parentAssociation && parentAssociation.through && parentAssociation.through.model === model) {\n          association = {as: model.name};\n        } else {\n          // find applicable association for linking parent to this model\n          association = parent.getAssociation(model, as);\n        }\n\n        if (association) {\n          tableNames[i] = association.as;\n          parent = model;\n          parentAssociation = association;\n        } else {\n          tableNames[i] = model.tableName;\n          throw new Error('\\'' + tableNames.join('.') + '\\' in order / group clause is not valid association');\n        }\n      }\n\n      // add 1st string as quoted, 2nd as unquoted raw\n      var sql = (i > 0 ? this.quoteIdentifier(tableNames.join('.')) + '.' : (Utils._.isString(obj[0]) && parent ? this.quoteIdentifier(parent.name) + '.' : '')) + this.quote(obj[i], parent, force);\n      if (i < len - 1) {\n        if (obj[i + 1]._isSequelizeMethod) {\n          sql += this.handleSequelizeMethod(obj[i + 1]);\n        } else {\n          sql += ' ' + obj[i + 1];\n        }\n      }\n      return sql;\n    } else if (obj._modelAttribute) {\n      return this.quoteTable(obj.Model.name) + '.' + obj.fieldName;\n    } else if (obj._isSequelizeMethod) {\n      return this.handleSequelizeMethod(obj);\n    } else if (Utils._.isObject(obj) && 'raw' in obj) {\n      return obj.raw;\n    } else {\n      throw new Error('Unknown structure passed to order / group: ' + JSON.stringify(obj));\n    }\n  },\n\n  /*\n   Create a trigger\n   */\n  /* istanbul ignore next */\n  createTrigger: function(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray) {\n    throwMethodUndefined('createTrigger');\n  },\n\n  /*\n   Drop a trigger\n   */\n  /* istanbul ignore next */\n  dropTrigger: function(tableName, triggerName) {\n    throwMethodUndefined('dropTrigger');\n  },\n\n  /*\n   Rename a trigger\n  */\n  /* istanbul ignore next */\n  renameTrigger: function(tableName, oldTriggerName, newTriggerName) {\n    throwMethodUndefined('renameTrigger');\n  },\n\n  /*\n   Create a function\n   */\n  /* istanbul ignore next */\n  createFunction: function(functionName, params, returnType, language, body, options) {\n    throwMethodUndefined('createFunction');\n  },\n\n  /*\n   Drop a function\n   */\n  /* istanbul ignore next */\n  dropFunction: function(functionName, params) {\n    throwMethodUndefined('dropFunction');\n  },\n\n  /*\n   Rename a function\n   */\n  /* istanbul ignore next */\n  renameFunction: function(oldFunctionName, params, newFunctionName) {\n    throwMethodUndefined('renameFunction');\n  },\n\n  /*\n    Escape an identifier (e.g. a table or attribute name)\n  */\n  /* istanbul ignore next */\n  quoteIdentifier: function(identifier, force) {\n    throwMethodUndefined('quoteIdentifier');\n  },\n\n  /*\n    Split an identifier into .-separated tokens and quote each part\n  */\n  quoteIdentifiers: function(identifiers, force) {\n    if (identifiers.indexOf('.') !== -1) {\n      identifiers = identifiers.split('.');\n      return this.quoteIdentifier(identifiers.slice(0, identifiers.length - 1).join('.')) + '.' + this.quoteIdentifier(identifiers[identifiers.length - 1]);\n    } else {\n      return this.quoteIdentifier(identifiers);\n    }\n  },\n\n  /*\n    Escape a value (e.g. a string, number or date)\n  */\n  escape: function(value, field, options) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value._isSequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      } else {\n        if (field && field.type) {\n          if (this.typeValidation && field.type.validate && value) {\n            if (options.isList && Array.isArray(value)) {\n              _.forEach(value, function(item) {\n                field.type.validate(item, options);\n              });\n            } else {\n              field.type.validate(value, options);\n            }\n          }\n\n          if (field.type.stringify) {\n            // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n            var simpleEscape = _.partialRight(SqlString.escape, this.options.timezone, this.dialect);\n\n            value = field.type.stringify(value, { escape: simpleEscape, field: field, timezone: this.options.timezone });\n\n            if (field.type.escape === false) {\n              // The data-type already did the required escaping\n              return value;\n            }\n          }\n        }\n      }\n    }\n\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} schemaName The name of the schema.\n   * @return {String}            The generated sql query.\n   */\n  /* istanbul ignore next */\n  getForeignKeysQuery: function(tableName, schemaName) {\n    throwMethodUndefined('getForeignKeysQuery');\n  },\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} foreignKey The name of the foreign key constraint.\n   * @return {String}            The generated sql query.\n   */\n  /* istanbul ignore next */\n  dropForeignKeyQuery: function(tableName, foreignKey) {\n    throwMethodUndefined('dropForeignKeyQuery');\n  },\n\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n  */\n\n  selectQuery: function(tableName, options, model) {\n    // Enter and change at your own peril -- Mick Hansen\n\n    options = options || {};\n\n    var table = null\n      , self = this\n      , query\n      , limit = options.limit\n      , mainModel = model\n      , mainQueryItems = []\n      , mainAttributes = options.attributes && options.attributes.slice()\n      , mainJoinQueries = []\n      // We'll use a subquery if we have a hasMany association and a limit\n      , subQuery = options.subQuery === undefined ?\n                   limit && options.hasMultiAssociation :\n                   options.subQuery\n      , subQueryItems = []\n      , subQueryAttributes = null\n      , subJoinQueries = []\n      , mainTableAs = null;\n\n    if (options.tableAs) {\n      mainTableAs = this.quoteTable(options.tableAs);\n    } else if (!Array.isArray(tableName) && model) {\n      mainTableAs = this.quoteTable(model.name);\n    }\n\n    table = !Array.isArray(tableName) ? this.quoteTable(tableName) : tableName.map(function(t) {\n      if (Array.isArray(t)) {\n        return this.quoteTable(t[0], t[1]);\n      }\n      return this.quoteTable(t, true);\n    }.bind(this)).join(', ');\n\n    if (subQuery && mainAttributes) {\n      model.primaryKeyAttributes.forEach(function(keyAtt) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!_.find(mainAttributes, function (attr) {\n          return keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1];\n        })) {\n          mainAttributes.push(model.rawAttributes[keyAtt].field ? [keyAtt, model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      });\n    }\n\n    // Escape attributes\n    mainAttributes = mainAttributes && mainAttributes.map(function(attr) {\n      var addTable = true;\n\n      if (attr._isSequelizeMethod) {\n        return self.handleSequelizeMethod(attr);\n      }\n\n      if (Array.isArray(attr) && attr.length === 2) {\n        attr = attr.slice();\n\n        if (attr[0]._isSequelizeMethod) {\n          attr[0] = self.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (\n          attr[0].indexOf('(') === -1 &&\n          attr[0].indexOf(')') === -1\n        ) {\n          attr[0] = self.quoteIdentifier(attr[0]);\n        } else {\n          deprecate('Use sequelize.fn / sequelize.literal to construct attributes');\n        }\n\n        attr = [attr[0], self.quoteIdentifier(attr[1])].join(' AS ');\n      } else {\n        if (\n          attr.indexOf(Utils.TICK_CHAR) < 0 &&\n          attr.indexOf('\"') < 0\n        ) {\n          attr = self.quoteIdentifiers(attr);\n        } else {\n          attr = self.escape(attr);\n        }\n      }\n\n      if (options.include && attr.indexOf('.') === -1 && addTable) {\n        attr = mainTableAs + '.' + attr;\n      }\n\n      return attr;\n    });\n\n    // If no attributes specified, use *\n    mainAttributes = mainAttributes || (options.include ? [mainTableAs + '.*'] : ['*']);\n\n    // If subquery, we ad the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      subQueryAttributes = mainAttributes;\n      mainAttributes = [(mainTableAs || table) + '.*'];\n    }\n\n    if (options.include) {\n      var generateJoinQueries = function(include, parentTable) {\n        var table = include.model.getTableName()\n          , as = include.as\n          , joinQueryItem = ''\n          , joinQueries = {\n            mainQuery: [],\n            subQuery: []\n          }\n          , attributes\n          , association = include.association\n          , through = include.through\n          , joinType = include.required ? ' INNER JOIN ' : ' LEFT OUTER JOIN '\n          , parentIsTop = !include.parent.association && include.parent.model.name === options.model.name\n          , whereOptions = Utils._.clone(options)\n          , targetWhere;\n\n        whereOptions.keysEscaped = true;\n\n        if (tableName !== parentTable && mainTableAs !== parentTable) {\n          as = parentTable + '.' + include.as;\n        }\n\n        // includeIgnoreAttributes is used by aggregate functions\n        if (options.includeIgnoreAttributes !== false) {\n          attributes = include.attributes.map(function(attr) {\n            var attrAs = attr,\n                verbatim = false;\n\n            if (Array.isArray(attr) && attr.length === 2) {\n              if (attr[0]._isSequelizeMethod) {\n                if (attr[0] instanceof Utils.literal ||\n                  attr[0] instanceof Utils.cast ||\n                  attr[0] instanceof Utils.fn\n                ) {\n                  verbatim = true;\n                }\n              }\n\n              attr = attr.map(function($attr) {\n                return $attr._isSequelizeMethod ? self.handleSequelizeMethod($attr) : $attr;\n              });\n\n              attrAs = attr[1];\n              attr = attr[0];\n            } else if (attr instanceof Utils.literal) {\n              return attr.val; // We trust the user to rename the field correctly\n            } else if (attr instanceof Utils.cast ||\n              attr instanceof Utils.fn\n            ) {\n              throw new Error(\n                'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +\n                'This means the attribute will not be added to the returned instance'\n              );\n            }\n\n            var prefix;\n\n            if (verbatim === true) {\n              prefix = attr;\n            } else {\n              prefix = self.quoteIdentifier(as) + '.' + self.quoteIdentifier(attr);\n            }\n\n            return prefix + ' AS ' + self.quoteIdentifier(as + '.' + attrAs, true);\n          });\n\n          if (include.subQuery && subQuery) {\n            subQueryAttributes = subQueryAttributes.concat(attributes);\n          } else {\n            mainAttributes = mainAttributes.concat(attributes);\n          }\n        }\n\n        if (through) {\n          var throughTable = through.model.getTableName()\n            , throughAs = as + '.' + through.as\n            , throughAttributes = through.attributes.map(function(attr) {\n              return self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr) +\n                     ' AS ' +\n                     self.quoteIdentifier(throughAs + '.' + (Array.isArray(attr) ? attr[1] : attr));\n            })\n            , primaryKeysSource = association.source.primaryKeyAttributes\n            , tableSource = parentTable\n            , identSource = association.identifierField\n            , attrSource = primaryKeysSource[0]\n            , primaryKeysTarget = association.target.primaryKeyAttributes\n            , tableTarget = as\n            , identTarget = association.foreignIdentifierField\n            , attrTarget = association.target.rawAttributes[primaryKeysTarget[0]].field || primaryKeysTarget[0]\n\n            , sourceJoinOn\n            , targetJoinOn\n\n            , throughWhere;\n\n          if (options.includeIgnoreAttributes !== false) {\n            // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n            mainAttributes = mainAttributes.concat(throughAttributes);\n          }\n\n          // Figure out if we need to use field or attribute\n          if (!subQuery) {\n            attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;\n          }\n          if (subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== mainModel) {\n            attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;\n          }\n\n          // Filter statement for left side of through\n          // Used by both join and subquery where\n\n          // If parent include was in a subquery need to join on the aliased attribute\n\n          if (subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n            sourceJoinOn = self.quoteIdentifier(tableSource + '.' + attrSource) + ' = ';\n          } else {\n            sourceJoinOn = self.quoteTable(tableSource) + '.' + self.quoteIdentifier(attrSource) + ' = ';\n          }\n          sourceJoinOn += self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(identSource);\n\n          // Filter statement for right side of through\n          // Used by both join and subquery where\n          targetJoinOn = self.quoteIdentifier(tableTarget) + '.' + self.quoteIdentifier(attrTarget) + ' = ';\n          targetJoinOn += self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(identTarget);\n\n          if (include.through.where) {\n            throughWhere = self.getWhereConditions(include.through.where, self.sequelize.literal(self.quoteIdentifier(throughAs)), include.through.model);\n          }\n\n          if (self._dialect.supports.joinTableDependent) {\n            // Generate a wrapped join so that the through table join can be dependent on the target join\n            joinQueryItem += joinType + '(';\n            joinQueryItem += self.quoteTable(throughTable, throughAs);\n            joinQueryItem += ' INNER JOIN ' + self.quoteTable(table, as) + ' ON ';\n            joinQueryItem += targetJoinOn;\n\n            if (throughWhere) {\n              joinQueryItem += ' AND ' + throughWhere;\n            }\n\n            joinQueryItem += ') ON '+sourceJoinOn;\n          } else {\n            // Generate join SQL for left side of through\n            joinQueryItem += joinType + self.quoteTable(throughTable, throughAs)  + ' ON ';\n            joinQueryItem += sourceJoinOn;\n\n            // Generate join SQL for right side of through\n            joinQueryItem += joinType + self.quoteTable(table, as) + ' ON ';\n            joinQueryItem += targetJoinOn;\n\n            if (throughWhere) {\n              joinQueryItem += ' AND ' + throughWhere;\n            }\n\n          }\n\n          if (include.where || include.through.where) {\n            if (include.where) {\n              targetWhere = self.getWhereConditions(include.where, self.sequelize.literal(self.quoteIdentifier(as)), include.model, whereOptions);\n              if (targetWhere) {\n                joinQueryItem += ' AND ' + targetWhere;\n              }\n            }\n            if (subQuery && include.required) {\n              if (!options.where) options.where = {};\n              (function (include) {\n                // Closure to use sane local variables\n\n                var parent = include\n                  , child = include\n                  , nestedIncludes = []\n                  , topParent\n                  , topInclude\n                  , $query;\n\n                while (parent = parent.parent) {\n                  nestedIncludes = [_.extend({}, child, {include: nestedIncludes})];\n                  child = parent;\n                }\n\n                topInclude = nestedIncludes[0];\n                topParent = topInclude.parent;\n\n                if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n                  $query = self.selectQuery(topInclude.through.model.getTableName(), {\n                    attributes: [topInclude.through.model.primaryKeyField],\n                    include: Model.$validateIncludedElements({\n                      model: topInclude.through.model,\n                      include: [{\n                        association: topInclude.association.toTarget,\n                        required: true\n                      }]\n                    }).include,\n                    model: topInclude.through.model,\n                    where: { $and: [\n                      self.sequelize.asIs([\n                        self.quoteTable(topParent.model.name) + '.' + self.quoteIdentifier(topParent.model.primaryKeyField),\n                        self.quoteIdentifier(topInclude.through.model.name) + '.' + self.quoteIdentifier(topInclude.association.identifierField)\n                      ].join(' = ')),\n                      topInclude.through.where\n                    ]},\n                    limit: 1,\n                    includeIgnoreAttributes: false\n                  }, topInclude.through.model);\n                } else {\n                  var isBelongsTo = topInclude.association.associationType === 'BelongsTo';\n                  var join = [\n                    self.quoteTable(topParent.model.name) + '.' + self.quoteIdentifier(isBelongsTo ? topInclude.association.identifierField : topParent.model.primaryKeyAttributes[0]),\n                    self.quoteIdentifier(topInclude.model.name) + '.' + self.quoteIdentifier(isBelongsTo ? topInclude.model.primaryKeyAttributes[0] : topInclude.association.identifierField)\n                  ].join(' = ');\n                  $query = self.selectQuery(topInclude.model.tableName, {\n                    attributes: [topInclude.model.primaryKeyAttributes[0]],\n                    include: topInclude.include,\n                    where: {\n                      $join: self.sequelize.asIs(join)\n                    },\n                    limit: 1,\n                    includeIgnoreAttributes: false\n                  }, topInclude.model);\n                }\n\n                options.where['__' + throughAs] = self.sequelize.asIs([\n                  '(',\n                    $query.replace(/\\;$/, ''),\n                  ')',\n                  'IS NOT NULL'\n                ].join(' '));\n              })(include);\n            }\n          }\n        } else {\n          if (subQuery && include.subQueryFilter) {\n            var associationWhere = {}\n              , $query\n              , subQueryWhere;\n\n            associationWhere[association.identifierField] = {\n              $raw: self.quoteTable(parentTable) + '.' + self.quoteIdentifier(association.sourceKeyField || association.source.primaryKeyField)\n            };\n\n            if (!options.where) options.where = {};\n\n            // Creating the as-is where for the subQuery, checks that the required association exists\n            $query = self.selectQuery(include.model.getTableName(), {\n              attributes: [association.identifierField],\n              where: {\n                $and: [\n                  associationWhere,\n                  include.where || {}\n                ]\n              },\n              limit: 1\n            }, include.model);\n\n            subQueryWhere = self.sequelize.asIs([\n              '(',\n                $query.replace(/\\;$/, ''),\n              ')',\n              'IS NOT NULL'\n            ].join(' '));\n\n            if (Utils._.isPlainObject(options.where)) {\n              options.where['__' + as] = subQueryWhere;\n            } else {\n              options.where = { $and: [options.where, subQueryWhere] };\n            }\n          }\n\n          joinQueryItem = ' ' + self.joinIncludeQuery({\n            model: mainModel,\n            subQuery: options.subQuery,\n            include: include,\n            groupedLimit: options.groupedLimit\n          });\n        }\n\n        if (include.subQuery && subQuery) {\n          joinQueries.subQuery.push(joinQueryItem);\n        } else {\n          joinQueries.mainQuery.push(joinQueryItem);\n        }\n\n        if (include.include) {\n          include.include.filter(function (include) {\n            return !include.separate;\n          }).forEach(function(childInclude) {\n            if (childInclude._pseudo) return;\n            var childJoinQueries = generateJoinQueries(childInclude, as);\n\n            if (childInclude.subQuery && subQuery) {\n              joinQueries.subQuery = joinQueries.subQuery.concat(childJoinQueries.subQuery);\n            }\n            if (childJoinQueries.mainQuery) {\n              joinQueries.mainQuery = joinQueries.mainQuery.concat(childJoinQueries.mainQuery);\n            }\n\n          }.bind(this));\n        }\n\n        return joinQueries;\n      };\n\n      // Loop through includes and generate subqueries\n      options.include.filter(function (include) {\n        return !include.separate;\n      }).forEach(function(include) {\n        var joinQueries = generateJoinQueries(include, mainTableAs);\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n      }.bind(this));\n    }\n\n    // If using subQuery select defined subQuery attributes and join subJoinQueries\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, model, subQueryAttributes, table, mainTableAs));\n      subQueryItems.push(subJoinQueries.join(''));\n\n    // Else do it the reguar way\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTableAs) {\n          mainTableAs = table;\n        }\n\n        var groupedLimitOrder\n          , where = _.assign({}, options.where)\n          , whereKey\n          , include\n          , groupedTableName = mainTableAs;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          var groupedLimitOptions = Model.$validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: _.assign({\n                '$$PLACEHOLDER$$': true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model: model\n          });\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = _.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach(function(order, i) {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              var alias = 'subquery_order_' +i;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            }, this);\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n          delete options.order;\n          where.$$PLACEHOLDER$$ = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        var baseQuery = '('+this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            where: where,\n            include: include,\n            model: model\n          },\n          model\n        ).replace(/;$/, '')+')';\n        var placeHolder = this.whereItemQuery('$$PLACEHOLDER$$', true, { model: model })\n          , splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, model, mainAttributes, '('+\n          options.groupedLimit.values.map(function (value) {\n            var groupWhere = {};\n            if (whereKey) {\n              groupWhere[whereKey] = value;\n            }\n            if (include) {\n              groupWhere[options.groupedLimit.on.foreignIdentifierField] = value;\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n          }, this).join(\n            self._dialect.supports['UNION ALL'] ?' UNION ALL ' : ' UNION '\n          )\n        +')', mainTableAs));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, model, mainAttributes, table, mainTableAs));\n      }\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (options.hasOwnProperty('where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTableAs || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(' WHERE ' + options.where);\n        } else {\n          mainQueryItems.push(' WHERE ' + options.where);\n          // Walk the main query to update all selects\n          _.each(mainQueryItems, function(value, key) {\n            if(value.match(/^SELECT/)) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, mainAttributes, table, mainTableAs, options.where);\n            }\n          }.bind(this));\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map(function(t) { return this.quote(t, model); }.bind(this)).join(', ') : options.group;\n      if (subQuery) {\n        subQueryItems.push(' GROUP BY ' + options.group);\n      } else {\n        mainQueryItems.push(' GROUP BY ' + options.group);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (options.hasOwnProperty('having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (subQuery) {\n        subQueryItems.push(' HAVING ' + options.having);\n      } else {\n        mainQueryItems.push(' HAVING ' + options.having);\n      }\n    }\n    // Add ORDER to sub or main query\n    if (options.order) {\n      var orders = this.getQueryOrders(options, model, subQuery);\n\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(' ORDER BY ' + orders.mainQueryOrder.join(', '));\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(' ORDER BY ' + orders.subQueryOrder.join(', '));\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    var limitOrder = this.addLimitAndOffset(options, model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    // If using subQuery, select attributes from wrapped subQuery and join out join tables\n    if (subQuery) {\n      query = 'SELECT ' + mainAttributes.join(', ') + ' FROM (';\n      query += subQueryItems.join('');\n      query += ') AS ' + mainTableAs;\n      query += mainJoinQueries.join('');\n      query += mainQueryItems.join('');\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this._dialect.supports.lock) {\n      var lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {\n        query += ' FOR ' + lock;\n      } else if (lock === 'SHARE') {\n        query += ' ' + this._dialect.supports.forShare;\n      } else {\n        query += ' FOR UPDATE';\n      }\n      if (this._dialect.supports.lockOf && options.lock.of instanceof Model) {\n        query += ' OF ' + this.quoteTable(options.lock.of.name);\n      }\n    }\n\n    query += ';';\n\n    return query;\n  },\n\n  getQueryOrders: function(options, model, subQuery) {\n    var mainQueryOrder = [];\n    var subQueryOrder = [];\n\n    var validateOrder = function(order) {\n      if (order instanceof Utils.literal) return;\n\n      if (!_.includes([\n        'ASC',\n        'DESC',\n        'ASC NULLS LAST',\n        'DESC NULLS LAST',\n        'ASC NULLS FIRST',\n        'DESC NULLS FIRST',\n        'NULLS FIRST',\n        'NULLS LAST'\n      ], order.toUpperCase())) {\n        throw new Error(util.format('Order must be \\'ASC\\' or \\'DESC\\', \\'%s\\' given', order));\n      }\n    };\n\n    if (Array.isArray(options.order)) {\n      options.order.forEach(function(t) {\n        if (Array.isArray(t) && _.size(t) > 1) {\n          if (t[0] instanceof Model || t[0].model instanceof Model) {\n            if (typeof t[t.length - 2] === 'string') {\n              validateOrder(_.last(t));\n            }\n          } else {\n            validateOrder(_.last(t));\n          }\n        }\n\n        var hadSubquery = false;\n\n        if (subQuery && (Array.isArray(t) && !(t[0] instanceof Model) && !(t[0].model instanceof Model))) {\n          subQueryOrder.push(this.quote(t, model));\n          hadSubquery = true;\n        }\n\n        if (hadSubquery) {\n          for (var name in model.attributes) {\n            var attribute = model.attributes[name];\n            if (attribute.field && attribute.field === t[0]) {\n              t[0] = attribute.fieldName;\n            }\n          }\n        }\n\n        mainQueryOrder.push(this.quote(t, model));\n      }.bind(this));\n    } else {\n      var sql = this.quote(typeof options.order === 'string' ? new Utils.literal(options.order) : options.order, model);\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    }\n\n    return {\n      mainQueryOrder: mainQueryOrder,\n      subQueryOrder: subQueryOrder\n    };\n  },\n\n  selectFromTableFragment: function(options, model, attributes, tables, mainTableAs, whereClause) {\n    var fragment = 'SELECT ' + attributes.join(', ') + ' FROM ' + tables;\n\n    if(mainTableAs) {\n      fragment += ' AS ' + mainTableAs;\n    }\n\n    return fragment;\n  },\n\n  joinIncludeQuery: function(options) {\n    var subQuery = options.subQuery\n      , include = options.include\n      , association = include.association\n      , parent = include.parent\n      , parentIsTop = !include.parent.association && include.parent.model.name === options.model.name\n      , $parent\n      , joinType = include.required ? 'INNER JOIN ' : 'LEFT OUTER JOIN '\n      , joinOn\n      , joinWhere\n\n      /* Attributes for the left side */\n      , left = association.source\n      , asLeft\n      , attrLeft = association instanceof BelongsTo ?\n                   association.identifier :\n                   association.sourceKeyAttribute || left.primaryKeyAttribute\n      , fieldLeft = association instanceof BelongsTo ?\n                   association.identifierField :\n                   left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field\n\n      /* Attributes for the right side */\n      , right = include.model\n      , asRight = include.as\n      , tableRight = right.getTableName()\n      , fieldRight = association instanceof BelongsTo ?\n                     right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :\n                     association.identifierField;\n\n    while (($parent = ($parent && $parent.parent || include.parent)) && $parent.association) {\n      if (asLeft) {\n        asLeft = [$parent.as, asLeft].join('.');\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) asLeft = parent.as || parent.model.name;\n    else asRight = [asLeft, asRight].join('.');\n\n    joinOn = [\n      this.quoteTable(asLeft),\n      this.quoteIdentifier(fieldLeft)\n    ].join('.');\n\n    if ((options.groupedLimit && parentIsTop) || (subQuery && include.parent.subQuery && !include.subQuery)) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        joinOn = [\n          this.quoteTable(parent.as || parent.model.name),\n          this.quoteIdentifier(attrLeft)\n        ].join('.');\n      } else {\n        joinOn = this.quoteIdentifier(asLeft + '.' + attrLeft);\n      }\n    }\n\n    joinOn += ' = ' + this.quoteIdentifier(asRight) + '.' + this.quoteIdentifier(fieldRight);\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ' OR ' + joinWhere;\n        } else {\n          joinOn += ' AND ' + joinWhere;\n        }\n      }\n    }\n\n    return joinType + this.quoteTable(tableRight, asRight) + ' ON ' + joinOn;\n  },\n\n  /**\n   * Returns a query that starts a transaction.\n   *\n   * @param  {Boolean} value   A boolean that states whether autocommit shall be done or not.\n   * @param  {Object}  options An object with options.\n   * @return {String}          The generated sql query.\n   */\n  setAutocommitQuery: function(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    return 'SET autocommit = ' + (!!value ? 1 : 0) + ';';\n  },\n\n  /**\n   * Returns a query that sets the transaction isolation level.\n   *\n   * @param  {String} value   The isolation level.\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  setIsolationLevelQuery: function(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    return 'SET SESSION TRANSACTION ISOLATION LEVEL ' + value + ';';\n  },\n\n  generateTransactionId: function() {\n    return uuid.v4();\n  },\n\n  /**\n   * Returns a query that starts a transaction.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  startTransactionQuery: function(transaction) {\n    if (transaction.parent) {\n      // force quoting of savepoint identifiers for postgres\n      return 'SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';\n    }\n\n    return 'START TRANSACTION;';\n  },\n\n  /**\n   * Returns a query that defers the constraints. Only works for postgres.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  deferConstraintsQuery: function () {},\n\n  setConstraintQuery: function () {},\n  setDeferredQuery: function () {},\n  setImmediateQuery: function () {},\n\n  /**\n   * Returns a query that commits a transaction.\n   *\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  commitTransactionQuery: function(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT;';\n  },\n\n  /**\n   * Returns a query that rollbacks a transaction.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  rollbackTransactionQuery: function(transaction) {\n    if (transaction.parent) {\n      // force quoting of savepoint identifiers for postgres\n      return 'ROLLBACK TO SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';\n    }\n\n    return 'ROLLBACK;';\n  },\n\n  /**\n   * Returns an SQL fragment for adding result constraints\n   *\n   * @param  {Object} options An object with selectQuery options.\n   * @param  {Object} options The model passed to the selectQuery.\n   * @return {String}         The generated sql query.\n   */\n  addLimitAndOffset: function(options, model) {\n    var fragment = '';\n\n    /*jshint eqeqeq:false*/\n    if (options.offset != null && options.limit == null) {\n      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n      } else {\n        fragment += ' LIMIT ' + this.escape(options.limit);\n      }\n    }\n\n    return fragment;\n  },\n\n  handleSequelizeMethod: function (smth, tableName, factory, options, prepend) {\n    var self = this\n      , result;\n\n    if (smth instanceof Utils.where) {\n      var value = smth.logic\n        , key;\n\n      if (smth.attribute._isSequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = this.quoteTable(smth.attribute.Model.name) + '.' + this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName);\n      }\n\n      if (value && value._isSequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        result = (value === 'NULL') ? key + ' IS NULL' : [key, value].join(smth.comparator);\n      } else if (_.isPlainObject(value)) {\n        result = this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      } else {\n        if (typeof value === 'boolean') {\n          value = this.booleanValue(value);\n        } else {\n          value = this.escape(value);\n        }\n\n        result = (value === 'NULL') ? key + ' IS NULL' : [key, value].join(' ' + smth.comparator + ' ');\n      }\n    } else if (smth instanceof Utils.literal) {\n      result = smth.val;\n    } else if (smth instanceof Utils.cast) {\n      if (smth.val._isSequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n\n      result = 'CAST(' + result + ' AS ' + smth.type.toUpperCase() + ')';\n    } else if (smth instanceof Utils.fn) {\n      result = smth.fn + '(' + smth.args.map(function(arg) {\n        if (arg._isSequelizeMethod) {\n          return self.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        } else if (_.isPlainObject(arg)) {\n          return self.whereItemsQuery(arg);\n        } else {\n          return self.escape(arg);\n        }\n      }).join(', ') + ')';\n    } else if (smth instanceof Utils.col) {\n      if (Array.isArray(smth.col)) {\n        if (!factory) {\n          throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n        }\n      } else if (smth.col.indexOf('*') === 0) {\n        return '*';\n      }\n      return this.quote(smth.col, factory);\n    } else {\n      result = smth.toString(this, factory);\n    }\n\n    return result;\n  },\n\n  whereQuery: function(where, options) {\n    var query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return 'WHERE '+query;\n    }\n    return '';\n  },\n  whereItemsQuery: function(where, options, binding) {\n    if (\n      (Array.isArray(where) && where.length === 0) ||\n      (_.isPlainObject(where) && _.isEmpty(where)) ||\n      where === null ||\n      where === undefined\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (_.isString(where)) {\n      throw new Error('where: \"raw query\" has been removed, please use where [\"raw query\", [replacements]]');\n    }\n\n    var self = this\n      , items = [];\n\n    binding = binding || 'AND';\n    if (binding.substr(0, 1) !== ' ') binding = ' '+binding+' ';\n\n    if (_.isPlainObject(where)) {\n      _.forOwn(where, function (value, key) {\n        items.push(self.whereItemQuery(key, value, options));\n      });\n    } else {\n      items.push(self.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(function (item) {\n      return item && item.length;\n    }).join(binding) || '';\n  },\n  whereItemQuery: function(key, value, options) {\n    options = options || {};\n\n    var self = this\n      , binding\n      , outerBinding\n      , comparatorMap\n      , aliasMap\n      , comparator = '='\n      , field = options.field || options.model && options.model.rawAttributes && options.model.rawAttributes[key] || options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]\n      , fieldType = options.type || (field && field.type)\n      , tmp;\n\n    if (key && typeof key === 'string' && key.indexOf('.') !== -1 && options.model) {\n      if (options.model.rawAttributes[key.split('.')[0]] && options.model.rawAttributes[key.split('.')[0]].type instanceof DataTypes.JSON) {\n        field = options.model.rawAttributes[key.split('.')[0]];\n        fieldType = field.type;\n        tmp = value;\n        value = {};\n\n        Dottie.set(value, key.split('.').slice(1), tmp);\n        key = field.field || key.split('.')[0];\n      }\n    }\n\n    comparatorMap = {\n      $eq: '=',\n      $ne: '!=',\n      $gte: '>=',\n      $gt: '>',\n      $lte: '<=',\n      $lt: '<',\n      $not: 'IS NOT',\n      $is: 'IS',\n      $like: 'LIKE',\n      $notLike: 'NOT LIKE',\n      $iLike: 'ILIKE',\n      $notILike: 'NOT ILIKE',\n      $between: 'BETWEEN',\n      $notBetween: 'NOT BETWEEN',\n      $overlap: '&&',\n      $contains: '@>',\n      $contained: '<@'\n    };\n\n    // Maintain BC\n    aliasMap = {\n      'ne': '$ne',\n      'in': '$in',\n      'not': '$not',\n      'notIn': '$notIn',\n      'gte': '$gte',\n      'gt': '$gt',\n      'lte': '$lte',\n      'lt': '$lt',\n      'like': '$like',\n      'ilike': '$iLike',\n      '$ilike': '$iLike',\n      'nlike': '$notLike',\n      '$notlike': '$notLike',\n      'notilike': '$notILike',\n      '..': '$between',\n      'between': '$between',\n      '!..': '$notBetween',\n      'notbetween': '$notBetween',\n      'nbetween': '$notBetween',\n      'overlap': '$overlap',\n      '&&': '$overlap',\n      '@>': '$contains',\n      '<@': '$contained'\n    };\n\n    key = aliasMap[key] || key;\n    if (_.isPlainObject(value)) {\n      _.forOwn(value, function (item, key) {\n        if (aliasMap[key]) {\n          value[aliasMap[key]] = item;\n          delete value[key];\n        }\n      });\n    }\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (_.isPlainObject(value) && _.size(value) === 1) {\n        key = Object.keys(value)[0];\n        value = _.values(value)[0];\n      }\n    }\n\n    if (value && value._isSequelizeMethod && !(key !== undefined && value instanceof Utils.fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n\n    // Convert where: [] to $and if possible, else treat as literal/replacements\n    if (key === undefined && Array.isArray(value)) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = '$and';\n      } else {\n        return Utils.format(value, this.dialect);\n      }\n    }\n    // OR/AND/NOT grouping logic\n    if (key === '$or' || key === '$and' || key === '$not') {\n      binding = (key === '$or') ?' OR ' : ' AND ';\n      outerBinding = '';\n      if (key === '$not') outerBinding = 'NOT ';\n\n      if (Array.isArray(value)) {\n        value = value.map(function (item) {\n          var itemQuery = self.whereItemsQuery(item, options, ' AND ');\n          if ((Array.isArray(item) || _.isPlainObject(item)) && _.size(item) > 1) {\n            itemQuery = '('+itemQuery+')';\n          }\n          return itemQuery;\n        }).filter(function (item) {\n          return item && item.length;\n        });\n\n        // $or: [] should return no data.\n        // $not of no restriction should also return no data\n        if ((key === '$or' || key === '$not') && value.length === 0) {\n          return '0 = 1';\n        }\n\n        return value.length ? outerBinding + '('+value.join(binding)+')' : undefined;\n      } else {\n        value = self.whereItemsQuery(value, options, binding);\n\n        if ((key === '$or' || key === '$not') && !value) {\n          return '0 = 1';\n        }\n\n        return value ? outerBinding + '('+value+')' : undefined;\n      }\n    }\n\n    if (value && (value.$or || value.$and)) {\n      binding = value.$or ? ' OR ' : ' AND ';\n      value = value.$or || value.$and;\n\n      if (_.isPlainObject(value)) {\n        value = _.reduce(value, function (result, _value, key) {\n          result.push(_.zipObject([key], [_value]));\n          return result;\n        }, []);\n      }\n\n      value = value.map(function (_value) {\n        return self.whereItemQuery(key, _value, options);\n      }).filter(function (item) {\n        return item && item.length;\n      });\n\n      return value.length ? '('+value.join(binding)+')' : undefined;\n    }\n\n    if (_.isPlainObject(value) && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return (function () {\n        var $items = []\n          , result\n          , traverse;\n\n        traverse = function (prop, item, path) {\n          var $where = {}\n            , $key\n            , $cast\n            , $baseKey\n            , $tmp\n            , castKey;\n\n          if (path[path.length - 1].indexOf('::') > -1) {\n            $tmp = path[path.length - 1].split('::');\n            $cast = $tmp[1];\n            path[path.length - 1] = $tmp[0];\n          }\n\n          $baseKey = self.quoteIdentifier(key)+'#>>\\'{'+path.join(', ')+'}\\'';\n\n          if (options.prefix) {\n            if (options.prefix instanceof Utils.literal) {\n              $baseKey = self.handleSequelizeMethod(options.prefix)+'.'+$baseKey;\n            } else {\n              $baseKey = self.quoteTable(options.prefix)+'.'+$baseKey;\n            }\n          }\n\n          $baseKey = '('+$baseKey+')';\n\n          castKey = function ($item) {\n            var key = $baseKey;\n\n            if (!$cast) {\n              if (typeof $item === 'number') {\n                $cast = 'double precision';\n              } else if ($item instanceof Date) {\n                $cast = 'timestamptz';\n              } else if (typeof $item === 'boolean') {\n                $cast = 'boolean';\n              }\n            }\n\n            if ($cast) {\n              key += '::'+$cast;\n            }\n\n            return key;\n          };\n\n          if (_.isPlainObject(item)) {\n            _.forOwn(item, function ($item, $prop) {\n              if ($prop.indexOf('$') === 0) {\n                $where[$prop] = $item;\n                $key = castKey($item);\n\n                $items.push(self.whereItemQuery(new Utils.literal($key), $where/*, _.pick(options, 'prefix')*/));\n              } else {\n                traverse($prop, $item, path.concat([$prop]));\n              }\n            });\n          } else {\n            $where.$eq = item;\n            $key = castKey(item);\n\n            $items.push(self.whereItemQuery(new Utils.literal($key), $where/*, _.pick(options, 'prefix')*/));\n          }\n        };\n\n        _.forOwn(value, function (item, prop) {\n          if (prop.indexOf('$') === 0) {\n            var $where = {};\n            $where[prop] = item;\n            $items.push(self.whereItemQuery(key, $where, _.assign({}, options, {json: false})));\n            return;\n          }\n\n          traverse(prop, item, [prop]);\n        });\n\n        result = $items.join(' AND ');\n        return $items.length > 1 ? '('+result+')' : result;\n      })();\n    }\n\n    // If multiple keys we combine the different logic conditions\n    if (_.isPlainObject(value) && Object.keys(value).length > 1) {\n      return (function () {\n        var $items = [];\n        _.forOwn(value, function (item, logic) {\n          var $where = {};\n          $where[logic] = item;\n          $items.push(self.whereItemQuery(key, $where, options));\n        });\n\n        return '('+$items.join(' AND ')+')';\n      })();\n    }\n\n    // Do [] to $in/$notIn normalization\n    if (value && (!fieldType || !(fieldType instanceof DataTypes.ARRAY))) {\n      if (Array.isArray(value)) {\n        value = {\n          $in: value\n        };\n      } else if (value && Array.isArray(value.$not)) {\n        value.$notIn = value.$not;\n        delete value.$not;\n      }\n    }\n\n    // normalize $not: non-bool|non-null to $ne\n    if (value && typeof value.$not !== 'undefined' && [null, true, false].indexOf(value.$not) < 0) {\n      value.$ne = value.$not;\n      delete value.$not;\n    }\n\n    // Setup keys and comparators\n    if (Array.isArray(value) && fieldType instanceof DataTypes.ARRAY) {\n      value = this.escape(value, field);\n    } else if (value && (value.$in || value.$notIn)) {\n      comparator = 'IN';\n      if (value.$notIn) comparator = 'NOT IN';\n\n      if ((value.$in || value.$notIn) instanceof Utils.literal) {\n        value = (value.$in || value.$notIn).val;\n      } else if ((value.$in || value.$notIn).length) {\n        value = '('+(value.$in || value.$notIn).map(function (item) {\n          return self.escape(item);\n        }).join(', ')+')';\n      } else {\n        value = '(NULL)';\n      }\n    } else if (value && (value.$any || value.$all)) {\n      comparator = value.$any ? '= ANY' : '= ALL';\n      if (value.$any && value.$any.$values || value.$all && value.$all.$values) {\n        value = '(VALUES '+(value.$any && value.$any.$values || value.$all && value.$all.$values).map(function (value) {\n          return '('+this.escape(value)+')';\n        }.bind(this)).join(', ')+')';\n      } else {\n        value = '('+this.escape(value.$any || value.$all, field)+')';\n      }\n    } else if (value && (value.$between || value.$notBetween)) {\n      comparator = 'BETWEEN';\n      if (value.$notBetween) comparator = 'NOT BETWEEN';\n\n      value = (value.$between || value.$notBetween).map(function (item) {\n        return self.escape(item);\n      }).join(' AND ');\n    } else if (value && value.$raw) {\n      value = value.$raw;\n    } else if (value && value.$col) {\n      value = value.$col.split('.');\n\n      if (value.length > 2) {\n        value = [\n          value.slice(0, -1).join('.'),\n          value[value.length - 1]\n        ];\n      }\n\n      value = value.map(this.quoteIdentifier.bind(this)).join('.');\n    } else {\n      var escapeValue = true;\n      var escapeOptions = {};\n\n      if (_.isPlainObject(value)) {\n        _.forOwn(value, function (item, key) {\n          if (comparatorMap[key]) {\n            comparator = comparatorMap[key];\n            value = item;\n\n            if (_.isPlainObject(value) && value.$any) {\n              comparator += ' ANY';\n              escapeOptions.isList = true;\n              value = value.$any;\n            } else if (_.isPlainObject(value) && value.$all) {\n              comparator += ' ALL';\n              escapeOptions.isList = true;\n              value = value.$all;\n            } else if (value && value.$col) {\n              escapeValue = false;\n              value = this.whereItemQuery(null, value);\n            }\n          }\n        }.bind(this));\n      }\n\n      if (comparator === '=' && value === null) {\n        comparator = 'IS';\n      } else if (comparator === '!=' && value === null) {\n        comparator = 'IS NOT';\n      }\n\n      escapeOptions.acceptStrings = comparator.indexOf('LIKE') !== -1;\n\n      if (escapeValue) {\n        value = this.escape(value, field, escapeOptions);\n\n        //if ANY is used with like, add parentheses to generate correct query\n        if (escapeOptions.acceptStrings && (comparator.indexOf('ANY') > comparator.indexOf('LIKE'))) {\n         value = '(' + value + ')';\n        }\n      }\n    }\n\n    if (key) {\n      var prefix = true;\n      if (key._isSequelizeMethod) {\n        key = this.handleSequelizeMethod(key);\n      } else if (Utils.isColString(key)) {\n        key = key.substr(1, key.length - 2).split('.');\n\n        if (key.length > 2) {\n          key = [\n            key.slice(0, -1).join('.'),\n            key[key.length - 1]\n          ];\n        }\n\n        key = key.map(this.quoteIdentifier.bind(this)).join('.');\n        prefix = false;\n      } else {\n        key = this.quoteIdentifier(key);\n      }\n\n      if (options.prefix && prefix) {\n        if (options.prefix instanceof Utils.literal) {\n          key = [this.handleSequelizeMethod(options.prefix), key].join('.');\n        } else {\n          key = [this.quoteTable(options.prefix), key].join('.');\n        }\n      }\n      return [key, value].join(' '+comparator+' ');\n    }\n    return value;\n  },\n\n  /*\n    Takes something and transforms it into values of a where condition.\n  */\n  getWhereConditions: function(smth, tableName, factory, options, prepend) {\n    var result = null\n      , where = {}\n      , self = this;\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (typeof prepend === 'undefined') {\n      prepend = true;\n    }\n\n    if (smth && smth._isSequelizeMethod === true) { // Checking a property is cheaper than a lot of instanceof calls\n      result = this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    } else if (Utils._.isPlainObject(smth)) {\n      return self.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (typeof smth === 'number') {\n      var primaryKeys = !!factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return self.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (typeof smth === 'string') {\n      return self.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (Buffer.isBuffer(smth)) {\n      result = this.escape(smth);\n    } else if (Array.isArray(smth)) {\n      if (smth.length === 0) return '1=1';\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        var _smth = { $and: smth };\n        result = self.getWhereConditions(_smth, tableName, factory, options, prepend);\n      } else {\n        result = Utils.format(smth, this.dialect);\n      }\n    } else if (smth === null) {\n      return self.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n\n    return result ? result : '1=1';\n  },\n\n  booleanValue: function(value) {\n    return value;\n  }\n};\n\nmodule.exports = QueryGenerator;\n"], "fixing_code": ["  'use strict';\n\nvar Utils = require('../../utils')\n  , SqlString = require('../../sql-string')\n  , Model = require('../../model')\n  , DataTypes = require('../../data-types')\n  , _ = require('lodash')\n  , util = require('util')\n  , Dottie = require('dottie')\n  , BelongsTo = require('../../associations/belongs-to')\n  , BelongsToMany = require('../../associations/belongs-to-many')\n  , HasMany = require('../../associations/has-many')\n  , uuid = require('uuid')\n  , semver = require('semver')\n  , deprecate = require('depd')('sequelize');\n\n/* istanbul ignore next */\nvar throwMethodUndefined = function(methodName) {\n  throw new Error('The method \"' + methodName + '\" is not defined! Please add it to your sql dialect.');\n};\n\nvar QueryGenerator = {\n  options: {},\n\n  extractTableDetails: function(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || 'public',\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || '.'\n    };\n  },\n\n  addSchema: function(param) {\n    var self = this;\n\n    if (!param.$schema) return param.tableName || param;\n\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param.$schema,\n      delimiter: param.$schemaDelimiter || '.',\n      toString: function() {\n        return self.quoteTable(this);\n      }\n    };\n  },\n\n  /*\n    Returns a query for dropping a schema\n  */\n  dropSchema: function(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  },\n\n  /*\n    Returns a query for creating a table.\n    Parameters:\n      - tableName: Name of the new table.\n      - attributes: An object with containing attribute-attributeType-pairs.\n                    Attributes should have the format:\n                    {attributeName: type, attr2: type2}\n                    --> e.g. {title: 'VARCHAR(255)'}\n      - options: An object with options.\n                 Defaults: { engine: 'InnoDB', charset: null }\n  */\n  /* istanbul ignore next */\n  createTableQuery: function(tableName, attributes, options) {\n    throwMethodUndefined('createTableQuery');\n  },\n\n  versionQuery: function(tableName, attributes, options) {\n    throwMethodUndefined('versionQuery');\n  },\n\n  describeTableQuery: function(tableName, schema, schemaDelimiter) {\n    var table = this.quoteTable(\n      this.addSchema({\n        tableName: tableName,\n        $schema: schema,\n        $schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return 'DESCRIBE ' + table + ';';\n  },\n\n  /*\n    Returns a query for dropping a table.\n  */\n  dropTableQuery: function(tableName, options) {\n    options = options || {};\n\n    var query = 'DROP TABLE IF EXISTS <%= table %>;';\n\n    return Utils._.template(query)({\n      table: this.quoteTable(tableName)\n    });\n  },\n\n  /*\n    Returns a rename table query.\n    Parameters:\n      - originalTableName: Name of the table before execution.\n      - futureTableName: Name of the table after execution.\n  */\n  renameTableQuery: function(before, after) {\n    var query = 'ALTER TABLE <%= before %> RENAME TO <%= after %>;';\n    return Utils._.template(query)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  },\n\n  /*\n    Returns a query, which gets all available table names in the database.\n  */\n  /* istanbul ignore next */\n  showTablesQuery: function() {\n    throwMethodUndefined('showTablesQuery');\n  },\n\n  /*\n    Returns a query, which adds an attribute to an existing table.\n    Parameters:\n      - tableName: Name of the existing table.\n      - attributes: A hash with attribute-attributeOptions-pairs.\n        - key: attributeName\n        - value: A hash with attribute specific options:\n          - type: DataType\n          - defaultValue: A String with the default value\n          - allowNull: Boolean\n  */\n  /* istanbul ignore next */\n  addColumnQuery: function(tableName, attributes) {\n    throwMethodUndefined('addColumnQuery');\n  },\n\n  /*\n    Returns a query, which removes an attribute from an existing table.\n    Parameters:\n      - tableName: Name of the existing table\n      - attributeName: Name of the obsolete attribute.\n  */\n  /* istanbul ignore next */\n  removeColumnQuery: function(tableName, attributeName) {\n    throwMethodUndefined('removeColumnQuery');\n  },\n\n  /*\n    Returns a query, which modifies an existing attribute from a table.\n    Parameters:\n      - tableName: Name of the existing table.\n      - attributes: A hash with attribute-attributeOptions-pairs.\n        - key: attributeName\n        - value: A hash with attribute specific options:\n          - type: DataType\n          - defaultValue: A String with the default value\n          - allowNull: Boolean\n  */\n  /* istanbul ignore next */\n  changeColumnQuery: function(tableName, attributes) {\n    throwMethodUndefined('changeColumnQuery');\n  },\n\n  /*\n    Returns a query, which renames an existing attribute.\n    Parameters:\n      - tableName: Name of an existing table.\n      - attrNameBefore: The name of the attribute, which shall be renamed.\n      - attrNameAfter: The name of the attribute, after renaming.\n  */\n  /* istanbul ignore next */\n  renameColumnQuery: function(tableName, attrNameBefore, attrNameAfter) {\n    throwMethodUndefined('renameColumnQuery');\n  },\n\n  /*\n    Returns an insert into command. Parameters: table name + hash of attribute-value-pairs.\n  */\n  insertQuery: function(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    var query\n      , valueQuery = '<%= tmpTable %>INSERT<%= ignore %> INTO <%= table %> (<%= attributes %>)<%= output %> VALUES (<%= values %>)'\n      , emptyQuery = '<%= tmpTable %>INSERT<%= ignore %> INTO <%= table %><%= output %>'\n      , outputFragment\n      , fields = []\n      , values = []\n      , key\n      , value\n      , identityWrapperRequired = false\n      , modelAttributeMap = {}\n      , tmpTable = ''         //tmpTable declaration for trigger\n      , selectFromTmp = ''    //Select statement for trigger\n      , tmpColumns = ''       //Columns for temp table for trigger\n      , outputColumns = ''    //Columns to capture into temp table for trigger\n      , attribute             //Model attribute holder\n      , modelKey;             //key for model\n\n    if (modelAttributes) {\n      Utils._.each(modelAttributes, function(attribute, key) {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this._dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this._dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (!!this._dialect.supports.returnValues.returning) {\n        valueQuery += ' RETURNING *';\n        emptyQuery += ' RETURNING *';\n      } else if (!!this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n            tmpTable = 'declare @tmp table (<%= columns %>); ';\n\n            for (modelKey in modelAttributes){\n              attribute = modelAttributes[modelKey];\n              if(!(attribute.type instanceof DataTypes.VIRTUAL)){\n                if (tmpColumns.length > 0){\n                  tmpColumns += ',';\n                  outputColumns += ',';\n                }\n\n                tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();\n                outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);\n              }\n            }\n\n            var replacement ={\n              columns : tmpColumns\n            };\n\n            tmpTable = Utils._.template(tmpTable)(replacement).trim();\n            outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';\n            selectFromTmp = ';select * from @tmp';\n\n            valueQuery += selectFromTmp;\n            emptyQuery += selectFromTmp;\n        }\n      }\n    }\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Mostly for internal use, so we expect the user to know what he's doing!\n      // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n      if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {\n        // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)\n        var delimiter = '$func_' + uuid.v4().replace(/-/g, '') + '$';\n\n        options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response <%= table %>, OUT sequelize_caught_exception text) RETURNS RECORD AS ' + delimiter +\n          ' BEGIN ' + valueQuery + ' INTO response; EXCEPTION ' + options.exception + ' END ' + delimiter +\n          ' LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()';\n      } else {\n        options.exception = 'WHEN unique_violation THEN NULL;';\n        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF <%= table %> AS $body$ BEGIN RETURN QUERY ' + valueQuery + '; EXCEPTION ' + options.exception + ' END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();';\n      }\n    }\n\n    if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {\n      valueQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;\n      emptyQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;\n    }\n\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (key in valueHash) {\n      if (valueHash.hasOwnProperty(key)) {\n        value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1,1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push('DEFAULT');\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          values.push(this.escape(value, (modelAttributeMap && modelAttributeMap[key]) || undefined, { context: 'INSERT' }));\n        }\n      }\n    }\n\n    var replacements = {\n      ignore: options.ignore ? this._dialect.supports.IGNORE : '',\n      table: this.quoteTable(table),\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: values.join(','),\n      tmpTable: tmpTable\n    };\n\n    query = (replacements.attributes.length ? valueQuery : emptyQuery) + ';';\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = [\n        'SET IDENTITY_INSERT', this.quoteTable(table), 'ON;',\n        query,\n        'SET IDENTITY_INSERT', this.quoteTable(table), 'OFF;',\n      ].join(' ');\n    }\n\n    return Utils._.template(query)(replacements);\n  },\n\n  /*\n    Returns an insert into command for multiple values.\n    Parameters: table name + list of hashes of attribute-value-pairs.\n  */\n  bulkInsertQuery: function(tableName, attrValueHashes, options, rawAttributes) {\n    options = options || {};\n    rawAttributes = rawAttributes || {};\n\n    var query = 'INSERT<%= ignoreDuplicates %> INTO <%= table %> (<%= attributes %>) VALUES <%= tuples %><%= onDuplicateKeyUpdate %><%= returning %>;'\n      , tuples = []\n      , serials = []\n      , allAttributes = []\n      , onDuplicateKeyUpdate = '';\n\n    attrValueHashes.forEach(function(attrValueHash) {\n      _.forOwn(attrValueHash, function(value, key) {\n        if (allAttributes.indexOf(key) === -1) {\n          allAttributes.push(key);\n        }\n\n        if (rawAttributes[key] && rawAttributes[key].autoIncrement === true) {\n          serials.push(key);\n        }\n      });\n    });\n\n    attrValueHashes.forEach(function(attrValueHash) {\n      tuples.push('(' +\n        allAttributes.map(function(key) {\n          if (this._dialect.supports.bulkDefault && serials.indexOf(key) !== -1) {\n            return attrValueHash[key] || 'DEFAULT';\n          }\n          return this.escape(attrValueHash[key], rawAttributes[key], { context: 'INSERT' });\n        }, this).join(',') +\n        ')');\n    }, this);\n\n    if (this._dialect.supports.updateOnDuplicate && options.updateOnDuplicate) {\n      onDuplicateKeyUpdate += ' ON DUPLICATE KEY UPDATE ' + options.updateOnDuplicate.map(function(attr) {\n        var field = rawAttributes && rawAttributes[attr] && rawAttributes[attr].field || attr;\n        var key = this.quoteIdentifier(field);\n        return key + '=VALUES(' + key + ')';\n      }, this).join(',');\n    }\n\n    var replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.ignoreDuplicates : '',\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map(function(attr) {\n        return this.quoteIdentifier(attr);\n      }, this).join(','),\n      tuples: tuples.join(','),\n      onDuplicateKeyUpdate: onDuplicateKeyUpdate,\n      returning: this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : ''\n    };\n\n    return _.template(query)(replacements);\n  },\n\n  /*\n    Returns an update query.\n    Parameters:\n      - tableName -> Name of the table\n      - values -> A hash with attribute-value-pairs\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n  */\n  updateQuery: function(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    var query\n      , values = []\n      , outputFragment\n      , modelAttributeMap = {}\n      , tmpTable = ''         //tmpTable declaration for trigger\n      , selectFromTmp = ''    //Select statement for trigger\n      , tmpColumns = ''       //Columns for temp table for trigger\n      , outputColumns = ''    //Columns to capture into temp table for trigger\n      , attribute             //Model attribute holder\n      , modelKey;             //key for model\n\n    query = '<%= tmpTable %>UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';\n\n    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n      query += ' LIMIT ' + this.escape(options.limit) + ' ';\n    }\n\n    if (this._dialect.supports.returnValues) {\n      if (!!this._dialect.supports.returnValues.output) {\n        // we always need this for mssql\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n            tmpTable = 'declare @tmp table (<%= columns %>); ';\n\n            for (modelKey in attributes){\n              attribute = attributes[modelKey];\n              if(!(attribute.type instanceof DataTypes.VIRTUAL)){\n                if (tmpColumns.length > 0){\n                  tmpColumns += ',';\n                  outputColumns += ',';\n                }\n\n                tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();\n                outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);\n              }\n            }\n\n            var replacement ={\n              columns : tmpColumns\n            };\n\n            tmpTable = Utils._.template(tmpTable)(replacement).trim();\n            outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';\n            selectFromTmp = ';select * from @tmp';\n\n            query += selectFromTmp;\n        }\n      } else if (this._dialect.supports.returnValues && options.returning) {\n        // ensure that the return output is properly mapped to model fields.\n        options.mapToModel = true;\n        query += ' RETURNING *';\n      }\n    }\n\n    if (attributes) {\n      Utils._.each(attributes, function(attribute, key) {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (var key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] &&\n          modelAttributeMap[key].autoIncrement === true &&\n          !this._dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      var value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value, (modelAttributeMap && modelAttributeMap[key] || undefined), { context: 'UPDATE' }));\n    }\n\n    var replacements = {\n      table: this.quoteTable(tableName),\n      values: values.join(','),\n      output: outputFragment,\n      where: this.whereQuery(where),\n      tmpTable: tmpTable\n    };\n\n    if (values.length === 0) {\n      return '';\n    }\n\n    return Utils._.template(query)(replacements).trim();\n  },\n\n  /*\n    Returns an upsert query.\n  */\n  upsertQuery: function (tableName, insertValues, updateValues, where, rawAttributes, options) {\n    throwMethodUndefined('upsertQuery');\n  },\n\n  /*\n    Returns a deletion query.\n    Parameters:\n      - tableName -> Name of the table\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n    Options:\n      - limit -> Maximaum count of lines to delete\n      - truncate -> boolean - whether to use an 'optimized' mechanism (i.e. TRUNCATE) if available,\n                              note that this should not be the default behaviour because TRUNCATE does not\n                              always play nicely (e.g. InnoDB tables with FK constraints)\n                              (@see http://dev.mysql.com/doc/refman/5.6/en/truncate-table.html).\n                              Note that truncate must ignore limit and where\n  */\n  /* istanbul ignore next */\n  deleteQuery: function(tableName, where, options) {\n    throwMethodUndefined('deleteQuery');\n  },\n\n  /*\n    Returns an update query.\n    Parameters:\n      - tableName -> Name of the table\n      - values -> A hash with attribute-value-pairs\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n  */\n  incrementQuery: function(tableName, attrValueHash, where, options) {\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);\n\n    var query\n      , key\n      , value\n      , values = []\n      , outputFragment;\n\n    query = 'UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';\n    if (this._dialect.supports.returnValues) {\n      if (!!this._dialect.supports.returnValues.returning) {\n        query += ' RETURNING *';\n      } else if (!!this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n      }\n    }\n\n    for (key in attrValueHash) {\n      value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.quoteIdentifier(key) + ' + ' + this.escape(value));\n    }\n\n    options = options || {};\n    for (key in options) {\n      value = options[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value));\n    }\n\n    var replacements = {\n      table: this.quoteTable(tableName),\n      values: values.join(','),\n      output: outputFragment,\n      where: this.whereQuery(where)\n    };\n\n    return Utils._.template(query)(replacements);\n  },\n\n  nameIndexes: function (indexes, rawTablename) {\n    return Utils._.map(indexes, function (index) {\n      if (!index.hasOwnProperty('name')) {\n        var onlyAttributeNames = index.fields.map(function(field) {\n          return (typeof field === 'string') ? field : (field.name || field.attribute);\n        }.bind(this));\n\n        index.name = Utils.inflection.underscore(rawTablename + '_' + onlyAttributeNames.join('_'));\n      }\n\n      return index;\n    });\n  },\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n  */\n  addIndexQuery: function(tableName, attributes, options, rawTablename) {\n    var fieldsSql;\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    // Backwards compatability\n    if (options.indexName) {\n      options.name = options.indexName;\n    }\n    if (options.indicesType) {\n      options.type = options.indicesType;\n    }\n    if (options.indexType || options.method) {\n      options.using = options.indexType || options.method;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && _.isString(options.prefix)) {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n      options.prefix = options.prefix.replace(/(\\\"|\\')/g, '');\n    }\n\n    fieldsSql = options.fields.map(function(field) {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      } else if (field._isSequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      } else {\n        var result = '';\n\n        if (field.attribute) {\n          field.name = field.attribute;\n        }\n\n        if (!field.name) {\n          throw new Error('The following index field has no name: ' + util.inspect(field));\n        }\n\n        result += this.quoteIdentifier(field.name);\n\n        if (this._dialect.supports.index.collate && field.collate) {\n          result += ' COLLATE ' + this.quoteIdentifier(field.collate);\n        }\n\n        if (this._dialect.supports.index.length && field.length) {\n          result += '(' + field.length + ')';\n        }\n\n        if (field.order) {\n          result += ' ' + field.order;\n        }\n\n        return result;\n      }\n    }.bind(this));\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = this.nameIndexes([options], options.prefix)[0];\n    }\n\n    options = Model.prototype.$conformIndex(options);\n\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    if (_.isString(tableName)) {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    var concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined\n      , ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        tableName,\n        concurrently,\n        'ADD'\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this._dialect.supports.indexViaAlter ? concurrently : undefined,\n      this.quoteIdentifiers(options.name),\n      this._dialect.supports.index.using === 1 && options.using ? 'USING ' + options.using : '',\n      !this._dialect.supports.indexViaAlter ? 'ON ' + tableName : undefined,\n      this._dialect.supports.index.using === 2 && options.using ? 'USING ' + options.using : '',\n      '(' + fieldsSql.join(', ') + (options.operator ? ' '+options.operator : '') + ')',\n      (this._dialect.supports.index.parser && options.parser ? 'WITH PARSER ' + options.parser : undefined),\n      (this._dialect.supports.index.where && options.where ? options.where : undefined)\n    );\n\n    return Utils._.compact(ind).join(' ');\n  },\n\n  /*\n    Returns a query listing indexes for a given table.\n    Parameters:\n      - tableName: Name of an existing table.\n      - options:\n        - database: Name of the database.\n  */\n  /* istanbul ignore next */\n  showIndexesQuery: function(tableName, options) {\n    throwMethodUndefined('showIndexesQuery');\n  },\n\n  /*\n    Returns a remove index query.\n    Parameters:\n      - tableName: Name of an existing table.\n      - indexNameOrAttributes: The name of the index as string or an array of attribute names.\n  */\n  /* istanbul ignore next */\n  removeIndexQuery: function(tableName, indexNameOrAttributes) {\n    throwMethodUndefined('removeIndexQuery');\n  },\n\n  /*\n    This method transforms an array of attribute hashes into equivalent\n    sql attribute definition.\n  */\n  /* istanbul ignore next */\n  attributesToSQL: function(attributes) {\n    throwMethodUndefined('attributesToSQL');\n  },\n\n  /*\n    Returns all auto increment fields of a factory.\n  */\n  /* istanbul ignore next */\n  findAutoIncrementField: function(factory) {\n    throwMethodUndefined('findAutoIncrementField');\n  },\n\n\n  quoteTable: function(param, as) {\n    var table = '';\n\n    if (as === true) {\n      as = param.as || param.name || param;\n    }\n\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += this.quoteIdentifier(param.schema) + '.';\n        }\n\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || '.');\n        }\n\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n\n\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n\n    if (as) {\n      table += ' AS ' + this.quoteIdentifier(as);\n    }\n    return table;\n  },\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model or an object {model: Model, as: String}, matching include\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n  */\n  quote: function(obj, parent, force) {\n    if (Utils._.isString(obj)) {\n      return this.quoteIdentifiers(obj, force);\n    } else if (Array.isArray(obj)) {\n      // loop through array, adding table names of models to quoted\n      // (checking associations to see if names should be singularised or not)\n      var tableNames = []\n        , parentAssociation\n        , len = obj.length\n        , item\n        , model\n        , as\n        , association;\n\n      for (var i = 0; i < len - 1; i++) {\n        item = obj[i];\n        if (item._modelAttribute || Utils._.isString(item) || item._isSequelizeMethod || 'raw' in item) {\n          break;\n        }\n\n        if (item instanceof Model) {\n          model = item;\n          as = undefined;\n        } else {\n          model = item.model;\n          as = item.as;\n        }\n\n        // check if model provided is through table\n        if (!as && parentAssociation && parentAssociation.through && parentAssociation.through.model === model) {\n          association = {as: model.name};\n        } else {\n          // find applicable association for linking parent to this model\n          association = parent.getAssociation(model, as);\n        }\n\n        if (association) {\n          tableNames[i] = association.as;\n          parent = model;\n          parentAssociation = association;\n        } else {\n          tableNames[i] = model.tableName;\n          throw new Error('\\'' + tableNames.join('.') + '\\' in order / group clause is not valid association');\n        }\n      }\n\n      // add 1st string as quoted, 2nd as unquoted raw\n      var sql = (i > 0 ? this.quoteIdentifier(tableNames.join('.')) + '.' : (Utils._.isString(obj[0]) && parent ? this.quoteIdentifier(parent.name) + '.' : '')) + this.quote(obj[i], parent, force);\n      if (i < len - 1) {\n        if (obj[i + 1]._isSequelizeMethod) {\n          sql += this.handleSequelizeMethod(obj[i + 1]);\n        } else {\n          sql += ' ' + obj[i + 1];\n        }\n      }\n      return sql;\n    } else if (obj._modelAttribute) {\n      return this.quoteTable(obj.Model.name) + '.' + obj.fieldName;\n    } else if (obj._isSequelizeMethod) {\n      return this.handleSequelizeMethod(obj);\n    } else if (Utils._.isObject(obj) && 'raw' in obj) {\n      return obj.raw;\n    } else {\n      throw new Error('Unknown structure passed to order / group: ' + JSON.stringify(obj));\n    }\n  },\n\n  /*\n   Create a trigger\n   */\n  /* istanbul ignore next */\n  createTrigger: function(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray) {\n    throwMethodUndefined('createTrigger');\n  },\n\n  /*\n   Drop a trigger\n   */\n  /* istanbul ignore next */\n  dropTrigger: function(tableName, triggerName) {\n    throwMethodUndefined('dropTrigger');\n  },\n\n  /*\n   Rename a trigger\n  */\n  /* istanbul ignore next */\n  renameTrigger: function(tableName, oldTriggerName, newTriggerName) {\n    throwMethodUndefined('renameTrigger');\n  },\n\n  /*\n   Create a function\n   */\n  /* istanbul ignore next */\n  createFunction: function(functionName, params, returnType, language, body, options) {\n    throwMethodUndefined('createFunction');\n  },\n\n  /*\n   Drop a function\n   */\n  /* istanbul ignore next */\n  dropFunction: function(functionName, params) {\n    throwMethodUndefined('dropFunction');\n  },\n\n  /*\n   Rename a function\n   */\n  /* istanbul ignore next */\n  renameFunction: function(oldFunctionName, params, newFunctionName) {\n    throwMethodUndefined('renameFunction');\n  },\n\n  /*\n    Escape an identifier (e.g. a table or attribute name)\n  */\n  /* istanbul ignore next */\n  quoteIdentifier: function(identifier, force) {\n    throwMethodUndefined('quoteIdentifier');\n  },\n\n  /*\n    Split an identifier into .-separated tokens and quote each part\n  */\n  quoteIdentifiers: function(identifiers, force) {\n    if (identifiers.indexOf('.') !== -1) {\n      identifiers = identifiers.split('.');\n      return this.quoteIdentifier(identifiers.slice(0, identifiers.length - 1).join('.')) + '.' + this.quoteIdentifier(identifiers[identifiers.length - 1]);\n    } else {\n      return this.quoteIdentifier(identifiers);\n    }\n  },\n\n  /*\n    Escape a value (e.g. a string, number or date)\n  */\n  escape: function(value, field, options) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value._isSequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      } else {\n        if (field && field.type) {\n          if (this.typeValidation && field.type.validate && value) {\n            if (options.isList && Array.isArray(value)) {\n              _.forEach(value, function(item) {\n                field.type.validate(item, options);\n              });\n            } else {\n              field.type.validate(value, options);\n            }\n          }\n\n          if (field.type.stringify) {\n            // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n            var simpleEscape = _.partialRight(SqlString.escape, this.options.timezone, this.dialect);\n\n            value = field.type.stringify(value, { escape: simpleEscape, field: field, timezone: this.options.timezone });\n\n            if (field.type.escape === false) {\n              // The data-type already did the required escaping\n              return value;\n            }\n          }\n        }\n      }\n    }\n\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} schemaName The name of the schema.\n   * @return {String}            The generated sql query.\n   */\n  /* istanbul ignore next */\n  getForeignKeysQuery: function(tableName, schemaName) {\n    throwMethodUndefined('getForeignKeysQuery');\n  },\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} foreignKey The name of the foreign key constraint.\n   * @return {String}            The generated sql query.\n   */\n  /* istanbul ignore next */\n  dropForeignKeyQuery: function(tableName, foreignKey) {\n    throwMethodUndefined('dropForeignKeyQuery');\n  },\n\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n                 OR a string with conditions (e.g. 'name=\"foo\"').\n                 If you use a string, you have to escape it on your own.\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n  */\n\n  selectQuery: function(tableName, options, model) {\n    // Enter and change at your own peril -- Mick Hansen\n\n    options = options || {};\n\n    var table = null\n      , self = this\n      , query\n      , limit = options.limit\n      , mainModel = model\n      , mainQueryItems = []\n      , mainAttributes = options.attributes && options.attributes.slice()\n      , mainJoinQueries = []\n      // We'll use a subquery if we have a hasMany association and a limit\n      , subQuery = options.subQuery === undefined ?\n                   limit && options.hasMultiAssociation :\n                   options.subQuery\n      , subQueryItems = []\n      , subQueryAttributes = null\n      , subJoinQueries = []\n      , mainTableAs = null;\n\n    if (options.tableAs) {\n      mainTableAs = this.quoteTable(options.tableAs);\n    } else if (!Array.isArray(tableName) && model) {\n      mainTableAs = this.quoteTable(model.name);\n    }\n\n    table = !Array.isArray(tableName) ? this.quoteTable(tableName) : tableName.map(function(t) {\n      if (Array.isArray(t)) {\n        return this.quoteTable(t[0], t[1]);\n      }\n      return this.quoteTable(t, true);\n    }.bind(this)).join(', ');\n\n    if (subQuery && mainAttributes) {\n      model.primaryKeyAttributes.forEach(function(keyAtt) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!_.find(mainAttributes, function (attr) {\n          return keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1];\n        })) {\n          mainAttributes.push(model.rawAttributes[keyAtt].field ? [keyAtt, model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      });\n    }\n\n    // Escape attributes\n    mainAttributes = mainAttributes && mainAttributes.map(function(attr) {\n      var addTable = true;\n\n      if (attr._isSequelizeMethod) {\n        return self.handleSequelizeMethod(attr);\n      }\n\n      if (Array.isArray(attr) && attr.length === 2) {\n        attr = attr.slice();\n\n        if (attr[0]._isSequelizeMethod) {\n          attr[0] = self.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (\n          attr[0].indexOf('(') === -1 &&\n          attr[0].indexOf(')') === -1\n        ) {\n          attr[0] = self.quoteIdentifier(attr[0]);\n        } else {\n          deprecate('Use sequelize.fn / sequelize.literal to construct attributes');\n        }\n\n        attr = [attr[0], self.quoteIdentifier(attr[1])].join(' AS ');\n      } else {\n        if (\n          attr.indexOf(Utils.TICK_CHAR) < 0 &&\n          attr.indexOf('\"') < 0\n        ) {\n          attr = self.quoteIdentifiers(attr);\n        } else {\n          attr = self.escape(attr);\n        }\n      }\n\n      if (options.include && attr.indexOf('.') === -1 && addTable) {\n        attr = mainTableAs + '.' + attr;\n      }\n\n      return attr;\n    });\n\n    // If no attributes specified, use *\n    mainAttributes = mainAttributes || (options.include ? [mainTableAs + '.*'] : ['*']);\n\n    // If subquery, we ad the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      subQueryAttributes = mainAttributes;\n      mainAttributes = [(mainTableAs || table) + '.*'];\n    }\n\n    if (options.include) {\n      var generateJoinQueries = function(include, parentTable) {\n        var table = include.model.getTableName()\n          , as = include.as\n          , joinQueryItem = ''\n          , joinQueries = {\n            mainQuery: [],\n            subQuery: []\n          }\n          , attributes\n          , association = include.association\n          , through = include.through\n          , joinType = include.required ? ' INNER JOIN ' : ' LEFT OUTER JOIN '\n          , parentIsTop = !include.parent.association && include.parent.model.name === options.model.name\n          , whereOptions = Utils._.clone(options)\n          , targetWhere;\n\n        whereOptions.keysEscaped = true;\n\n        if (tableName !== parentTable && mainTableAs !== parentTable) {\n          as = parentTable + '.' + include.as;\n        }\n\n        // includeIgnoreAttributes is used by aggregate functions\n        if (options.includeIgnoreAttributes !== false) {\n          attributes = include.attributes.map(function(attr) {\n            var attrAs = attr,\n                verbatim = false;\n\n            if (Array.isArray(attr) && attr.length === 2) {\n              if (attr[0]._isSequelizeMethod) {\n                if (attr[0] instanceof Utils.literal ||\n                  attr[0] instanceof Utils.cast ||\n                  attr[0] instanceof Utils.fn\n                ) {\n                  verbatim = true;\n                }\n              }\n\n              attr = attr.map(function($attr) {\n                return $attr._isSequelizeMethod ? self.handleSequelizeMethod($attr) : $attr;\n              });\n\n              attrAs = attr[1];\n              attr = attr[0];\n            } else if (attr instanceof Utils.literal) {\n              return attr.val; // We trust the user to rename the field correctly\n            } else if (attr instanceof Utils.cast ||\n              attr instanceof Utils.fn\n            ) {\n              throw new Error(\n                'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +\n                'This means the attribute will not be added to the returned instance'\n              );\n            }\n\n            var prefix;\n\n            if (verbatim === true) {\n              prefix = attr;\n            } else {\n              prefix = self.quoteIdentifier(as) + '.' + self.quoteIdentifier(attr);\n            }\n\n            return prefix + ' AS ' + self.quoteIdentifier(as + '.' + attrAs, true);\n          });\n\n          if (include.subQuery && subQuery) {\n            subQueryAttributes = subQueryAttributes.concat(attributes);\n          } else {\n            mainAttributes = mainAttributes.concat(attributes);\n          }\n        }\n\n        if (through) {\n          var throughTable = through.model.getTableName()\n            , throughAs = as + '.' + through.as\n            , throughAttributes = through.attributes.map(function(attr) {\n              return self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr) +\n                     ' AS ' +\n                     self.quoteIdentifier(throughAs + '.' + (Array.isArray(attr) ? attr[1] : attr));\n            })\n            , primaryKeysSource = association.source.primaryKeyAttributes\n            , tableSource = parentTable\n            , identSource = association.identifierField\n            , attrSource = primaryKeysSource[0]\n            , primaryKeysTarget = association.target.primaryKeyAttributes\n            , tableTarget = as\n            , identTarget = association.foreignIdentifierField\n            , attrTarget = association.target.rawAttributes[primaryKeysTarget[0]].field || primaryKeysTarget[0]\n\n            , sourceJoinOn\n            , targetJoinOn\n\n            , throughWhere;\n\n          if (options.includeIgnoreAttributes !== false) {\n            // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n            mainAttributes = mainAttributes.concat(throughAttributes);\n          }\n\n          // Figure out if we need to use field or attribute\n          if (!subQuery) {\n            attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;\n          }\n          if (subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== mainModel) {\n            attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;\n          }\n\n          // Filter statement for left side of through\n          // Used by both join and subquery where\n\n          // If parent include was in a subquery need to join on the aliased attribute\n\n          if (subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n            sourceJoinOn = self.quoteIdentifier(tableSource + '.' + attrSource) + ' = ';\n          } else {\n            sourceJoinOn = self.quoteTable(tableSource) + '.' + self.quoteIdentifier(attrSource) + ' = ';\n          }\n          sourceJoinOn += self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(identSource);\n\n          // Filter statement for right side of through\n          // Used by both join and subquery where\n          targetJoinOn = self.quoteIdentifier(tableTarget) + '.' + self.quoteIdentifier(attrTarget) + ' = ';\n          targetJoinOn += self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(identTarget);\n\n          if (include.through.where) {\n            throughWhere = self.getWhereConditions(include.through.where, self.sequelize.literal(self.quoteIdentifier(throughAs)), include.through.model);\n          }\n\n          if (self._dialect.supports.joinTableDependent) {\n            // Generate a wrapped join so that the through table join can be dependent on the target join\n            joinQueryItem += joinType + '(';\n            joinQueryItem += self.quoteTable(throughTable, throughAs);\n            joinQueryItem += ' INNER JOIN ' + self.quoteTable(table, as) + ' ON ';\n            joinQueryItem += targetJoinOn;\n\n            if (throughWhere) {\n              joinQueryItem += ' AND ' + throughWhere;\n            }\n\n            joinQueryItem += ') ON '+sourceJoinOn;\n          } else {\n            // Generate join SQL for left side of through\n            joinQueryItem += joinType + self.quoteTable(throughTable, throughAs)  + ' ON ';\n            joinQueryItem += sourceJoinOn;\n\n            // Generate join SQL for right side of through\n            joinQueryItem += joinType + self.quoteTable(table, as) + ' ON ';\n            joinQueryItem += targetJoinOn;\n\n            if (throughWhere) {\n              joinQueryItem += ' AND ' + throughWhere;\n            }\n\n          }\n\n          if (include.where || include.through.where) {\n            if (include.where) {\n              targetWhere = self.getWhereConditions(include.where, self.sequelize.literal(self.quoteIdentifier(as)), include.model, whereOptions);\n              if (targetWhere) {\n                joinQueryItem += ' AND ' + targetWhere;\n              }\n            }\n            if (subQuery && include.required) {\n              if (!options.where) options.where = {};\n              (function (include) {\n                // Closure to use sane local variables\n\n                var parent = include\n                  , child = include\n                  , nestedIncludes = []\n                  , topParent\n                  , topInclude\n                  , $query;\n\n                while (parent = parent.parent) {\n                  nestedIncludes = [_.extend({}, child, {include: nestedIncludes})];\n                  child = parent;\n                }\n\n                topInclude = nestedIncludes[0];\n                topParent = topInclude.parent;\n\n                if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n                  $query = self.selectQuery(topInclude.through.model.getTableName(), {\n                    attributes: [topInclude.through.model.primaryKeyField],\n                    include: Model.$validateIncludedElements({\n                      model: topInclude.through.model,\n                      include: [{\n                        association: topInclude.association.toTarget,\n                        required: true\n                      }]\n                    }).include,\n                    model: topInclude.through.model,\n                    where: { $and: [\n                      self.sequelize.asIs([\n                        self.quoteTable(topParent.model.name) + '.' + self.quoteIdentifier(topParent.model.primaryKeyField),\n                        self.quoteIdentifier(topInclude.through.model.name) + '.' + self.quoteIdentifier(topInclude.association.identifierField)\n                      ].join(' = ')),\n                      topInclude.through.where\n                    ]},\n                    limit: 1,\n                    includeIgnoreAttributes: false\n                  }, topInclude.through.model);\n                } else {\n                  var isBelongsTo = topInclude.association.associationType === 'BelongsTo';\n                  var join = [\n                    self.quoteTable(topParent.model.name) + '.' + self.quoteIdentifier(isBelongsTo ? topInclude.association.identifierField : topParent.model.primaryKeyAttributes[0]),\n                    self.quoteIdentifier(topInclude.model.name) + '.' + self.quoteIdentifier(isBelongsTo ? topInclude.model.primaryKeyAttributes[0] : topInclude.association.identifierField)\n                  ].join(' = ');\n                  $query = self.selectQuery(topInclude.model.tableName, {\n                    attributes: [topInclude.model.primaryKeyAttributes[0]],\n                    include: topInclude.include,\n                    where: {\n                      $join: self.sequelize.asIs(join)\n                    },\n                    limit: 1,\n                    includeIgnoreAttributes: false\n                  }, topInclude.model);\n                }\n\n                options.where['__' + throughAs] = self.sequelize.asIs([\n                  '(',\n                    $query.replace(/\\;$/, ''),\n                  ')',\n                  'IS NOT NULL'\n                ].join(' '));\n              })(include);\n            }\n          }\n        } else {\n          if (subQuery && include.subQueryFilter) {\n            var associationWhere = {}\n              , $query\n              , subQueryWhere;\n\n            associationWhere[association.identifierField] = {\n              $raw: self.quoteTable(parentTable) + '.' + self.quoteIdentifier(association.sourceKeyField || association.source.primaryKeyField)\n            };\n\n            if (!options.where) options.where = {};\n\n            // Creating the as-is where for the subQuery, checks that the required association exists\n            $query = self.selectQuery(include.model.getTableName(), {\n              attributes: [association.identifierField],\n              where: {\n                $and: [\n                  associationWhere,\n                  include.where || {}\n                ]\n              },\n              limit: 1\n            }, include.model);\n\n            subQueryWhere = self.sequelize.asIs([\n              '(',\n                $query.replace(/\\;$/, ''),\n              ')',\n              'IS NOT NULL'\n            ].join(' '));\n\n            if (Utils._.isPlainObject(options.where)) {\n              options.where['__' + as] = subQueryWhere;\n            } else {\n              options.where = { $and: [options.where, subQueryWhere] };\n            }\n          }\n\n          joinQueryItem = ' ' + self.joinIncludeQuery({\n            model: mainModel,\n            subQuery: options.subQuery,\n            include: include,\n            groupedLimit: options.groupedLimit\n          });\n        }\n\n        if (include.subQuery && subQuery) {\n          joinQueries.subQuery.push(joinQueryItem);\n        } else {\n          joinQueries.mainQuery.push(joinQueryItem);\n        }\n\n        if (include.include) {\n          include.include.filter(function (include) {\n            return !include.separate;\n          }).forEach(function(childInclude) {\n            if (childInclude._pseudo) return;\n            var childJoinQueries = generateJoinQueries(childInclude, as);\n\n            if (childInclude.subQuery && subQuery) {\n              joinQueries.subQuery = joinQueries.subQuery.concat(childJoinQueries.subQuery);\n            }\n            if (childJoinQueries.mainQuery) {\n              joinQueries.mainQuery = joinQueries.mainQuery.concat(childJoinQueries.mainQuery);\n            }\n\n          }.bind(this));\n        }\n\n        return joinQueries;\n      };\n\n      // Loop through includes and generate subqueries\n      options.include.filter(function (include) {\n        return !include.separate;\n      }).forEach(function(include) {\n        var joinQueries = generateJoinQueries(include, mainTableAs);\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n      }.bind(this));\n    }\n\n    // If using subQuery select defined subQuery attributes and join subJoinQueries\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, model, subQueryAttributes, table, mainTableAs));\n      subQueryItems.push(subJoinQueries.join(''));\n\n    // Else do it the reguar way\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTableAs) {\n          mainTableAs = table;\n        }\n\n        var groupedLimitOrder\n          , where = _.assign({}, options.where)\n          , whereKey\n          , include\n          , groupedTableName = mainTableAs;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          var groupedLimitOptions = Model.$validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: _.assign({\n                '$$PLACEHOLDER$$': true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model: model\n          });\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = _.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach(function(order, i) {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              var alias = 'subquery_order_' +i;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            }, this);\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n          delete options.order;\n          where.$$PLACEHOLDER$$ = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        var baseQuery = '('+this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            where: where,\n            include: include,\n            model: model\n          },\n          model\n        ).replace(/;$/, '')+')';\n        var placeHolder = this.whereItemQuery('$$PLACEHOLDER$$', true, { model: model })\n          , splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, model, mainAttributes, '('+\n          options.groupedLimit.values.map(function (value) {\n            var groupWhere = {};\n            if (whereKey) {\n              groupWhere[whereKey] = value;\n            }\n            if (include) {\n              groupWhere[options.groupedLimit.on.foreignIdentifierField] = value;\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n          }, this).join(\n            self._dialect.supports['UNION ALL'] ?' UNION ALL ' : ' UNION '\n          )\n        +')', mainTableAs));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, model, mainAttributes, table, mainTableAs));\n      }\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (options.hasOwnProperty('where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTableAs || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(' WHERE ' + options.where);\n        } else {\n          mainQueryItems.push(' WHERE ' + options.where);\n          // Walk the main query to update all selects\n          _.each(mainQueryItems, function(value, key) {\n            if(value.match(/^SELECT/)) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, mainAttributes, table, mainTableAs, options.where);\n            }\n          }.bind(this));\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map(function(t) { return this.quote(t, model); }.bind(this)).join(', ') : options.group;\n      if (subQuery) {\n        subQueryItems.push(' GROUP BY ' + options.group);\n      } else {\n        mainQueryItems.push(' GROUP BY ' + options.group);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (options.hasOwnProperty('having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (subQuery) {\n        subQueryItems.push(' HAVING ' + options.having);\n      } else {\n        mainQueryItems.push(' HAVING ' + options.having);\n      }\n    }\n    // Add ORDER to sub or main query\n    if (options.order) {\n      var orders = this.getQueryOrders(options, model, subQuery);\n\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(' ORDER BY ' + orders.mainQueryOrder.join(', '));\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(' ORDER BY ' + orders.subQueryOrder.join(', '));\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    var limitOrder = this.addLimitAndOffset(options, model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    // If using subQuery, select attributes from wrapped subQuery and join out join tables\n    if (subQuery) {\n      query = 'SELECT ' + mainAttributes.join(', ') + ' FROM (';\n      query += subQueryItems.join('');\n      query += ') AS ' + mainTableAs;\n      query += mainJoinQueries.join('');\n      query += mainQueryItems.join('');\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this._dialect.supports.lock) {\n      var lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {\n        query += ' FOR ' + lock;\n      } else if (lock === 'SHARE') {\n        query += ' ' + this._dialect.supports.forShare;\n      } else {\n        query += ' FOR UPDATE';\n      }\n      if (this._dialect.supports.lockOf && options.lock.of instanceof Model) {\n        query += ' OF ' + this.quoteTable(options.lock.of.name);\n      }\n    }\n\n    query += ';';\n\n    return query;\n  },\n\n  getQueryOrders: function(options, model, subQuery) {\n    var mainQueryOrder = [];\n    var subQueryOrder = [];\n\n    var validateOrder = function(order) {\n      if (order instanceof Utils.literal) return;\n\n      if (!_.includes([\n        'ASC',\n        'DESC',\n        'ASC NULLS LAST',\n        'DESC NULLS LAST',\n        'ASC NULLS FIRST',\n        'DESC NULLS FIRST',\n        'NULLS FIRST',\n        'NULLS LAST'\n      ], order.toUpperCase())) {\n        throw new Error(util.format('Order must be \\'ASC\\' or \\'DESC\\', \\'%s\\' given', order));\n      }\n    };\n\n    if (Array.isArray(options.order)) {\n      options.order.forEach(function(t) {\n        if (Array.isArray(t) && _.size(t) > 1) {\n          if (t[0] instanceof Model || t[0].model instanceof Model) {\n            if (typeof t[t.length - 2] === 'string') {\n              validateOrder(_.last(t));\n            }\n          } else {\n            validateOrder(_.last(t));\n          }\n        }\n\n        var hadSubquery = false;\n\n        if (subQuery && (Array.isArray(t) && !(t[0] instanceof Model) && !(t[0].model instanceof Model))) {\n          subQueryOrder.push(this.quote(t, model));\n          hadSubquery = true;\n        }\n\n        if (hadSubquery) {\n          for (var name in model.attributes) {\n            var attribute = model.attributes[name];\n            if (attribute.field && attribute.field === t[0]) {\n              t[0] = attribute.fieldName;\n            }\n          }\n        }\n\n        mainQueryOrder.push(this.quote(t, model));\n      }.bind(this));\n    } else {\n      var sql = this.quote(typeof options.order === 'string' ? new Utils.literal(options.order) : options.order, model);\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    }\n\n    return {\n      mainQueryOrder: mainQueryOrder,\n      subQueryOrder: subQueryOrder\n    };\n  },\n\n  selectFromTableFragment: function(options, model, attributes, tables, mainTableAs, whereClause) {\n    var fragment = 'SELECT ' + attributes.join(', ') + ' FROM ' + tables;\n\n    if(mainTableAs) {\n      fragment += ' AS ' + mainTableAs;\n    }\n\n    return fragment;\n  },\n\n  joinIncludeQuery: function(options) {\n    var subQuery = options.subQuery\n      , include = options.include\n      , association = include.association\n      , parent = include.parent\n      , parentIsTop = !include.parent.association && include.parent.model.name === options.model.name\n      , $parent\n      , joinType = include.required ? 'INNER JOIN ' : 'LEFT OUTER JOIN '\n      , joinOn\n      , joinWhere\n\n      /* Attributes for the left side */\n      , left = association.source\n      , asLeft\n      , attrLeft = association instanceof BelongsTo ?\n                   association.identifier :\n                   association.sourceKeyAttribute || left.primaryKeyAttribute\n      , fieldLeft = association instanceof BelongsTo ?\n                   association.identifierField :\n                   left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field\n\n      /* Attributes for the right side */\n      , right = include.model\n      , asRight = include.as\n      , tableRight = right.getTableName()\n      , fieldRight = association instanceof BelongsTo ?\n                     right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :\n                     association.identifierField;\n\n    while (($parent = ($parent && $parent.parent || include.parent)) && $parent.association) {\n      if (asLeft) {\n        asLeft = [$parent.as, asLeft].join('.');\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) asLeft = parent.as || parent.model.name;\n    else asRight = [asLeft, asRight].join('.');\n\n    joinOn = [\n      this.quoteTable(asLeft),\n      this.quoteIdentifier(fieldLeft)\n    ].join('.');\n\n    if ((options.groupedLimit && parentIsTop) || (subQuery && include.parent.subQuery && !include.subQuery)) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        joinOn = [\n          this.quoteTable(parent.as || parent.model.name),\n          this.quoteIdentifier(attrLeft)\n        ].join('.');\n      } else {\n        joinOn = this.quoteIdentifier(asLeft + '.' + attrLeft);\n      }\n    }\n\n    joinOn += ' = ' + this.quoteIdentifier(asRight) + '.' + this.quoteIdentifier(fieldRight);\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ' OR ' + joinWhere;\n        } else {\n          joinOn += ' AND ' + joinWhere;\n        }\n      }\n    }\n\n    return joinType + this.quoteTable(tableRight, asRight) + ' ON ' + joinOn;\n  },\n\n  /**\n   * Returns a query that starts a transaction.\n   *\n   * @param  {Boolean} value   A boolean that states whether autocommit shall be done or not.\n   * @param  {Object}  options An object with options.\n   * @return {String}          The generated sql query.\n   */\n  setAutocommitQuery: function(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    return 'SET autocommit = ' + (!!value ? 1 : 0) + ';';\n  },\n\n  /**\n   * Returns a query that sets the transaction isolation level.\n   *\n   * @param  {String} value   The isolation level.\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  setIsolationLevelQuery: function(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    return 'SET SESSION TRANSACTION ISOLATION LEVEL ' + value + ';';\n  },\n\n  generateTransactionId: function() {\n    return uuid.v4();\n  },\n\n  /**\n   * Returns a query that starts a transaction.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  startTransactionQuery: function(transaction) {\n    if (transaction.parent) {\n      // force quoting of savepoint identifiers for postgres\n      return 'SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';\n    }\n\n    return 'START TRANSACTION;';\n  },\n\n  /**\n   * Returns a query that defers the constraints. Only works for postgres.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  deferConstraintsQuery: function () {},\n\n  setConstraintQuery: function () {},\n  setDeferredQuery: function () {},\n  setImmediateQuery: function () {},\n\n  /**\n   * Returns a query that commits a transaction.\n   *\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  commitTransactionQuery: function(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT;';\n  },\n\n  /**\n   * Returns a query that rollbacks a transaction.\n   *\n   * @param  {Transaction} transaction\n   * @param  {Object} options An object with options.\n   * @return {String}         The generated sql query.\n   */\n  rollbackTransactionQuery: function(transaction) {\n    if (transaction.parent) {\n      // force quoting of savepoint identifiers for postgres\n      return 'ROLLBACK TO SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';\n    }\n\n    return 'ROLLBACK;';\n  },\n\n  /**\n   * Returns an SQL fragment for adding result constraints\n   *\n   * @param  {Object} options An object with selectQuery options.\n   * @param  {Object} options The model passed to the selectQuery.\n   * @return {String}         The generated sql query.\n   */\n  addLimitAndOffset: function(options, model) {\n    var fragment = '';\n\n    /*jshint eqeqeq:false*/\n    if (options.offset != null && options.limit == null) {\n      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n      } else {\n        fragment += ' LIMIT ' + this.escape(options.limit);\n      }\n    }\n\n    return fragment;\n  },\n\n  handleSequelizeMethod: function (smth, tableName, factory, options, prepend) {\n    var self = this\n      , result;\n\n    if (smth instanceof Utils.where) {\n      var value = smth.logic\n        , key;\n\n      if (smth.attribute._isSequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = this.quoteTable(smth.attribute.Model.name) + '.' + this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName);\n      }\n\n      if (value && value._isSequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        result = (value === 'NULL') ? key + ' IS NULL' : [key, value].join(smth.comparator);\n      } else if (_.isPlainObject(value)) {\n        result = this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      } else {\n        if (typeof value === 'boolean') {\n          value = this.booleanValue(value);\n        } else {\n          value = this.escape(value);\n        }\n\n        result = (value === 'NULL') ? key + ' IS NULL' : [key, value].join(' ' + smth.comparator + ' ');\n      }\n    } else if (smth instanceof Utils.literal) {\n      result = smth.val;\n    } else if (smth instanceof Utils.cast) {\n      if (smth.val._isSequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n\n      result = 'CAST(' + result + ' AS ' + smth.type.toUpperCase() + ')';\n    } else if (smth instanceof Utils.fn) {\n      result = smth.fn + '(' + smth.args.map(function(arg) {\n        if (arg._isSequelizeMethod) {\n          return self.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        } else if (_.isPlainObject(arg)) {\n          return self.whereItemsQuery(arg);\n        } else {\n          return self.escape(arg);\n        }\n      }).join(', ') + ')';\n    } else if (smth instanceof Utils.col) {\n      if (Array.isArray(smth.col)) {\n        if (!factory) {\n          throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n        }\n      } else if (smth.col.indexOf('*') === 0) {\n        return '*';\n      }\n      return this.quote(smth.col, factory);\n    } else {\n      result = smth.toString(this, factory);\n    }\n\n    return result;\n  },\n\n  whereQuery: function(where, options) {\n    var query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return 'WHERE '+query;\n    }\n    return '';\n  },\n  whereItemsQuery: function(where, options, binding) {\n    if (\n      (Array.isArray(where) && where.length === 0) ||\n      (_.isPlainObject(where) && _.isEmpty(where)) ||\n      where === null ||\n      where === undefined\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (_.isString(where)) {\n      throw new Error('where: \"raw query\" has been removed, please use where [\"raw query\", [replacements]]');\n    }\n\n    var self = this\n      , items = [];\n\n    binding = binding || 'AND';\n    if (binding.substr(0, 1) !== ' ') binding = ' '+binding+' ';\n\n    if (_.isPlainObject(where)) {\n      _.forOwn(where, function (value, key) {\n        items.push(self.whereItemQuery(key, value, options));\n      });\n    } else {\n      items.push(self.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(function (item) {\n      return item && item.length;\n    }).join(binding) || '';\n  },\n  whereItemQuery: function(key, value, options) {\n    options = options || {};\n\n    var self = this\n      , binding\n      , outerBinding\n      , comparatorMap\n      , aliasMap\n      , comparator = '='\n      , field = options.field || options.model && options.model.rawAttributes && options.model.rawAttributes[key] || options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]\n      , fieldType = options.type || (field && field.type)\n      , tmp;\n\n    if (key && typeof key === 'string' && key.indexOf('.') !== -1 && options.model) {\n      if (options.model.rawAttributes[key.split('.')[0]] && options.model.rawAttributes[key.split('.')[0]].type instanceof DataTypes.JSON) {\n        field = options.model.rawAttributes[key.split('.')[0]];\n        fieldType = field.type;\n        tmp = value;\n        value = {};\n\n        Dottie.set(value, key.split('.').slice(1), tmp);\n        key = field.field || key.split('.')[0];\n      }\n    }\n\n    comparatorMap = {\n      $eq: '=',\n      $ne: '!=',\n      $gte: '>=',\n      $gt: '>',\n      $lte: '<=',\n      $lt: '<',\n      $not: 'IS NOT',\n      $is: 'IS',\n      $like: 'LIKE',\n      $notLike: 'NOT LIKE',\n      $iLike: 'ILIKE',\n      $notILike: 'NOT ILIKE',\n      $between: 'BETWEEN',\n      $notBetween: 'NOT BETWEEN',\n      $overlap: '&&',\n      $contains: '@>',\n      $contained: '<@'\n    };\n\n    // Maintain BC\n    aliasMap = {\n      'ne': '$ne',\n      'in': '$in',\n      'not': '$not',\n      'notIn': '$notIn',\n      'gte': '$gte',\n      'gt': '$gt',\n      'lte': '$lte',\n      'lt': '$lt',\n      'like': '$like',\n      'ilike': '$iLike',\n      '$ilike': '$iLike',\n      'nlike': '$notLike',\n      '$notlike': '$notLike',\n      'notilike': '$notILike',\n      '..': '$between',\n      'between': '$between',\n      '!..': '$notBetween',\n      'notbetween': '$notBetween',\n      'nbetween': '$notBetween',\n      'overlap': '$overlap',\n      '&&': '$overlap',\n      '@>': '$contains',\n      '<@': '$contained'\n    };\n\n    key = aliasMap[key] || key;\n    if (_.isPlainObject(value)) {\n      _.forOwn(value, function (item, key) {\n        if (aliasMap[key]) {\n          value[aliasMap[key]] = item;\n          delete value[key];\n        }\n      });\n    }\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (_.isPlainObject(value) && _.size(value) === 1) {\n        key = Object.keys(value)[0];\n        value = _.values(value)[0];\n      }\n    }\n\n    if (value && value._isSequelizeMethod && !(key !== undefined && value instanceof Utils.fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n\n    // Convert where: [] to $and if possible, else treat as literal/replacements\n    if (key === undefined && Array.isArray(value)) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = '$and';\n      } else {\n        return Utils.format(value, this.dialect);\n      }\n    }\n    // OR/AND/NOT grouping logic\n    if (key === '$or' || key === '$and' || key === '$not') {\n      binding = (key === '$or') ?' OR ' : ' AND ';\n      outerBinding = '';\n      if (key === '$not') outerBinding = 'NOT ';\n\n      if (Array.isArray(value)) {\n        value = value.map(function (item) {\n          var itemQuery = self.whereItemsQuery(item, options, ' AND ');\n          if ((Array.isArray(item) || _.isPlainObject(item)) && _.size(item) > 1) {\n            itemQuery = '('+itemQuery+')';\n          }\n          return itemQuery;\n        }).filter(function (item) {\n          return item && item.length;\n        });\n\n        // $or: [] should return no data.\n        // $not of no restriction should also return no data\n        if ((key === '$or' || key === '$not') && value.length === 0) {\n          return '0 = 1';\n        }\n\n        return value.length ? outerBinding + '('+value.join(binding)+')' : undefined;\n      } else {\n        value = self.whereItemsQuery(value, options, binding);\n\n        if ((key === '$or' || key === '$not') && !value) {\n          return '0 = 1';\n        }\n\n        return value ? outerBinding + '('+value+')' : undefined;\n      }\n    }\n\n    if (value && (value.$or || value.$and)) {\n      binding = value.$or ? ' OR ' : ' AND ';\n      value = value.$or || value.$and;\n\n      if (_.isPlainObject(value)) {\n        value = _.reduce(value, function (result, _value, key) {\n          result.push(_.zipObject([key], [_value]));\n          return result;\n        }, []);\n      }\n\n      value = value.map(function (_value) {\n        return self.whereItemQuery(key, _value, options);\n      }).filter(function (item) {\n        return item && item.length;\n      });\n\n      return value.length ? '('+value.join(binding)+')' : undefined;\n    }\n\n    if (_.isPlainObject(value) && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return (function () {\n        var $items = []\n          , result\n          , traverse;\n\n        traverse = function (prop, item, path) {\n          var $where = {}\n            , $key\n            , $cast\n            , $baseKey\n            , $tmp\n            , castKey;\n\n          if (path[path.length - 1].indexOf('::') > -1) {\n            $tmp = path[path.length - 1].split('::');\n            $cast = $tmp[1];\n            path[path.length - 1] = $tmp[0];\n          }\n\n          var pathKey = self.escape('{' + path.join(', ') + '}');\n          $baseKey = self.quoteIdentifier(key)+'#>>'+pathKey;\n\n          if (options.prefix) {\n            if (options.prefix instanceof Utils.literal) {\n              $baseKey = self.handleSequelizeMethod(options.prefix)+'.'+$baseKey;\n            } else {\n              $baseKey = self.quoteTable(options.prefix)+'.'+$baseKey;\n            }\n          }\n\n          $baseKey = '('+$baseKey+')';\n\n          castKey = function ($item) {\n            var key = $baseKey;\n\n            if (!$cast) {\n              if (typeof $item === 'number') {\n                $cast = 'double precision';\n              } else if ($item instanceof Date) {\n                $cast = 'timestamptz';\n              } else if (typeof $item === 'boolean') {\n                $cast = 'boolean';\n              }\n            }\n\n            if ($cast) {\n              key += '::'+$cast;\n            }\n\n            return key;\n          };\n\n          if (_.isPlainObject(item)) {\n            _.forOwn(item, function ($item, $prop) {\n              if ($prop.indexOf('$') === 0) {\n                $where[$prop] = $item;\n                $key = castKey($item);\n\n                $items.push(self.whereItemQuery(new Utils.literal($key), $where/*, _.pick(options, 'prefix')*/));\n              } else {\n                traverse($prop, $item, path.concat([$prop]));\n              }\n            });\n          } else {\n            $where.$eq = item;\n            $key = castKey(item);\n\n            $items.push(self.whereItemQuery(new Utils.literal($key), $where/*, _.pick(options, 'prefix')*/));\n          }\n        };\n\n        _.forOwn(value, function (item, prop) {\n          if (prop.indexOf('$') === 0) {\n            var $where = {};\n            $where[prop] = item;\n            $items.push(self.whereItemQuery(key, $where, _.assign({}, options, {json: false})));\n            return;\n          }\n\n          traverse(prop, item, [prop]);\n        });\n\n        result = $items.join(' AND ');\n        return $items.length > 1 ? '('+result+')' : result;\n      })();\n    }\n\n    // If multiple keys we combine the different logic conditions\n    if (_.isPlainObject(value) && Object.keys(value).length > 1) {\n      return (function () {\n        var $items = [];\n        _.forOwn(value, function (item, logic) {\n          var $where = {};\n          $where[logic] = item;\n          $items.push(self.whereItemQuery(key, $where, options));\n        });\n\n        return '('+$items.join(' AND ')+')';\n      })();\n    }\n\n    // Do [] to $in/$notIn normalization\n    if (value && (!fieldType || !(fieldType instanceof DataTypes.ARRAY))) {\n      if (Array.isArray(value)) {\n        value = {\n          $in: value\n        };\n      } else if (value && Array.isArray(value.$not)) {\n        value.$notIn = value.$not;\n        delete value.$not;\n      }\n    }\n\n    // normalize $not: non-bool|non-null to $ne\n    if (value && typeof value.$not !== 'undefined' && [null, true, false].indexOf(value.$not) < 0) {\n      value.$ne = value.$not;\n      delete value.$not;\n    }\n\n    // Setup keys and comparators\n    if (Array.isArray(value) && fieldType instanceof DataTypes.ARRAY) {\n      value = this.escape(value, field);\n    } else if (value && (value.$in || value.$notIn)) {\n      comparator = 'IN';\n      if (value.$notIn) comparator = 'NOT IN';\n\n      if ((value.$in || value.$notIn) instanceof Utils.literal) {\n        value = (value.$in || value.$notIn).val;\n      } else if ((value.$in || value.$notIn).length) {\n        value = '('+(value.$in || value.$notIn).map(function (item) {\n          return self.escape(item);\n        }).join(', ')+')';\n      } else {\n        value = '(NULL)';\n      }\n    } else if (value && (value.$any || value.$all)) {\n      comparator = value.$any ? '= ANY' : '= ALL';\n      if (value.$any && value.$any.$values || value.$all && value.$all.$values) {\n        value = '(VALUES '+(value.$any && value.$any.$values || value.$all && value.$all.$values).map(function (value) {\n          return '('+this.escape(value)+')';\n        }.bind(this)).join(', ')+')';\n      } else {\n        value = '('+this.escape(value.$any || value.$all, field)+')';\n      }\n    } else if (value && (value.$between || value.$notBetween)) {\n      comparator = 'BETWEEN';\n      if (value.$notBetween) comparator = 'NOT BETWEEN';\n\n      value = (value.$between || value.$notBetween).map(function (item) {\n        return self.escape(item);\n      }).join(' AND ');\n    } else if (value && value.$raw) {\n      value = value.$raw;\n    } else if (value && value.$col) {\n      value = value.$col.split('.');\n\n      if (value.length > 2) {\n        value = [\n          value.slice(0, -1).join('.'),\n          value[value.length - 1]\n        ];\n      }\n\n      value = value.map(this.quoteIdentifier.bind(this)).join('.');\n    } else {\n      var escapeValue = true;\n      var escapeOptions = {};\n\n      if (_.isPlainObject(value)) {\n        _.forOwn(value, function (item, key) {\n          if (comparatorMap[key]) {\n            comparator = comparatorMap[key];\n            value = item;\n\n            if (_.isPlainObject(value) && value.$any) {\n              comparator += ' ANY';\n              escapeOptions.isList = true;\n              value = value.$any;\n            } else if (_.isPlainObject(value) && value.$all) {\n              comparator += ' ALL';\n              escapeOptions.isList = true;\n              value = value.$all;\n            } else if (value && value.$col) {\n              escapeValue = false;\n              value = this.whereItemQuery(null, value);\n            }\n          }\n        }.bind(this));\n      }\n\n      if (comparator === '=' && value === null) {\n        comparator = 'IS';\n      } else if (comparator === '!=' && value === null) {\n        comparator = 'IS NOT';\n      }\n\n      escapeOptions.acceptStrings = comparator.indexOf('LIKE') !== -1;\n\n      if (escapeValue) {\n        value = this.escape(value, field, escapeOptions);\n\n        //if ANY is used with like, add parentheses to generate correct query\n        if (escapeOptions.acceptStrings && (comparator.indexOf('ANY') > comparator.indexOf('LIKE'))) {\n         value = '(' + value + ')';\n        }\n      }\n    }\n\n    if (key) {\n      var prefix = true;\n      if (key._isSequelizeMethod) {\n        key = this.handleSequelizeMethod(key);\n      } else if (Utils.isColString(key)) {\n        key = key.substr(1, key.length - 2).split('.');\n\n        if (key.length > 2) {\n          key = [\n            key.slice(0, -1).join('.'),\n            key[key.length - 1]\n          ];\n        }\n\n        key = key.map(this.quoteIdentifier.bind(this)).join('.');\n        prefix = false;\n      } else {\n        key = this.quoteIdentifier(key);\n      }\n\n      if (options.prefix && prefix) {\n        if (options.prefix instanceof Utils.literal) {\n          key = [this.handleSequelizeMethod(options.prefix), key].join('.');\n        } else {\n          key = [this.quoteTable(options.prefix), key].join('.');\n        }\n      }\n      return [key, value].join(' '+comparator+' ');\n    }\n    return value;\n  },\n\n  /*\n    Takes something and transforms it into values of a where condition.\n  */\n  getWhereConditions: function(smth, tableName, factory, options, prepend) {\n    var result = null\n      , where = {}\n      , self = this;\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (typeof prepend === 'undefined') {\n      prepend = true;\n    }\n\n    if (smth && smth._isSequelizeMethod === true) { // Checking a property is cheaper than a lot of instanceof calls\n      result = this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    } else if (Utils._.isPlainObject(smth)) {\n      return self.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (typeof smth === 'number') {\n      var primaryKeys = !!factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return self.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (typeof smth === 'string') {\n      return self.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    } else if (Buffer.isBuffer(smth)) {\n      result = this.escape(smth);\n    } else if (Array.isArray(smth)) {\n      if (smth.length === 0) return '1=1';\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        var _smth = { $and: smth };\n        result = self.getWhereConditions(_smth, tableName, factory, options, prepend);\n      } else {\n        result = Utils.format(smth, this.dialect);\n      }\n    } else if (smth === null) {\n      return self.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n\n    return result ? result : '1=1';\n  },\n\n  booleanValue: function(value) {\n    return value;\n  }\n};\n\nmodule.exports = QueryGenerator;\n"], "filenames": ["lib/dialects/abstract/query-generator.js"], "buggy_code_start_loc": [2201], "buggy_code_end_loc": [2202], "fixing_code_start_loc": [2201], "fixing_code_end_loc": [2203], "type": "CWE-89", "message": "sequelize before version 3.35.1 allows attackers to perform a SQL Injection due to the JSON path keys not being properly sanitized in the Postgres dialect.", "other": {"cve": {"id": "CVE-2019-10749", "sourceIdentifier": "report@snyk.io", "published": "2019-10-29T19:15:16.750", "lastModified": "2019-10-31T00:13:47.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sequelize before version 3.35.1 allows attackers to perform a SQL Injection due to the JSON path keys not being properly sanitized in the Postgres dialect."}, {"lang": "es", "value": "sequelize anterior a la versi\u00f3n 3.35.1, permite a atacantes realizar una inyecci\u00f3n SQL debido a que las claves de ruta JSON no son saneadas apropiadamente en el dialecto de Postgres."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sequelizejs:sequelize:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.35.1", "matchCriteriaId": "B334C638-40B7-4D06-83B9-ECDBCB83AEC5"}]}]}], "references": [{"url": "https://github.com/sequelize/sequelize/commit/ee4017379db0059566ecb5424274ad4e2d66bc68", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://snyk.io/vuln/SNYK-JS-SEQUELIZE-450222", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sequelize/sequelize/commit/ee4017379db0059566ecb5424274ad4e2d66bc68"}}