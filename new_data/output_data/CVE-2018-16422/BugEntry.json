{"buggy_code": ["/*\n * card-cac.c: Support for CAC from NIST SP800-73\n * card-default.c: Support for cards with no driver\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n * Copyright (C) 2005,2006,2007,2008,2009,2010 Douglas E. Engert <deengert@anl.gov>\n * Copyright (C) 2006, Identity Alliance, Thomas Harning <thomas.harning@identityalliance.com>\n * Copyright (C) 2007, EMC, Russell Larner <rlarner@rsa.com>\n * Copyright (C) 2016 - 2018, Red Hat, Inc.\n *\n * CAC driver author: Robert Relyea <rrelyea@redhat.com>\n * Further work: Jakub Jelen <jjelen@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#ifdef ENABLE_OPENSSL\n\t/* openssl only needed for card administration */\n#include <openssl/evp.h>\n#include <openssl/bio.h>\n#include <openssl/pem.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#endif /* ENABLE_OPENSSL */\n\n#include \"internal.h\"\n#include \"simpletlv.h\"\n#include \"cardctl.h\"\n#ifdef ENABLE_ZLIB\n#include \"compression.h\"\n#endif\n#include \"iso7816.h\"\n\n#define CAC_MAX_SIZE 4096\t\t/* arbitrary, just needs to be 'large enough' */\n/*\n *  CAC hardware and APDU constants\n */\n#define CAC_MAX_CHUNK_SIZE 240\n#define CAC_INS_SIGN_DECRYPT          0x42  /* A crypto operation */\n#define CAC_INS_READ_FILE             0x52  /* read a TL or V file */\n#define CAC_INS_GET_ACR               0x4c\n#define CAC_INS_GET_PROPERTIES        0x56\n#define CAC_P1_STEP    0x80\n#define CAC_P1_FINAL   0x00\n#define CAC_FILE_TAG    1\n#define CAC_FILE_VALUE  2\n/* TAGS in a TL file */\n#define CAC_TAG_CERTIFICATE           0x70\n#define CAC_TAG_CERTINFO              0x71\n#define CAC_TAG_MSCUID                0x72\n#define CAC_TAG_CUID                  0xF0\n#define CAC_TAG_CC_VERSION_NUMBER     0xF1\n#define CAC_TAG_GRAMMAR_VERION_NUMBER 0xF2\n#define CAC_TAG_CARDURL               0xF3\n#define CAC_TAG_PKCS15                0xF4\n#define CAC_TAG_ACCESS_CONTROL        0xF6\n#define CAC_TAG_DATA_MODEL            0xF5\n#define CAC_TAG_CARD_APDU             0xF7\n#define CAC_TAG_REDIRECTION           0xFA\n#define CAC_TAG_CAPABILITY_TUPLES     0xFB\n#define CAC_TAG_STATUS_TUPLES         0xFC\n#define CAC_TAG_NEXT_CCC              0xFD\n#define CAC_TAG_ERROR_CODES           0xFE\n#define CAC_TAG_APPLET_FAMILY         0x01\n#define CAC_TAG_NUMBER_APPLETS        0x94\n#define CAC_TAG_APPLET_ENTRY          0x93\n#define CAC_TAG_APPLET_AID            0x92\n#define CAC_TAG_APPLET_INFORMATION    0x01\n#define CAC_TAG_NUMBER_OF_OBJECTS     0x40\n#define CAC_TAG_TV_BUFFER             0x50\n#define CAC_TAG_PKI_OBJECT            0x51\n#define CAC_TAG_OBJECT_ID             0x41\n#define CAC_TAG_BUFFER_PROPERTIES     0x42\n#define CAC_TAG_PKI_PROPERTIES        0x43\n\n#define CAC_APP_TYPE_GENERAL          0x01\n#define CAC_APP_TYPE_SKI              0x02\n#define CAC_APP_TYPE_PKI              0x04\n\n#define CAC_ACR_ACR                   0x00\n#define CAC_ACR_APPLET_OBJECT         0x10\n#define CAC_ACR_AMP                   0x20\n#define CAC_ACR_SERVICE               0x21\n\n/* hardware data structures (returned in the CCC) */\n/* part of the card_url */\ntypedef struct cac_access_profile {\n\tu8 GCACR_listID;\n\tu8 GCACR_readTagListACRID;\n\tu8 GCACR_updatevalueACRID;\n\tu8 GCACR_readvalueACRID;\n\tu8 GCACR_createACRID;\n\tu8 GCACR_deleteACRID;\n\tu8 CryptoACR_listID;\n\tu8 CryptoACR_getChallengeACRID;\n\tu8 CryptoACR_internalAuthenicateACRID;\n\tu8 CryptoACR_pkiComputeACRID;\n\tu8 CryptoACR_readTagListACRID;\n\tu8 CryptoACR_updatevalueACRID;\n\tu8 CryptoACR_readvalueACRID;\n\tu8 CryptoACR_createACRID;\n\tu8 CryptoACR_deleteACRID;\n} cac_access_profile_t;\n\n/* part of the card url */\ntypedef struct cac_access_key_info {\n\tu8\tkeyFileID[2];\n\tu8\tkeynumber;\n} cac_access_key_info_t;\n\ntypedef struct cac_card_url {\n\tu8 rid[5];\n\tu8 cardApplicationType;\n\tu8 objectID[2];\n\tu8 applicationID[2];\n\tcac_access_profile_t accessProfile;\n\tu8 pinID;\t\t\t     /* not used for VM cards */\n\tcac_access_key_info_t accessKeyInfo; /* not used for VM cards */\n\tu8 keyCryptoAlgorithm;               /* not used for VM cards */\n} cac_card_url_t;\n\ntypedef struct cac_cuid {\n\tu8 gsc_rid[5];\n\tu8 manufacturer_id;\n\tu8 card_type;\n\tu8 card_id;\n} cac_cuid_t;\n\n/* data structures to store meta data about CAC objects */\ntypedef struct cac_object {\n\tconst char *name;\n\tint fd;\n\tsc_path_t path;\n} cac_object_t;\n\n#define CAC_MAX_OBJECTS 16\n\ntypedef struct {\n\t/* OID has two bytes */\n\tunsigned char oid[2];\n\t/* Format is NOT SimpleTLV? */\n\tunsigned char simpletlv;\n\t/* Is certificate object and private key is initialized */\n\tunsigned char privatekey;\n} cac_properties_object_t;\n\ntypedef struct {\n\tunsigned int num_objects;\n\tcac_properties_object_t objects[CAC_MAX_OBJECTS];\n} cac_properties_t;\n\n/*\n * Flags for Current Selected Object Type\n *   CAC files are TLV files, with TL and V separated. For generic\n *   containers we reintegrate the TL anv V portions into a single\n *   file to read. Certs are also TLV files, but pkcs15 wants the\n *   actual certificate. At select time we know the patch which tells\n *   us what time of files we want to read. We remember that type\n *   so that read_binary can do the appropriate processing.\n */\n#define CAC_OBJECT_TYPE_CERT\t\t1\n#define CAC_OBJECT_TYPE_TLV_FILE\t4\n#define CAC_OBJECT_TYPE_GENERIC\t\t5\n\n/*\n * CAC private data per card state\n */\ntypedef struct cac_private_data {\n\tint object_type;\t\t/* select set this so we know how to read the file */\n\tint cert_next;\t\t\t/* index number for the next certificate found in the list */\n\tu8 *cache_buf;\t\t\t/* cached version of the currently selected file */\n\tsize_t cache_buf_len;\t\t/* length of the cached selected file */\n\tint cached;\t\t\t/* is the cached selected file valid */\n\tcac_cuid_t cuid;                /* card unique ID from the CCC */\n\tu8 *cac_id;                     /* card serial number */\n\tsize_t cac_id_len;              /* card serial number len */\n\tlist_t pki_list;                /* list of pki containers */\n\tcac_object_t *pki_current;      /* current pki object _ctl function */\n\tlist_t general_list;            /* list of general containers */\n\tcac_object_t *general_current;  /* current object for _ctl function */\n\tsc_path_t *aca_path;\t\t/* ACA path to be selected before pin verification */\n} cac_private_data_t;\n\n#define CAC_DATA(card) ((cac_private_data_t*)card->drv_data)\n\nint cac_list_compare_path(const void *a, const void *b)\n{\n\tif (a == NULL || b == NULL)\n\t\treturn 1;\n\treturn memcmp( &((cac_object_t *) a)->path,\n\t\t&((cac_object_t *) b)->path, sizeof(sc_path_t));\n}\n\n/* For SimCList autocopy, we need to know the size of the data elements */\nsize_t cac_list_meter(const void *el) {\n\treturn sizeof(cac_object_t);\n}\n\nstatic cac_private_data_t *cac_new_private_data(void)\n{\n\tcac_private_data_t *priv;\n\tpriv = calloc(1, sizeof(cac_private_data_t));\n\tif (!priv)\n\t\treturn NULL;\n\tlist_init(&priv->pki_list);\n\tlist_attributes_comparator(&priv->pki_list, cac_list_compare_path);\n\tlist_attributes_copy(&priv->pki_list, cac_list_meter, 1);\n\tlist_init(&priv->general_list);\n\tlist_attributes_comparator(&priv->general_list, cac_list_compare_path);\n\tlist_attributes_copy(&priv->general_list, cac_list_meter, 1);\n\t/* set other fields as appropriate */\n\n\treturn priv;\n}\n\nstatic void cac_free_private_data(cac_private_data_t *priv)\n{\n\tfree(priv->cac_id);\n\tfree(priv->cache_buf);\n\tfree(priv->aca_path);\n\tlist_destroy(&priv->pki_list);\n\tlist_destroy(&priv->general_list);\n\tfree(priv);\n\treturn;\n}\n\nstatic int cac_add_object_to_list(list_t *list, const cac_object_t *object)\n{\n\tif (list_append(list, object) < 0)\n\t\treturn SC_ERROR_UNKNOWN;\n\treturn SC_SUCCESS;\n}\n\n/*\n * Set up the normal CAC paths\n */\n#define CAC_TO_AID(x) x, sizeof(x)-1\n\n#define CAC_2_RID \"\\xA0\\x00\\x00\\x01\\x16\"\n#define CAC_1_RID \"\\xA0\\x00\\x00\\x00\\x79\"\n\nstatic const sc_path_t cac_ACA_Path = {\n\t\"\", 0,\n\t0,0,SC_PATH_TYPE_DF_NAME,\n\t{ CAC_TO_AID(CAC_1_RID \"\\x10\\x00\") }\n};\n\nstatic const sc_path_t cac_CCC_Path = {\n\t\"\", 0,\n\t0,0,SC_PATH_TYPE_DF_NAME,\n\t{ CAC_TO_AID(CAC_2_RID \"\\xDB\\x00\") }\n};\n\n#define MAX_CAC_SLOTS 16\t\t/* Maximum number of slots is 16 now */\n/* default certificate labels for the CAC card */\nstatic const char *cac_labels[MAX_CAC_SLOTS] = {\n\t\"CAC ID Certificate\",\n\t\"CAC Email Signature Certificate\",\n\t\"CAC Email Encryption Certificate\",\n\t\"CAC Cert 4\",\n\t\"CAC Cert 5\",\n\t\"CAC Cert 6\",\n\t\"CAC Cert 7\",\n\t\"CAC Cert 8\",\n\t\"CAC Cert 9\",\n\t\"CAC Cert 10\",\n\t\"CAC Cert 11\",\n\t\"CAC Cert 12\",\n\t\"CAC Cert 13\",\n\t\"CAC Cert 14\",\n\t\"CAC Cert 15\",\n\t\"CAC Cert 16\"\n};\n\n/* template for a CAC pki object */\nstatic const cac_object_t cac_cac_pki_obj = {\n\t\"CAC Certificate\", 0x0, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t{ CAC_TO_AID(CAC_1_RID \"\\x01\\x00\") } }\n};\n\n/* template for emulated cuid */\nstatic const cac_cuid_t cac_cac_cuid = {\n\t{ 0xa0, 0x00, 0x00, 0x00, 0x79 },\n\t2, 2, 0\n};\n\n/*\n *  CAC general objects defined in 4.3.1.2 of CAC Applet Developer Guide Version 1.0.\n *   doubles as a source for CAC-2 labels.\n */\nstatic const cac_object_t cac_objects[] = {\n\t{ \"Person Instance\", 0x200, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\x00\") }}},\n\t{ \"Personnel\", 0x201, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\x01\") }}},\n\t{ \"Benefits\", 0x202, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\x02\") }}},\n\t{ \"Other Benefits\", 0x203, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\x03\") }}},\n\t{ \"PKI Credential\", 0x2FD, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\xFD\") }}},\n\t{ \"PKI Certificate\", 0x2FE, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\xFE\") }}},\n};\n\nstatic const int cac_object_count = sizeof(cac_objects)/sizeof(cac_objects[0]);\n\n/*\n * use the object id to find our object info on the object in our CAC-1 list\n */\nstatic const cac_object_t *cac_find_obj_by_id(unsigned short object_id)\n{\n\tint i;\n\n\tfor (i = 0; i < cac_object_count; i++) {\n\t\tif (cac_objects[i].fd == object_id) {\n\t\t\treturn &cac_objects[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n * Lookup the path in the pki list to see if it is a cert path\n */\nstatic int cac_is_cert(cac_private_data_t * priv, const sc_path_t *in_path)\n{\n\tcac_object_t test_obj;\n\ttest_obj.path = *in_path;\n\ttest_obj.path.index = 0;\n\ttest_obj.path.count = 0;\n\n\treturn (list_contains(&priv->pki_list, &test_obj) != 0);\n}\n\n/*\n * Send a command and receive data.\n *\n * A caller may provide a buffer, and length to read. If not provided,\n * an internal 4096 byte buffer is used, and a copy is returned to the\n * caller. that need to be freed by the caller.\n *\n * modelled after a similar function in card-piv.c\n */\n\nstatic int cac_apdu_io(sc_card_t *card, int ins, int p1, int p2,\n\tconst u8 * sendbuf, size_t sendbuflen, u8 ** recvbuf,\n\tsize_t * recvbuflen)\n{\n\tint r;\n\tsc_apdu_t apdu;\n\tu8 rbufinitbuf[CAC_MAX_SIZE];\n\tu8 *rbuf;\n\tsize_t rbuflen;\n\tunsigned int apdu_case = SC_APDU_CASE_1;\n\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"%02x %02x %02x %\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t ins, p1, p2, sendbuflen, card->max_send_size,\n\t\t card->max_recv_size);\n\n\trbuf = rbufinitbuf;\n\trbuflen = sizeof(rbufinitbuf);\n\n\t/* if caller provided a buffer and length */\n\tif (recvbuf && *recvbuf && recvbuflen && *recvbuflen) {\n\t\trbuf = *recvbuf;\n\t\trbuflen = *recvbuflen;\n\t}\n\n\tif (recvbuf) {\n\t\tif (sendbuf)\n\t\t\tapdu_case = SC_APDU_CASE_4_SHORT;\n\t\telse\n\t\t\tapdu_case = SC_APDU_CASE_2_SHORT;\n\t} else if (sendbuf)\n\t\tapdu_case = SC_APDU_CASE_3_SHORT;\n\n\n\tsc_format_apdu(card, &apdu, apdu_case, ins, p1, p2);\n\n\tapdu.lc = sendbuflen;\n\tapdu.datalen = sendbuflen;\n\tapdu.data = sendbuf;\n\n\tif (recvbuf) {\n\t\tapdu.resp = rbuf;\n\t\tapdu.le = (rbuflen > 255) ? 255 : rbuflen;\n\t\tapdu.resplen = rbuflen;\n\t} else {\n\t\t apdu.resp =  rbuf;\n\t\t apdu.le = 0;\n\t\t apdu.resplen = 0;\n\t}\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"calling sc_transmit_apdu flags=%lx le=%\"SC_FORMAT_LEN_SIZE_T\"u, resplen=%\"SC_FORMAT_LEN_SIZE_T\"u, resp=%p\",\n\t\t apdu.flags, apdu.le, apdu.resplen, apdu.resp);\n\n\t/* with new adpu.c and chaining, this actually reads the whole object */\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"result r=%d apdu.resplen=%\"SC_FORMAT_LEN_SIZE_T\"u sw1=%02x sw2=%02x\",\n\t\t r, apdu.resplen, apdu.sw1, apdu.sw2);\n\tif (r < 0) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\"Transmit failed\");\n\t\tgoto err;\n\t}\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\n\tif (r < 0) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Card returned error \");\n\t\tgoto err;\n\t}\n\n\tif (recvbuflen) {\n\t\tif (recvbuf && *recvbuf == NULL) {\n\t\t\t*recvbuf =  malloc(apdu.resplen);\n\t\t\tif (*recvbuf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tmemcpy(*recvbuf, rbuf, apdu.resplen);\n\t\t}\n\t\t*recvbuflen =  apdu.resplen;\n\t\tr = *recvbuflen;\n\t}\n\nerr:\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\n/*\n * Get ACR of currently ACA applet identified by the  acr_type\n * 5.3.3.5 Get ACR APDU\n */\nstatic int\ncac_get_acr(sc_card_t *card, int acr_type, u8 **out_buf, size_t *out_len)\n{\n\tu8 *out = NULL;\n\t/* XXX assuming it will not be longer than 255 B */\n\tsize_t len = 256;\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* for simplicity we support only ACR without arguments now */\n\tif (acr_type != 0x00 && acr_type != 0x10\n\t    && acr_type != 0x20 && acr_type != 0x21) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tr = cac_apdu_io(card, CAC_INS_GET_ACR, acr_type, 0, NULL, 0, &out, &len);\n\tif (len == 0) {\n\t\tr = SC_ERROR_FILE_NOT_FOUND;\n\t}\n\tif (r < 0)\n\t\tgoto fail;\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t    \"got %\"SC_FORMAT_LEN_SIZE_T\"u bytes out=%p\", len, out);\n\n\t*out_len = len;\n\t*out_buf = out;\n\treturn SC_SUCCESS;\n\nfail:\n\tif (out)\n\t\tfree(out);\n\t*out_buf = NULL;\n\t*out_len = 0;\n\treturn r;\n}\n\n/*\n * Read a CAC TLV file. Parameters specify if the TLV file is TL (Tag/Length) file or a V (value) file\n */\n#define HIGH_BYTE_OF_SHORT(x) (((x)>> 8) & 0xff)\n#define LOW_BYTE_OF_SHORT(x) ((x) & 0xff)\nstatic int cac_read_file(sc_card_t *card, int file_type, u8 **out_buf, size_t *out_len)\n{\n\tu8 params[2];\n\tu8 count[2];\n\tu8 *out = NULL;\n\tu8 *out_ptr;\n\tsize_t offset = 0;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\n\tparams[0] = file_type;\n\tparams[1] = 2;\n\n\t/* get the size */\n\tlen = sizeof(count);\n\tout_ptr = count;\n\tr = cac_apdu_io(card, CAC_INS_READ_FILE, 0, 0, &params[0], sizeof(params), &out_ptr, &len);\n\tif (len == 0) {\n\t\tr = SC_ERROR_FILE_NOT_FOUND;\n\t}\n\tif (r < 0)\n\t\tgoto fail;\n\n\tleft = size = lebytes2ushort(count);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"got %\"SC_FORMAT_LEN_SIZE_T\"u bytes out_ptr=%p count&=%p count[0]=0x%02x count[1]=0x%02x, len=0x%04\"SC_FORMAT_LEN_SIZE_T\"x (%\"SC_FORMAT_LEN_SIZE_T\"u)\",\n\t\t len, out_ptr, &count, count[0], count[1], size, size);\n\tout = out_ptr = malloc(size);\n\tif (out == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto fail;\n\t}\n\tfor (offset += 2; left > 0; offset += len, left -= len, out_ptr += len) {\n\t\tlen = MIN(left, CAC_MAX_CHUNK_SIZE);\n\t\tparams[1] = len;\n\t\tr = cac_apdu_io(card, CAC_INS_READ_FILE, HIGH_BYTE_OF_SHORT(offset), LOW_BYTE_OF_SHORT(offset),\n\t\t\t\t\t\t&params[0], sizeof(params), &out_ptr, &len);\n\t\t/* if there is no data, assume there is no file */\n\t\tif (len == 0) {\n\t\t\tr = SC_ERROR_FILE_NOT_FOUND;\n\t\t}\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*out_len = size;\n\t*out_buf = out;\n\treturn SC_SUCCESS;\nfail:\n\tif (out)\n\t\tfree(out);\n\t*out_len = 0;\n\treturn r;\n}\n\n\n/*\n * Callers of this may be expecting a certificate,\n * select file will have saved the object type for us\n * as well as set that we want the cert from the object.\n */\nstatic int cac_read_binary(sc_card_t *card, unsigned int idx,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tint r = 0;\n\tu8 *tl = NULL, *val = NULL;\n\tu8 *tl_ptr, *val_ptr, *tlv_ptr, *tl_start;\n\tu8 *cert_ptr;\n\tsize_t tl_len, val_len, tlv_len;\n\tsize_t len, tl_head_len, cert_len;\n\tu8 cert_type, tag;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* if we didn't return it all last time, return the remainder */\n\tif (priv->cached) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t idx, count);\n\t\tif (idx > priv->cache_buf_len) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_END_REACHED);\n\t\t}\n\t\tlen = MIN(count, priv->cache_buf_len-idx);\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, len);\n\t}\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t idx, count);\n\tif (priv->cache_buf) {\n\t\tfree(priv->cache_buf);\n\t\tpriv->cache_buf = NULL;\n\t\tpriv->cache_buf_len = 0;\n\t}\n\n\n\tif (priv->object_type <= 0)\n\t\t SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INTERNAL);\n\n\tr = cac_read_file(card, CAC_FILE_TAG, &tl, &tl_len);\n\tif (r < 0)  {\n\t\tgoto done;\n\t}\n\n\tr = cac_read_file(card, CAC_FILE_VALUE, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tswitch (priv->object_type) {\n\tcase CAC_OBJECT_TYPE_TLV_FILE:\n\t\ttlv_len = tl_len + val_len;\n\t\tpriv->cache_buf = malloc(tlv_len);\n\t\tif (priv->cache_buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->cache_buf_len = tlv_len;\n\n\t\tfor (tl_ptr = tl, val_ptr=val, tlv_ptr = priv->cache_buf;\n\t\t\t\ttl_len >= 2 && tlv_len > 0;\n\t\t\t\tval_len -= len, tlv_len -= len, val_ptr += len, tlv_ptr += len) {\n\t\t\t/* get the tag and the length */\n\t\t\ttl_start = tl_ptr;\n\t\t\tif (sc_simpletlv_read_tag(&tl_ptr, tl_len, &tag, &len) != SC_SUCCESS)\n\t\t\t\tbreak;\n\t\t\ttl_head_len = (tl_ptr - tl_start);\n\t\t\tsc_simpletlv_put_tag(tag, len, tlv_ptr, tlv_len, &tlv_ptr);\n\t\t\ttlv_len -= tl_head_len;\n\t\t\ttl_len -= tl_head_len;\n\n\t\t\t/* don't crash on bad data */\n\t\t\tif (val_len < len) {\n\t\t\t\tlen = val_len;\n\t\t\t}\n\t\t\t/* if we run out of return space, truncate */\n\t\t\tif (tlv_len < len) {\n\t\t\t\tlen = tlv_len;\n\t\t\t}\n\t\t\tmemcpy(tlv_ptr, val_ptr, len);\n\t\t}\n\t\tbreak;\n\n\tcase CAC_OBJECT_TYPE_CERT:\n\t\t/* read file */\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \" obj= cert_file, val_len=%\"SC_FORMAT_LEN_SIZE_T\"u (0x%04\"SC_FORMAT_LEN_SIZE_T\"x)\",\n\t\t\t val_len, val_len);\n\t\tcert_len = 0;\n\t\tcert_ptr = NULL;\n\t\tcert_type = 0;\n\t\tfor (tl_ptr = tl, val_ptr = val; tl_len >= 2;\n\t\t    val_len -= len, val_ptr += len, tl_len -= tl_head_len) {\n\t\t\ttl_start = tl_ptr;\n\t\t\tif (sc_simpletlv_read_tag(&tl_ptr, tl_len, &tag, &len) != SC_SUCCESS)\n\t\t\t\tbreak;\n\t\t\ttl_head_len = tl_ptr - tl_start;\n\n\t\t\t/* incomplete value */\n\t\t\tif (val_len < len)\n\t\t\t\tbreak;\n\n\t\t\tif (tag == CAC_TAG_CERTIFICATE) {\n\t\t\t\tcert_len = len;\n\t\t\t\tcert_ptr = val_ptr;\n\t\t\t}\n\t\t\tif (tag == CAC_TAG_CERTINFO) {\n\t\t\t\tif ((len >= 1) && (val_len >=1)) {\n\t\t\t\t\tcert_type = *val_ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tag == CAC_TAG_MSCUID) {\n\t\t\t\tsc_log_hex(card->ctx, \"MSCUID\", val_ptr, len);\n\t\t\t}\n\t\t\tif ((val_len < len) || (tl_len < tl_head_len)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* if the info byte is 1, then the cert is compressed, decompress it */\n\t\tif ((cert_type & 0x3) == 1) {\n#ifdef ENABLE_ZLIB\n\t\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,\n\t\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);\n#else\n\t\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");\n\t\t\tr = SC_ERROR_NOT_SUPPORTED;\n#endif\n\t\t\tif (r)\n\t\t\t\tgoto done;\n\t\t} else if (cert_len > 0) {\n\t\t\tpriv->cache_buf = malloc(cert_len);\n\t\t\tif (priv->cache_buf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tpriv->cache_buf_len = cert_len;\n\t\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);\n\t\t} else {\n\t\t\tsc_log(card->ctx, \"Can't read zero-length certificate\");\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase CAC_OBJECT_TYPE_GENERIC:\n\t\t/* TODO\n\t\t * We have some two buffers in unknown encoding that we\n\t\t * need to present in PKCS#15 layer.\n\t\t */\n\tdefault:\n\t\t/* Unknown object type */\n\t\tsc_log(card->ctx, \"Unknown object type: %x\", priv->object_type);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto done;\n\t}\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tpriv->cached = 1;\n\tlen = MIN(count, priv->cache_buf_len-idx);\n\tmemcpy(buf, &priv->cache_buf[idx], len);\n\tr = len;\ndone:\n\tif (tl)\n\t\tfree(tl);\n\tif (val)\n\t\tfree(val);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\n/* CAC driver is read only */\nstatic int cac_write_binary(sc_card_t *card, unsigned int idx,\n\t\tconst u8 *buf, size_t count, unsigned long flags)\n{\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_NOT_SUPPORTED);\n}\n\n/* initialize getting a list and return the number of elements in the list */\nstatic int cac_get_init_and_get_count(list_t *list, cac_object_t **entry, int *countp)\n{\n\t*countp = list_size(list);\n\tlist_iterator_start(list);\n\t*entry = list_iterator_next(list);\n\treturn SC_SUCCESS;\n}\n\n/* finalize the list iterator */\nstatic int cac_final_iterator(list_t *list)\n{\n\tlist_iterator_stop(list);\n\treturn SC_SUCCESS;\n}\n\n/* fill in the obj_info for the current object on the list and advance to the next object */\nstatic int cac_fill_object_info(list_t *list, cac_object_t **entry, sc_pkcs15_data_info_t *obj_info)\n{\n\tmemset(obj_info, 0, sizeof(sc_pkcs15_data_info_t));\n\tif (*entry == NULL) {\n\t\treturn SC_ERROR_FILE_END_REACHED;\n\t}\n\n\tobj_info->path = (*entry)->path;\n\tobj_info->path.count = CAC_MAX_SIZE-1; /* read something from the object */\n\tobj_info->id.value[0] = ((*entry)->fd >> 8) & 0xff;\n\tobj_info->id.value[1] = (*entry)->fd & 0xff;\n\tobj_info->id.len = 2;\n\tstrncpy(obj_info->app_label, (*entry)->name, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t*entry = list_iterator_next(list);\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}\n\nstatic int cac_get_ACA_path(sc_card_t *card, sc_path_t *path)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n\tif (priv->aca_path) {\n\t\t*path = *priv->aca_path;\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n}\n\nstatic int cac_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_log(card->ctx, \"cmd=%ld ptr=%p\", cmd, ptr);\n\n\tif (priv == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t}\n\tswitch(cmd) {\n\t\tcase SC_CARDCTL_CAC_GET_ACA_PATH:\n\t\t\treturn cac_get_ACA_path(card, (sc_path_t *) ptr);\n\t\tcase SC_CARDCTL_GET_SERIALNR:\n\t\t\treturn cac_get_serial_nr_from_CUID(card, (sc_serial_number_t *) ptr);\n\t\tcase SC_CARDCTL_CAC_INIT_GET_GENERIC_OBJECTS:\n\t\t\treturn cac_get_init_and_get_count(&priv->general_list, &priv->general_current, (int *)ptr);\n\t\tcase SC_CARDCTL_CAC_INIT_GET_CERT_OBJECTS:\n\t\t\treturn cac_get_init_and_get_count(&priv->pki_list, &priv->pki_current, (int *)ptr);\n\t\tcase SC_CARDCTL_CAC_GET_NEXT_GENERIC_OBJECT:\n\t\t\treturn cac_fill_object_info(&priv->general_list, &priv->general_current, (sc_pkcs15_data_info_t *)ptr);\n\t\tcase SC_CARDCTL_CAC_GET_NEXT_CERT_OBJECT:\n\t\t\treturn cac_fill_object_info(&priv->pki_list, &priv->pki_current, (sc_pkcs15_data_info_t *)ptr);\n\t\tcase SC_CARDCTL_CAC_FINAL_GET_GENERIC_OBJECTS:\n\t\t\treturn cac_final_iterator(&priv->general_list);\n\t\tcase SC_CARDCTL_CAC_FINAL_GET_CERT_OBJECTS:\n\t\t\treturn cac_final_iterator(&priv->pki_list);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n}\n\nstatic int cac_get_challenge(sc_card_t *card, u8 *rnd, size_t len)\n{\n\t/* CAC requires 8 byte response */\n\tu8 rbuf[8];\n\tu8 *rbufp = &rbuf[0];\n\tsize_t out_len = sizeof rbuf;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = cac_apdu_io(card, 0x84, 0x00, 0x00, NULL, 0, &rbufp, &out_len);\n\tLOG_TEST_RET(card->ctx, r, \"Could not get challenge\");\n\n\tif (len < out_len) {\n\t\tout_len = len;\n\t}\n\tmemcpy(rnd, rbuf, out_len);\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, (int) out_len);\n}\n\nstatic int cac_set_security_env(sc_card_t *card, const sc_security_env_t *env, int se_num)\n{\n\tint r = SC_SUCCESS;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"flags=%08lx op=%d alg=%d algf=%08x algr=%08x kr0=%02x, krfl=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t env->flags, env->operation, env->algorithm,\n\t\t env->algorithm_flags, env->algorithm_ref, env->key_ref[0],\n\t\t env->key_ref_len);\n\n\tif (env->algorithm != SC_ALGORITHM_RSA) {\n\t\t r = SC_ERROR_NO_CARD_SUPPORT;\n\t}\n\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\n\nstatic int cac_restore_security_env(sc_card_t *card, int se_num)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n}\n\n\nstatic int cac_rsa_op(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tu8 *outp, *rbuf;\n\tsize_t rbuflen, outplen;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"datalen=%\"SC_FORMAT_LEN_SIZE_T\"u outlen=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t datalen, outlen);\n\n\toutp = out;\n\toutplen = outlen;\n\n\t/* Not strictly necessary. This code requires the caller to have selected the correct PKI container\n\t * and authenticated to that container with the verifyPin command... All of this under the reader lock.\n\t * The PKCS #15 higher level driver code does all this correctly (it's the same for all cards, just\n\t * different sets of APDU's that need to be called), so this call is really a little bit of paranoia */\n\tr = sc_lock(card);\n\tif (r != SC_SUCCESS)\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n\n\n\trbuf = NULL;\n\trbuflen = 0;\n\tfor (; datalen > CAC_MAX_CHUNK_SIZE; data += CAC_MAX_CHUNK_SIZE, datalen -= CAC_MAX_CHUNK_SIZE) {\n\t\tr = cac_apdu_io(card, CAC_INS_SIGN_DECRYPT, CAC_P1_STEP,  0,\n\t\t\tdata, CAC_MAX_CHUNK_SIZE, &rbuf, &rbuflen);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (rbuflen != 0) {\n\t\t\tint n = MIN(rbuflen, outplen);\n\t\t\tmemcpy(outp,rbuf, n);\n\t\t\toutp += n;\n\t\t\toutplen -= n;\n\t\t}\n\t\tfree(rbuf);\n\t\trbuf = NULL;\n\t\trbuflen = 0;\n\t}\n\tif (r < 0) {\n\t\tgoto err;\n\t}\n\trbuf = NULL;\n\trbuflen = 0;\n\tr = cac_apdu_io(card, CAC_INS_SIGN_DECRYPT, CAC_P1_FINAL, 0, data, datalen, &rbuf, &rbuflen);\n\tif (r < 0) {\n\t\tgoto err;\n\t}\n\tif (rbuflen != 0) {\n\t\tint n = MIN(rbuflen, outplen);\n\t\tmemcpy(outp,rbuf, n);\n\t\t/*outp += n;     unused */\n\t\toutplen -= n;\n\t}\n\tfree(rbuf);\n\trbuf = NULL;\n\tr = outlen-outplen;\n\nerr:\n\tsc_unlock(card);\n\tif (r < 0) {\n\t\tsc_mem_clear(out, outlen);\n\t}\n\tif (rbuf) {\n\t\tfree(rbuf);\n\t}\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\nstatic int cac_compute_signature(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, cac_rsa_op(card, data, datalen, out, outlen));\n}\n\nstatic int cac_decipher(sc_card_t *card,\n\t\t\t\t\t const u8 * data, size_t datalen,\n\t\t\t\t\t u8 * out, size_t outlen)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, cac_rsa_op(card, data, datalen, out, outlen));\n}\n\nstatic int cac_parse_properties_object(sc_card_t *card, u8 type,\n    u8 *data, size_t data_len, cac_properties_object_t *object)\n{\n\tsize_t len;\n\tu8 *val, *val_end, tag;\n\tint parsed = 0;\n\n\tif (data_len < 11)\n\t\treturn -1;\n\n\t/* Initilize: non-PKI applet */\n\tobject->privatekey = 0;\n\n\tval = data;\n\tval_end = data + data_len;\n\tfor (; val < val_end; val += len) {\n\t\t/* get the tag and the length */\n\t\tif (sc_simpletlv_read_tag(&val, val_end - val, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_OBJECT_ID:\n\t\t\tif (len != 2) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Object ID: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Object ID = 0x%02x 0x%02x\", val[0], val[1]);\n\t\t\tmemcpy(&object->oid, val, 2);\n\t\t\tparsed++;\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_BUFFER_PROPERTIES:\n\t\t\tif (len != 5) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Buffer Properties: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* First byte is \"Type of Tag Supported\" */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Buffer Properties: Type of Tag Supported = 0x%02x\",\n\t\t\t    val[0]);\n\t\t\tobject->simpletlv = val[0];\n\t\t\tparsed++;\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_PKI_PROPERTIES:\n\t\t\t/* 4th byte is \"Private Key Initialized\" */\n\t\t\tif (len != 4) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKI Properties: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (type != CAC_TAG_PKI_OBJECT) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKI Properties outside of PKI Object\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: PKI Properties: Private Key Initialized = 0x%02x\",\n\t\t\t    val[2]);\n\t\t\tobject->privatekey = val[2];\n\t\t\tparsed++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Unknown (0x%02x)\",tag );\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (parsed < 2)\n\t\treturn SC_ERROR_INVALID_DATA;\n\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_get_properties(sc_card_t *card, cac_properties_t *prop)\n{\n\tu8 *rbuf = NULL;\n\tsize_t rbuflen = 0, len;\n\tu8 *val, *val_end, tag;\n\tsize_t i = 0;\n\tint r;\n\tprop->num_objects = 0;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = cac_apdu_io(card, CAC_INS_GET_PROPERTIES, 0x01, 0x00, NULL, 0,\n\t\t&rbuf, &rbuflen);\n\tif (r < 0)\n\t\treturn r;\n\n\tval = rbuf;\n\tval_end = val + rbuflen;\n\tfor (; val < val_end; val += len) {\n\t\t/* get the tag and the length */\n\t\tif (sc_simpletlv_read_tag(&val, val_end - val, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_APPLET_INFORMATION:\n\t\t\tif (len != 5) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Applet Information: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Applet Information: Family: 0x%0x\", val[0]);\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"     Applet Version: 0x%02x 0x%02x 0x%02x 0x%02x\",\n\t\t\t    val[1], val[2], val[3], val[4]);\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_NUMBER_OF_OBJECTS:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Num objects: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Num objects = %hhd\", *val);\n\t\t\t/* make sure we do not overrun buffer */\n\t\t\tprop->num_objects = MIN(val[0], CAC_MAX_OBJECTS);\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_TV_BUFFER:\n\t\t\tif (len != 17) {\n\t\t\t\tsc_log(card->ctx, \"TAG: TV Object: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: TV Object nr. %\"SC_FORMAT_LEN_SIZE_T\"u\", i);\n\t\t\tif (i >= CAC_MAX_OBJECTS) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\n\t\t\tif (cac_parse_properties_object(card, tag, val, len,\n\t\t\t    &prop->objects[i]) == SC_SUCCESS)\n\t\t\t\ti++;\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_PKI_OBJECT:\n\t\t\tif (len != 17) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKI Object: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: PKI Object nr. %\"SC_FORMAT_LEN_SIZE_T\"u\", i);\n\t\t\tif (i >= CAC_MAX_OBJECTS) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\n\t\t\tif (cac_parse_properties_object(card, tag, val, len,\n\t\t\t    &prop->objects[i]) == SC_SUCCESS)\n\t\t\t\ti++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_log(card->ctx, \"TAG: Unknown (0x%02x), len=%\"\n\t\t\t    SC_FORMAT_LEN_SIZE_T\"u\", tag, len);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(rbuf);\n\t/* sanity */\n\tif (i != prop->num_objects)\n\t\tsc_log(card->ctx, \"The announced number of objects (%u) \"\n\t\t    \"did not match reality (%\"SC_FORMAT_LEN_SIZE_T\"u)\",\n\t\t    prop->num_objects, i);\n\tprop->num_objects = i;\n\n\treturn SC_SUCCESS;\n}\n\n/*\n * CAC cards use SC_PATH_SELECT_OBJECT_ID rather than SC_PATH_SELECT_FILE_ID. In order to use more\n * of the PKCS #15 structure, we call the selection SC_PATH_SELECT_FILE_ID, but we set p1 to 2 instead\n * of 0. Also cac1 does not do any FCI, but it doesn't understand not selecting it. It returns invalid INS\n * if it doesn't like anything about the select, so we always 'request' FCI for CAC1\n *\n * The rest is just copied from iso7816_select_file\n */\nstatic int cac_select_file_by_type(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out, int type)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char buf[SC_MAX_APDU_BUFFER_SIZE];\n\tunsigned char pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tint r, pathlen, pathtype;\n\tstruct sc_file *file = NULL;\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tassert(card != NULL && in_path != NULL);\n\tctx = card->ctx;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\tpathtype = in_path->type;\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"path->aid=%x %x %x %x %x %x %x  len=%\"SC_FORMAT_LEN_SIZE_T\"u, path->value = %x %x %x %x len=%\"SC_FORMAT_LEN_SIZE_T\"u path->type=%d (%x)\",\n\t\t in_path->aid.value[0], in_path->aid.value[1],\n\t\t in_path->aid.value[2], in_path->aid.value[3],\n\t\t in_path->aid.value[4], in_path->aid.value[5],\n\t\t in_path->aid.value[6], in_path->aid.len, in_path->value[0],\n\t\t in_path->value[1], in_path->value[2], in_path->value[3],\n\t\t in_path->len, in_path->type, in_path->type);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"file_out=%p index=%d count=%d\\n\",\n\t\t file_out, in_path->index, in_path->count);\n\n\t/* Sigh, sc_key_select expects paths to keys to have specific formats. There is no override.\n\t * we have to add some bytes to the path to make it happy. A better fix would be to give sc_key_file\n\t * a flag that says 'no, really this path is fine'.  We only need to do this for private keys */\n\tif ((pathlen > 2) && (pathlen <= 4) && memcmp(path, \"\\x3F\\x00\", 2) == 0) {\n\t\tif (pathlen > 2) {\n\t\t\tpath += 2;\n\t\t\tpathlen -= 2;\n\t\t}\n\t}\n\n\n\t/* CAC has multiple different type of objects that aren't PKCS #15. When we read\n\t * them we need convert them to something PKCS #15 would understand. Find the object\n\t * and object type here:\n\t */\n\tif (priv) { /* don't record anything if we haven't been initialized yet */\n\t\tpriv->object_type = CAC_OBJECT_TYPE_GENERIC;\n\t\tif (cac_is_cert(priv, in_path)) {\n\t\t\tpriv->object_type = CAC_OBJECT_TYPE_CERT;\n\t\t}\n\n\t\t/* forget any old cached values */\n\t\tif (priv->cache_buf) {\n\t\t\tfree(priv->cache_buf);\n\t\t\tpriv->cache_buf = NULL;\n\t\t}\n\t\tpriv->cache_buf_len = 0;\n\t\tpriv->cached = 0;\n\t}\n\n\tif (in_path->aid.len) {\n\t\tif (!pathlen) {\n\t\t\tmemcpy(path, in_path->aid.value, in_path->aid.len);\n\t\t\tpathlen = in_path->aid.len;\n\t\t\tpathtype = SC_PATH_TYPE_DF_NAME;\n\t\t} else {\n\t\t\t/* First, select the application */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"select application\" );\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 4, 0);\n\t\t\tapdu.data = in_path->aid.value;\n\t\t\tapdu.datalen = in_path->aid.len;\n\t\t\tapdu.lc = in_path->aid.len;\n\n\t\t\tr = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (r)\n\t\t\t\tLOG_FUNC_RETURN(ctx, r);\n\n\t\t}\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0);\n\n\tswitch (pathtype) {\n\t/* ideally we would had SC_PATH_TYPE_OBJECT_ID and add code to the iso7816 select.\n\t * Unfortunately we'd also need to update the caching code as well. For now just\n\t * use FILE_ID and change p1 here */\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tapdu.p1 = 2;\n\t\tif (pathlen != 2)\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\tapdu.resp = buf;\n\tapdu.resplen = sizeof(buf);\n\tapdu.le = sc_get_max_recv_size(card) < 256 ? sc_get_max_recv_size(card) : 256;\n\n\tif (file_out != NULL) {\n\t\tapdu.p2 = 0;\t\t/* first record, return FCI */\n\t}\n\telse {\n\t\tapdu.p2 = 0x0C;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\n\tif (file_out == NULL) {\n\t\t/* For some cards 'SELECT' can be only with request to return FCI/FCP. */\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (apdu.sw1 == 0x6A && apdu.sw2 == 0x86)   {\n\t\t\tapdu.p2 = 0x00;\n\t\t\tapdu.resplen = sizeof(buf);\n\t\t\tif (sc_transmit_apdu(card, &apdu) == SC_SUCCESS)\n\t\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t}\n\t\tif (apdu.sw1 == 0x61)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r)\n\t\tLOG_FUNC_RETURN(ctx, r);\n\n\t/* This needs to come after the applet selection */\n\tif (priv && in_path->len >= 2) {\n\t\t/* get applet properties to know if we can treat the\n\t\t * buffer as SimpleLTV and if we have PKI applet.\n\t\t *\n\t\t * Do this only if we select applets for reading\n\t\t * (not during driver initialization)\n\t\t */\n\t\tcac_properties_t prop;\n\t\tsize_t i = -1;\n\n\t\tr = cac_get_properties(card, &prop);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tfor (i = 0; i < prop.num_objects; i++) {\n\t\t\t\tsc_log(card->ctx, \"Searching for our OID: 0x%02x 0x%02x = 0x%02x 0x%02x\",\n\t\t\t\t    prop.objects[i].oid[0], prop.objects[i].oid[1],\n\t\t\t\t\tin_path->value[0], in_path->value[1]);\n\t\t\t\tif (memcmp(prop.objects[i].oid,\n\t\t\t\t    in_path->value, 2) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i < prop.num_objects) {\n\t\t\tif (prop.objects[i].privatekey)\n\t\t\t\tpriv->object_type = CAC_OBJECT_TYPE_CERT;\n\t\t\telse if (prop.objects[i].simpletlv == 0)\n\t\t\t\tpriv->object_type = CAC_OBJECT_TYPE_TLV_FILE;\n\t\t}\n\t}\n\n\t/* CAC cards never return FCI, fake one */\n\tfile = sc_file_new();\n\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tfile->path = *in_path;\n\tfile->size = CAC_MAX_SIZE; /* we don't know how big, just give a large size until we can read the file */\n\n\t*file_out = file;\n\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\n}\n\nstatic int cac_select_file(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\treturn cac_select_file_by_type(card, in_path, file_out, card->type);\n}\n\nstatic int cac_finish(sc_card_t *card)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (priv) {\n\t\tcac_free_private_data(priv);\n\t}\n\treturn SC_SUCCESS;\n}\n\n\n/* select the Card Capabilities Container on CAC-2 */\nstatic int cac_select_CCC(sc_card_t *card)\n{\n\treturn cac_select_file_by_type(card, &cac_CCC_Path, NULL, SC_CARD_TYPE_CAC_II);\n}\n\n/* Select ACA in non-standard location */\nstatic int cac_select_ACA(sc_card_t *card)\n{\n\treturn cac_select_file_by_type(card, &cac_ACA_Path, NULL, SC_CARD_TYPE_CAC_II);\n}\n\nstatic int cac_path_from_cardurl(sc_card_t *card, sc_path_t *path, cac_card_url_t *val, int len)\n{\n\tif (len < 10) {\n\t\treturn SC_ERROR_INVALID_DATA;\n\t}\n\tsc_mem_clear(path, sizeof(sc_path_t));\n\tmemcpy(path->aid.value, &val->rid, sizeof(val->rid));\n\tmemcpy(&path->aid.value[5], &val->applicationID, sizeof(val->applicationID));\n\tpath->aid.len = sizeof(val->rid) + sizeof(val->applicationID);\n\tmemcpy(path->value, &val->objectID, sizeof(val->objectID));\n\tpath->len = sizeof(val->objectID);\n\tpath->type = SC_PATH_TYPE_FILE_ID;\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"path->aid=%x %x %x %x %x %x %x  len=%\"SC_FORMAT_LEN_SIZE_T\"u, path->value = %x %x len=%\"SC_FORMAT_LEN_SIZE_T\"u path->type=%d (%x)\",\n\t\t path->aid.value[0], path->aid.value[1], path->aid.value[2],\n\t\t path->aid.value[3], path->aid.value[4], path->aid.value[5],\n\t\t path->aid.value[6], path->aid.len, path->value[0],\n\t\t path->value[1], path->len, path->type, path->type);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"rid=%x %x %x %x %x  len=%\"SC_FORMAT_LEN_SIZE_T\"u appid= %x %x len=%\"SC_FORMAT_LEN_SIZE_T\"u objid= %x %x len=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t val->rid[0], val->rid[1], val->rid[2], val->rid[3],\n\t\t val->rid[4], sizeof(val->rid), val->applicationID[0],\n\t\t val->applicationID[1], sizeof(val->applicationID),\n\t\t val->objectID[0], val->objectID[1], sizeof(val->objectID));\n\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_parse_aid(sc_card_t *card, cac_private_data_t *priv, u8 *aid, int aid_len)\n{\n\tcac_object_t new_object;\n\tcac_properties_t prop;\n\tsize_t i;\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* Search for PKI applets (7 B). Ignore generic objects for now */\n\tif (aid_len != 7 || (memcmp(aid, CAC_1_RID \"\\x01\", 6) != 0\n\t    && memcmp(aid, CAC_1_RID \"\\x00\", 6) != 0))\n\t\treturn SC_SUCCESS;\n\n\tsc_mem_clear(&new_object.path, sizeof(sc_path_t));\n\tmemcpy(new_object.path.aid.value, aid, aid_len);\n\tnew_object.path.aid.len = aid_len;\n\n\t/* Call without OID set will just select the AID without subseqent\n\t * OID selection, which we need to figure out just now\n\t */\n\tcac_select_file_by_type(card, &new_object.path, NULL, SC_CARD_TYPE_CAC_II);\n\tr = cac_get_properties(card, &prop);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\tfor (i = 0; i < prop.num_objects; i++) {\n\t\t/* don't fail just because we have more certs than we can support */\n\t\tif (priv->cert_next >= MAX_CAC_SLOTS)\n\t\t\treturn SC_SUCCESS;\n\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t    \"ACA: pki_object found, cert_next=%d (%s), privkey=%d\",\n\t\t    priv->cert_next, cac_labels[priv->cert_next],\n\t\t    prop.objects[i].privatekey);\n\n\t\t/* If the private key is not initialized, we can safely\n\t\t * ignore this object here, but increase the pointer to follow\n\t\t * the certificate labels\n\t\t */\n\t\tif (!prop.objects[i].privatekey) {\n\t\t\tpriv->cert_next++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* OID here has always 2B */\n\t\tmemcpy(new_object.path.value, &prop.objects[i].oid, 2);\n\t\tnew_object.path.len = 2;\n\t\tnew_object.path.type = SC_PATH_TYPE_FILE_ID;\n\t\tnew_object.name = cac_labels[priv->cert_next];\n\t\tnew_object.fd = priv->cert_next+1;\n\t\tcac_add_object_to_list(&priv->pki_list, &new_object);\n\t\tpriv->cert_next++;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_parse_cardurl(sc_card_t *card, cac_private_data_t *priv, cac_card_url_t *val, int len)\n{\n\tcac_object_t new_object;\n\tconst cac_object_t *obj;\n\tunsigned short object_id;\n\tint r;\n\n\tr = cac_path_from_cardurl(card, &new_object.path, val, len);\n\tif (r != SC_SUCCESS) {\n\t\treturn r;\n\t}\n\tswitch (val->cardApplicationType) {\n\tcase CAC_APP_TYPE_PKI:\n\t\t/* we don't want to overflow the cac_label array. This test could\n\t\t * go way if we create a label function that will create a unique label\n\t\t * from a cert index.\n\t\t */\n\t\tif (priv->cert_next >= MAX_CAC_SLOTS)\n\t\t\tbreak; /* don't fail just because we have more certs than we can support */\n\t\tnew_object.name = cac_labels[priv->cert_next];\n\t\tnew_object.fd = priv->cert_next+1;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"CARDURL: pki_object found, cert_next=%d (%s),\", priv->cert_next, new_object.name);\n\t\tcac_add_object_to_list(&priv->pki_list, &new_object);\n\t\tpriv->cert_next++;\n\t\tbreak;\n\tcase CAC_APP_TYPE_GENERAL:\n\t\tobject_id = bebytes2ushort(val->objectID);\n\t\tobj = cac_find_obj_by_id(object_id);\n\t\tif (obj == NULL)\n\t\t\tbreak; /* don't fail just because we don't recognize the object */\n\t\tnew_object.name = obj->name;\n\t\tnew_object.fd = 0;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"CARDURL: gen_object found, objectID=%x (%s),\", object_id, new_object.name);\n\t\tcac_add_object_to_list(&priv->general_list, &new_object);\n\t\tbreak;\n\tcase CAC_APP_TYPE_SKI:\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"CARDURL: ski_object found\");\n\tbreak;\n\tdefault:\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"CARDURL: unknown object_object found (type=0x%02x)\", val->cardApplicationType);\n\t\t/* don't fail just because there is an unknown object in the CCC */\n\t\tbreak;\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_parse_cuid(sc_card_t *card, cac_private_data_t *priv, cac_cuid_t *val, size_t len)\n{\n\tsize_t card_id_len;\n\n\tif (len < sizeof(cac_cuid_t)) {\n\t\treturn SC_ERROR_INVALID_DATA;\n\t}\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"gsc_rid=%s\", sc_dump_hex(val->gsc_rid, sizeof(val->gsc_rid)));\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"manufacture id=%x\", val->manufacturer_id);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"cac_type=%d\", val->card_type);\n\tcard_id_len = len - (&val->card_id - (u8 *)val);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"card_id=%s (%\"SC_FORMAT_LEN_SIZE_T\"u)\",\n\t\t sc_dump_hex(&val->card_id, card_id_len),\n\t\t card_id_len);\n\tpriv->cuid = *val;\n\tpriv->cac_id = malloc(card_id_len);\n\tif (priv->cac_id == NULL) {\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tmemcpy(priv->cac_id, &val->card_id, card_id_len);\n\tpriv->cac_id_len = card_id_len;\n\treturn SC_SUCCESS;\n}\nstatic int cac_process_CCC(sc_card_t *card, cac_private_data_t *priv);\n\nstatic int cac_parse_CCC(sc_card_t *card, cac_private_data_t *priv, u8 *tl,\n\t\t\t\t\t\t size_t tl_len, u8 *val, size_t val_len)\n{\n\tsize_t len = 0;\n\tu8 *tl_end = tl + tl_len;\n\tu8 *val_end = val + val_len;\n\tsc_path_t new_path;\n\tint r;\n\n\n\tfor (; (tl < tl_end) && (val< val_end); val += len) {\n\t\t/* get the tag and the length */\n\t\tu8 tag;\n\t\tif (sc_simpletlv_read_tag(&tl, tl_end - tl, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_CUID:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:CUID\");\n\t\t\tr = cac_parse_cuid(card, priv, (cac_cuid_t *)val, len);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase CAC_TAG_CC_VERSION_NUMBER:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: CC Version: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* ignore the version numbers for now */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\t\"TAG: CC Version = 0x%02x\", *val);\n\t\t\tbreak;\n\t\tcase CAC_TAG_GRAMMAR_VERION_NUMBER:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Grammar Version: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* ignore the version numbers for now */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\t\"TAG: Grammar Version = 0x%02x\", *val);\n\t\t\tbreak;\n\t\tcase CAC_TAG_CARDURL:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:CARDURL\");\n\t\t\tr = cac_parse_cardurl(card, priv, (cac_card_url_t *)val, len);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\t/*\n\t\t * The following are really for file systems cards. This code only cares about CAC VM cards\n\t\t */\n\t\tcase CAC_TAG_PKCS15:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKCS15: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* TODO should verify that this is '0'. If it's not\n\t\t\t * zero, we should drop out of here and let the PKCS 15\n\t\t\t * code handle this card */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG: PKCS15 = 0x%02x\", *val);\n\t\t\tbreak;\n\t\tcase CAC_TAG_DATA_MODEL:\n\t\tcase CAC_TAG_CARD_APDU:\n\t\tcase CAC_TAG_CAPABILITY_TUPLES:\n\t\tcase CAC_TAG_STATUS_TUPLES:\n\t\tcase CAC_TAG_REDIRECTION:\n\t\tcase CAC_TAG_ERROR_CODES:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:FSSpecific(0x%02x)\", tag);\n\t\t\tbreak;\n\t\tcase CAC_TAG_ACCESS_CONTROL:\n\t\t\t/* TODO handle access control later */\n\t\t\tsc_log_hex(card->ctx, \"TAG:ACCESS Control\", val, len);\n\t\t\tbreak;\n\t\tcase CAC_TAG_NEXT_CCC:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:NEXT CCC\");\n\t\t\tr = cac_path_from_cardurl(card, &new_path, (cac_card_url_t *)val, len);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\n\t\t\tr = cac_select_file_by_type(card, &new_path, NULL, SC_CARD_TYPE_CAC_II);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\n\t\t\tr = cac_process_CCC(card, priv);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:Unknown (0x%02x)\",tag );\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_process_CCC(sc_card_t *card, cac_private_data_t *priv)\n{\n\tu8 *tl = NULL, *val = NULL;\n\tsize_t tl_len, val_len;\n\tint r;\n\n\n\tr = cac_read_file(card, CAC_FILE_TAG, &tl, &tl_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tr = cac_read_file(card, CAC_FILE_VALUE, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tr = cac_parse_CCC(card, priv, tl, tl_len, val, val_len);\ndone:\n\tif (tl)\n\t\tfree(tl);\n\tif (val)\n\t\tfree(val);\n\treturn r;\n}\n\n/* Service Applet Table (Table 5-21) should list all the applets on the\n * card, which is a good start if we don't have CCC\n */\nstatic int cac_parse_ACA_service(sc_card_t *card, cac_private_data_t *priv,\n    u8 *val, size_t val_len)\n{\n\tsize_t len = 0;\n\tu8 *val_end = val + val_len;\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tfor (; val < val_end; val += len) {\n\t\t/* get the tag and the length */\n\t\tu8 tag;\n\t\tif (sc_simpletlv_read_tag(&val, val_end - val, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_APPLET_FAMILY:\n\t\t\tif (len != 5) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Applet Information: \"\n\t\t\t\t    \"bad length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Applet Information: Family: 0x%02x\", val[0]);\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"     Applet Version: 0x%02x 0x%02x 0x%02x 0x%02x\",\n\t\t\t    val[1], val[2], val[3], val[4]);\n\t\t\tbreak;\n\t\tcase CAC_TAG_NUMBER_APPLETS:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Num applets: \"\n\t\t\t\t    \"bad length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Num applets = %hhd\", *val);\n\t\t\tbreak;\n\t\tcase CAC_TAG_APPLET_ENTRY:\n\t\t\t/* Make sure we match the outer length */\n\t\t\tif (len < 3 || val[2] != len - 3) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Applet Entry: \"\n\t\t\t\t    \"bad length (%\"SC_FORMAT_LEN_SIZE_T\n\t\t\t\t    \"u) or length of internal buffer\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug_hex(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Applet Entry: AID\", &val[3], val[2]);\n\t\t\t/* This is SimpleTLV prefixed with applet ID (1B) */\n\t\t\tr = cac_parse_aid(card, priv, &val[3], val[2]);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Unknown (0x%02x)\", tag);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn SC_SUCCESS;\n}\n\n/* select a CAC pki applet by index */\nstatic int cac_select_pki_applet(sc_card_t *card, int index)\n{\n\tsc_path_t applet_path = cac_cac_pki_obj.path;\n\tapplet_path.aid.value[applet_path.aid.len-1] = index;\n\treturn cac_select_file_by_type(card, &applet_path, NULL, SC_CARD_TYPE_CAC_II);\n}\n\n/*\n *  Find the first existing CAC applet. If none found, then this isn't a CAC\n */\nstatic int cac_find_first_pki_applet(sc_card_t *card, int *index_out)\n{\n\tint r, i;\n\tfor (i = 0; i < MAX_CAC_SLOTS; i++) {\n\t\tr = cac_select_pki_applet(card, i);\n\t\tif (r == SC_SUCCESS) {\n\t\t\t/* Try to read first two bytes of the buffer to\n\t\t\t * make sure it is not just malfunctioning card\n\t\t\t */\n\t\t\tu8 params[2] = {CAC_FILE_TAG, 2};\n\t\t\tu8 data[2], *out_ptr = data;\n\t\t\tsize_t len = 2;\n\t\t\tr = cac_apdu_io(card, CAC_INS_READ_FILE, 0, 0,\n\t\t\t    &params[0], sizeof(params), &out_ptr, &len);\n\t\t\tif (r != 2)\n\t\t\t\tcontinue;\n\n\t\t\t*index_out = i;\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_OBJECT_NOT_FOUND;\n}\n\n/*\n * This emulates CCC for Alt tokens, that do not come with CCC nor ACA applets\n */\nstatic int cac_populate_cac_alt(sc_card_t *card, int index, cac_private_data_t *priv)\n{\n\tint r, i;\n\tcac_object_t pki_obj = cac_cac_pki_obj;\n\tu8 buf[100];\n\tu8 *val;\n\tsize_t val_len;\n\n\t/* populate PKI objects */\n\tfor (i = index; i < MAX_CAC_SLOTS; i++) {\n\t\tr = cac_select_pki_applet(card, i);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tpki_obj.name = cac_labels[i];\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"CAC: pki_object found, cert_next=%d (%s),\", i, pki_obj.name);\n\t\t\tpki_obj.path.aid.value[pki_obj.path.aid.len-1] = i;\n\t\t\tpki_obj.fd = i+1; /* don't use id of zero */\n\t\t\tcac_add_object_to_list(&priv->pki_list, &pki_obj);\n\t\t}\n\t}\n\n\t/* populate non-PKI objects */\n\tfor (i=0; i < cac_object_count; i++) {\n\t\tr = cac_select_file_by_type(card, &cac_objects[i].path, NULL,\n\t\t    SC_CARD_TYPE_CAC_II);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"CAC: obj_object found, cert_next=%d (%s),\",\n\t\t\t    i, cac_objects[i].name);\n\t\t\tcac_add_object_to_list(&priv->general_list, &cac_objects[i]);\n\t\t}\n\t}\n\n\t/*\n\t * create a cuid to simulate the cac 2 cuid.\n\t */\n\tpriv->cuid = cac_cac_cuid;\n\t/* create a serial number by hashing the first 100 bytes of the\n\t * first certificate on the card */\n\tr = cac_select_pki_applet(card, index);\n\tif (r < 0) {\n\t\treturn r; /* shouldn't happen unless the card has been removed or is malfunctioning */\n\t}\n\tval = buf;\n\tval_len = cac_read_binary(card, 0, val, sizeof(buf), 0);\n\tif (val_len > 0) {\n\t\tpriv->cac_id = malloc(20);\n\t\tif (priv->cac_id == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n#ifdef ENABLE_OPENSSL\n\t\tSHA1(val, val_len, priv->cac_id);\n\t\tpriv->cac_id_len = 20;\n\t\tsc_debug_hex(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t    \"cuid\", priv->cac_id, priv->cac_id_len);\n#else\n\t\tsc_log(card->ctx, \"OpenSSL Required\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_OPENSSL */\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_process_ACA(sc_card_t *card, cac_private_data_t *priv)\n{\n\tint r;\n\tu8 *val = NULL;\n\tsize_t val_len;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* Assuming ACA is already selected */\n\tr = cac_get_acr(card, CAC_ACR_SERVICE, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tr = cac_parse_ACA_service(card, priv, val, val_len);\n        if (r == SC_SUCCESS) {\n\t\tpriv->aca_path = malloc(sizeof(sc_path_t));\n\t\tif (!priv->aca_path) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tmemcpy(priv->aca_path, &cac_ACA_Path, sizeof(sc_path_t));\n\t}\ndone:\n\tif (val)\n\t\tfree(val);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\n/*\n * Look for a CAC card. If it exists, initialize our data structures\n */\nstatic int cac_find_and_initialize(sc_card_t *card, int initialize)\n{\n\tint r, index;\n\tcac_private_data_t *priv = NULL;\n\n\t/* already initialized? */\n\tif (card->drv_data) {\n\t\treturn SC_SUCCESS;\n\t}\n\n\t/* is this a CAC-2 specified in NIST Interagency Report 6887 -\n\t * \"Government Smart Card Interoperability Specification v2.1 July 2003\" */\n\tr = cac_select_CCC(card);\n\tif (r == SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"CCC found, is CAC-2\");\n\t\tif (!initialize) /* match card only */\n\t\t\treturn r;\n\n\t\tpriv = cac_new_private_data();\n\t\tif (!priv)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tr = cac_process_CCC(card, priv);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tcard->type = SC_CARD_TYPE_CAC_II;\n\t\t\tcard->drv_data = priv;\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t/* Even some ALT tokens can be missing CCC so we should try with ACA */\n\tr = cac_select_ACA(card);\n\tif (r == SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"ACA found, is CAC-2 without CCC\");\n\t\tif (!initialize) /* match card only */\n\t\t\treturn r;\n\n\t\tif (!priv) {\n\t\t\tpriv = cac_new_private_data();\n\t\t\tif (!priv)\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tr = cac_process_ACA(card, priv);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tcard->type = SC_CARD_TYPE_CAC_II;\n\t\t\tcard->drv_data = priv;\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t/* is this a CAC Alt token without any accompanying structures */\n\tr = cac_find_first_pki_applet(card, &index);\n\tif (r == SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"PKI applet found, is bare CAC Alt\");\n\t\tif (!initialize) /* match card only */\n\t\t\treturn r;\n\n\t\tif (!priv) {\n\t\t\tpriv = cac_new_private_data();\n\t\t\tif (!priv)\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcard->drv_data = priv; /* needed for the read_binary() */\n\t\tr = cac_populate_cac_alt(card, index, priv);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tcard->type = SC_CARD_TYPE_CAC_II;\n\t\t\treturn r;\n\t\t}\n\t\tcard->drv_data = NULL; /* reset on failure */\n\t}\n\tif (priv) {\n\t\tcac_free_private_data(priv);\n\t}\n\treturn r;\n}\n\n\n/* NOTE: returns a bool, 1 card matches, 0 it does not */\nstatic int cac_match_card(sc_card_t *card)\n{\n\tint r;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* Since we send an APDU, the card's logout function may be called...\n\t * however it may be in dirty memory */\n\tcard->ops->logout = NULL;\n\n\tr = cac_find_and_initialize(card, 0);\n\treturn (r == SC_SUCCESS); /* never match */\n}\n\n\nstatic int cac_init(sc_card_t *card)\n{\n\tint r;\n\tunsigned long flags;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = cac_find_and_initialize(card, 1);\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_CARD);\n\t}\n\tflags = SC_ALGORITHM_RSA_RAW;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0); /* mandatory */\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0); /* optional */\n\t_sc_card_add_rsa_alg(card, 3072, flags, 0); /* optional */\n\n\tcard->caps |= SC_CARD_CAP_RNG | SC_CARD_CAP_ISO7816_PIN_INFO;\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n}\n\nstatic int cac_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\t/* CAC, like PIV needs Extra validation of (new) PIN during\n\t * a PIN change request, to ensure it's not outside the\n\t * FIPS 201 4.1.6.1 (numeric only) and * FIPS 140-2\n\t * (6 character minimum) requirements.\n\t */\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (data->cmd == SC_PIN_CMD_CHANGE) {\n\t\tint i = 0;\n\t\tif (data->pin2.len < 6) {\n\t\t\treturn SC_ERROR_INVALID_PIN_LENGTH;\n\t\t}\n\t\tfor(i=0; i < data->pin2.len; ++i) {\n\t\t\tif (!isdigit(data->pin2.data[i])) {\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  iso_drv->ops->pin_cmd(card, data, tries_left);\n}\n\nstatic struct sc_card_operations cac_ops;\n\nstatic struct sc_card_driver cac_drv = {\n\t\"Common Access Card (CAC)\",\n\t\"cac\",\n\t&cac_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tcac_ops = *iso_drv->ops;\n\tcac_ops.match_card = cac_match_card;\n\tcac_ops.init = cac_init;\n\tcac_ops.finish = cac_finish;\n\n\tcac_ops.select_file =  cac_select_file; /* need to record object type */\n\tcac_ops.get_challenge = cac_get_challenge;\n\tcac_ops.read_binary = cac_read_binary;\n\tcac_ops.write_binary = cac_write_binary;\n\tcac_ops.set_security_env = cac_set_security_env;\n\tcac_ops.restore_security_env = cac_restore_security_env;\n\tcac_ops.compute_signature = cac_compute_signature;\n\tcac_ops.decipher =  cac_decipher;\n\tcac_ops.card_ctl = cac_card_ctl;\n\tcac_ops.pin_cmd = cac_pin_cmd;\n\n\treturn &cac_drv;\n}\n\n\nstruct sc_card_driver * sc_get_cac_driver(void)\n{\n\treturn sc_get_driver();\n}\n", "/*\n * Support for ePass2003 smart cards\n *\n * Copyright (C) 2008, Weitao Sun <weitao@ftsafe.com>\n * Copyright (C) 2011, Xiaoshuo Wu <xiaoshuo@ftsafe.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#ifdef ENABLE_SM\t\t/* empty file without SM enabled */\n#ifdef ENABLE_OPENSSL\t\t/* empty file without openssl */\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n\nstatic struct sc_atr_table epass2003_atrs[] = {\n\t/* This is a FIPS certified card using SCP01 security messaging. */\n\t{\"3B:9F:95:81:31:FE:9F:00:66:46:53:05:10:00:11:71:df:00:00:00:6a:82:5e\",\n\t \"FF:FF:FF:FF:FF:00:FF:FF:FF:FF:FF:FF:00:00:00:ff:00:ff:ff:00:00:00:00\",\n\t \"FTCOS/ePass2003\", SC_CARD_TYPE_ENTERSAFE_FTCOS_EPASS2003, 0, NULL },\n\t{NULL, NULL, NULL, 0, 0, NULL}\n};\n\nstatic struct sc_card_operations *iso_ops = NULL;\nstatic struct sc_card_operations epass2003_ops;\n\nstatic struct sc_card_driver epass2003_drv = {\n\t\"epass2003\",\n\t\"epass2003\",\n\t&epass2003_ops,\n\tNULL, 0, NULL\n};\n\n#define KEY_TYPE_AES\t0x01\t/* FIPS mode */\n#define KEY_TYPE_DES\t0x02\t/* Non-FIPS mode */\n\n#define KEY_LEN_AES\t16\n#define KEY_LEN_DES\t8\n#define KEY_LEN_DES3\t24\n#define HASH_LEN\t24\n\nstatic unsigned char PIN_ID[2] = { ENTERSAFE_USER_PIN_ID, ENTERSAFE_SO_PIN_ID };\n\n/*0x00:plain; 0x01:scp01 sm*/\n#define SM_PLAIN\t\t\t\t0x00\n#define SM_SCP01\t\t\t\t0x01\n\nstatic unsigned char g_init_key_enc[16] = {\n\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,\n\t0x0D, 0x0E, 0x0F, 0x10\n};\n\nstatic unsigned char g_init_key_mac[16] = {\n\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,\n\t0x0D, 0x0E, 0x0F, 0x10\n};\n\nstatic unsigned char g_random[8] = {\n\t0xBF, 0xC3, 0x29, 0x11, 0xC7, 0x18, 0xC3, 0x40\n};\n\ntypedef struct epass2003_exdata_st {\n\tunsigned char sm;\t\t/* SM_PLAIN or SM_SCP01 */\n\tunsigned char smtype;\t\t/* KEY_TYPE_AES or KEY_TYPE_DES */\n\tunsigned char sk_enc[16];\t/* encrypt session key */\n\tunsigned char sk_mac[16];\t/* mac session key */\n\tunsigned char icv_mac[16];\t/* instruction counter vector(for sm) */\n\tunsigned char currAlg;\t\t/* current Alg */\n\tunsigned int  ecAlgFlags; \t/* Ec Alg mechanism type*/\n} epass2003_exdata;\n\n#define REVERSE_ORDER4(x)\t(\t\t\t  \\\n\t\t((unsigned long)x & 0xFF000000)>> 24\t| \\\n\t\t((unsigned long)x & 0x00FF0000)>>  8 \t| \\\n\t\t((unsigned long)x & 0x0000FF00)<<  8\t| \\\n\t\t((unsigned long)x & 0x000000FF)<< 24)\n\n\nstatic const struct sc_card_error epass2003_errors[] = {\n\t{ 0x6200, SC_ERROR_CARD_CMD_FAILED,\t\"Warning: no information given, non-volatile memory is unchanged\" },\n\t{ 0x6281, SC_ERROR_CORRUPTED_DATA,\t\"Part of returned data may be corrupted\" },\n\t{ 0x6282, SC_ERROR_FILE_END_REACHED,\t\"End of file/record reached before reading Le bytes\" },\n\t{ 0x6283, SC_ERROR_CARD_CMD_FAILED,\t\"Selected file invalidated\" },\n\t{ 0x6284, SC_ERROR_CARD_CMD_FAILED,\t\"FCI not formatted according to ISO 7816-4\" },\n\n\t{ 0x6300, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C1, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed. One tries left\"}, \n\t{ 0x63C2, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed. Two tries left\"}, \n\t{ 0x63C3, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C4, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C5, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C6, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C7, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C8, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C9, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63CA, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\n\t{ 0x6381, SC_ERROR_CARD_CMD_FAILED,\t\"Warning: file filled up by last write\" },\n\n\t{ 0x6581, SC_ERROR_MEMORY_FAILURE,\t\"Memory failure\" },\n\n\t{ 0x6700, SC_ERROR_WRONG_LENGTH,\t\"Wrong length\" },\n\n\t{ 0x6800, SC_ERROR_NO_CARD_SUPPORT,\t\"Functions in CLA not supported\" },\n\t{ 0x6881, SC_ERROR_NO_CARD_SUPPORT,\t\"Logical channel not supported\" },\n\t{ 0x6882, SC_ERROR_NO_CARD_SUPPORT,\t\"Secure messaging not supported\" },\n\n\t{ 0x6900, SC_ERROR_NOT_ALLOWED,\t\t\"Command not allowed\" },\n\t{ 0x6981, SC_ERROR_CARD_CMD_FAILED,\t\"Command incompatible with file structure\" },\n\t{ 0x6982, SC_ERROR_SECURITY_STATUS_NOT_SATISFIED, \"Security status not satisfied\" },\n\t{ 0x6983, SC_ERROR_AUTH_METHOD_BLOCKED,\t\"Authentication method blocked\" },\n\t{ 0x6984, SC_ERROR_REF_DATA_NOT_USABLE,\t\"Referenced data not usable\" },\n\t{ 0x6985, SC_ERROR_NOT_ALLOWED,\t\t\"Conditions of use not satisfied\" },\n\t{ 0x6986, SC_ERROR_NOT_ALLOWED,\t\t\"Command not allowed (no current EF)\" },\n\t{ 0x6987, SC_ERROR_INCORRECT_PARAMETERS,\"Expected SM data objects missing\" },\n\t{ 0x6988, SC_ERROR_INCORRECT_PARAMETERS,\"SM data objects incorrect\" },\n\n\t{ 0x6A00, SC_ERROR_INCORRECT_PARAMETERS,\"Wrong parameter(s) P1-P2\" },\n\t{ 0x6A80, SC_ERROR_INCORRECT_PARAMETERS,\"Incorrect parameters in the data field\" },\n\t{ 0x6A81, SC_ERROR_NO_CARD_SUPPORT,\t\"Function not supported\" },\n\t{ 0x6A82, SC_ERROR_FILE_NOT_FOUND,\t\"File not found\" },\n\t{ 0x6A83, SC_ERROR_RECORD_NOT_FOUND,\t\"Record not found\" },\n\t{ 0x6A84, SC_ERROR_NOT_ENOUGH_MEMORY,\t\"Not enough memory space in the file\" },\n\t{ 0x6A85, SC_ERROR_INCORRECT_PARAMETERS,\"Lc inconsistent with TLV structure\" },\n\t{ 0x6A86, SC_ERROR_INCORRECT_PARAMETERS,\"Incorrect parameters P1-P2\" },\n\t{ 0x6A87, SC_ERROR_INCORRECT_PARAMETERS,\"Lc inconsistent with P1-P2\" },\n\t{ 0x6A88, SC_ERROR_DATA_OBJECT_NOT_FOUND,\"Referenced data not found\" },\n\t{ 0x6A89, SC_ERROR_FILE_ALREADY_EXISTS,  \"File already exists\"},\n\t{ 0x6A8A, SC_ERROR_FILE_ALREADY_EXISTS,  \"DF name already exists\"},\n\n\t{ 0x6B00, SC_ERROR_INCORRECT_PARAMETERS,\"Wrong parameter(s) P1-P2\" },\n\t{ 0x6D00, SC_ERROR_INS_NOT_SUPPORTED,\t\"Instruction code not supported or invalid\" },\n\t{ 0x6E00, SC_ERROR_CLASS_NOT_SUPPORTED,\t\"Class not supported\" },\n\t{ 0x6F00, SC_ERROR_CARD_CMD_FAILED,\t\"No precise diagnosis\" },\n\n\t{ 0x9000,SC_SUCCESS,                       NULL }\n};\n\nstatic int epass2003_transmit_apdu(struct sc_card *card, struct sc_apdu *apdu);\nstatic int epass2003_select_file(struct sc_card *card, const sc_path_t * in_path, sc_file_t ** file_out);\nint epass2003_refresh(struct sc_card *card);\nstatic int hash_data(const unsigned char *data, size_t datalen, unsigned char *hash, unsigned int mechanismType);\n\nstatic int\nepass2003_check_sw(struct sc_card *card, unsigned int sw1, unsigned int sw2)\n{\n\tconst int err_count = sizeof(epass2003_errors)/sizeof(epass2003_errors[0]);\n\tint i;\n\n\t/* Handle special cases here */\n\tif (sw1 == 0x6C) {\n\t\tsc_log(card->ctx, \"Wrong length; correct length is %d\", sw2);\n\t\treturn SC_ERROR_WRONG_LENGTH;\n\t}\n\n\n\tfor (i = 0; i < err_count; i++)   {\n\t\tif (epass2003_errors[i].SWs == ((sw1 << 8) | sw2)) {\n\t\t\tsc_log(card->ctx, \"%s\", epass2003_errors[i].errorstr);\n\t\t\treturn epass2003_errors[i].errorno;\n\t\t}\n\t}\n\n\tsc_log(card->ctx, \"Unknown SWs; SW1=%02X, SW2=%02X\", sw1, sw2);\n\treturn SC_ERROR_CARD_CMD_FAILED;\n}\n\nstatic int\nsc_transmit_apdu_t(sc_card_t *card, sc_apdu_t *apdu)\n{\n\tint r = sc_transmit_apdu(card, apdu);\n\tif ( ((0x69 == apdu->sw1) && (0x85 == apdu->sw2)) || ((0x69 == apdu->sw1) && (0x88 == apdu->sw2)))\n\t{\n\t\tepass2003_refresh(card);\n\t\tr = sc_transmit_apdu(card, apdu);\n\t}\n\treturn r;\n}\n\nstatic int\nopenssl_enc(const EVP_CIPHER * cipher, const unsigned char *key, const unsigned char *iv,\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tint r = SC_ERROR_INTERNAL;\n\tEVP_CIPHER_CTX * ctx = NULL;\n\tint outl = 0;\n\tint outl_tmp = 0;\n\tunsigned char iv_tmp[EVP_MAX_IV_LENGTH] = { 0 };\n\n\tmemcpy(iv_tmp, iv, EVP_MAX_IV_LENGTH);\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL)\n\t\tgoto out;\n\tEVP_EncryptInit_ex(ctx, cipher, NULL, key, iv_tmp);\n\tEVP_CIPHER_CTX_set_padding(ctx, 0);\n\n\tif (!EVP_EncryptUpdate(ctx, output, &outl, input, length))\n\t\tgoto out;\n\n\tif (!EVP_EncryptFinal_ex(ctx, output + outl, &outl_tmp))\n\t\tgoto out;\n\n\tr = SC_SUCCESS;\nout:\n\tif (ctx)\n\t    EVP_CIPHER_CTX_free(ctx);\n\treturn r;\n}\n\nstatic int\nopenssl_dec(const EVP_CIPHER * cipher, const unsigned char *key, const unsigned char *iv,\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tint r = SC_ERROR_INTERNAL;\n\tEVP_CIPHER_CTX * ctx = NULL;\n\tint outl = 0;\n\tint outl_tmp = 0;\n\tunsigned char iv_tmp[EVP_MAX_IV_LENGTH] = { 0 };\n\n\tmemcpy(iv_tmp, iv, EVP_MAX_IV_LENGTH);\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL)\n\t\tgoto out;\n\tEVP_DecryptInit_ex(ctx, cipher, NULL, key, iv_tmp);\n\tEVP_CIPHER_CTX_set_padding(ctx, 0);\n\n\tif (!EVP_DecryptUpdate(ctx, output, &outl, input, length))\n\t\tgoto out;\n\n\tif (!EVP_DecryptFinal_ex(ctx, output + outl, &outl_tmp))\n\t\tgoto out;\n\n\tr = SC_SUCCESS;\nout:\n\tif (ctx)\n\t\tEVP_CIPHER_CTX_free(ctx);\n\treturn r;\n}\n\n\nstatic int\naes128_encrypt_ecb(const unsigned char *key, int keysize,\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };\n\treturn openssl_enc(EVP_aes_128_ecb(), key, iv, input, length, output);\n}\n\n\nstatic int\naes128_encrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[16],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_enc(EVP_aes_128_cbc(), key, iv, input, length, output);\n}\n\n\nstatic int\naes128_decrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[16],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dec(EVP_aes_128_cbc(), key, iv, input, length, output);\n}\n\n\nstatic int\ndes3_encrypt_ecb(const unsigned char *key, int keysize,\n\t\tconst unsigned char *input, int length, unsigned char *output)\n{\n\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };\n\tunsigned char bKey[24] = { 0 };\n\n\tif (keysize == 16) {\n\t\tmemcpy(&bKey[0], key, 16);\n\t\tmemcpy(&bKey[16], key, 8);\n\t}\n\telse {\n\t\tmemcpy(&bKey[0], key, 24);\n\t}\n\n\treturn openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);\n}\n\n\nstatic int\ndes3_encrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tunsigned char bKey[24] = { 0 };\n\n\tif (keysize == 16) {\n\t\tmemcpy(&bKey[0], key, 16);\n\t\tmemcpy(&bKey[16], key, 8);\n\t}\n\telse {\n\t\tmemcpy(&bKey[0], key, 24);\n\t}\n\n\treturn openssl_enc(EVP_des_ede3_cbc(), bKey, iv, input, length, output);\n}\n\n\nstatic int\ndes3_decrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tunsigned char bKey[24] = { 0 };\n\tif (keysize == 16) {\n\t\tmemcpy(&bKey[0], key, 16);\n\t\tmemcpy(&bKey[16], key, 8);\n\t}\n\telse {\n\t\tmemcpy(&bKey[0], key, 24);\n\t}\n\n\treturn openssl_dec(EVP_des_ede3_cbc(), bKey, iv, input, length, output);\n}\n\n\nstatic int\ndes_encrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_enc(EVP_des_cbc(), key, iv, input, length, output);\n}\n\n\nstatic int\ndes_decrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dec(EVP_des_cbc(), key, iv, input, length, output);\n}\n\n\nstatic int\nopenssl_dig(const EVP_MD * digest, const unsigned char *input, size_t length,\n\t\tunsigned char *output)\n{\n\tint r = 0;\n\tEVP_MD_CTX *ctx = NULL;\n\tunsigned outl = 0;\n\n\tctx = EVP_MD_CTX_create();\n\tif (ctx == NULL) {\n\t    r = SC_ERROR_OUT_OF_MEMORY;\n\t    goto err;\n\t}\n\t    \n\tEVP_MD_CTX_init(ctx);\n\tEVP_DigestInit_ex(ctx, digest, NULL);\n\tif (!EVP_DigestUpdate(ctx, input, length)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tif (!EVP_DigestFinal_ex(ctx, output, &outl)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tr = SC_SUCCESS;\nerr:\n\tif (ctx)\n\t\tEVP_MD_CTX_destroy(ctx);\n\n\treturn r;\n}\n\n\nstatic int\nsha1_digest(const unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dig(EVP_sha1(), input, length, output);\n}\n\nstatic int\nsha256_digest(const unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dig(EVP_sha256(), input, length, output);\n}\n\n\nstatic int\ngen_init_key(struct sc_card *card, unsigned char *key_enc, unsigned char *key_mac,\n\t\tunsigned char *result, unsigned char key_type)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char data[256] = { 0 };\n\tunsigned char tmp_sm;\n\tunsigned long blocksize = 0;\n\tunsigned char cryptogram[256] = { 0 };\t/* host cryptogram */\n\tunsigned char iv[16] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\t\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x50, 0x00, 0x00);\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = sizeof(g_random);\n\tapdu.data = g_random;\t/* host random */\n\tapdu.le = apdu.resplen = 28;\n\tapdu.resp = result;\t/* card random is result[12~19] */\n\n\ttmp_sm = exdata->sm;\n\texdata->sm = SM_PLAIN;\n\tr = epass2003_transmit_apdu(card, &apdu);\n\texdata->sm = tmp_sm;\n\tLOG_TEST_RET(card->ctx, r, \"APDU gen_init_key failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"gen_init_key failed\");\n\n\t/* Step 1 - Generate Derivation data */\n\tmemcpy(data, &result[16], 4);\n\tmemcpy(&data[4], g_random, 4);\n\tmemcpy(&data[8], &result[12], 4);\n\tmemcpy(&data[12], &g_random[4], 4);\n\n\t/* Step 2,3 - Create S-ENC/S-MAC Session Key */\n\tif (KEY_TYPE_AES == key_type) {\n\t\taes128_encrypt_ecb(key_enc, 16, data, 16, exdata->sk_enc);\n\t\taes128_encrypt_ecb(key_mac, 16, data, 16, exdata->sk_mac);\n\t}\n\telse {\n\t\tdes3_encrypt_ecb(key_enc, 16, data, 16, exdata->sk_enc);\n\t\tdes3_encrypt_ecb(key_mac, 16, data, 16, exdata->sk_mac);\n\t}\n\n\tmemcpy(data, g_random, 8);\n\tmemcpy(&data[8], &result[12], 8);\n\tdata[16] = 0x80;\n\tblocksize = (key_type == KEY_TYPE_AES ? 16 : 8);\n\tmemset(&data[17], 0x00, blocksize - 1);\n\n\t/* calculate host cryptogram */\n\tif (KEY_TYPE_AES == key_type)\n\t\taes128_encrypt_cbc(exdata->sk_enc, 16, iv, data, 16 + blocksize, cryptogram);\n\telse\n\t\tdes3_encrypt_cbc(exdata->sk_enc, 16, iv, data, 16 + blocksize, cryptogram);\n\n\t/* verify card cryptogram */\n\tif (0 != memcmp(&cryptogram[16], &result[20], 8))\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_CARD_CMD_FAILED);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nverify_init_key(struct sc_card *card, unsigned char *ran_key, unsigned char key_type)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned long blocksize = (key_type == KEY_TYPE_AES ? 16 : 8);\n\tunsigned char data[256] = { 0 };\n\tunsigned char cryptogram[256] = { 0 };\t/* host cryptogram */\n\tunsigned char iv[16] = { 0 };\n\tunsigned char mac[256] = { 0 };\n\tunsigned long i;\n\tunsigned char tmp_sm;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tmemcpy(data, ran_key, 8);\n\tmemcpy(&data[8], g_random, 8);\n\tdata[16] = 0x80;\n\tmemset(&data[17], 0x00, blocksize - 1);\n\tmemset(iv, 0, 16);\n\n\t/* calculate host cryptogram */\n\tif (KEY_TYPE_AES == key_type) {\n\t\taes128_encrypt_cbc(exdata->sk_enc, 16, iv, data, 16 + blocksize,\n\t\t\t\t   cryptogram);\n\t} else {\n\t\tdes3_encrypt_cbc(exdata->sk_enc, 16, iv, data, 16 + blocksize,\n\t\t\t\t cryptogram);\n\t}\n\n\tmemset(data, 0, sizeof(data));\n\tmemcpy(data, \"\\x84\\x82\\x03\\x00\\x10\", 5);\n\tmemcpy(&data[5], &cryptogram[16], 8);\n\tmemcpy(&data[13], \"\\x80\\x00\\x00\", 3);\n\n\t/* calculate mac icv */\n\tmemset(iv, 0x00, 16);\n\tif (KEY_TYPE_AES == key_type) {\n\t\taes128_encrypt_cbc(exdata->sk_mac, 16, iv, data, 16, mac);\n\t\ti = 0;\n\t} else {\n\t\tdes3_encrypt_cbc(exdata->sk_mac, 16, iv, data, 16, mac);\n\t\ti = 8;\n\t}\n\t/* save mac icv */\n\tmemset(exdata->icv_mac, 0x00, 16);\n\tmemcpy(exdata->icv_mac, &mac[i], 8);\n\n\t/* verify host cryptogram */\n\tmemcpy(data, &cryptogram[16], 8);\n\tmemcpy(&data[8], &mac[i], 8);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x82, 0x03, 0x00);\n\tapdu.cla = 0x84;\n\tapdu.lc = apdu.datalen = 16;\n\tapdu.data = data;\n\ttmp_sm = exdata->sm;\n\texdata->sm = SM_PLAIN;\n\tr = epass2003_transmit_apdu(card, &apdu);\n\texdata->sm = tmp_sm;\n\tLOG_TEST_RET(card->ctx, r,\n\t\t    \"APDU verify_init_key failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r,\n\t\t    \"verify_init_key failed\");\n\treturn r;\n}\n\n\nstatic int\nmutual_auth(struct sc_card *card, unsigned char *key_enc,\n\t\t\tunsigned char *key_mac)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint r;\n\tunsigned char result[256] = { 0 };\n\tunsigned char ran_key[8] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tr = gen_init_key(card, key_enc, key_mac, result, exdata->smtype);\n\tLOG_TEST_RET(ctx, r, \"gen_init_key failed\");\n\tmemcpy(ran_key, &result[12], 8);\n\n\tr = verify_init_key(card, ran_key, exdata->smtype);\n\tLOG_TEST_RET(ctx, r, \"verify_init_key failed\");\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\nint\nepass2003_refresh(struct sc_card *card)\n{\n\tint r = SC_SUCCESS;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tif (exdata->sm) {\n\t\tcard->sm_ctx.sm_mode = 0;\n\t\tr = mutual_auth(card, g_init_key_enc, g_init_key_mac);\n\t\tcard->sm_ctx.sm_mode = SM_MODE_TRANSMIT;\n\t\tLOG_TEST_RET(card->ctx, r, \"mutual_auth failed\");\n\t}\n\n\treturn r;\n}\n\n\n/* Data(TLV)=0x87|L|0x01+Cipher */\nstatic int\nconstruct_data_tlv(struct sc_card *card, struct sc_apdu *apdu, unsigned char *apdu_buf,\n\t\tunsigned char *data_tlv, size_t * data_tlv_len, const unsigned char key_type)\n{\n\tsize_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);\n\tunsigned char pad[4096] = { 0 };\n\tsize_t pad_len;\n\tsize_t tlv_more;\t/* increased tlv length */\n\tunsigned char iv[16] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* padding */\n\tapdu_buf[block_size] = 0x87;\n\tmemcpy(pad, apdu->data, apdu->lc);\n\tpad[apdu->lc] = 0x80;\n\tif ((apdu->lc + 1) % block_size)\n\t\tpad_len = ((apdu->lc + 1) / block_size + 1) * block_size;\n\telse\n\t\tpad_len = apdu->lc + 1;\n\n\t/* encode Lc' */\n\tif (pad_len > 0x7E) {\n\t\t/* Lc' > 0x7E, use extended APDU */\n\t\tapdu_buf[block_size + 1] = 0x82;\n\t\tapdu_buf[block_size + 2] = (unsigned char)((pad_len + 1) / 0x100);\n\t\tapdu_buf[block_size + 3] = (unsigned char)((pad_len + 1) % 0x100);\n\t\tapdu_buf[block_size + 4] = 0x01;\n\t\ttlv_more = 5;\n\t}\n\telse {\n\t\tapdu_buf[block_size + 1] = (unsigned char)pad_len + 1;\n\t\tapdu_buf[block_size + 2] = 0x01;\n\t\ttlv_more = 3;\n\t}\n\tmemcpy(data_tlv, &apdu_buf[block_size], tlv_more);\n\n\t/* encrypt Data */\n\tif (KEY_TYPE_AES == key_type)\n\t\taes128_encrypt_cbc(exdata->sk_enc, 16, iv, pad, pad_len, apdu_buf + block_size + tlv_more);\n\telse\n\t\tdes3_encrypt_cbc(exdata->sk_enc, 16, iv, pad, pad_len, apdu_buf + block_size + tlv_more);\n\n\tmemcpy(data_tlv + tlv_more, apdu_buf + block_size + tlv_more, pad_len);\n\t*data_tlv_len = tlv_more + pad_len;\n\treturn 0;\n}\n\n\n/* Le(TLV)=0x97|L|Le */\nstatic int\nconstruct_le_tlv(struct sc_apdu *apdu, unsigned char *apdu_buf, size_t data_tlv_len,\n\t\tunsigned char *le_tlv, size_t * le_tlv_len, const unsigned char key_type)\n{\n\tsize_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);\n\n\t*(apdu_buf + block_size + data_tlv_len) = 0x97;\n\tif (apdu->le > 0x7F) {\n\t\t/* Le' > 0x7E, use extended APDU */\n\t\t*(apdu_buf + block_size + data_tlv_len + 1) = 2;\n\t\t*(apdu_buf + block_size + data_tlv_len + 2) = (unsigned char)(apdu->le / 0x100);\n\t\t*(apdu_buf + block_size + data_tlv_len + 3) = (unsigned char)(apdu->le % 0x100);\n\t\tmemcpy(le_tlv, apdu_buf + block_size + data_tlv_len, 4);\n\t\t*le_tlv_len = 4;\n\t}\n\telse {\n\t\t*(apdu_buf + block_size + data_tlv_len + 1) = 1;\n\t\t*(apdu_buf + block_size + data_tlv_len + 2) = (unsigned char)apdu->le;\n\t\tmemcpy(le_tlv, apdu_buf + block_size + data_tlv_len, 3);\n\t\t*le_tlv_len = 3;\n\t}\n\treturn 0;\n}\n\n\n/* MAC(TLV)=0x8e|0x08|MAC */\nstatic int\nconstruct_mac_tlv(struct sc_card *card, unsigned char *apdu_buf, size_t data_tlv_len, size_t le_tlv_len,\n\t\tunsigned char *mac_tlv, size_t * mac_tlv_len, const unsigned char key_type)\n{\n\tsize_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);\n\tunsigned char mac[4096] = { 0 };\n\tsize_t mac_len;\n\tunsigned char icv[16] = { 0 };\n\tint i = (KEY_TYPE_AES == key_type ? 15 : 7);\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tif (0 == data_tlv_len && 0 == le_tlv_len) {\n\t\tmac_len = block_size;\n\t}\n\telse {\n\t\t/* padding */\n\t\t*(apdu_buf + block_size + data_tlv_len + le_tlv_len) = 0x80;\n\t\tif ((data_tlv_len + le_tlv_len + 1) % block_size)\n\t\t\tmac_len = (((data_tlv_len + le_tlv_len + 1) / block_size) +\n\t\t\t\t\t1) * block_size + block_size;\n\n\t\telse\n\t\t\tmac_len = data_tlv_len + le_tlv_len + 1 + block_size;\n\n\t\tmemset((apdu_buf + block_size + data_tlv_len + le_tlv_len + 1),\n\t\t       0, (mac_len - (data_tlv_len + le_tlv_len + 1)));\n\t}\n\n\t/* increase icv */\n\tfor (; i >= 0; i--) {\n\t\tif (exdata->icv_mac[i] == 0xff) {\n\t\t\texdata->icv_mac[i] = 0;\n\t\t}\n\t\telse {\n\t\t\texdata->icv_mac[i]++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* calculate MAC */\n\tmemset(icv, 0, sizeof(icv));\n\tmemcpy(icv, exdata->icv_mac, 16);\n\tif (KEY_TYPE_AES == key_type) {\n\t\taes128_encrypt_cbc(exdata->sk_mac, 16, icv, apdu_buf, mac_len, mac);\n\t\tmemcpy(mac_tlv + 2, &mac[mac_len - 16], 8);\n\t}\n\telse {\n\t\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };\n\t\tunsigned char tmp[8] = { 0 };\n\t\tdes_encrypt_cbc(exdata->sk_mac, 8, icv, apdu_buf, mac_len, mac);\n\t\tdes_decrypt_cbc(&exdata->sk_mac[8], 8, iv, &mac[mac_len - 8], 8, tmp);\n\t\tmemset(iv, 0x00, sizeof iv);\n\t\tdes_encrypt_cbc(exdata->sk_mac, 8, iv, tmp, 8, mac_tlv + 2);\n\t}\n\n\t*mac_tlv_len = 2 + 8;\n\treturn 0;\n}\n\n\n/* According to GlobalPlatform Card Specification's SCP01\n * encode APDU from\n * CLA INS P1 P2 [Lc] Data [Le]\n * to\n * CLA INS P1 P2 Lc' Data' [Le]\n * where\n * Data'=Data(TLV)+Le(TLV)+MAC(TLV) */\nstatic int\nencode_apdu(struct sc_card *card, struct sc_apdu *plain, struct sc_apdu *sm,\n\t\tunsigned char *apdu_buf, size_t * apdu_buf_len)\n{\n\tsize_t block_size = 0;\n\tunsigned char dataTLV[4096] = { 0 };\n\tsize_t data_tlv_len = 0;\n\tunsigned char le_tlv[256] = { 0 };\n\tsize_t le_tlv_len = 0;\n\tsize_t mac_tlv_len = 10;\n\tsize_t tmp_lc = 0;\n\tsize_t tmp_le = 0;\n\tunsigned char mac_tlv[256] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tmac_tlv[0] = 0x8E;\n\tmac_tlv[1] = 8;\n\t/* size_t plain_le = 0; */\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata*)card->drv_data;\n\tblock_size = (KEY_TYPE_DES == exdata->smtype ? 16 : 8);\n\n\tsm->cse = SC_APDU_CASE_4_SHORT;\n\tapdu_buf[0] = (unsigned char)plain->cla;\n\tapdu_buf[1] = (unsigned char)plain->ins;\n\tapdu_buf[2] = (unsigned char)plain->p1;\n\tapdu_buf[3] = (unsigned char)plain->p2;\n\t/* plain_le = plain->le; */\n\t/* padding */\n\tapdu_buf[4] = 0x80;\n\tmemset(&apdu_buf[5], 0x00, block_size - 5);\n\n\t/* Data -> Data' */\n\tif (plain->lc != 0)\n\t\tif (0 != construct_data_tlv(card, plain, apdu_buf, dataTLV, &data_tlv_len, exdata->smtype))\n\t\t\treturn -1;\n\n\tif (plain->le != 0 || (plain->le == 0 && plain->resplen != 0))\n\t\tif (0 != construct_le_tlv(plain, apdu_buf, data_tlv_len, le_tlv,\n\t\t\t\t     &le_tlv_len, exdata->smtype))\n\t\t\treturn -1;\n\n\tif (0 != construct_mac_tlv(card, apdu_buf, data_tlv_len, le_tlv_len, mac_tlv, &mac_tlv_len, exdata->smtype))\n\t\treturn -1;\n\n\tmemset(apdu_buf + 4, 0, *apdu_buf_len - 4);\n\tsm->lc = sm->datalen = data_tlv_len + le_tlv_len + mac_tlv_len;\n\tif (sm->lc > 0xFF) {\n\t\tsm->cse = SC_APDU_CASE_4_EXT;\n\t\tapdu_buf[4] = (unsigned char)((sm->lc) / 0x10000);\n\t\tapdu_buf[5] = (unsigned char)(((sm->lc) / 0x100) % 0x100);\n\t\tapdu_buf[6] = (unsigned char)((sm->lc) % 0x100);\n\t\ttmp_lc = 3;\n\t}\n\telse {\n\t\tapdu_buf[4] = (unsigned char)sm->lc;\n\t\ttmp_lc = 1;\n\t}\n\n\tmemcpy(apdu_buf + 4 + tmp_lc, dataTLV, data_tlv_len);\n\tmemcpy(apdu_buf + 4 + tmp_lc + data_tlv_len, le_tlv, le_tlv_len);\n\tmemcpy(apdu_buf + 4 + tmp_lc + data_tlv_len + le_tlv_len, mac_tlv, mac_tlv_len);\n\tmemcpy((unsigned char *)sm->data, apdu_buf + 4 + tmp_lc, sm->datalen);\n\t*apdu_buf_len = 0;\n\n\tif (4 == le_tlv_len) {\n\t\tsm->cse = SC_APDU_CASE_4_EXT;\n\t\t*(apdu_buf + 4 + tmp_lc + sm->lc) = (unsigned char)(plain->le / 0x100);\n\t\t*(apdu_buf + 4 + tmp_lc + sm->lc + 1) = (unsigned char)(plain->le % 0x100);\n\t\ttmp_le = 2;\n\t}\n\telse if (3 == le_tlv_len) {\n\t\t*(apdu_buf + 4 + tmp_lc + sm->lc) = (unsigned char)plain->le;\n\t\ttmp_le = 1;\n\t}\n\n\t*apdu_buf_len += 4 + tmp_lc + data_tlv_len + le_tlv_len + mac_tlv_len + tmp_le;\n\t/* sm->le = calc_le(plain_le); */\n\treturn 0;\n}\n\n\nstatic int\nepass2003_sm_wrap_apdu(struct sc_card *card, struct sc_apdu *plain, struct sc_apdu *sm)\n{\n\tunsigned char buf[4096] = { 0 };\t/* APDU buffer */\n\tsize_t buf_len = sizeof(buf);\n\tepass2003_exdata *exdata = NULL;\n\t\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (exdata->sm)\n\t\tplain->cla |= 0x0C;\n\n\tsm->cse = plain->cse;\n\tsm->cla = plain->cla;\n\tsm->ins = plain->ins;\n\tsm->p1 = plain->p1;\n\tsm->p2 = plain->p2;\n\tsm->lc = plain->lc;\n\tsm->le = plain->le;\n\tsm->control = plain->control;\n\tsm->flags = plain->flags;\n\n\tswitch (sm->cla & 0x0C) {\n\tcase 0x00:\n\tcase 0x04:\n\t\tsm->datalen = plain->datalen;\n\t\tmemcpy((void *)sm->data, plain->data, plain->datalen);\n\t\tsm->resplen = plain->resplen;\n\t\tmemcpy(sm->resp, plain->resp, plain->resplen);\n\t\tbreak;\n\tcase 0x0C:\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (0 != encode_apdu(card, plain, sm, buf, &buf_len))\n\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\n\n/* According to GlobalPlatform Card Specification's SCP01\n * decrypt APDU response from\n * ResponseData' SW1 SW2\n * to\n * ResponseData SW1 SW2\n * where\n * ResponseData'=Data(TLV)+SW12(TLV)+MAC(TLV)\n * where\n * Data(TLV)=0x87|L|Cipher\n * SW12(TLV)=0x99|0x02|SW1+SW2\n * MAC(TLV)=0x8e|0x08|MAC */\nstatic int\ndecrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}\n\n\nstatic int\nepass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_sm_free_wrapped_apdu(struct sc_card *card,\n\t\tstruct sc_apdu *plain, struct sc_apdu **sm_apdu)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint rv = SC_SUCCESS;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!sm_apdu)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\tif (!(*sm_apdu))\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\n\tif (plain)\n\t\trv = epass2003_sm_unwrap_apdu(card, *sm_apdu, plain);\n\n\tif ((*sm_apdu)->data) {\n\t\tunsigned char * p = (unsigned char *)((*sm_apdu)->data);\n\t\tfree(p);\n\t}\n\tif ((*sm_apdu)->resp) {\n\t\tfree((*sm_apdu)->resp);\n\t}\n\n\tfree(*sm_apdu);\n\t*sm_apdu = NULL;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\nepass2003_sm_get_wrapped_apdu(struct sc_card *card,\n\t\tstruct sc_apdu *plain, struct sc_apdu **sm_apdu)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu *apdu = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!plain || !sm_apdu)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\t*sm_apdu = NULL;\n\t//construct new SM apdu from original apdu\n\tapdu = calloc(1, sizeof(struct sc_apdu));\n\tif (!apdu) {\n\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\tapdu->data = calloc (1, SC_MAX_EXT_APDU_BUFFER_SIZE);\n\tif (!apdu->data) {\n\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\tapdu->resp = calloc (1, SC_MAX_EXT_APDU_BUFFER_SIZE);\n\tif (!apdu->resp) {\n\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\tapdu->datalen = SC_MAX_EXT_APDU_BUFFER_SIZE;\n\tapdu->resplen = SC_MAX_EXT_APDU_BUFFER_SIZE;\n\n\trv = epass2003_sm_wrap_apdu(card, plain, apdu);\n\tif (rv)   {\n\t\trv = epass2003_sm_free_wrapped_apdu(card, NULL, &apdu);\n\t\tif (rv < 0)\n\t\t\tgoto err;\n\t}\n\n\t*sm_apdu = apdu;\n\tapdu = NULL;\nerr:\n\tif (apdu) {\n\t\tfree((unsigned char *) apdu->data);\n\t\tfree(apdu->resp);\n\t\tfree(apdu);\n\t\tapdu = NULL;\n\t}\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\nepass2003_transmit_apdu(struct sc_card *card, struct sc_apdu *apdu)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_transmit_apdu_t(card, apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\treturn r;\n}\n\n\nstatic int\nget_data(struct sc_card *card, unsigned char type, unsigned char *data, size_t datalen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char resp[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tsize_t resplen = SC_MAX_APDU_BUFFER_SIZE;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, type);\n\tapdu.resp = resp;\n\tapdu.le = 0;\n\tapdu.resplen = resplen;\n\tif (0x86 == type) {\n\t\t/* No SM temporarily */\n\t\tunsigned char tmp_sm = exdata->sm;\n\t\texdata->sm = SM_PLAIN;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\texdata->sm = tmp_sm;\n\t}\n\telse {\n\t\tr = sc_transmit_apdu_t(card, &apdu);\n\t}\n\tLOG_TEST_RET(card->ctx, r, \"APDU get_data failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"get_data failed\");\n\n\tmemcpy(data, resp, datalen);\n\treturn r;\n}\n\n/* card driver functions */\n\nstatic int epass2003_match_card(struct sc_card *card)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tr = _sc_match_atr(card, epass2003_atrs, &card->type);\n\tif (r < 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic int\nepass2003_init(struct sc_card *card)\n{\n\tunsigned int flags;\n\tunsigned int ext_flags;\n\tunsigned char data[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tsize_t datalen = SC_MAX_APDU_BUFFER_SIZE;\n\tepass2003_exdata *exdata = NULL;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tcard->name = \"epass2003\";\n\tcard->cla = 0x00;\n\texdata = (epass2003_exdata *)calloc(1, sizeof(epass2003_exdata));\n\tif (!exdata)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tcard->drv_data = exdata;\n\n\texdata->sm = SM_SCP01;\n\n\t/* decide FIPS/Non-FIPS mode */\n\tif (SC_SUCCESS != get_data(card, 0x86, data, datalen))\n\t\treturn SC_ERROR_INVALID_CARD;\n\n\tif (0x01 == data[2])\n\t\texdata->smtype = KEY_TYPE_AES;\n\telse\n\t\texdata->smtype = KEY_TYPE_DES;\n\n\tif (0x84 == data[14]) {\n\t\tif (0x00 == data[16]) { \n\t\t\texdata->sm = SM_PLAIN;\n\t\t}\n\t}\n\n\n\t/* mutual authentication */\n\tcard->max_recv_size = 0xD8;\n\tcard->max_send_size = 0xE8;\n\n\tcard->sm_ctx.ops.open = epass2003_refresh;\n\tcard->sm_ctx.ops.get_sm_apdu = epass2003_sm_get_wrapped_apdu;\n\tcard->sm_ctx.ops.free_sm_apdu = epass2003_sm_free_wrapped_apdu;\n\n\t/* FIXME (VT): rather then set/unset 'g_sm', better to implement filter for APDUs to be wrapped */\n\tepass2003_refresh(card);\n\n\tcard->sm_ctx.sm_mode = SM_MODE_TRANSMIT;\n\n\tflags = SC_ALGORITHM_ONBOARD_KEY_GEN | SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_RSA_HASH_NONE;\n\n\t_sc_card_add_rsa_alg(card, 512, flags, 0);\n\t_sc_card_add_rsa_alg(card, 768, flags, 0);\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\n\t//set EC Alg Flags\n\tflags = SC_ALGORITHM_ONBOARD_KEY_GEN|SC_ALGORITHM_ECDSA_HASH_SHA1|SC_ALGORITHM_ECDSA_HASH_SHA256|SC_ALGORITHM_ECDSA_HASH_NONE|SC_ALGORITHM_ECDSA_RAW;\n\text_flags = 0;\n\t_sc_card_add_ec_alg(card, 256, flags, ext_flags, NULL);\n\n\tcard->caps = SC_CARD_CAP_RNG | SC_CARD_CAP_APDU_EXT;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nstatic int\nepass2003_finish(sc_card_t *card)\n{\n\tepass2003_exdata *exdata = (epass2003_exdata *)card->drv_data;\n\n\tif (exdata)\n\t\tfree(exdata);\n\treturn SC_SUCCESS;\n}\n\n/* COS implement SFI as lower 5 bits of FID, and not allow same SFI at the\n * same DF, so use hook functions to increase/decrease FID by 0x20 */\nstatic int\nepass2003_hook_path(struct sc_path *path, int inc)\n{\n\tu8 fid_h = path->value[path->len - 2];\n\tu8 fid_l = path->value[path->len - 1];\n\n\tswitch (fid_h) {\n\tcase 0x29:\n\tcase 0x30:\n\tcase 0x31:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\t\tif (inc)\n\t\t\tfid_l = fid_l * FID_STEP;\n\t\telse\n\t\t\tfid_l = fid_l / FID_STEP;\n\t\tpath->value[path->len - 1] = fid_l;\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\nstatic void\nepass2003_hook_file(struct sc_file *file, int inc)\n{\n\tint fidl = file->id & 0xff;\n\tint fidh = file->id & 0xff00;\n\tif (epass2003_hook_path(&file->path, inc)) {\n\t\tif (inc)\n\t\t\tfile->id = fidh + fidl * FID_STEP;\n\t\telse\n\t\t\tfile->id = fidh + fidl / FID_STEP;\n\t}\n}\n\n\nstatic int\nepass2003_select_fid_(struct sc_card *card, sc_path_t * in_path, sc_file_t ** file_out)\n{\n\tstruct sc_apdu apdu;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tu8 pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tint r, pathlen;\n\tsc_file_t *file = NULL;\n\n\tepass2003_hook_path(in_path, 1);\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);\n\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tapdu.p1 = 0;\n\t\tif (pathlen != 2)\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tapdu.p2 = 0;\t\t/* first record, return FCI */\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 0;\n\t}\n\telse   {\n\t\tapdu.cse = (apdu.lc == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tif (path[0] == 0x29) {\t/* TODO:0x29 accords with FID prefix in profile  */\n\t\t/* Not allowed to select private key file, so fake fci. */\n\t\t/* 62 16 82 02 11 00 83 02 29 00 85 02 08 00 86 08 FF 90 90 90 FF FF FF FF */\n\t\tapdu.resplen = 0x18;\n\t\tmemcpy(apdu.resp,\n\t\t       \"\\x6f\\x16\\x82\\x02\\x11\\x00\\x83\\x02\\x29\\x00\\x85\\x02\\x08\\x00\\x86\\x08\\xff\\x90\\x90\\x90\\xff\\xff\\xff\\xff\",\n\t\t       apdu.resplen);\n\t\tapdu.resp[9] = path[1];\n\t\tapdu.sw1 = 0x90;\n\t\tapdu.sw2 = 0x00;\n\t}\n\telse {\n\t\tr = sc_transmit_apdu_t(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\t}\n\n\tif (file_out == NULL) {\n\t\tif (apdu.sw1 == 0x61)\n\t\t\tLOG_FUNC_RETURN(card->ctx, 0);\n\t\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n\t}\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\tif (apdu.resplen < 2)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\n\tswitch (apdu.resp[0]) {\n\tcase 0x6F:\n\t\tfile = sc_file_new();\n\t\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tfile->path = *in_path;\n\t\tif (card->ops->process_fci == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t\t}\n\n\t\tif ((size_t) apdu.resp[1] + 2 <= apdu.resplen)\n\t\t\tcard->ops->process_fci(card, file, apdu.resp + 2, apdu.resp[1]);\n\t\tepass2003_hook_file(file, 0);\n\t\t*file_out = file;\n\t\tbreak;\n\tcase 0x00:\t\t/* proprietary coding */\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\treturn 0;\n}\n\n\nstatic int\nepass2003_select_fid(struct sc_card *card, unsigned int id_hi, unsigned int id_lo,\n\t\tsc_file_t ** file_out)\n{\n\tint r;\n\tsc_file_t *file = 0;\n\tsc_path_t path;\n\n\tmemset(&path, 0, sizeof(path));\n\tpath.type = SC_PATH_TYPE_FILE_ID;\n\tpath.value[0] = id_hi;\n\tpath.value[1] = id_lo;\n\tpath.len = 2;\n\n\tr = epass2003_select_fid_(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t/* update cache */\n\tif (file && file->type == SC_FILE_TYPE_DF) {\n\t\tcard->cache.current_path.type = SC_PATH_TYPE_PATH;\n\t\tcard->cache.current_path.value[0] = 0x3f;\n\t\tcard->cache.current_path.value[1] = 0x00;\n\t\tif (id_hi == 0x3f && id_lo == 0x00) {\n\t\t\tcard->cache.current_path.len = 2;\n\t\t}\n\t\telse {\n\t\t\tcard->cache.current_path.len = 4;\n\t\t\tcard->cache.current_path.value[2] = id_hi;\n\t\t\tcard->cache.current_path.value[3] = id_lo;\n\t\t}\n\t}\n\n\tif (file_out)\n\t\t*file_out = file;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_select_aid(struct sc_card *card, const sc_path_t * in_path, sc_file_t ** file_out)\n{\n\tint r = 0;\n\n\tif (card->cache.valid\n\t\t\t&& card->cache.current_path.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_path.len == in_path->len\n\t\t\t&& memcmp(card->cache.current_path.value, in_path->value, in_path->len) == 0) {\n\t\tif (file_out) {\n\t\t\t*file_out = sc_file_new();\n\t\t\tif (!file_out)\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t}\n\telse {\n\t\tr = iso_ops->select_file(card, in_path, file_out);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t\t/* update cache */\n\t\tcard->cache.current_path.type = SC_PATH_TYPE_DF_NAME;\n\t\tcard->cache.current_path.len = in_path->len;\n\t\tmemcpy(card->cache.current_path.value, in_path->value, in_path->len);\n\t}\n\n\tif (file_out) {\n\t\tsc_file_t *file = *file_out;\n\n\t\tfile->type = SC_FILE_TYPE_DF;\n\t\tfile->ef_structure = SC_FILE_EF_UNKNOWN;\n\t\tfile->path.len = 0;\n\t\tfile->size = 0;\n\t\t/* AID */\n\t\tmemcpy(file->name, in_path->value, in_path->len);\n\t\tfile->namelen = in_path->len;\n\t\tfile->id = 0x0000;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\nstatic int\nepass2003_select_path(struct sc_card *card, const u8 pathbuf[16], const size_t len,\n\t\tsc_file_t ** file_out)\n{\n\tu8 n_pathbuf[SC_MAX_PATH_SIZE];\n\tconst u8 *path = pathbuf;\n\tsize_t pathlen = len;\n\tint bMatch = -1;\n\tunsigned int i;\n\tint r;\n\n\tif (pathlen % 2 != 0 || pathlen > 6 || pathlen <= 0)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\t/* if pathlen == 6 then the first FID must be MF (== 3F00) */\n\tif (pathlen == 6 && (path[0] != 0x3f || path[1] != 0x00))\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\t/* unify path (the first FID should be MF) */\n\tif (path[0] != 0x3f || path[1] != 0x00) {\n\t\tn_pathbuf[0] = 0x3f;\n\t\tn_pathbuf[1] = 0x00;\n\n\t\tfor (i = 0; i < pathlen; i++)\n\t\t\tn_pathbuf[i + 2] = pathbuf[i];\n\t\tpath = n_pathbuf;\n\t\tpathlen += 2;\n\t}\n\n\t/* check current working directory */\n\tif (card->cache.valid\n\t\t\t&& card->cache.current_path.type == SC_PATH_TYPE_PATH\n\t\t\t&& card->cache.current_path.len >= 2\n\t\t\t&& card->cache.current_path.len <= pathlen) {\n\t\tbMatch = 0;\n\t\tfor (i = 0; i < card->cache.current_path.len; i += 2)\n\t\t\tif (card->cache.current_path.value[i] == path[i]\n\t\t\t\t\t&& card->cache.current_path.value[i + 1] == path[i + 1])\n\t\t\t\tbMatch += 2;\n\t}\n\n\tif (card->cache.valid && bMatch > 2) {\n\t\tif (pathlen - bMatch == 2) {\n\t\t\t/* we are in the right directory */\n\t\t\treturn epass2003_select_fid(card, path[bMatch], path[bMatch + 1], file_out);\n\t\t}\n\t\telse if (pathlen - bMatch > 2) {\n\t\t\t/* two more steps to go */\n\t\t\tsc_path_t new_path;\n\n\t\t\t/* first step: change directory */\n\t\t\tr = epass2003_select_fid(card, path[bMatch], path[bMatch + 1], NULL);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"SELECT FILE (DF-ID) failed\");\n\n\t\t\tnew_path.type = SC_PATH_TYPE_PATH;\n\t\t\tnew_path.len = pathlen - bMatch - 2;\n\t\t\tmemcpy(new_path.value, &(path[bMatch + 2]), new_path.len);\n\n\t\t\t/* final step: select file */\n\t\t\treturn epass2003_select_file(card, &new_path, file_out);\n\t\t}\n\t\telse {\t/* if (bMatch - pathlen == 0) */\n\n\t\t\t/* done: we are already in the\n\t\t\t * requested directory */\n\t\t\tsc_log(card->ctx, \"cache hit\\n\");\n\t\t\t/* copy file info (if necessary) */\n\t\t\tif (file_out) {\n\t\t\t\tsc_file_t *file = sc_file_new();\n\t\t\t\tif (!file)\n\t\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tfile->id = (path[pathlen - 2] << 8) + path[pathlen - 1];\n\t\t\t\tfile->path = card->cache.current_path;\n\t\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\t\tfile->ef_structure = SC_FILE_EF_UNKNOWN;\n\t\t\t\tfile->size = 0;\n\t\t\t\tfile->namelen = 0;\n\t\t\t\tfile->magic = SC_FILE_MAGIC;\n\t\t\t\t*file_out = file;\n\t\t\t}\n\t\t\t/* nothing left to do */\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\telse {\n\t\t/* no usable cache */\n\t\tfor (i = 0; i < pathlen - 2; i += 2) {\n\t\t\tr = epass2003_select_fid(card, path[i], path[i + 1], NULL);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"SELECT FILE (DF-ID) failed\");\n\t\t}\n\n\t\treturn epass2003_select_fid(card, path[pathlen - 2], path[pathlen - 1], file_out);\n\t}\n}\n\n\nstatic int\nepass2003_select_file(struct sc_card *card, const sc_path_t * in_path,\n\t\tsc_file_t ** file_out)\n{\n\tint r;\n\tchar pbuf[SC_MAX_PATH_STRING_SIZE];\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_path_print(pbuf, sizeof(pbuf), &card->cache.current_path);\n\tif (r != SC_SUCCESS)\n\t\tpbuf[0] = '\\0';\n\n\tsc_log(card->ctx,\n\t       \"current path (%s, %s): %s (len: %\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t       card->cache.current_path.type == SC_PATH_TYPE_DF_NAME ?\n\t       \"aid\" : \"path\",\n\t       card->cache.valid ? \"valid\" : \"invalid\", pbuf,\n\t       card->cache.current_path.len);\n\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (in_path->len != 2)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t\treturn epass2003_select_fid(card, in_path->value[0], in_path->value[1], file_out);\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\treturn epass2003_select_aid(card, in_path, file_out);\n\tcase SC_PATH_TYPE_PATH:\n\t\treturn epass2003_select_path(card, in_path->value, in_path->len, file_out);\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n}\n\n\nstatic int\nepass2003_set_security_env(struct sc_card *card, const sc_security_env_t * env, int se_num)\n{\n\tstruct sc_apdu apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tu8 *p;\n\tunsigned short fid = 0;\n\tint r, locked = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, 0);\n    \n\tp = sbuf;\n\t*p++ = 0x80;\t\t/* algorithm reference */\n\t*p++ = 0x01;\n\t*p++ = 0x84;\n\n\t*p++ = 0x81;\n\t*p++ = 0x02;\n\n\tfid = 0x2900;\n\tfid += (unsigned short)(0x20 * (env->key_ref[0] & 0xff));\n\t*p++ = fid >> 8;\n\t*p++ = fid & 0xff;\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\n\tif (env->algorithm == SC_ALGORITHM_EC)\n\t{\n\t\tapdu.p2 = 0xB6;\n\t\texdata->currAlg = SC_ALGORITHM_EC;\n\t\tif(env->algorithm_flags & SC_ALGORITHM_ECDSA_HASH_SHA1)\n\t\t{\n\t\t\tsbuf[2] = 0x91;\n\t\t\texdata->ecAlgFlags = SC_ALGORITHM_ECDSA_HASH_SHA1;\n\t\t}\n\t\telse if (env->algorithm_flags & SC_ALGORITHM_ECDSA_HASH_SHA256)\n\t\t{\n\t\t\tsbuf[2] = 0x92;\n\t\t\texdata->ecAlgFlags = SC_ALGORITHM_ECDSA_HASH_SHA256;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsc_log(card->ctx, \"%0x Alg Not Support! \", env->algorithm_flags);\n\t\t\tgoto err;\n\t\t}\n\t}\n\telse if(env->algorithm == SC_ALGORITHM_RSA)\n\t{\n\t\texdata->currAlg = SC_ALGORITHM_RSA; \n\t\tapdu.p2 = 0xB8;\n\t\tsc_log(card->ctx, \"setenv RSA Algorithm alg_flags = %0x\\n\",env->algorithm_flags);\n\t}\n\telse\n\t{\n\t\tsc_log(card->ctx, \"%0x Alg Not Support! \", env->algorithm);\n\t}\n\n\tif (se_num > 0) {\n\t\tr = sc_lock(card);\n\t\tLOG_TEST_RET(card->ctx, r, \"sc_lock() failed\");\n\t\tlocked = 1;\n\t}\n\tif (apdu.datalen != 0) {\n\t\tr = sc_transmit_apdu_t(card, &apdu);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (se_num <= 0)\n\t\treturn 0;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0xF2, se_num);\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tsc_unlock(card);\n\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n\nerr:\n\tif (locked)\n\t\tsc_unlock(card);\n\treturn r;\n}\n\n\nstatic int\nepass2003_restore_security_env(struct sc_card *card, int se_num)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int epass2003_decipher(struct sc_card *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\t\n\tLOG_FUNC_CALLED(card->ctx);\n\t\n\tif (!card->drv_data)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tif(exdata->currAlg == SC_ALGORITHM_EC)\n\t{\n\t\tif(exdata->ecAlgFlags & SC_ALGORITHM_ECDSA_HASH_SHA1)\n\t\t{\n\t\t\tr = hash_data(data, datalen, sbuf, SC_ALGORITHM_ECDSA_HASH_SHA1);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"hash_data failed\"); \n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3,0x2A, 0x9E, 0x9A);\n\t\t\tapdu.data = sbuf;\n\t\t\tapdu.lc = 0x14;\n\t\t\tapdu.datalen = 0x14;\n\t\t}\n\t\telse if (exdata->ecAlgFlags & SC_ALGORITHM_ECDSA_HASH_SHA256)\n\t\t{\n\t\t\tr = hash_data(data, datalen, sbuf, SC_ALGORITHM_ECDSA_HASH_SHA256);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"hash_data failed\");\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3,0x2A, 0x9E, 0x9A);\n\t\t\tapdu.data = sbuf;\n\t\t\tapdu.lc = 0x20;\n\t\t\tapdu.datalen = 0x20;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 0;\n\n\t\tr = sc_transmit_apdu_t(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\t\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\t\tsize_t len = apdu.resplen > outlen ? outlen : apdu.resplen;\n\t\t\tmemcpy(out, apdu.resp, len);\n\t\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t\t}\n\t\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n\t}\n\telse if(exdata->currAlg == SC_ALGORITHM_RSA)\n\t{\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_EXT, 0x2A, 0x80, 0x86);\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 0;\n\n\t\tmemcpy(sbuf, data, datalen);\n\t\tapdu.data = sbuf;\n\t\tapdu.lc = datalen;\n\t\tapdu.datalen = datalen;\n\t}\n\telse\n\t{\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_EXT, 0x2A, 0x80, 0x86);\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 256;\n\n\t\tmemcpy(sbuf, data, datalen);\n\t\tapdu.data = sbuf;\n\t\tapdu.lc = datalen;\n\t\tapdu.datalen = datalen;\n\t}\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\tsize_t len = apdu.resplen > outlen ? outlen : apdu.resplen;\n\t\tmemcpy(out, apdu.resp, len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\n\nstatic int\nacl_to_ac_byte(struct sc_card *card, const struct sc_acl_entry *e)\n{\n\tif (e == NULL)\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\n\tswitch (e->method) {\n\tcase SC_AC_NONE:\n\t\tLOG_FUNC_RETURN(card->ctx, EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE);\n\tcase SC_AC_NEVER:\n\t\tLOG_FUNC_RETURN(card->ctx, EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_NOONE);\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_USER);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INCORRECT_PARAMETERS);\n}\n\n\nstatic int\nepass2003_process_fci(struct sc_card *card, sc_file_t * file, const u8 * buf, size_t buflen)\n{\n\tsc_context_t *ctx = card->ctx;\n\tsize_t taglen, len = buflen;\n\tconst u8 *tag = NULL, *p = buf;\n\n\tsc_log(ctx, \"processing FCI bytes\");\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x83, &taglen);\n\tif (tag != NULL && taglen == 2) {\n\t\tfile->id = (tag[0] << 8) | tag[1];\n\t\tsc_log(ctx, \"  file identifier: 0x%02X%02X\", tag[0], tag[1]);\n\t}\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x80, &taglen);\n\tif (tag != NULL && taglen > 0 && taglen < 3) {\n\t\tfile->size = tag[0];\n\t\tif (taglen == 2)\n\t\t\tfile->size = (file->size << 8) + tag[1];\n\t\tsc_log(ctx, \"  bytes in file: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       file->size);\n\t}\n\n\tif (tag == NULL) {\n\t\ttag = sc_asn1_find_tag(ctx, p, len, 0x81, &taglen);\n\t\tif (tag != NULL && taglen >= 2) {\n\t\t\tint bytes = (tag[0] << 8) + tag[1];\n\n\t\t\tsc_log(ctx, \"  bytes in file: %d\", bytes);\n\t\t\tfile->size = bytes;\n\t\t}\n\t}\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x82, &taglen);\n\tif (tag != NULL) {\n\t\tif (taglen > 0) {\n\t\t\tunsigned char byte = tag[0];\n\t\t\tconst char *type;\n\n\t\t\tif (byte == 0x38) {\n\t\t\t\ttype = \"DF\";\n\t\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\t}\n\t\t\telse if (0x01 <= byte && byte <= 0x07) {\n\t\t\t\ttype = \"working EF\";\n\t\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\t\t\t\tswitch (byte) {\n\t\t\t\tcase 0x01:\n\t\t\t\t\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02:\n\t\t\t\t\tfile->ef_structure = SC_FILE_EF_LINEAR_FIXED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x04:\n\t\t\t\t\tfile->ef_structure = SC_FILE_EF_LINEAR_FIXED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x03:\n\t\t\t\tcase 0x05:\n\t\t\t\tcase 0x06:\n\t\t\t\tcase 0x07:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (0x10 == byte) {\n\t\t\t\ttype = \"BSO\";\n\t\t\t\tfile->type = SC_FILE_TYPE_BSO;\n\t\t\t}\n\t\t\telse if (0x11 <= byte) {\n\t\t\t\ttype = \"internal EF\";\n\t\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\t\t\t\tswitch (byte) {\n\t\t\t\tcase 0x11:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x12:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttype = \"unknown\";\n\t\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\n\t\t\t}\n\t\t\tsc_log(ctx, \"type %s, EF structure %d\", type, byte);\n\t\t}\n\t}\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x84, &taglen);\n\tif (tag != NULL && taglen > 0 && taglen <= 16) {\n\t\tmemcpy(file->name, tag, taglen);\n\t\tfile->namelen = taglen;\n\n\t\tsc_log_hex(ctx, \"File name\", file->name, file->namelen);\n\t\tif (!file->type)\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t}\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x85, &taglen);\n\tif (tag != NULL && taglen)\n\t\tsc_file_set_prop_attr(file, tag, taglen);\n\telse\n\t\tfile->prop_attr_len = 0;\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0xA5, &taglen);\n\tif (tag != NULL && taglen)\n\t\tsc_file_set_prop_attr(file, tag, taglen);\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x86, &taglen);\n\tif (tag != NULL && taglen)\n\t\tsc_file_set_sec_attr(file, tag, taglen);\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x8A, &taglen);\n\tif (tag != NULL && taglen == 1) {\n\t\tif (tag[0] == 0x01)\n\t\t\tfile->status = SC_FILE_STATUS_CREATION;\n\t\telse if (tag[0] == 0x07 || tag[0] == 0x05)\n\t\t\tfile->status = SC_FILE_STATUS_ACTIVATED;\n\t\telse if (tag[0] == 0x06 || tag[0] == 0x04)\n\t\t\tfile->status = SC_FILE_STATUS_INVALIDATED;\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\treturn 0;\n}\n\n\nstatic int\nepass2003_construct_fci(struct sc_card *card, const sc_file_t * file,\n\t\tu8 * out, size_t * outlen)\n{\n\tu8 *p = out;\n\tu8 buf[64];\n\tunsigned char ops[8] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\tint rv;\n\tunsigned ii;\n\n\tif (*outlen < 2)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\n\t*p++ = 0x62;\n\tp++;\n\tif (file->type == SC_FILE_TYPE_WORKING_EF) {\n\t\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT) {\n\t\t\tbuf[0] = (file->size >> 8) & 0xFF;\n\t\t\tbuf[1] = file->size & 0xFF;\n\t\t\tsc_asn1_put_tag(0x80, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t}\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tbuf[0] = 0x38;\n\t\tbuf[1] = 0x00;\n\t\tsc_asn1_put_tag(0x82, buf, 2, p, *outlen - (p - out), &p);\n\t}\n\telse if (file->type == SC_FILE_TYPE_WORKING_EF) {\n\t\tbuf[0] = file->ef_structure & 7;\n\t\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT) {\n\t\t\tbuf[1] = 0x00;\n\t\t\tsc_asn1_put_tag(0x82, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t\telse if (file->ef_structure == SC_FILE_EF_LINEAR_FIXED\n\t\t\t   || file->ef_structure == SC_FILE_EF_LINEAR_VARIABLE) {\n\t\t\tbuf[1] = 0x00;\n\t\t\tbuf[2] = 0x00;\n\t\t\tbuf[3] = 0x40;\t/* record length */\n\t\t\tbuf[4] = 0x00;\t/* record count */\n\t\t\tsc_asn1_put_tag(0x82, buf, 5, p, *outlen - (p - out), &p);\n\t\t}\n\t\telse {\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\n\t}\n\telse if (file->type == SC_FILE_TYPE_INTERNAL_EF) {\n\t\tif (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_CRT ||\n\t\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_CRT) {\n\t\t\tbuf[0] = 0x11;\n\t\t\tbuf[1] = 0x00;\n\t\t}\n\t\telse if (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC ||\n\t\t\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC) {\n\t\t\tbuf[0] = 0x12;\n\t\t\tbuf[1] = 0x00;\n\t\t}\n\t\telse {\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tsc_asn1_put_tag(0x82, buf, 2, p, *outlen - (p - out), &p);\n\t}\n\telse if (file->type == SC_FILE_TYPE_BSO) {\n\t\tbuf[0] = 0x10;\n\t\tbuf[1] = 0x00;\n\t\tsc_asn1_put_tag(0x82, buf, 2, p, *outlen - (p - out), &p);\n\t}\n\n\tbuf[0] = (file->id >> 8) & 0xFF;\n\tbuf[1] = file->id & 0xFF;\n\tsc_asn1_put_tag(0x83, buf, 2, p, *outlen - (p - out), &p);\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tif (file->namelen != 0) {\n\t\t\tsc_asn1_put_tag(0x84, file->name, file->namelen, p, *outlen - (p - out), &p);\n\t\t}\n\t\telse {\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t}\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tunsigned char data[2] = {0x00, 0x7F};\n\t\t/* 127 files at most */\n\t\tsc_asn1_put_tag(0x85, data, sizeof(data), p, *outlen - (p - out), &p);\n\t}\n\telse if (file->type == SC_FILE_TYPE_BSO) {\n\t\tbuf[0] = file->size & 0xff;\n\t\tsc_asn1_put_tag(0x85, buf, 1, p, *outlen - (p - out), &p);\n\t}\n\telse if (file->type == SC_FILE_TYPE_INTERNAL_EF) {\n\t\tif (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_CRT ||\n\t\t    file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC||\n\t\t    file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_CRT||\n\t\t    file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC) {\n\t\t\tbuf[0] = (file->size >> 8) & 0xFF;\n\t\t\tbuf[1] = file->size & 0xFF;\n\t\t\tsc_asn1_put_tag(0x85, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t}\n\tif (file->sec_attr_len) {\n\t\tmemcpy(buf, file->sec_attr, file->sec_attr_len);\n\t\tsc_asn1_put_tag(0x86, buf, file->sec_attr_len, p, *outlen - (p - out), &p);\n\t}\n\telse {\n\t\tsc_log(card->ctx, \"SC_FILE_ACL\");\n\t\tif (file->type == SC_FILE_TYPE_DF) {\n\t\t\tops[0] = SC_AC_OP_LIST_FILES;\n\t\t\tops[1] = SC_AC_OP_CREATE;\n\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t}\n\t\telse if (file->type == SC_FILE_TYPE_WORKING_EF) {\n\t\t\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT) {\n\t\t\t\tops[0] = SC_AC_OP_READ;\n\t\t\t\tops[1] = SC_AC_OP_UPDATE;\n\t\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t\t}\n\t\t\telse if (file->ef_structure == SC_FILE_EF_LINEAR_FIXED\n\t\t\t\t\t|| file->ef_structure == SC_FILE_EF_LINEAR_VARIABLE) {\n\t\t\t\tops[0] = SC_AC_OP_READ;\n\t\t\t\tops[1] = SC_AC_OP_UPDATE;\n\t\t\t\tops[2] = SC_AC_OP_WRITE;\n\t\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t\t}\n\t\t}\n\t\telse if (file->type == SC_FILE_TYPE_BSO) {\n\t\t\tops[0] = SC_AC_OP_UPDATE;\n\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t}\n\t\telse if (file->type == SC_FILE_TYPE_INTERNAL_EF) {\n\t\t\tif (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_CRT ||\n\t\t\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_CRT) {\n\t\t\t\tops[1] = SC_AC_OP_UPDATE;\n\t\t\t\tops[2] = SC_AC_OP_CRYPTO;\n\t\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t\t}\n\t\t\telse if (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC||\n\t\t\t\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC) {\n\t\t\t\tops[0] = SC_AC_OP_READ;\n\t\t\t\tops[1] = SC_AC_OP_UPDATE;\n\t\t\t\tops[2] = SC_AC_OP_CRYPTO;\n\t\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\n\t\tfor (ii = 0; ii < sizeof(ops); ii++) {\n\t\t\tconst struct sc_acl_entry *entry;\n\n\t\t\tbuf[ii] = 0xFF;\n\t\t\tif (ops[ii] == 0xFF)\n\t\t\t\tcontinue;\n\t\t\tentry = sc_file_get_acl_entry(file, ops[ii]);\n\n\t\t\trv = acl_to_ac_byte(card, entry);\n\t\t\tLOG_TEST_RET(card->ctx, rv, \"Invalid ACL\");\n\n\t\t\tbuf[ii] = rv;\n\t\t}\n\t\tsc_asn1_put_tag(0x86, buf, sizeof(ops), p, *outlen - (p - out), &p);\n\t\tif(file->size == 256)\t\n\t\t{\n\t\t\tout[4]= 0x13;\n\t\t}\n\n\t}\n\n\t/* VT ??? */\n\tif (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC||\n\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC) {\n\t\tunsigned char data[2] = {0x00, 0x66};\n\t\tsc_asn1_put_tag(0x87, data, sizeof(data), p, *outlen - (p - out), &p);\n\t\tif(file->size == 256)\t\n\t\t{\n\t\t\tout[4]= 0x14;\n\t\t}\n\t}\n\n\tout[1] = p - out - 2;\n\n\t*outlen = p - out;\n\treturn 0;\n}\n\n\nstatic int\nepass2003_create_file(struct sc_card *card, sc_file_t * file)\n{\n\tint r;\n\tsize_t len;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tstruct sc_apdu apdu;\n\n\tlen = SC_MAX_APDU_BUFFER_SIZE;\n\n\tepass2003_hook_file(file, 1);\n\n\tif (card->ops->construct_fci == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tr = epass2003_construct_fci(card, file, sbuf, &len);\n\tLOG_TEST_RET(card->ctx, r, \"construct_fci() failed\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x00, 0x00);\n\tapdu.lc = len;\n\tapdu.datalen = len;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"APDU sw1/2 wrong\");\n\n\tepass2003_hook_file(file, 0);\n\treturn r;\n}\n\n\nstatic int\nepass2003_delete_file(struct sc_card *card, const sc_path_t * path)\n{\n\tint r;\n\tu8 sbuf[2];\n\tstruct sc_apdu apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_select_file(card, path, NULL);\n\tepass2003_hook_path((struct sc_path *)path, 1);\n\tif (r == SC_SUCCESS) {\n\t\tsbuf[0] = path->value[path->len - 2];\n\t\tsbuf[1] = path->value[path->len - 1];\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE4, 0x00, 0x00);\n\t\tapdu.lc = 2;\n\t\tapdu.datalen = 2;\n\t\tapdu.data = sbuf;\n\t}\n\telse   {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Delete file failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int\nepass2003_list_files(struct sc_card *card, unsigned char *buf, size_t buflen)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x34, 0x00, 0x00);\n\tapdu.cla = 0x80;\n\tapdu.le = 0;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.resp = rbuf;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Card returned error\");\n\n\tif (apdu.resplen == 0x100 && rbuf[0] == 0 && rbuf[1] == 0)\n\t\tLOG_FUNC_RETURN(card->ctx, 0);\n\n\tbuflen = buflen < apdu.resplen ? buflen : apdu.resplen;\n\tmemcpy(buf, rbuf, buflen);\n\n\tLOG_FUNC_RETURN(card->ctx, buflen);\n}\n\n\nstatic int\ninternal_write_rsa_key_factor(struct sc_card *card, unsigned short fid, u8 factor,\n\t\tsc_pkcs15_bignum_t data)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tu8 sbuff[SC_MAX_EXT_APDU_BUFFER_SIZE] = { 0 };\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsbuff[0] = ((fid & 0xff00) >> 8);\n\tsbuff[1] = (fid & 0x00ff);\n\tmemcpy(&sbuff[2], data.data, data.len);\n//\tsc_mem_reverse(&sbuff[2], data.len);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3, 0xe7, factor, 0x00);\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = 2 + data.len;\n\tapdu.data = sbuff;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Write rsa key factor failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\ninternal_write_rsa_key(struct sc_card *card, unsigned short fid, struct sc_pkcs15_prkey_rsa *rsa)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = internal_write_rsa_key_factor(card, fid, 0x02, rsa->modulus);\n\tLOG_TEST_RET(card->ctx, r, \"write n failed\");\n\tr = internal_write_rsa_key_factor(card, fid, 0x03, rsa->d);\n\tLOG_TEST_RET(card->ctx, r, \"write d failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nhash_data(const unsigned char *data, size_t datalen, unsigned char *hash, unsigned int mechanismType)\n{\n\n\tif ((NULL == data) || (NULL == hash))\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tif(mechanismType & SC_ALGORITHM_ECDSA_HASH_SHA1)\n\t{\n\t\tunsigned char data_hash[24] = { 0 };\n\t\tsize_t len = 0;\n\n\t\tsha1_digest(data, datalen, data_hash);\n\t\tlen = REVERSE_ORDER4(datalen);\n\t\tmemcpy(&data_hash[20], &len, 4);\n\t\tmemcpy(hash, data_hash, 24);\n\t}\n\telse if(mechanismType & SC_ALGORITHM_ECDSA_HASH_SHA256)\n\t{\n\t\tunsigned char data_hash[36] = { 0 };\n\t\tsize_t len = 0;\n\n\t\tsha256_digest(data, datalen, data_hash);\n\t\tlen = REVERSE_ORDER4(datalen);\n\t\tmemcpy(&data_hash[32], &len, 4);\n\t\tmemcpy(hash, data_hash, 36);\n\t}\n\telse\n\t{\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\n\nstatic int\ninstall_secret_key(struct sc_card *card, unsigned char ktype, unsigned char kid,\n\t\tunsigned char useac, unsigned char modifyac, unsigned char EC,\n\t\tunsigned char *data, unsigned long dataLen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char isapp = 0x00;\t/* appendable */\n\tunsigned char tmp_data[256] = { 0 };\n\n\ttmp_data[0] = ktype;\n\ttmp_data[1] = kid;\n\ttmp_data[2] = useac;\n\ttmp_data[3] = modifyac;\n\ttmp_data[8] = 0xFF;\n\n\tif (0x04 == ktype || 0x06 == ktype) {\n\t\ttmp_data[4] = EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_SO;\n\t\ttmp_data[5] = EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_SO;\n\t\ttmp_data[7] = (kid == PIN_ID[0] ? EPASS2003_AC_USER : EPASS2003_AC_SO);\n\t\ttmp_data[9] = (EC << 4) | EC;\n\t}\n\n\tmemcpy(&tmp_data[10], data, dataLen);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xe3, isapp, 0x00);\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = 10 + dataLen;\n\tapdu.data = tmp_data;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU install_secret_key failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"install_secret_key failed\");\n\n\treturn r;\n}\n\n\nstatic int\ninternal_install_pre(struct sc_card *card)\n{\n\tint r;\n\t/* init key for enc */\n\tr = install_secret_key(card, 0x01, 0x00,\n\t\t\t       EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE,\n\t\t\t       EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE,\n\t\t\t       0, g_init_key_enc, 16);\n\tLOG_TEST_RET(card->ctx, r, \"Install init key failed\");\n\n\t/* init key for mac */\n\tr = install_secret_key(card, 0x02, 0x00,\n\t\t\t       EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE,\n\t\t\t       EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE,\n\t\t\t       0, g_init_key_mac, 16);\n\tLOG_TEST_RET(card->ctx, r, \"Install init key failed\");\n\n\treturn r;\n}\n\n\n/* use external auth secret as pin */\nstatic int\ninternal_install_pin(struct sc_card *card, sc_epass2003_wkey_data * pin)\n{\n\tint r;\n\tunsigned char hash[HASH_LEN] = { 0 };\n\n\tr = hash_data(pin->key_data.es_secret.key_val, pin->key_data.es_secret.key_len, hash, SC_ALGORITHM_ECDSA_HASH_SHA1);\n\tLOG_TEST_RET(card->ctx, r, \"hash data failed\");\n\n\tr = install_secret_key(card, 0x04, pin->key_data.es_secret.kid,\n\t\t\t       pin->key_data.es_secret.ac[0],\n\t\t\t       pin->key_data.es_secret.ac[1],\n\t\t\t       pin->key_data.es_secret.EC, hash, HASH_LEN);\n\tLOG_TEST_RET(card->ctx, r, \"Install failed\");\n\n\treturn r;\n}\n\n\nstatic int\nepass2003_write_key(struct sc_card *card, sc_epass2003_wkey_data * data)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (data->type & SC_EPASS2003_KEY) {\n\t\tif (data->type == SC_EPASS2003_KEY_RSA)\n\t\t\treturn internal_write_rsa_key(card, data->key_data.es_key.fid,\n\t\t\t\t\t\t      data->key_data.es_key.rsa);\n\t\telse\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t} else if (data->type & SC_EPASS2003_SECRET) {\n\t\tif (data->type == SC_EPASS2003_SECRET_PRE)\n\t\t\treturn internal_install_pre(card);\n\t\telse if (data->type == SC_EPASS2003_SECRET_PIN)\n\t\t\treturn internal_install_pin(card, data);\n\t\telse\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\telse {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_gen_key(struct sc_card *card, sc_epass2003_gen_key_data * data)\n{\n\tint r;\n\tsize_t len = data->key_length;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_EXT_APDU_BUFFER_SIZE] = { 0 };\n\tu8 sbuf[SC_MAX_EXT_APDU_BUFFER_SIZE] = { 0 };\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif(len == 256)\n\t{\n\t\tsbuf[0] = 0x02;\n\t}\n\telse\n\t{\n\t\tsbuf[0] = 0x01;\n\t}\n\tsbuf[1] = (u8) ((len >> 8) & 0xff);\n\tsbuf[2] = (u8) (len & 0xff);\n\tsbuf[3] = (u8) ((data->prkey_id >> 8) & 0xFF);\n\tsbuf[4] = (u8) ((data->prkey_id) & 0xFF);\n\tsbuf[5] = (u8) ((data->pukey_id >> 8) & 0xFF);\n\tsbuf[6] = (u8) ((data->pukey_id) & 0xFF);\n\n\t/* generate key */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n\tapdu.lc = apdu.datalen = 7;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"generate keypair failed\");\n\n\t/* read public key */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xb4, 0x02, 0x00);\n\tif(len == 256)\n\t{\n\t\tapdu.p1 = 0x00;\n\t}\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = 2;\n\tapdu.data = &sbuf[5];\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0x00;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"get pukey failed\");\n\n\tif (len < apdu.resplen)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tdata->modulus = (u8 *) malloc(len);\n\tif (!data->modulus)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(data->modulus, rbuf, len);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_erase_card(struct sc_card *card)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_invalidate_cache(card);\n\n\tr = sc_delete_file(card, sc_get_mf_path());\n\tLOG_TEST_RET(card->ctx, r, \"delete MF failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\nstatic int\nepass2003_get_serialnr(struct sc_card *card, sc_serial_number_t * serial)\n{\n\tu8 rbuf[8];\n\tsize_t rbuf_len = sizeof(rbuf);\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (SC_SUCCESS != get_data(card, 0x80, rbuf, rbuf_len))\n\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\n\tcard->serialnr.len = serial->len = 8;\n\tmemcpy(card->serialnr.value, rbuf, 8);\n\tmemcpy(serial->value, rbuf, 8);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_card_ctl(struct sc_card *card, unsigned long cmd, void *ptr)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_log(card->ctx, \"cmd is %0lx\", cmd);\n\tswitch (cmd) {\n\tcase SC_CARDCTL_ENTERSAFE_WRITE_KEY:\n\t\treturn epass2003_write_key(card, (sc_epass2003_wkey_data *) ptr);\n\tcase SC_CARDCTL_ENTERSAFE_GENERATE_KEY:\n\t\treturn epass2003_gen_key(card, (sc_epass2003_gen_key_data *) ptr);\n\tcase SC_CARDCTL_ERASE_CARD:\n\t\treturn epass2003_erase_card(card);\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\treturn epass2003_get_serialnr(card, (sc_serial_number_t *) ptr);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n}\n\n\nstatic void\ninternal_sanitize_pin_info(struct sc_pin_cmd_pin *pin, unsigned int num)\n{\n\tpin->encoding = SC_PIN_ENCODING_ASCII;\n\tpin->min_length = 4;\n\tpin->max_length = 16;\n\tpin->pad_length = 16;\n\tpin->offset = 5 + num * 16;\n\tpin->pad_char = 0x00;\n}\n\n\nstatic int\nget_external_key_maxtries(struct sc_card *card, unsigned char *maxtries)\n{\n\tunsigned char maxcounter[2] = { 0 };\n\tstatic const sc_path_t file_path = {\n\t\t{0x3f, 0x00, 0x50, 0x15, 0x9f, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 6,\n\t\t0,\n\t\t0,\n\t\tSC_PATH_TYPE_PATH,\n\t\t{{0}, 0}\n\t};\n\tint ret;\n\n\tret = sc_select_file(card, &file_path, NULL);\n\tLOG_TEST_RET(card->ctx, ret, \"select max counter file failed\");\n\n\tret = sc_read_binary(card, 0, maxcounter, 2, 0);\n\tLOG_TEST_RET(card->ctx, ret, \"read max counter file failed\");\n\n\t*maxtries = maxcounter[0];\n\treturn SC_SUCCESS;\n}\n\n\nstatic int\nget_external_key_retries(struct sc_card *card, unsigned char kid, unsigned char *retries)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char random[16] = { 0 };\n\n\tr = sc_get_challenge(card, random, 8);\n\tLOG_TEST_RET(card->ctx, r, \"get challenge get_external_key_retries failed\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x82, 0x01, 0x80 | kid);\n\tapdu.resp = NULL;\n\tapdu.resplen = 0;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU get_external_key_retries failed\");\n\n\tif (retries && ((0x63 == (apdu.sw1 & 0xff)) && (0xC0 == (apdu.sw2 & 0xf0)))) {\n\t\t*retries = (apdu.sw2 & 0x0f);\n\t\tr = SC_SUCCESS;\n\t}\n\telse {\n\t\tLOG_TEST_RET(card->ctx, r, \"get_external_key_retries failed\");\n\t\tr = SC_ERROR_CARD_CMD_FAILED;\n\t}\n\n\treturn r;\n}\n\nstatic int \nepass2003_get_challenge(sc_card_t *card, u8 *rnd, size_t len)\n{\n\tu8 rbuf[16];\n\tsize_t out_len;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = iso_ops->get_challenge(card, rbuf, sizeof rbuf);\n\tLOG_TEST_RET(card->ctx, r, \"GET CHALLENGE cmd failed\");\n\n\tif (len < (size_t) r) {\n\t\tout_len = len;\n\t} else {\n\t\tout_len = (size_t) r;\n\t}\n\tmemcpy(rnd, rbuf, out_len);\n\n\tLOG_FUNC_RETURN(card->ctx, (int) out_len);\n}\n\n\nstatic int\nexternal_key_auth(struct sc_card *card, unsigned char kid,\n\t\tunsigned char *data, size_t datalen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char random[16] = { 0 };\n\tunsigned char tmp_data[16] = { 0 };\n\tunsigned char hash[HASH_LEN] = { 0 };\n\tunsigned char iv[16] = { 0 };\n\n\tr = sc_get_challenge(card, random, 8);\n\tLOG_TEST_RET(card->ctx, r, \"get challenge external_key_auth failed\");\n\n\tr = hash_data(data, datalen, hash, SC_ALGORITHM_ECDSA_HASH_SHA1);\n\tLOG_TEST_RET(card->ctx, r, \"hash data failed\");\n\n\tdes3_encrypt_cbc(hash, HASH_LEN, iv, random, 8, tmp_data);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x82, 0x01, 0x80 | kid);\n\tapdu.lc = apdu.datalen = 8;\n\tapdu.data = tmp_data;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU external_key_auth failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"external_key_auth failed\");\n\n\treturn r;\n}\n\n\nstatic int\nupdate_secret_key(struct sc_card *card, unsigned char ktype, unsigned char kid,\n\t\tconst unsigned char *data, unsigned long datalen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char hash[HASH_LEN] = { 0 };\n\tunsigned char tmp_data[256] = { 0 };\n\tunsigned char maxtries = 0;\n\n\tr = hash_data(data, datalen, hash, SC_ALGORITHM_ECDSA_HASH_SHA1);\n\tLOG_TEST_RET(card->ctx, r, \"hash data failed\");\n\n\tr = get_external_key_maxtries(card, &maxtries);\n\tLOG_TEST_RET(card->ctx, r, \"get max counter failed\");\n\n\ttmp_data[0] = (maxtries << 4) | maxtries;\n\tmemcpy(&tmp_data[1], hash, HASH_LEN);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xe5, ktype, kid);\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = 1 + HASH_LEN;\n\tapdu.data = tmp_data;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU update_secret_key failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"update_secret_key failed\");\n\n\treturn r;\n}\n\n/* use external auth secret as pin */\nstatic int\nepass2003_pin_cmd(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tint r;\n\tu8 kid;\n\tu8 retries = 0;\n\tu8 pin_low = 3;\n\tunsigned char maxtries = 0;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tinternal_sanitize_pin_info(&data->pin1, 0);\n\tinternal_sanitize_pin_info(&data->pin2, 1);\n\tdata->flags |= SC_PIN_CMD_NEED_PADDING;\n\tkid = data->pin_reference;\n\t/* get pin retries */\n\tif (data->cmd == SC_PIN_CMD_GET_INFO) {\n\n\t\tr = get_external_key_retries(card, 0x80 | kid, &retries);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tdata->pin1.tries_left = retries;\n\t\t\tif (tries_left)\n\t\t\t\t*tries_left = retries;\n\n\t\t\tr = get_external_key_maxtries(card, &maxtries);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"get max counter failed\");\n\n\t\t\tdata->pin1.max_tries = maxtries;\n\t\t}\n//remove below code, because the old implement only return PIN retries, now modify the code and return PIN status\n//\t\treturn r;\n\t}\n\telse if (data->cmd == SC_PIN_CMD_UNBLOCK) { /* verify */\n\t\tr = external_key_auth(card, (kid + 1), (unsigned char *)data->pin1.data,\n\t\t\t\tdata->pin1.len);\n\t\tLOG_TEST_RET(card->ctx, r, \"verify pin failed\");\n\t}\n\telse if (data->cmd == SC_PIN_CMD_CHANGE || data->cmd == SC_PIN_CMD_UNBLOCK) { /* change */\n\t\tr = update_secret_key(card, 0x04, kid, data->pin2.data,\n\t\t\t\t(unsigned long)data->pin2.len);\n\t\tLOG_TEST_RET(card->ctx, r, \"verify pin failed\");\n\t}\n\telse {\n\t\tr = external_key_auth(card, kid, (unsigned char *)data->pin1.data,\n\t\t\t\tdata->pin1.len);\n\t\tget_external_key_retries(card, 0x80 | kid, &retries);\n\t\tif (retries < pin_low)\n\t\t\tsc_log(card->ctx, \"Verification failed (remaining tries: %d)\", retries);\n\n\t}\n\tLOG_TEST_RET(card->ctx, r, \"verify pin failed\");\n\n\tif (r == SC_SUCCESS)\n\t{\n\t\tdata->pin1.logged_in = SC_PIN_STATE_LOGGED_IN;\n\t}\n\n\treturn r;\n}\n\nstatic struct sc_card_driver *sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\n\tepass2003_ops = *iso_ops;\n\n\tepass2003_ops.match_card = epass2003_match_card;\n\tepass2003_ops.init = epass2003_init;\n\tepass2003_ops.finish = epass2003_finish;\n\tepass2003_ops.write_binary = NULL;\n\tepass2003_ops.write_record = NULL;\n\tepass2003_ops.select_file = epass2003_select_file;\n\tepass2003_ops.get_response = NULL;\n\tepass2003_ops.restore_security_env = epass2003_restore_security_env;\n\tepass2003_ops.set_security_env = epass2003_set_security_env;\n\tepass2003_ops.decipher = epass2003_decipher;\n\tepass2003_ops.compute_signature = epass2003_decipher;\n\tepass2003_ops.create_file = epass2003_create_file;\n\tepass2003_ops.delete_file = epass2003_delete_file;\n\tepass2003_ops.list_files = epass2003_list_files;\n\tepass2003_ops.card_ctl = epass2003_card_ctl;\n\tepass2003_ops.process_fci = epass2003_process_fci;\n\tepass2003_ops.construct_fci = epass2003_construct_fci;\n\tepass2003_ops.pin_cmd = epass2003_pin_cmd;\n\tepass2003_ops.check_sw = epass2003_check_sw;\n\tepass2003_ops.get_challenge = epass2003_get_challenge;\n\treturn &epass2003_drv;\n}\n\nstruct sc_card_driver *sc_get_epass2003_driver(void)\n{\n\treturn sc_get_driver();\n}\n#endif\t/* #ifdef ENABLE_OPENSSL */\n#endif\t/* #ifdef ENABLE_SM */\n", "/*\n * card-muscle.c: Support for MuscleCard Applet from musclecard.com\n *\n * Copyright (C) 2006, Identity Alliance, Thomas Harning <support@identityalliance.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"internal.h\"\n#include \"cardctl.h\"\n#include \"muscle.h\"\n#include \"muscle-filesystem.h\"\n#include \"types.h\"\n#include \"opensc.h\"\n\nstatic struct sc_card_operations muscle_ops;\nstatic const struct sc_card_operations *iso_ops = NULL;\n\nstatic struct sc_card_driver muscle_drv = {\n\t\"MuscleApplet\",\n\t\"muscle\",\n\t&muscle_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_atr_table muscle_atrs[] = {\n\t/* Tyfone JCOP 242R2 cards */\n\t{ \"3b:6d:00:00:ff:54:79:66:6f:6e:65:20:32:34:32:52:32\", NULL, NULL, SC_CARD_TYPE_MUSCLE_JCOP242R2_NO_EXT_APDU, 0, NULL },\n\t/* Aladdin eToken PRO USB 72K Java */\n\t{ \"3b:d5:18:00:81:31:3a:7d:80:73:c8:21:10:30\", NULL, NULL, SC_CARD_TYPE_MUSCLE_ETOKEN_72K, 0, NULL },\n\t/* JCOP31 v2.4.1 contact interface */\n\t{ \"3b:f8:13:00:00:81:31:fe:45:4a:43:4f:50:76:32:34:31:b7\", NULL, NULL, SC_CARD_TYPE_MUSCLE_JCOP241, 0, NULL },\n\t/* JCOP31 v2.4.1 RF interface */\n\t{ \"3b:88:80:01:4a:43:4f:50:76:32:34:31:5e\", NULL, NULL, SC_CARD_TYPE_MUSCLE_JCOP241, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n\n#define MUSCLE_DATA(card) ( (muscle_private_t*)card->drv_data )\n#define MUSCLE_FS(card) ( ((muscle_private_t*)card->drv_data)->fs )\ntypedef struct muscle_private {\n\tsc_security_env_t env;\n\tunsigned short verifiedPins;\n\tmscfs_t *fs;\n\tint rsa_key_ref;\n\n} muscle_private_t;\n\nstatic int muscle_finish(sc_card_t *card)\n{\n\tmuscle_private_t *priv = MUSCLE_DATA(card);\n\tmscfs_free(priv->fs);\n\tfree(priv);\n\treturn 0;\n}\n\n\nstatic u8 muscleAppletId[] = { 0xA0, 0x00,0x00,0x00, 0x01, 0x01 };\n\nstatic int muscle_match_card(sc_card_t *card)\n{\n\tsc_apdu_t apdu;\n\tu8 response[64];\n\tint r;\n\n\t/* Since we send an APDU, the card's logout function may be called...\n\t * however it's not always properly nulled out... */\n\tcard->ops->logout = NULL;\n\n\tif (msc_select_applet(card, muscleAppletId, sizeof muscleAppletId) == 1) {\n\t\t/* Muscle applet is present, check the protocol version to be sure */\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2, 0x3C, 0x00, 0x00);\n\t\tapdu.cla = 0xB0;\n\t\tapdu.le = 64;\n\t\tapdu.resplen = 64;\n\t\tapdu.resp = response;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r == SC_SUCCESS && response[0] == 0x01) {\n\t\t\tcard->type = SC_CARD_TYPE_MUSCLE_V1;\n\t\t} else {\n\t\t\tcard->type = SC_CARD_TYPE_MUSCLE_GENERIC;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Since Musclecard has a different ACL system then PKCS15\n * objects need to have their READ/UPDATE/DELETE permissions mapped for files\n * and directory ACLS need to be set\n * For keys.. they have different ACLS, but are accessed in different locations, so it shouldn't be an issue here\n */\nstatic unsigned short muscle_parse_singleAcl(const sc_acl_entry_t* acl)\n{\n\tunsigned short acl_entry = 0;\n\twhile(acl) {\n\t\tint key = acl->key_ref;\n\t\tint method = acl->method;\n\t\tswitch(method) {\n\t\tcase SC_AC_NEVER:\n\t\t\treturn 0xFFFF;\n\t\t/* Ignore... other items overwrite these */\n\t\tcase SC_AC_NONE:\n\t\tcase SC_AC_UNKNOWN:\n\t\t\tbreak;\n\t\tcase SC_AC_CHV:\n\t\t\tacl_entry |= (1 << key); /* Assuming key 0 == SO */\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tdefault:\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\t}\n\t\tacl = acl->next;\n\t}\n\treturn acl_entry;\n}\n\nstatic void muscle_parse_acls(const sc_file_t* file, unsigned short* read_perm, unsigned short* write_perm, unsigned short* delete_perm)\n{\n\tassert(read_perm && write_perm && delete_perm);\n\t*read_perm =  muscle_parse_singleAcl(sc_file_get_acl_entry(file, SC_AC_OP_READ));\n\t*write_perm =  muscle_parse_singleAcl(sc_file_get_acl_entry(file, SC_AC_OP_UPDATE));\n\t*delete_perm =  muscle_parse_singleAcl(sc_file_get_acl_entry(file, SC_AC_OP_DELETE));\n}\n\nstatic int muscle_create_directory(sc_card_t *card, sc_file_t *file)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmsc_id objectId;\n\tu8* oid = objectId.id;\n\tunsigned id = file->id;\n\tunsigned short read_perm = 0, write_perm = 0, delete_perm = 0;\n\tint objectSize;\n\tint r;\n\tif(id == 0) /* No null name files */\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\t/* No nesting directories */\n\tif(fs->currentPath[0] != 0x3F || fs->currentPath[1] != 0x00)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\toid[0] = ((id & 0xFF00) >> 8) & 0xFF;\n\toid[1] = id & 0xFF;\n\toid[2] = oid[3] = 0;\n\n\tobjectSize = file->size;\n\n\tmuscle_parse_acls(file, &read_perm, &write_perm, &delete_perm);\n\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);\n\tmscfs_clear_cache(fs);\n\tif(r >= 0) return 0;\n\treturn r;\n}\n\n\nstatic int muscle_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tint objectSize = file->size;\n\tunsigned short read_perm = 0, write_perm = 0, delete_perm = 0;\n\tmsc_id objectId;\n\tint r;\n\tif(file->type == SC_FILE_TYPE_DF)\n\t\treturn muscle_create_directory(card, file);\n\tif(file->type != SC_FILE_TYPE_WORKING_EF)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\tif(file->id == 0) /* No null name files */\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tmuscle_parse_acls(file, &read_perm, &write_perm, &delete_perm);\n\n\tmscfs_lookup_local(fs, file->id, &objectId);\n\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);\n\tmscfs_clear_cache(fs);\n\tif(r >= 0) return 0;\n\treturn r;\n}\n\nstatic int muscle_read_binary(sc_card_t *card, unsigned int idx, u8* buf, size_t count, unsigned long flags)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tint r;\n\tmsc_id objectId;\n\tu8* oid = objectId.id;\n\tmscfs_file_t *file;\n\n\tr = mscfs_check_selection(fs, -1);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n\tfile = &fs->cache.array[fs->currentFileIndex];\n\tobjectId = file->objectId;\n\t/* memcpy(objectId.id, file->objectId.id, 4); */\n\tif(!file->ef) {\n\t\toid[0] = oid[2];\n\t\toid[1] = oid[3];\n\t\toid[2] = oid[3] = 0;\n\t}\n\tr = msc_read_object(card, objectId, idx, buf, count);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\nstatic int muscle_update_binary(sc_card_t *card, unsigned int idx, const u8* buf, size_t count, unsigned long flags)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tint r;\n\tmscfs_file_t *file;\n\tmsc_id objectId;\n\tu8* oid = objectId.id;\n\n\tr = mscfs_check_selection(fs, -1);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n\tfile = &fs->cache.array[fs->currentFileIndex];\n\n\tobjectId = file->objectId;\n\t/* memcpy(objectId.id, file->objectId.id, 4); */\n\tif(!file->ef) {\n\t\toid[0] = oid[2];\n\t\toid[1] = oid[3];\n\t\toid[2] = oid[3] = 0;\n\t}\n\tif(file->size < idx + count) {\n\t\tint newFileSize = idx + count;\n\t\tu8* buffer = malloc(newFileSize);\n\t\tif(buffer == NULL) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\n\t\tr = msc_read_object(card, objectId, 0, buffer, file->size);\n\t\t/* TODO: RETRIEVE ACLS */\n\t\tif(r < 0) goto update_bin_free_buffer;\n\t\tr = msc_delete_object(card, objectId, 0);\n\t\tif(r < 0) goto update_bin_free_buffer;\n\t\tr = msc_create_object(card, objectId, newFileSize, 0,0,0);\n\t\tif(r < 0) goto update_bin_free_buffer;\n\t\tmemcpy(buffer + idx, buf, count);\n\t\tr = msc_update_object(card, objectId, 0, buffer, newFileSize);\n\t\tif(r < 0) goto update_bin_free_buffer;\n\t\tfile->size = newFileSize;\nupdate_bin_free_buffer:\n\t\tfree(buffer);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n\t} else {\n\t\tr = msc_update_object(card, objectId, idx, buf, count);\n\t}\n\t/* mscfs_clear_cache(fs); */\n\treturn r;\n}\n\n/* TODO: Evaluate correctness */\nstatic int muscle_delete_mscfs_file(sc_card_t *card, mscfs_file_t *file_data)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmsc_id id = file_data->objectId;\n\tu8* oid = id.id;\n\tint r;\n\n\tif(!file_data->ef) {\n\t\tint x;\n\t\tmscfs_file_t *childFile;\n\t\t/* Delete children */\n\t\tmscfs_check_cache(fs);\n\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"DELETING Children of: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tfor(x = 0; x < fs->cache.size; x++) {\n\t\t\tmsc_id objectId;\n\t\t\tchildFile = &fs->cache.array[x];\n\t\t\tobjectId = childFile->objectId;\n\n\t\t\tif(0 == memcmp(oid + 2, objectId.id, 2)) {\n\t\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\t\t\"DELETING: %02X%02X%02X%02X\\n\",\n\t\t\t\t\tobjectId.id[0],objectId.id[1],\n\t\t\t\t\tobjectId.id[2],objectId.id[3]);\n\t\t\t\tr = muscle_delete_mscfs_file(card, childFile);\n\t\t\t\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\t\t\t}\n\t\t}\n\t\toid[0] = oid[2];\n\t\toid[1] = oid[3];\n\t\toid[2] = oid[3] = 0;\n\t\t/* ??? objectId = objectId >> 16; */\n\t}\n\tif((0 == memcmp(oid, \"\\x3F\\x00\\x00\\x00\", 4))\n\t\t|| (0 == memcmp(oid, \"\\x3F\\x00\\x3F\\x00\", 4))) {\n\t}\n\tr = msc_delete_object(card, id, 1);\n\t/* Check if its the root... this file generally is virtual\n\t * So don't return an error if it fails */\n\tif((0 == memcmp(oid, \"\\x3F\\x00\\x00\\x00\", 4))\n\t\t|| (0 == memcmp(oid, \"\\x3F\\x00\\x3F\\x00\", 4)))\n\t\treturn 0;\n\n\tif(r < 0) {\n\t\tprintf(\"ID: %02X%02X%02X%02X\\n\",\n\t\t\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\t}\n\treturn 0;\n}\n\nstatic int muscle_delete_file(sc_card_t *card, const sc_path_t *path_in)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint r = 0;\n\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, NULL);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\tr = muscle_delete_mscfs_file(card, file_data);\n\tmscfs_clear_cache(fs);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\treturn 0;\n}\n\nstatic void muscle_load_single_acl(sc_file_t* file, int operation, unsigned short acl)\n{\n\tint key;\n\t/* Everybody by default.... */\n\tsc_file_add_acl_entry(file, operation, SC_AC_NONE, 0);\n\tif(acl == 0xFFFF) {\n\t\tsc_file_add_acl_entry(file, operation, SC_AC_NEVER, 0);\n\t\treturn;\n\t}\n\tfor(key = 0; key < 16; key++) {\n\t\tif(acl >> key & 1) {\n\t\t\tsc_file_add_acl_entry(file, operation, SC_AC_CHV, key);\n\t\t}\n\t}\n}\nstatic void muscle_load_file_acls(sc_file_t* file, mscfs_file_t *file_data)\n{\n\tmuscle_load_single_acl(file, SC_AC_OP_READ, file_data->read);\n\tmuscle_load_single_acl(file, SC_AC_OP_WRITE, file_data->write);\n\tmuscle_load_single_acl(file, SC_AC_OP_UPDATE, file_data->write);\n\tmuscle_load_single_acl(file, SC_AC_OP_DELETE, file_data->delete);\n}\nstatic void muscle_load_dir_acls(sc_file_t* file, mscfs_file_t *file_data)\n{\n\tmuscle_load_single_acl(file, SC_AC_OP_SELECT, 0);\n\tmuscle_load_single_acl(file, SC_AC_OP_LIST_FILES, 0);\n\tmuscle_load_single_acl(file, SC_AC_OP_LOCK, 0xFFFF);\n\tmuscle_load_single_acl(file, SC_AC_OP_DELETE, file_data->delete);\n\tmuscle_load_single_acl(file, SC_AC_OP_CREATE, file_data->write);\n}\n\n/* Required type = -1 for don't care, 1 for EF, 0 for DF */\nstatic int select_item(sc_card_t *card, const sc_path_t *path_in, sc_file_t ** file_out, int requiredType)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint pathlen = path_in->len;\n\tint r = 0;\n\tint objectIndex;\n\tu8* oid;\n\n\tmscfs_check_cache(fs);\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, &objectIndex);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\n\t/* Check if its the right type */\n\tif(requiredType >= 0 && requiredType != file_data->ef) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\toid = file_data->objectId.id;\n\t/* Is it a file or directory */\n\tif(file_data->ef) {\n\t\tfs->currentPath[0] = oid[0];\n\t\tfs->currentPath[1] = oid[1];\n\t\tfs->currentFile[0] = oid[2];\n\t\tfs->currentFile[1] = oid[3];\n\t} else {\n\t\tfs->currentPath[0] = oid[pathlen - 2];\n\t\tfs->currentPath[1] = oid[pathlen - 1];\n\t\tfs->currentFile[0] = 0;\n\t\tfs->currentFile[1] = 0;\n\t}\n\n\tfs->currentFileIndex = objectIndex;\n\tif(file_out) {\n\t\tsc_file_t *file;\n\t\tfile = sc_file_new();\n\t\tfile->path = *path_in;\n\t\tfile->size = file_data->size;\n\t\tfile->id = (oid[2] << 8) | oid[3];\n\t\tif(!file_data->ef) {\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t} else {\n\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\t\t\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\t\t}\n\n\t\t/* Setup ACLS */\n\t\tif(file_data->ef) {\n\t\t\tmuscle_load_file_acls(file, file_data);\n\t\t} else {\n\t\t\tmuscle_load_dir_acls(file, file_data);\n\t\t\t/* Setup directory acls... */\n\t\t}\n\n\t\tfile->magic = SC_FILE_MAGIC;\n\t\t*file_out = file;\n\t}\n\treturn 0;\n}\n\nstatic int muscle_select_file(sc_card_t *card, const sc_path_t *path_in,\n\t\t\t     sc_file_t **file_out)\n{\n\tint r;\n\n\tassert(card != NULL && path_in != NULL);\n\n\tswitch (path_in->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tr = select_item(card, path_in, file_out, 1);\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tr = select_item(card, path_in, file_out, 0);\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tr = select_item(card, path_in, file_out, -1);\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif(r > 0) r = 0;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n}\n\nstatic int _listFile(mscfs_file_t *file, int reset, void *udata)\n{\n\tint next = reset ? 0x00 : 0x01;\n\treturn msc_list_objects( (sc_card_t*)udata, next, file);\n}\n\nstatic int muscle_init(sc_card_t *card)\n{\n\tmuscle_private_t *priv;\n\n\tcard->name = \"MuscleApplet\";\n\tcard->drv_data = malloc(sizeof(muscle_private_t));\n\tif(!card->drv_data) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tmemset(card->drv_data, 0, sizeof(muscle_private_t));\n\tpriv = MUSCLE_DATA(card);\n\tpriv->verifiedPins = 0;\n\tpriv->fs = mscfs_new();\n\tif(!priv->fs) {\n\t\tfree(card->drv_data);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tpriv->fs->udata = card;\n\tpriv->fs->listFile = _listFile;\n\n\tcard->cla = 0xB0;\n\n\tcard->flags |= SC_CARD_FLAG_RNG;\n\tcard->caps |= SC_CARD_CAP_RNG;\n\n\t/* Card type detection */\n\t_sc_match_atr(card, muscle_atrs, &card->type);\n\tif(card->type == SC_CARD_TYPE_MUSCLE_ETOKEN_72K) {\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t}\n\tif(card->type == SC_CARD_TYPE_MUSCLE_JCOP241) {\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t}\n\tif (!(card->caps & SC_CARD_CAP_APDU_EXT)) {\n\t\tcard->max_recv_size = 255;\n\t\tcard->max_send_size = 255;\n\t}\n\tif(card->type == SC_CARD_TYPE_MUSCLE_JCOP242R2_NO_EXT_APDU) {\n\t        /* Tyfone JCOP v242R2 card that doesn't support extended APDUs */\n\t}\n\n\n\t/* FIXME: Card type detection */\n\tif (1) {\n\t\tunsigned long flags;\n\n\t\tflags = SC_ALGORITHM_RSA_RAW;\n\t\tflags |= SC_ALGORITHM_RSA_HASH_NONE;\n\t\tflags |= SC_ALGORITHM_ONBOARD_KEY_GEN;\n\n\t\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n\t\t\tbuf += 2;\n\t\t\tcount+=2;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic int muscle_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *cmd,\n\t\t\t\tint *tries_left)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tconst int bufferLength = MSC_MAX_PIN_COMMAND_LENGTH;\n\tu8 buffer[MSC_MAX_PIN_COMMAND_LENGTH];\n\tswitch(cmd->cmd) {\n\tcase SC_PIN_CMD_VERIFY:\n\t\tswitch(cmd->pin_type) {\n\t\tcase SC_AC_CHV: {\n\t\t\tsc_apdu_t apdu;\n\t\t\tint r;\n\t\t\tmsc_verify_pin_apdu(card, &apdu, buffer, bufferLength, cmd->pin_reference, cmd->pin1.data, cmd->pin1.len);\n\t\t\tcmd->apdu = &apdu;\n\t\t\tcmd->pin1.offset = 5;\n\t\t\tr = iso_ops->pin_cmd(card, cmd, tries_left);\n\t\t\tif(r >= 0)\n\t\t\t\tpriv->verifiedPins |= (1 << cmd->pin_reference);\n\t\t\treturn r;\n\t\t}\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_NONE:\n\t\tdefault:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Unsupported authentication method\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\tcase SC_PIN_CMD_CHANGE:\n\t\tswitch(cmd->pin_type) {\n\t\tcase SC_AC_CHV: {\n\t\t\tsc_apdu_t apdu;\n\t\t\tmsc_change_pin_apdu(card, &apdu, buffer, bufferLength, cmd->pin_reference, cmd->pin1.data, cmd->pin1.len, cmd->pin2.data, cmd->pin2.len);\n\t\t\tcmd->apdu = &apdu;\n\t\t\treturn iso_ops->pin_cmd(card, cmd, tries_left);\n\t\t}\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_NONE:\n\t\tdefault:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Unsupported authentication method\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\tcase SC_PIN_CMD_UNBLOCK:\n\tswitch(cmd->pin_type) {\n\t\tcase SC_AC_CHV: {\n\t\t\tsc_apdu_t apdu;\n\t\t\tmsc_unblock_pin_apdu(card, &apdu, buffer, bufferLength, cmd->pin_reference, cmd->pin1.data, cmd->pin1.len);\n\t\t\tcmd->apdu = &apdu;\n\t\t\treturn iso_ops->pin_cmd(card, cmd, tries_left);\n\t\t}\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_NONE:\n\t\tdefault:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Unsupported authentication method\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\tdefault:\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Unsupported command\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\n\t}\n\n}\n\nstatic int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)\n{\n\t/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */\n\tswitch(info->keyType) {\n\tcase 1: /* RSA */\n\t\treturn msc_extract_rsa_public_key(card,\n\t\t\tinfo->keyLocation,\n\t\t\t&info->modLength,\n\t\t\t&info->modValue,\n\t\t\t&info->expLength,\n\t\t\t&info->expValue);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n}\n\nstatic int muscle_card_import_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)\n{\n\t/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */\n\tswitch(info->keyType) {\n\tcase 0x02: /* RSA_PRIVATE */\n\tcase 0x03: /* RSA_PRIVATE_CRT */\n\t\treturn msc_import_key(card,\n\t\t\tinfo->keyLocation,\n\t\t\tinfo);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n}\n\nstatic int muscle_card_generate_key(sc_card_t *card, sc_cardctl_muscle_gen_key_info_t *info)\n{\n\treturn msc_generate_keypair(card,\n\t\tinfo->privateKeyLocation,\n\t\tinfo->publicKeyLocation,\n\t\tinfo->keyType,\n\t\tinfo->keySize,\n\t\t0);\n}\n\nstatic int muscle_card_verified_pins(sc_card_t *card, sc_cardctl_muscle_verified_pins_info_t *info)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tinfo->verifiedPins = priv->verifiedPins;\n\treturn 0;\n}\nstatic int muscle_card_ctl(sc_card_t *card, unsigned long request, void *data)\n{\n\tswitch(request) {\n\tcase SC_CARDCTL_MUSCLE_GENERATE_KEY:\n\t\treturn muscle_card_generate_key(card, (sc_cardctl_muscle_gen_key_info_t*) data);\n\tcase SC_CARDCTL_MUSCLE_EXTRACT_KEY:\n\t\treturn muscle_card_extract_key(card, (sc_cardctl_muscle_key_info_t*) data);\n\tcase SC_CARDCTL_MUSCLE_IMPORT_KEY:\n\t\treturn muscle_card_import_key(card, (sc_cardctl_muscle_key_info_t*) data);\n\tcase SC_CARDCTL_MUSCLE_VERIFIED_PINS:\n\t\treturn muscle_card_verified_pins(card, (sc_cardctl_muscle_verified_pins_info_t*) data);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED; /* Unsupported.. whatever it is */\n\t}\n}\n\nstatic int muscle_set_security_env(sc_card_t *card,\n\t\t\t\t const sc_security_env_t *env,\n\t\t\t\t int se_num)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\n\tif (env->operation != SC_SEC_OPERATION_SIGN &&\n\t    env->operation != SC_SEC_OPERATION_DECIPHER) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Invalid crypto operation supplied.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (env->algorithm != SC_ALGORITHM_RSA) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Invalid crypto algorithm supplied.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\t/* ADJUST FOR PKCS1 padding support for decryption only */\n\tif ((env->algorithm_flags & SC_ALGORITHM_RSA_PADS) ||\n\t    (env->algorithm_flags & SC_ALGORITHM_RSA_HASHES)) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Card supports only raw RSA.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT) {\n\t\tif (env->key_ref_len != 1 ||\n\t\t    (env->key_ref[0] > 0x0F)) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Invalid key reference supplied.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tpriv->rsa_key_ref = env->key_ref[0];\n\t}\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Algorithm reference not supported.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\t/* if (env->flags & SC_SEC_ENV_FILE_REF_PRESENT)\n\t\tif (memcmp(env->file_ref.value, \"\\x00\\x12\", 2) != 0) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"File reference is not 0012.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t} */\n\tpriv->env = *env;\n\treturn 0;\n}\n\nstatic int muscle_restore_security_env(sc_card_t *card, int se_num)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmemset(&priv->env, 0, sizeof(priv->env));\n\treturn 0;\n}\n\n\nstatic int muscle_decipher(sc_card_t * card,\n\t\t\t const u8 * crgram, size_t crgram_len, u8 * out,\n\t\t\t size_t out_len)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\n\tu8 key_id;\n\tint r;\n\n\t/* sanity check */\n\tif (priv->env.operation != SC_SEC_OPERATION_DECIPHER)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tkey_id = priv->rsa_key_ref * 2; /* Private key */\n\n\tif (out_len < crgram_len) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Output buffer too small\");\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t}\n\n\tr = msc_compute_crypt(card,\n\t\tkey_id,\n\t\t0x00, /* RSA NO PADDING */\n\t\t0x04, /* decrypt */\n\t\tcrgram,\n\t\tout,\n\t\tcrgram_len,\n\t\tout_len);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"Card signature failed\");\n\treturn r;\n}\n\nstatic int muscle_compute_signature(sc_card_t *card, const u8 *data,\n\t\tsize_t data_len, u8 * out, size_t outlen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tu8 key_id;\n\tint r;\n\n\tkey_id = priv->rsa_key_ref * 2; /* Private key */\n\n\tif (outlen < data_len) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Output buffer too small\");\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t}\n\n\tr = msc_compute_crypt(card,\n\t\tkey_id,\n\t\t0x00, /* RSA NO PADDING */\n\t\t0x04, /* -- decrypt raw... will do what we need since signing isn't yet supported */\n\t\tdata,\n\t\tout,\n\t\tdata_len,\n\t\toutlen);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"Card signature failed\");\n\treturn r;\n}\n\nstatic int muscle_get_challenge(sc_card_t *card, u8 *rnd, size_t len)\n{\n\tif (len == 0)\n\t\treturn SC_SUCCESS;\n\telse {\n\t\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\tmsc_get_challenge(card, len, 0, NULL, rnd),\n\t\t\t\t\"GET CHALLENGE cmd failed\");\n\t\treturn (int) len;\n\t}\n}\n\nstatic int muscle_check_sw(sc_card_t * card, unsigned int sw1, unsigned int sw2) {\n\tif(sw1 == 0x9C) {\n\t\tswitch(sw2) {\n\t\t\tcase 0x01: /* SW_NO_MEMORY_LEFT */\n\t\t\t\treturn SC_ERROR_NOT_ENOUGH_MEMORY;\n\t\t\tcase 0x02: /* SW_AUTH_FAILED */\n\t\t\t\treturn SC_ERROR_PIN_CODE_INCORRECT;\n\t\t\tcase 0x03: /* SW_OPERATION_NOT_ALLOWED */\n\t\t\t\treturn SC_ERROR_NOT_ALLOWED;\n\t\t\tcase 0x05: /* SW_UNSUPPORTED_FEATURE */\n\t\t\t\treturn SC_ERROR_NO_CARD_SUPPORT;\n\t\t\tcase 0x06: /* SW_UNAUTHORIZED */\n\t\t\t\treturn SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t\tcase 0x07: /* SW_OBJECT_NOT_FOUND */\n\t\t\t\treturn SC_ERROR_FILE_NOT_FOUND;\n\t\t\tcase 0x08: /* SW_OBJECT_EXISTS */\n\t\t\t\treturn SC_ERROR_FILE_ALREADY_EXISTS;\n\t\t\tcase 0x09: /* SW_INCORRECT_ALG */\n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t\t\tcase 0x0B: /* SW_SIGNATURE_INVALID */\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t\tcase 0x0C: /* SW_IDENTITY_BLOCKED */\n\t\t\t\treturn SC_ERROR_AUTH_METHOD_BLOCKED;\n\t\t\tcase 0x0F: /* SW_INVALID_PARAMETER */\n\t\t\tcase 0x10: /* SW_INCORRECT_P1 */\n\t\t\tcase 0x11: /* SW_INCORRECT_P2 */\n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t\t}\n\t}\n\treturn iso_ops->check_sw(card, sw1, sw2);\n}\n\nstatic int muscle_card_reader_lock_obtained(sc_card_t *card, int was_reset)\n{\n\tint r = SC_SUCCESS;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (was_reset > 0) {\n\t\tif (msc_select_applet(card, muscleAppletId, sizeof muscleAppletId) != 1) {\n\t\t\tr = SC_ERROR_INVALID_CARD;\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\n\tmuscle_ops = *iso_drv->ops;\n\tmuscle_ops.check_sw = muscle_check_sw;\n\tmuscle_ops.pin_cmd = muscle_pin_cmd;\n\tmuscle_ops.match_card = muscle_match_card;\n\tmuscle_ops.init = muscle_init;\n\tmuscle_ops.finish = muscle_finish;\n\n\tmuscle_ops.get_challenge = muscle_get_challenge;\n\n\tmuscle_ops.set_security_env = muscle_set_security_env;\n\tmuscle_ops.restore_security_env = muscle_restore_security_env;\n\tmuscle_ops.compute_signature = muscle_compute_signature;\n\tmuscle_ops.decipher = muscle_decipher;\n\tmuscle_ops.card_ctl = muscle_card_ctl;\n\tmuscle_ops.read_binary = muscle_read_binary;\n\tmuscle_ops.update_binary = muscle_update_binary;\n\tmuscle_ops.create_file = muscle_create_file;\n\tmuscle_ops.select_file = muscle_select_file;\n\tmuscle_ops.delete_file = muscle_delete_file;\n\tmuscle_ops.list_files = muscle_list_files;\n\tmuscle_ops.card_reader_lock_obtained = muscle_card_reader_lock_obtained;\n\n\treturn &muscle_drv;\n}\n\nstruct sc_card_driver * sc_get_muscle_driver(void)\n{\n\treturn sc_get_driver();\n}\n", "/*\n * card-tcos.c: Support for TCOS cards\n *\n * Copyright (C) 2011  Peter Koch <pk@opensc-project.org>\n * Copyright (C) 2002  g10 Code GmbH\n * Copyright (C) 2001  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n\nstatic struct sc_atr_table tcos_atrs[] = {\n\t/* Infineon SLE44 */\n\t{ \"3B:BA:13:00:81:31:86:5D:00:64:05:0A:02:01:31:80:90:00:8B\", NULL, NULL, SC_CARD_TYPE_TCOS_V2, 0, NULL },\n\t/* Infineon SLE66S */\n\t{ \"3B:BA:14:00:81:31:86:5D:00:64:05:14:02:02:31:80:90:00:91\", NULL, NULL, SC_CARD_TYPE_TCOS_V2, 0, NULL },\n\t/* Infineon SLE66CX320P */\n\t{ \"3B:BA:96:00:81:31:86:5D:00:64:05:60:02:03:31:80:90:00:66\", NULL, NULL, SC_CARD_TYPE_TCOS_V2, 0, NULL },\n\t/* Infineon SLE66CX322P */\n\t{ \"3B:BA:96:00:81:31:86:5D:00:64:05:7B:02:03:31:80:90:00:7D\", NULL, NULL, SC_CARD_TYPE_TCOS_V2, 0, NULL },\n\t/* Philips P5CT072 */\n\t{ \"3B:BF:96:00:81:31:FE:5D:00:64:04:11:03:01:31:C0:73:F7:01:D0:00:90:00:7D\", NULL, NULL, SC_CARD_TYPE_TCOS_V3, 0, NULL },\n\t{ \"3B:BF:96:00:81:31:FE:5D:00:64:04:11:04:0F:31:C0:73:F7:01:D0:00:90:00:74\", NULL, NULL, SC_CARD_TYPE_TCOS_V3, 0, NULL },\n\t/* Philips P5CT080 */\n\t{ \"3B:BF:B6:00:81:31:FE:5D:00:64:04:28:03:02:31:C0:73:F7:01:D0:00:90:00:67\", NULL, NULL, SC_CARD_TYPE_TCOS_V3, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n\nstatic struct sc_card_operations tcos_ops;\nstatic struct sc_card_driver tcos_drv = {\n\t\"TCOS 3.0\",\n\t\"tcos\",\n\t&tcos_ops,\n\tNULL, 0, NULL\n};\n\nstatic const struct sc_card_operations *iso_ops = NULL;\n\ntypedef struct tcos_data_st {\n\tunsigned int pad_flags;\n\tunsigned int next_sign;\n} tcos_data;\n\n\nstatic int tcos_finish(sc_card_t *card)\n{\n\tfree(card->drv_data);\n\treturn 0;\n}\n\n\nstatic int tcos_match_card(sc_card_t *card)\n{\n\tint i;\n\n\ti = _sc_match_atr(card, tcos_atrs, &card->type);\n\tif (i < 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic int tcos_init(sc_card_t *card)\n{\n        unsigned long flags;\n\n\ttcos_data *data = malloc(sizeof(tcos_data));\n\tif (!data) return SC_ERROR_OUT_OF_MEMORY;\n\n\tcard->name = \"TCOS\";\n\tcard->drv_data = (void *)data;\n\tcard->cla = 0x00;\n\n        flags = SC_ALGORITHM_RSA_RAW;\n        flags |= SC_ALGORITHM_RSA_PAD_PKCS1;\n        flags |= SC_ALGORITHM_RSA_HASH_NONE;\n\n        _sc_card_add_rsa_alg(card, 512, flags, 0);\n        _sc_card_add_rsa_alg(card, 768, flags, 0);\n        _sc_card_add_rsa_alg(card, 1024, flags, 0);\n\n\tif (card->type == SC_CARD_TYPE_TCOS_V3) {\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t\t_sc_card_add_rsa_alg(card, 1280, flags, 0);\n\t\t_sc_card_add_rsa_alg(card, 1536, flags, 0);\n\t\t_sc_card_add_rsa_alg(card, 1792, flags, 0);\n        \t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t}\n\n\treturn 0;\n}\n\n\n/* Hmmm, I don't know what to do.  It seems that the ACL design of\n   OpenSC should be enhanced to allow for the command based security\n   attributes of TCOS.  FIXME: This just allows to create a very basic\n   file. */\nstatic int tcos_construct_fci(const sc_file_t *file,\n                              u8 *out, size_t *outlen)\n{\n\tu8 *p = out;\n\tu8 buf[64];\n        size_t n;\n\n        /* FIXME: possible buffer overflow */\n\n        *p++ = 0x6F; /* FCI */\n        p++;\n\n\t/* File size */\n\tbuf[0] = (file->size >> 8) & 0xFF;\n\tbuf[1] = file->size & 0xFF;\n\tsc_asn1_put_tag(0x81, buf, 2, p, 16, &p);\n\n        /* File descriptor */\n        n = 0;\n\tbuf[n] = file->shareable ? 0x40 : 0;\n\tswitch (file->type) {\n\tcase SC_FILE_TYPE_WORKING_EF:\n\t\tbreak;\n\tcase SC_FILE_TYPE_DF:\n\t\tbuf[0] |= 0x38;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tbuf[n++] |= file->ef_structure & 7;\n        if ( (file->ef_structure & 7) > 1) {\n                /* record structured file */\n                buf[n++] = 0x41; /* indicate 3rd byte */\n                buf[n++] = file->record_length;\n        }\n\tsc_asn1_put_tag(0x82, buf, n, p, 8, &p);\n\n        /* File identifier */\n\tbuf[0] = (file->id >> 8) & 0xFF;\n\tbuf[1] = file->id & 0xFF;\n\tsc_asn1_put_tag(0x83, buf, 2, p, 16, &p);\n\n        /* Directory name */\n        if (file->type == SC_FILE_TYPE_DF) {\n                if (file->namelen) {\n                        sc_asn1_put_tag(0x84, file->name, file->namelen,\n                                        p, 16, &p);\n                }\n                else {\n                        /* TCOS needs one, so we use a faked one */\n                        snprintf ((char *) buf, sizeof(buf)-1, \"foo-%lu\",\n                                  (unsigned long) time (NULL));\n                        sc_asn1_put_tag(0x84, buf, strlen ((char *) buf), p, 16, &p);\n                }\n        }\n\n        /* File descriptor extension */\n        if (file->prop_attr_len && file->prop_attr) {\n\t\tn = file->prop_attr_len;\n\t\tmemcpy(buf, file->prop_attr, n);\n        }\n        else {\n                n = 0;\n                buf[n++] = 0x01; /* not invalidated, permanent */\n                if (file->type == SC_FILE_TYPE_WORKING_EF) \n                        buf[n++] = 0x00; /* generic data file */\n        }\n        sc_asn1_put_tag(0x85, buf, n, p, 16, &p);\n\n        /* Security attributes */\n\tif (file->sec_attr_len && file->sec_attr) {\n\t\tmemcpy(buf, file->sec_attr, file->sec_attr_len);\n\t\tn = file->sec_attr_len;\n\t}\n        else {\n                /* no attributes given - fall back to default one */\n                memcpy (buf+ 0, \"\\xa4\\x00\\x00\\x00\\xff\\xff\", 6); /* select */\n                memcpy (buf+ 6, \"\\xb0\\x00\\x00\\x00\\xff\\xff\", 6); /* read bin */\n                memcpy (buf+12, \"\\xd6\\x00\\x00\\x00\\xff\\xff\", 6); /* upd bin */\n                memcpy (buf+18, \"\\x60\\x00\\x00\\x00\\xff\\xff\", 6); /* admin grp*/\n                n = 24;\n        }\n        sc_asn1_put_tag(0x86, buf, n, p, sizeof (buf), &p);\n\n        \n        /* fixup length of FCI */\n        out[1] = p - out - 2;\n\n\t*outlen = p - out;\n\treturn 0;\n}\n\n\nstatic int tcos_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tint r;\n\tsize_t len;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tsc_apdu_t apdu;\n\n\tlen = SC_MAX_APDU_BUFFER_SIZE;\n\tr = tcos_construct_fci(file, sbuf, &len);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"tcos_construct_fci() failed\");\n\t\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x00, 0x00);\n        apdu.cla |= 0x80;  /* this is an proprietary extension */\n\tapdu.lc = len;\n\tapdu.datalen = len;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n}\n\n\nstatic unsigned int map_operations (int commandbyte )\n{\n\tunsigned int op = (unsigned int)-1;\n\n\tswitch ( (commandbyte & 0xfe) ) {\n\t\tcase 0xe2: /* append record */   op = SC_AC_OP_UPDATE; break;\n\t\tcase 0x24: /* change password */ op = SC_AC_OP_UPDATE; break;\n\t\tcase 0xe0: /* create */          op = SC_AC_OP_CREATE; break;\n\t\tcase 0xe4: /* delete */          op = SC_AC_OP_DELETE; break;\n\t\tcase 0xe8: /* exclude sfi */     op = SC_AC_OP_WRITE; break;\n\t\tcase 0x82: /* external auth */   op = SC_AC_OP_READ; break;\n\t\tcase 0xe6: /* include sfi */     op = SC_AC_OP_WRITE; break;\n\t\tcase 0x88: /* internal auth */   op = SC_AC_OP_READ; break;\n\t\tcase 0x04: /* invalidate */      op = SC_AC_OP_INVALIDATE; break;\n\t\tcase 0x2a: /* perform sec. op */ op = SC_AC_OP_SELECT; break;\n\t\tcase 0xb0: /* read binary */     op = SC_AC_OP_READ; break;\n\t\tcase 0xb2: /* read record */     op = SC_AC_OP_READ; break;\n\t\tcase 0x44: /* rehabilitate */    op = SC_AC_OP_REHABILITATE; break;\n\t\tcase 0xa4: /* select */          op = SC_AC_OP_SELECT; break;\n\t\tcase 0xee: /* set permanent */   op = SC_AC_OP_CREATE; break;\n\t\tcase 0x2c: /* unblock password */op = SC_AC_OP_WRITE; break;\n\t\tcase 0xd6: /* update binary */   op = SC_AC_OP_WRITE; break;\n\t\tcase 0xdc: /* update record */   op = SC_AC_OP_WRITE; break;\n\t\tcase 0x20: /* verify password */ op = SC_AC_OP_SELECT; break;\n\t\tcase 0x60: /* admin group */     op = SC_AC_OP_CREATE; break;\n\t}\n\treturn op;\n}\n\n\n/* Hmmm, I don't know what to do.  It seems that the ACL design of\n   OpenSC should be enhanced to allow for the command based security\n   attributes of TCOS.  FIXME: This just allows to create a very basic\n   file. */\nstatic void parse_sec_attr(sc_card_t *card,\n                           sc_file_t *file, const u8 *buf, size_t len)\n{\n        unsigned int op;\n        \n        /* list directory is not covered by ACLs - so always add an entry */\n        sc_file_add_acl_entry (file, SC_AC_OP_LIST_FILES,\n                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n        /* FIXME: check for what LOCK is used */\n        sc_file_add_acl_entry (file, SC_AC_OP_LOCK,\n                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n        for (; len >= 6; len -= 6, buf += 6) {\n                /* FIXME: temporary hacks */\n                if (!memcmp(buf, \"\\xa4\\x00\\x00\\x00\\xff\\xff\", 6)) /* select */\n                        sc_file_add_acl_entry (file, SC_AC_OP_SELECT,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                else if (!memcmp(buf, \"\\xb0\\x00\\x00\\x00\\xff\\xff\", 6)) /*read*/\n                        sc_file_add_acl_entry (file, SC_AC_OP_READ,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                else if (!memcmp(buf, \"\\xd6\\x00\\x00\\x00\\xff\\xff\", 6)) /*upd*/\n                        sc_file_add_acl_entry (file, SC_AC_OP_UPDATE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                else if (!memcmp(buf, \"\\x60\\x00\\x00\\x00\\xff\\xff\", 6)) {/*adm */\n                        sc_file_add_acl_entry (file, SC_AC_OP_WRITE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                        sc_file_add_acl_entry (file, SC_AC_OP_CREATE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                        sc_file_add_acl_entry (file, SC_AC_OP_INVALIDATE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                        sc_file_add_acl_entry (file, SC_AC_OP_REHABILITATE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                }\n                else {\n                        /* the first byte tells use the command or the\n                           command group.  We have to mask bit 0\n                           because this one distinguish between AND/OR\n                           combination of PINs*/\n                        op = map_operations (buf[0]);\n                        if (op == (unsigned int)-1)\n                        {\n                                sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n                                       \"Unknown security command byte %02x\\n\",\n                                       buf[0]);\n                                continue;\n                        }\n                        if (!buf[1])\n                                sc_file_add_acl_entry (file, op,\n                                                       SC_AC_NONE,\n                                                       SC_AC_KEY_REF_NONE);\n                        else\n                                sc_file_add_acl_entry (file, op,\n                                                       SC_AC_CHV, buf[1]);\n\n                        if (!buf[2] && !buf[3])\n                                sc_file_add_acl_entry (file, op,\n                                                       SC_AC_NONE,\n                                                       SC_AC_KEY_REF_NONE);\n                        else\n                                sc_file_add_acl_entry (file, op,\n                                                       SC_AC_TERM,\n                                                       (buf[2]<<8)|buf[3]);\n                }\n        }\n}\n\n\nstatic int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}\n\n\nstatic int tcos_list_files(sc_card_t *card, u8 *buf, size_t buflen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE], p1;\n\tint r, count = 0;\n\n\tassert(card != NULL);\n\tctx = card->ctx;\n\n\tfor (p1=1; p1<=2; p1++) {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xAA, p1, 0);\n\t\tapdu.cla = 0x80;\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 256;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t\tif (apdu.sw1==0x6A && (apdu.sw2==0x82 || apdu.sw2==0x88)) continue;\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"List Dir failed\");\n\t\tif (apdu.resplen > buflen) return SC_ERROR_BUFFER_TOO_SMALL;\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"got %\"SC_FORMAT_LEN_SIZE_T\"u %s-FileIDs\\n\",\n\t\t\t apdu.resplen / 2, p1 == 1 ? \"DF\" : \"EF\");\n\n\t\tmemcpy(buf, apdu.resp, apdu.resplen);\n\t\tbuf += apdu.resplen;\n\t\tbuflen -= apdu.resplen;\n\t\tcount += apdu.resplen;\n\t}\n\treturn count;\n}\n\n\nstatic int tcos_delete_file(sc_card_t *card, const sc_path_t *path)\n{\n\tint r;\n\tu8 sbuf[2];\n\tsc_apdu_t apdu;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (path->type != SC_PATH_TYPE_FILE_ID && path->len != 2) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"File type has to be SC_PATH_TYPE_FILE_ID\\n\");\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tsbuf[0] = path->value[0];\n\tsbuf[1] = path->value[1];\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE4, 0x00, 0x00);\n        apdu.cla |= 0x80;\n\tapdu.lc = 2;\n\tapdu.datalen = 2;\n\tapdu.data = sbuf;\n\t\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n}\n\n\nstatic int tcos_set_security_env(sc_card_t *card, const sc_security_env_t *env, int se_num)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE], *p;\n\tint r, default_key, tcos3;\n\ttcos_data *data;\n\n\tassert(card != NULL && env != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n        if (se_num || (env->operation!=SC_SEC_OPERATION_DECIPHER && env->operation!=SC_SEC_OPERATION_SIGN)){\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif(!(env->flags & SC_SEC_ENV_KEY_REF_PRESENT))\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"No Key-Reference in SecEnvironment\\n\");\n\telse\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"Key-Reference %02X (len=%\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t\t\t env->key_ref[0], env->key_ref_len);\n\t/* Key-Reference 0x80 ?? */\n\tdefault_key= !(env->flags & SC_SEC_ENV_KEY_REF_PRESENT) || (env->key_ref_len==1 && env->key_ref[0]==0x80);\n\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\"TCOS3:%d PKCS1:%d\\n\", tcos3,\n\t\t!!(env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tdata->pad_flags = env->algorithm_flags;\n\tdata->next_sign = default_key;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, tcos3 ? 0x41 : 0xC1, 0xB8);\n\tp = sbuf;\n\t*p++=0x80; *p++=0x01; *p++=tcos3 ? 0x0A : 0x10;\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT) {\n\t\t*p++ = (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC) ? 0x83 : 0x84;\n\t\t*p++ = env->key_ref_len;\n\t\tmemcpy(p, env->key_ref, env->key_ref_len);\n\t\tp += env->key_ref_len;\n\t}\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = (p - sbuf);\n\n\tr=sc_transmit_apdu(card, &apdu);\n\tif (r) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\treturn r;\n\t}\n\tif (apdu.sw1==0x6A && (apdu.sw2==0x81 || apdu.sw2==0x88)) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"Detected Signature-Only key\\n\");\n\t\tif (env->operation==SC_SEC_OPERATION_SIGN && default_key) return SC_SUCCESS;\n\t}\n\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\n\nstatic int tcos_restore_security_env(sc_card_t *card, int se_num)\n{\n\treturn 0;\n}\n\n\nstatic int tcos_compute_signature(sc_card_t *card, const u8 * data, size_t datalen, u8 * out, size_t outlen)\n{\n\tsize_t i, dlen=datalen;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint tcos3, r;\n\n\tassert(card != NULL && data != NULL && out != NULL);\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\n\tif (datalen > 255) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif(((tcos_data *)card->drv_data)->next_sign){\n\t\tif(datalen>48){\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Data to be signed is too long (TCOS supports max. 48 bytes)\\n\");\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t\t}\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x9E, 0x9A);\n\t\tmemcpy(sbuf, data, datalen);\n\t\tdlen=datalen;\n\t} else {\n\t\tint keylen= tcos3 ? 256 : 128;\n\t\tsc_format_apdu(card, &apdu, keylen>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A,0x80,0x86);\n\t\tfor(i=0; i<sizeof(sbuf);++i) sbuf[i]=0xff;\n\t\tsbuf[0]=0x02; sbuf[1]=0x00; sbuf[2]=0x01; sbuf[keylen-datalen]=0x00;\n\t\tmemcpy(sbuf+keylen-datalen+1, data, datalen);\n\t\tdlen=keylen+1;\n\t}\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = tcos3 ? 256 : 128;\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = dlen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tif (tcos3 && apdu.p1==0x80 && apdu.sw1==0x6A && apdu.sw2==0x87) {\n\t\tint keylen=128;\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A,0x80,0x86);\n\t\tfor(i=0; i<sizeof(sbuf);++i) sbuf[i]=0xff;\n\t\tsbuf[0]=0x02; sbuf[1]=0x00; sbuf[2]=0x01; sbuf[keylen-datalen]=0x00;\n\t\tmemcpy(sbuf+keylen-datalen+1, data, datalen);\n\t\tdlen=keylen+1;\n\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 128;\n\t\tapdu.data = sbuf;\n\t\tapdu.lc = apdu.datalen = dlen;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t}\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len = apdu.resplen>outlen ? outlen : apdu.resplen;\n\t\tmemcpy(out, apdu.resp, len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\n\nstatic int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_NORMAL);\n\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2){\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\n\n/* Issue the SET PERMANENT command.  With ENABLE_NULLPIN set the\n   NullPIN method will be activated, otherwise the permanent operation\n   will be done on the active file. */\nstatic int tcos_setperm(sc_card_t *card, int enable_nullpin)\n{\n\tint r;\n\tsc_apdu_t apdu;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xEE, 0x00, 0x00);\n        apdu.cla |= 0x80;\n\tapdu.lc = 0;\n\tapdu.datalen = 0;\n\tapdu.data = NULL;\n\t\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n}\n\n\nstatic int tcos_get_serialnr(sc_card_t *card, sc_serial_number_t *serial)\n{\n\tint r;\n\n\tif (!serial)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\t/* see if we have cached serial number */\n\tif (card->serialnr.len) {\n\t\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\t\treturn SC_SUCCESS;\n\t}\n\n\tcard->serialnr.len = sizeof card->serialnr.value;\n\tr = sc_parse_ef_gdo(card, card->serialnr.value, &card->serialnr.len, NULL, 0);\n\tif (r < 0) {\n\t\tcard->serialnr.len = 0;\n\t\treturn r;\n\t}\n\n\t/* copy and return serial number */\n\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\n\treturn SC_SUCCESS;\n}\n\n\nstatic int tcos_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tswitch (cmd) {\n\tcase SC_CARDCTL_TCOS_SETPERM:\n\t\treturn tcos_setperm(card, !!ptr);\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\treturn tcos_get_serialnr(card, (sc_serial_number_t *)ptr);\n\t}\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n\n\nstruct sc_card_driver * sc_get_tcos_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (iso_ops == NULL) iso_ops = iso_drv->ops;\n\ttcos_ops = *iso_drv->ops;\n\n\ttcos_ops.match_card           = tcos_match_card;\n\ttcos_ops.init                 = tcos_init;\n\ttcos_ops.finish               = tcos_finish;\n\ttcos_ops.create_file          = tcos_create_file;\n\ttcos_ops.set_security_env     = tcos_set_security_env;\n\ttcos_ops.select_file          = tcos_select_file;\n\ttcos_ops.list_files           = tcos_list_files;\n\ttcos_ops.delete_file          = tcos_delete_file;\n\ttcos_ops.set_security_env     = tcos_set_security_env;\n\ttcos_ops.compute_signature    = tcos_compute_signature;\n\ttcos_ops.decipher             = tcos_decipher;\n\ttcos_ops.restore_security_env = tcos_restore_security_env;\n\ttcos_ops.card_ctl             = tcos_card_ctl;\n\t\n\treturn &tcos_drv;\n}\n", "/*\n * PKCS15 emulation layer for EstEID card.\n *\n * Copyright (C) 2004, Martin Paljak <martin@martinpaljak.net>\n * Copyright (C) 2004, Bud P. Bruegger <bud@comune.grosseto.it>\n * Copyright (C) 2004, Antonino Iacono <ant_iacono@tin.it>\n * Copyright (C) 2003, Olaf Kirch <okir@suse.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"common/compat_strlcpy.h\"\n#include \"common/compat_strlcat.h\"\n\n#include \"internal.h\"\n#include \"opensc.h\"\n#include \"pkcs15.h\"\n#include \"esteid.h\"\n\nint sc_pkcs15emu_esteid_init_ex(sc_pkcs15_card_t *, struct sc_aid *, sc_pkcs15emu_opt_t *);\n\nstatic void\nset_string (char **strp, const char *value)\n{\n\tif (*strp)\n\t\tfree (*strp);\n\t*strp = value ? strdup (value) : NULL;\n}\n\n\nint\nselect_esteid_df (sc_card_t * card)\n{\n\tint r;\n\tsc_path_t tmppath;\n\tsc_format_path (\"3F00EEEE\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"esteid select DF failed\");\n\treturn r;\n}\n\nstatic int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[r] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int esteid_detect_card(sc_pkcs15_card_t *p15card)\n{\n\tif (is_esteid_card(p15card->card))\n\t\treturn SC_SUCCESS;\n\telse\n\t\treturn SC_ERROR_WRONG_CARD;\n}\n\nint sc_pkcs15emu_esteid_init_ex(sc_pkcs15_card_t *p15card,\n\t\t\t\tstruct sc_aid *aid,\n\t\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\n\tif (opts && opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)\n\t\treturn sc_pkcs15emu_esteid_init(p15card);\n\telse {\n\t\tint r = esteid_detect_card(p15card);\n\t\tif (r)\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\treturn sc_pkcs15emu_esteid_init(p15card);\n\t}\n}\n", "/*\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n/* Initially written by David Mattes <david.mattes@boeing.com> */\n/* Support for multiple key containers by Lukas Wunner <lukas@wunner.de> */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"internal.h\"\n#include \"pkcs15.h\"\n\n#define MANU_ID\t\t\t\"Gemplus\"\n#define APPLET_NAME\t\t\"GemSAFE V1\"\n#define DRIVER_SERIAL_NUMBER\t\"v0.9\"\n#define GEMSAFE_APP_PATH\t\"3F001600\"\n#define GEMSAFE_PATH\t\t\"3F0016000004\"\n\n/* Apparently, the Applet max read \"quanta\" is 248 bytes\n * Gemalto ClassicClient reads files in chunks of 238 bytes\n */\n#define GEMSAFE_READ_QUANTUM    248\n#define GEMSAFE_MAX_OBJLEN      28672\n\nint sc_pkcs15emu_gemsafeV1_init_ex(sc_pkcs15_card_t *, struct sc_aid *,sc_pkcs15emu_opt_t *);\n\nstatic int\nsc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\tint type, int authority,\n\tconst sc_path_t *path,\n\tconst sc_pkcs15_id_t *id,\n\tconst char *label, int obj_flags);\n\nstatic int\nsc_pkcs15emu_add_pin(sc_pkcs15_card_t *p15card,\n\tconst sc_pkcs15_id_t *id, const char *label,\n\tconst sc_path_t *path, int ref, int type,\n\tunsigned int min_length,\n\tunsigned int max_length,\n\tint flags, int tries_left, const char pad_char, int obj_flags);\n\nstatic int\nsc_pkcs15emu_add_prkey(sc_pkcs15_card_t *p15card,\n\tconst sc_pkcs15_id_t *id,\n\tconst char *label,\n\tint type, unsigned int modulus_length, int usage,\n\tconst sc_path_t *path, int ref,\n\tconst sc_pkcs15_id_t *auth_id, int obj_flags);\n\ntypedef struct cdata_st {\n\tchar\t   *label;\n\tint\t    authority;\n\tconst char *path;\n\tsize_t\t    index;\n\tsize_t\t    count;\n\tconst char *id;\n\tint         obj_flags;\n} cdata;\n\nconst unsigned int gemsafe_cert_max = 12;\n\ncdata gemsafe_cert[] = {\n\t{\"DS certificate #1\",  0, GEMSAFE_PATH, 0, 0, \"45\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #2\",  0, GEMSAFE_PATH, 0, 0, \"46\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #3\",  0, GEMSAFE_PATH, 0, 0, \"47\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #4\",  0, GEMSAFE_PATH, 0, 0, \"48\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #5\",  0, GEMSAFE_PATH, 0, 0, \"49\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #6\",  0, GEMSAFE_PATH, 0, 0, \"50\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #7\",  0, GEMSAFE_PATH, 0, 0, \"51\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #8\",  0, GEMSAFE_PATH, 0, 0, \"52\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #9\",  0, GEMSAFE_PATH, 0, 0, \"53\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #10\", 0, GEMSAFE_PATH, 0, 0, \"54\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #11\", 0, GEMSAFE_PATH, 0, 0, \"55\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #12\", 0, GEMSAFE_PATH, 0, 0, \"56\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n};\n\ntypedef struct pdata_st {\n\tconst u8    atr[SC_MAX_ATR_SIZE];\n\tconst size_t atr_len;\n\tconst char *id;\n\tconst char *label;\n\tconst char *path;\n\tconst int   ref;\n\tconst int   type;\n\tconst unsigned int maxlen;\n\tconst unsigned int minlen;\n\tconst int   flags;\n\tconst int   tries_left;\n\tconst char  pad_char;\n\tconst int   obj_flags;\n} pindata;\n\nconst unsigned int gemsafe_pin_max = 2;\n\nconst pindata gemsafe_pin[] = {\n\t/* ATR-specific PIN policies, first match found is used: */\n\t{ {0x3B, 0x7D, 0x96, 0x00, 0x00, 0x80, 0x31, 0x80, 0x65,\n\t   0xB0, 0x83, 0x11, 0x48, 0xC8, 0x83, 0x00, 0x90, 0x00}, 18,\n\t  \"01\", \"DS pin\", GEMSAFE_PATH, 0x01, SC_PKCS15_PIN_TYPE_ASCII_NUMERIC,\n\t  8, 4, SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_LOCAL,\n\t  3, 0x00, SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE },\n\t/* default PIN policy comes last: */\n\t{ { 0 }, 0,\n\t  \"01\", \"DS pin\", GEMSAFE_PATH, 0x01, SC_PKCS15_PIN_TYPE_BCD,\n\t  16, 6, SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_LOCAL,\n\t  3, 0xFF, SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE }\n};\n\ntypedef struct prdata_st {\n\tconst char *id;\n\tchar\t   *label;\n\tunsigned int modulus_len;\n\tint         usage;\n\tconst char *path;\n\tint         ref;\n\tconst char *auth_id;\n\tint         obj_flags;\n} prdata;\n\n#define USAGE_NONREP\tSC_PKCS15_PRKEY_USAGE_NONREPUDIATION\n#define USAGE_KE\tSC_PKCS15_PRKEY_USAGE_ENCRYPT | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_DECRYPT | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_WRAP    | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_UNWRAP\n#define USAGE_AUT\tSC_PKCS15_PRKEY_USAGE_ENCRYPT | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_DECRYPT | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_WRAP    | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_UNWRAP  | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_SIGN\n\nprdata gemsafe_prkeys[] = {\n\t{ \"45\", \"DS key #1\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x03, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"46\", \"DS key #2\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x04, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"47\", \"DS key #3\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x05, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"48\", \"DS key #4\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x06, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"49\", \"DS key #5\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x07, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"50\", \"DS key #6\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x08, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"51\", \"DS key #7\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x09, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"52\", \"DS key #8\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x0a, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"53\", \"DS key #9\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x0b, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"54\", \"DS key #10\", 1024, USAGE_AUT, GEMSAFE_PATH, 0x0c, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"55\", \"DS key #11\", 1024, USAGE_AUT, GEMSAFE_PATH, 0x0d, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"56\", \"DS key #12\", 1024, USAGE_AUT, GEMSAFE_PATH, 0x0e, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n};\n\nstatic int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \"Could not read cert object\");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int gemsafe_detect_card( sc_pkcs15_card_t *p15card)\n{\n\tif (strcmp(p15card->card->name, \"GemSAFE V1\"))\n\t\treturn SC_ERROR_WRONG_CARD;\n\n\treturn SC_SUCCESS;\n}\n\nstatic int sc_pkcs15emu_gemsafeV1_init( sc_pkcs15_card_t *p15card)\n{\n\tint\t\t    r;\n\tunsigned int    i;\n\tstruct sc_path  path;\n\tstruct sc_file *file = NULL;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_apdu  apdu;\n\tu8\t\t    rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\n\tsc_log(p15card->card->ctx, \"Setting pkcs15 parameters\");\n\n\tif (p15card->tokeninfo->label)\n\t\tfree(p15card->tokeninfo->label);\n\tp15card->tokeninfo->label = malloc(strlen(APPLET_NAME) + 1);\n\tif (!p15card->tokeninfo->label)\n\t\treturn SC_ERROR_INTERNAL;\n\tstrcpy(p15card->tokeninfo->label, APPLET_NAME);\n\n\tif (p15card->tokeninfo->serial_number)\n\t\tfree(p15card->tokeninfo->serial_number);\n\tp15card->tokeninfo->serial_number = malloc(strlen(DRIVER_SERIAL_NUMBER) + 1);\n\tif (!p15card->tokeninfo->serial_number)\n\t\treturn SC_ERROR_INTERNAL;\n\tstrcpy(p15card->tokeninfo->serial_number, DRIVER_SERIAL_NUMBER);\n\n\t/* the GemSAFE applet version number */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0xdf, 0x03);\n\tapdu.cla = 0x80;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\t/* Manual says Le=0x05, but should be 0x08 to return full version number */\n\tapdu.le = 0x08;\n\tapdu.lc = 0;\n\tapdu.datalen = 0;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1 != 0x90 || apdu.sw2 != 0x00)\n\t\treturn SC_ERROR_INTERNAL;\n\tif (r != SC_SUCCESS)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* the manufacturer ID, in this case GemPlus */\n\tif (p15card->tokeninfo->manufacturer_id)\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\tp15card->tokeninfo->manufacturer_id = malloc(strlen(MANU_ID) + 1);\n\tif (!p15card->tokeninfo->manufacturer_id)\n\t\treturn SC_ERROR_INTERNAL;\n\tstrcpy(p15card->tokeninfo->manufacturer_id, MANU_ID);\n\n\t/* determine allocated key containers and length of certificates */\n\tr = gemsafe_get_cert_len(card);\n\tif (r != SC_SUCCESS)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* set certs */\n\tsc_log(p15card->card->ctx, \"Setting certificates\");\n\tfor (i = 0; i < gemsafe_cert_max; i++) {\n\t\tstruct sc_pkcs15_id p15Id;\n\t\tstruct sc_path path;\n\n\t\tif (gemsafe_cert[i].label == NULL)\n\t\t\tcontinue;\n\t\tsc_format_path(gemsafe_cert[i].path, &path);\n\t\tsc_pkcs15_format_id(gemsafe_cert[i].id, &p15Id);\n\t\tpath.index = gemsafe_cert[i].index;\n\t\tpath.count = gemsafe_cert[i].count;\n\t\tsc_pkcs15emu_add_cert(p15card, SC_PKCS15_TYPE_CERT_X509,\n\t\t\t\t      gemsafe_cert[i].authority, &path, &p15Id,\n\t\t\t\t      gemsafe_cert[i].label, gemsafe_cert[i].obj_flags);\n\t}\n\n\t/* set gemsafe_pin */\n\tsc_log(p15card->card->ctx, \"Setting PIN\");\n\tfor (i=0; i < gemsafe_pin_max; i++) {\n\t\tstruct sc_pkcs15_id\tp15Id;\n\t\tstruct sc_path path;\n\n\t\tsc_pkcs15_format_id(gemsafe_pin[i].id, &p15Id);\n\t\tsc_format_path(gemsafe_pin[i].path, &path);\n\t\tif (gemsafe_pin[i].atr_len == 0 ||\n\t\t   (gemsafe_pin[i].atr_len == p15card->card->atr.len &&\n\t\t    memcmp(p15card->card->atr.value, gemsafe_pin[i].atr,\n\t\t\t   p15card->card->atr.len) == 0)) {\n\t\t\tsc_pkcs15emu_add_pin(p15card, &p15Id, gemsafe_pin[i].label,\n\t\t\t\t\t     &path, gemsafe_pin[i].ref, gemsafe_pin[i].type,\n\t\t\t\t\t     gemsafe_pin[i].minlen, gemsafe_pin[i].maxlen,\n\t\t\t\t\t     gemsafe_pin[i].flags, gemsafe_pin[i].tries_left,\n\t\t\t\t\t     gemsafe_pin[i].pad_char, gemsafe_pin[i].obj_flags);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\t/* set private keys */\n\tsc_log(p15card->card->ctx, \"Setting private keys\");\n\tfor (i = 0; i < gemsafe_cert_max; i++) {\n\t\tstruct sc_pkcs15_id p15Id, authId, *pauthId;\n\t\tstruct sc_path path;\n\t\tint key_ref = 0x03;\n\n\t\tif (gemsafe_prkeys[i].label == NULL)\n\t\t\tcontinue;\n\t\tsc_pkcs15_format_id(gemsafe_prkeys[i].id, &p15Id);\n\t\tif (gemsafe_prkeys[i].auth_id) {\n\t\t\tsc_pkcs15_format_id(gemsafe_prkeys[i].auth_id, &authId);\n\t\t\tpauthId = &authId;\n\t\t} else\n\t\t\tpauthId = NULL;\n\t\tsc_format_path(gemsafe_prkeys[i].path, &path);\n\t\t/*\n\t\t * The key ref may be different for different sites;\n\t\t * by adding flags=n where the low order 4 bits can be\n\t\t * the key ref we can force it.\n\t\t */\n\t\tif ( p15card->card->flags & 0x0F) {\n\t\t\tkey_ref = p15card->card->flags & 0x0F;\n\t\t\tsc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\t \"Overriding key_ref %d with %d\\n\",\n\t\t\t\t gemsafe_prkeys[i].ref, key_ref);\n\t\t} else\n\t\t\tkey_ref = gemsafe_prkeys[i].ref;\n\t\tsc_pkcs15emu_add_prkey(p15card, &p15Id, gemsafe_prkeys[i].label,\n\t\t\t\t       SC_PKCS15_TYPE_PRKEY_RSA,\n\t\t\t\t       gemsafe_prkeys[i].modulus_len, gemsafe_prkeys[i].usage,\n\t\t\t\t       &path, key_ref, pauthId,\n\t\t\t\t       gemsafe_prkeys[i].obj_flags);\n\t}\n\n\t/* select the application DF */\n\tsc_log(p15card->card->ctx, \"Selecting application DF\");\n\tsc_format_path(GEMSAFE_APP_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\t/* set the application DF */\n\tif (p15card->file_app)\n\t\tfree(p15card->file_app);\n\tp15card->file_app = file;\n\n\treturn SC_SUCCESS;\n}\n\nint sc_pkcs15emu_gemsafeV1_init_ex( sc_pkcs15_card_t *p15card,\n\t\t\tstruct sc_aid *aid,\n\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\tif (opts && opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)\n\t\treturn sc_pkcs15emu_gemsafeV1_init(p15card);\n\telse {\n\t\tint r = gemsafe_detect_card(p15card);\n\t\tif (r)\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\treturn sc_pkcs15emu_gemsafeV1_init(p15card);\n\t}\n}\n\nstatic sc_pkcs15_df_t *\nsc_pkcs15emu_get_df(sc_pkcs15_card_t *p15card, unsigned int type)\n{\n\tsc_pkcs15_df_t\t*df;\n\tsc_file_t\t*file;\n\tint\t\tcreated = 0;\n\n\twhile (1) {\n\t\tfor (df = p15card->df_list; df; df = df->next) {\n\t\t\tif (df->type == type) {\n\t\t\t\tif (created)\n\t\t\t\t\tdf->enumerated = 1;\n\t\t\t\treturn df;\n\t\t\t}\n\t\t}\n\n\t\tassert(created == 0);\n\n\t\tfile = sc_file_new();\n\t\tif (!file)\n\t\t\treturn NULL;\n\t\tsc_format_path(\"11001101\", &file->path);\n\t\tsc_pkcs15_add_df(p15card, type, &file->path);\n\t\tsc_file_free(file);\n\t\tcreated++;\n\t}\n}\n\nstatic int\nsc_pkcs15emu_add_object(sc_pkcs15_card_t *p15card, int type,\n\t\tconst char *label, void *data,\n\t\tconst sc_pkcs15_id_t *auth_id, int obj_flags)\n{\n\tsc_pkcs15_object_t *obj;\n\tint\t\tdf_type;\n\n\tobj = calloc(1, sizeof(*obj));\n\n\tobj->type  = type;\n\tobj->data  = data;\n\n\tif (label)\n\t\tstrncpy(obj->label, label, sizeof(obj->label)-1);\n\n\tobj->flags = obj_flags;\n\tif (auth_id)\n\t\tobj->auth_id = *auth_id;\n\n\tswitch (type & SC_PKCS15_TYPE_CLASS_MASK) {\n\tcase SC_PKCS15_TYPE_AUTH:\n\t\tdf_type = SC_PKCS15_AODF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY:\n\t\tdf_type = SC_PKCS15_PRKDF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PUBKEY:\n\t\tdf_type = SC_PKCS15_PUKDF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_CERT:\n\t\tdf_type = SC_PKCS15_CDF;\n\t\tbreak;\n\tdefault:\n\t\tsc_log(p15card->card->ctx, \"Unknown PKCS15 object type %d\", type);\n\t\tfree(obj);\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tobj->df = sc_pkcs15emu_get_df(p15card, df_type);\n\tsc_pkcs15_add_object(p15card, obj);\n\n\treturn 0;\n}\n\nstatic int\nsc_pkcs15emu_add_pin(sc_pkcs15_card_t *p15card,\n                const sc_pkcs15_id_t *id, const char *label,\n                const sc_path_t *path, int ref, int type,\n                unsigned int min_length,\n                unsigned int max_length,\n                int flags, int tries_left, const char pad_char, int obj_flags)\n{\n\tsc_pkcs15_auth_info_t *info;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tinfo->auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tinfo->auth_method = SC_AC_CHV;\n\tinfo->auth_id           = *id;\n\tinfo->attrs.pin.min_length        = min_length;\n\tinfo->attrs.pin.max_length        = max_length;\n\tinfo->attrs.pin.stored_length     = max_length;\n\tinfo->attrs.pin.type              = type;\n\tinfo->attrs.pin.reference         = ref;\n\tinfo->attrs.pin.flags             = flags;\n\tinfo->attrs.pin.pad_char          = pad_char;\n\tinfo->tries_left        = tries_left;\n\tinfo->logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tif (path)\n\t\tinfo->path = *path;\n\n\treturn sc_pkcs15emu_add_object(p15card, SC_PKCS15_TYPE_AUTH_PIN, label, info, NULL, obj_flags);\n}\n\nstatic int\nsc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\t\tint type, int authority,\n\t\tconst sc_path_t *path,\n\t\tconst sc_pkcs15_id_t *id,\n                const char *label, int obj_flags)\n{\n\tsc_pkcs15_cert_info_t *info;\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id\t\t= *id;\n\tinfo->authority\t\t= authority;\n\tif (path)\n\t\tinfo->path = *path;\n\n\treturn sc_pkcs15emu_add_object(p15card, type, label, info, NULL, obj_flags);\n}\n\nstatic int\nsc_pkcs15emu_add_prkey(sc_pkcs15_card_t *p15card,\n                const sc_pkcs15_id_t *id,\n                const char *label,\n                int type, unsigned int modulus_length, int usage,\n                const sc_path_t *path, int ref,\n                const sc_pkcs15_id_t *auth_id, int obj_flags)\n{\n\tsc_pkcs15_prkey_info_t *info;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id                = *id;\n\tinfo->modulus_length    = modulus_length;\n\tinfo->usage             = usage;\n\tinfo->native            = 1;\n\tinfo->access_flags      = SC_PKCS15_PRKEY_ACCESS_SENSITIVE\n                                | SC_PKCS15_PRKEY_ACCESS_ALWAYSSENSITIVE\n                                | SC_PKCS15_PRKEY_ACCESS_NEVEREXTRACTABLE\n                                | SC_PKCS15_PRKEY_ACCESS_LOCAL;\n\tinfo->key_reference     = ref;\n\n\tif (path)\n\t\tinfo->path = *path;\n\n\treturn sc_pkcs15emu_add_object(p15card, type, label,\n\t\t\tinfo, auth_id, obj_flags);\n}\n\n/* SC_IMPLEMENT_DRIVER_VERSION(\"0.9.4\") */\n", "/*\n * pkcs15-sc-hsm.c : Initialize PKCS#15 emulation\n *\n * Copyright (C) 2012 Andreas Schwier, CardContact, Minden, Germany\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"internal.h\"\n#include \"pkcs15.h\"\n#include \"asn1.h\"\n#include \"common/compat_strlcpy.h\"\n#include \"common/compat_strnlen.h\"\n\n#include \"card-sc-hsm.h\"\n\n\nextern struct sc_aid sc_hsm_aid;\n\n\nvoid sc_hsm_set_serialnr(sc_card_t *card, char *serial);\n\n\n\nstatic struct ec_curve curves[] = {\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2A\\x86\\x48\\xCE\\x3D\\x03\\x01\\x01\", 8},\t// secp192r1 aka prime192r1\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 24},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFC\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x64\\x21\\x05\\x19\\xE5\\x9C\\x80\\xE7\\x0F\\xA7\\xE9\\xAB\\x72\\x24\\x30\\x49\\xFE\\xB8\\xDE\\xEC\\xC1\\x46\\xB9\\xB1\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x18\\x8D\\xA8\\x0E\\xB0\\x30\\x90\\xF6\\x7C\\xBF\\x20\\xEB\\x43\\xA1\\x88\\x00\\xF4\\xFF\\x0A\\xFD\\x82\\xFF\\x10\\x12\\x07\\x19\\x2B\\x95\\xFF\\xC8\\xDA\\x78\\x63\\x10\\x11\\xED\\x6B\\x24\\xCD\\xD5\\x73\\xF9\\x77\\xA1\\x1E\\x79\\x48\\x11\", 49},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x99\\xDE\\xF8\\x36\\x14\\x6B\\xC9\\xB1\\xB4\\xD2\\x28\\x31\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2A\\x86\\x48\\xCE\\x3D\\x03\\x01\\x07\", 8},\t// secp256r1 aka prime256r1\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 32},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFC\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x5A\\xC6\\x35\\xD8\\xAA\\x3A\\x93\\xE7\\xB3\\xEB\\xBD\\x55\\x76\\x98\\x86\\xBC\\x65\\x1D\\x06\\xB0\\xCC\\x53\\xB0\\xF6\\x3B\\xCE\\x3C\\x3E\\x27\\xD2\\x60\\x4B\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x6B\\x17\\xD1\\xF2\\xE1\\x2C\\x42\\x47\\xF8\\xBC\\xE6\\xE5\\x63\\xA4\\x40\\xF2\\x77\\x03\\x7D\\x81\\x2D\\xEB\\x33\\xA0\\xF4\\xA1\\x39\\x45\\xD8\\x98\\xC2\\x96\\x4F\\xE3\\x42\\xE2\\xFE\\x1A\\x7F\\x9B\\x8E\\xE7\\xEB\\x4A\\x7C\\x0F\\x9E\\x16\\x2B\\xCE\\x33\\x57\\x6B\\x31\\x5E\\xCE\\xCB\\xB6\\x40\\x68\\x37\\xBF\\x51\\xF5\", 65},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xBC\\xE6\\xFA\\xAD\\xA7\\x17\\x9E\\x84\\xF3\\xB9\\xCA\\xC2\\xFC\\x63\\x25\\x51\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x24\\x03\\x03\\x02\\x08\\x01\\x01\\x03\", 9},\t// brainpoolP192r1\n\t\t\t\t{ (unsigned char *) \"\\xC3\\x02\\xF4\\x1D\\x93\\x2A\\x36\\xCD\\xA7\\xA3\\x46\\x30\\x93\\xD1\\x8D\\xB7\\x8F\\xCE\\x47\\x6D\\xE1\\xA8\\x62\\x97\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x6A\\x91\\x17\\x40\\x76\\xB1\\xE0\\xE1\\x9C\\x39\\xC0\\x31\\xFE\\x86\\x85\\xC1\\xCA\\xE0\\x40\\xE5\\xC6\\x9A\\x28\\xEF\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x46\\x9A\\x28\\xEF\\x7C\\x28\\xCC\\xA3\\xDC\\x72\\x1D\\x04\\x4F\\x44\\x96\\xBC\\xCA\\x7E\\xF4\\x14\\x6F\\xBF\\x25\\xC9\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x04\\xC0\\xA0\\x64\\x7E\\xAA\\xB6\\xA4\\x87\\x53\\xB0\\x33\\xC5\\x6C\\xB0\\xF0\\x90\\x0A\\x2F\\x5C\\x48\\x53\\x37\\x5F\\xD6\\x14\\xB6\\x90\\x86\\x6A\\xBD\\x5B\\xB8\\x8B\\x5F\\x48\\x28\\xC1\\x49\\x00\\x02\\xE6\\x77\\x3F\\xA2\\xFA\\x29\\x9B\\x8F\", 49},\n\t\t\t\t{ (unsigned char *) \"\\xC3\\x02\\xF4\\x1D\\x93\\x2A\\x36\\xCD\\xA7\\xA3\\x46\\x2F\\x9E\\x9E\\x91\\x6B\\x5B\\xE8\\xF1\\x02\\x9A\\xC4\\xAC\\xC1\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x24\\x03\\x03\\x02\\x08\\x01\\x01\\x05\", 9},\t// brainpoolP224r1\n\t\t\t\t{ (unsigned char *) \"\\xD7\\xC1\\x34\\xAA\\x26\\x43\\x66\\x86\\x2A\\x18\\x30\\x25\\x75\\xD1\\xD7\\x87\\xB0\\x9F\\x07\\x57\\x97\\xDA\\x89\\xF5\\x7E\\xC8\\xC0\\xFF\", 28},\n\t\t\t\t{ (unsigned char *) \"\\x68\\xA5\\xE6\\x2C\\xA9\\xCE\\x6C\\x1C\\x29\\x98\\x03\\xA6\\xC1\\x53\\x0B\\x51\\x4E\\x18\\x2A\\xD8\\xB0\\x04\\x2A\\x59\\xCA\\xD2\\x9F\\x43\", 28},\n\t\t\t\t{ (unsigned char *) \"\\x25\\x80\\xF6\\x3C\\xCF\\xE4\\x41\\x38\\x87\\x07\\x13\\xB1\\xA9\\x23\\x69\\xE3\\x3E\\x21\\x35\\xD2\\x66\\xDB\\xB3\\x72\\x38\\x6C\\x40\\x0B\", 28},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x0D\\x90\\x29\\xAD\\x2C\\x7E\\x5C\\xF4\\x34\\x08\\x23\\xB2\\xA8\\x7D\\xC6\\x8C\\x9E\\x4C\\xE3\\x17\\x4C\\x1E\\x6E\\xFD\\xEE\\x12\\xC0\\x7D\\x58\\xAA\\x56\\xF7\\x72\\xC0\\x72\\x6F\\x24\\xC6\\xB8\\x9E\\x4E\\xCD\\xAC\\x24\\x35\\x4B\\x9E\\x99\\xCA\\xA3\\xF6\\xD3\\x76\\x14\\x02\\xCD\", 57},\n\t\t\t\t{ (unsigned char *) \"\\xD7\\xC1\\x34\\xAA\\x26\\x43\\x66\\x86\\x2A\\x18\\x30\\x25\\x75\\xD0\\xFB\\x98\\xD1\\x16\\xBC\\x4B\\x6D\\xDE\\xBC\\xA3\\xA5\\xA7\\x93\\x9F\", 28},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x24\\x03\\x03\\x02\\x08\\x01\\x01\\x07\", 9},\t// brainpoolP256r1\n\t\t\t\t{ (unsigned char *) \"\\xA9\\xFB\\x57\\xDB\\xA1\\xEE\\xA9\\xBC\\x3E\\x66\\x0A\\x90\\x9D\\x83\\x8D\\x72\\x6E\\x3B\\xF6\\x23\\xD5\\x26\\x20\\x28\\x20\\x13\\x48\\x1D\\x1F\\x6E\\x53\\x77\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x7D\\x5A\\x09\\x75\\xFC\\x2C\\x30\\x57\\xEE\\xF6\\x75\\x30\\x41\\x7A\\xFF\\xE7\\xFB\\x80\\x55\\xC1\\x26\\xDC\\x5C\\x6C\\xE9\\x4A\\x4B\\x44\\xF3\\x30\\xB5\\xD9\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x26\\xDC\\x5C\\x6C\\xE9\\x4A\\x4B\\x44\\xF3\\x30\\xB5\\xD9\\xBB\\xD7\\x7C\\xBF\\x95\\x84\\x16\\x29\\x5C\\xF7\\xE1\\xCE\\x6B\\xCC\\xDC\\x18\\xFF\\x8C\\x07\\xB6\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x8B\\xD2\\xAE\\xB9\\xCB\\x7E\\x57\\xCB\\x2C\\x4B\\x48\\x2F\\xFC\\x81\\xB7\\xAF\\xB9\\xDE\\x27\\xE1\\xE3\\xBD\\x23\\xC2\\x3A\\x44\\x53\\xBD\\x9A\\xCE\\x32\\x62\\x54\\x7E\\xF8\\x35\\xC3\\xDA\\xC4\\xFD\\x97\\xF8\\x46\\x1A\\x14\\x61\\x1D\\xC9\\xC2\\x77\\x45\\x13\\x2D\\xED\\x8E\\x54\\x5C\\x1D\\x54\\xC7\\x2F\\x04\\x69\\x97\", 65},\n\t\t\t\t{ (unsigned char *) \"\\xA9\\xFB\\x57\\xDB\\xA1\\xEE\\xA9\\xBC\\x3E\\x66\\x0A\\x90\\x9D\\x83\\x8D\\x71\\x8C\\x39\\x7A\\xA3\\xB5\\x61\\xA6\\xF7\\x90\\x1E\\x0E\\x82\\x97\\x48\\x56\\xA7\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x24\\x03\\x03\\x02\\x08\\x01\\x01\\x09\", 9},\t// brainpoolP320r1\n\t\t\t\t{ (unsigned char *) \"\\xD3\\x5E\\x47\\x20\\x36\\xBC\\x4F\\xB7\\xE1\\x3C\\x78\\x5E\\xD2\\x01\\xE0\\x65\\xF9\\x8F\\xCF\\xA6\\xF6\\xF4\\x0D\\xEF\\x4F\\x92\\xB9\\xEC\\x78\\x93\\xEC\\x28\\xFC\\xD4\\x12\\xB1\\xF1\\xB3\\x2E\\x27\", 40},\n\t\t\t\t{ (unsigned char *) \"\\x3E\\xE3\\x0B\\x56\\x8F\\xBA\\xB0\\xF8\\x83\\xCC\\xEB\\xD4\\x6D\\x3F\\x3B\\xB8\\xA2\\xA7\\x35\\x13\\xF5\\xEB\\x79\\xDA\\x66\\x19\\x0E\\xB0\\x85\\xFF\\xA9\\xF4\\x92\\xF3\\x75\\xA9\\x7D\\x86\\x0E\\xB4\", 40},\n\t\t\t\t{ (unsigned char *) \"\\x52\\x08\\x83\\x94\\x9D\\xFD\\xBC\\x42\\xD3\\xAD\\x19\\x86\\x40\\x68\\x8A\\x6F\\xE1\\x3F\\x41\\x34\\x95\\x54\\xB4\\x9A\\xCC\\x31\\xDC\\xCD\\x88\\x45\\x39\\x81\\x6F\\x5E\\xB4\\xAC\\x8F\\xB1\\xF1\\xA6\", 40},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x43\\xBD\\x7E\\x9A\\xFB\\x53\\xD8\\xB8\\x52\\x89\\xBC\\xC4\\x8E\\xE5\\xBF\\xE6\\xF2\\x01\\x37\\xD1\\x0A\\x08\\x7E\\xB6\\xE7\\x87\\x1E\\x2A\\x10\\xA5\\x99\\xC7\\x10\\xAF\\x8D\\x0D\\x39\\xE2\\x06\\x11\\x14\\xFD\\xD0\\x55\\x45\\xEC\\x1C\\xC8\\xAB\\x40\\x93\\x24\\x7F\\x77\\x27\\x5E\\x07\\x43\\xFF\\xED\\x11\\x71\\x82\\xEA\\xA9\\xC7\\x78\\x77\\xAA\\xAC\\x6A\\xC7\\xD3\\x52\\x45\\xD1\\x69\\x2E\\x8E\\xE1\", 81},\n\t\t\t\t{ (unsigned char *) \"\\xD3\\x5E\\x47\\x20\\x36\\xBC\\x4F\\xB7\\xE1\\x3C\\x78\\x5E\\xD2\\x01\\xE0\\x65\\xF9\\x8F\\xCF\\xA5\\xB6\\x8F\\x12\\xA3\\x2D\\x48\\x2E\\xC7\\xEE\\x86\\x58\\xE9\\x86\\x91\\x55\\x5B\\x44\\xC5\\x93\\x11\", 40},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x81\\x04\\x00\\x1F\", 5},\t// secp192k1\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xFF\\xFF\\xEE\\x37\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x04\\xDB\\x4F\\xF1\\x0E\\xC0\\x57\\xE9\\xAE\\x26\\xB0\\x7D\\x02\\x80\\xB7\\xF4\\x34\\x1D\\xA5\\xD1\\xB1\\xEA\\xE0\\x6C\\x7D\\x9B\\x2F\\x2F\\x6D\\x9C\\x56\\x28\\xA7\\x84\\x41\\x63\\xD0\\x15\\xBE\\x86\\x34\\x40\\x82\\xAA\\x88\\xD9\\x5E\\x2F\\x9D\", 49},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\x26\\xF2\\xFC\\x17\\x0F\\x69\\x46\\x6A\\x74\\xDE\\xFD\\x8D\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x81\\x04\\x00\\x0A\", 5},\t// secp256k1\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xFF\\xFF\\xFC\\x2F\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x79\\xBE\\x66\\x7E\\xF9\\xDC\\xBB\\xAC\\x55\\xA0\\x62\\x95\\xCE\\x87\\x0B\\x07\\x02\\x9B\\xFC\\xDB\\x2D\\xCE\\x28\\xD9\\x59\\xF2\\x81\\x5B\\x16\\xF8\\x17\\x98\\x48\\x3A\\xDA\\x77\\x26\\xA3\\xC4\\x65\\x5D\\xA4\\xFB\\xFC\\x0E\\x11\\x08\\xA8\\xFD\\x17\\xB4\\x48\\xA6\\x85\\x54\\x19\\x9C\\x47\\xD0\\x8F\\xFB\\x10\\xD4\\xB8\", 65},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xBA\\xAE\\xDC\\xE6\\xAF\\x48\\xA0\\x3B\\xBF\\xD2\\x5E\\x8C\\xD0\\x36\\x41\\x41\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0}\n\t\t}\n};\n\n\n\n#define C_ASN1_CVC_PUBKEY_SIZE 10\nstatic const struct sc_asn1_entry c_asn1_cvc_pubkey[C_ASN1_CVC_PUBKEY_SIZE] = {\n\t{ \"publicKeyOID\", SC_ASN1_OBJECT, SC_ASN1_UNI | SC_ASN1_OBJECT, 0, NULL, NULL },\n\t{ \"primeOrModulus\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 1, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"coefficientAorExponent\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 2,  SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"coefficientB\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 3, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"basePointG\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 4, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"order\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 5, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"publicPoint\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 6, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"cofactor\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 7, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"modulusSize\", SC_ASN1_INTEGER, SC_ASN1_UNI | SC_ASN1_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_CVC_BODY_SIZE 5\nstatic const struct sc_asn1_entry c_asn1_cvc_body[C_ASN1_CVC_BODY_SIZE] = {\n\t{ \"certificateProfileIdentifier\", SC_ASN1_INTEGER, SC_ASN1_APP | 0x1F29, 0, NULL, NULL },\n\t{ \"certificationAuthorityReference\", SC_ASN1_PRINTABLESTRING, SC_ASN1_APP | 2, 0, NULL, NULL },\n\t{ \"publicKey\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 0x1F49, 0, NULL, NULL },\n\t{ \"certificateHolderReference\", SC_ASN1_PRINTABLESTRING, SC_ASN1_APP | 0x1F20, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_CVCERT_SIZE 3\nstatic const struct sc_asn1_entry c_asn1_cvcert[C_ASN1_CVCERT_SIZE] = {\n\t{ \"certificateBody\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 0x1F4E, 0, NULL, NULL },\n\t{ \"signature\", SC_ASN1_OCTET_STRING, SC_ASN1_APP | 0x1F37, SC_ASN1_ALLOC, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_CVC_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_cvc[C_ASN1_CVC_SIZE] = {\n\t{ \"certificate\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 0x1F21, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_AUTHREQ_SIZE 4\nstatic const struct sc_asn1_entry c_asn1_authreq[C_ASN1_AUTHREQ_SIZE] = {\n\t{ \"certificate\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 0x1F21, 0, NULL, NULL },\n\t{ \"outerCAR\", SC_ASN1_PRINTABLESTRING, SC_ASN1_APP | 2, 0, NULL, NULL },\n\t{ \"signature\", SC_ASN1_OCTET_STRING, SC_ASN1_APP | 0x1F37, SC_ASN1_ALLOC, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_REQ_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_req[C_ASN1_REQ_SIZE] = {\n\t{ \"authenticatedrequest\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 7, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n\n\nstatic int read_file(sc_pkcs15_card_t * p15card, u8 fid[2],\n\t\tu8 *efbin, size_t *len, int optional)\n{\n\tsc_path_t path;\n\tint r;\n\n\tsc_path_set(&path, SC_PATH_TYPE_FILE_ID, fid, 2, 0, 0);\n\t/* look this up with our AID */\n\tpath.aid = sc_hsm_aid;\n\t/* we don't have a pre-known size of the file */\n\tpath.count = -1;\n\tif (!p15card->opts.use_file_cache || !efbin\n\t\t\t|| SC_SUCCESS != sc_pkcs15_read_cached_file(p15card, &path, &efbin, len)) {\n\t\t/* avoid re-selection of SC-HSM */\n\t\tpath.aid.len = 0;\n\t\tr = sc_select_file(p15card->card, &path, NULL);\n\t\tif (r < 0) {\n\t\t\tsc_log(p15card->card->ctx, \"Could not select EF\");\n\t\t} else {\n\t\t\tr = sc_read_binary(p15card->card, 0, efbin, *len, 0);\n\t\t}\n\n\t\tif (r < 0) {\n\t\t\tsc_log(p15card->card->ctx, \"Could not read EF\");\n\t\t\tif (!optional) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\t/* optional files are saved as empty files to avoid card\n\t\t\t * transactions. Parsing the file's data will reveal that they were\n\t\t\t * missing. */\n\t\t\t*len = 0;\n\t\t} else {\n\t\t\t*len = r;\n\t\t}\n\n\t\tif (p15card->opts.use_file_cache) {\n\t\t\t/* save this with our AID */\n\t\t\tpath.aid = sc_hsm_aid;\n\t\t\tsc_pkcs15_cache_file(p15card, &path, efbin, *len);\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}\n\n\n\n/*\n * Decode a card verifiable certificate as defined in TR-03110.\n */\nint sc_pkcs15emu_sc_hsm_decode_cvc(sc_pkcs15_card_t * p15card,\n\t\t\t\t\t\t\t\t\t\t\tconst u8 ** buf, size_t *buflen,\n\t\t\t\t\t\t\t\t\t\t\tsc_cvc_t *cvc)\n{\n\tsc_card_t *card = p15card->card;\n\tstruct sc_asn1_entry asn1_req[C_ASN1_REQ_SIZE];\n\tstruct sc_asn1_entry asn1_authreq[C_ASN1_AUTHREQ_SIZE];\n\tstruct sc_asn1_entry asn1_cvc[C_ASN1_CVC_SIZE];\n\tstruct sc_asn1_entry asn1_cvcert[C_ASN1_CVCERT_SIZE];\n\tstruct sc_asn1_entry asn1_cvc_body[C_ASN1_CVC_BODY_SIZE];\n\tstruct sc_asn1_entry asn1_cvc_pubkey[C_ASN1_CVC_PUBKEY_SIZE];\n\tunsigned int cla,tag;\n\tsize_t taglen;\n\tsize_t lenchr = sizeof(cvc->chr);\n\tsize_t lencar = sizeof(cvc->car);\n\tsize_t lenoutercar = sizeof(cvc->outer_car);\n\tconst u8 *tbuf;\n\tint r;\n\n\tmemset(cvc, 0, sizeof(*cvc));\n\tsc_copy_asn1_entry(c_asn1_req, asn1_req);\n\tsc_copy_asn1_entry(c_asn1_authreq, asn1_authreq);\n\tsc_copy_asn1_entry(c_asn1_cvc, asn1_cvc);\n\tsc_copy_asn1_entry(c_asn1_cvcert, asn1_cvcert);\n\tsc_copy_asn1_entry(c_asn1_cvc_body, asn1_cvc_body);\n\tsc_copy_asn1_entry(c_asn1_cvc_pubkey, asn1_cvc_pubkey);\n\n\tsc_format_asn1_entry(asn1_cvc_pubkey    , &cvc->pukoid, NULL, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 1, &cvc->primeOrModulus, &cvc->primeOrModuluslen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 2, &cvc->coefficientAorExponent, &cvc->coefficientAorExponentlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 3, &cvc->coefficientB, &cvc->coefficientBlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 4, &cvc->basePointG, &cvc->basePointGlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 5, &cvc->order, &cvc->orderlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 6, &cvc->publicPoint, &cvc->publicPointlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 7, &cvc->cofactor, &cvc->cofactorlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 8, &cvc->modulusSize, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_cvc_body    , &cvc->cpi, NULL, 0);\n\tsc_format_asn1_entry(asn1_cvc_body + 1, &cvc->car, &lencar, 0);\n\tsc_format_asn1_entry(asn1_cvc_body + 2, &asn1_cvc_pubkey, NULL, 0);\n\tsc_format_asn1_entry(asn1_cvc_body + 3, &cvc->chr, &lenchr, 0);\n\n\tsc_format_asn1_entry(asn1_cvcert    , &asn1_cvc_body, NULL, 0);\n\tsc_format_asn1_entry(asn1_cvcert + 1, &cvc->signature, &cvc->signatureLen, 0);\n\n\tsc_format_asn1_entry(asn1_cvc , &asn1_cvcert, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_authreq    , &asn1_cvcert, NULL, 0);\n\tsc_format_asn1_entry(asn1_authreq + 1, &cvc->outer_car, &lenoutercar, 0);\n\tsc_format_asn1_entry(asn1_authreq + 2, &cvc->outerSignature, &cvc->outerSignatureLen, 0);\n\n\tsc_format_asn1_entry(asn1_req , &asn1_authreq, NULL, 0);\n\n/*\tsc_asn1_print_tags(*buf, *buflen); */\n\n\ttbuf = *buf;\n\tr = sc_asn1_read_tag(&tbuf, *buflen, &cla, &tag, &taglen);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode card verifiable certificate\");\n\n\t/*  Determine if we deal with an authenticated request, plain request or certificate */\n\tif ((cla == (SC_ASN1_TAG_APPLICATION|SC_ASN1_TAG_CONSTRUCTED)) && (tag == 7)) {\n\t\tr = sc_asn1_decode(card->ctx, asn1_req, *buf, *buflen, buf, buflen);\n\t} else {\n\t\tr = sc_asn1_decode(card->ctx, asn1_cvc, *buf, *buflen, buf, buflen);\n\t}\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode card verifiable certificate\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\n\n/*\n * Encode a card verifiable certificate as defined in TR-03110.\n */\nint sc_pkcs15emu_sc_hsm_encode_cvc(sc_pkcs15_card_t * p15card,\n\t\tsc_cvc_t *cvc,\n\t\tu8 ** buf, size_t *buflen)\n{\n\tsc_card_t *card = p15card->card;\n\tstruct sc_asn1_entry asn1_cvc[C_ASN1_CVC_SIZE];\n\tstruct sc_asn1_entry asn1_cvcert[C_ASN1_CVCERT_SIZE];\n\tstruct sc_asn1_entry asn1_cvc_body[C_ASN1_CVC_BODY_SIZE];\n\tstruct sc_asn1_entry asn1_cvc_pubkey[C_ASN1_CVC_PUBKEY_SIZE];\n\tsize_t lenchr;\n\tsize_t lencar;\n\tint r;\n\n\tsc_copy_asn1_entry(c_asn1_cvc, asn1_cvc);\n\tsc_copy_asn1_entry(c_asn1_cvcert, asn1_cvcert);\n\tsc_copy_asn1_entry(c_asn1_cvc_body, asn1_cvc_body);\n\tsc_copy_asn1_entry(c_asn1_cvc_pubkey, asn1_cvc_pubkey);\n\n\tasn1_cvc_pubkey[1].flags = SC_ASN1_OPTIONAL;\n\tasn1_cvcert[1].flags = SC_ASN1_OPTIONAL;\n\n\tsc_format_asn1_entry(asn1_cvc_pubkey    , &cvc->pukoid, NULL, 1);\n\tif (cvc->primeOrModulus && (cvc->primeOrModuluslen > 0)) {\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 1, cvc->primeOrModulus, &cvc->primeOrModuluslen, 1);\n\t}\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 2, cvc->coefficientAorExponent, &cvc->coefficientAorExponentlen, 1);\n\tif (cvc->coefficientB && (cvc->coefficientBlen > 0)) {\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 3, cvc->coefficientB, &cvc->coefficientBlen, 1);\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 4, cvc->basePointG, &cvc->basePointGlen, 1);\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 5, cvc->order, &cvc->orderlen, 1);\n\t\tif (cvc->publicPoint && (cvc->publicPointlen > 0)) {\n\t\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 6, cvc->publicPoint, &cvc->publicPointlen, 1);\n\t\t}\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 7, cvc->cofactor, &cvc->cofactorlen, 1);\n\t}\n\tif (cvc->modulusSize > 0) {\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 8, &cvc->modulusSize, NULL, 1);\n\t}\n\n\tsc_format_asn1_entry(asn1_cvc_body    , &cvc->cpi, NULL, 1);\n\tlencar = strnlen(cvc->car, sizeof cvc->car);\n\tsc_format_asn1_entry(asn1_cvc_body + 1, &cvc->car, &lencar, 1);\n\tsc_format_asn1_entry(asn1_cvc_body + 2, &asn1_cvc_pubkey, NULL, 1);\n\tlenchr = strnlen(cvc->chr, sizeof cvc->chr);\n\tsc_format_asn1_entry(asn1_cvc_body + 3, &cvc->chr, &lenchr, 1);\n\n\tsc_format_asn1_entry(asn1_cvcert    , &asn1_cvc_body, NULL, 1);\n\tif (cvc->signature && (cvc->signatureLen > 0)) {\n\t\tsc_format_asn1_entry(asn1_cvcert + 1, cvc->signature, &cvc->signatureLen, 1);\n\t}\n\n\tsc_format_asn1_entry(asn1_cvc , &asn1_cvcert, NULL, 1);\n\n\tr = sc_asn1_encode(card->ctx, asn1_cvc, buf, buflen);\n\tLOG_TEST_RET(card->ctx, r, \"Could not encode card verifiable certificate\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\n\nint sc_pkcs15emu_sc_hsm_get_curve(struct ec_curve **curve, u8 *oid, size_t oidlen)\n{\n\tint i;\n\n\tfor (i = 0; curves[i].oid.value; i++) {\n\t\tif ((curves[i].oid.len == oidlen) && !memcmp(curves[i].oid.value, oid, oidlen)) {\n\t\t\t*curve = &curves[i];\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_INVALID_DATA;\n}\n\n\n\nint sc_pkcs15emu_sc_hsm_get_curve_oid(sc_cvc_t *cvc, const struct sc_lv_data **oid)\n{\n\tint i;\n\n\tfor (i = 0; curves[i].oid.value; i++) {\n\t\tif ((curves[i].prime.len == cvc->primeOrModuluslen) && !memcmp(curves[i].prime.value, cvc->primeOrModulus, cvc->primeOrModuluslen)) {\n\t\t\t*oid = &curves[i].oid;\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_INVALID_DATA;\n}\n\n\n\nstatic int sc_pkcs15emu_sc_hsm_get_rsa_public_key(struct sc_context *ctx, sc_cvc_t *cvc, struct sc_pkcs15_pubkey *pubkey)\n{\n\tpubkey->algorithm = SC_ALGORITHM_RSA;\n\n\tpubkey->alg_id = (struct sc_algorithm_id *)calloc(1, sizeof(struct sc_algorithm_id));\n\tif (!pubkey->alg_id)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tpubkey->alg_id->algorithm = SC_ALGORITHM_RSA;\n\n\tpubkey->u.rsa.modulus.len\t= cvc->primeOrModuluslen;\n\tpubkey->u.rsa.modulus.data\t= malloc(pubkey->u.rsa.modulus.len);\n\tpubkey->u.rsa.exponent.len\t= cvc->coefficientAorExponentlen;\n\tpubkey->u.rsa.exponent.data\t= malloc(pubkey->u.rsa.exponent.len);\n\tif (!pubkey->u.rsa.modulus.data || !pubkey->u.rsa.exponent.data)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tmemcpy(pubkey->u.rsa.exponent.data, cvc->coefficientAorExponent, pubkey->u.rsa.exponent.len);\n\tmemcpy(pubkey->u.rsa.modulus.data, cvc->primeOrModulus, pubkey->u.rsa.modulus.len);\n\n\treturn SC_SUCCESS;\n}\n\n\n\nstatic int sc_pkcs15emu_sc_hsm_get_ec_public_key(struct sc_context *ctx, sc_cvc_t *cvc, struct sc_pkcs15_pubkey *pubkey)\n{\n\tstruct sc_ec_parameters *ecp;\n\tconst struct sc_lv_data *oid;\n\tint r;\n\n\tpubkey->algorithm = SC_ALGORITHM_EC;\n\n\tr = sc_pkcs15emu_sc_hsm_get_curve_oid(cvc, &oid);\n\tif (r != SC_SUCCESS)\n\t\treturn r;\n\n\tecp = calloc(1, sizeof(struct sc_ec_parameters));\n\tif (!ecp)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tecp->der.len = oid->len + 2;\n\tecp->der.value = calloc(ecp->der.len, 1);\n\tif (!ecp->der.value) {\n\t\tfree(ecp);\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\t*(ecp->der.value + 0) = 0x06;\n\t*(ecp->der.value + 1) = (u8)oid->len;\n\tmemcpy(ecp->der.value + 2, oid->value, oid->len);\n\tecp->type = 1;\t\t// Named curve\n\n\tpubkey->alg_id = (struct sc_algorithm_id *)calloc(1, sizeof(struct sc_algorithm_id));\n\tif (!pubkey->alg_id) {\n\t\tfree(ecp->der.value);\n\t\tfree(ecp);\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\tpubkey->alg_id->algorithm = SC_ALGORITHM_EC;\n\tpubkey->alg_id->params = ecp;\n\n\tpubkey->u.ec.ecpointQ.value = malloc(cvc->publicPointlen);\n\tif (!pubkey->u.ec.ecpointQ.value)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\tmemcpy(pubkey->u.ec.ecpointQ.value, cvc->publicPoint, cvc->publicPointlen);\n\tpubkey->u.ec.ecpointQ.len = cvc->publicPointlen;\n\n\tpubkey->u.ec.params.der.value = malloc(ecp->der.len);\n\tif (!pubkey->u.ec.params.der.value)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\tmemcpy(pubkey->u.ec.params.der.value, ecp->der.value, ecp->der.len);\n\tpubkey->u.ec.params.der.len = ecp->der.len;\n\n\t/* FIXME: check return value? */\n\tsc_pkcs15_fix_ec_parameters(ctx, &pubkey->u.ec.params);\n\n\treturn SC_SUCCESS;\n}\n\n\n\nint sc_pkcs15emu_sc_hsm_get_public_key(struct sc_context *ctx, sc_cvc_t *cvc, struct sc_pkcs15_pubkey *pubkey)\n{\n\tif (cvc->publicPoint && cvc->publicPointlen) {\n\t\treturn sc_pkcs15emu_sc_hsm_get_ec_public_key(ctx, cvc, pubkey);\n\t} else {\n\t\treturn sc_pkcs15emu_sc_hsm_get_rsa_public_key(ctx, cvc, pubkey);\n\t}\n}\n\n\n\nvoid sc_pkcs15emu_sc_hsm_free_cvc(sc_cvc_t *cvc)\n{\n\tif (cvc->signature) {\n\t\tfree(cvc->signature);\n\t\tcvc->signature = NULL;\n\t}\n\tif (cvc->primeOrModulus) {\n\t\tfree(cvc->primeOrModulus);\n\t\tcvc->primeOrModulus = NULL;\n\t}\n\tif (cvc->coefficientAorExponent) {\n\t\tfree(cvc->coefficientAorExponent);\n\t\tcvc->coefficientAorExponent = NULL;\n\t}\n\tif (cvc->coefficientB) {\n\t\tfree(cvc->coefficientB);\n\t\tcvc->coefficientB = NULL;\n\t}\n\tif (cvc->basePointG) {\n\t\tfree(cvc->basePointG);\n\t\tcvc->basePointG = NULL;\n\t}\n\tif (cvc->order) {\n\t\tfree(cvc->order);\n\t\tcvc->order = NULL;\n\t}\n\tif (cvc->publicPoint) {\n\t\tfree(cvc->publicPoint);\n\t\tcvc->publicPoint = NULL;\n\t}\n\tif (cvc->cofactor) {\n\t\tfree(cvc->cofactor);\n\t\tcvc->cofactor = NULL;\n\t}\n}\n\n\n\nstatic int sc_pkcs15emu_sc_hsm_add_pubkey(sc_pkcs15_card_t *p15card, u8 *efbin, size_t len, sc_pkcs15_prkey_info_t *key_info, char *label)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_pubkey_info_t pubkey_info;\n\tsc_pkcs15_object_t pubkey_obj;\n\tstruct sc_pkcs15_pubkey pubkey;\n\tsc_cvc_t cvc;\n\tu8 *cvcpo;\n\tint r;\n\n\tcvcpo = efbin;\n\n\tmemset(&cvc, 0, sizeof(cvc));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&cvcpo, &len, &cvc);\n\tLOG_TEST_RET(ctx, r, \"Could decode certificate signing request\");\n\n\tmemset(&pubkey, 0, sizeof(pubkey));\n\tr = sc_pkcs15emu_sc_hsm_get_public_key(ctx, &cvc, &pubkey);\n\tLOG_TEST_RET(card->ctx, r, \"Could not extract public key\");\n\n\tmemset(&pubkey_info, 0, sizeof(pubkey_info));\n\tmemset(&pubkey_obj, 0, sizeof(pubkey_obj));\n\n\tr = sc_pkcs15_encode_pubkey(ctx, &pubkey, &pubkey_obj.content.value, &pubkey_obj.content.len);\n\tLOG_TEST_RET(ctx, r, \"Could not encode public key\");\n\tr = sc_pkcs15_encode_pubkey(ctx, &pubkey, &pubkey_info.direct.raw.value, &pubkey_info.direct.raw.len);\n\tLOG_TEST_RET(ctx, r, \"Could not encode public key\");\n\tr = sc_pkcs15_encode_pubkey_as_spki(ctx, &pubkey, &pubkey_info.direct.spki.value, &pubkey_info.direct.spki.len);\n\tLOG_TEST_RET(ctx, r, \"Could not encode public key\");\n\n\tpubkey_info.id = key_info->id;\n\tstrlcpy(pubkey_obj.label, label, sizeof(pubkey_obj.label));\n\n\tif (pubkey.algorithm == SC_ALGORITHM_RSA) {\n\t\tpubkey_info.modulus_length = pubkey.u.rsa.modulus.len << 3;\n\t\tpubkey_info.usage = SC_PKCS15_PRKEY_USAGE_ENCRYPT|SC_PKCS15_PRKEY_USAGE_VERIFY|SC_PKCS15_PRKEY_USAGE_WRAP;\n\t\tr = sc_pkcs15emu_add_rsa_pubkey(p15card, &pubkey_obj, &pubkey_info);\n\t} else {\n\t\t/* TODO fix if support of non multiple of 8 curves are added */\n\t\tpubkey_info.field_length = cvc.primeOrModuluslen << 3;\n\t\tpubkey_info.usage = SC_PKCS15_PRKEY_USAGE_VERIFY;\n\t\tr = sc_pkcs15emu_add_ec_pubkey(p15card, &pubkey_obj, &pubkey_info);\n\t}\n\tLOG_TEST_RET(ctx, r, \"Could not add public key\");\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&cvc);\n\tsc_pkcs15_erase_pubkey(&pubkey);\n\n\treturn SC_SUCCESS;\n}\n\n\n\n/*\n * Add a key and the key description in PKCS#15 format to the framework\n */\nstatic int sc_pkcs15emu_sc_hsm_add_prkd(sc_pkcs15_card_t * p15card, u8 keyid) {\n\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_cert_info_t cert_info;\n\tsc_pkcs15_object_t cert_obj;\n\tstruct sc_pkcs15_object prkd;\n\tsc_pkcs15_prkey_info_t *key_info;\n\tu8 fid[2];\n\t/* enough to hold a complete certificate */\n\tu8 efbin[4096];\n\tu8 *ptr;\n\tsize_t len;\n\tint r;\n\n\tfid[0] = PRKD_PREFIX;\n\tfid[1] = keyid;\n\n\t/* Try to select a related EF containing the PKCS#15 description of the key */\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.PRKD\");\n\n\tptr = efbin;\n\n\tmemset(&prkd, 0, sizeof(prkd));\n\tr = sc_pkcs15_decode_prkdf_entry(p15card, &prkd, (const u8 **)&ptr, &len);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.PRKD\");\n\n\t/* All keys require user PIN authentication */\n\tprkd.auth_id.len = 1;\n\tprkd.auth_id.value[0] = 1;\n\n\t/*\n\t * Set private key flag as all keys are private anyway\n\t */\n\tprkd.flags |= SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tkey_info = (sc_pkcs15_prkey_info_t *)prkd.data;\n\tkey_info->key_reference = keyid;\n\tkey_info->path.aid.len = 0;\n\n\tif (prkd.type == SC_PKCS15_TYPE_PRKEY_RSA) {\n\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkd, key_info);\n\t} else {\n\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkd, key_info);\n\t}\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not add private key to framework\");\n\n\t/* Check if we also have a certificate for the private key */\n\tfid[0] = EE_CERTIFICATE_PREFIX;\n\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 0);\n\tLOG_TEST_RET(card->ctx, r, \"Could not read EF\");\n\n\tif (efbin[0] == 0x67) {\t\t/* Decode CSR and create public key object */\n\t\tsc_pkcs15emu_sc_hsm_add_pubkey(p15card, efbin, len, key_info, prkd.label);\n\t\tfree(key_info);\n\t\treturn SC_SUCCESS;\t\t/* Ignore any errors */\n\t}\n\n\tif (efbin[0] != 0x30) {\n\t\tfree(key_info);\n\t\treturn SC_SUCCESS;\n\t}\n\n\tmemset(&cert_info, 0, sizeof(cert_info));\n\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\tcert_info.id = key_info->id;\n\tsc_path_set(&cert_info.path, SC_PATH_TYPE_FILE_ID, fid, 2, 0, 0);\n\tcert_info.path.count = -1;\n\tif (p15card->opts.use_file_cache) {\n\t\t/* look this up with our AID, which should already be cached from the\n\t\t * call to `read_file`. This may have the side effect that OpenSC's\n\t\t * caching layer re-selects our applet *if the cached file cannot be\n\t\t * found/used* and we may loose the authentication status. We assume\n\t\t * that caching works perfectly without this side effect. */\n\t\tcert_info.path.aid = sc_hsm_aid;\n\t}\n\n\tstrlcpy(cert_obj.label, prkd.label, sizeof(cert_obj.label));\n\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\n\tfree(key_info);\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not add certificate\");\n\n\treturn SC_SUCCESS;\n}\n\n\n\n/*\n * Add a data object and description in PKCS#15 format to the framework\n */\nstatic int sc_pkcs15emu_sc_hsm_add_dcod(sc_pkcs15_card_t * p15card, u8 id) {\n\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_data_info_t *data_info;\n\tsc_pkcs15_object_t data_obj;\n\tu8 fid[2];\n\tu8 efbin[512];\n\tconst u8 *ptr;\n\tsize_t len;\n\tint r;\n\n\tfid[0] = DCOD_PREFIX;\n\tfid[1] = id;\n\n\t/* Try to select a related EF containing the PKCS#15 description of the data */\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.DCOD\");\n\n\tptr = efbin;\n\n\tmemset(&data_obj, 0, sizeof(data_obj));\n\tr = sc_pkcs15_decode_dodf_entry(p15card, &data_obj, &ptr, &len);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode optional EF.DCOD\");\n\n\tdata_info = (sc_pkcs15_data_info_t *)data_obj.data;\n\n\tr = sc_pkcs15emu_add_data_object(p15card, &data_obj, data_info);\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not add data object to framework\");\n\n\treturn SC_SUCCESS;\n}\n\n\n\n/*\n * Add a unrelated certificate object and description in PKCS#15 format to the framework\n */\nstatic int sc_pkcs15emu_sc_hsm_add_cd(sc_pkcs15_card_t * p15card, u8 id) {\n\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_cert_info_t *cert_info;\n\tsc_pkcs15_object_t obj;\n\tu8 fid[2];\n\tu8 efbin[512];\n\tconst u8 *ptr;\n\tsize_t len;\n\tint r;\n\n\tfid[0] = CD_PREFIX;\n\tfid[1] = id;\n\n\t/* Try to select a related EF containing the PKCS#15 description of the data */\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.DCOD\");\n\n\tptr = efbin;\n\n\tmemset(&obj, 0, sizeof(obj));\n\tr = sc_pkcs15_decode_cdf_entry(p15card, &obj, &ptr, &len);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.CDOD\");\n\n\tcert_info = (sc_pkcs15_cert_info_t *)obj.data;\n\n\tr = sc_pkcs15emu_add_x509_cert(p15card, &obj, cert_info);\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not add data object to framework\");\n\n\treturn SC_SUCCESS;\n}\n\n\n\nstatic int sc_pkcs15emu_sc_hsm_read_tokeninfo (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tint r;\n\tu8 efbin[512];\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* Read token info */\n\tlen = sizeof efbin;\n\tr = read_file(p15card, (u8 *) \"\\x2F\\x03\", efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.TokenInfo\");\n\n\tr = sc_pkcs15_parse_tokeninfo(card->ctx, p15card->tokeninfo, efbin, len);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.TokenInfo\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\n\n/*\n * Initialize PKCS#15 emulation with user PIN, private keys, certificate and data objects\n *\n */\nstatic int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"Could not select SmartCard-HSM application\");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n\n\t\t/* save EF_C_DevAut for further use */\n\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\tif (ptr) {\n\t\t\tmemcpy(ptr, efbin, len);\n\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \"UserPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \"SOPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \"Could not enumerate file and key identifier\");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Error %d adding elements to framework\", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\n\nint sc_pkcs15emu_sc_hsm_init_ex(sc_pkcs15_card_t *p15card,\n\t\t\t\tstruct sc_aid *aid,\n\t\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\tif (opts && (opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)) {\n\t\treturn sc_pkcs15emu_sc_hsm_init(p15card);\n\t} else {\n\t\tif (p15card->card->type != SC_CARD_TYPE_SC_HSM\n\t\t\t\t&& p15card->card->type != SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t\t&& p15card->card->type != SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\t}\n\t\treturn sc_pkcs15emu_sc_hsm_init(p15card);\n\t}\n}\n", "/*\n * sc.c: General functions\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n#ifdef ENABLE_OPENSSL\n#include <openssl/crypto.h>     /* for OPENSSL_cleanse */\n#endif\n\n#include \"internal.h\"\n\n#ifdef PACKAGE_VERSION\nstatic const char *sc_version = PACKAGE_VERSION;\n#else\nstatic const char *sc_version = \"(undef)\";\n#endif\n\nconst char *sc_get_version(void)\n{\n    return sc_version;\n}\n\nint sc_hex_to_bin(const char *in, u8 *out, size_t *outlen)\n{\n\tint err = SC_SUCCESS;\n\tsize_t left, count = 0, in_len;\n\n\tif (in == NULL || out == NULL || outlen == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tleft = *outlen;\n\tin_len = strlen(in);\n\n\twhile (*in != '\\0') {\n\t\tint byte = 0, nybbles = 2;\n\n\t\twhile (nybbles-- && *in && *in != ':' && *in != ' ') {\n\t\t\tchar c;\n\t\t\tbyte <<= 4;\n\t\t\tc = *in++;\n\t\t\tif ('0' <= c && c <= '9')\n\t\t\t\tc -= '0';\n\t\t\telse\n\t\t\tif ('a' <= c && c <= 'f')\n\t\t\t\tc = c - 'a' + 10;\n\t\t\telse\n\t\t\tif ('A' <= c && c <= 'F')\n\t\t\t\tc = c - 'A' + 10;\n\t\t\telse {\n\t\t\t\terr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbyte |= c;\n\t\t}\n\n\t\t/* Detect premature end of string before byte is complete */\n\t\tif (in_len > 1 && *in == '\\0' && nybbles >= 0) {\n\t\t\terr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*in == ':' || *in == ' ')\n\t\t\tin++;\n\t\tif (left <= 0) {\n\t\t\terr = SC_ERROR_BUFFER_TOO_SMALL;\n\t\t\tbreak;\n\t\t}\n\t\tout[count++] = (u8) byte;\n\t\tleft--;\n\t}\n\nout:\n\t*outlen = count;\n\treturn err;\n}\n\nint sc_bin_to_hex(const u8 *in, size_t in_len, char *out, size_t out_len,\n\t\t  int in_sep)\n{\n\tunsigned int\tn, sep_len;\n\tchar\t\t*pos, *end, sep;\n\n\tsep = (char)in_sep;\n\tsep_len = sep > 0 ? 1 : 0;\n\tpos = out;\n\tend = out + out_len;\n\tfor (n = 0; n < in_len; n++) {\n\t\tif (pos + 3 + sep_len >= end)\n\t\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t\tif (n && sep_len)\n\t\t\t*pos++ = sep;\n\t\tsprintf(pos, \"%02x\", in[n]);\n\t\tpos += 2;\n\t}\n\t*pos = '\\0';\n\treturn SC_SUCCESS;\n}\n\n/*\n * Right trim all non-printable characters\n */\nsize_t sc_right_trim(u8 *buf, size_t len) {\n\n\tsize_t i;\n\n\tif (!buf)\n\t\treturn 0;\n\n\tif (len > 0) {\n\t\tfor(i = len-1; i > 0; i--) {\n\t\t\tif(!isprint(buf[i])) {\n\t\t\t\tbuf[i] = '\\0';\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn len;\n}\n\nu8 *ulong2bebytes(u8 *buf, unsigned long x)\n{\n\tif (buf != NULL) {\n\t\tbuf[3] = (u8) (x & 0xff);\n\t\tbuf[2] = (u8) ((x >> 8) & 0xff);\n\t\tbuf[1] = (u8) ((x >> 16) & 0xff);\n\t\tbuf[0] = (u8) ((x >> 24) & 0xff);\n\t}\n\treturn buf;\n}\n\nu8 *ushort2bebytes(u8 *buf, unsigned short x)\n{\n\tif (buf != NULL) {\n\t\tbuf[1] = (u8) (x & 0xff);\n\t\tbuf[0] = (u8) ((x >> 8) & 0xff);\n\t}\n\treturn buf;\n}\n\nunsigned long bebytes2ulong(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0UL;\n\treturn (unsigned long) (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]);\n}\n\nunsigned short bebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short) (buf[0] << 8 | buf[1]);\n}\n\nunsigned short lebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short)buf[1] << 8 | (unsigned short)buf[0];\n}\n\nvoid sc_init_oid(struct sc_object_id *oid)\n{\n\tint ii;\n\n\tif (!oid)\n\t\treturn;\n\tfor (ii=0; ii<SC_MAX_OBJECT_ID_OCTETS; ii++)\n\t\toid->value[ii] = -1;\n}\n\nint sc_format_oid(struct sc_object_id *oid, const char *in)\n{\n\tint        ii, ret = SC_ERROR_INVALID_ARGUMENTS;\n\tconst char *p;\n\tchar       *q;\n\n\tif (oid == NULL || in == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tsc_init_oid(oid);\n\n\tp = in;\n\tfor (ii=0; ii < SC_MAX_OBJECT_ID_OCTETS; ii++)   {\n\t\toid->value[ii] = strtol(p, &q, 10);\n\t\tif (!*q)\n\t\t\tbreak;\n\n\t\tif (!(q[0] == '.' && isdigit(q[1])))\n\t\t\tgoto out;\n\n\t\tp = q + 1;\n\t}\n\n\tif (!sc_valid_oid(oid))\n\t\tgoto out;\n\n\tret = SC_SUCCESS;\nout:\n\tif (ret)\n\t\tsc_init_oid(oid);\n\n\treturn ret;\n}\n\nint sc_compare_oid(const struct sc_object_id *oid1, const struct sc_object_id *oid2)\n{\n\tint i;\n\n\tif (oid1 == NULL || oid2 == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++)   {\n\t\tif (oid1->value[i] != oid2->value[i])\n\t\t\treturn 0;\n\t\tif (oid1->value[i] == -1)\n\t\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n\nint sc_valid_oid(const struct sc_object_id *oid)\n{\n\tint ii;\n\n\tif (!oid)\n\t\treturn 0;\n\tif (oid->value[0] == -1 || oid->value[1] == -1)\n\t\treturn 0;\n\tif (oid->value[0] > 2 || oid->value[1] > 39)\n\t\treturn 0;\n\tfor (ii=0;ii<SC_MAX_OBJECT_ID_OCTETS;ii++)\n\t\tif (oid->value[ii])\n\t\t\tbreak;\n\tif (ii==SC_MAX_OBJECT_ID_OCTETS)\n\t\treturn 0;\n\treturn 1;\n}\n\n\nint sc_detect_card_presence(sc_reader_t *reader)\n{\n\tint r;\n\tLOG_FUNC_CALLED(reader->ctx);\n\tif (reader->ops->detect_card_presence == NULL)\n\t\tLOG_FUNC_RETURN(reader->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tr = reader->ops->detect_card_presence(reader);\n\tLOG_FUNC_RETURN(reader->ctx, r);\n}\n\nint sc_path_set(sc_path_t *path, int type, const u8 *id, size_t id_len,\n\tint idx, int count)\n{\n\tif (path == NULL || id == NULL || id_len == 0 || id_len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tmemset(path, 0, sizeof(*path));\n\tmemcpy(path->value, id, id_len);\n\tpath->len   = id_len;\n\tpath->type  = type;\n\tpath->index = idx;\n\tpath->count = count;\n\n\treturn SC_SUCCESS;\n}\n\nvoid sc_format_path(const char *str, sc_path_t *path)\n{\n\tint type = SC_PATH_TYPE_PATH;\n\n\tif (path) {\n\t\tmemset(path, 0, sizeof(*path));\n\t\tif (*str == 'i' || *str == 'I') {\n\t\t\ttype = SC_PATH_TYPE_FILE_ID;\n\t\t\tstr++;\n\t\t}\n\t\tpath->len = sizeof(path->value);\n\t\tif (sc_hex_to_bin(str, path->value, &path->len) >= 0) {\n\t\t\tpath->type = type;\n\t\t}\n\t\tpath->count = -1;\n\t}\n}\n\nint sc_append_path(sc_path_t *dest, const sc_path_t *src)\n{\n\treturn sc_concatenate_path(dest, dest, src);\n}\n\nint sc_append_path_id(sc_path_t *dest, const u8 *id, size_t idlen)\n{\n\tif (dest->len + idlen > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemcpy(dest->value + dest->len, id, idlen);\n\tdest->len += idlen;\n\treturn SC_SUCCESS;\n}\n\nint sc_append_file_id(sc_path_t *dest, unsigned int fid)\n{\n\tu8 id[2] = { fid >> 8, fid & 0xff };\n\n\treturn sc_append_path_id(dest, id, 2);\n}\n\nint sc_concatenate_path(sc_path_t *d, const sc_path_t *p1, const sc_path_t *p2)\n{\n\tsc_path_t tpath;\n\n\tif (d == NULL || p1 == NULL || p2 == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tif (p1->type == SC_PATH_TYPE_DF_NAME || p2->type == SC_PATH_TYPE_DF_NAME)\n\t\t/* we do not support concatenation of AIDs at the moment */\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\n\tif (p1->len + p2->len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tmemset(&tpath, 0, sizeof(sc_path_t));\n\tmemcpy(tpath.value, p1->value, p1->len);\n\tmemcpy(tpath.value + p1->len, p2->value, p2->len);\n\ttpath.len  = p1->len + p2->len;\n\ttpath.type = SC_PATH_TYPE_PATH;\n\t/* use 'index' and 'count' entry of the second path object */\n\ttpath.index = p2->index;\n\ttpath.count = p2->count;\n\t/* the result is currently always as path */\n\ttpath.type  = SC_PATH_TYPE_PATH;\n\n\t*d = tpath;\n\n\treturn SC_SUCCESS;\n}\n\nconst char *sc_print_path(const sc_path_t *path)\n{\n\tstatic char buffer[SC_MAX_PATH_STRING_SIZE + SC_MAX_AID_STRING_SIZE];\n\n\tif (sc_path_print(buffer, sizeof(buffer), path) != SC_SUCCESS)\n\t\tbuffer[0] = '\\0';\n\n\treturn buffer;\n}\n\nint sc_path_print(char *buf, size_t buflen, const sc_path_t *path)\n{\n\tsize_t i;\n\n\tif (buf == NULL || path == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tif (buflen < path->len * 2 + path->aid.len * 2 + 1)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\n\tbuf[0] = '\\0';\n\tif (path->aid.len)   {\n\t\tfor (i = 0; i < path->aid.len; i++)\n\t\t\tsnprintf(buf + strlen(buf), buflen - strlen(buf), \"%02x\", path->aid.value[i]);\n\t\tsnprintf(buf + strlen(buf), buflen - strlen(buf), \"::\");\n\t}\n\n\tfor (i = 0; i < path->len; i++)\n\t\tsnprintf(buf + strlen(buf), buflen - strlen(buf), \"%02x\", path->value[i]);\n\tif (!path->aid.len && path->type == SC_PATH_TYPE_DF_NAME)\n\t\tsnprintf(buf + strlen(buf), buflen - strlen(buf), \"::\");\n\n\treturn SC_SUCCESS;\n}\n\nint sc_compare_path(const sc_path_t *path1, const sc_path_t *path2)\n{\n\treturn path1->len == path2->len\n\t\t&& !memcmp(path1->value, path2->value, path1->len);\n}\n\nint sc_compare_path_prefix(const sc_path_t *prefix, const sc_path_t *path)\n{\n\tsc_path_t tpath;\n\n\tif (prefix->len > path->len)\n\t\treturn 0;\n\n\ttpath     = *path;\n\ttpath.len = prefix->len;\n\n\treturn sc_compare_path(&tpath, prefix);\n}\n\nconst sc_path_t *sc_get_mf_path(void)\n{\n\tstatic const sc_path_t mf_path = {\n\t\t{0x3f, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 2,\n\t\t0,\n\t\t0,\n\t\tSC_PATH_TYPE_PATH,\n\t\t{{0},0}\n\t};\n\treturn &mf_path;\n}\n\nint sc_file_add_acl_entry(sc_file_t *file, unsigned int operation,\n                          unsigned int method, unsigned long key_ref)\n{\n\tsc_acl_entry_t *p, *_new;\n\n\tif (file == NULL || operation >= SC_MAX_AC_OPS) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tswitch (method) {\n\tcase SC_AC_NEVER:\n\t\tsc_file_clear_acl_entries(file, operation);\n\t\tfile->acl[operation] = (sc_acl_entry_t *) 1;\n\t\treturn SC_SUCCESS;\n\tcase SC_AC_NONE:\n\t\tsc_file_clear_acl_entries(file, operation);\n\t\tfile->acl[operation] = (sc_acl_entry_t *) 2;\n\t\treturn SC_SUCCESS;\n\tcase SC_AC_UNKNOWN:\n\t\tsc_file_clear_acl_entries(file, operation);\n\t\tfile->acl[operation] = (sc_acl_entry_t *) 3;\n\t\treturn SC_SUCCESS;\n\tdefault:\n\t\t/* NONE and UNKNOWN get zapped when a new AC is added.\n\t\t * If the ACL is NEVER, additional entries will be\n\t\t * dropped silently. */\n\t\tif (file->acl[operation] == (sc_acl_entry_t *) 1)\n\t\t\treturn SC_SUCCESS;\n\t\tif (file->acl[operation] == (sc_acl_entry_t *) 2\n\t\t || file->acl[operation] == (sc_acl_entry_t *) 3)\n\t\t\tfile->acl[operation] = NULL;\n\t}\n\n\t/* If the entry is already present (e.g. due to the mapping)\n\t * of the card's AC with OpenSC's), don't add it again. */\n\tfor (p = file->acl[operation]; p != NULL; p = p->next) {\n\t\tif ((p->method == method) && (p->key_ref == key_ref))\n\t\t\treturn SC_SUCCESS;\n\t}\n\n\t_new = malloc(sizeof(sc_acl_entry_t));\n\tif (_new == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t_new->method = method;\n\t_new->key_ref = key_ref;\n\t_new->next = NULL;\n\n\tp = file->acl[operation];\n\tif (p == NULL) {\n\t\tfile->acl[operation] = _new;\n\t\treturn SC_SUCCESS;\n\t}\n\twhile (p->next != NULL)\n\t\tp = p->next;\n\tp->next = _new;\n\n\treturn SC_SUCCESS;\n}\n\nconst sc_acl_entry_t * sc_file_get_acl_entry(const sc_file_t *file,\n\t\t\t\t\t\t  unsigned int operation)\n{\n\tsc_acl_entry_t *p;\n\tstatic const sc_acl_entry_t e_never = {\n\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE, {{0, 0, 0, {0}}}, NULL\n\t};\n\tstatic const sc_acl_entry_t e_none = {\n\t\tSC_AC_NONE, SC_AC_KEY_REF_NONE, {{0, 0, 0, {0}}}, NULL\n\t};\n\tstatic const sc_acl_entry_t e_unknown = {\n\t\tSC_AC_UNKNOWN, SC_AC_KEY_REF_NONE, {{0, 0, 0, {0}}}, NULL\n\t};\n\n\tif (file == NULL || operation >= SC_MAX_AC_OPS) {\n\t\treturn NULL;\n\t}\n\n\tp = file->acl[operation];\n\tif (p == (sc_acl_entry_t *) 1)\n\t\treturn &e_never;\n\tif (p == (sc_acl_entry_t *) 2)\n\t\treturn &e_none;\n\tif (p == (sc_acl_entry_t *) 3)\n\t\treturn &e_unknown;\n\n\treturn file->acl[operation];\n}\n\nvoid sc_file_clear_acl_entries(sc_file_t *file, unsigned int operation)\n{\n\tsc_acl_entry_t *e;\n\n\tif (file == NULL || operation >= SC_MAX_AC_OPS) {\n\t\treturn;\n\t}\n\n\te = file->acl[operation];\n\tif (e == (sc_acl_entry_t *) 1 ||\n\t    e == (sc_acl_entry_t *) 2 ||\n\t    e == (sc_acl_entry_t *) 3) {\n\t\tfile->acl[operation] = NULL;\n\t\treturn;\n\t}\n\n\twhile (e != NULL) {\n\t\tsc_acl_entry_t *tmp = e->next;\n\t\tfree(e);\n\t\te = tmp;\n\t}\n\tfile->acl[operation] = NULL;\n}\n\nsc_file_t * sc_file_new(void)\n{\n\tsc_file_t *file = (sc_file_t *)calloc(1, sizeof(sc_file_t));\n\tif (file == NULL)\n\t\treturn NULL;\n\n\tfile->magic = SC_FILE_MAGIC;\n\treturn file;\n}\n\nvoid sc_file_free(sc_file_t *file)\n{\n\tunsigned int i;\n\tif (file == NULL || !sc_file_valid(file))\n\t\treturn;\n\tfile->magic = 0;\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_clear_acl_entries(file, i);\n\tif (file->sec_attr)\n\t\tfree(file->sec_attr);\n\tif (file->prop_attr)\n\t\tfree(file->prop_attr);\n\tif (file->type_attr)\n\t\tfree(file->type_attr);\n\tif (file->encoded_content)\n\t\tfree(file->encoded_content);\n\tfree(file);\n}\n\nvoid sc_file_dup(sc_file_t **dest, const sc_file_t *src)\n{\n\tsc_file_t *newf;\n\tconst sc_acl_entry_t *e;\n\tunsigned int op;\n\n\t*dest = NULL;\n\tif (!sc_file_valid(src))\n\t\treturn;\n\tnewf = sc_file_new();\n\tif (newf == NULL)\n\t\treturn;\n\t*dest = newf;\n\n\tmemcpy(&newf->path, &src->path, sizeof(struct sc_path));\n\tmemcpy(&newf->name, &src->name, sizeof(src->name));\n\tnewf->namelen = src->namelen;\n\tnewf->type    = src->type;\n\tnewf->shareable    = src->shareable;\n\tnewf->ef_structure = src->ef_structure;\n\tnewf->size    = src->size;\n\tnewf->id      = src->id;\n\tnewf->status  = src->status;\n\tfor (op = 0; op < SC_MAX_AC_OPS; op++) {\n\t\tnewf->acl[op] = NULL;\n\t\te = sc_file_get_acl_entry(src, op);\n\t\tif (e != NULL) {\n\t\t\tif (sc_file_add_acl_entry(newf, op, e->method, e->key_ref) < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\tnewf->record_length = src->record_length;\n\tnewf->record_count  = src->record_count;\n\n\tif (sc_file_set_sec_attr(newf, src->sec_attr, src->sec_attr_len) < 0)\n\t\tgoto err;\n\tif (sc_file_set_prop_attr(newf, src->prop_attr, src->prop_attr_len) < 0)\n\t\tgoto err;\n\tif (sc_file_set_type_attr(newf, src->type_attr, src->type_attr_len) < 0)\n\t\tgoto err;\n\tif (sc_file_set_content(newf, src->encoded_content, src->encoded_content_len) < 0)\n\t\tgoto err;\n\treturn;\nerr:\n\tsc_file_free(newf);\n\t*dest = NULL;\n}\n\nint sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}\n\nint sc_file_set_prop_attr(sc_file_t *file, const u8 *prop_attr,\n\t\t\t size_t prop_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (prop_attr == NULL) {\n\t\tif (file->prop_attr != NULL)\n\t\t\tfree(file->prop_attr);\n\t\tfile->prop_attr = NULL;\n\t\tfile->prop_attr_len = 0;\n\t\treturn SC_SUCCESS;\n\t }\n\ttmp = (u8 *) realloc(file->prop_attr, prop_attr_len);\n\tif (!tmp) {\n\t\tif (file->prop_attr)\n\t\t\tfree(file->prop_attr);\n\t\tfile->prop_attr = NULL;\n\t\tfile->prop_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->prop_attr = tmp;\n\tmemcpy(file->prop_attr, prop_attr, prop_attr_len);\n\tfile->prop_attr_len = prop_attr_len;\n\n\treturn SC_SUCCESS;\n}\n\nint sc_file_set_type_attr(sc_file_t *file, const u8 *type_attr,\n\t\t\t size_t type_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (type_attr == NULL) {\n\t\tif (file->type_attr != NULL)\n\t\t\tfree(file->type_attr);\n\t\tfile->type_attr = NULL;\n\t\tfile->type_attr_len = 0;\n\t\treturn SC_SUCCESS;\n\t }\n\ttmp = (u8 *) realloc(file->type_attr, type_attr_len);\n\tif (!tmp) {\n\t\tif (file->type_attr)\n\t\t\tfree(file->type_attr);\n\t\tfile->type_attr = NULL;\n\t\tfile->type_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->type_attr = tmp;\n\tmemcpy(file->type_attr, type_attr, type_attr_len);\n\tfile->type_attr_len = type_attr_len;\n\n\treturn SC_SUCCESS;\n}\n\n\nint sc_file_set_content(sc_file_t *file, const u8 *content,\n\t\t\t size_t content_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (content == NULL) {\n\t\tif (file->encoded_content != NULL)\n\t\t\tfree(file->encoded_content);\n\t\tfile->encoded_content = NULL;\n\t\tfile->encoded_content_len = 0;\n\t\treturn SC_SUCCESS;\n\t}\n\n\ttmp = (u8 *) realloc(file->encoded_content, content_len);\n\tif (!tmp) {\n\t\tif (file->encoded_content)\n\t\t\tfree(file->encoded_content);\n\t\tfile->encoded_content = NULL;\n\t\tfile->encoded_content_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\tfile->encoded_content = tmp;\n\tmemcpy(file->encoded_content, content, content_len);\n\tfile->encoded_content_len = content_len;\n\n\treturn SC_SUCCESS;\n}\n\n\nint sc_file_valid(const sc_file_t *file) {\n\tif (file == NULL)\n\t\treturn 0;\n\treturn file->magic == SC_FILE_MAGIC;\n}\n\nint _sc_parse_atr(sc_reader_t *reader)\n{\n\tu8 *p = reader->atr.value;\n\tint atr_len = (int) reader->atr.len;\n\tint n_hist, x;\n\tint tx[4] = {-1, -1, -1, -1};\n\tint i, FI, DI;\n\tconst int Fi_table[] = {\n\t\t372, 372, 558, 744, 1116, 1488, 1860, -1,\n\t\t-1, 512, 768, 1024, 1536, 2048, -1, -1 };\n\tconst int f_table[] = {\n\t\t40, 50, 60, 80, 120, 160, 200, -1,\n\t\t-1, 50, 75, 100, 150, 200, -1, -1 };\n\tconst int Di_table[] = {\n\t\t-1, 1, 2, 4, 8, 16, 32, -1,\n\t\t12, 20, -1, -1, -1, -1, -1, -1 };\n\n\treader->atr_info.hist_bytes_len = 0;\n\treader->atr_info.hist_bytes = NULL;\n\n\tif (atr_len == 0) {\n\t\tsc_log(reader->ctx, \"empty ATR - card not present?\\n\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tif (p[0] != 0x3B && p[0] != 0x3F) {\n\t\tsc_log(reader->ctx, \"invalid sync byte in ATR: 0x%02X\\n\", p[0]);\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tn_hist = p[1] & 0x0F;\n\tx = p[1] >> 4;\n\tp += 2;\n\tatr_len -= 2;\n\tfor (i = 0; i < 4 && atr_len > 0; i++) {\n                if (x & (1 << i)) {\n                        tx[i] = *p;\n                        p++;\n                        atr_len--;\n                } else\n                        tx[i] = -1;\n        }\n\tif (tx[0] >= 0) {\n\t\treader->atr_info.FI = FI = tx[0] >> 4;\n\t\treader->atr_info.DI = DI = tx[0] & 0x0F;\n\t\treader->atr_info.Fi = Fi_table[FI];\n\t\treader->atr_info.f = f_table[FI];\n\t\treader->atr_info.Di = Di_table[DI];\n\t} else {\n\t\treader->atr_info.Fi = -1;\n\t\treader->atr_info.f = -1;\n\t\treader->atr_info.Di = -1;\n\t}\n\tif (tx[2] >= 0)\n\t\treader->atr_info.N = tx[3];\n\telse\n\t\treader->atr_info.N = -1;\n\twhile (tx[3] > 0 && tx[3] & 0xF0 && atr_len > 0) {\n\t\tx = tx[3] >> 4;\n\t\tfor (i = 0; i < 4 && atr_len > 0; i++) {\n\t                if (x & (1 << i)) {\n\t                        tx[i] = *p;\n\t                        p++;\n\t                        atr_len--;\n\t                } else\n\t                        tx[i] = -1;\n\t\t}\n\t}\n\tif (atr_len <= 0)\n\t\treturn SC_SUCCESS;\n\tif (n_hist > atr_len)\n\t\tn_hist = atr_len;\n\treader->atr_info.hist_bytes_len = n_hist;\n\treader->atr_info.hist_bytes = p;\n\treturn SC_SUCCESS;\n}\n\nvoid sc_mem_clear(void *ptr, size_t len)\n{\n\tif (len > 0)   {\n#ifdef ENABLE_OPENSSL\n\t\tOPENSSL_cleanse(ptr, len);\n#else\n\t\tmemset(ptr, 0, len);\n#endif\n\t}\n}\n\nint sc_mem_reverse(unsigned char *buf, size_t len)\n{\n\tunsigned char ch;\n\tsize_t ii;\n\n\tif (!buf || !len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tfor (ii = 0; ii < len / 2; ii++)   {\n\t\tch = *(buf + ii);\n\t\t*(buf + ii) = *(buf + len - 1 - ii);\n\t\t*(buf + len - 1 - ii) = ch;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int\nsc_remote_apdu_allocate(struct sc_remote_data *rdata,\n\t\tstruct sc_remote_apdu **new_rapdu)\n{\n\tstruct sc_remote_apdu *rapdu = NULL, *rr;\n\n\tif (!rdata)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\trapdu = calloc(1, sizeof(struct sc_remote_apdu));\n\tif (rapdu == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\trapdu->apdu.data = &rapdu->sbuf[0];\n\trapdu->apdu.resp = &rapdu->rbuf[0];\n\trapdu->apdu.resplen = sizeof(rapdu->rbuf);\n\n\tif (new_rapdu)\n\t\t*new_rapdu = rapdu;\n\n\tif (rdata->data == NULL)   {\n\t\trdata->data = rapdu;\n\t\trdata->length = 1;\n\t\treturn SC_SUCCESS;\n\t}\n\n\tfor (rr = rdata->data; rr->next; rr = rr->next)\n\t\t;\n\trr->next = rapdu;\n\trdata->length++;\n\n\treturn SC_SUCCESS;\n}\n\nstatic void\nsc_remote_apdu_free (struct sc_remote_data *rdata)\n{\n\tstruct sc_remote_apdu *rapdu = NULL;\n\n\tif (!rdata)\n\t\treturn;\n\n\trapdu = rdata->data;\n\twhile(rapdu)   {\n\t\tstruct sc_remote_apdu *rr = rapdu->next;\n\n\t\tfree(rapdu);\n\t\trapdu = rr;\n\t}\n}\n\nvoid sc_remote_data_init(struct sc_remote_data *rdata)\n{\n\tif (!rdata)\n\t\treturn;\n\tmemset(rdata, 0, sizeof(struct sc_remote_data));\n\n\trdata->alloc = sc_remote_apdu_allocate;\n\trdata->free = sc_remote_apdu_free;\n}\n\nstatic unsigned long  sc_CRC_tab32[256];\nstatic int sc_CRC_tab32_initialized = 0;\nunsigned sc_crc32(const unsigned char *value, size_t len)\n{\n\tsize_t ii, jj;\n\tunsigned long crc;\n\tunsigned long index, long_c;\n\n\tif (!sc_CRC_tab32_initialized)   {\n\t\tfor (ii=0; ii<256; ii++) {\n\t\t\tcrc = (unsigned long) ii;\n\t\t\tfor (jj=0; jj<8; jj++) {\n\t\t\t\tif ( crc & 0x00000001L )\n\t\t\t\t\tcrc = ( crc >> 1 ) ^ 0xEDB88320l;\n\t\t\t\telse\n\t\t\t\t\tcrc =   crc >> 1;\n\t\t\t}\n\t\t\tsc_CRC_tab32[ii] = crc;\n\t\t}\n\t\tsc_CRC_tab32_initialized = 1;\n\t}\n\n\tcrc = 0xffffffffL;\n\tfor (ii=0; ii<len; ii++)   {\n\t\tlong_c = 0x000000ffL & (unsigned long) (*(value + ii));\n\t\tindex = crc ^ long_c;\n\t\tcrc = (crc >> 8) ^ sc_CRC_tab32[ index & 0xff ];\n\t}\n\n\tcrc ^= 0xffffffff;\n\treturn  crc%0xffff;\n}\n\nconst u8 *sc_compacttlv_find_tag(const u8 *buf, size_t len, u8 tag, size_t *outlen)\n{\n\tif (buf != NULL) {\n\t\tsize_t idx;\n\t\tu8 plain_tag = tag & 0xF0;\n\t\tsize_t expected_len = tag & 0x0F;\n\n\t        for (idx = 0; idx < len; idx++) {\n\t\t\tif ((buf[idx] & 0xF0) == plain_tag && idx + expected_len < len &&\n\t\t\t    (expected_len == 0 || expected_len == (buf[idx] & 0x0F))) {\n\t\t\t\tif (outlen != NULL)\n\t\t\t\t\t*outlen = buf[idx] & 0x0F;\n\t\t\t\treturn buf + (idx + 1);\n\t\t\t}\n\t\t\tidx += (buf[idx] & 0x0F);\n                }\n        }\n\treturn NULL;\n}\n\n/**************************** mutex functions ************************/\n\nint sc_mutex_create(const sc_context_t *ctx, void **mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->create_mutex != NULL)\n\t\treturn ctx->thread_ctx->create_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n\nint sc_mutex_lock(const sc_context_t *ctx, void *mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->lock_mutex != NULL)\n\t\treturn ctx->thread_ctx->lock_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n\nint sc_mutex_unlock(const sc_context_t *ctx, void *mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->unlock_mutex != NULL)\n\t\treturn ctx->thread_ctx->unlock_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n\nint sc_mutex_destroy(const sc_context_t *ctx, void *mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->destroy_mutex != NULL)\n\t\treturn ctx->thread_ctx->destroy_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n\nunsigned long sc_thread_id(const sc_context_t *ctx)\n{\n\tif (ctx == NULL || ctx->thread_ctx == NULL ||\n\t    ctx->thread_ctx->thread_id == NULL)\n\t\treturn 0UL;\n\telse\n\t\treturn ctx->thread_ctx->thread_id();\n}\n", "/*\n * cryptoflex-tool.c: Tool for doing various Cryptoflex related stuff\n *\n * Copyright (C) 2001  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"config.h\"\n\n#include \"libopensc/sc-ossl-compat.h\"\n#include <openssl/bn.h>\n#include <openssl/rsa.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <openssl/err.h>\n\n#include \"libopensc/pkcs15.h\"\n#include \"common/compat_strlcpy.h\"\n#include \"common/compat_strlcat.h\"\n#include \"util.h\"\n\nstatic const char *app_name = \"cryptoflex-tool\";\n\nstatic char * opt_reader = NULL;\nstatic int opt_wait = 0;\nstatic int opt_key_num = 1, opt_pin_num = -1;\nstatic int verbose = 0;\nstatic int opt_exponent = 3;\nstatic int opt_mod_length = 1024;\nstatic int opt_key_count = 1;\nstatic int opt_pin_attempts = 10;\nstatic int opt_puk_attempts = 10;\n\nstatic const char *opt_appdf = NULL, *opt_prkeyf = NULL, *opt_pubkeyf = NULL;\nstatic u8 *pincode = NULL;\n\nstatic const struct option options[] = {\n\t{ \"list-keys\",\t\t0, NULL, \t\t'l' },\n\t{ \"create-key-files\",\t1, NULL,\t\t'c' },\n\t{ \"create-pin-file\",\t1, NULL,\t\t'P' },\n\t{ \"generate-key\",\t0, NULL,\t\t'g' },\n\t{ \"read-key\",\t\t0, NULL,\t\t'R' },\n\t{ \"verify-pin\",\t\t0, NULL,\t\t'V' },\n\t{ \"key-num\",\t\t1, NULL,\t\t'k' },\n\t{ \"app-df\",\t\t1, NULL,\t\t'a' },\n\t{ \"prkey-file\",\t\t1, NULL,\t\t'p' },\n\t{ \"pubkey-file\",\t1, NULL,\t\t'u' },\n\t{ \"exponent\",\t\t1, NULL,\t\t'e' },\n\t{ \"modulus-length\",\t1, NULL,\t\t'm' },\n\t{ \"reader\",\t\t1, NULL,\t\t'r' },\n\t{ \"wait\",\t\t0, NULL,\t\t'w' },\n\t{ \"verbose\",\t\t0, NULL,\t\t'v' },\n\t{ NULL, 0, NULL, 0 }\n};\n\nstatic const char *option_help[] = {\n\t\"Lists all keys in a public key file\",\n\t\"Creates new RSA key files for <arg> keys\",\n\t\"Creates a new CHV<arg> file\",\n\t\"Generates a new RSA key pair\",\n\t\"Reads a public key from the card\",\n\t\"Verifies CHV1 before issuing commands\",\n\t\"Selects which key number to operate on [1]\",\n\t\"Selects the DF to operate in\",\n\t\"Private key file\",\n\t\"Public key file\",\n\t\"The RSA exponent to use in key generation [3]\",\n\t\"Modulus length to use in key generation [1024]\",\n\t\"Uses reader <arg>\",\n\t\"Wait for card insertion\",\n\t\"Verbose operation. Use several times to enable debug output.\",\n};\n\nstatic sc_context_t *ctx = NULL;\nstatic sc_card_t *card = NULL;\n\nstatic char *getpin(const char *prompt)\n{\n\tchar *buf, pass[20];\n\tint i;\n\n\tprintf(\"%s\", prompt);\n\tfflush(stdout);\n\tif (fgets(pass, 20, stdin) == NULL)\n\t\treturn NULL;\n\tfor (i = 0; i < 20; i++)\n\t\tif (pass[i] == '\\n')\n\t\t\tpass[i] = 0;\n\tif (strlen(pass) == 0)\n\t\treturn NULL;\n\tbuf = malloc(8);\n\tif (buf == NULL)\n\t\treturn NULL;\n\tif (strlen(pass) > 8) {\n\t\tfprintf(stderr, \"PIN code too long.\\n\");\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tmemset(buf, 0, 8);\n\tstrlcpy(buf, pass, 8);\n\treturn buf;\n}\n\nstatic int verify_pin(int pin)\n{\n\tchar prompt[50];\n\tint r, tries_left = -1;\n\n\tif (pincode == NULL) {\n\t\tsprintf(prompt, \"Please enter CHV%d: \", pin);\n\t\tpincode = (u8 *) getpin(prompt);\n\t\tif (pincode == NULL || strlen((char *) pincode) == 0)\n\t\t\treturn -1;\n\t}\n\tif (pin != 1 && pin != 2)\n\t\treturn -3;\n\tr = sc_verify(card, SC_AC_CHV, pin, pincode, 8, &tries_left);\n\tif (r) {\n\t\tmemset(pincode, 0, 8);\n\t\tfree(pincode);\n\t\tpincode = NULL;\n\t\tfprintf(stderr, \"PIN code verification failed: %s\\n\", sc_strerror(r));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int select_app_df(void)\n{\n\tsc_path_t path;\n\tsc_file_t *file;\n\tchar str[80];\n\tint r;\n\n\tstrcpy(str, \"3F00\");\n\tif (opt_appdf != NULL)\n\t\tstrlcat(str, opt_appdf, sizeof str);\n\tsc_format_path(str, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select application DF: %s\\n\", sc_strerror(r));\n\t\treturn -1;\n\t}\n\tif (file->type != SC_FILE_TYPE_DF) {\n\t\tfprintf(stderr, \"Selected application DF is not a DF.\\n\");\n\t\treturn -1;\n\t}\n\tsc_file_free(file);\n\tif (opt_pin_num >= 0)\n\t\treturn verify_pin(opt_pin_num);\n\telse\n\t\treturn 0;\n}\n\nstatic void invert_buf(u8 *dest, const u8 *src, size_t c)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < c; i++)\n\t\tdest[i] = src[c-1-i];\n}\n\nstatic BIGNUM * cf2bn(const u8 *buf, size_t bufsize, BIGNUM *num)\n{\n\tu8 tmp[512];\n\n\tinvert_buf(tmp, buf, bufsize);\n\n\treturn BN_bin2bn(tmp, bufsize, num);\n}\n\nstatic int bn2cf(const BIGNUM *num, u8 *buf)\n{\n\tu8 tmp[512];\n\tint r;\n\n\tr = BN_bn2bin(num, tmp);\n\tif (r <= 0)\n\t\treturn r;\n\tinvert_buf(buf, tmp, r);\n\n\treturn r;\n}\n\nstatic int parse_public_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *n, *e;\n\tint base;\n\n\tbase = (keysize - 7) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tn = BN_new();\n\tif (n == NULL)\n\t\treturn -1;\n\tcf2bn(p, 2 * base, n);\n\tp += 2 * base;\n\tp += base;\n\tp += 2 * base;\n\te = BN_new();\n\tif (e == NULL)\n\t\treturn -1;\n\tcf2bn(p, 4, e);\n\tif (RSA_set0_key(rsa, n, e, NULL) != 1)\n\t    return -1;\n\treturn 0;\n}\n\nstatic int gen_d(RSA *rsa)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *r0, *r1, *r2;\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_n, *rsa_e, *rsa_d;\n\tBIGNUM *rsa_n_new, *rsa_e_new, *rsa_d_new;\n\n\tbnctx = BN_CTX_new();\n\tif (bnctx == NULL)\n\t\treturn -1;\n\tBN_CTX_start(bnctx);\n\tr0 = BN_CTX_get(bnctx);\n\tr1 = BN_CTX_get(bnctx);\n\tr2 = BN_CTX_get(bnctx);\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, &rsa_d);\n\tRSA_get0_factors(rsa, &rsa_p, &rsa_q);\n\n\tBN_sub(r1, rsa_p, BN_value_one());\n\tBN_sub(r2, rsa_q, BN_value_one());\n\tBN_mul(r0, r1, r2, bnctx);\n\tif ((rsa_d_new = BN_mod_inverse(NULL, rsa_e, r0, bnctx)) == NULL) {\n\t\tfprintf(stderr, \"BN_mod_inverse() failed.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* RSA_set0_key will free previous value, and replace with new value\n\t * Thus the need to copy the contents of rsa_n and rsa_e\n\t */\n\trsa_n_new = BN_dup(rsa_n);\n\trsa_e_new = BN_dup(rsa_e);\n\tif (RSA_set0_key(rsa, rsa_n_new, rsa_e_new, rsa_d_new) != 1)\n\t\treturn -1;\n\n\tBN_CTX_end(bnctx);\n\tBN_CTX_free(bnctx);\n\treturn 0;\n}\n\nstatic int parse_private_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *bn_p, *q, *dmp1, *dmq1, *iqmp;\n\tint base;\n\n\tbase = (keysize - 3) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tbn_p = BN_new();\n\tif (bn_p == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, bn_p);\n\tp += base;\n\n\tq = BN_new();\n\tif (q == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, q);\n\tp += base;\n\n\tiqmp = BN_new();\n\tif (iqmp == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, iqmp);\n\tp += base;\n\n\tdmp1 = BN_new();\n\tif (dmp1 == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, dmp1);\n\tp += base;\n\n\tdmq1 = BN_new();\n\tif (dmq1 == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, dmq1);\n\tp += base;\n\n\t\n\tif (RSA_set0_factors(rsa, bn_p, q) != 1)\n\t\treturn -1;\n\tif (RSA_set0_crt_params(rsa, dmp1, dmq1, iqmp) != 1)\n\t\treturn -1;\n\tif (gen_d(rsa))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = file->size;\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}\n\n\nstatic int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = file->size;\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}\n\nstatic int read_key(void)\n{\n\tRSA *rsa = RSA_new();\n\tu8 buf[1024], *p = buf;\n\tu8 b64buf[2048];\n\tint r;\n\n\tif (rsa == NULL)\n\t\treturn -1;\n\tr = read_public_key(rsa);\n\tif (r)\n\t\treturn r;\n\tr = i2d_RSA_PUBKEY(rsa, &p);\n\tif (r <= 0) {\n\t\tfprintf(stderr, \"Error encoding public key.\\n\");\n\t\treturn -1;\n\t}\n\tr = sc_base64_encode(buf, r, b64buf, sizeof(b64buf), 64);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Error in Base64 encoding: %s\\n\", sc_strerror(r));\n\t\treturn -1;\n\t}\n\tprintf(\"-----BEGIN PUBLIC KEY-----\\n%s-----END PUBLIC KEY-----\\n\", b64buf);\n\n\tr = read_private_key(rsa);\n\tif (r == 10)\n\t\treturn 0;\n\telse if (r)\n\t\treturn r;\n\tp = buf;\n\tr = i2d_RSAPrivateKey(rsa, &p);\n\tif (r <= 0) {\n\t\tfprintf(stderr, \"Error encoding private key.\\n\");\n\t\treturn -1;\n\t}\n\tr = sc_base64_encode(buf, r, b64buf, sizeof(b64buf), 64);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Error in Base64 encoding: %s\\n\", sc_strerror(r));\n\t\treturn -1;\n\t}\n\tprintf(\"-----BEGIN RSA PRIVATE KEY-----\\n%s-----END RSA PRIVATE KEY-----\\n\", b64buf);\n\n\treturn 0;\n}\n\nstatic int list_keys(void)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\tu8 buf[2048], *p = buf;\n\tsize_t keysize, i;\n\tint mod_lens[] = { 512, 768, 1024, 2048 };\n\tsize_t sizes[] = { 167, 247, 327, 647 };\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tdo {\n\t\tint mod_len = -1;\n\n\t\tr = sc_read_binary(card, idx, buf, 3, 0);\n\t\tif (r < 0) {\n\t\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\t\treturn 2;\n\t\t}\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tidx += keysize;\n\t\tfor (i = 0; i < sizeof(sizes)/sizeof(sizes[ 0]); i++)\n\t\t\tif (sizes[i] == keysize)\n\t\t\t\tmod_len = mod_lens[i];\n\t\tif (mod_len < 0)\n\t\t\tprintf(\"Key %d -- unknown modulus length\\n\", p[2] & 0x0F);\n\t\telse\n\t\t\tprintf(\"Key %d -- Modulus length %d\\n\", p[2] & 0x0F, mod_len);\n\t} while (1);\n\treturn 0;\n}\n\nstatic int generate_key(void)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[4];\n\tu8 p2;\n\tint r;\n\n\tswitch (opt_mod_length) {\n\tcase 512:\n\t\tp2 = 0x40;\n\t\tbreak;\n\tcase 768:\n\t\tp2 = 0x60;\n\t\tbreak;\n\tcase 1024:\n\t\tp2 = 0x80;\n\t\tbreak;\n\tcase 2048:\n\t\tp2 = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Invalid modulus length.\\n\");\n\t\treturn 2;\n\t}\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, (u8) opt_key_num-1, p2);\n\tapdu.cla = 0xF0;\n\tapdu.lc = 4;\n\tapdu.datalen = 4;\n\tapdu.data = sbuf;\n\tsbuf[0] = opt_exponent & 0xFF;\n\tsbuf[1] = (opt_exponent >> 8) & 0xFF;\n\tsbuf[2] = (opt_exponent >> 16) & 0xFF;\n\tsbuf[3] = (opt_exponent >> 24) & 0xFF;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tif (verbose)\n\t\tprintf(\"Generating key...\\n\");\n\tr = sc_transmit_apdu(card, &apdu);\n\tif (r) {\n\t\tfprintf(stderr, \"APDU transmit failed: %s\\n\", sc_strerror(r));\n\t\tif (r == SC_ERROR_TRANSMIT_FAILED)\n\t\t\tfprintf(stderr, \"Reader has timed out. It is still possible that the key generation has\\n\"\n\t\t\t\t\t\"succeeded.\\n\");\n\t\treturn 1;\n\t}\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\tprintf(\"Key generation successful.\\n\");\n\t\treturn 0;\n\t}\n\tif (apdu.sw1 == 0x69 && apdu.sw2 == 0x82)\n\t\tfprintf(stderr, \"CHV1 not verified or invalid exponent value.\\n\");\n\telse\n\t\tfprintf(stderr, \"Card returned SW1=%02X, SW2=%02X.\\n\", apdu.sw1, apdu.sw2);\n\treturn 1;\n}\n\nstatic int create_key_files(void)\n{\n\tsc_file_t *file;\n\tint mod_lens[] = { 512, 768, 1024, 2048 };\n\tint sizes[] = { 163, 243, 323, 643 };\n\tint size = -1;\n\tint r;\n\tsize_t i;\n\n\tfor (i = 0; i < sizeof(mod_lens) / sizeof(int); i++)\n\t\tif (mod_lens[i] == opt_mod_length) {\n\t\t\tsize = sizes[i];\n\t\t\tbreak;\n\t\t}\n\tif (size == -1) {\n\t\tfprintf(stderr, \"Invalid modulus length.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (verbose)\n\t\tprintf(\"Creating key files for %d keys.\\n\", opt_key_count);\n\n\tfile = sc_file_new();\n\tif (!file) {\n\t\tfprintf(stderr, \"out of memory.\\n\");\n\t\treturn 1;\n\t}\n\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\n\tfile->id = 0x0012;\n\tfile->size = opt_key_count * size + 3;\n\tsc_file_add_acl_entry(file, SC_AC_OP_READ, SC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_CHV, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE, SC_AC_CHV, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE, SC_AC_CHV, 1);\n\n\tif (select_app_df()) {\n\t\tsc_file_free(file);\n\t\treturn 1;\n\t}\n\tr = sc_create_file(card, file);\n\tsc_file_free(file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to create private key file: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\n\tfile = sc_file_new();\n\tif (!file) {\n\t\tfprintf(stderr, \"out of memory.\\n\");\n\t\treturn 1;\n\t}\n\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\n\tfile->id = 0x1012;\n\tfile->size = opt_key_count * (size + 4) + 3;\n\tsc_file_add_acl_entry(file, SC_AC_OP_READ, SC_AC_NONE, SC_AC_KEY_REF_NONE);\n\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_CHV, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE, SC_AC_CHV, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE, SC_AC_CHV, 1);\n\n\tif (select_app_df()) {\n\t\tsc_file_free(file);\n\t\treturn 1;\n\t}\n\tr = sc_create_file(card, file);\n\tsc_file_free(file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to create public key file: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\tif (verbose)\n\t\tprintf(\"Key files generated successfully.\\n\");\n\treturn 0;\n}\n\nstatic int read_rsa_privkey(RSA **rsa_out)\n{\n\tRSA *rsa = NULL;\n\tBIO *in = NULL;\n\tint r;\n\n\tin = BIO_new(BIO_s_file());\n\tif (opt_prkeyf == NULL) {\n\t\tfprintf(stderr, \"Private key file must be set.\\n\");\n\t\treturn 2;\n\t}\n\tr = BIO_read_filename(in, opt_prkeyf);\n\tif (r <= 0) {\n\t\tperror(opt_prkeyf);\n\t\treturn 2;\n\t}\n\trsa = PEM_read_bio_RSAPrivateKey(in, NULL, NULL, NULL);\n\tif (rsa == NULL) {\n\t\tfprintf(stderr, \"Unable to load private key.\\n\");\n\t\treturn 2;\n\t}\n\tBIO_free(in);\n\t*rsa_out = rsa;\n\treturn 0;\n}\n\nstatic int encode_private_key(RSA *rsa, u8 *key, size_t *keysize)\n{\n\tu8 buf[1024], *p = buf;\n\tu8 bnbuf[256];\n\tint base = 0;\n\tint r;\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_dmp1, *rsa_dmq1, *rsa_iqmp;\n\n\tswitch (RSA_bits(rsa)) {\n\tcase 512:\n\t\tbase = 32;\n\t\tbreak;\n\tcase 768:\n\t\tbase = 48;\n\t\tbreak;\n\tcase 1024:\n\t\tbase = 64;\n\t\tbreak;\n\tcase 2048:\n\t\tbase = 128;\n\t\tbreak;\n\t}\n\tif (base == 0) {\n\t\tfprintf(stderr, \"Key length invalid.\\n\");\n\t\treturn 2;\n\t}\n\t*p++ = (5 * base + 3) >> 8;\n\t*p++ = (5 * base + 3) & 0xFF;\n\t*p++ = opt_key_num;\n\n\tRSA_get0_factors(rsa, &rsa_p, &rsa_q);\n\n\tr = bn2cf(rsa_p, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tr = bn2cf(rsa_q, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tRSA_get0_crt_params(rsa, &rsa_dmp1, &rsa_dmq1, &rsa_iqmp);\n\n\tr = bn2cf(rsa_iqmp, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tr = bn2cf(rsa_dmp1, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tr = bn2cf(rsa_dmq1, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tmemcpy(key, buf, p - buf);\n\t*keysize = p - buf;\n\n\treturn 0;\n}\n\nstatic int encode_public_key(RSA *rsa, u8 *key, size_t *keysize)\n{\n\tu8 buf[1024], *p = buf;\n\tu8 bnbuf[256];\n\tint base = 0;\n\tint r;\n\tconst BIGNUM *rsa_n, *rsa_e;\n\n\tswitch (RSA_bits(rsa)) {\n\tcase 512:\n\t\tbase = 32;\n\t\tbreak;\n\tcase 768:\n\t\tbase = 48;\n\t\tbreak;\n\tcase 1024:\n\t\tbase = 64;\n\t\tbreak;\n\tcase 2048:\n\t\tbase = 128;\n\t\tbreak;\n\t}\n\tif (base == 0) {\n\t\tfprintf(stderr, \"Key length invalid.\\n\");\n\t\treturn 2;\n\t}\n\t*p++ = (5 * base + 7) >> 8;\n\t*p++ = (5 * base + 7) & 0xFF;\n\t*p++ = opt_key_num;\n\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, NULL);\n\tr = bn2cf(rsa_n, bnbuf);\n\tif (r != 2*base) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, 2*base);\n\tp += 2*base;\n\n\tmemset(p, 0, base);\n\tp += base;\n\n\tmemset(bnbuf, 0, 2*base);\n\tmemcpy(p, bnbuf, 2*base);\n\tp += 2*base;\n\tr = bn2cf(rsa_e, bnbuf);\n\tmemcpy(p, bnbuf, 4);\n\tp += 4;\n\n\tmemcpy(key, buf, p - buf);\n\t*keysize = p - buf;\n\n\treturn 0;\n}\n\nstatic int update_public_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write public key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic int update_private_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write private key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic int store_key(void)\n{\n\tu8 prv[1024], pub[1024];\n\tsize_t prvsize, pubsize;\n\tint r;\n\tRSA *rsa;\n\n\tr = read_rsa_privkey(&rsa);\n\tif (r)\n\t\treturn r;\n\tr = encode_private_key(rsa, prv, &prvsize);\n\tif (r)\n\t\treturn r;\n\tr = encode_public_key(rsa, pub, &pubsize);\n\tif (r)\n\t\treturn r;\n\tif (verbose)\n\t\tprintf(\"Storing private key...\\n\");\n\tr = select_app_df();\n\tif (r)\n\t\treturn r;\n\tr = update_private_key(prv, prvsize);\n\tif (r)\n\t\treturn r;\n\tif (verbose)\n\t\tprintf(\"Storing public key...\\n\");\n\tr = select_app_df();\n\tif (r)\n\t\treturn r;\n\tr = update_public_key(pub, pubsize);\n\tif (r)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic int create_pin_file(const sc_path_t *inpath, int chv, const char *key_id)\n{\n\tchar prompt[40], *pin, *puk;\n\tchar buf[30], *p = buf;\n\tsc_path_t file_id, path;\n\tsc_file_t *file;\n\tsize_t len;\n\tint r;\n\n\tfile_id = *inpath;\n\tif (file_id.len < 2)\n\t\treturn -1;\n\tif (chv == 1)\n\t\tsc_format_path(\"I0000\", &file_id);\n\telse if (chv == 2)\n\t\tsc_format_path(\"I0100\", &file_id);\n\telse\n\t\treturn -1;\n\tr = sc_select_file(card, inpath, NULL);\n\tif (r)\n\t\treturn -1;\n\tr = sc_select_file(card, &file_id, NULL);\n\tif (r == 0)\n\t\treturn 0;\n\n\tsprintf(prompt, \"Please enter CHV%d%s: \", chv, key_id);\n\tpin = getpin(prompt);\n\tif (pin == NULL)\n\t\treturn -1;\n\n\tsprintf(prompt, \"Please enter PUK for CHV%d%s: \", chv, key_id);\n\tpuk = getpin(prompt);\n\tif (puk == NULL) {\n\t\tfree(pin);\n\t\treturn -1;\n\t}\n\n\tmemset(p, 0xFF, 3);\n\tp += 3;\n\tmemcpy(p, pin, 8);\n\tp += 8;\n\t*p++ = opt_pin_attempts;\n\t*p++ = opt_pin_attempts;\n\tmemcpy(p, puk, 8);\n\tp += 8;\n\t*p++ = opt_puk_attempts;\n\t*p++ = opt_puk_attempts;\n\tlen = p - buf;\n\n\tfree(pin);\n\tfree(puk);\n\n\tfile = sc_file_new();\n\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\tsc_file_add_acl_entry(file, SC_AC_OP_READ, SC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\tif (inpath->len == 2 && inpath->value[0] == 0x3F &&\n\t    inpath->value[1] == 0x00)\n\t\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_AUT, 1);\n\telse\n\t\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_CHV, 2);\n\n\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE, SC_AC_AUT, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE, SC_AC_AUT, 1);\n\tfile->size = len;\n\tfile->id = (file_id.value[0] << 8) | file_id.value[1];\n\tr = sc_create_file(card, file);\n\tsc_file_free(file);\n\tif (r) {\n\t\tfprintf(stderr, \"PIN file creation failed: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\tpath = *inpath;\n\tsc_append_path(&path, &file_id);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select created PIN file: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\tr = sc_update_binary(card, 0, (const u8 *) buf, len, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to update created PIN file: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_pin(void)\n{\n\tsc_path_t path;\n\tchar buf[80];\n\n\tif (opt_pin_num != 1 && opt_pin_num != 2) {\n\t\tfprintf(stderr, \"Invalid PIN number. Possible values: 1, 2.\\n\");\n\t\treturn 2;\n\t}\n\tstrcpy(buf, \"3F00\");\n\tif (opt_appdf != NULL)\n\t\tstrlcat(buf, opt_appdf, sizeof buf);\n\tsc_format_path(buf, &path);\n\n\treturn create_pin_file(&path, opt_pin_num, \"\");\n}\n\nint main(int argc, char *argv[])\n{\n\tint err = 0, r, c, long_optind = 0;\n\tint action_count = 0;\n\tint do_read_key = 0;\n\tint do_generate_key = 0;\n\tint do_create_key_files = 0;\n\tint do_list_keys = 0;\n\tint do_store_key = 0;\n\tint do_create_pin_file = 0;\n\tsc_context_param_t ctx_param;\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"P:Vslgc:Rk:r:p:u:e:m:vwa:\", options, &long_optind);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tif (c == '?')\n\t\t\tutil_print_usage_and_die(app_name, options, option_help, NULL);\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\tdo_list_keys = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tdo_create_pin_file = 1;\n\t\t\topt_pin_num = atoi(optarg);\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdo_read_key = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tdo_generate_key = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tdo_create_key_files = 1;\n\t\t\topt_key_count = atoi(optarg);\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tdo_store_key = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\topt_key_num = atoi(optarg);\n\t\t\tif (opt_key_num < 1 || opt_key_num > 15) {\n\t\t\t\tfprintf(stderr, \"Key number invalid.\\n\");\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\topt_pin_num = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\topt_exponent = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\topt_mod_length = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\topt_prkeyf = optarg;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\topt_pubkeyf = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\topt_reader = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topt_wait = 1;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\topt_appdf = optarg;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (action_count == 0)\n\t\tutil_print_usage_and_die(app_name, options, option_help, NULL);\n\n\tmemset(&ctx_param, 0, sizeof(ctx_param));\n\tctx_param.ver      = 0;\n\tctx_param.app_name = app_name;\n\n\tr = sc_context_create(&ctx, &ctx_param);\n\tif (r) {\n\t\tfprintf(stderr, \"Failed to establish context: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\n\tif (verbose > 1) {\n\t\tctx->debug = verbose;\n\t\tsc_ctx_log_to_file(ctx, \"stderr\");\n\t}\n\n\terr = util_connect_card(ctx, &card, opt_reader, opt_wait, verbose);\n\tprintf(\"Using card driver: %s\\n\", card->driver->name);\n\n\tif (do_create_pin_file) {\n\t\tif ((err = create_pin()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_create_key_files) {\n\t\tif ((err = create_key_files()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_generate_key) {\n\t\tif ((err = generate_key()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_store_key) {\n\t\tif ((err = store_key()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_list_keys) {\n\t\tif ((err = list_keys()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_read_key) {\n\t\tif ((err = read_key()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (pincode != NULL) {\n\t\tmemset(pincode, 0, 8);\n\t\tfree(pincode);\n\t}\nend:\n\tif (card) {\n\t\tsc_unlock(card);\n\t\tsc_disconnect_card(card);\n\t}\n\tif (ctx)\n\t\tsc_release_context(ctx);\n\treturn err;\n}\n", "/*\n * Copyright (C) 2017 Frank Morgner <frankmorgner@gmail.com>\n *\n * This file is part of OpenSC.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"egk-tool-cmdline.h\"\n#include \"libopensc/log.h\"\n#include \"libopensc/opensc.h\"\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <io.h>\n#include <fcntl.h>\n#endif\n\n#ifdef ENABLE_ZLIB\n#include <zlib.h>\n\nint uncompress_gzip(void* uncompressed, size_t *uncompressed_len,\n\t\tconst void* compressed, size_t compressed_len)\n{\n\tz_stream stream;\n\tmemset(&stream, 0, sizeof stream);\n\tstream.total_in = compressed_len;\n\tstream.avail_in = compressed_len;\n\tstream.total_out = *uncompressed_len;\n\tstream.avail_out = *uncompressed_len;\n\tstream.next_in = (Bytef *) compressed;\n\tstream.next_out = (Bytef *) uncompressed;\n\n\t/* 15 window bits, and the +32 tells zlib to to detect if using gzip or zlib */\n\tif (Z_OK == inflateInit2(&stream, (15 + 32))\n\t\t\t&& Z_STREAM_END == inflate(&stream, Z_FINISH)) {\n\t\t*uncompressed_len = stream.total_out;\n\t} else {\n\t\treturn SC_ERROR_INVALID_DATA;\n\t}\n\tinflateEnd(&stream);\n\n\treturn SC_SUCCESS;\n}\n#else\nint uncompress_gzip(void* uncompressed, size_t *uncompressed_len,\n\t\tconst void* compressed, size_t compressed_len)\n{\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n#endif\n\n#define PRINT(c) (isprint(c) ? c : '?')\n\nvoid dump_binary(void *buf, size_t buf_len)\n{\n#ifdef _WIN32\n\t_setmode(fileno(stdout), _O_BINARY);\n#endif\n\tfwrite(buf, 1, buf_len, stdout);\n#ifdef _WIN32\n\t_setmode(fileno(stdout), _O_TEXT);\n#endif\n}\n\nconst unsigned char aid_hca[] = {0xD2, 0x76, 0x00, 0x00, 0x01, 0x02};\n\nstatic int initialize(int reader_id, int verbose,\n\t\tsc_context_t **ctx, sc_reader_t **reader)\n{\n\tunsigned int i, reader_count;\n\tint r;\n\n\tif (!ctx || !reader)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tr = sc_establish_context(ctx, \"\");\n\tif (r < 0 || !*ctx) {\n\t\tfprintf(stderr, \"Failed to create initial context: %s\", sc_strerror(r));\n\t\treturn r;\n\t}\n\n\t(*ctx)->debug = verbose;\n\t(*ctx)->flags |= SC_CTX_FLAG_ENABLE_DEFAULT_DRIVER;\n\n\treader_count = sc_ctx_get_reader_count(*ctx);\n\n\tif (reader_count == 0) {\n\t\tsc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"No reader not found.\\n\");\n\t\treturn SC_ERROR_NO_READERS_FOUND;\n\t}\n\n\tif (reader_id < 0) {\n\t\t/* Automatically try to skip to a reader with a card if reader not specified */\n\t\tfor (i = 0; i < reader_count; i++) {\n\t\t\t*reader = sc_ctx_get_reader(*ctx, i);\n\t\t\tif (sc_detect_card_presence(*reader) & SC_READER_CARD_PRESENT) {\n\t\t\t\treader_id = i;\n\t\t\t\tsc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"Using the first reader\"\n\t\t\t\t\t\t\" with a card: %s\", (*reader)->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((unsigned int) reader_id >= reader_count) {\n\t\t\tsc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"No card found, using the first reader.\");\n\t\t\treader_id = 0;\n\t\t}\n\t}\n\n\tif ((unsigned int) reader_id >= reader_count) {\n\t\tsc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"Invalid reader number \"\n\t\t\t\t\"(%d), only %d available.\\n\", reader_id, reader_count);\n\t\treturn SC_ERROR_NO_READERS_FOUND;\n\t}\n\n\t*reader = sc_ctx_get_reader(*ctx, reader_id);\n\n\treturn SC_SUCCESS;\n}\n\nint read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}\n\nvoid decode_version(unsigned char *bcd, unsigned int *major, unsigned int *minor, unsigned int *fix)\n{\n\t*major = 0;\n\t*minor = 0;\n\t*fix = 0;\n\n\t/* decode BCD to decimal */\n\tif ((bcd[0]>>4) < 10 && ((bcd[0]&0xF) < 10) && ((bcd[1]>>4) < 10)) {\n\t\t*major = (bcd[0]>>4)*100 + (bcd[0]&0xF)*10 + (bcd[1]>>4);\n\t}\n\tif (((bcd[1]&0xF) < 10) && ((bcd[2]>>4) < 10) && ((bcd[2]&0xF) < 10)) {\n\t\t*minor = (bcd[1]&0xF)*100 + (bcd[2]>>4)*10 + (bcd[2]&0xF);\n\t}\n\tif ((bcd[3]>>4) < 10 && ((bcd[3]&0xF) < 10)\n\t\t\t&& (bcd[4]>>4) < 10 && ((bcd[4]&0xF) < 10)) {\n\t\t*fix = (bcd[3]>>4)*1000 + (bcd[3]&0xF)*100\n\t\t\t+ (bcd[4]>>4)*10 + (bcd[4]&0xF);\n\t}\n}\n\nint\nmain (int argc, char **argv)\n{\n\tstruct gengetopt_args_info cmdline;\n\tstruct sc_path path;\n\tstruct sc_context *ctx;\n\tstruct sc_reader *reader = NULL;\n\tstruct sc_card *card;\n\tunsigned char *data = NULL;\n\tsize_t data_len = 0;\n\tint r;\n\n\tif (cmdline_parser(argc, argv, &cmdline) != 0)\n\t\texit(1);\n\n\tr = initialize(cmdline.reader_arg, cmdline.verbose_given, &ctx, &reader);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Can't initialize reader\\n\");\n\t\texit(1);\n\t}\n\n\tif (sc_connect_card(reader, &card) < 0) {\n\t\tfprintf(stderr, \"Could not connect to card\\n\");\n\t\tsc_release_context(ctx);\n\t\texit(1);\n\t}\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, aid_hca, sizeof aid_hca, 0, 0);\n\tif (SC_SUCCESS != sc_select_file(card, &path, NULL))\n\t\tgoto err;\n\n\tif (cmdline.pd_flag\n\t\t\t&& read_file(card, \"D001\", &data, &data_len)\n\t\t\t&& data_len >= 2) {\n\t\tsize_t len_pd = (data[0] << 8) | data[1];\n\n\t\tif (len_pd + 2 <= data_len) {\n\t\t\tunsigned char uncompressed[1024];\n\t\t\tsize_t uncompressed_len = sizeof uncompressed;\n\n\t\t\tif (uncompress_gzip(uncompressed, &uncompressed_len,\n\t\t\t\t\t\tdata + 2, len_pd) == SC_SUCCESS) {\n\t\t\t\tdump_binary(uncompressed, uncompressed_len);\n\t\t\t} else {\n\t\t\t\tdump_binary(data + 2, len_pd);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((cmdline.vd_flag || cmdline.gvd_flag)\n\t\t\t&& read_file(card, \"D001\", &data, &data_len)\n\t\t\t&& data_len >= 8) {\n\t\tsize_t off_vd  = (data[0] << 8) | data[1];\n\t\tsize_t end_vd  = (data[2] << 8) | data[3];\n\t\tsize_t off_gvd = (data[4] << 8) | data[5];\n\t\tsize_t end_gvd = (data[6] << 8) | data[7];\n\t\tsize_t len_vd = end_vd - off_vd + 1;\n\t\tsize_t len_gvd = end_gvd - off_gvd + 1;\n\n\t\tif (off_vd <= end_vd && end_vd < data_len\n\t\t\t\t&& off_gvd <= end_gvd && end_gvd < data_len) {\n\t\t\tunsigned char uncompressed[1024];\n\t\t\tsize_t uncompressed_len = sizeof uncompressed;\n\n\t\t\tif (cmdline.vd_flag) {\n\t\t\t\tif (uncompress_gzip(uncompressed, &uncompressed_len,\n\t\t\t\t\t\t\tdata + off_vd, len_vd) == SC_SUCCESS) {\n\t\t\t\t\tdump_binary(uncompressed, uncompressed_len);\n\t\t\t\t} else {\n\t\t\t\t\tdump_binary(data + off_vd, len_vd);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cmdline.gvd_flag) {\n\t\t\t\tif (uncompress_gzip(uncompressed, &uncompressed_len,\n\t\t\t\t\t\t\tdata + off_gvd, len_gvd) == SC_SUCCESS) {\n\t\t\t\t\tdump_binary(uncompressed, uncompressed_len);\n\t\t\t\t} else {\n\t\t\t\t\tdump_binary(data + off_gvd, len_gvd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmdline.vsd_status_flag\n\t\t\t&& read_file(card, \"D00C\", &data, &data_len)\n\t\t\t&& data_len >= 25) {\n\t\tchar *status;\n\t\tunsigned int major, minor, fix;\n\n\t\tswitch (data[0]) {\n\t\t\tcase '0':\n\t\t\t\tstatus = \"Transactions pending\";\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\tstatus = \"No transactions pending\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstatus = \"Unknown\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdecode_version(data+15, &major, &minor, &fix);\n\n\t\tprintf(\n\t\t\t\t\"Status      %s\\n\"\n\t\t\t\t\"Timestamp   %c%c.%c%c.%c%c%c%c at %c%c:%c%c:%c%c\\n\"\n\t\t\t\t\"Version     %u.%u.%u\\n\",\n\t\t\t\tstatus,\n\t\t\t\tPRINT(data[7]), PRINT(data[8]),\n\t\t\t\tPRINT(data[5]), PRINT(data[6]),\n\t\t\t\tPRINT(data[1]), PRINT(data[2]), PRINT(data[3]), PRINT(data[4]),\n\t\t\t\tPRINT(data[9]), PRINT(data[10]),\n\t\t\t\tPRINT(data[11]), PRINT(data[12]),\n\t\t\t\tPRINT(data[13]), PRINT(data[14]),\n\t\t\t\tmajor, minor, fix);\n\t}\n\nerr:\n\tsc_disconnect_card(card);\n\tsc_release_context(ctx);\n\tcmdline_parser_free (&cmdline);\n\n\treturn 0;\n}\n", "/*\n * util.c: utility functions used by OpenSC command line tools.\n *\n * Copyright (C) 2011 OpenSC Project developers\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#ifndef _WIN32\n#include <termios.h>\n#else\n#include <conio.h>\n#endif\n#include <ctype.h>\n#include \"util.h\"\n#include \"ui/notify.h\"\n\nint\nis_string_valid_atr(const char *atr_str)\n{\n\tunsigned char atr[SC_MAX_ATR_SIZE];\n\tsize_t atr_len = sizeof(atr);\n\n\tif (sc_hex_to_bin(atr_str, atr, &atr_len))\n\t\treturn 0;\n\tif (atr_len < 2)\n\t\treturn 0;\n\tif (atr[0] != 0x3B && atr[0] != 0x3F)\n\t\treturn 0;\n\treturn 1;\n}\n\nint\nutil_connect_card_ex(sc_context_t *ctx, sc_card_t **cardp,\n\t\t const char *reader_id, int do_wait, int do_lock, int verbose)\n{\n\tstruct sc_reader *reader = NULL, *found = NULL;\n\tstruct sc_card *card = NULL;\n\tint r;\n\n\tsc_notify_init();\n\n\tif (do_wait) {\n\t\tunsigned int event;\n\n\t\tif (sc_ctx_get_reader_count(ctx) == 0) {\n\t\t\tfprintf(stderr, \"Waiting for a reader to be attached...\\n\");\n\t\t\tr = sc_wait_for_event(ctx, SC_EVENT_READER_ATTACHED, &found, &event, -1, NULL);\n\t\t\tif (r < 0) {\n\t\t\t\tfprintf(stderr, \"Error while waiting for a reader: %s\\n\", sc_strerror(r));\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t\tr = sc_ctx_detect_readers(ctx);\n\t\t\tif (r < 0) {\n\t\t\t\tfprintf(stderr, \"Error while refreshing readers: %s\\n\", sc_strerror(r));\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"Waiting for a card to be inserted...\\n\");\n\t\tr = sc_wait_for_event(ctx, SC_EVENT_CARD_INSERTED, &found, &event, -1, NULL);\n\t\tif (r < 0) {\n\t\t\tfprintf(stderr, \"Error while waiting for a card: %s\\n\", sc_strerror(r));\n\t\t\treturn 3;\n\t\t}\n\t\treader = found;\n\t}\n\telse if (sc_ctx_get_reader_count(ctx) == 0) {\n\t\tfprintf(stderr, \"No smart card readers found.\\n\");\n\t\treturn 1;\n\t}\n\telse   {\n\t\tif (!reader_id) {\n\t\t\tunsigned int i;\n\t\t\t/* Automatically try to skip to a reader with a card if reader not specified */\n\t\t\tfor (i = 0; i < sc_ctx_get_reader_count(ctx); i++) {\n\t\t\t\treader = sc_ctx_get_reader(ctx, i);\n\t\t\t\tif (sc_detect_card_presence(reader) & SC_READER_CARD_PRESENT) {\n\t\t\t\t\tfprintf(stderr, \"Using reader with a card: %s\\n\", reader->name);\n\t\t\t\t\tgoto autofound;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If no reader had a card, default to the first reader */\n\t\t\treader = sc_ctx_get_reader(ctx, 0);\n\t\t}\n\t\telse {\n\t\t\t/* If the reader identifier looks like an ATR, try to find the reader with that card */\n\t\t\tif (is_string_valid_atr(reader_id))   {\n\t\t\t\tunsigned char atr_buf[SC_MAX_ATR_SIZE];\n\t\t\t\tsize_t atr_buf_len = sizeof(atr_buf);\n\t\t\t\tunsigned int i;\n\n\t\t\t\tsc_hex_to_bin(reader_id, atr_buf, &atr_buf_len);\n\t\t\t\t/* Loop readers, looking for a card with ATR */\n\t\t\t\tfor (i = 0; i < sc_ctx_get_reader_count(ctx); i++) {\n\t\t\t\t\tstruct sc_reader *rdr = sc_ctx_get_reader(ctx, i);\n\n\t\t\t\t\tif (!(sc_detect_card_presence(rdr) & SC_READER_CARD_PRESENT))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (rdr->atr.len != atr_buf_len)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (memcmp(rdr->atr.value, atr_buf, rdr->atr.len))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfprintf(stderr, \"Matched ATR in reader: %s\\n\", rdr->name);\n\t\t\t\t\treader = rdr;\n\t\t\t\t\tgoto autofound;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tchar *endptr = NULL;\n\t\t\t\tunsigned int num;\n\n\t\t\t\terrno = 0;\n\t\t\t\tnum = strtol(reader_id, &endptr, 0);\n\t\t\t\tif (!errno && endptr && *endptr == '\\0')\n\t\t\t\t\treader = sc_ctx_get_reader(ctx, num);\n\t\t\t\telse\n\t\t\t\t\treader = sc_ctx_get_reader_by_name(ctx, reader_id);\n\t\t\t}\n\t\t}\nautofound:\n\t\tif (!reader) {\n\t\t\tfprintf(stderr, \"Reader \\\"%s\\\" not found (%d reader(s) detected)\\n\",\n\t\t\t\t\treader_id, sc_ctx_get_reader_count(ctx));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (sc_detect_card_presence(reader) <= 0) {\n\t\t\tfprintf(stderr, \"Card not present.\\n\");\n\t\t\treturn 3;\n\t\t}\n\t}\n\n\tif (verbose)\n\t\tprintf(\"Connecting to card in reader %s...\\n\", reader->name);\n\tr = sc_connect_card(reader, &card);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Failed to connect to card: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\n\tif (verbose)\n\t\tprintf(\"Using card driver %s.\\n\", card->driver->name);\n\n\tif (do_lock) {\n\t\tr = sc_lock(card);\n\t\tif (r < 0) {\n\t\t\tfprintf(stderr, \"Failed to lock card: %s\\n\", sc_strerror(r));\n\t\t\tsc_disconnect_card(card);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t*cardp = card;\n\treturn 0;\n}\n\nint\nutil_connect_card(sc_context_t *ctx, sc_card_t **cardp,\n\t\t const char *reader_id, int do_wait, int verbose)\n{\n\treturn util_connect_card_ex(ctx, cardp, reader_id, do_wait, 1, verbose);\n}\n\nvoid util_print_binary(FILE *f, const u8 *buf, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned char c = buf[i];\n\t\tconst char *format;\n\t\tif (!isprint(c))\n\t\t\tformat = \"\\\\x%02X\";\n\t\telse\n\t\t\tformat = \"%c\";\n\t\tfprintf(f, format, c);\n\t}\n\t(void) fflush(f);\n}\n\nvoid util_hex_dump(FILE *f, const u8 *in, int len, const char *sep)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (sep != NULL && i)\n\t\t\tfprintf(f, \"%s\", sep);\n\t\tfprintf(f, \"%02X\", in[i]);\n\t}\n}\n\nvoid util_hex_dump_asc(FILE *f, const u8 *in, size_t count, int addr)\n{\n\tint lines = 0;\n\n \twhile (count) {\n\t\tchar ascbuf[17];\n\t\tsize_t i;\n\n\t\tif (addr >= 0) {\n\t\t\tfprintf(f, \"%08X: \", addr);\n\t\t\taddr += 16;\n\t\t}\n\t\tfor (i = 0; i < count && i < 16; i++) {\n\t\t\tfprintf(f, \"%02X \", *in);\n\t\t\tif (isprint(*in))\n\t\t\t\tascbuf[i] = *in;\n\t\t\telse\n\t\t\t\tascbuf[i] = '.';\n\t\t\tin++;\n\t\t}\n\t\tcount -= i;\n\t\tascbuf[i] = 0;\n\t\tfor (; i < 16 && lines; i++)\n\t\t\tfprintf(f, \"   \");\n\t\tfprintf(f, \"%s\\n\", ascbuf);\n\t\tlines++;\n\t}\n}\n\nNORETURN void\nutil_print_usage_and_die(const char *app_name, const struct option options[],\n\tconst char *option_help[], const char *args)\n{\n\tint i;\n\tint header_shown = 0;\n\n\tif (args)\n\t\tprintf(\"Usage: %s [OPTIONS] %s\\n\", app_name, args);\n\telse\n\t\tprintf(\"Usage: %s [OPTIONS]\\n\", app_name);\n\n\tfor (i = 0; options[i].name; i++) {\n\t\tchar buf[40];\n\t\tconst char *arg_str;\n\n\t\t/* Skip \"hidden\" options */\n\t\tif (option_help[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif (!header_shown++)\n\t\t\tprintf(\"Options:\\n\");\n\n\t\tswitch (options[i].has_arg) {\n\t\tcase 1:\n\t\t\targ_str = \" <arg>\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\targ_str = \" [arg]\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targ_str = \"\";\n\t\t\tbreak;\n\t\t}\n\t\tif (isascii(options[i].val) &&\n\t\t    isprint(options[i].val) && !isspace(options[i].val))\n\t\t\tsprintf(buf, \"-%c, --%s%s\", options[i].val, options[i].name, arg_str);\n\t\telse\n\t\t\tsprintf(buf, \"    --%s%s\", options[i].name, arg_str);\n\n\t\t/* print the line - wrap if necessary */\n\t\tif (strlen(buf) > 28) {\n\t\t\tprintf(\"  %s\\n\", buf);\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\t\tprintf(\"  %-28s  %s\\n\", buf, option_help[i]);\n\t}\n\n\texit(2);\n}\n\nconst char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n\t\te = e->next;\n\t}\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}\n\nNORETURN void\nutil_fatal(const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"error: \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\nAborting.\\n\");\n\tva_end(ap);\n\n\tsc_notify_close();\n\n\texit(1);\n}\n\nvoid\nutil_error(const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"error: \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n\nvoid\nutil_warn(const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"warning: \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n\nint\nutil_getpass (char **lineptr, size_t *len, FILE *stream)\n{\n#define MAX_PASS_SIZE\t128\n\tchar *buf;\n\tsize_t i;\n\tint ch = 0;\n#ifndef _WIN32\n\tstruct termios old, new;\n\n\tfflush(stdout);\n\tif (tcgetattr (fileno (stdout), &old) != 0)\n\t\treturn -1;\n\tnew = old;\n\tnew.c_lflag &= ~ECHO;\n\tif (tcsetattr (fileno (stdout), TCSAFLUSH, &new) != 0)\n\t\treturn -1;\n#endif\n\n\tbuf = calloc(1, MAX_PASS_SIZE);\n\tif (!buf)\n\t\treturn -1;\n\n\tfor (i = 0; i < MAX_PASS_SIZE - 1; i++) {\n#ifndef _WIN32\n\t\tch = getchar();\n#else\n\t\tch = _getch();\n#endif\n\t\tif (ch == 0 || ch == 3)\n\t\t\tbreak;\n\t\tif (ch == '\\n' || ch == '\\r')\n\t\t\tbreak;\n\n\t\tbuf[i] = (char) ch;\n\t}\n#ifndef _WIN32\n\ttcsetattr (fileno (stdout), TCSAFLUSH, &old);\n\tfputs(\"\\n\", stdout);\n#endif\n\tif (ch == 0 || ch == 3) {\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\n\tif (*lineptr && (!len || *len < i+1)) {\n\t\tfree(*lineptr);\n\t\t*lineptr = NULL;\n\t}\n\n\tif (*lineptr) {\n\t\tmemcpy(*lineptr,buf,i+1);\n\t\tmemset(buf, 0, MAX_PASS_SIZE);\n\t\tfree(buf);\n\t} else {\n\t\t*lineptr = buf;\n\t\tif (len)\n\t\t\t*len = MAX_PASS_SIZE;\n\t}\n\treturn i;\n}\n\nsize_t\nutil_get_pin(const char *input, const char **pin)\n{\n\tsize_t inputlen = strlen(input);\n\tsize_t pinlen = 0;\n\n\tif(inputlen > 4 && strncasecmp(input, \"env:\", 4) == 0) {\n\t\t// Get a PIN from a environment variable\n\t\t*pin = getenv(input + 4);\n\t\tpinlen = *pin ? strlen(*pin) : 0;\n\t} else {\n\t\t//Just use the input\n\t\t*pin = input;\n\t\tpinlen = inputlen;\n\t}\n\treturn pinlen;\n}\n"], "fixing_code": ["/*\n * card-cac.c: Support for CAC from NIST SP800-73\n * card-default.c: Support for cards with no driver\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n * Copyright (C) 2005,2006,2007,2008,2009,2010 Douglas E. Engert <deengert@anl.gov>\n * Copyright (C) 2006, Identity Alliance, Thomas Harning <thomas.harning@identityalliance.com>\n * Copyright (C) 2007, EMC, Russell Larner <rlarner@rsa.com>\n * Copyright (C) 2016 - 2018, Red Hat, Inc.\n *\n * CAC driver author: Robert Relyea <rrelyea@redhat.com>\n * Further work: Jakub Jelen <jjelen@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#ifdef ENABLE_OPENSSL\n\t/* openssl only needed for card administration */\n#include <openssl/evp.h>\n#include <openssl/bio.h>\n#include <openssl/pem.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#endif /* ENABLE_OPENSSL */\n\n#include \"internal.h\"\n#include \"simpletlv.h\"\n#include \"cardctl.h\"\n#ifdef ENABLE_ZLIB\n#include \"compression.h\"\n#endif\n#include \"iso7816.h\"\n\n#define CAC_MAX_SIZE 4096\t\t/* arbitrary, just needs to be 'large enough' */\n/*\n *  CAC hardware and APDU constants\n */\n#define CAC_MAX_CHUNK_SIZE 240\n#define CAC_INS_SIGN_DECRYPT          0x42  /* A crypto operation */\n#define CAC_INS_READ_FILE             0x52  /* read a TL or V file */\n#define CAC_INS_GET_ACR               0x4c\n#define CAC_INS_GET_PROPERTIES        0x56\n#define CAC_P1_STEP    0x80\n#define CAC_P1_FINAL   0x00\n#define CAC_FILE_TAG    1\n#define CAC_FILE_VALUE  2\n/* TAGS in a TL file */\n#define CAC_TAG_CERTIFICATE           0x70\n#define CAC_TAG_CERTINFO              0x71\n#define CAC_TAG_MSCUID                0x72\n#define CAC_TAG_CUID                  0xF0\n#define CAC_TAG_CC_VERSION_NUMBER     0xF1\n#define CAC_TAG_GRAMMAR_VERION_NUMBER 0xF2\n#define CAC_TAG_CARDURL               0xF3\n#define CAC_TAG_PKCS15                0xF4\n#define CAC_TAG_ACCESS_CONTROL        0xF6\n#define CAC_TAG_DATA_MODEL            0xF5\n#define CAC_TAG_CARD_APDU             0xF7\n#define CAC_TAG_REDIRECTION           0xFA\n#define CAC_TAG_CAPABILITY_TUPLES     0xFB\n#define CAC_TAG_STATUS_TUPLES         0xFC\n#define CAC_TAG_NEXT_CCC              0xFD\n#define CAC_TAG_ERROR_CODES           0xFE\n#define CAC_TAG_APPLET_FAMILY         0x01\n#define CAC_TAG_NUMBER_APPLETS        0x94\n#define CAC_TAG_APPLET_ENTRY          0x93\n#define CAC_TAG_APPLET_AID            0x92\n#define CAC_TAG_APPLET_INFORMATION    0x01\n#define CAC_TAG_NUMBER_OF_OBJECTS     0x40\n#define CAC_TAG_TV_BUFFER             0x50\n#define CAC_TAG_PKI_OBJECT            0x51\n#define CAC_TAG_OBJECT_ID             0x41\n#define CAC_TAG_BUFFER_PROPERTIES     0x42\n#define CAC_TAG_PKI_PROPERTIES        0x43\n\n#define CAC_APP_TYPE_GENERAL          0x01\n#define CAC_APP_TYPE_SKI              0x02\n#define CAC_APP_TYPE_PKI              0x04\n\n#define CAC_ACR_ACR                   0x00\n#define CAC_ACR_APPLET_OBJECT         0x10\n#define CAC_ACR_AMP                   0x20\n#define CAC_ACR_SERVICE               0x21\n\n/* hardware data structures (returned in the CCC) */\n/* part of the card_url */\ntypedef struct cac_access_profile {\n\tu8 GCACR_listID;\n\tu8 GCACR_readTagListACRID;\n\tu8 GCACR_updatevalueACRID;\n\tu8 GCACR_readvalueACRID;\n\tu8 GCACR_createACRID;\n\tu8 GCACR_deleteACRID;\n\tu8 CryptoACR_listID;\n\tu8 CryptoACR_getChallengeACRID;\n\tu8 CryptoACR_internalAuthenicateACRID;\n\tu8 CryptoACR_pkiComputeACRID;\n\tu8 CryptoACR_readTagListACRID;\n\tu8 CryptoACR_updatevalueACRID;\n\tu8 CryptoACR_readvalueACRID;\n\tu8 CryptoACR_createACRID;\n\tu8 CryptoACR_deleteACRID;\n} cac_access_profile_t;\n\n/* part of the card url */\ntypedef struct cac_access_key_info {\n\tu8\tkeyFileID[2];\n\tu8\tkeynumber;\n} cac_access_key_info_t;\n\ntypedef struct cac_card_url {\n\tu8 rid[5];\n\tu8 cardApplicationType;\n\tu8 objectID[2];\n\tu8 applicationID[2];\n\tcac_access_profile_t accessProfile;\n\tu8 pinID;\t\t\t     /* not used for VM cards */\n\tcac_access_key_info_t accessKeyInfo; /* not used for VM cards */\n\tu8 keyCryptoAlgorithm;               /* not used for VM cards */\n} cac_card_url_t;\n\ntypedef struct cac_cuid {\n\tu8 gsc_rid[5];\n\tu8 manufacturer_id;\n\tu8 card_type;\n\tu8 card_id;\n} cac_cuid_t;\n\n/* data structures to store meta data about CAC objects */\ntypedef struct cac_object {\n\tconst char *name;\n\tint fd;\n\tsc_path_t path;\n} cac_object_t;\n\n#define CAC_MAX_OBJECTS 16\n\ntypedef struct {\n\t/* OID has two bytes */\n\tunsigned char oid[2];\n\t/* Format is NOT SimpleTLV? */\n\tunsigned char simpletlv;\n\t/* Is certificate object and private key is initialized */\n\tunsigned char privatekey;\n} cac_properties_object_t;\n\ntypedef struct {\n\tunsigned int num_objects;\n\tcac_properties_object_t objects[CAC_MAX_OBJECTS];\n} cac_properties_t;\n\n/*\n * Flags for Current Selected Object Type\n *   CAC files are TLV files, with TL and V separated. For generic\n *   containers we reintegrate the TL anv V portions into a single\n *   file to read. Certs are also TLV files, but pkcs15 wants the\n *   actual certificate. At select time we know the patch which tells\n *   us what time of files we want to read. We remember that type\n *   so that read_binary can do the appropriate processing.\n */\n#define CAC_OBJECT_TYPE_CERT\t\t1\n#define CAC_OBJECT_TYPE_TLV_FILE\t4\n#define CAC_OBJECT_TYPE_GENERIC\t\t5\n\n/*\n * CAC private data per card state\n */\ntypedef struct cac_private_data {\n\tint object_type;\t\t/* select set this so we know how to read the file */\n\tint cert_next;\t\t\t/* index number for the next certificate found in the list */\n\tu8 *cache_buf;\t\t\t/* cached version of the currently selected file */\n\tsize_t cache_buf_len;\t\t/* length of the cached selected file */\n\tint cached;\t\t\t/* is the cached selected file valid */\n\tcac_cuid_t cuid;                /* card unique ID from the CCC */\n\tu8 *cac_id;                     /* card serial number */\n\tsize_t cac_id_len;              /* card serial number len */\n\tlist_t pki_list;                /* list of pki containers */\n\tcac_object_t *pki_current;      /* current pki object _ctl function */\n\tlist_t general_list;            /* list of general containers */\n\tcac_object_t *general_current;  /* current object for _ctl function */\n\tsc_path_t *aca_path;\t\t/* ACA path to be selected before pin verification */\n} cac_private_data_t;\n\n#define CAC_DATA(card) ((cac_private_data_t*)card->drv_data)\n\nint cac_list_compare_path(const void *a, const void *b)\n{\n\tif (a == NULL || b == NULL)\n\t\treturn 1;\n\treturn memcmp( &((cac_object_t *) a)->path,\n\t\t&((cac_object_t *) b)->path, sizeof(sc_path_t));\n}\n\n/* For SimCList autocopy, we need to know the size of the data elements */\nsize_t cac_list_meter(const void *el) {\n\treturn sizeof(cac_object_t);\n}\n\nstatic cac_private_data_t *cac_new_private_data(void)\n{\n\tcac_private_data_t *priv;\n\tpriv = calloc(1, sizeof(cac_private_data_t));\n\tif (!priv)\n\t\treturn NULL;\n\tlist_init(&priv->pki_list);\n\tlist_attributes_comparator(&priv->pki_list, cac_list_compare_path);\n\tlist_attributes_copy(&priv->pki_list, cac_list_meter, 1);\n\tlist_init(&priv->general_list);\n\tlist_attributes_comparator(&priv->general_list, cac_list_compare_path);\n\tlist_attributes_copy(&priv->general_list, cac_list_meter, 1);\n\t/* set other fields as appropriate */\n\n\treturn priv;\n}\n\nstatic void cac_free_private_data(cac_private_data_t *priv)\n{\n\tfree(priv->cac_id);\n\tfree(priv->cache_buf);\n\tfree(priv->aca_path);\n\tlist_destroy(&priv->pki_list);\n\tlist_destroy(&priv->general_list);\n\tfree(priv);\n\treturn;\n}\n\nstatic int cac_add_object_to_list(list_t *list, const cac_object_t *object)\n{\n\tif (list_append(list, object) < 0)\n\t\treturn SC_ERROR_UNKNOWN;\n\treturn SC_SUCCESS;\n}\n\n/*\n * Set up the normal CAC paths\n */\n#define CAC_TO_AID(x) x, sizeof(x)-1\n\n#define CAC_2_RID \"\\xA0\\x00\\x00\\x01\\x16\"\n#define CAC_1_RID \"\\xA0\\x00\\x00\\x00\\x79\"\n\nstatic const sc_path_t cac_ACA_Path = {\n\t\"\", 0,\n\t0,0,SC_PATH_TYPE_DF_NAME,\n\t{ CAC_TO_AID(CAC_1_RID \"\\x10\\x00\") }\n};\n\nstatic const sc_path_t cac_CCC_Path = {\n\t\"\", 0,\n\t0,0,SC_PATH_TYPE_DF_NAME,\n\t{ CAC_TO_AID(CAC_2_RID \"\\xDB\\x00\") }\n};\n\n#define MAX_CAC_SLOTS 16\t\t/* Maximum number of slots is 16 now */\n/* default certificate labels for the CAC card */\nstatic const char *cac_labels[MAX_CAC_SLOTS] = {\n\t\"CAC ID Certificate\",\n\t\"CAC Email Signature Certificate\",\n\t\"CAC Email Encryption Certificate\",\n\t\"CAC Cert 4\",\n\t\"CAC Cert 5\",\n\t\"CAC Cert 6\",\n\t\"CAC Cert 7\",\n\t\"CAC Cert 8\",\n\t\"CAC Cert 9\",\n\t\"CAC Cert 10\",\n\t\"CAC Cert 11\",\n\t\"CAC Cert 12\",\n\t\"CAC Cert 13\",\n\t\"CAC Cert 14\",\n\t\"CAC Cert 15\",\n\t\"CAC Cert 16\"\n};\n\n/* template for a CAC pki object */\nstatic const cac_object_t cac_cac_pki_obj = {\n\t\"CAC Certificate\", 0x0, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t{ CAC_TO_AID(CAC_1_RID \"\\x01\\x00\") } }\n};\n\n/* template for emulated cuid */\nstatic const cac_cuid_t cac_cac_cuid = {\n\t{ 0xa0, 0x00, 0x00, 0x00, 0x79 },\n\t2, 2, 0\n};\n\n/*\n *  CAC general objects defined in 4.3.1.2 of CAC Applet Developer Guide Version 1.0.\n *   doubles as a source for CAC-2 labels.\n */\nstatic const cac_object_t cac_objects[] = {\n\t{ \"Person Instance\", 0x200, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\x00\") }}},\n\t{ \"Personnel\", 0x201, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\x01\") }}},\n\t{ \"Benefits\", 0x202, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\x02\") }}},\n\t{ \"Other Benefits\", 0x203, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\x03\") }}},\n\t{ \"PKI Credential\", 0x2FD, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\xFD\") }}},\n\t{ \"PKI Certificate\", 0x2FE, { { 0 }, 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ CAC_TO_AID(CAC_1_RID \"\\x02\\xFE\") }}},\n};\n\nstatic const int cac_object_count = sizeof(cac_objects)/sizeof(cac_objects[0]);\n\n/*\n * use the object id to find our object info on the object in our CAC-1 list\n */\nstatic const cac_object_t *cac_find_obj_by_id(unsigned short object_id)\n{\n\tint i;\n\n\tfor (i = 0; i < cac_object_count; i++) {\n\t\tif (cac_objects[i].fd == object_id) {\n\t\t\treturn &cac_objects[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n * Lookup the path in the pki list to see if it is a cert path\n */\nstatic int cac_is_cert(cac_private_data_t * priv, const sc_path_t *in_path)\n{\n\tcac_object_t test_obj;\n\ttest_obj.path = *in_path;\n\ttest_obj.path.index = 0;\n\ttest_obj.path.count = 0;\n\n\treturn (list_contains(&priv->pki_list, &test_obj) != 0);\n}\n\n/*\n * Send a command and receive data.\n *\n * A caller may provide a buffer, and length to read. If not provided,\n * an internal 4096 byte buffer is used, and a copy is returned to the\n * caller. that need to be freed by the caller.\n *\n * modelled after a similar function in card-piv.c\n */\n\nstatic int cac_apdu_io(sc_card_t *card, int ins, int p1, int p2,\n\tconst u8 * sendbuf, size_t sendbuflen, u8 ** recvbuf,\n\tsize_t * recvbuflen)\n{\n\tint r;\n\tsc_apdu_t apdu;\n\tu8 rbufinitbuf[CAC_MAX_SIZE];\n\tu8 *rbuf;\n\tsize_t rbuflen;\n\tunsigned int apdu_case = SC_APDU_CASE_1;\n\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"%02x %02x %02x %\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t ins, p1, p2, sendbuflen, card->max_send_size,\n\t\t card->max_recv_size);\n\n\trbuf = rbufinitbuf;\n\trbuflen = sizeof(rbufinitbuf);\n\n\t/* if caller provided a buffer and length */\n\tif (recvbuf && *recvbuf && recvbuflen && *recvbuflen) {\n\t\trbuf = *recvbuf;\n\t\trbuflen = *recvbuflen;\n\t}\n\n\tif (recvbuf) {\n\t\tif (sendbuf)\n\t\t\tapdu_case = SC_APDU_CASE_4_SHORT;\n\t\telse\n\t\t\tapdu_case = SC_APDU_CASE_2_SHORT;\n\t} else if (sendbuf)\n\t\tapdu_case = SC_APDU_CASE_3_SHORT;\n\n\n\tsc_format_apdu(card, &apdu, apdu_case, ins, p1, p2);\n\n\tapdu.lc = sendbuflen;\n\tapdu.datalen = sendbuflen;\n\tapdu.data = sendbuf;\n\n\tif (recvbuf) {\n\t\tapdu.resp = rbuf;\n\t\tapdu.le = (rbuflen > 255) ? 255 : rbuflen;\n\t\tapdu.resplen = rbuflen;\n\t} else {\n\t\t apdu.resp =  rbuf;\n\t\t apdu.le = 0;\n\t\t apdu.resplen = 0;\n\t}\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"calling sc_transmit_apdu flags=%lx le=%\"SC_FORMAT_LEN_SIZE_T\"u, resplen=%\"SC_FORMAT_LEN_SIZE_T\"u, resp=%p\",\n\t\t apdu.flags, apdu.le, apdu.resplen, apdu.resp);\n\n\t/* with new adpu.c and chaining, this actually reads the whole object */\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"result r=%d apdu.resplen=%\"SC_FORMAT_LEN_SIZE_T\"u sw1=%02x sw2=%02x\",\n\t\t r, apdu.resplen, apdu.sw1, apdu.sw2);\n\tif (r < 0) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\"Transmit failed\");\n\t\tgoto err;\n\t}\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\n\tif (r < 0) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Card returned error \");\n\t\tgoto err;\n\t}\n\n\tif (recvbuflen) {\n\t\tif (recvbuf && *recvbuf == NULL) {\n\t\t\t*recvbuf =  malloc(apdu.resplen);\n\t\t\tif (*recvbuf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tmemcpy(*recvbuf, rbuf, apdu.resplen);\n\t\t}\n\t\t*recvbuflen =  apdu.resplen;\n\t\tr = *recvbuflen;\n\t}\n\nerr:\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\n/*\n * Get ACR of currently ACA applet identified by the  acr_type\n * 5.3.3.5 Get ACR APDU\n */\nstatic int\ncac_get_acr(sc_card_t *card, int acr_type, u8 **out_buf, size_t *out_len)\n{\n\tu8 *out = NULL;\n\t/* XXX assuming it will not be longer than 255 B */\n\tsize_t len = 256;\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* for simplicity we support only ACR without arguments now */\n\tif (acr_type != 0x00 && acr_type != 0x10\n\t    && acr_type != 0x20 && acr_type != 0x21) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tr = cac_apdu_io(card, CAC_INS_GET_ACR, acr_type, 0, NULL, 0, &out, &len);\n\tif (len == 0) {\n\t\tr = SC_ERROR_FILE_NOT_FOUND;\n\t}\n\tif (r < 0)\n\t\tgoto fail;\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t    \"got %\"SC_FORMAT_LEN_SIZE_T\"u bytes out=%p\", len, out);\n\n\t*out_len = len;\n\t*out_buf = out;\n\treturn SC_SUCCESS;\n\nfail:\n\tif (out)\n\t\tfree(out);\n\t*out_buf = NULL;\n\t*out_len = 0;\n\treturn r;\n}\n\n/*\n * Read a CAC TLV file. Parameters specify if the TLV file is TL (Tag/Length) file or a V (value) file\n */\n#define HIGH_BYTE_OF_SHORT(x) (((x)>> 8) & 0xff)\n#define LOW_BYTE_OF_SHORT(x) ((x) & 0xff)\nstatic int cac_read_file(sc_card_t *card, int file_type, u8 **out_buf, size_t *out_len)\n{\n\tu8 params[2];\n\tu8 count[2];\n\tu8 *out = NULL;\n\tu8 *out_ptr;\n\tsize_t offset = 0;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\n\tparams[0] = file_type;\n\tparams[1] = 2;\n\n\t/* get the size */\n\tlen = sizeof(count);\n\tout_ptr = count;\n\tr = cac_apdu_io(card, CAC_INS_READ_FILE, 0, 0, &params[0], sizeof(params), &out_ptr, &len);\n\tif (len == 0) {\n\t\tr = SC_ERROR_FILE_NOT_FOUND;\n\t}\n\tif (r < 0)\n\t\tgoto fail;\n\n\tleft = size = lebytes2ushort(count);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"got %\"SC_FORMAT_LEN_SIZE_T\"u bytes out_ptr=%p count&=%p count[0]=0x%02x count[1]=0x%02x, len=0x%04\"SC_FORMAT_LEN_SIZE_T\"x (%\"SC_FORMAT_LEN_SIZE_T\"u)\",\n\t\t len, out_ptr, &count, count[0], count[1], size, size);\n\tout = out_ptr = malloc(size);\n\tif (out == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto fail;\n\t}\n\tfor (offset += 2; left > 0; offset += len, left -= len, out_ptr += len) {\n\t\tlen = MIN(left, CAC_MAX_CHUNK_SIZE);\n\t\tparams[1] = len;\n\t\tr = cac_apdu_io(card, CAC_INS_READ_FILE, HIGH_BYTE_OF_SHORT(offset), LOW_BYTE_OF_SHORT(offset),\n\t\t\t\t\t\t&params[0], sizeof(params), &out_ptr, &len);\n\t\t/* if there is no data, assume there is no file */\n\t\tif (len == 0) {\n\t\t\tr = SC_ERROR_FILE_NOT_FOUND;\n\t\t}\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*out_len = size;\n\t*out_buf = out;\n\treturn SC_SUCCESS;\nfail:\n\tif (out)\n\t\tfree(out);\n\t*out_len = 0;\n\treturn r;\n}\n\n\n/*\n * Callers of this may be expecting a certificate,\n * select file will have saved the object type for us\n * as well as set that we want the cert from the object.\n */\nstatic int cac_read_binary(sc_card_t *card, unsigned int idx,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tint r = 0;\n\tu8 *tl = NULL, *val = NULL;\n\tu8 *tl_ptr, *val_ptr, *tlv_ptr, *tl_start;\n\tu8 *cert_ptr;\n\tsize_t tl_len, val_len, tlv_len;\n\tsize_t len, tl_head_len, cert_len;\n\tu8 cert_type, tag;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* if we didn't return it all last time, return the remainder */\n\tif (priv->cached) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t idx, count);\n\t\tif (idx > priv->cache_buf_len) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_END_REACHED);\n\t\t}\n\t\tlen = MIN(count, priv->cache_buf_len-idx);\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, len);\n\t}\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t idx, count);\n\tif (priv->cache_buf) {\n\t\tfree(priv->cache_buf);\n\t\tpriv->cache_buf = NULL;\n\t\tpriv->cache_buf_len = 0;\n\t}\n\n\n\tif (priv->object_type <= 0)\n\t\t SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INTERNAL);\n\n\tr = cac_read_file(card, CAC_FILE_TAG, &tl, &tl_len);\n\tif (r < 0)  {\n\t\tgoto done;\n\t}\n\n\tr = cac_read_file(card, CAC_FILE_VALUE, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tswitch (priv->object_type) {\n\tcase CAC_OBJECT_TYPE_TLV_FILE:\n\t\ttlv_len = tl_len + val_len;\n\t\tpriv->cache_buf = malloc(tlv_len);\n\t\tif (priv->cache_buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->cache_buf_len = tlv_len;\n\n\t\tfor (tl_ptr = tl, val_ptr=val, tlv_ptr = priv->cache_buf;\n\t\t\t\ttl_len >= 2 && tlv_len > 0;\n\t\t\t\tval_len -= len, tlv_len -= len, val_ptr += len, tlv_ptr += len) {\n\t\t\t/* get the tag and the length */\n\t\t\ttl_start = tl_ptr;\n\t\t\tif (sc_simpletlv_read_tag(&tl_ptr, tl_len, &tag, &len) != SC_SUCCESS)\n\t\t\t\tbreak;\n\t\t\ttl_head_len = (tl_ptr - tl_start);\n\t\t\tsc_simpletlv_put_tag(tag, len, tlv_ptr, tlv_len, &tlv_ptr);\n\t\t\ttlv_len -= tl_head_len;\n\t\t\ttl_len -= tl_head_len;\n\n\t\t\t/* don't crash on bad data */\n\t\t\tif (val_len < len) {\n\t\t\t\tlen = val_len;\n\t\t\t}\n\t\t\t/* if we run out of return space, truncate */\n\t\t\tif (tlv_len < len) {\n\t\t\t\tlen = tlv_len;\n\t\t\t}\n\t\t\tmemcpy(tlv_ptr, val_ptr, len);\n\t\t}\n\t\tbreak;\n\n\tcase CAC_OBJECT_TYPE_CERT:\n\t\t/* read file */\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \" obj= cert_file, val_len=%\"SC_FORMAT_LEN_SIZE_T\"u (0x%04\"SC_FORMAT_LEN_SIZE_T\"x)\",\n\t\t\t val_len, val_len);\n\t\tcert_len = 0;\n\t\tcert_ptr = NULL;\n\t\tcert_type = 0;\n\t\tfor (tl_ptr = tl, val_ptr = val; tl_len >= 2;\n\t\t    val_len -= len, val_ptr += len, tl_len -= tl_head_len) {\n\t\t\ttl_start = tl_ptr;\n\t\t\tif (sc_simpletlv_read_tag(&tl_ptr, tl_len, &tag, &len) != SC_SUCCESS)\n\t\t\t\tbreak;\n\t\t\ttl_head_len = tl_ptr - tl_start;\n\n\t\t\t/* incomplete value */\n\t\t\tif (val_len < len)\n\t\t\t\tbreak;\n\n\t\t\tif (tag == CAC_TAG_CERTIFICATE) {\n\t\t\t\tcert_len = len;\n\t\t\t\tcert_ptr = val_ptr;\n\t\t\t}\n\t\t\tif (tag == CAC_TAG_CERTINFO) {\n\t\t\t\tif ((len >= 1) && (val_len >=1)) {\n\t\t\t\t\tcert_type = *val_ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tag == CAC_TAG_MSCUID) {\n\t\t\t\tsc_log_hex(card->ctx, \"MSCUID\", val_ptr, len);\n\t\t\t}\n\t\t\tif ((val_len < len) || (tl_len < tl_head_len)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* if the info byte is 1, then the cert is compressed, decompress it */\n\t\tif ((cert_type & 0x3) == 1) {\n#ifdef ENABLE_ZLIB\n\t\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,\n\t\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);\n#else\n\t\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");\n\t\t\tr = SC_ERROR_NOT_SUPPORTED;\n#endif\n\t\t\tif (r)\n\t\t\t\tgoto done;\n\t\t} else if (cert_len > 0) {\n\t\t\tpriv->cache_buf = malloc(cert_len);\n\t\t\tif (priv->cache_buf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tpriv->cache_buf_len = cert_len;\n\t\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);\n\t\t} else {\n\t\t\tsc_log(card->ctx, \"Can't read zero-length certificate\");\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase CAC_OBJECT_TYPE_GENERIC:\n\t\t/* TODO\n\t\t * We have some two buffers in unknown encoding that we\n\t\t * need to present in PKCS#15 layer.\n\t\t */\n\tdefault:\n\t\t/* Unknown object type */\n\t\tsc_log(card->ctx, \"Unknown object type: %x\", priv->object_type);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto done;\n\t}\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tpriv->cached = 1;\n\tlen = MIN(count, priv->cache_buf_len-idx);\n\tmemcpy(buf, &priv->cache_buf[idx], len);\n\tr = len;\ndone:\n\tif (tl)\n\t\tfree(tl);\n\tif (val)\n\t\tfree(val);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\n/* CAC driver is read only */\nstatic int cac_write_binary(sc_card_t *card, unsigned int idx,\n\t\tconst u8 *buf, size_t count, unsigned long flags)\n{\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_NOT_SUPPORTED);\n}\n\n/* initialize getting a list and return the number of elements in the list */\nstatic int cac_get_init_and_get_count(list_t *list, cac_object_t **entry, int *countp)\n{\n\t*countp = list_size(list);\n\tlist_iterator_start(list);\n\t*entry = list_iterator_next(list);\n\treturn SC_SUCCESS;\n}\n\n/* finalize the list iterator */\nstatic int cac_final_iterator(list_t *list)\n{\n\tlist_iterator_stop(list);\n\treturn SC_SUCCESS;\n}\n\n/* fill in the obj_info for the current object on the list and advance to the next object */\nstatic int cac_fill_object_info(list_t *list, cac_object_t **entry, sc_pkcs15_data_info_t *obj_info)\n{\n\tmemset(obj_info, 0, sizeof(sc_pkcs15_data_info_t));\n\tif (*entry == NULL) {\n\t\treturn SC_ERROR_FILE_END_REACHED;\n\t}\n\n\tobj_info->path = (*entry)->path;\n\tobj_info->path.count = CAC_MAX_SIZE-1; /* read something from the object */\n\tobj_info->id.value[0] = ((*entry)->fd >> 8) & 0xff;\n\tobj_info->id.value[1] = (*entry)->fd & 0xff;\n\tobj_info->id.len = 2;\n\tstrncpy(obj_info->app_label, (*entry)->name, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t*entry = list_iterator_next(list);\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}\n\nstatic int cac_get_ACA_path(sc_card_t *card, sc_path_t *path)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n\tif (priv->aca_path) {\n\t\t*path = *priv->aca_path;\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n}\n\nstatic int cac_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_log(card->ctx, \"cmd=%ld ptr=%p\", cmd, ptr);\n\n\tif (priv == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t}\n\tswitch(cmd) {\n\t\tcase SC_CARDCTL_CAC_GET_ACA_PATH:\n\t\t\treturn cac_get_ACA_path(card, (sc_path_t *) ptr);\n\t\tcase SC_CARDCTL_GET_SERIALNR:\n\t\t\treturn cac_get_serial_nr_from_CUID(card, (sc_serial_number_t *) ptr);\n\t\tcase SC_CARDCTL_CAC_INIT_GET_GENERIC_OBJECTS:\n\t\t\treturn cac_get_init_and_get_count(&priv->general_list, &priv->general_current, (int *)ptr);\n\t\tcase SC_CARDCTL_CAC_INIT_GET_CERT_OBJECTS:\n\t\t\treturn cac_get_init_and_get_count(&priv->pki_list, &priv->pki_current, (int *)ptr);\n\t\tcase SC_CARDCTL_CAC_GET_NEXT_GENERIC_OBJECT:\n\t\t\treturn cac_fill_object_info(&priv->general_list, &priv->general_current, (sc_pkcs15_data_info_t *)ptr);\n\t\tcase SC_CARDCTL_CAC_GET_NEXT_CERT_OBJECT:\n\t\t\treturn cac_fill_object_info(&priv->pki_list, &priv->pki_current, (sc_pkcs15_data_info_t *)ptr);\n\t\tcase SC_CARDCTL_CAC_FINAL_GET_GENERIC_OBJECTS:\n\t\t\treturn cac_final_iterator(&priv->general_list);\n\t\tcase SC_CARDCTL_CAC_FINAL_GET_CERT_OBJECTS:\n\t\t\treturn cac_final_iterator(&priv->pki_list);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n}\n\nstatic int cac_get_challenge(sc_card_t *card, u8 *rnd, size_t len)\n{\n\t/* CAC requires 8 byte response */\n\tu8 rbuf[8];\n\tu8 *rbufp = &rbuf[0];\n\tsize_t out_len = sizeof rbuf;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = cac_apdu_io(card, 0x84, 0x00, 0x00, NULL, 0, &rbufp, &out_len);\n\tLOG_TEST_RET(card->ctx, r, \"Could not get challenge\");\n\n\tif (len < out_len) {\n\t\tout_len = len;\n\t}\n\tmemcpy(rnd, rbuf, out_len);\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, (int) out_len);\n}\n\nstatic int cac_set_security_env(sc_card_t *card, const sc_security_env_t *env, int se_num)\n{\n\tint r = SC_SUCCESS;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"flags=%08lx op=%d alg=%d algf=%08x algr=%08x kr0=%02x, krfl=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t env->flags, env->operation, env->algorithm,\n\t\t env->algorithm_flags, env->algorithm_ref, env->key_ref[0],\n\t\t env->key_ref_len);\n\n\tif (env->algorithm != SC_ALGORITHM_RSA) {\n\t\t r = SC_ERROR_NO_CARD_SUPPORT;\n\t}\n\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\n\nstatic int cac_restore_security_env(sc_card_t *card, int se_num)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n}\n\n\nstatic int cac_rsa_op(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tu8 *outp, *rbuf;\n\tsize_t rbuflen, outplen;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t \"datalen=%\"SC_FORMAT_LEN_SIZE_T\"u outlen=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t datalen, outlen);\n\n\toutp = out;\n\toutplen = outlen;\n\n\t/* Not strictly necessary. This code requires the caller to have selected the correct PKI container\n\t * and authenticated to that container with the verifyPin command... All of this under the reader lock.\n\t * The PKCS #15 higher level driver code does all this correctly (it's the same for all cards, just\n\t * different sets of APDU's that need to be called), so this call is really a little bit of paranoia */\n\tr = sc_lock(card);\n\tif (r != SC_SUCCESS)\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n\n\n\trbuf = NULL;\n\trbuflen = 0;\n\tfor (; datalen > CAC_MAX_CHUNK_SIZE; data += CAC_MAX_CHUNK_SIZE, datalen -= CAC_MAX_CHUNK_SIZE) {\n\t\tr = cac_apdu_io(card, CAC_INS_SIGN_DECRYPT, CAC_P1_STEP,  0,\n\t\t\tdata, CAC_MAX_CHUNK_SIZE, &rbuf, &rbuflen);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (rbuflen != 0) {\n\t\t\tint n = MIN(rbuflen, outplen);\n\t\t\tmemcpy(outp,rbuf, n);\n\t\t\toutp += n;\n\t\t\toutplen -= n;\n\t\t}\n\t\tfree(rbuf);\n\t\trbuf = NULL;\n\t\trbuflen = 0;\n\t}\n\tif (r < 0) {\n\t\tgoto err;\n\t}\n\trbuf = NULL;\n\trbuflen = 0;\n\tr = cac_apdu_io(card, CAC_INS_SIGN_DECRYPT, CAC_P1_FINAL, 0, data, datalen, &rbuf, &rbuflen);\n\tif (r < 0) {\n\t\tgoto err;\n\t}\n\tif (rbuflen != 0) {\n\t\tint n = MIN(rbuflen, outplen);\n\t\tmemcpy(outp,rbuf, n);\n\t\t/*outp += n;     unused */\n\t\toutplen -= n;\n\t}\n\tfree(rbuf);\n\trbuf = NULL;\n\tr = outlen-outplen;\n\nerr:\n\tsc_unlock(card);\n\tif (r < 0) {\n\t\tsc_mem_clear(out, outlen);\n\t}\n\tif (rbuf) {\n\t\tfree(rbuf);\n\t}\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\nstatic int cac_compute_signature(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, cac_rsa_op(card, data, datalen, out, outlen));\n}\n\nstatic int cac_decipher(sc_card_t *card,\n\t\t\t\t\t const u8 * data, size_t datalen,\n\t\t\t\t\t u8 * out, size_t outlen)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, cac_rsa_op(card, data, datalen, out, outlen));\n}\n\nstatic int cac_parse_properties_object(sc_card_t *card, u8 type,\n    u8 *data, size_t data_len, cac_properties_object_t *object)\n{\n\tsize_t len;\n\tu8 *val, *val_end, tag;\n\tint parsed = 0;\n\n\tif (data_len < 11)\n\t\treturn -1;\n\n\t/* Initilize: non-PKI applet */\n\tobject->privatekey = 0;\n\n\tval = data;\n\tval_end = data + data_len;\n\tfor (; val < val_end; val += len) {\n\t\t/* get the tag and the length */\n\t\tif (sc_simpletlv_read_tag(&val, val_end - val, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_OBJECT_ID:\n\t\t\tif (len != 2) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Object ID: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Object ID = 0x%02x 0x%02x\", val[0], val[1]);\n\t\t\tmemcpy(&object->oid, val, 2);\n\t\t\tparsed++;\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_BUFFER_PROPERTIES:\n\t\t\tif (len != 5) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Buffer Properties: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* First byte is \"Type of Tag Supported\" */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Buffer Properties: Type of Tag Supported = 0x%02x\",\n\t\t\t    val[0]);\n\t\t\tobject->simpletlv = val[0];\n\t\t\tparsed++;\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_PKI_PROPERTIES:\n\t\t\t/* 4th byte is \"Private Key Initialized\" */\n\t\t\tif (len != 4) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKI Properties: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (type != CAC_TAG_PKI_OBJECT) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKI Properties outside of PKI Object\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: PKI Properties: Private Key Initialized = 0x%02x\",\n\t\t\t    val[2]);\n\t\t\tobject->privatekey = val[2];\n\t\t\tparsed++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Unknown (0x%02x)\",tag );\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (parsed < 2)\n\t\treturn SC_ERROR_INVALID_DATA;\n\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_get_properties(sc_card_t *card, cac_properties_t *prop)\n{\n\tu8 *rbuf = NULL;\n\tsize_t rbuflen = 0, len;\n\tu8 *val, *val_end, tag;\n\tsize_t i = 0;\n\tint r;\n\tprop->num_objects = 0;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = cac_apdu_io(card, CAC_INS_GET_PROPERTIES, 0x01, 0x00, NULL, 0,\n\t\t&rbuf, &rbuflen);\n\tif (r < 0)\n\t\treturn r;\n\n\tval = rbuf;\n\tval_end = val + rbuflen;\n\tfor (; val < val_end; val += len) {\n\t\t/* get the tag and the length */\n\t\tif (sc_simpletlv_read_tag(&val, val_end - val, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_APPLET_INFORMATION:\n\t\t\tif (len != 5) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Applet Information: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Applet Information: Family: 0x%0x\", val[0]);\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"     Applet Version: 0x%02x 0x%02x 0x%02x 0x%02x\",\n\t\t\t    val[1], val[2], val[3], val[4]);\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_NUMBER_OF_OBJECTS:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Num objects: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Num objects = %hhd\", *val);\n\t\t\t/* make sure we do not overrun buffer */\n\t\t\tprop->num_objects = MIN(val[0], CAC_MAX_OBJECTS);\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_TV_BUFFER:\n\t\t\tif (len != 17) {\n\t\t\t\tsc_log(card->ctx, \"TAG: TV Object: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: TV Object nr. %\"SC_FORMAT_LEN_SIZE_T\"u\", i);\n\t\t\tif (i >= CAC_MAX_OBJECTS) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\n\t\t\tif (cac_parse_properties_object(card, tag, val, len,\n\t\t\t    &prop->objects[i]) == SC_SUCCESS)\n\t\t\t\ti++;\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_PKI_OBJECT:\n\t\t\tif (len != 17) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKI Object: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: PKI Object nr. %\"SC_FORMAT_LEN_SIZE_T\"u\", i);\n\t\t\tif (i >= CAC_MAX_OBJECTS) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\n\t\t\tif (cac_parse_properties_object(card, tag, val, len,\n\t\t\t    &prop->objects[i]) == SC_SUCCESS)\n\t\t\t\ti++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_log(card->ctx, \"TAG: Unknown (0x%02x), len=%\"\n\t\t\t    SC_FORMAT_LEN_SIZE_T\"u\", tag, len);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(rbuf);\n\t/* sanity */\n\tif (i != prop->num_objects)\n\t\tsc_log(card->ctx, \"The announced number of objects (%u) \"\n\t\t    \"did not match reality (%\"SC_FORMAT_LEN_SIZE_T\"u)\",\n\t\t    prop->num_objects, i);\n\tprop->num_objects = i;\n\n\treturn SC_SUCCESS;\n}\n\n/*\n * CAC cards use SC_PATH_SELECT_OBJECT_ID rather than SC_PATH_SELECT_FILE_ID. In order to use more\n * of the PKCS #15 structure, we call the selection SC_PATH_SELECT_FILE_ID, but we set p1 to 2 instead\n * of 0. Also cac1 does not do any FCI, but it doesn't understand not selecting it. It returns invalid INS\n * if it doesn't like anything about the select, so we always 'request' FCI for CAC1\n *\n * The rest is just copied from iso7816_select_file\n */\nstatic int cac_select_file_by_type(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out, int type)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char buf[SC_MAX_APDU_BUFFER_SIZE];\n\tunsigned char pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tint r, pathlen, pathtype;\n\tstruct sc_file *file = NULL;\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tassert(card != NULL && in_path != NULL);\n\tctx = card->ctx;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\tpathtype = in_path->type;\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"path->aid=%x %x %x %x %x %x %x  len=%\"SC_FORMAT_LEN_SIZE_T\"u, path->value = %x %x %x %x len=%\"SC_FORMAT_LEN_SIZE_T\"u path->type=%d (%x)\",\n\t\t in_path->aid.value[0], in_path->aid.value[1],\n\t\t in_path->aid.value[2], in_path->aid.value[3],\n\t\t in_path->aid.value[4], in_path->aid.value[5],\n\t\t in_path->aid.value[6], in_path->aid.len, in_path->value[0],\n\t\t in_path->value[1], in_path->value[2], in_path->value[3],\n\t\t in_path->len, in_path->type, in_path->type);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"file_out=%p index=%d count=%d\\n\",\n\t\t file_out, in_path->index, in_path->count);\n\n\t/* Sigh, sc_key_select expects paths to keys to have specific formats. There is no override.\n\t * we have to add some bytes to the path to make it happy. A better fix would be to give sc_key_file\n\t * a flag that says 'no, really this path is fine'.  We only need to do this for private keys */\n\tif ((pathlen > 2) && (pathlen <= 4) && memcmp(path, \"\\x3F\\x00\", 2) == 0) {\n\t\tif (pathlen > 2) {\n\t\t\tpath += 2;\n\t\t\tpathlen -= 2;\n\t\t}\n\t}\n\n\n\t/* CAC has multiple different type of objects that aren't PKCS #15. When we read\n\t * them we need convert them to something PKCS #15 would understand. Find the object\n\t * and object type here:\n\t */\n\tif (priv) { /* don't record anything if we haven't been initialized yet */\n\t\tpriv->object_type = CAC_OBJECT_TYPE_GENERIC;\n\t\tif (cac_is_cert(priv, in_path)) {\n\t\t\tpriv->object_type = CAC_OBJECT_TYPE_CERT;\n\t\t}\n\n\t\t/* forget any old cached values */\n\t\tif (priv->cache_buf) {\n\t\t\tfree(priv->cache_buf);\n\t\t\tpriv->cache_buf = NULL;\n\t\t}\n\t\tpriv->cache_buf_len = 0;\n\t\tpriv->cached = 0;\n\t}\n\n\tif (in_path->aid.len) {\n\t\tif (!pathlen) {\n\t\t\tmemcpy(path, in_path->aid.value, in_path->aid.len);\n\t\t\tpathlen = in_path->aid.len;\n\t\t\tpathtype = SC_PATH_TYPE_DF_NAME;\n\t\t} else {\n\t\t\t/* First, select the application */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"select application\" );\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 4, 0);\n\t\t\tapdu.data = in_path->aid.value;\n\t\t\tapdu.datalen = in_path->aid.len;\n\t\t\tapdu.lc = in_path->aid.len;\n\n\t\t\tr = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (r)\n\t\t\t\tLOG_FUNC_RETURN(ctx, r);\n\n\t\t}\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0);\n\n\tswitch (pathtype) {\n\t/* ideally we would had SC_PATH_TYPE_OBJECT_ID and add code to the iso7816 select.\n\t * Unfortunately we'd also need to update the caching code as well. For now just\n\t * use FILE_ID and change p1 here */\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tapdu.p1 = 2;\n\t\tif (pathlen != 2)\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\tapdu.resp = buf;\n\tapdu.resplen = sizeof(buf);\n\tapdu.le = sc_get_max_recv_size(card) < 256 ? sc_get_max_recv_size(card) : 256;\n\n\tif (file_out != NULL) {\n\t\tapdu.p2 = 0;\t\t/* first record, return FCI */\n\t}\n\telse {\n\t\tapdu.p2 = 0x0C;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\n\tif (file_out == NULL) {\n\t\t/* For some cards 'SELECT' can be only with request to return FCI/FCP. */\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (apdu.sw1 == 0x6A && apdu.sw2 == 0x86)   {\n\t\t\tapdu.p2 = 0x00;\n\t\t\tapdu.resplen = sizeof(buf);\n\t\t\tif (sc_transmit_apdu(card, &apdu) == SC_SUCCESS)\n\t\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t}\n\t\tif (apdu.sw1 == 0x61)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r)\n\t\tLOG_FUNC_RETURN(ctx, r);\n\n\t/* This needs to come after the applet selection */\n\tif (priv && in_path->len >= 2) {\n\t\t/* get applet properties to know if we can treat the\n\t\t * buffer as SimpleLTV and if we have PKI applet.\n\t\t *\n\t\t * Do this only if we select applets for reading\n\t\t * (not during driver initialization)\n\t\t */\n\t\tcac_properties_t prop;\n\t\tsize_t i = -1;\n\n\t\tr = cac_get_properties(card, &prop);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tfor (i = 0; i < prop.num_objects; i++) {\n\t\t\t\tsc_log(card->ctx, \"Searching for our OID: 0x%02x 0x%02x = 0x%02x 0x%02x\",\n\t\t\t\t    prop.objects[i].oid[0], prop.objects[i].oid[1],\n\t\t\t\t\tin_path->value[0], in_path->value[1]);\n\t\t\t\tif (memcmp(prop.objects[i].oid,\n\t\t\t\t    in_path->value, 2) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i < prop.num_objects) {\n\t\t\tif (prop.objects[i].privatekey)\n\t\t\t\tpriv->object_type = CAC_OBJECT_TYPE_CERT;\n\t\t\telse if (prop.objects[i].simpletlv == 0)\n\t\t\t\tpriv->object_type = CAC_OBJECT_TYPE_TLV_FILE;\n\t\t}\n\t}\n\n\t/* CAC cards never return FCI, fake one */\n\tfile = sc_file_new();\n\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tfile->path = *in_path;\n\tfile->size = CAC_MAX_SIZE; /* we don't know how big, just give a large size until we can read the file */\n\n\t*file_out = file;\n\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\n}\n\nstatic int cac_select_file(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\treturn cac_select_file_by_type(card, in_path, file_out, card->type);\n}\n\nstatic int cac_finish(sc_card_t *card)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (priv) {\n\t\tcac_free_private_data(priv);\n\t}\n\treturn SC_SUCCESS;\n}\n\n\n/* select the Card Capabilities Container on CAC-2 */\nstatic int cac_select_CCC(sc_card_t *card)\n{\n\treturn cac_select_file_by_type(card, &cac_CCC_Path, NULL, SC_CARD_TYPE_CAC_II);\n}\n\n/* Select ACA in non-standard location */\nstatic int cac_select_ACA(sc_card_t *card)\n{\n\treturn cac_select_file_by_type(card, &cac_ACA_Path, NULL, SC_CARD_TYPE_CAC_II);\n}\n\nstatic int cac_path_from_cardurl(sc_card_t *card, sc_path_t *path, cac_card_url_t *val, int len)\n{\n\tif (len < 10) {\n\t\treturn SC_ERROR_INVALID_DATA;\n\t}\n\tsc_mem_clear(path, sizeof(sc_path_t));\n\tmemcpy(path->aid.value, &val->rid, sizeof(val->rid));\n\tmemcpy(&path->aid.value[5], &val->applicationID, sizeof(val->applicationID));\n\tpath->aid.len = sizeof(val->rid) + sizeof(val->applicationID);\n\tmemcpy(path->value, &val->objectID, sizeof(val->objectID));\n\tpath->len = sizeof(val->objectID);\n\tpath->type = SC_PATH_TYPE_FILE_ID;\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"path->aid=%x %x %x %x %x %x %x  len=%\"SC_FORMAT_LEN_SIZE_T\"u, path->value = %x %x len=%\"SC_FORMAT_LEN_SIZE_T\"u path->type=%d (%x)\",\n\t\t path->aid.value[0], path->aid.value[1], path->aid.value[2],\n\t\t path->aid.value[3], path->aid.value[4], path->aid.value[5],\n\t\t path->aid.value[6], path->aid.len, path->value[0],\n\t\t path->value[1], path->len, path->type, path->type);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"rid=%x %x %x %x %x  len=%\"SC_FORMAT_LEN_SIZE_T\"u appid= %x %x len=%\"SC_FORMAT_LEN_SIZE_T\"u objid= %x %x len=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t val->rid[0], val->rid[1], val->rid[2], val->rid[3],\n\t\t val->rid[4], sizeof(val->rid), val->applicationID[0],\n\t\t val->applicationID[1], sizeof(val->applicationID),\n\t\t val->objectID[0], val->objectID[1], sizeof(val->objectID));\n\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_parse_aid(sc_card_t *card, cac_private_data_t *priv, u8 *aid, int aid_len)\n{\n\tcac_object_t new_object;\n\tcac_properties_t prop;\n\tsize_t i;\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* Search for PKI applets (7 B). Ignore generic objects for now */\n\tif (aid_len != 7 || (memcmp(aid, CAC_1_RID \"\\x01\", 6) != 0\n\t    && memcmp(aid, CAC_1_RID \"\\x00\", 6) != 0))\n\t\treturn SC_SUCCESS;\n\n\tsc_mem_clear(&new_object.path, sizeof(sc_path_t));\n\tmemcpy(new_object.path.aid.value, aid, aid_len);\n\tnew_object.path.aid.len = aid_len;\n\n\t/* Call without OID set will just select the AID without subseqent\n\t * OID selection, which we need to figure out just now\n\t */\n\tcac_select_file_by_type(card, &new_object.path, NULL, SC_CARD_TYPE_CAC_II);\n\tr = cac_get_properties(card, &prop);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\tfor (i = 0; i < prop.num_objects; i++) {\n\t\t/* don't fail just because we have more certs than we can support */\n\t\tif (priv->cert_next >= MAX_CAC_SLOTS)\n\t\t\treturn SC_SUCCESS;\n\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t    \"ACA: pki_object found, cert_next=%d (%s), privkey=%d\",\n\t\t    priv->cert_next, cac_labels[priv->cert_next],\n\t\t    prop.objects[i].privatekey);\n\n\t\t/* If the private key is not initialized, we can safely\n\t\t * ignore this object here, but increase the pointer to follow\n\t\t * the certificate labels\n\t\t */\n\t\tif (!prop.objects[i].privatekey) {\n\t\t\tpriv->cert_next++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* OID here has always 2B */\n\t\tmemcpy(new_object.path.value, &prop.objects[i].oid, 2);\n\t\tnew_object.path.len = 2;\n\t\tnew_object.path.type = SC_PATH_TYPE_FILE_ID;\n\t\tnew_object.name = cac_labels[priv->cert_next];\n\t\tnew_object.fd = priv->cert_next+1;\n\t\tcac_add_object_to_list(&priv->pki_list, &new_object);\n\t\tpriv->cert_next++;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_parse_cardurl(sc_card_t *card, cac_private_data_t *priv, cac_card_url_t *val, int len)\n{\n\tcac_object_t new_object;\n\tconst cac_object_t *obj;\n\tunsigned short object_id;\n\tint r;\n\n\tr = cac_path_from_cardurl(card, &new_object.path, val, len);\n\tif (r != SC_SUCCESS) {\n\t\treturn r;\n\t}\n\tswitch (val->cardApplicationType) {\n\tcase CAC_APP_TYPE_PKI:\n\t\t/* we don't want to overflow the cac_label array. This test could\n\t\t * go way if we create a label function that will create a unique label\n\t\t * from a cert index.\n\t\t */\n\t\tif (priv->cert_next >= MAX_CAC_SLOTS)\n\t\t\tbreak; /* don't fail just because we have more certs than we can support */\n\t\tnew_object.name = cac_labels[priv->cert_next];\n\t\tnew_object.fd = priv->cert_next+1;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"CARDURL: pki_object found, cert_next=%d (%s),\", priv->cert_next, new_object.name);\n\t\tcac_add_object_to_list(&priv->pki_list, &new_object);\n\t\tpriv->cert_next++;\n\t\tbreak;\n\tcase CAC_APP_TYPE_GENERAL:\n\t\tobject_id = bebytes2ushort(val->objectID);\n\t\tobj = cac_find_obj_by_id(object_id);\n\t\tif (obj == NULL)\n\t\t\tbreak; /* don't fail just because we don't recognize the object */\n\t\tnew_object.name = obj->name;\n\t\tnew_object.fd = 0;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"CARDURL: gen_object found, objectID=%x (%s),\", object_id, new_object.name);\n\t\tcac_add_object_to_list(&priv->general_list, &new_object);\n\t\tbreak;\n\tcase CAC_APP_TYPE_SKI:\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"CARDURL: ski_object found\");\n\tbreak;\n\tdefault:\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"CARDURL: unknown object_object found (type=0x%02x)\", val->cardApplicationType);\n\t\t/* don't fail just because there is an unknown object in the CCC */\n\t\tbreak;\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_parse_cuid(sc_card_t *card, cac_private_data_t *priv, cac_cuid_t *val, size_t len)\n{\n\tsize_t card_id_len;\n\n\tif (len < sizeof(cac_cuid_t)) {\n\t\treturn SC_ERROR_INVALID_DATA;\n\t}\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"gsc_rid=%s\", sc_dump_hex(val->gsc_rid, sizeof(val->gsc_rid)));\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"manufacture id=%x\", val->manufacturer_id);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"cac_type=%d\", val->card_type);\n\tcard_id_len = len - (&val->card_id - (u8 *)val);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t \"card_id=%s (%\"SC_FORMAT_LEN_SIZE_T\"u)\",\n\t\t sc_dump_hex(&val->card_id, card_id_len),\n\t\t card_id_len);\n\tpriv->cuid = *val;\n\tpriv->cac_id = malloc(card_id_len);\n\tif (priv->cac_id == NULL) {\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tmemcpy(priv->cac_id, &val->card_id, card_id_len);\n\tpriv->cac_id_len = card_id_len;\n\treturn SC_SUCCESS;\n}\nstatic int cac_process_CCC(sc_card_t *card, cac_private_data_t *priv);\n\nstatic int cac_parse_CCC(sc_card_t *card, cac_private_data_t *priv, u8 *tl,\n\t\t\t\t\t\t size_t tl_len, u8 *val, size_t val_len)\n{\n\tsize_t len = 0;\n\tu8 *tl_end = tl + tl_len;\n\tu8 *val_end = val + val_len;\n\tsc_path_t new_path;\n\tint r;\n\n\n\tfor (; (tl < tl_end) && (val< val_end); val += len) {\n\t\t/* get the tag and the length */\n\t\tu8 tag;\n\t\tif (sc_simpletlv_read_tag(&tl, tl_end - tl, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_CUID:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:CUID\");\n\t\t\tr = cac_parse_cuid(card, priv, (cac_cuid_t *)val, len);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase CAC_TAG_CC_VERSION_NUMBER:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: CC Version: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* ignore the version numbers for now */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\t\"TAG: CC Version = 0x%02x\", *val);\n\t\t\tbreak;\n\t\tcase CAC_TAG_GRAMMAR_VERION_NUMBER:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Grammar Version: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* ignore the version numbers for now */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\t\"TAG: Grammar Version = 0x%02x\", *val);\n\t\t\tbreak;\n\t\tcase CAC_TAG_CARDURL:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:CARDURL\");\n\t\t\tr = cac_parse_cardurl(card, priv, (cac_card_url_t *)val, len);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\t/*\n\t\t * The following are really for file systems cards. This code only cares about CAC VM cards\n\t\t */\n\t\tcase CAC_TAG_PKCS15:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKCS15: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* TODO should verify that this is '0'. If it's not\n\t\t\t * zero, we should drop out of here and let the PKCS 15\n\t\t\t * code handle this card */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG: PKCS15 = 0x%02x\", *val);\n\t\t\tbreak;\n\t\tcase CAC_TAG_DATA_MODEL:\n\t\tcase CAC_TAG_CARD_APDU:\n\t\tcase CAC_TAG_CAPABILITY_TUPLES:\n\t\tcase CAC_TAG_STATUS_TUPLES:\n\t\tcase CAC_TAG_REDIRECTION:\n\t\tcase CAC_TAG_ERROR_CODES:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:FSSpecific(0x%02x)\", tag);\n\t\t\tbreak;\n\t\tcase CAC_TAG_ACCESS_CONTROL:\n\t\t\t/* TODO handle access control later */\n\t\t\tsc_log_hex(card->ctx, \"TAG:ACCESS Control\", val, len);\n\t\t\tbreak;\n\t\tcase CAC_TAG_NEXT_CCC:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:NEXT CCC\");\n\t\t\tr = cac_path_from_cardurl(card, &new_path, (cac_card_url_t *)val, len);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\n\t\t\tr = cac_select_file_by_type(card, &new_path, NULL, SC_CARD_TYPE_CAC_II);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\n\t\t\tr = cac_process_CCC(card, priv);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"TAG:Unknown (0x%02x)\",tag );\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_process_CCC(sc_card_t *card, cac_private_data_t *priv)\n{\n\tu8 *tl = NULL, *val = NULL;\n\tsize_t tl_len, val_len;\n\tint r;\n\n\n\tr = cac_read_file(card, CAC_FILE_TAG, &tl, &tl_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tr = cac_read_file(card, CAC_FILE_VALUE, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tr = cac_parse_CCC(card, priv, tl, tl_len, val, val_len);\ndone:\n\tif (tl)\n\t\tfree(tl);\n\tif (val)\n\t\tfree(val);\n\treturn r;\n}\n\n/* Service Applet Table (Table 5-21) should list all the applets on the\n * card, which is a good start if we don't have CCC\n */\nstatic int cac_parse_ACA_service(sc_card_t *card, cac_private_data_t *priv,\n    u8 *val, size_t val_len)\n{\n\tsize_t len = 0;\n\tu8 *val_end = val + val_len;\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tfor (; val < val_end; val += len) {\n\t\t/* get the tag and the length */\n\t\tu8 tag;\n\t\tif (sc_simpletlv_read_tag(&val, val_end - val, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_APPLET_FAMILY:\n\t\t\tif (len != 5) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Applet Information: \"\n\t\t\t\t    \"bad length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Applet Information: Family: 0x%02x\", val[0]);\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"     Applet Version: 0x%02x 0x%02x 0x%02x 0x%02x\",\n\t\t\t    val[1], val[2], val[3], val[4]);\n\t\t\tbreak;\n\t\tcase CAC_TAG_NUMBER_APPLETS:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Num applets: \"\n\t\t\t\t    \"bad length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Num applets = %hhd\", *val);\n\t\t\tbreak;\n\t\tcase CAC_TAG_APPLET_ENTRY:\n\t\t\t/* Make sure we match the outer length */\n\t\t\tif (len < 3 || val[2] != len - 3) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Applet Entry: \"\n\t\t\t\t    \"bad length (%\"SC_FORMAT_LEN_SIZE_T\n\t\t\t\t    \"u) or length of internal buffer\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug_hex(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Applet Entry: AID\", &val[3], val[2]);\n\t\t\t/* This is SimpleTLV prefixed with applet ID (1B) */\n\t\t\tr = cac_parse_aid(card, priv, &val[3], val[2]);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Unknown (0x%02x)\", tag);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn SC_SUCCESS;\n}\n\n/* select a CAC pki applet by index */\nstatic int cac_select_pki_applet(sc_card_t *card, int index)\n{\n\tsc_path_t applet_path = cac_cac_pki_obj.path;\n\tapplet_path.aid.value[applet_path.aid.len-1] = index;\n\treturn cac_select_file_by_type(card, &applet_path, NULL, SC_CARD_TYPE_CAC_II);\n}\n\n/*\n *  Find the first existing CAC applet. If none found, then this isn't a CAC\n */\nstatic int cac_find_first_pki_applet(sc_card_t *card, int *index_out)\n{\n\tint r, i;\n\tfor (i = 0; i < MAX_CAC_SLOTS; i++) {\n\t\tr = cac_select_pki_applet(card, i);\n\t\tif (r == SC_SUCCESS) {\n\t\t\t/* Try to read first two bytes of the buffer to\n\t\t\t * make sure it is not just malfunctioning card\n\t\t\t */\n\t\t\tu8 params[2] = {CAC_FILE_TAG, 2};\n\t\t\tu8 data[2], *out_ptr = data;\n\t\t\tsize_t len = 2;\n\t\t\tr = cac_apdu_io(card, CAC_INS_READ_FILE, 0, 0,\n\t\t\t    &params[0], sizeof(params), &out_ptr, &len);\n\t\t\tif (r != 2)\n\t\t\t\tcontinue;\n\n\t\t\t*index_out = i;\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_OBJECT_NOT_FOUND;\n}\n\n/*\n * This emulates CCC for Alt tokens, that do not come with CCC nor ACA applets\n */\nstatic int cac_populate_cac_alt(sc_card_t *card, int index, cac_private_data_t *priv)\n{\n\tint r, i;\n\tcac_object_t pki_obj = cac_cac_pki_obj;\n\tu8 buf[100];\n\tu8 *val;\n\tsize_t val_len;\n\n\t/* populate PKI objects */\n\tfor (i = index; i < MAX_CAC_SLOTS; i++) {\n\t\tr = cac_select_pki_applet(card, i);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tpki_obj.name = cac_labels[i];\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"CAC: pki_object found, cert_next=%d (%s),\", i, pki_obj.name);\n\t\t\tpki_obj.path.aid.value[pki_obj.path.aid.len-1] = i;\n\t\t\tpki_obj.fd = i+1; /* don't use id of zero */\n\t\t\tcac_add_object_to_list(&priv->pki_list, &pki_obj);\n\t\t}\n\t}\n\n\t/* populate non-PKI objects */\n\tfor (i=0; i < cac_object_count; i++) {\n\t\tr = cac_select_file_by_type(card, &cac_objects[i].path, NULL,\n\t\t    SC_CARD_TYPE_CAC_II);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"CAC: obj_object found, cert_next=%d (%s),\",\n\t\t\t    i, cac_objects[i].name);\n\t\t\tcac_add_object_to_list(&priv->general_list, &cac_objects[i]);\n\t\t}\n\t}\n\n\t/*\n\t * create a cuid to simulate the cac 2 cuid.\n\t */\n\tpriv->cuid = cac_cac_cuid;\n\t/* create a serial number by hashing the first 100 bytes of the\n\t * first certificate on the card */\n\tr = cac_select_pki_applet(card, index);\n\tif (r < 0) {\n\t\treturn r; /* shouldn't happen unless the card has been removed or is malfunctioning */\n\t}\n\tval = buf;\n\tval_len = cac_read_binary(card, 0, val, sizeof(buf), 0);\n\tif (val_len > 0) {\n\t\tpriv->cac_id = malloc(20);\n\t\tif (priv->cac_id == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n#ifdef ENABLE_OPENSSL\n\t\tSHA1(val, val_len, priv->cac_id);\n\t\tpriv->cac_id_len = 20;\n\t\tsc_debug_hex(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t    \"cuid\", priv->cac_id, priv->cac_id_len);\n#else\n\t\tsc_log(card->ctx, \"OpenSSL Required\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_OPENSSL */\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int cac_process_ACA(sc_card_t *card, cac_private_data_t *priv)\n{\n\tint r;\n\tu8 *val = NULL;\n\tsize_t val_len;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* Assuming ACA is already selected */\n\tr = cac_get_acr(card, CAC_ACR_SERVICE, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tr = cac_parse_ACA_service(card, priv, val, val_len);\n        if (r == SC_SUCCESS) {\n\t\tpriv->aca_path = malloc(sizeof(sc_path_t));\n\t\tif (!priv->aca_path) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tmemcpy(priv->aca_path, &cac_ACA_Path, sizeof(sc_path_t));\n\t}\ndone:\n\tif (val)\n\t\tfree(val);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\n/*\n * Look for a CAC card. If it exists, initialize our data structures\n */\nstatic int cac_find_and_initialize(sc_card_t *card, int initialize)\n{\n\tint r, index;\n\tcac_private_data_t *priv = NULL;\n\n\t/* already initialized? */\n\tif (card->drv_data) {\n\t\treturn SC_SUCCESS;\n\t}\n\n\t/* is this a CAC-2 specified in NIST Interagency Report 6887 -\n\t * \"Government Smart Card Interoperability Specification v2.1 July 2003\" */\n\tr = cac_select_CCC(card);\n\tif (r == SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"CCC found, is CAC-2\");\n\t\tif (!initialize) /* match card only */\n\t\t\treturn r;\n\n\t\tpriv = cac_new_private_data();\n\t\tif (!priv)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tr = cac_process_CCC(card, priv);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tcard->type = SC_CARD_TYPE_CAC_II;\n\t\t\tcard->drv_data = priv;\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t/* Even some ALT tokens can be missing CCC so we should try with ACA */\n\tr = cac_select_ACA(card);\n\tif (r == SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"ACA found, is CAC-2 without CCC\");\n\t\tif (!initialize) /* match card only */\n\t\t\treturn r;\n\n\t\tif (!priv) {\n\t\t\tpriv = cac_new_private_data();\n\t\t\tif (!priv)\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tr = cac_process_ACA(card, priv);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tcard->type = SC_CARD_TYPE_CAC_II;\n\t\t\tcard->drv_data = priv;\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t/* is this a CAC Alt token without any accompanying structures */\n\tr = cac_find_first_pki_applet(card, &index);\n\tif (r == SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"PKI applet found, is bare CAC Alt\");\n\t\tif (!initialize) /* match card only */\n\t\t\treturn r;\n\n\t\tif (!priv) {\n\t\t\tpriv = cac_new_private_data();\n\t\t\tif (!priv)\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcard->drv_data = priv; /* needed for the read_binary() */\n\t\tr = cac_populate_cac_alt(card, index, priv);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tcard->type = SC_CARD_TYPE_CAC_II;\n\t\t\treturn r;\n\t\t}\n\t\tcard->drv_data = NULL; /* reset on failure */\n\t}\n\tif (priv) {\n\t\tcac_free_private_data(priv);\n\t}\n\treturn r;\n}\n\n\n/* NOTE: returns a bool, 1 card matches, 0 it does not */\nstatic int cac_match_card(sc_card_t *card)\n{\n\tint r;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* Since we send an APDU, the card's logout function may be called...\n\t * however it may be in dirty memory */\n\tcard->ops->logout = NULL;\n\n\tr = cac_find_and_initialize(card, 0);\n\treturn (r == SC_SUCCESS); /* never match */\n}\n\n\nstatic int cac_init(sc_card_t *card)\n{\n\tint r;\n\tunsigned long flags;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = cac_find_and_initialize(card, 1);\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_CARD);\n\t}\n\tflags = SC_ALGORITHM_RSA_RAW;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0); /* mandatory */\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0); /* optional */\n\t_sc_card_add_rsa_alg(card, 3072, flags, 0); /* optional */\n\n\tcard->caps |= SC_CARD_CAP_RNG | SC_CARD_CAP_ISO7816_PIN_INFO;\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n}\n\nstatic int cac_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\t/* CAC, like PIV needs Extra validation of (new) PIN during\n\t * a PIN change request, to ensure it's not outside the\n\t * FIPS 201 4.1.6.1 (numeric only) and * FIPS 140-2\n\t * (6 character minimum) requirements.\n\t */\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (data->cmd == SC_PIN_CMD_CHANGE) {\n\t\tint i = 0;\n\t\tif (data->pin2.len < 6) {\n\t\t\treturn SC_ERROR_INVALID_PIN_LENGTH;\n\t\t}\n\t\tfor(i=0; i < data->pin2.len; ++i) {\n\t\t\tif (!isdigit(data->pin2.data[i])) {\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  iso_drv->ops->pin_cmd(card, data, tries_left);\n}\n\nstatic struct sc_card_operations cac_ops;\n\nstatic struct sc_card_driver cac_drv = {\n\t\"Common Access Card (CAC)\",\n\t\"cac\",\n\t&cac_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tcac_ops = *iso_drv->ops;\n\tcac_ops.match_card = cac_match_card;\n\tcac_ops.init = cac_init;\n\tcac_ops.finish = cac_finish;\n\n\tcac_ops.select_file =  cac_select_file; /* need to record object type */\n\tcac_ops.get_challenge = cac_get_challenge;\n\tcac_ops.read_binary = cac_read_binary;\n\tcac_ops.write_binary = cac_write_binary;\n\tcac_ops.set_security_env = cac_set_security_env;\n\tcac_ops.restore_security_env = cac_restore_security_env;\n\tcac_ops.compute_signature = cac_compute_signature;\n\tcac_ops.decipher =  cac_decipher;\n\tcac_ops.card_ctl = cac_card_ctl;\n\tcac_ops.pin_cmd = cac_pin_cmd;\n\n\treturn &cac_drv;\n}\n\n\nstruct sc_card_driver * sc_get_cac_driver(void)\n{\n\treturn sc_get_driver();\n}\n", "/*\n * Support for ePass2003 smart cards\n *\n * Copyright (C) 2008, Weitao Sun <weitao@ftsafe.com>\n * Copyright (C) 2011, Xiaoshuo Wu <xiaoshuo@ftsafe.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#ifdef ENABLE_SM\t\t/* empty file without SM enabled */\n#ifdef ENABLE_OPENSSL\t\t/* empty file without openssl */\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n\nstatic struct sc_atr_table epass2003_atrs[] = {\n\t/* This is a FIPS certified card using SCP01 security messaging. */\n\t{\"3B:9F:95:81:31:FE:9F:00:66:46:53:05:10:00:11:71:df:00:00:00:6a:82:5e\",\n\t \"FF:FF:FF:FF:FF:00:FF:FF:FF:FF:FF:FF:00:00:00:ff:00:ff:ff:00:00:00:00\",\n\t \"FTCOS/ePass2003\", SC_CARD_TYPE_ENTERSAFE_FTCOS_EPASS2003, 0, NULL },\n\t{NULL, NULL, NULL, 0, 0, NULL}\n};\n\nstatic struct sc_card_operations *iso_ops = NULL;\nstatic struct sc_card_operations epass2003_ops;\n\nstatic struct sc_card_driver epass2003_drv = {\n\t\"epass2003\",\n\t\"epass2003\",\n\t&epass2003_ops,\n\tNULL, 0, NULL\n};\n\n#define KEY_TYPE_AES\t0x01\t/* FIPS mode */\n#define KEY_TYPE_DES\t0x02\t/* Non-FIPS mode */\n\n#define KEY_LEN_AES\t16\n#define KEY_LEN_DES\t8\n#define KEY_LEN_DES3\t24\n#define HASH_LEN\t24\n\nstatic unsigned char PIN_ID[2] = { ENTERSAFE_USER_PIN_ID, ENTERSAFE_SO_PIN_ID };\n\n/*0x00:plain; 0x01:scp01 sm*/\n#define SM_PLAIN\t\t\t\t0x00\n#define SM_SCP01\t\t\t\t0x01\n\nstatic unsigned char g_init_key_enc[16] = {\n\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,\n\t0x0D, 0x0E, 0x0F, 0x10\n};\n\nstatic unsigned char g_init_key_mac[16] = {\n\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,\n\t0x0D, 0x0E, 0x0F, 0x10\n};\n\nstatic unsigned char g_random[8] = {\n\t0xBF, 0xC3, 0x29, 0x11, 0xC7, 0x18, 0xC3, 0x40\n};\n\ntypedef struct epass2003_exdata_st {\n\tunsigned char sm;\t\t/* SM_PLAIN or SM_SCP01 */\n\tunsigned char smtype;\t\t/* KEY_TYPE_AES or KEY_TYPE_DES */\n\tunsigned char sk_enc[16];\t/* encrypt session key */\n\tunsigned char sk_mac[16];\t/* mac session key */\n\tunsigned char icv_mac[16];\t/* instruction counter vector(for sm) */\n\tunsigned char currAlg;\t\t/* current Alg */\n\tunsigned int  ecAlgFlags; \t/* Ec Alg mechanism type*/\n} epass2003_exdata;\n\n#define REVERSE_ORDER4(x)\t(\t\t\t  \\\n\t\t((unsigned long)x & 0xFF000000)>> 24\t| \\\n\t\t((unsigned long)x & 0x00FF0000)>>  8 \t| \\\n\t\t((unsigned long)x & 0x0000FF00)<<  8\t| \\\n\t\t((unsigned long)x & 0x000000FF)<< 24)\n\n\nstatic const struct sc_card_error epass2003_errors[] = {\n\t{ 0x6200, SC_ERROR_CARD_CMD_FAILED,\t\"Warning: no information given, non-volatile memory is unchanged\" },\n\t{ 0x6281, SC_ERROR_CORRUPTED_DATA,\t\"Part of returned data may be corrupted\" },\n\t{ 0x6282, SC_ERROR_FILE_END_REACHED,\t\"End of file/record reached before reading Le bytes\" },\n\t{ 0x6283, SC_ERROR_CARD_CMD_FAILED,\t\"Selected file invalidated\" },\n\t{ 0x6284, SC_ERROR_CARD_CMD_FAILED,\t\"FCI not formatted according to ISO 7816-4\" },\n\n\t{ 0x6300, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C1, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed. One tries left\"}, \n\t{ 0x63C2, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed. Two tries left\"}, \n\t{ 0x63C3, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C4, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C5, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C6, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C7, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C8, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63C9, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\t{ 0x63CA, SC_ERROR_PIN_CODE_INCORRECT,  \"Authentication failed\"}, \n\n\t{ 0x6381, SC_ERROR_CARD_CMD_FAILED,\t\"Warning: file filled up by last write\" },\n\n\t{ 0x6581, SC_ERROR_MEMORY_FAILURE,\t\"Memory failure\" },\n\n\t{ 0x6700, SC_ERROR_WRONG_LENGTH,\t\"Wrong length\" },\n\n\t{ 0x6800, SC_ERROR_NO_CARD_SUPPORT,\t\"Functions in CLA not supported\" },\n\t{ 0x6881, SC_ERROR_NO_CARD_SUPPORT,\t\"Logical channel not supported\" },\n\t{ 0x6882, SC_ERROR_NO_CARD_SUPPORT,\t\"Secure messaging not supported\" },\n\n\t{ 0x6900, SC_ERROR_NOT_ALLOWED,\t\t\"Command not allowed\" },\n\t{ 0x6981, SC_ERROR_CARD_CMD_FAILED,\t\"Command incompatible with file structure\" },\n\t{ 0x6982, SC_ERROR_SECURITY_STATUS_NOT_SATISFIED, \"Security status not satisfied\" },\n\t{ 0x6983, SC_ERROR_AUTH_METHOD_BLOCKED,\t\"Authentication method blocked\" },\n\t{ 0x6984, SC_ERROR_REF_DATA_NOT_USABLE,\t\"Referenced data not usable\" },\n\t{ 0x6985, SC_ERROR_NOT_ALLOWED,\t\t\"Conditions of use not satisfied\" },\n\t{ 0x6986, SC_ERROR_NOT_ALLOWED,\t\t\"Command not allowed (no current EF)\" },\n\t{ 0x6987, SC_ERROR_INCORRECT_PARAMETERS,\"Expected SM data objects missing\" },\n\t{ 0x6988, SC_ERROR_INCORRECT_PARAMETERS,\"SM data objects incorrect\" },\n\n\t{ 0x6A00, SC_ERROR_INCORRECT_PARAMETERS,\"Wrong parameter(s) P1-P2\" },\n\t{ 0x6A80, SC_ERROR_INCORRECT_PARAMETERS,\"Incorrect parameters in the data field\" },\n\t{ 0x6A81, SC_ERROR_NO_CARD_SUPPORT,\t\"Function not supported\" },\n\t{ 0x6A82, SC_ERROR_FILE_NOT_FOUND,\t\"File not found\" },\n\t{ 0x6A83, SC_ERROR_RECORD_NOT_FOUND,\t\"Record not found\" },\n\t{ 0x6A84, SC_ERROR_NOT_ENOUGH_MEMORY,\t\"Not enough memory space in the file\" },\n\t{ 0x6A85, SC_ERROR_INCORRECT_PARAMETERS,\"Lc inconsistent with TLV structure\" },\n\t{ 0x6A86, SC_ERROR_INCORRECT_PARAMETERS,\"Incorrect parameters P1-P2\" },\n\t{ 0x6A87, SC_ERROR_INCORRECT_PARAMETERS,\"Lc inconsistent with P1-P2\" },\n\t{ 0x6A88, SC_ERROR_DATA_OBJECT_NOT_FOUND,\"Referenced data not found\" },\n\t{ 0x6A89, SC_ERROR_FILE_ALREADY_EXISTS,  \"File already exists\"},\n\t{ 0x6A8A, SC_ERROR_FILE_ALREADY_EXISTS,  \"DF name already exists\"},\n\n\t{ 0x6B00, SC_ERROR_INCORRECT_PARAMETERS,\"Wrong parameter(s) P1-P2\" },\n\t{ 0x6D00, SC_ERROR_INS_NOT_SUPPORTED,\t\"Instruction code not supported or invalid\" },\n\t{ 0x6E00, SC_ERROR_CLASS_NOT_SUPPORTED,\t\"Class not supported\" },\n\t{ 0x6F00, SC_ERROR_CARD_CMD_FAILED,\t\"No precise diagnosis\" },\n\n\t{ 0x9000,SC_SUCCESS,                       NULL }\n};\n\nstatic int epass2003_transmit_apdu(struct sc_card *card, struct sc_apdu *apdu);\nstatic int epass2003_select_file(struct sc_card *card, const sc_path_t * in_path, sc_file_t ** file_out);\nint epass2003_refresh(struct sc_card *card);\nstatic int hash_data(const unsigned char *data, size_t datalen, unsigned char *hash, unsigned int mechanismType);\n\nstatic int\nepass2003_check_sw(struct sc_card *card, unsigned int sw1, unsigned int sw2)\n{\n\tconst int err_count = sizeof(epass2003_errors)/sizeof(epass2003_errors[0]);\n\tint i;\n\n\t/* Handle special cases here */\n\tif (sw1 == 0x6C) {\n\t\tsc_log(card->ctx, \"Wrong length; correct length is %d\", sw2);\n\t\treturn SC_ERROR_WRONG_LENGTH;\n\t}\n\n\n\tfor (i = 0; i < err_count; i++)   {\n\t\tif (epass2003_errors[i].SWs == ((sw1 << 8) | sw2)) {\n\t\t\tsc_log(card->ctx, \"%s\", epass2003_errors[i].errorstr);\n\t\t\treturn epass2003_errors[i].errorno;\n\t\t}\n\t}\n\n\tsc_log(card->ctx, \"Unknown SWs; SW1=%02X, SW2=%02X\", sw1, sw2);\n\treturn SC_ERROR_CARD_CMD_FAILED;\n}\n\nstatic int\nsc_transmit_apdu_t(sc_card_t *card, sc_apdu_t *apdu)\n{\n\tint r = sc_transmit_apdu(card, apdu);\n\tif ( ((0x69 == apdu->sw1) && (0x85 == apdu->sw2)) || ((0x69 == apdu->sw1) && (0x88 == apdu->sw2)))\n\t{\n\t\tepass2003_refresh(card);\n\t\tr = sc_transmit_apdu(card, apdu);\n\t}\n\treturn r;\n}\n\nstatic int\nopenssl_enc(const EVP_CIPHER * cipher, const unsigned char *key, const unsigned char *iv,\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tint r = SC_ERROR_INTERNAL;\n\tEVP_CIPHER_CTX * ctx = NULL;\n\tint outl = 0;\n\tint outl_tmp = 0;\n\tunsigned char iv_tmp[EVP_MAX_IV_LENGTH] = { 0 };\n\n\tmemcpy(iv_tmp, iv, EVP_MAX_IV_LENGTH);\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL)\n\t\tgoto out;\n\tEVP_EncryptInit_ex(ctx, cipher, NULL, key, iv_tmp);\n\tEVP_CIPHER_CTX_set_padding(ctx, 0);\n\n\tif (!EVP_EncryptUpdate(ctx, output, &outl, input, length))\n\t\tgoto out;\n\n\tif (!EVP_EncryptFinal_ex(ctx, output + outl, &outl_tmp))\n\t\tgoto out;\n\n\tr = SC_SUCCESS;\nout:\n\tif (ctx)\n\t    EVP_CIPHER_CTX_free(ctx);\n\treturn r;\n}\n\nstatic int\nopenssl_dec(const EVP_CIPHER * cipher, const unsigned char *key, const unsigned char *iv,\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tint r = SC_ERROR_INTERNAL;\n\tEVP_CIPHER_CTX * ctx = NULL;\n\tint outl = 0;\n\tint outl_tmp = 0;\n\tunsigned char iv_tmp[EVP_MAX_IV_LENGTH] = { 0 };\n\n\tmemcpy(iv_tmp, iv, EVP_MAX_IV_LENGTH);\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL)\n\t\tgoto out;\n\tEVP_DecryptInit_ex(ctx, cipher, NULL, key, iv_tmp);\n\tEVP_CIPHER_CTX_set_padding(ctx, 0);\n\n\tif (!EVP_DecryptUpdate(ctx, output, &outl, input, length))\n\t\tgoto out;\n\n\tif (!EVP_DecryptFinal_ex(ctx, output + outl, &outl_tmp))\n\t\tgoto out;\n\n\tr = SC_SUCCESS;\nout:\n\tif (ctx)\n\t\tEVP_CIPHER_CTX_free(ctx);\n\treturn r;\n}\n\n\nstatic int\naes128_encrypt_ecb(const unsigned char *key, int keysize,\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };\n\treturn openssl_enc(EVP_aes_128_ecb(), key, iv, input, length, output);\n}\n\n\nstatic int\naes128_encrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[16],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_enc(EVP_aes_128_cbc(), key, iv, input, length, output);\n}\n\n\nstatic int\naes128_decrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[16],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dec(EVP_aes_128_cbc(), key, iv, input, length, output);\n}\n\n\nstatic int\ndes3_encrypt_ecb(const unsigned char *key, int keysize,\n\t\tconst unsigned char *input, int length, unsigned char *output)\n{\n\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };\n\tunsigned char bKey[24] = { 0 };\n\n\tif (keysize == 16) {\n\t\tmemcpy(&bKey[0], key, 16);\n\t\tmemcpy(&bKey[16], key, 8);\n\t}\n\telse {\n\t\tmemcpy(&bKey[0], key, 24);\n\t}\n\n\treturn openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);\n}\n\n\nstatic int\ndes3_encrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tunsigned char bKey[24] = { 0 };\n\n\tif (keysize == 16) {\n\t\tmemcpy(&bKey[0], key, 16);\n\t\tmemcpy(&bKey[16], key, 8);\n\t}\n\telse {\n\t\tmemcpy(&bKey[0], key, 24);\n\t}\n\n\treturn openssl_enc(EVP_des_ede3_cbc(), bKey, iv, input, length, output);\n}\n\n\nstatic int\ndes3_decrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tunsigned char bKey[24] = { 0 };\n\tif (keysize == 16) {\n\t\tmemcpy(&bKey[0], key, 16);\n\t\tmemcpy(&bKey[16], key, 8);\n\t}\n\telse {\n\t\tmemcpy(&bKey[0], key, 24);\n\t}\n\n\treturn openssl_dec(EVP_des_ede3_cbc(), bKey, iv, input, length, output);\n}\n\n\nstatic int\ndes_encrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_enc(EVP_des_cbc(), key, iv, input, length, output);\n}\n\n\nstatic int\ndes_decrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dec(EVP_des_cbc(), key, iv, input, length, output);\n}\n\n\nstatic int\nopenssl_dig(const EVP_MD * digest, const unsigned char *input, size_t length,\n\t\tunsigned char *output)\n{\n\tint r = 0;\n\tEVP_MD_CTX *ctx = NULL;\n\tunsigned outl = 0;\n\n\tctx = EVP_MD_CTX_create();\n\tif (ctx == NULL) {\n\t    r = SC_ERROR_OUT_OF_MEMORY;\n\t    goto err;\n\t}\n\t    \n\tEVP_MD_CTX_init(ctx);\n\tEVP_DigestInit_ex(ctx, digest, NULL);\n\tif (!EVP_DigestUpdate(ctx, input, length)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tif (!EVP_DigestFinal_ex(ctx, output, &outl)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tr = SC_SUCCESS;\nerr:\n\tif (ctx)\n\t\tEVP_MD_CTX_destroy(ctx);\n\n\treturn r;\n}\n\n\nstatic int\nsha1_digest(const unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dig(EVP_sha1(), input, length, output);\n}\n\nstatic int\nsha256_digest(const unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dig(EVP_sha256(), input, length, output);\n}\n\n\nstatic int\ngen_init_key(struct sc_card *card, unsigned char *key_enc, unsigned char *key_mac,\n\t\tunsigned char *result, unsigned char key_type)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char data[256] = { 0 };\n\tunsigned char tmp_sm;\n\tunsigned long blocksize = 0;\n\tunsigned char cryptogram[256] = { 0 };\t/* host cryptogram */\n\tunsigned char iv[16] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\t\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x50, 0x00, 0x00);\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = sizeof(g_random);\n\tapdu.data = g_random;\t/* host random */\n\tapdu.le = apdu.resplen = 28;\n\tapdu.resp = result;\t/* card random is result[12~19] */\n\n\ttmp_sm = exdata->sm;\n\texdata->sm = SM_PLAIN;\n\tr = epass2003_transmit_apdu(card, &apdu);\n\texdata->sm = tmp_sm;\n\tLOG_TEST_RET(card->ctx, r, \"APDU gen_init_key failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"gen_init_key failed\");\n\n\t/* Step 1 - Generate Derivation data */\n\tmemcpy(data, &result[16], 4);\n\tmemcpy(&data[4], g_random, 4);\n\tmemcpy(&data[8], &result[12], 4);\n\tmemcpy(&data[12], &g_random[4], 4);\n\n\t/* Step 2,3 - Create S-ENC/S-MAC Session Key */\n\tif (KEY_TYPE_AES == key_type) {\n\t\taes128_encrypt_ecb(key_enc, 16, data, 16, exdata->sk_enc);\n\t\taes128_encrypt_ecb(key_mac, 16, data, 16, exdata->sk_mac);\n\t}\n\telse {\n\t\tdes3_encrypt_ecb(key_enc, 16, data, 16, exdata->sk_enc);\n\t\tdes3_encrypt_ecb(key_mac, 16, data, 16, exdata->sk_mac);\n\t}\n\n\tmemcpy(data, g_random, 8);\n\tmemcpy(&data[8], &result[12], 8);\n\tdata[16] = 0x80;\n\tblocksize = (key_type == KEY_TYPE_AES ? 16 : 8);\n\tmemset(&data[17], 0x00, blocksize - 1);\n\n\t/* calculate host cryptogram */\n\tif (KEY_TYPE_AES == key_type)\n\t\taes128_encrypt_cbc(exdata->sk_enc, 16, iv, data, 16 + blocksize, cryptogram);\n\telse\n\t\tdes3_encrypt_cbc(exdata->sk_enc, 16, iv, data, 16 + blocksize, cryptogram);\n\n\t/* verify card cryptogram */\n\tif (0 != memcmp(&cryptogram[16], &result[20], 8))\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_CARD_CMD_FAILED);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nverify_init_key(struct sc_card *card, unsigned char *ran_key, unsigned char key_type)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned long blocksize = (key_type == KEY_TYPE_AES ? 16 : 8);\n\tunsigned char data[256] = { 0 };\n\tunsigned char cryptogram[256] = { 0 };\t/* host cryptogram */\n\tunsigned char iv[16] = { 0 };\n\tunsigned char mac[256] = { 0 };\n\tunsigned long i;\n\tunsigned char tmp_sm;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tmemcpy(data, ran_key, 8);\n\tmemcpy(&data[8], g_random, 8);\n\tdata[16] = 0x80;\n\tmemset(&data[17], 0x00, blocksize - 1);\n\tmemset(iv, 0, 16);\n\n\t/* calculate host cryptogram */\n\tif (KEY_TYPE_AES == key_type) {\n\t\taes128_encrypt_cbc(exdata->sk_enc, 16, iv, data, 16 + blocksize,\n\t\t\t\t   cryptogram);\n\t} else {\n\t\tdes3_encrypt_cbc(exdata->sk_enc, 16, iv, data, 16 + blocksize,\n\t\t\t\t cryptogram);\n\t}\n\n\tmemset(data, 0, sizeof(data));\n\tmemcpy(data, \"\\x84\\x82\\x03\\x00\\x10\", 5);\n\tmemcpy(&data[5], &cryptogram[16], 8);\n\tmemcpy(&data[13], \"\\x80\\x00\\x00\", 3);\n\n\t/* calculate mac icv */\n\tmemset(iv, 0x00, 16);\n\tif (KEY_TYPE_AES == key_type) {\n\t\taes128_encrypt_cbc(exdata->sk_mac, 16, iv, data, 16, mac);\n\t\ti = 0;\n\t} else {\n\t\tdes3_encrypt_cbc(exdata->sk_mac, 16, iv, data, 16, mac);\n\t\ti = 8;\n\t}\n\t/* save mac icv */\n\tmemset(exdata->icv_mac, 0x00, 16);\n\tmemcpy(exdata->icv_mac, &mac[i], 8);\n\n\t/* verify host cryptogram */\n\tmemcpy(data, &cryptogram[16], 8);\n\tmemcpy(&data[8], &mac[i], 8);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x82, 0x03, 0x00);\n\tapdu.cla = 0x84;\n\tapdu.lc = apdu.datalen = 16;\n\tapdu.data = data;\n\ttmp_sm = exdata->sm;\n\texdata->sm = SM_PLAIN;\n\tr = epass2003_transmit_apdu(card, &apdu);\n\texdata->sm = tmp_sm;\n\tLOG_TEST_RET(card->ctx, r,\n\t\t    \"APDU verify_init_key failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r,\n\t\t    \"verify_init_key failed\");\n\treturn r;\n}\n\n\nstatic int\nmutual_auth(struct sc_card *card, unsigned char *key_enc,\n\t\t\tunsigned char *key_mac)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint r;\n\tunsigned char result[256] = { 0 };\n\tunsigned char ran_key[8] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tr = gen_init_key(card, key_enc, key_mac, result, exdata->smtype);\n\tLOG_TEST_RET(ctx, r, \"gen_init_key failed\");\n\tmemcpy(ran_key, &result[12], 8);\n\n\tr = verify_init_key(card, ran_key, exdata->smtype);\n\tLOG_TEST_RET(ctx, r, \"verify_init_key failed\");\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\nint\nepass2003_refresh(struct sc_card *card)\n{\n\tint r = SC_SUCCESS;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tif (exdata->sm) {\n\t\tcard->sm_ctx.sm_mode = 0;\n\t\tr = mutual_auth(card, g_init_key_enc, g_init_key_mac);\n\t\tcard->sm_ctx.sm_mode = SM_MODE_TRANSMIT;\n\t\tLOG_TEST_RET(card->ctx, r, \"mutual_auth failed\");\n\t}\n\n\treturn r;\n}\n\n\n/* Data(TLV)=0x87|L|0x01+Cipher */\nstatic int\nconstruct_data_tlv(struct sc_card *card, struct sc_apdu *apdu, unsigned char *apdu_buf,\n\t\tunsigned char *data_tlv, size_t * data_tlv_len, const unsigned char key_type)\n{\n\tsize_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);\n\tunsigned char pad[4096] = { 0 };\n\tsize_t pad_len;\n\tsize_t tlv_more;\t/* increased tlv length */\n\tunsigned char iv[16] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* padding */\n\tapdu_buf[block_size] = 0x87;\n\tmemcpy(pad, apdu->data, apdu->lc);\n\tpad[apdu->lc] = 0x80;\n\tif ((apdu->lc + 1) % block_size)\n\t\tpad_len = ((apdu->lc + 1) / block_size + 1) * block_size;\n\telse\n\t\tpad_len = apdu->lc + 1;\n\n\t/* encode Lc' */\n\tif (pad_len > 0x7E) {\n\t\t/* Lc' > 0x7E, use extended APDU */\n\t\tapdu_buf[block_size + 1] = 0x82;\n\t\tapdu_buf[block_size + 2] = (unsigned char)((pad_len + 1) / 0x100);\n\t\tapdu_buf[block_size + 3] = (unsigned char)((pad_len + 1) % 0x100);\n\t\tapdu_buf[block_size + 4] = 0x01;\n\t\ttlv_more = 5;\n\t}\n\telse {\n\t\tapdu_buf[block_size + 1] = (unsigned char)pad_len + 1;\n\t\tapdu_buf[block_size + 2] = 0x01;\n\t\ttlv_more = 3;\n\t}\n\tmemcpy(data_tlv, &apdu_buf[block_size], tlv_more);\n\n\t/* encrypt Data */\n\tif (KEY_TYPE_AES == key_type)\n\t\taes128_encrypt_cbc(exdata->sk_enc, 16, iv, pad, pad_len, apdu_buf + block_size + tlv_more);\n\telse\n\t\tdes3_encrypt_cbc(exdata->sk_enc, 16, iv, pad, pad_len, apdu_buf + block_size + tlv_more);\n\n\tmemcpy(data_tlv + tlv_more, apdu_buf + block_size + tlv_more, pad_len);\n\t*data_tlv_len = tlv_more + pad_len;\n\treturn 0;\n}\n\n\n/* Le(TLV)=0x97|L|Le */\nstatic int\nconstruct_le_tlv(struct sc_apdu *apdu, unsigned char *apdu_buf, size_t data_tlv_len,\n\t\tunsigned char *le_tlv, size_t * le_tlv_len, const unsigned char key_type)\n{\n\tsize_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);\n\n\t*(apdu_buf + block_size + data_tlv_len) = 0x97;\n\tif (apdu->le > 0x7F) {\n\t\t/* Le' > 0x7E, use extended APDU */\n\t\t*(apdu_buf + block_size + data_tlv_len + 1) = 2;\n\t\t*(apdu_buf + block_size + data_tlv_len + 2) = (unsigned char)(apdu->le / 0x100);\n\t\t*(apdu_buf + block_size + data_tlv_len + 3) = (unsigned char)(apdu->le % 0x100);\n\t\tmemcpy(le_tlv, apdu_buf + block_size + data_tlv_len, 4);\n\t\t*le_tlv_len = 4;\n\t}\n\telse {\n\t\t*(apdu_buf + block_size + data_tlv_len + 1) = 1;\n\t\t*(apdu_buf + block_size + data_tlv_len + 2) = (unsigned char)apdu->le;\n\t\tmemcpy(le_tlv, apdu_buf + block_size + data_tlv_len, 3);\n\t\t*le_tlv_len = 3;\n\t}\n\treturn 0;\n}\n\n\n/* MAC(TLV)=0x8e|0x08|MAC */\nstatic int\nconstruct_mac_tlv(struct sc_card *card, unsigned char *apdu_buf, size_t data_tlv_len, size_t le_tlv_len,\n\t\tunsigned char *mac_tlv, size_t * mac_tlv_len, const unsigned char key_type)\n{\n\tsize_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);\n\tunsigned char mac[4096] = { 0 };\n\tsize_t mac_len;\n\tunsigned char icv[16] = { 0 };\n\tint i = (KEY_TYPE_AES == key_type ? 15 : 7);\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tif (0 == data_tlv_len && 0 == le_tlv_len) {\n\t\tmac_len = block_size;\n\t}\n\telse {\n\t\t/* padding */\n\t\t*(apdu_buf + block_size + data_tlv_len + le_tlv_len) = 0x80;\n\t\tif ((data_tlv_len + le_tlv_len + 1) % block_size)\n\t\t\tmac_len = (((data_tlv_len + le_tlv_len + 1) / block_size) +\n\t\t\t\t\t1) * block_size + block_size;\n\n\t\telse\n\t\t\tmac_len = data_tlv_len + le_tlv_len + 1 + block_size;\n\n\t\tmemset((apdu_buf + block_size + data_tlv_len + le_tlv_len + 1),\n\t\t       0, (mac_len - (data_tlv_len + le_tlv_len + 1)));\n\t}\n\n\t/* increase icv */\n\tfor (; i >= 0; i--) {\n\t\tif (exdata->icv_mac[i] == 0xff) {\n\t\t\texdata->icv_mac[i] = 0;\n\t\t}\n\t\telse {\n\t\t\texdata->icv_mac[i]++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* calculate MAC */\n\tmemset(icv, 0, sizeof(icv));\n\tmemcpy(icv, exdata->icv_mac, 16);\n\tif (KEY_TYPE_AES == key_type) {\n\t\taes128_encrypt_cbc(exdata->sk_mac, 16, icv, apdu_buf, mac_len, mac);\n\t\tmemcpy(mac_tlv + 2, &mac[mac_len - 16], 8);\n\t}\n\telse {\n\t\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };\n\t\tunsigned char tmp[8] = { 0 };\n\t\tdes_encrypt_cbc(exdata->sk_mac, 8, icv, apdu_buf, mac_len, mac);\n\t\tdes_decrypt_cbc(&exdata->sk_mac[8], 8, iv, &mac[mac_len - 8], 8, tmp);\n\t\tmemset(iv, 0x00, sizeof iv);\n\t\tdes_encrypt_cbc(exdata->sk_mac, 8, iv, tmp, 8, mac_tlv + 2);\n\t}\n\n\t*mac_tlv_len = 2 + 8;\n\treturn 0;\n}\n\n\n/* According to GlobalPlatform Card Specification's SCP01\n * encode APDU from\n * CLA INS P1 P2 [Lc] Data [Le]\n * to\n * CLA INS P1 P2 Lc' Data' [Le]\n * where\n * Data'=Data(TLV)+Le(TLV)+MAC(TLV) */\nstatic int\nencode_apdu(struct sc_card *card, struct sc_apdu *plain, struct sc_apdu *sm,\n\t\tunsigned char *apdu_buf, size_t * apdu_buf_len)\n{\n\tsize_t block_size = 0;\n\tunsigned char dataTLV[4096] = { 0 };\n\tsize_t data_tlv_len = 0;\n\tunsigned char le_tlv[256] = { 0 };\n\tsize_t le_tlv_len = 0;\n\tsize_t mac_tlv_len = 10;\n\tsize_t tmp_lc = 0;\n\tsize_t tmp_le = 0;\n\tunsigned char mac_tlv[256] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tmac_tlv[0] = 0x8E;\n\tmac_tlv[1] = 8;\n\t/* size_t plain_le = 0; */\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata*)card->drv_data;\n\tblock_size = (KEY_TYPE_DES == exdata->smtype ? 16 : 8);\n\n\tsm->cse = SC_APDU_CASE_4_SHORT;\n\tapdu_buf[0] = (unsigned char)plain->cla;\n\tapdu_buf[1] = (unsigned char)plain->ins;\n\tapdu_buf[2] = (unsigned char)plain->p1;\n\tapdu_buf[3] = (unsigned char)plain->p2;\n\t/* plain_le = plain->le; */\n\t/* padding */\n\tapdu_buf[4] = 0x80;\n\tmemset(&apdu_buf[5], 0x00, block_size - 5);\n\n\t/* Data -> Data' */\n\tif (plain->lc != 0)\n\t\tif (0 != construct_data_tlv(card, plain, apdu_buf, dataTLV, &data_tlv_len, exdata->smtype))\n\t\t\treturn -1;\n\n\tif (plain->le != 0 || (plain->le == 0 && plain->resplen != 0))\n\t\tif (0 != construct_le_tlv(plain, apdu_buf, data_tlv_len, le_tlv,\n\t\t\t\t     &le_tlv_len, exdata->smtype))\n\t\t\treturn -1;\n\n\tif (0 != construct_mac_tlv(card, apdu_buf, data_tlv_len, le_tlv_len, mac_tlv, &mac_tlv_len, exdata->smtype))\n\t\treturn -1;\n\n\tmemset(apdu_buf + 4, 0, *apdu_buf_len - 4);\n\tsm->lc = sm->datalen = data_tlv_len + le_tlv_len + mac_tlv_len;\n\tif (sm->lc > 0xFF) {\n\t\tsm->cse = SC_APDU_CASE_4_EXT;\n\t\tapdu_buf[4] = (unsigned char)((sm->lc) / 0x10000);\n\t\tapdu_buf[5] = (unsigned char)(((sm->lc) / 0x100) % 0x100);\n\t\tapdu_buf[6] = (unsigned char)((sm->lc) % 0x100);\n\t\ttmp_lc = 3;\n\t}\n\telse {\n\t\tapdu_buf[4] = (unsigned char)sm->lc;\n\t\ttmp_lc = 1;\n\t}\n\n\tmemcpy(apdu_buf + 4 + tmp_lc, dataTLV, data_tlv_len);\n\tmemcpy(apdu_buf + 4 + tmp_lc + data_tlv_len, le_tlv, le_tlv_len);\n\tmemcpy(apdu_buf + 4 + tmp_lc + data_tlv_len + le_tlv_len, mac_tlv, mac_tlv_len);\n\tmemcpy((unsigned char *)sm->data, apdu_buf + 4 + tmp_lc, sm->datalen);\n\t*apdu_buf_len = 0;\n\n\tif (4 == le_tlv_len) {\n\t\tsm->cse = SC_APDU_CASE_4_EXT;\n\t\t*(apdu_buf + 4 + tmp_lc + sm->lc) = (unsigned char)(plain->le / 0x100);\n\t\t*(apdu_buf + 4 + tmp_lc + sm->lc + 1) = (unsigned char)(plain->le % 0x100);\n\t\ttmp_le = 2;\n\t}\n\telse if (3 == le_tlv_len) {\n\t\t*(apdu_buf + 4 + tmp_lc + sm->lc) = (unsigned char)plain->le;\n\t\ttmp_le = 1;\n\t}\n\n\t*apdu_buf_len += 4 + tmp_lc + data_tlv_len + le_tlv_len + mac_tlv_len + tmp_le;\n\t/* sm->le = calc_le(plain_le); */\n\treturn 0;\n}\n\n\nstatic int\nepass2003_sm_wrap_apdu(struct sc_card *card, struct sc_apdu *plain, struct sc_apdu *sm)\n{\n\tunsigned char buf[4096] = { 0 };\t/* APDU buffer */\n\tsize_t buf_len = sizeof(buf);\n\tepass2003_exdata *exdata = NULL;\n\t\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (exdata->sm)\n\t\tplain->cla |= 0x0C;\n\n\tsm->cse = plain->cse;\n\tsm->cla = plain->cla;\n\tsm->ins = plain->ins;\n\tsm->p1 = plain->p1;\n\tsm->p2 = plain->p2;\n\tsm->lc = plain->lc;\n\tsm->le = plain->le;\n\tsm->control = plain->control;\n\tsm->flags = plain->flags;\n\n\tswitch (sm->cla & 0x0C) {\n\tcase 0x00:\n\tcase 0x04:\n\t\tsm->datalen = plain->datalen;\n\t\tmemcpy((void *)sm->data, plain->data, plain->datalen);\n\t\tsm->resplen = plain->resplen;\n\t\tmemcpy(sm->resp, plain->resp, plain->resplen);\n\t\tbreak;\n\tcase 0x0C:\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (0 != encode_apdu(card, plain, sm, buf, &buf_len))\n\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\n\n/* According to GlobalPlatform Card Specification's SCP01\n * decrypt APDU response from\n * ResponseData' SW1 SW2\n * to\n * ResponseData SW1 SW2\n * where\n * ResponseData'=Data(TLV)+SW12(TLV)+MAC(TLV)\n * where\n * Data(TLV)=0x87|L|Cipher\n * SW12(TLV)=0x99|0x02|SW1+SW2\n * MAC(TLV)=0x8e|0x08|MAC */\nstatic int\ndecrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len || *out_len < cipher_len - 2)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}\n\n\nstatic int\nepass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tlen = plain->resplen;\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_sm_free_wrapped_apdu(struct sc_card *card,\n\t\tstruct sc_apdu *plain, struct sc_apdu **sm_apdu)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint rv = SC_SUCCESS;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!sm_apdu)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\tif (!(*sm_apdu))\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\n\tif (plain)\n\t\trv = epass2003_sm_unwrap_apdu(card, *sm_apdu, plain);\n\n\tif ((*sm_apdu)->data) {\n\t\tunsigned char * p = (unsigned char *)((*sm_apdu)->data);\n\t\tfree(p);\n\t}\n\tif ((*sm_apdu)->resp) {\n\t\tfree((*sm_apdu)->resp);\n\t}\n\n\tfree(*sm_apdu);\n\t*sm_apdu = NULL;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\nepass2003_sm_get_wrapped_apdu(struct sc_card *card,\n\t\tstruct sc_apdu *plain, struct sc_apdu **sm_apdu)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu *apdu = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!plain || !sm_apdu)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\t*sm_apdu = NULL;\n\t//construct new SM apdu from original apdu\n\tapdu = calloc(1, sizeof(struct sc_apdu));\n\tif (!apdu) {\n\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\tapdu->data = calloc (1, SC_MAX_EXT_APDU_BUFFER_SIZE);\n\tif (!apdu->data) {\n\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\tapdu->resp = calloc (1, SC_MAX_EXT_APDU_BUFFER_SIZE);\n\tif (!apdu->resp) {\n\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\tapdu->datalen = SC_MAX_EXT_APDU_BUFFER_SIZE;\n\tapdu->resplen = SC_MAX_EXT_APDU_BUFFER_SIZE;\n\n\trv = epass2003_sm_wrap_apdu(card, plain, apdu);\n\tif (rv)   {\n\t\trv = epass2003_sm_free_wrapped_apdu(card, NULL, &apdu);\n\t\tif (rv < 0)\n\t\t\tgoto err;\n\t}\n\n\t*sm_apdu = apdu;\n\tapdu = NULL;\nerr:\n\tif (apdu) {\n\t\tfree((unsigned char *) apdu->data);\n\t\tfree(apdu->resp);\n\t\tfree(apdu);\n\t\tapdu = NULL;\n\t}\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\nepass2003_transmit_apdu(struct sc_card *card, struct sc_apdu *apdu)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_transmit_apdu_t(card, apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\treturn r;\n}\n\n\nstatic int\nget_data(struct sc_card *card, unsigned char type, unsigned char *data, size_t datalen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char resp[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tsize_t resplen = SC_MAX_APDU_BUFFER_SIZE;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, type);\n\tapdu.resp = resp;\n\tapdu.le = 0;\n\tapdu.resplen = resplen;\n\tif (0x86 == type) {\n\t\t/* No SM temporarily */\n\t\tunsigned char tmp_sm = exdata->sm;\n\t\texdata->sm = SM_PLAIN;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\texdata->sm = tmp_sm;\n\t}\n\telse {\n\t\tr = sc_transmit_apdu_t(card, &apdu);\n\t}\n\tLOG_TEST_RET(card->ctx, r, \"APDU get_data failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"get_data failed\");\n\n\tmemcpy(data, resp, datalen);\n\treturn r;\n}\n\n/* card driver functions */\n\nstatic int epass2003_match_card(struct sc_card *card)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tr = _sc_match_atr(card, epass2003_atrs, &card->type);\n\tif (r < 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic int\nepass2003_init(struct sc_card *card)\n{\n\tunsigned int flags;\n\tunsigned int ext_flags;\n\tunsigned char data[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tsize_t datalen = SC_MAX_APDU_BUFFER_SIZE;\n\tepass2003_exdata *exdata = NULL;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tcard->name = \"epass2003\";\n\tcard->cla = 0x00;\n\texdata = (epass2003_exdata *)calloc(1, sizeof(epass2003_exdata));\n\tif (!exdata)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tcard->drv_data = exdata;\n\n\texdata->sm = SM_SCP01;\n\n\t/* decide FIPS/Non-FIPS mode */\n\tif (SC_SUCCESS != get_data(card, 0x86, data, datalen))\n\t\treturn SC_ERROR_INVALID_CARD;\n\n\tif (0x01 == data[2])\n\t\texdata->smtype = KEY_TYPE_AES;\n\telse\n\t\texdata->smtype = KEY_TYPE_DES;\n\n\tif (0x84 == data[14]) {\n\t\tif (0x00 == data[16]) { \n\t\t\texdata->sm = SM_PLAIN;\n\t\t}\n\t}\n\n\n\t/* mutual authentication */\n\tcard->max_recv_size = 0xD8;\n\tcard->max_send_size = 0xE8;\n\n\tcard->sm_ctx.ops.open = epass2003_refresh;\n\tcard->sm_ctx.ops.get_sm_apdu = epass2003_sm_get_wrapped_apdu;\n\tcard->sm_ctx.ops.free_sm_apdu = epass2003_sm_free_wrapped_apdu;\n\n\t/* FIXME (VT): rather then set/unset 'g_sm', better to implement filter for APDUs to be wrapped */\n\tepass2003_refresh(card);\n\n\tcard->sm_ctx.sm_mode = SM_MODE_TRANSMIT;\n\n\tflags = SC_ALGORITHM_ONBOARD_KEY_GEN | SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_RSA_HASH_NONE;\n\n\t_sc_card_add_rsa_alg(card, 512, flags, 0);\n\t_sc_card_add_rsa_alg(card, 768, flags, 0);\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\n\t//set EC Alg Flags\n\tflags = SC_ALGORITHM_ONBOARD_KEY_GEN|SC_ALGORITHM_ECDSA_HASH_SHA1|SC_ALGORITHM_ECDSA_HASH_SHA256|SC_ALGORITHM_ECDSA_HASH_NONE|SC_ALGORITHM_ECDSA_RAW;\n\text_flags = 0;\n\t_sc_card_add_ec_alg(card, 256, flags, ext_flags, NULL);\n\n\tcard->caps = SC_CARD_CAP_RNG | SC_CARD_CAP_APDU_EXT;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nstatic int\nepass2003_finish(sc_card_t *card)\n{\n\tepass2003_exdata *exdata = (epass2003_exdata *)card->drv_data;\n\n\tif (exdata)\n\t\tfree(exdata);\n\treturn SC_SUCCESS;\n}\n\n/* COS implement SFI as lower 5 bits of FID, and not allow same SFI at the\n * same DF, so use hook functions to increase/decrease FID by 0x20 */\nstatic int\nepass2003_hook_path(struct sc_path *path, int inc)\n{\n\tu8 fid_h = path->value[path->len - 2];\n\tu8 fid_l = path->value[path->len - 1];\n\n\tswitch (fid_h) {\n\tcase 0x29:\n\tcase 0x30:\n\tcase 0x31:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\t\tif (inc)\n\t\t\tfid_l = fid_l * FID_STEP;\n\t\telse\n\t\t\tfid_l = fid_l / FID_STEP;\n\t\tpath->value[path->len - 1] = fid_l;\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\nstatic void\nepass2003_hook_file(struct sc_file *file, int inc)\n{\n\tint fidl = file->id & 0xff;\n\tint fidh = file->id & 0xff00;\n\tif (epass2003_hook_path(&file->path, inc)) {\n\t\tif (inc)\n\t\t\tfile->id = fidh + fidl * FID_STEP;\n\t\telse\n\t\t\tfile->id = fidh + fidl / FID_STEP;\n\t}\n}\n\n\nstatic int\nepass2003_select_fid_(struct sc_card *card, sc_path_t * in_path, sc_file_t ** file_out)\n{\n\tstruct sc_apdu apdu;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tu8 pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tint r, pathlen;\n\tsc_file_t *file = NULL;\n\n\tepass2003_hook_path(in_path, 1);\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);\n\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tapdu.p1 = 0;\n\t\tif (pathlen != 2)\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tapdu.p2 = 0;\t\t/* first record, return FCI */\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 0;\n\t}\n\telse   {\n\t\tapdu.cse = (apdu.lc == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tif (path[0] == 0x29) {\t/* TODO:0x29 accords with FID prefix in profile  */\n\t\t/* Not allowed to select private key file, so fake fci. */\n\t\t/* 62 16 82 02 11 00 83 02 29 00 85 02 08 00 86 08 FF 90 90 90 FF FF FF FF */\n\t\tapdu.resplen = 0x18;\n\t\tmemcpy(apdu.resp,\n\t\t       \"\\x6f\\x16\\x82\\x02\\x11\\x00\\x83\\x02\\x29\\x00\\x85\\x02\\x08\\x00\\x86\\x08\\xff\\x90\\x90\\x90\\xff\\xff\\xff\\xff\",\n\t\t       apdu.resplen);\n\t\tapdu.resp[9] = path[1];\n\t\tapdu.sw1 = 0x90;\n\t\tapdu.sw2 = 0x00;\n\t}\n\telse {\n\t\tr = sc_transmit_apdu_t(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\t}\n\n\tif (file_out == NULL) {\n\t\tif (apdu.sw1 == 0x61)\n\t\t\tLOG_FUNC_RETURN(card->ctx, 0);\n\t\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n\t}\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\tif (apdu.resplen < 2)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\n\tswitch (apdu.resp[0]) {\n\tcase 0x6F:\n\t\tfile = sc_file_new();\n\t\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tfile->path = *in_path;\n\t\tif (card->ops->process_fci == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t\t}\n\n\t\tif ((size_t) apdu.resp[1] + 2 <= apdu.resplen)\n\t\t\tcard->ops->process_fci(card, file, apdu.resp + 2, apdu.resp[1]);\n\t\tepass2003_hook_file(file, 0);\n\t\t*file_out = file;\n\t\tbreak;\n\tcase 0x00:\t\t/* proprietary coding */\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\treturn 0;\n}\n\n\nstatic int\nepass2003_select_fid(struct sc_card *card, unsigned int id_hi, unsigned int id_lo,\n\t\tsc_file_t ** file_out)\n{\n\tint r;\n\tsc_file_t *file = 0;\n\tsc_path_t path;\n\n\tmemset(&path, 0, sizeof(path));\n\tpath.type = SC_PATH_TYPE_FILE_ID;\n\tpath.value[0] = id_hi;\n\tpath.value[1] = id_lo;\n\tpath.len = 2;\n\n\tr = epass2003_select_fid_(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t/* update cache */\n\tif (file && file->type == SC_FILE_TYPE_DF) {\n\t\tcard->cache.current_path.type = SC_PATH_TYPE_PATH;\n\t\tcard->cache.current_path.value[0] = 0x3f;\n\t\tcard->cache.current_path.value[1] = 0x00;\n\t\tif (id_hi == 0x3f && id_lo == 0x00) {\n\t\t\tcard->cache.current_path.len = 2;\n\t\t}\n\t\telse {\n\t\t\tcard->cache.current_path.len = 4;\n\t\t\tcard->cache.current_path.value[2] = id_hi;\n\t\t\tcard->cache.current_path.value[3] = id_lo;\n\t\t}\n\t}\n\n\tif (file_out)\n\t\t*file_out = file;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_select_aid(struct sc_card *card, const sc_path_t * in_path, sc_file_t ** file_out)\n{\n\tint r = 0;\n\n\tif (card->cache.valid\n\t\t\t&& card->cache.current_path.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_path.len == in_path->len\n\t\t\t&& memcmp(card->cache.current_path.value, in_path->value, in_path->len) == 0) {\n\t\tif (file_out) {\n\t\t\t*file_out = sc_file_new();\n\t\t\tif (!file_out)\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t}\n\telse {\n\t\tr = iso_ops->select_file(card, in_path, file_out);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\t\t/* update cache */\n\t\tcard->cache.current_path.type = SC_PATH_TYPE_DF_NAME;\n\t\tcard->cache.current_path.len = in_path->len;\n\t\tmemcpy(card->cache.current_path.value, in_path->value, in_path->len);\n\t}\n\n\tif (file_out) {\n\t\tsc_file_t *file = *file_out;\n\n\t\tfile->type = SC_FILE_TYPE_DF;\n\t\tfile->ef_structure = SC_FILE_EF_UNKNOWN;\n\t\tfile->path.len = 0;\n\t\tfile->size = 0;\n\t\t/* AID */\n\t\tmemcpy(file->name, in_path->value, in_path->len);\n\t\tfile->namelen = in_path->len;\n\t\tfile->id = 0x0000;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\nstatic int\nepass2003_select_path(struct sc_card *card, const u8 pathbuf[16], const size_t len,\n\t\tsc_file_t ** file_out)\n{\n\tu8 n_pathbuf[SC_MAX_PATH_SIZE];\n\tconst u8 *path = pathbuf;\n\tsize_t pathlen = len;\n\tint bMatch = -1;\n\tunsigned int i;\n\tint r;\n\n\tif (pathlen % 2 != 0 || pathlen > 6 || pathlen <= 0)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\t/* if pathlen == 6 then the first FID must be MF (== 3F00) */\n\tif (pathlen == 6 && (path[0] != 0x3f || path[1] != 0x00))\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\t/* unify path (the first FID should be MF) */\n\tif (path[0] != 0x3f || path[1] != 0x00) {\n\t\tn_pathbuf[0] = 0x3f;\n\t\tn_pathbuf[1] = 0x00;\n\n\t\tfor (i = 0; i < pathlen; i++)\n\t\t\tn_pathbuf[i + 2] = pathbuf[i];\n\t\tpath = n_pathbuf;\n\t\tpathlen += 2;\n\t}\n\n\t/* check current working directory */\n\tif (card->cache.valid\n\t\t\t&& card->cache.current_path.type == SC_PATH_TYPE_PATH\n\t\t\t&& card->cache.current_path.len >= 2\n\t\t\t&& card->cache.current_path.len <= pathlen) {\n\t\tbMatch = 0;\n\t\tfor (i = 0; i < card->cache.current_path.len; i += 2)\n\t\t\tif (card->cache.current_path.value[i] == path[i]\n\t\t\t\t\t&& card->cache.current_path.value[i + 1] == path[i + 1])\n\t\t\t\tbMatch += 2;\n\t}\n\n\tif (card->cache.valid && bMatch > 2) {\n\t\tif (pathlen - bMatch == 2) {\n\t\t\t/* we are in the right directory */\n\t\t\treturn epass2003_select_fid(card, path[bMatch], path[bMatch + 1], file_out);\n\t\t}\n\t\telse if (pathlen - bMatch > 2) {\n\t\t\t/* two more steps to go */\n\t\t\tsc_path_t new_path;\n\n\t\t\t/* first step: change directory */\n\t\t\tr = epass2003_select_fid(card, path[bMatch], path[bMatch + 1], NULL);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"SELECT FILE (DF-ID) failed\");\n\n\t\t\tnew_path.type = SC_PATH_TYPE_PATH;\n\t\t\tnew_path.len = pathlen - bMatch - 2;\n\t\t\tmemcpy(new_path.value, &(path[bMatch + 2]), new_path.len);\n\n\t\t\t/* final step: select file */\n\t\t\treturn epass2003_select_file(card, &new_path, file_out);\n\t\t}\n\t\telse {\t/* if (bMatch - pathlen == 0) */\n\n\t\t\t/* done: we are already in the\n\t\t\t * requested directory */\n\t\t\tsc_log(card->ctx, \"cache hit\\n\");\n\t\t\t/* copy file info (if necessary) */\n\t\t\tif (file_out) {\n\t\t\t\tsc_file_t *file = sc_file_new();\n\t\t\t\tif (!file)\n\t\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tfile->id = (path[pathlen - 2] << 8) + path[pathlen - 1];\n\t\t\t\tfile->path = card->cache.current_path;\n\t\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\t\tfile->ef_structure = SC_FILE_EF_UNKNOWN;\n\t\t\t\tfile->size = 0;\n\t\t\t\tfile->namelen = 0;\n\t\t\t\tfile->magic = SC_FILE_MAGIC;\n\t\t\t\t*file_out = file;\n\t\t\t}\n\t\t\t/* nothing left to do */\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\telse {\n\t\t/* no usable cache */\n\t\tfor (i = 0; i < pathlen - 2; i += 2) {\n\t\t\tr = epass2003_select_fid(card, path[i], path[i + 1], NULL);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"SELECT FILE (DF-ID) failed\");\n\t\t}\n\n\t\treturn epass2003_select_fid(card, path[pathlen - 2], path[pathlen - 1], file_out);\n\t}\n}\n\n\nstatic int\nepass2003_select_file(struct sc_card *card, const sc_path_t * in_path,\n\t\tsc_file_t ** file_out)\n{\n\tint r;\n\tchar pbuf[SC_MAX_PATH_STRING_SIZE];\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_path_print(pbuf, sizeof(pbuf), &card->cache.current_path);\n\tif (r != SC_SUCCESS)\n\t\tpbuf[0] = '\\0';\n\n\tsc_log(card->ctx,\n\t       \"current path (%s, %s): %s (len: %\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t       card->cache.current_path.type == SC_PATH_TYPE_DF_NAME ?\n\t       \"aid\" : \"path\",\n\t       card->cache.valid ? \"valid\" : \"invalid\", pbuf,\n\t       card->cache.current_path.len);\n\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (in_path->len != 2)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t\treturn epass2003_select_fid(card, in_path->value[0], in_path->value[1], file_out);\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\treturn epass2003_select_aid(card, in_path, file_out);\n\tcase SC_PATH_TYPE_PATH:\n\t\treturn epass2003_select_path(card, in_path->value, in_path->len, file_out);\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n}\n\n\nstatic int\nepass2003_set_security_env(struct sc_card *card, const sc_security_env_t * env, int se_num)\n{\n\tstruct sc_apdu apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tu8 *p;\n\tunsigned short fid = 0;\n\tint r, locked = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, 0);\n    \n\tp = sbuf;\n\t*p++ = 0x80;\t\t/* algorithm reference */\n\t*p++ = 0x01;\n\t*p++ = 0x84;\n\n\t*p++ = 0x81;\n\t*p++ = 0x02;\n\n\tfid = 0x2900;\n\tfid += (unsigned short)(0x20 * (env->key_ref[0] & 0xff));\n\t*p++ = fid >> 8;\n\t*p++ = fid & 0xff;\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\n\tif (env->algorithm == SC_ALGORITHM_EC)\n\t{\n\t\tapdu.p2 = 0xB6;\n\t\texdata->currAlg = SC_ALGORITHM_EC;\n\t\tif(env->algorithm_flags & SC_ALGORITHM_ECDSA_HASH_SHA1)\n\t\t{\n\t\t\tsbuf[2] = 0x91;\n\t\t\texdata->ecAlgFlags = SC_ALGORITHM_ECDSA_HASH_SHA1;\n\t\t}\n\t\telse if (env->algorithm_flags & SC_ALGORITHM_ECDSA_HASH_SHA256)\n\t\t{\n\t\t\tsbuf[2] = 0x92;\n\t\t\texdata->ecAlgFlags = SC_ALGORITHM_ECDSA_HASH_SHA256;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsc_log(card->ctx, \"%0x Alg Not Support! \", env->algorithm_flags);\n\t\t\tgoto err;\n\t\t}\n\t}\n\telse if(env->algorithm == SC_ALGORITHM_RSA)\n\t{\n\t\texdata->currAlg = SC_ALGORITHM_RSA; \n\t\tapdu.p2 = 0xB8;\n\t\tsc_log(card->ctx, \"setenv RSA Algorithm alg_flags = %0x\\n\",env->algorithm_flags);\n\t}\n\telse\n\t{\n\t\tsc_log(card->ctx, \"%0x Alg Not Support! \", env->algorithm);\n\t}\n\n\tif (se_num > 0) {\n\t\tr = sc_lock(card);\n\t\tLOG_TEST_RET(card->ctx, r, \"sc_lock() failed\");\n\t\tlocked = 1;\n\t}\n\tif (apdu.datalen != 0) {\n\t\tr = sc_transmit_apdu_t(card, &apdu);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (se_num <= 0)\n\t\treturn 0;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0xF2, se_num);\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tsc_unlock(card);\n\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n\nerr:\n\tif (locked)\n\t\tsc_unlock(card);\n\treturn r;\n}\n\n\nstatic int\nepass2003_restore_security_env(struct sc_card *card, int se_num)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int epass2003_decipher(struct sc_card *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\t\n\tLOG_FUNC_CALLED(card->ctx);\n\t\n\tif (!card->drv_data)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tif(exdata->currAlg == SC_ALGORITHM_EC)\n\t{\n\t\tif(exdata->ecAlgFlags & SC_ALGORITHM_ECDSA_HASH_SHA1)\n\t\t{\n\t\t\tr = hash_data(data, datalen, sbuf, SC_ALGORITHM_ECDSA_HASH_SHA1);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"hash_data failed\"); \n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3,0x2A, 0x9E, 0x9A);\n\t\t\tapdu.data = sbuf;\n\t\t\tapdu.lc = 0x14;\n\t\t\tapdu.datalen = 0x14;\n\t\t}\n\t\telse if (exdata->ecAlgFlags & SC_ALGORITHM_ECDSA_HASH_SHA256)\n\t\t{\n\t\t\tr = hash_data(data, datalen, sbuf, SC_ALGORITHM_ECDSA_HASH_SHA256);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"hash_data failed\");\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3,0x2A, 0x9E, 0x9A);\n\t\t\tapdu.data = sbuf;\n\t\t\tapdu.lc = 0x20;\n\t\t\tapdu.datalen = 0x20;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 0;\n\n\t\tr = sc_transmit_apdu_t(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\t\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\t\tsize_t len = apdu.resplen > outlen ? outlen : apdu.resplen;\n\t\t\tmemcpy(out, apdu.resp, len);\n\t\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t\t}\n\t\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n\t}\n\telse if(exdata->currAlg == SC_ALGORITHM_RSA)\n\t{\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_EXT, 0x2A, 0x80, 0x86);\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 0;\n\n\t\tmemcpy(sbuf, data, datalen);\n\t\tapdu.data = sbuf;\n\t\tapdu.lc = datalen;\n\t\tapdu.datalen = datalen;\n\t}\n\telse\n\t{\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_EXT, 0x2A, 0x80, 0x86);\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 256;\n\n\t\tmemcpy(sbuf, data, datalen);\n\t\tapdu.data = sbuf;\n\t\tapdu.lc = datalen;\n\t\tapdu.datalen = datalen;\n\t}\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\tsize_t len = apdu.resplen > outlen ? outlen : apdu.resplen;\n\t\tmemcpy(out, apdu.resp, len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\n\nstatic int\nacl_to_ac_byte(struct sc_card *card, const struct sc_acl_entry *e)\n{\n\tif (e == NULL)\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\n\tswitch (e->method) {\n\tcase SC_AC_NONE:\n\t\tLOG_FUNC_RETURN(card->ctx, EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE);\n\tcase SC_AC_NEVER:\n\t\tLOG_FUNC_RETURN(card->ctx, EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_NOONE);\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_USER);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INCORRECT_PARAMETERS);\n}\n\n\nstatic int\nepass2003_process_fci(struct sc_card *card, sc_file_t * file, const u8 * buf, size_t buflen)\n{\n\tsc_context_t *ctx = card->ctx;\n\tsize_t taglen, len = buflen;\n\tconst u8 *tag = NULL, *p = buf;\n\n\tsc_log(ctx, \"processing FCI bytes\");\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x83, &taglen);\n\tif (tag != NULL && taglen == 2) {\n\t\tfile->id = (tag[0] << 8) | tag[1];\n\t\tsc_log(ctx, \"  file identifier: 0x%02X%02X\", tag[0], tag[1]);\n\t}\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x80, &taglen);\n\tif (tag != NULL && taglen > 0 && taglen < 3) {\n\t\tfile->size = tag[0];\n\t\tif (taglen == 2)\n\t\t\tfile->size = (file->size << 8) + tag[1];\n\t\tsc_log(ctx, \"  bytes in file: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       file->size);\n\t}\n\n\tif (tag == NULL) {\n\t\ttag = sc_asn1_find_tag(ctx, p, len, 0x81, &taglen);\n\t\tif (tag != NULL && taglen >= 2) {\n\t\t\tint bytes = (tag[0] << 8) + tag[1];\n\n\t\t\tsc_log(ctx, \"  bytes in file: %d\", bytes);\n\t\t\tfile->size = bytes;\n\t\t}\n\t}\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x82, &taglen);\n\tif (tag != NULL) {\n\t\tif (taglen > 0) {\n\t\t\tunsigned char byte = tag[0];\n\t\t\tconst char *type;\n\n\t\t\tif (byte == 0x38) {\n\t\t\t\ttype = \"DF\";\n\t\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\t}\n\t\t\telse if (0x01 <= byte && byte <= 0x07) {\n\t\t\t\ttype = \"working EF\";\n\t\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\t\t\t\tswitch (byte) {\n\t\t\t\tcase 0x01:\n\t\t\t\t\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02:\n\t\t\t\t\tfile->ef_structure = SC_FILE_EF_LINEAR_FIXED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x04:\n\t\t\t\t\tfile->ef_structure = SC_FILE_EF_LINEAR_FIXED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x03:\n\t\t\t\tcase 0x05:\n\t\t\t\tcase 0x06:\n\t\t\t\tcase 0x07:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (0x10 == byte) {\n\t\t\t\ttype = \"BSO\";\n\t\t\t\tfile->type = SC_FILE_TYPE_BSO;\n\t\t\t}\n\t\t\telse if (0x11 <= byte) {\n\t\t\t\ttype = \"internal EF\";\n\t\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\t\t\t\tswitch (byte) {\n\t\t\t\tcase 0x11:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x12:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttype = \"unknown\";\n\t\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\n\t\t\t}\n\t\t\tsc_log(ctx, \"type %s, EF structure %d\", type, byte);\n\t\t}\n\t}\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x84, &taglen);\n\tif (tag != NULL && taglen > 0 && taglen <= 16) {\n\t\tmemcpy(file->name, tag, taglen);\n\t\tfile->namelen = taglen;\n\n\t\tsc_log_hex(ctx, \"File name\", file->name, file->namelen);\n\t\tif (!file->type)\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t}\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x85, &taglen);\n\tif (tag != NULL && taglen)\n\t\tsc_file_set_prop_attr(file, tag, taglen);\n\telse\n\t\tfile->prop_attr_len = 0;\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0xA5, &taglen);\n\tif (tag != NULL && taglen)\n\t\tsc_file_set_prop_attr(file, tag, taglen);\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x86, &taglen);\n\tif (tag != NULL && taglen)\n\t\tsc_file_set_sec_attr(file, tag, taglen);\n\n\ttag = sc_asn1_find_tag(ctx, p, len, 0x8A, &taglen);\n\tif (tag != NULL && taglen == 1) {\n\t\tif (tag[0] == 0x01)\n\t\t\tfile->status = SC_FILE_STATUS_CREATION;\n\t\telse if (tag[0] == 0x07 || tag[0] == 0x05)\n\t\t\tfile->status = SC_FILE_STATUS_ACTIVATED;\n\t\telse if (tag[0] == 0x06 || tag[0] == 0x04)\n\t\t\tfile->status = SC_FILE_STATUS_INVALIDATED;\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\treturn 0;\n}\n\n\nstatic int\nepass2003_construct_fci(struct sc_card *card, const sc_file_t * file,\n\t\tu8 * out, size_t * outlen)\n{\n\tu8 *p = out;\n\tu8 buf[64];\n\tunsigned char ops[8] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\tint rv;\n\tunsigned ii;\n\n\tif (*outlen < 2)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\n\t*p++ = 0x62;\n\tp++;\n\tif (file->type == SC_FILE_TYPE_WORKING_EF) {\n\t\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT) {\n\t\t\tbuf[0] = (file->size >> 8) & 0xFF;\n\t\t\tbuf[1] = file->size & 0xFF;\n\t\t\tsc_asn1_put_tag(0x80, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t}\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tbuf[0] = 0x38;\n\t\tbuf[1] = 0x00;\n\t\tsc_asn1_put_tag(0x82, buf, 2, p, *outlen - (p - out), &p);\n\t}\n\telse if (file->type == SC_FILE_TYPE_WORKING_EF) {\n\t\tbuf[0] = file->ef_structure & 7;\n\t\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT) {\n\t\t\tbuf[1] = 0x00;\n\t\t\tsc_asn1_put_tag(0x82, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t\telse if (file->ef_structure == SC_FILE_EF_LINEAR_FIXED\n\t\t\t   || file->ef_structure == SC_FILE_EF_LINEAR_VARIABLE) {\n\t\t\tbuf[1] = 0x00;\n\t\t\tbuf[2] = 0x00;\n\t\t\tbuf[3] = 0x40;\t/* record length */\n\t\t\tbuf[4] = 0x00;\t/* record count */\n\t\t\tsc_asn1_put_tag(0x82, buf, 5, p, *outlen - (p - out), &p);\n\t\t}\n\t\telse {\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\n\t}\n\telse if (file->type == SC_FILE_TYPE_INTERNAL_EF) {\n\t\tif (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_CRT ||\n\t\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_CRT) {\n\t\t\tbuf[0] = 0x11;\n\t\t\tbuf[1] = 0x00;\n\t\t}\n\t\telse if (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC ||\n\t\t\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC) {\n\t\t\tbuf[0] = 0x12;\n\t\t\tbuf[1] = 0x00;\n\t\t}\n\t\telse {\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tsc_asn1_put_tag(0x82, buf, 2, p, *outlen - (p - out), &p);\n\t}\n\telse if (file->type == SC_FILE_TYPE_BSO) {\n\t\tbuf[0] = 0x10;\n\t\tbuf[1] = 0x00;\n\t\tsc_asn1_put_tag(0x82, buf, 2, p, *outlen - (p - out), &p);\n\t}\n\n\tbuf[0] = (file->id >> 8) & 0xFF;\n\tbuf[1] = file->id & 0xFF;\n\tsc_asn1_put_tag(0x83, buf, 2, p, *outlen - (p - out), &p);\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tif (file->namelen != 0) {\n\t\t\tsc_asn1_put_tag(0x84, file->name, file->namelen, p, *outlen - (p - out), &p);\n\t\t}\n\t\telse {\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t}\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tunsigned char data[2] = {0x00, 0x7F};\n\t\t/* 127 files at most */\n\t\tsc_asn1_put_tag(0x85, data, sizeof(data), p, *outlen - (p - out), &p);\n\t}\n\telse if (file->type == SC_FILE_TYPE_BSO) {\n\t\tbuf[0] = file->size & 0xff;\n\t\tsc_asn1_put_tag(0x85, buf, 1, p, *outlen - (p - out), &p);\n\t}\n\telse if (file->type == SC_FILE_TYPE_INTERNAL_EF) {\n\t\tif (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_CRT ||\n\t\t    file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC||\n\t\t    file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_CRT||\n\t\t    file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC) {\n\t\t\tbuf[0] = (file->size >> 8) & 0xFF;\n\t\t\tbuf[1] = file->size & 0xFF;\n\t\t\tsc_asn1_put_tag(0x85, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t}\n\tif (file->sec_attr_len) {\n\t\tmemcpy(buf, file->sec_attr, file->sec_attr_len);\n\t\tsc_asn1_put_tag(0x86, buf, file->sec_attr_len, p, *outlen - (p - out), &p);\n\t}\n\telse {\n\t\tsc_log(card->ctx, \"SC_FILE_ACL\");\n\t\tif (file->type == SC_FILE_TYPE_DF) {\n\t\t\tops[0] = SC_AC_OP_LIST_FILES;\n\t\t\tops[1] = SC_AC_OP_CREATE;\n\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t}\n\t\telse if (file->type == SC_FILE_TYPE_WORKING_EF) {\n\t\t\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT) {\n\t\t\t\tops[0] = SC_AC_OP_READ;\n\t\t\t\tops[1] = SC_AC_OP_UPDATE;\n\t\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t\t}\n\t\t\telse if (file->ef_structure == SC_FILE_EF_LINEAR_FIXED\n\t\t\t\t\t|| file->ef_structure == SC_FILE_EF_LINEAR_VARIABLE) {\n\t\t\t\tops[0] = SC_AC_OP_READ;\n\t\t\t\tops[1] = SC_AC_OP_UPDATE;\n\t\t\t\tops[2] = SC_AC_OP_WRITE;\n\t\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t\t}\n\t\t}\n\t\telse if (file->type == SC_FILE_TYPE_BSO) {\n\t\t\tops[0] = SC_AC_OP_UPDATE;\n\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t}\n\t\telse if (file->type == SC_FILE_TYPE_INTERNAL_EF) {\n\t\t\tif (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_CRT ||\n\t\t\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_CRT) {\n\t\t\t\tops[1] = SC_AC_OP_UPDATE;\n\t\t\t\tops[2] = SC_AC_OP_CRYPTO;\n\t\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t\t}\n\t\t\telse if (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC||\n\t\t\t\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC) {\n\t\t\t\tops[0] = SC_AC_OP_READ;\n\t\t\t\tops[1] = SC_AC_OP_UPDATE;\n\t\t\t\tops[2] = SC_AC_OP_CRYPTO;\n\t\t\t\tops[3] = SC_AC_OP_DELETE;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\n\t\tfor (ii = 0; ii < sizeof(ops); ii++) {\n\t\t\tconst struct sc_acl_entry *entry;\n\n\t\t\tbuf[ii] = 0xFF;\n\t\t\tif (ops[ii] == 0xFF)\n\t\t\t\tcontinue;\n\t\t\tentry = sc_file_get_acl_entry(file, ops[ii]);\n\n\t\t\trv = acl_to_ac_byte(card, entry);\n\t\t\tLOG_TEST_RET(card->ctx, rv, \"Invalid ACL\");\n\n\t\t\tbuf[ii] = rv;\n\t\t}\n\t\tsc_asn1_put_tag(0x86, buf, sizeof(ops), p, *outlen - (p - out), &p);\n\t\tif(file->size == 256)\t\n\t\t{\n\t\t\tout[4]= 0x13;\n\t\t}\n\n\t}\n\n\t/* VT ??? */\n\tif (file->ef_structure == SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC||\n\t\tfile->ef_structure == SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC) {\n\t\tunsigned char data[2] = {0x00, 0x66};\n\t\tsc_asn1_put_tag(0x87, data, sizeof(data), p, *outlen - (p - out), &p);\n\t\tif(file->size == 256)\t\n\t\t{\n\t\t\tout[4]= 0x14;\n\t\t}\n\t}\n\n\tout[1] = p - out - 2;\n\n\t*outlen = p - out;\n\treturn 0;\n}\n\n\nstatic int\nepass2003_create_file(struct sc_card *card, sc_file_t * file)\n{\n\tint r;\n\tsize_t len;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tstruct sc_apdu apdu;\n\n\tlen = SC_MAX_APDU_BUFFER_SIZE;\n\n\tepass2003_hook_file(file, 1);\n\n\tif (card->ops->construct_fci == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tr = epass2003_construct_fci(card, file, sbuf, &len);\n\tLOG_TEST_RET(card->ctx, r, \"construct_fci() failed\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x00, 0x00);\n\tapdu.lc = len;\n\tapdu.datalen = len;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"APDU sw1/2 wrong\");\n\n\tepass2003_hook_file(file, 0);\n\treturn r;\n}\n\n\nstatic int\nepass2003_delete_file(struct sc_card *card, const sc_path_t * path)\n{\n\tint r;\n\tu8 sbuf[2];\n\tstruct sc_apdu apdu;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_select_file(card, path, NULL);\n\tepass2003_hook_path((struct sc_path *)path, 1);\n\tif (r == SC_SUCCESS) {\n\t\tsbuf[0] = path->value[path->len - 2];\n\t\tsbuf[1] = path->value[path->len - 1];\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE4, 0x00, 0x00);\n\t\tapdu.lc = 2;\n\t\tapdu.datalen = 2;\n\t\tapdu.data = sbuf;\n\t}\n\telse   {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Delete file failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic int\nepass2003_list_files(struct sc_card *card, unsigned char *buf, size_t buflen)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x34, 0x00, 0x00);\n\tapdu.cla = 0x80;\n\tapdu.le = 0;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.resp = rbuf;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Card returned error\");\n\n\tif (apdu.resplen == 0x100 && rbuf[0] == 0 && rbuf[1] == 0)\n\t\tLOG_FUNC_RETURN(card->ctx, 0);\n\n\tbuflen = buflen < apdu.resplen ? buflen : apdu.resplen;\n\tmemcpy(buf, rbuf, buflen);\n\n\tLOG_FUNC_RETURN(card->ctx, buflen);\n}\n\n\nstatic int\ninternal_write_rsa_key_factor(struct sc_card *card, unsigned short fid, u8 factor,\n\t\tsc_pkcs15_bignum_t data)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tu8 sbuff[SC_MAX_EXT_APDU_BUFFER_SIZE] = { 0 };\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsbuff[0] = ((fid & 0xff00) >> 8);\n\tsbuff[1] = (fid & 0x00ff);\n\tmemcpy(&sbuff[2], data.data, data.len);\n//\tsc_mem_reverse(&sbuff[2], data.len);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3, 0xe7, factor, 0x00);\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = 2 + data.len;\n\tapdu.data = sbuff;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Write rsa key factor failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\ninternal_write_rsa_key(struct sc_card *card, unsigned short fid, struct sc_pkcs15_prkey_rsa *rsa)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = internal_write_rsa_key_factor(card, fid, 0x02, rsa->modulus);\n\tLOG_TEST_RET(card->ctx, r, \"write n failed\");\n\tr = internal_write_rsa_key_factor(card, fid, 0x03, rsa->d);\n\tLOG_TEST_RET(card->ctx, r, \"write d failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nhash_data(const unsigned char *data, size_t datalen, unsigned char *hash, unsigned int mechanismType)\n{\n\n\tif ((NULL == data) || (NULL == hash))\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tif(mechanismType & SC_ALGORITHM_ECDSA_HASH_SHA1)\n\t{\n\t\tunsigned char data_hash[24] = { 0 };\n\t\tsize_t len = 0;\n\n\t\tsha1_digest(data, datalen, data_hash);\n\t\tlen = REVERSE_ORDER4(datalen);\n\t\tmemcpy(&data_hash[20], &len, 4);\n\t\tmemcpy(hash, data_hash, 24);\n\t}\n\telse if(mechanismType & SC_ALGORITHM_ECDSA_HASH_SHA256)\n\t{\n\t\tunsigned char data_hash[36] = { 0 };\n\t\tsize_t len = 0;\n\n\t\tsha256_digest(data, datalen, data_hash);\n\t\tlen = REVERSE_ORDER4(datalen);\n\t\tmemcpy(&data_hash[32], &len, 4);\n\t\tmemcpy(hash, data_hash, 36);\n\t}\n\telse\n\t{\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\n\nstatic int\ninstall_secret_key(struct sc_card *card, unsigned char ktype, unsigned char kid,\n\t\tunsigned char useac, unsigned char modifyac, unsigned char EC,\n\t\tunsigned char *data, unsigned long dataLen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char isapp = 0x00;\t/* appendable */\n\tunsigned char tmp_data[256] = { 0 };\n\n\ttmp_data[0] = ktype;\n\ttmp_data[1] = kid;\n\ttmp_data[2] = useac;\n\ttmp_data[3] = modifyac;\n\ttmp_data[8] = 0xFF;\n\n\tif (0x04 == ktype || 0x06 == ktype) {\n\t\ttmp_data[4] = EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_SO;\n\t\ttmp_data[5] = EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_SO;\n\t\ttmp_data[7] = (kid == PIN_ID[0] ? EPASS2003_AC_USER : EPASS2003_AC_SO);\n\t\ttmp_data[9] = (EC << 4) | EC;\n\t}\n\n\tmemcpy(&tmp_data[10], data, dataLen);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xe3, isapp, 0x00);\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = 10 + dataLen;\n\tapdu.data = tmp_data;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU install_secret_key failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"install_secret_key failed\");\n\n\treturn r;\n}\n\n\nstatic int\ninternal_install_pre(struct sc_card *card)\n{\n\tint r;\n\t/* init key for enc */\n\tr = install_secret_key(card, 0x01, 0x00,\n\t\t\t       EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE,\n\t\t\t       EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE,\n\t\t\t       0, g_init_key_enc, 16);\n\tLOG_TEST_RET(card->ctx, r, \"Install init key failed\");\n\n\t/* init key for mac */\n\tr = install_secret_key(card, 0x02, 0x00,\n\t\t\t       EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE,\n\t\t\t       EPASS2003_AC_MAC_NOLESS | EPASS2003_AC_EVERYONE,\n\t\t\t       0, g_init_key_mac, 16);\n\tLOG_TEST_RET(card->ctx, r, \"Install init key failed\");\n\n\treturn r;\n}\n\n\n/* use external auth secret as pin */\nstatic int\ninternal_install_pin(struct sc_card *card, sc_epass2003_wkey_data * pin)\n{\n\tint r;\n\tunsigned char hash[HASH_LEN] = { 0 };\n\n\tr = hash_data(pin->key_data.es_secret.key_val, pin->key_data.es_secret.key_len, hash, SC_ALGORITHM_ECDSA_HASH_SHA1);\n\tLOG_TEST_RET(card->ctx, r, \"hash data failed\");\n\n\tr = install_secret_key(card, 0x04, pin->key_data.es_secret.kid,\n\t\t\t       pin->key_data.es_secret.ac[0],\n\t\t\t       pin->key_data.es_secret.ac[1],\n\t\t\t       pin->key_data.es_secret.EC, hash, HASH_LEN);\n\tLOG_TEST_RET(card->ctx, r, \"Install failed\");\n\n\treturn r;\n}\n\n\nstatic int\nepass2003_write_key(struct sc_card *card, sc_epass2003_wkey_data * data)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (data->type & SC_EPASS2003_KEY) {\n\t\tif (data->type == SC_EPASS2003_KEY_RSA)\n\t\t\treturn internal_write_rsa_key(card, data->key_data.es_key.fid,\n\t\t\t\t\t\t      data->key_data.es_key.rsa);\n\t\telse\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t} else if (data->type & SC_EPASS2003_SECRET) {\n\t\tif (data->type == SC_EPASS2003_SECRET_PRE)\n\t\t\treturn internal_install_pre(card);\n\t\telse if (data->type == SC_EPASS2003_SECRET_PIN)\n\t\t\treturn internal_install_pin(card, data);\n\t\telse\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\telse {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_gen_key(struct sc_card *card, sc_epass2003_gen_key_data * data)\n{\n\tint r;\n\tsize_t len = data->key_length;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_EXT_APDU_BUFFER_SIZE] = { 0 };\n\tu8 sbuf[SC_MAX_EXT_APDU_BUFFER_SIZE] = { 0 };\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif(len == 256)\n\t{\n\t\tsbuf[0] = 0x02;\n\t}\n\telse\n\t{\n\t\tsbuf[0] = 0x01;\n\t}\n\tsbuf[1] = (u8) ((len >> 8) & 0xff);\n\tsbuf[2] = (u8) (len & 0xff);\n\tsbuf[3] = (u8) ((data->prkey_id >> 8) & 0xFF);\n\tsbuf[4] = (u8) ((data->prkey_id) & 0xFF);\n\tsbuf[5] = (u8) ((data->pukey_id >> 8) & 0xFF);\n\tsbuf[6] = (u8) ((data->pukey_id) & 0xFF);\n\n\t/* generate key */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n\tapdu.lc = apdu.datalen = 7;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"generate keypair failed\");\n\n\t/* read public key */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xb4, 0x02, 0x00);\n\tif(len == 256)\n\t{\n\t\tapdu.p1 = 0x00;\n\t}\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = 2;\n\tapdu.data = &sbuf[5];\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0x00;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"get pukey failed\");\n\n\tif (len < apdu.resplen)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tdata->modulus = (u8 *) malloc(len);\n\tif (!data->modulus)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(data->modulus, rbuf, len);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_erase_card(struct sc_card *card)\n{\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_invalidate_cache(card);\n\n\tr = sc_delete_file(card, sc_get_mf_path());\n\tLOG_TEST_RET(card->ctx, r, \"delete MF failed\");\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\nstatic int\nepass2003_get_serialnr(struct sc_card *card, sc_serial_number_t * serial)\n{\n\tu8 rbuf[8];\n\tsize_t rbuf_len = sizeof(rbuf);\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (SC_SUCCESS != get_data(card, 0x80, rbuf, rbuf_len))\n\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\n\tcard->serialnr.len = serial->len = 8;\n\tmemcpy(card->serialnr.value, rbuf, 8);\n\tmemcpy(serial->value, rbuf, 8);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\nepass2003_card_ctl(struct sc_card *card, unsigned long cmd, void *ptr)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tsc_log(card->ctx, \"cmd is %0lx\", cmd);\n\tswitch (cmd) {\n\tcase SC_CARDCTL_ENTERSAFE_WRITE_KEY:\n\t\treturn epass2003_write_key(card, (sc_epass2003_wkey_data *) ptr);\n\tcase SC_CARDCTL_ENTERSAFE_GENERATE_KEY:\n\t\treturn epass2003_gen_key(card, (sc_epass2003_gen_key_data *) ptr);\n\tcase SC_CARDCTL_ERASE_CARD:\n\t\treturn epass2003_erase_card(card);\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\treturn epass2003_get_serialnr(card, (sc_serial_number_t *) ptr);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n}\n\n\nstatic void\ninternal_sanitize_pin_info(struct sc_pin_cmd_pin *pin, unsigned int num)\n{\n\tpin->encoding = SC_PIN_ENCODING_ASCII;\n\tpin->min_length = 4;\n\tpin->max_length = 16;\n\tpin->pad_length = 16;\n\tpin->offset = 5 + num * 16;\n\tpin->pad_char = 0x00;\n}\n\n\nstatic int\nget_external_key_maxtries(struct sc_card *card, unsigned char *maxtries)\n{\n\tunsigned char maxcounter[2] = { 0 };\n\tstatic const sc_path_t file_path = {\n\t\t{0x3f, 0x00, 0x50, 0x15, 0x9f, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 6,\n\t\t0,\n\t\t0,\n\t\tSC_PATH_TYPE_PATH,\n\t\t{{0}, 0}\n\t};\n\tint ret;\n\n\tret = sc_select_file(card, &file_path, NULL);\n\tLOG_TEST_RET(card->ctx, ret, \"select max counter file failed\");\n\n\tret = sc_read_binary(card, 0, maxcounter, 2, 0);\n\tLOG_TEST_RET(card->ctx, ret, \"read max counter file failed\");\n\n\t*maxtries = maxcounter[0];\n\treturn SC_SUCCESS;\n}\n\n\nstatic int\nget_external_key_retries(struct sc_card *card, unsigned char kid, unsigned char *retries)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char random[16] = { 0 };\n\n\tr = sc_get_challenge(card, random, 8);\n\tLOG_TEST_RET(card->ctx, r, \"get challenge get_external_key_retries failed\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x82, 0x01, 0x80 | kid);\n\tapdu.resp = NULL;\n\tapdu.resplen = 0;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU get_external_key_retries failed\");\n\n\tif (retries && ((0x63 == (apdu.sw1 & 0xff)) && (0xC0 == (apdu.sw2 & 0xf0)))) {\n\t\t*retries = (apdu.sw2 & 0x0f);\n\t\tr = SC_SUCCESS;\n\t}\n\telse {\n\t\tLOG_TEST_RET(card->ctx, r, \"get_external_key_retries failed\");\n\t\tr = SC_ERROR_CARD_CMD_FAILED;\n\t}\n\n\treturn r;\n}\n\nstatic int \nepass2003_get_challenge(sc_card_t *card, u8 *rnd, size_t len)\n{\n\tu8 rbuf[16];\n\tsize_t out_len;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = iso_ops->get_challenge(card, rbuf, sizeof rbuf);\n\tLOG_TEST_RET(card->ctx, r, \"GET CHALLENGE cmd failed\");\n\n\tif (len < (size_t) r) {\n\t\tout_len = len;\n\t} else {\n\t\tout_len = (size_t) r;\n\t}\n\tmemcpy(rnd, rbuf, out_len);\n\n\tLOG_FUNC_RETURN(card->ctx, (int) out_len);\n}\n\n\nstatic int\nexternal_key_auth(struct sc_card *card, unsigned char kid,\n\t\tunsigned char *data, size_t datalen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char random[16] = { 0 };\n\tunsigned char tmp_data[16] = { 0 };\n\tunsigned char hash[HASH_LEN] = { 0 };\n\tunsigned char iv[16] = { 0 };\n\n\tr = sc_get_challenge(card, random, 8);\n\tLOG_TEST_RET(card->ctx, r, \"get challenge external_key_auth failed\");\n\n\tr = hash_data(data, datalen, hash, SC_ALGORITHM_ECDSA_HASH_SHA1);\n\tLOG_TEST_RET(card->ctx, r, \"hash data failed\");\n\n\tdes3_encrypt_cbc(hash, HASH_LEN, iv, random, 8, tmp_data);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x82, 0x01, 0x80 | kid);\n\tapdu.lc = apdu.datalen = 8;\n\tapdu.data = tmp_data;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU external_key_auth failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"external_key_auth failed\");\n\n\treturn r;\n}\n\n\nstatic int\nupdate_secret_key(struct sc_card *card, unsigned char ktype, unsigned char kid,\n\t\tconst unsigned char *data, unsigned long datalen)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char hash[HASH_LEN] = { 0 };\n\tunsigned char tmp_data[256] = { 0 };\n\tunsigned char maxtries = 0;\n\n\tr = hash_data(data, datalen, hash, SC_ALGORITHM_ECDSA_HASH_SHA1);\n\tLOG_TEST_RET(card->ctx, r, \"hash data failed\");\n\n\tr = get_external_key_maxtries(card, &maxtries);\n\tLOG_TEST_RET(card->ctx, r, \"get max counter failed\");\n\n\ttmp_data[0] = (maxtries << 4) | maxtries;\n\tmemcpy(&tmp_data[1], hash, HASH_LEN);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xe5, ktype, kid);\n\tapdu.cla = 0x80;\n\tapdu.lc = apdu.datalen = 1 + HASH_LEN;\n\tapdu.data = tmp_data;\n\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU update_secret_key failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"update_secret_key failed\");\n\n\treturn r;\n}\n\n/* use external auth secret as pin */\nstatic int\nepass2003_pin_cmd(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tint r;\n\tu8 kid;\n\tu8 retries = 0;\n\tu8 pin_low = 3;\n\tunsigned char maxtries = 0;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tinternal_sanitize_pin_info(&data->pin1, 0);\n\tinternal_sanitize_pin_info(&data->pin2, 1);\n\tdata->flags |= SC_PIN_CMD_NEED_PADDING;\n\tkid = data->pin_reference;\n\t/* get pin retries */\n\tif (data->cmd == SC_PIN_CMD_GET_INFO) {\n\n\t\tr = get_external_key_retries(card, 0x80 | kid, &retries);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tdata->pin1.tries_left = retries;\n\t\t\tif (tries_left)\n\t\t\t\t*tries_left = retries;\n\n\t\t\tr = get_external_key_maxtries(card, &maxtries);\n\t\t\tLOG_TEST_RET(card->ctx, r, \"get max counter failed\");\n\n\t\t\tdata->pin1.max_tries = maxtries;\n\t\t}\n//remove below code, because the old implement only return PIN retries, now modify the code and return PIN status\n//\t\treturn r;\n\t}\n\telse if (data->cmd == SC_PIN_CMD_UNBLOCK) { /* verify */\n\t\tr = external_key_auth(card, (kid + 1), (unsigned char *)data->pin1.data,\n\t\t\t\tdata->pin1.len);\n\t\tLOG_TEST_RET(card->ctx, r, \"verify pin failed\");\n\t}\n\telse if (data->cmd == SC_PIN_CMD_CHANGE || data->cmd == SC_PIN_CMD_UNBLOCK) { /* change */\n\t\tr = update_secret_key(card, 0x04, kid, data->pin2.data,\n\t\t\t\t(unsigned long)data->pin2.len);\n\t\tLOG_TEST_RET(card->ctx, r, \"verify pin failed\");\n\t}\n\telse {\n\t\tr = external_key_auth(card, kid, (unsigned char *)data->pin1.data,\n\t\t\t\tdata->pin1.len);\n\t\tget_external_key_retries(card, 0x80 | kid, &retries);\n\t\tif (retries < pin_low)\n\t\t\tsc_log(card->ctx, \"Verification failed (remaining tries: %d)\", retries);\n\n\t}\n\tLOG_TEST_RET(card->ctx, r, \"verify pin failed\");\n\n\tif (r == SC_SUCCESS)\n\t{\n\t\tdata->pin1.logged_in = SC_PIN_STATE_LOGGED_IN;\n\t}\n\n\treturn r;\n}\n\nstatic struct sc_card_driver *sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\n\tepass2003_ops = *iso_ops;\n\n\tepass2003_ops.match_card = epass2003_match_card;\n\tepass2003_ops.init = epass2003_init;\n\tepass2003_ops.finish = epass2003_finish;\n\tepass2003_ops.write_binary = NULL;\n\tepass2003_ops.write_record = NULL;\n\tepass2003_ops.select_file = epass2003_select_file;\n\tepass2003_ops.get_response = NULL;\n\tepass2003_ops.restore_security_env = epass2003_restore_security_env;\n\tepass2003_ops.set_security_env = epass2003_set_security_env;\n\tepass2003_ops.decipher = epass2003_decipher;\n\tepass2003_ops.compute_signature = epass2003_decipher;\n\tepass2003_ops.create_file = epass2003_create_file;\n\tepass2003_ops.delete_file = epass2003_delete_file;\n\tepass2003_ops.list_files = epass2003_list_files;\n\tepass2003_ops.card_ctl = epass2003_card_ctl;\n\tepass2003_ops.process_fci = epass2003_process_fci;\n\tepass2003_ops.construct_fci = epass2003_construct_fci;\n\tepass2003_ops.pin_cmd = epass2003_pin_cmd;\n\tepass2003_ops.check_sw = epass2003_check_sw;\n\tepass2003_ops.get_challenge = epass2003_get_challenge;\n\treturn &epass2003_drv;\n}\n\nstruct sc_card_driver *sc_get_epass2003_driver(void)\n{\n\treturn sc_get_driver();\n}\n#endif\t/* #ifdef ENABLE_OPENSSL */\n#endif\t/* #ifdef ENABLE_SM */\n", "/*\n * card-muscle.c: Support for MuscleCard Applet from musclecard.com\n *\n * Copyright (C) 2006, Identity Alliance, Thomas Harning <support@identityalliance.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"internal.h\"\n#include \"cardctl.h\"\n#include \"muscle.h\"\n#include \"muscle-filesystem.h\"\n#include \"types.h\"\n#include \"opensc.h\"\n\nstatic struct sc_card_operations muscle_ops;\nstatic const struct sc_card_operations *iso_ops = NULL;\n\nstatic struct sc_card_driver muscle_drv = {\n\t\"MuscleApplet\",\n\t\"muscle\",\n\t&muscle_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_atr_table muscle_atrs[] = {\n\t/* Tyfone JCOP 242R2 cards */\n\t{ \"3b:6d:00:00:ff:54:79:66:6f:6e:65:20:32:34:32:52:32\", NULL, NULL, SC_CARD_TYPE_MUSCLE_JCOP242R2_NO_EXT_APDU, 0, NULL },\n\t/* Aladdin eToken PRO USB 72K Java */\n\t{ \"3b:d5:18:00:81:31:3a:7d:80:73:c8:21:10:30\", NULL, NULL, SC_CARD_TYPE_MUSCLE_ETOKEN_72K, 0, NULL },\n\t/* JCOP31 v2.4.1 contact interface */\n\t{ \"3b:f8:13:00:00:81:31:fe:45:4a:43:4f:50:76:32:34:31:b7\", NULL, NULL, SC_CARD_TYPE_MUSCLE_JCOP241, 0, NULL },\n\t/* JCOP31 v2.4.1 RF interface */\n\t{ \"3b:88:80:01:4a:43:4f:50:76:32:34:31:5e\", NULL, NULL, SC_CARD_TYPE_MUSCLE_JCOP241, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n\n#define MUSCLE_DATA(card) ( (muscle_private_t*)card->drv_data )\n#define MUSCLE_FS(card) ( ((muscle_private_t*)card->drv_data)->fs )\ntypedef struct muscle_private {\n\tsc_security_env_t env;\n\tunsigned short verifiedPins;\n\tmscfs_t *fs;\n\tint rsa_key_ref;\n\n} muscle_private_t;\n\nstatic int muscle_finish(sc_card_t *card)\n{\n\tmuscle_private_t *priv = MUSCLE_DATA(card);\n\tmscfs_free(priv->fs);\n\tfree(priv);\n\treturn 0;\n}\n\n\nstatic u8 muscleAppletId[] = { 0xA0, 0x00,0x00,0x00, 0x01, 0x01 };\n\nstatic int muscle_match_card(sc_card_t *card)\n{\n\tsc_apdu_t apdu;\n\tu8 response[64];\n\tint r;\n\n\t/* Since we send an APDU, the card's logout function may be called...\n\t * however it's not always properly nulled out... */\n\tcard->ops->logout = NULL;\n\n\tif (msc_select_applet(card, muscleAppletId, sizeof muscleAppletId) == 1) {\n\t\t/* Muscle applet is present, check the protocol version to be sure */\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2, 0x3C, 0x00, 0x00);\n\t\tapdu.cla = 0xB0;\n\t\tapdu.le = 64;\n\t\tapdu.resplen = 64;\n\t\tapdu.resp = response;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r == SC_SUCCESS && response[0] == 0x01) {\n\t\t\tcard->type = SC_CARD_TYPE_MUSCLE_V1;\n\t\t} else {\n\t\t\tcard->type = SC_CARD_TYPE_MUSCLE_GENERIC;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Since Musclecard has a different ACL system then PKCS15\n * objects need to have their READ/UPDATE/DELETE permissions mapped for files\n * and directory ACLS need to be set\n * For keys.. they have different ACLS, but are accessed in different locations, so it shouldn't be an issue here\n */\nstatic unsigned short muscle_parse_singleAcl(const sc_acl_entry_t* acl)\n{\n\tunsigned short acl_entry = 0;\n\twhile(acl) {\n\t\tint key = acl->key_ref;\n\t\tint method = acl->method;\n\t\tswitch(method) {\n\t\tcase SC_AC_NEVER:\n\t\t\treturn 0xFFFF;\n\t\t/* Ignore... other items overwrite these */\n\t\tcase SC_AC_NONE:\n\t\tcase SC_AC_UNKNOWN:\n\t\t\tbreak;\n\t\tcase SC_AC_CHV:\n\t\t\tacl_entry |= (1 << key); /* Assuming key 0 == SO */\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tdefault:\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\t}\n\t\tacl = acl->next;\n\t}\n\treturn acl_entry;\n}\n\nstatic void muscle_parse_acls(const sc_file_t* file, unsigned short* read_perm, unsigned short* write_perm, unsigned short* delete_perm)\n{\n\tassert(read_perm && write_perm && delete_perm);\n\t*read_perm =  muscle_parse_singleAcl(sc_file_get_acl_entry(file, SC_AC_OP_READ));\n\t*write_perm =  muscle_parse_singleAcl(sc_file_get_acl_entry(file, SC_AC_OP_UPDATE));\n\t*delete_perm =  muscle_parse_singleAcl(sc_file_get_acl_entry(file, SC_AC_OP_DELETE));\n}\n\nstatic int muscle_create_directory(sc_card_t *card, sc_file_t *file)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmsc_id objectId;\n\tu8* oid = objectId.id;\n\tunsigned id = file->id;\n\tunsigned short read_perm = 0, write_perm = 0, delete_perm = 0;\n\tint objectSize;\n\tint r;\n\tif(id == 0) /* No null name files */\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\t/* No nesting directories */\n\tif(fs->currentPath[0] != 0x3F || fs->currentPath[1] != 0x00)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\toid[0] = ((id & 0xFF00) >> 8) & 0xFF;\n\toid[1] = id & 0xFF;\n\toid[2] = oid[3] = 0;\n\n\tobjectSize = file->size;\n\n\tmuscle_parse_acls(file, &read_perm, &write_perm, &delete_perm);\n\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);\n\tmscfs_clear_cache(fs);\n\tif(r >= 0) return 0;\n\treturn r;\n}\n\n\nstatic int muscle_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tint objectSize = file->size;\n\tunsigned short read_perm = 0, write_perm = 0, delete_perm = 0;\n\tmsc_id objectId;\n\tint r;\n\tif(file->type == SC_FILE_TYPE_DF)\n\t\treturn muscle_create_directory(card, file);\n\tif(file->type != SC_FILE_TYPE_WORKING_EF)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\tif(file->id == 0) /* No null name files */\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tmuscle_parse_acls(file, &read_perm, &write_perm, &delete_perm);\n\n\tmscfs_lookup_local(fs, file->id, &objectId);\n\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);\n\tmscfs_clear_cache(fs);\n\tif(r >= 0) return 0;\n\treturn r;\n}\n\nstatic int muscle_read_binary(sc_card_t *card, unsigned int idx, u8* buf, size_t count, unsigned long flags)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tint r;\n\tmsc_id objectId;\n\tu8* oid = objectId.id;\n\tmscfs_file_t *file;\n\n\tr = mscfs_check_selection(fs, -1);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n\tfile = &fs->cache.array[fs->currentFileIndex];\n\tobjectId = file->objectId;\n\t/* memcpy(objectId.id, file->objectId.id, 4); */\n\tif(!file->ef) {\n\t\toid[0] = oid[2];\n\t\toid[1] = oid[3];\n\t\toid[2] = oid[3] = 0;\n\t}\n\tr = msc_read_object(card, objectId, idx, buf, count);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n\nstatic int muscle_update_binary(sc_card_t *card, unsigned int idx, const u8* buf, size_t count, unsigned long flags)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tint r;\n\tmscfs_file_t *file;\n\tmsc_id objectId;\n\tu8* oid = objectId.id;\n\n\tr = mscfs_check_selection(fs, -1);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n\tfile = &fs->cache.array[fs->currentFileIndex];\n\n\tobjectId = file->objectId;\n\t/* memcpy(objectId.id, file->objectId.id, 4); */\n\tif(!file->ef) {\n\t\toid[0] = oid[2];\n\t\toid[1] = oid[3];\n\t\toid[2] = oid[3] = 0;\n\t}\n\tif(file->size < idx + count) {\n\t\tint newFileSize = idx + count;\n\t\tu8* buffer = malloc(newFileSize);\n\t\tif(buffer == NULL) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\n\t\tr = msc_read_object(card, objectId, 0, buffer, file->size);\n\t\t/* TODO: RETRIEVE ACLS */\n\t\tif(r < 0) goto update_bin_free_buffer;\n\t\tr = msc_delete_object(card, objectId, 0);\n\t\tif(r < 0) goto update_bin_free_buffer;\n\t\tr = msc_create_object(card, objectId, newFileSize, 0,0,0);\n\t\tif(r < 0) goto update_bin_free_buffer;\n\t\tmemcpy(buffer + idx, buf, count);\n\t\tr = msc_update_object(card, objectId, 0, buffer, newFileSize);\n\t\tif(r < 0) goto update_bin_free_buffer;\n\t\tfile->size = newFileSize;\nupdate_bin_free_buffer:\n\t\tfree(buffer);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n\t} else {\n\t\tr = msc_update_object(card, objectId, idx, buf, count);\n\t}\n\t/* mscfs_clear_cache(fs); */\n\treturn r;\n}\n\n/* TODO: Evaluate correctness */\nstatic int muscle_delete_mscfs_file(sc_card_t *card, mscfs_file_t *file_data)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmsc_id id = file_data->objectId;\n\tu8* oid = id.id;\n\tint r;\n\n\tif(!file_data->ef) {\n\t\tint x;\n\t\tmscfs_file_t *childFile;\n\t\t/* Delete children */\n\t\tmscfs_check_cache(fs);\n\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"DELETING Children of: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tfor(x = 0; x < fs->cache.size; x++) {\n\t\t\tmsc_id objectId;\n\t\t\tchildFile = &fs->cache.array[x];\n\t\t\tobjectId = childFile->objectId;\n\n\t\t\tif(0 == memcmp(oid + 2, objectId.id, 2)) {\n\t\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\t\t\"DELETING: %02X%02X%02X%02X\\n\",\n\t\t\t\t\tobjectId.id[0],objectId.id[1],\n\t\t\t\t\tobjectId.id[2],objectId.id[3]);\n\t\t\t\tr = muscle_delete_mscfs_file(card, childFile);\n\t\t\t\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\t\t\t}\n\t\t}\n\t\toid[0] = oid[2];\n\t\toid[1] = oid[3];\n\t\toid[2] = oid[3] = 0;\n\t\t/* ??? objectId = objectId >> 16; */\n\t}\n\tif((0 == memcmp(oid, \"\\x3F\\x00\\x00\\x00\", 4))\n\t\t|| (0 == memcmp(oid, \"\\x3F\\x00\\x3F\\x00\", 4))) {\n\t}\n\tr = msc_delete_object(card, id, 1);\n\t/* Check if its the root... this file generally is virtual\n\t * So don't return an error if it fails */\n\tif((0 == memcmp(oid, \"\\x3F\\x00\\x00\\x00\", 4))\n\t\t|| (0 == memcmp(oid, \"\\x3F\\x00\\x3F\\x00\", 4)))\n\t\treturn 0;\n\n\tif(r < 0) {\n\t\tprintf(\"ID: %02X%02X%02X%02X\\n\",\n\t\t\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\t}\n\treturn 0;\n}\n\nstatic int muscle_delete_file(sc_card_t *card, const sc_path_t *path_in)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint r = 0;\n\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, NULL);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\tr = muscle_delete_mscfs_file(card, file_data);\n\tmscfs_clear_cache(fs);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\treturn 0;\n}\n\nstatic void muscle_load_single_acl(sc_file_t* file, int operation, unsigned short acl)\n{\n\tint key;\n\t/* Everybody by default.... */\n\tsc_file_add_acl_entry(file, operation, SC_AC_NONE, 0);\n\tif(acl == 0xFFFF) {\n\t\tsc_file_add_acl_entry(file, operation, SC_AC_NEVER, 0);\n\t\treturn;\n\t}\n\tfor(key = 0; key < 16; key++) {\n\t\tif(acl >> key & 1) {\n\t\t\tsc_file_add_acl_entry(file, operation, SC_AC_CHV, key);\n\t\t}\n\t}\n}\nstatic void muscle_load_file_acls(sc_file_t* file, mscfs_file_t *file_data)\n{\n\tmuscle_load_single_acl(file, SC_AC_OP_READ, file_data->read);\n\tmuscle_load_single_acl(file, SC_AC_OP_WRITE, file_data->write);\n\tmuscle_load_single_acl(file, SC_AC_OP_UPDATE, file_data->write);\n\tmuscle_load_single_acl(file, SC_AC_OP_DELETE, file_data->delete);\n}\nstatic void muscle_load_dir_acls(sc_file_t* file, mscfs_file_t *file_data)\n{\n\tmuscle_load_single_acl(file, SC_AC_OP_SELECT, 0);\n\tmuscle_load_single_acl(file, SC_AC_OP_LIST_FILES, 0);\n\tmuscle_load_single_acl(file, SC_AC_OP_LOCK, 0xFFFF);\n\tmuscle_load_single_acl(file, SC_AC_OP_DELETE, file_data->delete);\n\tmuscle_load_single_acl(file, SC_AC_OP_CREATE, file_data->write);\n}\n\n/* Required type = -1 for don't care, 1 for EF, 0 for DF */\nstatic int select_item(sc_card_t *card, const sc_path_t *path_in, sc_file_t ** file_out, int requiredType)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint pathlen = path_in->len;\n\tint r = 0;\n\tint objectIndex;\n\tu8* oid;\n\n\tmscfs_check_cache(fs);\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, &objectIndex);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\n\t/* Check if its the right type */\n\tif(requiredType >= 0 && requiredType != file_data->ef) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\toid = file_data->objectId.id;\n\t/* Is it a file or directory */\n\tif(file_data->ef) {\n\t\tfs->currentPath[0] = oid[0];\n\t\tfs->currentPath[1] = oid[1];\n\t\tfs->currentFile[0] = oid[2];\n\t\tfs->currentFile[1] = oid[3];\n\t} else {\n\t\tfs->currentPath[0] = oid[pathlen - 2];\n\t\tfs->currentPath[1] = oid[pathlen - 1];\n\t\tfs->currentFile[0] = 0;\n\t\tfs->currentFile[1] = 0;\n\t}\n\n\tfs->currentFileIndex = objectIndex;\n\tif(file_out) {\n\t\tsc_file_t *file;\n\t\tfile = sc_file_new();\n\t\tfile->path = *path_in;\n\t\tfile->size = file_data->size;\n\t\tfile->id = (oid[2] << 8) | oid[3];\n\t\tif(!file_data->ef) {\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t} else {\n\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\t\t\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\t\t}\n\n\t\t/* Setup ACLS */\n\t\tif(file_data->ef) {\n\t\t\tmuscle_load_file_acls(file, file_data);\n\t\t} else {\n\t\t\tmuscle_load_dir_acls(file, file_data);\n\t\t\t/* Setup directory acls... */\n\t\t}\n\n\t\tfile->magic = SC_FILE_MAGIC;\n\t\t*file_out = file;\n\t}\n\treturn 0;\n}\n\nstatic int muscle_select_file(sc_card_t *card, const sc_path_t *path_in,\n\t\t\t     sc_file_t **file_out)\n{\n\tint r;\n\n\tassert(card != NULL && path_in != NULL);\n\n\tswitch (path_in->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tr = select_item(card, path_in, file_out, 1);\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tr = select_item(card, path_in, file_out, 0);\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tr = select_item(card, path_in, file_out, -1);\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif(r > 0) r = 0;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n}\n\nstatic int _listFile(mscfs_file_t *file, int reset, void *udata)\n{\n\tint next = reset ? 0x00 : 0x01;\n\treturn msc_list_objects( (sc_card_t*)udata, next, file);\n}\n\nstatic int muscle_init(sc_card_t *card)\n{\n\tmuscle_private_t *priv;\n\n\tcard->name = \"MuscleApplet\";\n\tcard->drv_data = malloc(sizeof(muscle_private_t));\n\tif(!card->drv_data) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tmemset(card->drv_data, 0, sizeof(muscle_private_t));\n\tpriv = MUSCLE_DATA(card);\n\tpriv->verifiedPins = 0;\n\tpriv->fs = mscfs_new();\n\tif(!priv->fs) {\n\t\tfree(card->drv_data);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tpriv->fs->udata = card;\n\tpriv->fs->listFile = _listFile;\n\n\tcard->cla = 0xB0;\n\n\tcard->flags |= SC_CARD_FLAG_RNG;\n\tcard->caps |= SC_CARD_CAP_RNG;\n\n\t/* Card type detection */\n\t_sc_match_atr(card, muscle_atrs, &card->type);\n\tif(card->type == SC_CARD_TYPE_MUSCLE_ETOKEN_72K) {\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t}\n\tif(card->type == SC_CARD_TYPE_MUSCLE_JCOP241) {\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t}\n\tif (!(card->caps & SC_CARD_CAP_APDU_EXT)) {\n\t\tcard->max_recv_size = 255;\n\t\tcard->max_send_size = 255;\n\t}\n\tif(card->type == SC_CARD_TYPE_MUSCLE_JCOP242R2_NO_EXT_APDU) {\n\t        /* Tyfone JCOP v242R2 card that doesn't support extended APDUs */\n\t}\n\n\n\t/* FIXME: Card type detection */\n\tif (1) {\n\t\tunsigned long flags;\n\n\t\tflags = SC_ALGORITHM_RSA_RAW;\n\t\tflags |= SC_ALGORITHM_RSA_HASH_NONE;\n\t\tflags |= SC_ALGORITHM_ONBOARD_KEY_GEN;\n\n\t\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid = fs->cache.array[x].objectId.id;\n\t\tif (bufLen < 2)\n\t\t\tbreak;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n\t\t\tbuf += 2;\n\t\t\tcount += 2;\n\t\t\tbufLen -= 2;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic int muscle_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *cmd,\n\t\t\t\tint *tries_left)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tconst int bufferLength = MSC_MAX_PIN_COMMAND_LENGTH;\n\tu8 buffer[MSC_MAX_PIN_COMMAND_LENGTH];\n\tswitch(cmd->cmd) {\n\tcase SC_PIN_CMD_VERIFY:\n\t\tswitch(cmd->pin_type) {\n\t\tcase SC_AC_CHV: {\n\t\t\tsc_apdu_t apdu;\n\t\t\tint r;\n\t\t\tmsc_verify_pin_apdu(card, &apdu, buffer, bufferLength, cmd->pin_reference, cmd->pin1.data, cmd->pin1.len);\n\t\t\tcmd->apdu = &apdu;\n\t\t\tcmd->pin1.offset = 5;\n\t\t\tr = iso_ops->pin_cmd(card, cmd, tries_left);\n\t\t\tif(r >= 0)\n\t\t\t\tpriv->verifiedPins |= (1 << cmd->pin_reference);\n\t\t\treturn r;\n\t\t}\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_NONE:\n\t\tdefault:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Unsupported authentication method\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\tcase SC_PIN_CMD_CHANGE:\n\t\tswitch(cmd->pin_type) {\n\t\tcase SC_AC_CHV: {\n\t\t\tsc_apdu_t apdu;\n\t\t\tmsc_change_pin_apdu(card, &apdu, buffer, bufferLength, cmd->pin_reference, cmd->pin1.data, cmd->pin1.len, cmd->pin2.data, cmd->pin2.len);\n\t\t\tcmd->apdu = &apdu;\n\t\t\treturn iso_ops->pin_cmd(card, cmd, tries_left);\n\t\t}\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_NONE:\n\t\tdefault:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Unsupported authentication method\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\tcase SC_PIN_CMD_UNBLOCK:\n\tswitch(cmd->pin_type) {\n\t\tcase SC_AC_CHV: {\n\t\t\tsc_apdu_t apdu;\n\t\t\tmsc_unblock_pin_apdu(card, &apdu, buffer, bufferLength, cmd->pin_reference, cmd->pin1.data, cmd->pin1.len);\n\t\t\tcmd->apdu = &apdu;\n\t\t\treturn iso_ops->pin_cmd(card, cmd, tries_left);\n\t\t}\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_NONE:\n\t\tdefault:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Unsupported authentication method\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\tdefault:\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Unsupported command\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\n\t}\n\n}\n\nstatic int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)\n{\n\t/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */\n\tswitch(info->keyType) {\n\tcase 1: /* RSA */\n\t\treturn msc_extract_rsa_public_key(card,\n\t\t\tinfo->keyLocation,\n\t\t\t&info->modLength,\n\t\t\t&info->modValue,\n\t\t\t&info->expLength,\n\t\t\t&info->expValue);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n}\n\nstatic int muscle_card_import_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)\n{\n\t/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */\n\tswitch(info->keyType) {\n\tcase 0x02: /* RSA_PRIVATE */\n\tcase 0x03: /* RSA_PRIVATE_CRT */\n\t\treturn msc_import_key(card,\n\t\t\tinfo->keyLocation,\n\t\t\tinfo);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n}\n\nstatic int muscle_card_generate_key(sc_card_t *card, sc_cardctl_muscle_gen_key_info_t *info)\n{\n\treturn msc_generate_keypair(card,\n\t\tinfo->privateKeyLocation,\n\t\tinfo->publicKeyLocation,\n\t\tinfo->keyType,\n\t\tinfo->keySize,\n\t\t0);\n}\n\nstatic int muscle_card_verified_pins(sc_card_t *card, sc_cardctl_muscle_verified_pins_info_t *info)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tinfo->verifiedPins = priv->verifiedPins;\n\treturn 0;\n}\nstatic int muscle_card_ctl(sc_card_t *card, unsigned long request, void *data)\n{\n\tswitch(request) {\n\tcase SC_CARDCTL_MUSCLE_GENERATE_KEY:\n\t\treturn muscle_card_generate_key(card, (sc_cardctl_muscle_gen_key_info_t*) data);\n\tcase SC_CARDCTL_MUSCLE_EXTRACT_KEY:\n\t\treturn muscle_card_extract_key(card, (sc_cardctl_muscle_key_info_t*) data);\n\tcase SC_CARDCTL_MUSCLE_IMPORT_KEY:\n\t\treturn muscle_card_import_key(card, (sc_cardctl_muscle_key_info_t*) data);\n\tcase SC_CARDCTL_MUSCLE_VERIFIED_PINS:\n\t\treturn muscle_card_verified_pins(card, (sc_cardctl_muscle_verified_pins_info_t*) data);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED; /* Unsupported.. whatever it is */\n\t}\n}\n\nstatic int muscle_set_security_env(sc_card_t *card,\n\t\t\t\t const sc_security_env_t *env,\n\t\t\t\t int se_num)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\n\tif (env->operation != SC_SEC_OPERATION_SIGN &&\n\t    env->operation != SC_SEC_OPERATION_DECIPHER) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Invalid crypto operation supplied.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (env->algorithm != SC_ALGORITHM_RSA) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Invalid crypto algorithm supplied.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\t/* ADJUST FOR PKCS1 padding support for decryption only */\n\tif ((env->algorithm_flags & SC_ALGORITHM_RSA_PADS) ||\n\t    (env->algorithm_flags & SC_ALGORITHM_RSA_HASHES)) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Card supports only raw RSA.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT) {\n\t\tif (env->key_ref_len != 1 ||\n\t\t    (env->key_ref[0] > 0x0F)) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Invalid key reference supplied.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tpriv->rsa_key_ref = env->key_ref[0];\n\t}\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Algorithm reference not supported.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\t/* if (env->flags & SC_SEC_ENV_FILE_REF_PRESENT)\n\t\tif (memcmp(env->file_ref.value, \"\\x00\\x12\", 2) != 0) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"File reference is not 0012.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t} */\n\tpriv->env = *env;\n\treturn 0;\n}\n\nstatic int muscle_restore_security_env(sc_card_t *card, int se_num)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmemset(&priv->env, 0, sizeof(priv->env));\n\treturn 0;\n}\n\n\nstatic int muscle_decipher(sc_card_t * card,\n\t\t\t const u8 * crgram, size_t crgram_len, u8 * out,\n\t\t\t size_t out_len)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\n\tu8 key_id;\n\tint r;\n\n\t/* sanity check */\n\tif (priv->env.operation != SC_SEC_OPERATION_DECIPHER)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tkey_id = priv->rsa_key_ref * 2; /* Private key */\n\n\tif (out_len < crgram_len) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Output buffer too small\");\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t}\n\n\tr = msc_compute_crypt(card,\n\t\tkey_id,\n\t\t0x00, /* RSA NO PADDING */\n\t\t0x04, /* decrypt */\n\t\tcrgram,\n\t\tout,\n\t\tcrgram_len,\n\t\tout_len);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"Card signature failed\");\n\treturn r;\n}\n\nstatic int muscle_compute_signature(sc_card_t *card, const u8 *data,\n\t\tsize_t data_len, u8 * out, size_t outlen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tu8 key_id;\n\tint r;\n\n\tkey_id = priv->rsa_key_ref * 2; /* Private key */\n\n\tif (outlen < data_len) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Output buffer too small\");\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t}\n\n\tr = msc_compute_crypt(card,\n\t\tkey_id,\n\t\t0x00, /* RSA NO PADDING */\n\t\t0x04, /* -- decrypt raw... will do what we need since signing isn't yet supported */\n\t\tdata,\n\t\tout,\n\t\tdata_len,\n\t\toutlen);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"Card signature failed\");\n\treturn r;\n}\n\nstatic int muscle_get_challenge(sc_card_t *card, u8 *rnd, size_t len)\n{\n\tif (len == 0)\n\t\treturn SC_SUCCESS;\n\telse {\n\t\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\tmsc_get_challenge(card, len, 0, NULL, rnd),\n\t\t\t\t\"GET CHALLENGE cmd failed\");\n\t\treturn (int) len;\n\t}\n}\n\nstatic int muscle_check_sw(sc_card_t * card, unsigned int sw1, unsigned int sw2) {\n\tif(sw1 == 0x9C) {\n\t\tswitch(sw2) {\n\t\t\tcase 0x01: /* SW_NO_MEMORY_LEFT */\n\t\t\t\treturn SC_ERROR_NOT_ENOUGH_MEMORY;\n\t\t\tcase 0x02: /* SW_AUTH_FAILED */\n\t\t\t\treturn SC_ERROR_PIN_CODE_INCORRECT;\n\t\t\tcase 0x03: /* SW_OPERATION_NOT_ALLOWED */\n\t\t\t\treturn SC_ERROR_NOT_ALLOWED;\n\t\t\tcase 0x05: /* SW_UNSUPPORTED_FEATURE */\n\t\t\t\treturn SC_ERROR_NO_CARD_SUPPORT;\n\t\t\tcase 0x06: /* SW_UNAUTHORIZED */\n\t\t\t\treturn SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t\tcase 0x07: /* SW_OBJECT_NOT_FOUND */\n\t\t\t\treturn SC_ERROR_FILE_NOT_FOUND;\n\t\t\tcase 0x08: /* SW_OBJECT_EXISTS */\n\t\t\t\treturn SC_ERROR_FILE_ALREADY_EXISTS;\n\t\t\tcase 0x09: /* SW_INCORRECT_ALG */\n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t\t\tcase 0x0B: /* SW_SIGNATURE_INVALID */\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t\tcase 0x0C: /* SW_IDENTITY_BLOCKED */\n\t\t\t\treturn SC_ERROR_AUTH_METHOD_BLOCKED;\n\t\t\tcase 0x0F: /* SW_INVALID_PARAMETER */\n\t\t\tcase 0x10: /* SW_INCORRECT_P1 */\n\t\t\tcase 0x11: /* SW_INCORRECT_P2 */\n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t\t}\n\t}\n\treturn iso_ops->check_sw(card, sw1, sw2);\n}\n\nstatic int muscle_card_reader_lock_obtained(sc_card_t *card, int was_reset)\n{\n\tint r = SC_SUCCESS;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (was_reset > 0) {\n\t\tif (msc_select_applet(card, muscleAppletId, sizeof muscleAppletId) != 1) {\n\t\t\tr = SC_ERROR_INVALID_CARD;\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\n\tmuscle_ops = *iso_drv->ops;\n\tmuscle_ops.check_sw = muscle_check_sw;\n\tmuscle_ops.pin_cmd = muscle_pin_cmd;\n\tmuscle_ops.match_card = muscle_match_card;\n\tmuscle_ops.init = muscle_init;\n\tmuscle_ops.finish = muscle_finish;\n\n\tmuscle_ops.get_challenge = muscle_get_challenge;\n\n\tmuscle_ops.set_security_env = muscle_set_security_env;\n\tmuscle_ops.restore_security_env = muscle_restore_security_env;\n\tmuscle_ops.compute_signature = muscle_compute_signature;\n\tmuscle_ops.decipher = muscle_decipher;\n\tmuscle_ops.card_ctl = muscle_card_ctl;\n\tmuscle_ops.read_binary = muscle_read_binary;\n\tmuscle_ops.update_binary = muscle_update_binary;\n\tmuscle_ops.create_file = muscle_create_file;\n\tmuscle_ops.select_file = muscle_select_file;\n\tmuscle_ops.delete_file = muscle_delete_file;\n\tmuscle_ops.list_files = muscle_list_files;\n\tmuscle_ops.card_reader_lock_obtained = muscle_card_reader_lock_obtained;\n\n\treturn &muscle_drv;\n}\n\nstruct sc_card_driver * sc_get_muscle_driver(void)\n{\n\treturn sc_get_driver();\n}\n", "/*\n * card-tcos.c: Support for TCOS cards\n *\n * Copyright (C) 2011  Peter Koch <pk@opensc-project.org>\n * Copyright (C) 2002  g10 Code GmbH\n * Copyright (C) 2001  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n\nstatic struct sc_atr_table tcos_atrs[] = {\n\t/* Infineon SLE44 */\n\t{ \"3B:BA:13:00:81:31:86:5D:00:64:05:0A:02:01:31:80:90:00:8B\", NULL, NULL, SC_CARD_TYPE_TCOS_V2, 0, NULL },\n\t/* Infineon SLE66S */\n\t{ \"3B:BA:14:00:81:31:86:5D:00:64:05:14:02:02:31:80:90:00:91\", NULL, NULL, SC_CARD_TYPE_TCOS_V2, 0, NULL },\n\t/* Infineon SLE66CX320P */\n\t{ \"3B:BA:96:00:81:31:86:5D:00:64:05:60:02:03:31:80:90:00:66\", NULL, NULL, SC_CARD_TYPE_TCOS_V2, 0, NULL },\n\t/* Infineon SLE66CX322P */\n\t{ \"3B:BA:96:00:81:31:86:5D:00:64:05:7B:02:03:31:80:90:00:7D\", NULL, NULL, SC_CARD_TYPE_TCOS_V2, 0, NULL },\n\t/* Philips P5CT072 */\n\t{ \"3B:BF:96:00:81:31:FE:5D:00:64:04:11:03:01:31:C0:73:F7:01:D0:00:90:00:7D\", NULL, NULL, SC_CARD_TYPE_TCOS_V3, 0, NULL },\n\t{ \"3B:BF:96:00:81:31:FE:5D:00:64:04:11:04:0F:31:C0:73:F7:01:D0:00:90:00:74\", NULL, NULL, SC_CARD_TYPE_TCOS_V3, 0, NULL },\n\t/* Philips P5CT080 */\n\t{ \"3B:BF:B6:00:81:31:FE:5D:00:64:04:28:03:02:31:C0:73:F7:01:D0:00:90:00:67\", NULL, NULL, SC_CARD_TYPE_TCOS_V3, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n\nstatic struct sc_card_operations tcos_ops;\nstatic struct sc_card_driver tcos_drv = {\n\t\"TCOS 3.0\",\n\t\"tcos\",\n\t&tcos_ops,\n\tNULL, 0, NULL\n};\n\nstatic const struct sc_card_operations *iso_ops = NULL;\n\ntypedef struct tcos_data_st {\n\tunsigned int pad_flags;\n\tunsigned int next_sign;\n} tcos_data;\n\n\nstatic int tcos_finish(sc_card_t *card)\n{\n\tfree(card->drv_data);\n\treturn 0;\n}\n\n\nstatic int tcos_match_card(sc_card_t *card)\n{\n\tint i;\n\n\ti = _sc_match_atr(card, tcos_atrs, &card->type);\n\tif (i < 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic int tcos_init(sc_card_t *card)\n{\n        unsigned long flags;\n\n\ttcos_data *data = malloc(sizeof(tcos_data));\n\tif (!data) return SC_ERROR_OUT_OF_MEMORY;\n\n\tcard->name = \"TCOS\";\n\tcard->drv_data = (void *)data;\n\tcard->cla = 0x00;\n\n        flags = SC_ALGORITHM_RSA_RAW;\n        flags |= SC_ALGORITHM_RSA_PAD_PKCS1;\n        flags |= SC_ALGORITHM_RSA_HASH_NONE;\n\n        _sc_card_add_rsa_alg(card, 512, flags, 0);\n        _sc_card_add_rsa_alg(card, 768, flags, 0);\n        _sc_card_add_rsa_alg(card, 1024, flags, 0);\n\n\tif (card->type == SC_CARD_TYPE_TCOS_V3) {\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t\t_sc_card_add_rsa_alg(card, 1280, flags, 0);\n\t\t_sc_card_add_rsa_alg(card, 1536, flags, 0);\n\t\t_sc_card_add_rsa_alg(card, 1792, flags, 0);\n        \t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t}\n\n\treturn 0;\n}\n\n\n/* Hmmm, I don't know what to do.  It seems that the ACL design of\n   OpenSC should be enhanced to allow for the command based security\n   attributes of TCOS.  FIXME: This just allows to create a very basic\n   file. */\nstatic int tcos_construct_fci(const sc_file_t *file,\n                              u8 *out, size_t *outlen)\n{\n\tu8 *p = out;\n\tu8 buf[64];\n        size_t n;\n\n        /* FIXME: possible buffer overflow */\n\n        *p++ = 0x6F; /* FCI */\n        p++;\n\n\t/* File size */\n\tbuf[0] = (file->size >> 8) & 0xFF;\n\tbuf[1] = file->size & 0xFF;\n\tsc_asn1_put_tag(0x81, buf, 2, p, 16, &p);\n\n        /* File descriptor */\n        n = 0;\n\tbuf[n] = file->shareable ? 0x40 : 0;\n\tswitch (file->type) {\n\tcase SC_FILE_TYPE_WORKING_EF:\n\t\tbreak;\n\tcase SC_FILE_TYPE_DF:\n\t\tbuf[0] |= 0x38;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tbuf[n++] |= file->ef_structure & 7;\n        if ( (file->ef_structure & 7) > 1) {\n                /* record structured file */\n                buf[n++] = 0x41; /* indicate 3rd byte */\n                buf[n++] = file->record_length;\n        }\n\tsc_asn1_put_tag(0x82, buf, n, p, 8, &p);\n\n        /* File identifier */\n\tbuf[0] = (file->id >> 8) & 0xFF;\n\tbuf[1] = file->id & 0xFF;\n\tsc_asn1_put_tag(0x83, buf, 2, p, 16, &p);\n\n        /* Directory name */\n        if (file->type == SC_FILE_TYPE_DF) {\n                if (file->namelen) {\n                        sc_asn1_put_tag(0x84, file->name, file->namelen,\n                                        p, 16, &p);\n                }\n                else {\n                        /* TCOS needs one, so we use a faked one */\n                        snprintf ((char *) buf, sizeof(buf)-1, \"foo-%lu\",\n                                  (unsigned long) time (NULL));\n                        sc_asn1_put_tag(0x84, buf, strlen ((char *) buf), p, 16, &p);\n                }\n        }\n\n        /* File descriptor extension */\n        if (file->prop_attr_len && file->prop_attr) {\n\t\tn = file->prop_attr_len;\n\t\tmemcpy(buf, file->prop_attr, n);\n        }\n        else {\n                n = 0;\n                buf[n++] = 0x01; /* not invalidated, permanent */\n                if (file->type == SC_FILE_TYPE_WORKING_EF) \n                        buf[n++] = 0x00; /* generic data file */\n        }\n        sc_asn1_put_tag(0x85, buf, n, p, 16, &p);\n\n        /* Security attributes */\n\tif (file->sec_attr_len && file->sec_attr) {\n\t\tmemcpy(buf, file->sec_attr, file->sec_attr_len);\n\t\tn = file->sec_attr_len;\n\t}\n        else {\n                /* no attributes given - fall back to default one */\n                memcpy (buf+ 0, \"\\xa4\\x00\\x00\\x00\\xff\\xff\", 6); /* select */\n                memcpy (buf+ 6, \"\\xb0\\x00\\x00\\x00\\xff\\xff\", 6); /* read bin */\n                memcpy (buf+12, \"\\xd6\\x00\\x00\\x00\\xff\\xff\", 6); /* upd bin */\n                memcpy (buf+18, \"\\x60\\x00\\x00\\x00\\xff\\xff\", 6); /* admin grp*/\n                n = 24;\n        }\n        sc_asn1_put_tag(0x86, buf, n, p, sizeof (buf), &p);\n\n        \n        /* fixup length of FCI */\n        out[1] = p - out - 2;\n\n\t*outlen = p - out;\n\treturn 0;\n}\n\n\nstatic int tcos_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tint r;\n\tsize_t len;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tsc_apdu_t apdu;\n\n\tlen = SC_MAX_APDU_BUFFER_SIZE;\n\tr = tcos_construct_fci(file, sbuf, &len);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"tcos_construct_fci() failed\");\n\t\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x00, 0x00);\n        apdu.cla |= 0x80;  /* this is an proprietary extension */\n\tapdu.lc = len;\n\tapdu.datalen = len;\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n}\n\n\nstatic unsigned int map_operations (int commandbyte )\n{\n\tunsigned int op = (unsigned int)-1;\n\n\tswitch ( (commandbyte & 0xfe) ) {\n\t\tcase 0xe2: /* append record */   op = SC_AC_OP_UPDATE; break;\n\t\tcase 0x24: /* change password */ op = SC_AC_OP_UPDATE; break;\n\t\tcase 0xe0: /* create */          op = SC_AC_OP_CREATE; break;\n\t\tcase 0xe4: /* delete */          op = SC_AC_OP_DELETE; break;\n\t\tcase 0xe8: /* exclude sfi */     op = SC_AC_OP_WRITE; break;\n\t\tcase 0x82: /* external auth */   op = SC_AC_OP_READ; break;\n\t\tcase 0xe6: /* include sfi */     op = SC_AC_OP_WRITE; break;\n\t\tcase 0x88: /* internal auth */   op = SC_AC_OP_READ; break;\n\t\tcase 0x04: /* invalidate */      op = SC_AC_OP_INVALIDATE; break;\n\t\tcase 0x2a: /* perform sec. op */ op = SC_AC_OP_SELECT; break;\n\t\tcase 0xb0: /* read binary */     op = SC_AC_OP_READ; break;\n\t\tcase 0xb2: /* read record */     op = SC_AC_OP_READ; break;\n\t\tcase 0x44: /* rehabilitate */    op = SC_AC_OP_REHABILITATE; break;\n\t\tcase 0xa4: /* select */          op = SC_AC_OP_SELECT; break;\n\t\tcase 0xee: /* set permanent */   op = SC_AC_OP_CREATE; break;\n\t\tcase 0x2c: /* unblock password */op = SC_AC_OP_WRITE; break;\n\t\tcase 0xd6: /* update binary */   op = SC_AC_OP_WRITE; break;\n\t\tcase 0xdc: /* update record */   op = SC_AC_OP_WRITE; break;\n\t\tcase 0x20: /* verify password */ op = SC_AC_OP_SELECT; break;\n\t\tcase 0x60: /* admin group */     op = SC_AC_OP_CREATE; break;\n\t}\n\treturn op;\n}\n\n\n/* Hmmm, I don't know what to do.  It seems that the ACL design of\n   OpenSC should be enhanced to allow for the command based security\n   attributes of TCOS.  FIXME: This just allows to create a very basic\n   file. */\nstatic void parse_sec_attr(sc_card_t *card,\n                           sc_file_t *file, const u8 *buf, size_t len)\n{\n        unsigned int op;\n        \n        /* list directory is not covered by ACLs - so always add an entry */\n        sc_file_add_acl_entry (file, SC_AC_OP_LIST_FILES,\n                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n        /* FIXME: check for what LOCK is used */\n        sc_file_add_acl_entry (file, SC_AC_OP_LOCK,\n                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n        for (; len >= 6; len -= 6, buf += 6) {\n                /* FIXME: temporary hacks */\n                if (!memcmp(buf, \"\\xa4\\x00\\x00\\x00\\xff\\xff\", 6)) /* select */\n                        sc_file_add_acl_entry (file, SC_AC_OP_SELECT,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                else if (!memcmp(buf, \"\\xb0\\x00\\x00\\x00\\xff\\xff\", 6)) /*read*/\n                        sc_file_add_acl_entry (file, SC_AC_OP_READ,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                else if (!memcmp(buf, \"\\xd6\\x00\\x00\\x00\\xff\\xff\", 6)) /*upd*/\n                        sc_file_add_acl_entry (file, SC_AC_OP_UPDATE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                else if (!memcmp(buf, \"\\x60\\x00\\x00\\x00\\xff\\xff\", 6)) {/*adm */\n                        sc_file_add_acl_entry (file, SC_AC_OP_WRITE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                        sc_file_add_acl_entry (file, SC_AC_OP_CREATE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                        sc_file_add_acl_entry (file, SC_AC_OP_INVALIDATE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                        sc_file_add_acl_entry (file, SC_AC_OP_REHABILITATE,\n                                               SC_AC_NONE, SC_AC_KEY_REF_NONE);\n                }\n                else {\n                        /* the first byte tells use the command or the\n                           command group.  We have to mask bit 0\n                           because this one distinguish between AND/OR\n                           combination of PINs*/\n                        op = map_operations (buf[0]);\n                        if (op == (unsigned int)-1)\n                        {\n                                sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n                                       \"Unknown security command byte %02x\\n\",\n                                       buf[0]);\n                                continue;\n                        }\n                        if (!buf[1])\n                                sc_file_add_acl_entry (file, op,\n                                                       SC_AC_NONE,\n                                                       SC_AC_KEY_REF_NONE);\n                        else\n                                sc_file_add_acl_entry (file, op,\n                                                       SC_AC_CHV, buf[1]);\n\n                        if (!buf[2] && !buf[3])\n                                sc_file_add_acl_entry (file, op,\n                                                       SC_AC_NONE,\n                                                       SC_AC_KEY_REF_NONE);\n                        else\n                                sc_file_add_acl_entry (file, op,\n                                                       SC_AC_TERM,\n                                                       (buf[2]<<8)|buf[3]);\n                }\n        }\n}\n\n\nstatic int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}\n\n\nstatic int tcos_list_files(sc_card_t *card, u8 *buf, size_t buflen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE], p1;\n\tint r, count = 0;\n\n\tassert(card != NULL);\n\tctx = card->ctx;\n\n\tfor (p1=1; p1<=2; p1++) {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xAA, p1, 0);\n\t\tapdu.cla = 0x80;\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 256;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t\tif (apdu.sw1==0x6A && (apdu.sw2==0x82 || apdu.sw2==0x88)) continue;\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"List Dir failed\");\n\t\tif (apdu.resplen > buflen) return SC_ERROR_BUFFER_TOO_SMALL;\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"got %\"SC_FORMAT_LEN_SIZE_T\"u %s-FileIDs\\n\",\n\t\t\t apdu.resplen / 2, p1 == 1 ? \"DF\" : \"EF\");\n\n\t\tmemcpy(buf, apdu.resp, apdu.resplen);\n\t\tbuf += apdu.resplen;\n\t\tbuflen -= apdu.resplen;\n\t\tcount += apdu.resplen;\n\t}\n\treturn count;\n}\n\n\nstatic int tcos_delete_file(sc_card_t *card, const sc_path_t *path)\n{\n\tint r;\n\tu8 sbuf[2];\n\tsc_apdu_t apdu;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (path->type != SC_PATH_TYPE_FILE_ID && path->len != 2) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"File type has to be SC_PATH_TYPE_FILE_ID\\n\");\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tsbuf[0] = path->value[0];\n\tsbuf[1] = path->value[1];\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE4, 0x00, 0x00);\n        apdu.cla |= 0x80;\n\tapdu.lc = 2;\n\tapdu.datalen = 2;\n\tapdu.data = sbuf;\n\t\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n}\n\n\nstatic int tcos_set_security_env(sc_card_t *card, const sc_security_env_t *env, int se_num)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE], *p;\n\tint r, default_key, tcos3;\n\ttcos_data *data;\n\n\tassert(card != NULL && env != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n        if (se_num || (env->operation!=SC_SEC_OPERATION_DECIPHER && env->operation!=SC_SEC_OPERATION_SIGN)){\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif(!(env->flags & SC_SEC_ENV_KEY_REF_PRESENT))\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"No Key-Reference in SecEnvironment\\n\");\n\telse\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"Key-Reference %02X (len=%\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t\t\t env->key_ref[0], env->key_ref_len);\n\t/* Key-Reference 0x80 ?? */\n\tdefault_key= !(env->flags & SC_SEC_ENV_KEY_REF_PRESENT) || (env->key_ref_len==1 && env->key_ref[0]==0x80);\n\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\"TCOS3:%d PKCS1:%d\\n\", tcos3,\n\t\t!!(env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tdata->pad_flags = env->algorithm_flags;\n\tdata->next_sign = default_key;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, tcos3 ? 0x41 : 0xC1, 0xB8);\n\tp = sbuf;\n\t*p++=0x80; *p++=0x01; *p++=tcos3 ? 0x0A : 0x10;\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT) {\n\t\t*p++ = (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC) ? 0x83 : 0x84;\n\t\t*p++ = env->key_ref_len;\n\t\tmemcpy(p, env->key_ref, env->key_ref_len);\n\t\tp += env->key_ref_len;\n\t}\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = (p - sbuf);\n\n\tr=sc_transmit_apdu(card, &apdu);\n\tif (r) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\treturn r;\n\t}\n\tif (apdu.sw1==0x6A && (apdu.sw2==0x81 || apdu.sw2==0x88)) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"Detected Signature-Only key\\n\");\n\t\tif (env->operation==SC_SEC_OPERATION_SIGN && default_key) return SC_SUCCESS;\n\t}\n\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\n\nstatic int tcos_restore_security_env(sc_card_t *card, int se_num)\n{\n\treturn 0;\n}\n\n\nstatic int tcos_compute_signature(sc_card_t *card, const u8 * data, size_t datalen, u8 * out, size_t outlen)\n{\n\tsize_t i, dlen=datalen;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint tcos3, r;\n\n\tassert(card != NULL && data != NULL && out != NULL);\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\n\tif (datalen > 255) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif(((tcos_data *)card->drv_data)->next_sign){\n\t\tif(datalen>48){\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Data to be signed is too long (TCOS supports max. 48 bytes)\\n\");\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t\t}\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x9E, 0x9A);\n\t\tmemcpy(sbuf, data, datalen);\n\t\tdlen=datalen;\n\t} else {\n\t\tint keylen= tcos3 ? 256 : 128;\n\t\tsc_format_apdu(card, &apdu, keylen>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A,0x80,0x86);\n\t\tfor(i=0; i<sizeof(sbuf);++i) sbuf[i]=0xff;\n\t\tsbuf[0]=0x02; sbuf[1]=0x00; sbuf[2]=0x01; sbuf[keylen-datalen]=0x00;\n\t\tmemcpy(sbuf+keylen-datalen+1, data, datalen);\n\t\tdlen=keylen+1;\n\t}\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = tcos3 ? 256 : 128;\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = dlen;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tif (tcos3 && apdu.p1==0x80 && apdu.sw1==0x6A && apdu.sw2==0x87) {\n\t\tint keylen=128;\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A,0x80,0x86);\n\t\tfor(i=0; i<sizeof(sbuf);++i) sbuf[i]=0xff;\n\t\tsbuf[0]=0x02; sbuf[1]=0x00; sbuf[2]=0x01; sbuf[keylen-datalen]=0x00;\n\t\tmemcpy(sbuf+keylen-datalen+1, data, datalen);\n\t\tdlen=keylen+1;\n\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 128;\n\t\tapdu.data = sbuf;\n\t\tapdu.lc = apdu.datalen = dlen;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t}\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len = apdu.resplen>outlen ? outlen : apdu.resplen;\n\t\tmemcpy(out, apdu.resp, len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\n\nstatic int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_NORMAL);\n\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2){\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\n\n/* Issue the SET PERMANENT command.  With ENABLE_NULLPIN set the\n   NullPIN method will be activated, otherwise the permanent operation\n   will be done on the active file. */\nstatic int tcos_setperm(sc_card_t *card, int enable_nullpin)\n{\n\tint r;\n\tsc_apdu_t apdu;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xEE, 0x00, 0x00);\n        apdu.cla |= 0x80;\n\tapdu.lc = 0;\n\tapdu.datalen = 0;\n\tapdu.data = NULL;\n\t\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n}\n\n\nstatic int tcos_get_serialnr(sc_card_t *card, sc_serial_number_t *serial)\n{\n\tint r;\n\n\tif (!serial)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\t/* see if we have cached serial number */\n\tif (card->serialnr.len) {\n\t\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\t\treturn SC_SUCCESS;\n\t}\n\n\tcard->serialnr.len = sizeof card->serialnr.value;\n\tr = sc_parse_ef_gdo(card, card->serialnr.value, &card->serialnr.len, NULL, 0);\n\tif (r < 0) {\n\t\tcard->serialnr.len = 0;\n\t\treturn r;\n\t}\n\n\t/* copy and return serial number */\n\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\n\treturn SC_SUCCESS;\n}\n\n\nstatic int tcos_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tswitch (cmd) {\n\tcase SC_CARDCTL_TCOS_SETPERM:\n\t\treturn tcos_setperm(card, !!ptr);\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\treturn tcos_get_serialnr(card, (sc_serial_number_t *)ptr);\n\t}\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n\n\nstruct sc_card_driver * sc_get_tcos_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (iso_ops == NULL) iso_ops = iso_drv->ops;\n\ttcos_ops = *iso_drv->ops;\n\n\ttcos_ops.match_card           = tcos_match_card;\n\ttcos_ops.init                 = tcos_init;\n\ttcos_ops.finish               = tcos_finish;\n\ttcos_ops.create_file          = tcos_create_file;\n\ttcos_ops.set_security_env     = tcos_set_security_env;\n\ttcos_ops.select_file          = tcos_select_file;\n\ttcos_ops.list_files           = tcos_list_files;\n\ttcos_ops.delete_file          = tcos_delete_file;\n\ttcos_ops.set_security_env     = tcos_set_security_env;\n\ttcos_ops.compute_signature    = tcos_compute_signature;\n\ttcos_ops.decipher             = tcos_decipher;\n\ttcos_ops.restore_security_env = tcos_restore_security_env;\n\ttcos_ops.card_ctl             = tcos_card_ctl;\n\t\n\treturn &tcos_drv;\n}\n", "/*\n * PKCS15 emulation layer for EstEID card.\n *\n * Copyright (C) 2004, Martin Paljak <martin@martinpaljak.net>\n * Copyright (C) 2004, Bud P. Bruegger <bud@comune.grosseto.it>\n * Copyright (C) 2004, Antonino Iacono <ant_iacono@tin.it>\n * Copyright (C) 2003, Olaf Kirch <okir@suse.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"common/compat_strlcpy.h\"\n#include \"common/compat_strlcat.h\"\n\n#include \"internal.h\"\n#include \"opensc.h\"\n#include \"pkcs15.h\"\n#include \"esteid.h\"\n\nint sc_pkcs15emu_esteid_init_ex(sc_pkcs15_card_t *, struct sc_aid *, sc_pkcs15emu_opt_t *);\n\nstatic void\nset_string (char **strp, const char *value)\n{\n\tif (*strp)\n\t\tfree (*strp);\n\t*strp = value ? strdup (value) : NULL;\n}\n\n\nint\nselect_esteid_df (sc_card_t * card)\n{\n\tint r;\n\tsc_path_t tmppath;\n\tsc_format_path (\"3F00EEEE\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"esteid select DF failed\");\n\treturn r;\n}\n\nstatic int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int esteid_detect_card(sc_pkcs15_card_t *p15card)\n{\n\tif (is_esteid_card(p15card->card))\n\t\treturn SC_SUCCESS;\n\telse\n\t\treturn SC_ERROR_WRONG_CARD;\n}\n\nint sc_pkcs15emu_esteid_init_ex(sc_pkcs15_card_t *p15card,\n\t\t\t\tstruct sc_aid *aid,\n\t\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\n\tif (opts && opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)\n\t\treturn sc_pkcs15emu_esteid_init(p15card);\n\telse {\n\t\tint r = esteid_detect_card(p15card);\n\t\tif (r)\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\treturn sc_pkcs15emu_esteid_init(p15card);\n\t}\n}\n", "/*\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n/* Initially written by David Mattes <david.mattes@boeing.com> */\n/* Support for multiple key containers by Lukas Wunner <lukas@wunner.de> */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"internal.h\"\n#include \"pkcs15.h\"\n\n#define MANU_ID\t\t\t\"Gemplus\"\n#define APPLET_NAME\t\t\"GemSAFE V1\"\n#define DRIVER_SERIAL_NUMBER\t\"v0.9\"\n#define GEMSAFE_APP_PATH\t\"3F001600\"\n#define GEMSAFE_PATH\t\t\"3F0016000004\"\n\n/* Apparently, the Applet max read \"quanta\" is 248 bytes\n * Gemalto ClassicClient reads files in chunks of 238 bytes\n */\n#define GEMSAFE_READ_QUANTUM    248\n#define GEMSAFE_MAX_OBJLEN      28672\n\nint sc_pkcs15emu_gemsafeV1_init_ex(sc_pkcs15_card_t *, struct sc_aid *,sc_pkcs15emu_opt_t *);\n\nstatic int\nsc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\tint type, int authority,\n\tconst sc_path_t *path,\n\tconst sc_pkcs15_id_t *id,\n\tconst char *label, int obj_flags);\n\nstatic int\nsc_pkcs15emu_add_pin(sc_pkcs15_card_t *p15card,\n\tconst sc_pkcs15_id_t *id, const char *label,\n\tconst sc_path_t *path, int ref, int type,\n\tunsigned int min_length,\n\tunsigned int max_length,\n\tint flags, int tries_left, const char pad_char, int obj_flags);\n\nstatic int\nsc_pkcs15emu_add_prkey(sc_pkcs15_card_t *p15card,\n\tconst sc_pkcs15_id_t *id,\n\tconst char *label,\n\tint type, unsigned int modulus_length, int usage,\n\tconst sc_path_t *path, int ref,\n\tconst sc_pkcs15_id_t *auth_id, int obj_flags);\n\ntypedef struct cdata_st {\n\tchar\t   *label;\n\tint\t    authority;\n\tconst char *path;\n\tsize_t\t    index;\n\tsize_t\t    count;\n\tconst char *id;\n\tint         obj_flags;\n} cdata;\n\nconst unsigned int gemsafe_cert_max = 12;\n\ncdata gemsafe_cert[] = {\n\t{\"DS certificate #1\",  0, GEMSAFE_PATH, 0, 0, \"45\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #2\",  0, GEMSAFE_PATH, 0, 0, \"46\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #3\",  0, GEMSAFE_PATH, 0, 0, \"47\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #4\",  0, GEMSAFE_PATH, 0, 0, \"48\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #5\",  0, GEMSAFE_PATH, 0, 0, \"49\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #6\",  0, GEMSAFE_PATH, 0, 0, \"50\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #7\",  0, GEMSAFE_PATH, 0, 0, \"51\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #8\",  0, GEMSAFE_PATH, 0, 0, \"52\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #9\",  0, GEMSAFE_PATH, 0, 0, \"53\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #10\", 0, GEMSAFE_PATH, 0, 0, \"54\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #11\", 0, GEMSAFE_PATH, 0, 0, \"55\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n\t{\"DS certificate #12\", 0, GEMSAFE_PATH, 0, 0, \"56\", SC_PKCS15_CO_FLAG_MODIFIABLE},\n};\n\ntypedef struct pdata_st {\n\tconst u8    atr[SC_MAX_ATR_SIZE];\n\tconst size_t atr_len;\n\tconst char *id;\n\tconst char *label;\n\tconst char *path;\n\tconst int   ref;\n\tconst int   type;\n\tconst unsigned int maxlen;\n\tconst unsigned int minlen;\n\tconst int   flags;\n\tconst int   tries_left;\n\tconst char  pad_char;\n\tconst int   obj_flags;\n} pindata;\n\nconst unsigned int gemsafe_pin_max = 2;\n\nconst pindata gemsafe_pin[] = {\n\t/* ATR-specific PIN policies, first match found is used: */\n\t{ {0x3B, 0x7D, 0x96, 0x00, 0x00, 0x80, 0x31, 0x80, 0x65,\n\t   0xB0, 0x83, 0x11, 0x48, 0xC8, 0x83, 0x00, 0x90, 0x00}, 18,\n\t  \"01\", \"DS pin\", GEMSAFE_PATH, 0x01, SC_PKCS15_PIN_TYPE_ASCII_NUMERIC,\n\t  8, 4, SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_LOCAL,\n\t  3, 0x00, SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE },\n\t/* default PIN policy comes last: */\n\t{ { 0 }, 0,\n\t  \"01\", \"DS pin\", GEMSAFE_PATH, 0x01, SC_PKCS15_PIN_TYPE_BCD,\n\t  16, 6, SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_LOCAL,\n\t  3, 0xFF, SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE }\n};\n\ntypedef struct prdata_st {\n\tconst char *id;\n\tchar\t   *label;\n\tunsigned int modulus_len;\n\tint         usage;\n\tconst char *path;\n\tint         ref;\n\tconst char *auth_id;\n\tint         obj_flags;\n} prdata;\n\n#define USAGE_NONREP\tSC_PKCS15_PRKEY_USAGE_NONREPUDIATION\n#define USAGE_KE\tSC_PKCS15_PRKEY_USAGE_ENCRYPT | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_DECRYPT | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_WRAP    | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_UNWRAP\n#define USAGE_AUT\tSC_PKCS15_PRKEY_USAGE_ENCRYPT | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_DECRYPT | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_WRAP    | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_UNWRAP  | \\\n\t\t\tSC_PKCS15_PRKEY_USAGE_SIGN\n\nprdata gemsafe_prkeys[] = {\n\t{ \"45\", \"DS key #1\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x03, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"46\", \"DS key #2\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x04, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"47\", \"DS key #3\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x05, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"48\", \"DS key #4\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x06, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"49\", \"DS key #5\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x07, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"50\", \"DS key #6\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x08, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"51\", \"DS key #7\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x09, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"52\", \"DS key #8\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x0a, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"53\", \"DS key #9\",  1024, USAGE_AUT, GEMSAFE_PATH, 0x0b, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"54\", \"DS key #10\", 1024, USAGE_AUT, GEMSAFE_PATH, 0x0c, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"55\", \"DS key #11\", 1024, USAGE_AUT, GEMSAFE_PATH, 0x0d, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n\t{ \"56\", \"DS key #12\", 1024, USAGE_AUT, GEMSAFE_PATH, 0x0e, \"01\", SC_PKCS15_CO_FLAG_PRIVATE},\n};\n\nstatic int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \"Could not read cert object\");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int gemsafe_detect_card( sc_pkcs15_card_t *p15card)\n{\n\tif (strcmp(p15card->card->name, \"GemSAFE V1\"))\n\t\treturn SC_ERROR_WRONG_CARD;\n\n\treturn SC_SUCCESS;\n}\n\nstatic int sc_pkcs15emu_gemsafeV1_init( sc_pkcs15_card_t *p15card)\n{\n\tint\t\t    r;\n\tunsigned int    i;\n\tstruct sc_path  path;\n\tstruct sc_file *file = NULL;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_apdu  apdu;\n\tu8\t\t    rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\n\tsc_log(p15card->card->ctx, \"Setting pkcs15 parameters\");\n\n\tif (p15card->tokeninfo->label)\n\t\tfree(p15card->tokeninfo->label);\n\tp15card->tokeninfo->label = malloc(strlen(APPLET_NAME) + 1);\n\tif (!p15card->tokeninfo->label)\n\t\treturn SC_ERROR_INTERNAL;\n\tstrcpy(p15card->tokeninfo->label, APPLET_NAME);\n\n\tif (p15card->tokeninfo->serial_number)\n\t\tfree(p15card->tokeninfo->serial_number);\n\tp15card->tokeninfo->serial_number = malloc(strlen(DRIVER_SERIAL_NUMBER) + 1);\n\tif (!p15card->tokeninfo->serial_number)\n\t\treturn SC_ERROR_INTERNAL;\n\tstrcpy(p15card->tokeninfo->serial_number, DRIVER_SERIAL_NUMBER);\n\n\t/* the GemSAFE applet version number */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0xdf, 0x03);\n\tapdu.cla = 0x80;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\t/* Manual says Le=0x05, but should be 0x08 to return full version number */\n\tapdu.le = 0x08;\n\tapdu.lc = 0;\n\tapdu.datalen = 0;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1 != 0x90 || apdu.sw2 != 0x00)\n\t\treturn SC_ERROR_INTERNAL;\n\tif (r != SC_SUCCESS)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* the manufacturer ID, in this case GemPlus */\n\tif (p15card->tokeninfo->manufacturer_id)\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\tp15card->tokeninfo->manufacturer_id = malloc(strlen(MANU_ID) + 1);\n\tif (!p15card->tokeninfo->manufacturer_id)\n\t\treturn SC_ERROR_INTERNAL;\n\tstrcpy(p15card->tokeninfo->manufacturer_id, MANU_ID);\n\n\t/* determine allocated key containers and length of certificates */\n\tr = gemsafe_get_cert_len(card);\n\tif (r != SC_SUCCESS)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* set certs */\n\tsc_log(p15card->card->ctx, \"Setting certificates\");\n\tfor (i = 0; i < gemsafe_cert_max; i++) {\n\t\tstruct sc_pkcs15_id p15Id;\n\t\tstruct sc_path path;\n\n\t\tif (gemsafe_cert[i].label == NULL)\n\t\t\tcontinue;\n\t\tsc_format_path(gemsafe_cert[i].path, &path);\n\t\tsc_pkcs15_format_id(gemsafe_cert[i].id, &p15Id);\n\t\tpath.index = gemsafe_cert[i].index;\n\t\tpath.count = gemsafe_cert[i].count;\n\t\tsc_pkcs15emu_add_cert(p15card, SC_PKCS15_TYPE_CERT_X509,\n\t\t\t\t      gemsafe_cert[i].authority, &path, &p15Id,\n\t\t\t\t      gemsafe_cert[i].label, gemsafe_cert[i].obj_flags);\n\t}\n\n\t/* set gemsafe_pin */\n\tsc_log(p15card->card->ctx, \"Setting PIN\");\n\tfor (i=0; i < gemsafe_pin_max; i++) {\n\t\tstruct sc_pkcs15_id\tp15Id;\n\t\tstruct sc_path path;\n\n\t\tsc_pkcs15_format_id(gemsafe_pin[i].id, &p15Id);\n\t\tsc_format_path(gemsafe_pin[i].path, &path);\n\t\tif (gemsafe_pin[i].atr_len == 0 ||\n\t\t   (gemsafe_pin[i].atr_len == p15card->card->atr.len &&\n\t\t    memcmp(p15card->card->atr.value, gemsafe_pin[i].atr,\n\t\t\t   p15card->card->atr.len) == 0)) {\n\t\t\tsc_pkcs15emu_add_pin(p15card, &p15Id, gemsafe_pin[i].label,\n\t\t\t\t\t     &path, gemsafe_pin[i].ref, gemsafe_pin[i].type,\n\t\t\t\t\t     gemsafe_pin[i].minlen, gemsafe_pin[i].maxlen,\n\t\t\t\t\t     gemsafe_pin[i].flags, gemsafe_pin[i].tries_left,\n\t\t\t\t\t     gemsafe_pin[i].pad_char, gemsafe_pin[i].obj_flags);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\t/* set private keys */\n\tsc_log(p15card->card->ctx, \"Setting private keys\");\n\tfor (i = 0; i < gemsafe_cert_max; i++) {\n\t\tstruct sc_pkcs15_id p15Id, authId, *pauthId;\n\t\tstruct sc_path path;\n\t\tint key_ref = 0x03;\n\n\t\tif (gemsafe_prkeys[i].label == NULL)\n\t\t\tcontinue;\n\t\tsc_pkcs15_format_id(gemsafe_prkeys[i].id, &p15Id);\n\t\tif (gemsafe_prkeys[i].auth_id) {\n\t\t\tsc_pkcs15_format_id(gemsafe_prkeys[i].auth_id, &authId);\n\t\t\tpauthId = &authId;\n\t\t} else\n\t\t\tpauthId = NULL;\n\t\tsc_format_path(gemsafe_prkeys[i].path, &path);\n\t\t/*\n\t\t * The key ref may be different for different sites;\n\t\t * by adding flags=n where the low order 4 bits can be\n\t\t * the key ref we can force it.\n\t\t */\n\t\tif ( p15card->card->flags & 0x0F) {\n\t\t\tkey_ref = p15card->card->flags & 0x0F;\n\t\t\tsc_debug(p15card->card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\t \"Overriding key_ref %d with %d\\n\",\n\t\t\t\t gemsafe_prkeys[i].ref, key_ref);\n\t\t} else\n\t\t\tkey_ref = gemsafe_prkeys[i].ref;\n\t\tsc_pkcs15emu_add_prkey(p15card, &p15Id, gemsafe_prkeys[i].label,\n\t\t\t\t       SC_PKCS15_TYPE_PRKEY_RSA,\n\t\t\t\t       gemsafe_prkeys[i].modulus_len, gemsafe_prkeys[i].usage,\n\t\t\t\t       &path, key_ref, pauthId,\n\t\t\t\t       gemsafe_prkeys[i].obj_flags);\n\t}\n\n\t/* select the application DF */\n\tsc_log(p15card->card->ctx, \"Selecting application DF\");\n\tsc_format_path(GEMSAFE_APP_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\t/* set the application DF */\n\tif (p15card->file_app)\n\t\tfree(p15card->file_app);\n\tp15card->file_app = file;\n\n\treturn SC_SUCCESS;\n}\n\nint sc_pkcs15emu_gemsafeV1_init_ex( sc_pkcs15_card_t *p15card,\n\t\t\tstruct sc_aid *aid,\n\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\tif (opts && opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)\n\t\treturn sc_pkcs15emu_gemsafeV1_init(p15card);\n\telse {\n\t\tint r = gemsafe_detect_card(p15card);\n\t\tif (r)\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\treturn sc_pkcs15emu_gemsafeV1_init(p15card);\n\t}\n}\n\nstatic sc_pkcs15_df_t *\nsc_pkcs15emu_get_df(sc_pkcs15_card_t *p15card, unsigned int type)\n{\n\tsc_pkcs15_df_t\t*df;\n\tsc_file_t\t*file;\n\tint\t\tcreated = 0;\n\n\twhile (1) {\n\t\tfor (df = p15card->df_list; df; df = df->next) {\n\t\t\tif (df->type == type) {\n\t\t\t\tif (created)\n\t\t\t\t\tdf->enumerated = 1;\n\t\t\t\treturn df;\n\t\t\t}\n\t\t}\n\n\t\tassert(created == 0);\n\n\t\tfile = sc_file_new();\n\t\tif (!file)\n\t\t\treturn NULL;\n\t\tsc_format_path(\"11001101\", &file->path);\n\t\tsc_pkcs15_add_df(p15card, type, &file->path);\n\t\tsc_file_free(file);\n\t\tcreated++;\n\t}\n}\n\nstatic int\nsc_pkcs15emu_add_object(sc_pkcs15_card_t *p15card, int type,\n\t\tconst char *label, void *data,\n\t\tconst sc_pkcs15_id_t *auth_id, int obj_flags)\n{\n\tsc_pkcs15_object_t *obj;\n\tint\t\tdf_type;\n\n\tobj = calloc(1, sizeof(*obj));\n\n\tobj->type  = type;\n\tobj->data  = data;\n\n\tif (label)\n\t\tstrncpy(obj->label, label, sizeof(obj->label)-1);\n\n\tobj->flags = obj_flags;\n\tif (auth_id)\n\t\tobj->auth_id = *auth_id;\n\n\tswitch (type & SC_PKCS15_TYPE_CLASS_MASK) {\n\tcase SC_PKCS15_TYPE_AUTH:\n\t\tdf_type = SC_PKCS15_AODF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY:\n\t\tdf_type = SC_PKCS15_PRKDF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PUBKEY:\n\t\tdf_type = SC_PKCS15_PUKDF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_CERT:\n\t\tdf_type = SC_PKCS15_CDF;\n\t\tbreak;\n\tdefault:\n\t\tsc_log(p15card->card->ctx, \"Unknown PKCS15 object type %d\", type);\n\t\tfree(obj);\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tobj->df = sc_pkcs15emu_get_df(p15card, df_type);\n\tsc_pkcs15_add_object(p15card, obj);\n\n\treturn 0;\n}\n\nstatic int\nsc_pkcs15emu_add_pin(sc_pkcs15_card_t *p15card,\n                const sc_pkcs15_id_t *id, const char *label,\n                const sc_path_t *path, int ref, int type,\n                unsigned int min_length,\n                unsigned int max_length,\n                int flags, int tries_left, const char pad_char, int obj_flags)\n{\n\tsc_pkcs15_auth_info_t *info;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tinfo->auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tinfo->auth_method = SC_AC_CHV;\n\tinfo->auth_id           = *id;\n\tinfo->attrs.pin.min_length        = min_length;\n\tinfo->attrs.pin.max_length        = max_length;\n\tinfo->attrs.pin.stored_length     = max_length;\n\tinfo->attrs.pin.type              = type;\n\tinfo->attrs.pin.reference         = ref;\n\tinfo->attrs.pin.flags             = flags;\n\tinfo->attrs.pin.pad_char          = pad_char;\n\tinfo->tries_left        = tries_left;\n\tinfo->logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tif (path)\n\t\tinfo->path = *path;\n\n\treturn sc_pkcs15emu_add_object(p15card, SC_PKCS15_TYPE_AUTH_PIN, label, info, NULL, obj_flags);\n}\n\nstatic int\nsc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\t\tint type, int authority,\n\t\tconst sc_path_t *path,\n\t\tconst sc_pkcs15_id_t *id,\n                const char *label, int obj_flags)\n{\n\tsc_pkcs15_cert_info_t *info;\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id\t\t= *id;\n\tinfo->authority\t\t= authority;\n\tif (path)\n\t\tinfo->path = *path;\n\n\treturn sc_pkcs15emu_add_object(p15card, type, label, info, NULL, obj_flags);\n}\n\nstatic int\nsc_pkcs15emu_add_prkey(sc_pkcs15_card_t *p15card,\n                const sc_pkcs15_id_t *id,\n                const char *label,\n                int type, unsigned int modulus_length, int usage,\n                const sc_path_t *path, int ref,\n                const sc_pkcs15_id_t *auth_id, int obj_flags)\n{\n\tsc_pkcs15_prkey_info_t *info;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id                = *id;\n\tinfo->modulus_length    = modulus_length;\n\tinfo->usage             = usage;\n\tinfo->native            = 1;\n\tinfo->access_flags      = SC_PKCS15_PRKEY_ACCESS_SENSITIVE\n                                | SC_PKCS15_PRKEY_ACCESS_ALWAYSSENSITIVE\n                                | SC_PKCS15_PRKEY_ACCESS_NEVEREXTRACTABLE\n                                | SC_PKCS15_PRKEY_ACCESS_LOCAL;\n\tinfo->key_reference     = ref;\n\n\tif (path)\n\t\tinfo->path = *path;\n\n\treturn sc_pkcs15emu_add_object(p15card, type, label,\n\t\t\tinfo, auth_id, obj_flags);\n}\n\n/* SC_IMPLEMENT_DRIVER_VERSION(\"0.9.4\") */\n", "/*\n * pkcs15-sc-hsm.c : Initialize PKCS#15 emulation\n *\n * Copyright (C) 2012 Andreas Schwier, CardContact, Minden, Germany\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"internal.h\"\n#include \"pkcs15.h\"\n#include \"asn1.h\"\n#include \"common/compat_strlcpy.h\"\n#include \"common/compat_strnlen.h\"\n\n#include \"card-sc-hsm.h\"\n\n\nextern struct sc_aid sc_hsm_aid;\n\n\nvoid sc_hsm_set_serialnr(sc_card_t *card, char *serial);\n\n\n\nstatic struct ec_curve curves[] = {\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2A\\x86\\x48\\xCE\\x3D\\x03\\x01\\x01\", 8},\t// secp192r1 aka prime192r1\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 24},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFC\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x64\\x21\\x05\\x19\\xE5\\x9C\\x80\\xE7\\x0F\\xA7\\xE9\\xAB\\x72\\x24\\x30\\x49\\xFE\\xB8\\xDE\\xEC\\xC1\\x46\\xB9\\xB1\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x18\\x8D\\xA8\\x0E\\xB0\\x30\\x90\\xF6\\x7C\\xBF\\x20\\xEB\\x43\\xA1\\x88\\x00\\xF4\\xFF\\x0A\\xFD\\x82\\xFF\\x10\\x12\\x07\\x19\\x2B\\x95\\xFF\\xC8\\xDA\\x78\\x63\\x10\\x11\\xED\\x6B\\x24\\xCD\\xD5\\x73\\xF9\\x77\\xA1\\x1E\\x79\\x48\\x11\", 49},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x99\\xDE\\xF8\\x36\\x14\\x6B\\xC9\\xB1\\xB4\\xD2\\x28\\x31\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2A\\x86\\x48\\xCE\\x3D\\x03\\x01\\x07\", 8},\t// secp256r1 aka prime256r1\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 32},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFC\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x5A\\xC6\\x35\\xD8\\xAA\\x3A\\x93\\xE7\\xB3\\xEB\\xBD\\x55\\x76\\x98\\x86\\xBC\\x65\\x1D\\x06\\xB0\\xCC\\x53\\xB0\\xF6\\x3B\\xCE\\x3C\\x3E\\x27\\xD2\\x60\\x4B\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x6B\\x17\\xD1\\xF2\\xE1\\x2C\\x42\\x47\\xF8\\xBC\\xE6\\xE5\\x63\\xA4\\x40\\xF2\\x77\\x03\\x7D\\x81\\x2D\\xEB\\x33\\xA0\\xF4\\xA1\\x39\\x45\\xD8\\x98\\xC2\\x96\\x4F\\xE3\\x42\\xE2\\xFE\\x1A\\x7F\\x9B\\x8E\\xE7\\xEB\\x4A\\x7C\\x0F\\x9E\\x16\\x2B\\xCE\\x33\\x57\\x6B\\x31\\x5E\\xCE\\xCB\\xB6\\x40\\x68\\x37\\xBF\\x51\\xF5\", 65},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xBC\\xE6\\xFA\\xAD\\xA7\\x17\\x9E\\x84\\xF3\\xB9\\xCA\\xC2\\xFC\\x63\\x25\\x51\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x24\\x03\\x03\\x02\\x08\\x01\\x01\\x03\", 9},\t// brainpoolP192r1\n\t\t\t\t{ (unsigned char *) \"\\xC3\\x02\\xF4\\x1D\\x93\\x2A\\x36\\xCD\\xA7\\xA3\\x46\\x30\\x93\\xD1\\x8D\\xB7\\x8F\\xCE\\x47\\x6D\\xE1\\xA8\\x62\\x97\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x6A\\x91\\x17\\x40\\x76\\xB1\\xE0\\xE1\\x9C\\x39\\xC0\\x31\\xFE\\x86\\x85\\xC1\\xCA\\xE0\\x40\\xE5\\xC6\\x9A\\x28\\xEF\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x46\\x9A\\x28\\xEF\\x7C\\x28\\xCC\\xA3\\xDC\\x72\\x1D\\x04\\x4F\\x44\\x96\\xBC\\xCA\\x7E\\xF4\\x14\\x6F\\xBF\\x25\\xC9\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x04\\xC0\\xA0\\x64\\x7E\\xAA\\xB6\\xA4\\x87\\x53\\xB0\\x33\\xC5\\x6C\\xB0\\xF0\\x90\\x0A\\x2F\\x5C\\x48\\x53\\x37\\x5F\\xD6\\x14\\xB6\\x90\\x86\\x6A\\xBD\\x5B\\xB8\\x8B\\x5F\\x48\\x28\\xC1\\x49\\x00\\x02\\xE6\\x77\\x3F\\xA2\\xFA\\x29\\x9B\\x8F\", 49},\n\t\t\t\t{ (unsigned char *) \"\\xC3\\x02\\xF4\\x1D\\x93\\x2A\\x36\\xCD\\xA7\\xA3\\x46\\x2F\\x9E\\x9E\\x91\\x6B\\x5B\\xE8\\xF1\\x02\\x9A\\xC4\\xAC\\xC1\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x24\\x03\\x03\\x02\\x08\\x01\\x01\\x05\", 9},\t// brainpoolP224r1\n\t\t\t\t{ (unsigned char *) \"\\xD7\\xC1\\x34\\xAA\\x26\\x43\\x66\\x86\\x2A\\x18\\x30\\x25\\x75\\xD1\\xD7\\x87\\xB0\\x9F\\x07\\x57\\x97\\xDA\\x89\\xF5\\x7E\\xC8\\xC0\\xFF\", 28},\n\t\t\t\t{ (unsigned char *) \"\\x68\\xA5\\xE6\\x2C\\xA9\\xCE\\x6C\\x1C\\x29\\x98\\x03\\xA6\\xC1\\x53\\x0B\\x51\\x4E\\x18\\x2A\\xD8\\xB0\\x04\\x2A\\x59\\xCA\\xD2\\x9F\\x43\", 28},\n\t\t\t\t{ (unsigned char *) \"\\x25\\x80\\xF6\\x3C\\xCF\\xE4\\x41\\x38\\x87\\x07\\x13\\xB1\\xA9\\x23\\x69\\xE3\\x3E\\x21\\x35\\xD2\\x66\\xDB\\xB3\\x72\\x38\\x6C\\x40\\x0B\", 28},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x0D\\x90\\x29\\xAD\\x2C\\x7E\\x5C\\xF4\\x34\\x08\\x23\\xB2\\xA8\\x7D\\xC6\\x8C\\x9E\\x4C\\xE3\\x17\\x4C\\x1E\\x6E\\xFD\\xEE\\x12\\xC0\\x7D\\x58\\xAA\\x56\\xF7\\x72\\xC0\\x72\\x6F\\x24\\xC6\\xB8\\x9E\\x4E\\xCD\\xAC\\x24\\x35\\x4B\\x9E\\x99\\xCA\\xA3\\xF6\\xD3\\x76\\x14\\x02\\xCD\", 57},\n\t\t\t\t{ (unsigned char *) \"\\xD7\\xC1\\x34\\xAA\\x26\\x43\\x66\\x86\\x2A\\x18\\x30\\x25\\x75\\xD0\\xFB\\x98\\xD1\\x16\\xBC\\x4B\\x6D\\xDE\\xBC\\xA3\\xA5\\xA7\\x93\\x9F\", 28},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x24\\x03\\x03\\x02\\x08\\x01\\x01\\x07\", 9},\t// brainpoolP256r1\n\t\t\t\t{ (unsigned char *) \"\\xA9\\xFB\\x57\\xDB\\xA1\\xEE\\xA9\\xBC\\x3E\\x66\\x0A\\x90\\x9D\\x83\\x8D\\x72\\x6E\\x3B\\xF6\\x23\\xD5\\x26\\x20\\x28\\x20\\x13\\x48\\x1D\\x1F\\x6E\\x53\\x77\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x7D\\x5A\\x09\\x75\\xFC\\x2C\\x30\\x57\\xEE\\xF6\\x75\\x30\\x41\\x7A\\xFF\\xE7\\xFB\\x80\\x55\\xC1\\x26\\xDC\\x5C\\x6C\\xE9\\x4A\\x4B\\x44\\xF3\\x30\\xB5\\xD9\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x26\\xDC\\x5C\\x6C\\xE9\\x4A\\x4B\\x44\\xF3\\x30\\xB5\\xD9\\xBB\\xD7\\x7C\\xBF\\x95\\x84\\x16\\x29\\x5C\\xF7\\xE1\\xCE\\x6B\\xCC\\xDC\\x18\\xFF\\x8C\\x07\\xB6\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x8B\\xD2\\xAE\\xB9\\xCB\\x7E\\x57\\xCB\\x2C\\x4B\\x48\\x2F\\xFC\\x81\\xB7\\xAF\\xB9\\xDE\\x27\\xE1\\xE3\\xBD\\x23\\xC2\\x3A\\x44\\x53\\xBD\\x9A\\xCE\\x32\\x62\\x54\\x7E\\xF8\\x35\\xC3\\xDA\\xC4\\xFD\\x97\\xF8\\x46\\x1A\\x14\\x61\\x1D\\xC9\\xC2\\x77\\x45\\x13\\x2D\\xED\\x8E\\x54\\x5C\\x1D\\x54\\xC7\\x2F\\x04\\x69\\x97\", 65},\n\t\t\t\t{ (unsigned char *) \"\\xA9\\xFB\\x57\\xDB\\xA1\\xEE\\xA9\\xBC\\x3E\\x66\\x0A\\x90\\x9D\\x83\\x8D\\x71\\x8C\\x39\\x7A\\xA3\\xB5\\x61\\xA6\\xF7\\x90\\x1E\\x0E\\x82\\x97\\x48\\x56\\xA7\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x24\\x03\\x03\\x02\\x08\\x01\\x01\\x09\", 9},\t// brainpoolP320r1\n\t\t\t\t{ (unsigned char *) \"\\xD3\\x5E\\x47\\x20\\x36\\xBC\\x4F\\xB7\\xE1\\x3C\\x78\\x5E\\xD2\\x01\\xE0\\x65\\xF9\\x8F\\xCF\\xA6\\xF6\\xF4\\x0D\\xEF\\x4F\\x92\\xB9\\xEC\\x78\\x93\\xEC\\x28\\xFC\\xD4\\x12\\xB1\\xF1\\xB3\\x2E\\x27\", 40},\n\t\t\t\t{ (unsigned char *) \"\\x3E\\xE3\\x0B\\x56\\x8F\\xBA\\xB0\\xF8\\x83\\xCC\\xEB\\xD4\\x6D\\x3F\\x3B\\xB8\\xA2\\xA7\\x35\\x13\\xF5\\xEB\\x79\\xDA\\x66\\x19\\x0E\\xB0\\x85\\xFF\\xA9\\xF4\\x92\\xF3\\x75\\xA9\\x7D\\x86\\x0E\\xB4\", 40},\n\t\t\t\t{ (unsigned char *) \"\\x52\\x08\\x83\\x94\\x9D\\xFD\\xBC\\x42\\xD3\\xAD\\x19\\x86\\x40\\x68\\x8A\\x6F\\xE1\\x3F\\x41\\x34\\x95\\x54\\xB4\\x9A\\xCC\\x31\\xDC\\xCD\\x88\\x45\\x39\\x81\\x6F\\x5E\\xB4\\xAC\\x8F\\xB1\\xF1\\xA6\", 40},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x43\\xBD\\x7E\\x9A\\xFB\\x53\\xD8\\xB8\\x52\\x89\\xBC\\xC4\\x8E\\xE5\\xBF\\xE6\\xF2\\x01\\x37\\xD1\\x0A\\x08\\x7E\\xB6\\xE7\\x87\\x1E\\x2A\\x10\\xA5\\x99\\xC7\\x10\\xAF\\x8D\\x0D\\x39\\xE2\\x06\\x11\\x14\\xFD\\xD0\\x55\\x45\\xEC\\x1C\\xC8\\xAB\\x40\\x93\\x24\\x7F\\x77\\x27\\x5E\\x07\\x43\\xFF\\xED\\x11\\x71\\x82\\xEA\\xA9\\xC7\\x78\\x77\\xAA\\xAC\\x6A\\xC7\\xD3\\x52\\x45\\xD1\\x69\\x2E\\x8E\\xE1\", 81},\n\t\t\t\t{ (unsigned char *) \"\\xD3\\x5E\\x47\\x20\\x36\\xBC\\x4F\\xB7\\xE1\\x3C\\x78\\x5E\\xD2\\x01\\xE0\\x65\\xF9\\x8F\\xCF\\xA5\\xB6\\x8F\\x12\\xA3\\x2D\\x48\\x2E\\xC7\\xEE\\x86\\x58\\xE9\\x86\\x91\\x55\\x5B\\x44\\xC5\\x93\\x11\", 40},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x81\\x04\\x00\\x1F\", 5},\t// secp192k1\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xFF\\xFF\\xEE\\x37\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x04\\xDB\\x4F\\xF1\\x0E\\xC0\\x57\\xE9\\xAE\\x26\\xB0\\x7D\\x02\\x80\\xB7\\xF4\\x34\\x1D\\xA5\\xD1\\xB1\\xEA\\xE0\\x6C\\x7D\\x9B\\x2F\\x2F\\x6D\\x9C\\x56\\x28\\xA7\\x84\\x41\\x63\\xD0\\x15\\xBE\\x86\\x34\\x40\\x82\\xAA\\x88\\xD9\\x5E\\x2F\\x9D\", 49},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\x26\\xF2\\xFC\\x17\\x0F\\x69\\x46\\x6A\\x74\\xDE\\xFD\\x8D\", 24},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ (unsigned char *) \"\\x2B\\x81\\x04\\x00\\x0A\", 5},\t// secp256k1\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xFF\\xFF\\xFC\\x2F\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x04\\x79\\xBE\\x66\\x7E\\xF9\\xDC\\xBB\\xAC\\x55\\xA0\\x62\\x95\\xCE\\x87\\x0B\\x07\\x02\\x9B\\xFC\\xDB\\x2D\\xCE\\x28\\xD9\\x59\\xF2\\x81\\x5B\\x16\\xF8\\x17\\x98\\x48\\x3A\\xDA\\x77\\x26\\xA3\\xC4\\x65\\x5D\\xA4\\xFB\\xFC\\x0E\\x11\\x08\\xA8\\xFD\\x17\\xB4\\x48\\xA6\\x85\\x54\\x19\\x9C\\x47\\xD0\\x8F\\xFB\\x10\\xD4\\xB8\", 65},\n\t\t\t\t{ (unsigned char *) \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\\xBA\\xAE\\xDC\\xE6\\xAF\\x48\\xA0\\x3B\\xBF\\xD2\\x5E\\x8C\\xD0\\x36\\x41\\x41\", 32},\n\t\t\t\t{ (unsigned char *) \"\\x01\", 1}\n\t\t},\n\t\t{\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0},\n\t\t\t\t{ NULL, 0}\n\t\t}\n};\n\n\n\n#define C_ASN1_CVC_PUBKEY_SIZE 10\nstatic const struct sc_asn1_entry c_asn1_cvc_pubkey[C_ASN1_CVC_PUBKEY_SIZE] = {\n\t{ \"publicKeyOID\", SC_ASN1_OBJECT, SC_ASN1_UNI | SC_ASN1_OBJECT, 0, NULL, NULL },\n\t{ \"primeOrModulus\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 1, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"coefficientAorExponent\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 2,  SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"coefficientB\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 3, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"basePointG\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 4, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"order\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 5, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"publicPoint\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 6, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"cofactor\", SC_ASN1_OCTET_STRING, SC_ASN1_CTX | 7, SC_ASN1_OPTIONAL | SC_ASN1_ALLOC, NULL, NULL },\n\t{ \"modulusSize\", SC_ASN1_INTEGER, SC_ASN1_UNI | SC_ASN1_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_CVC_BODY_SIZE 5\nstatic const struct sc_asn1_entry c_asn1_cvc_body[C_ASN1_CVC_BODY_SIZE] = {\n\t{ \"certificateProfileIdentifier\", SC_ASN1_INTEGER, SC_ASN1_APP | 0x1F29, 0, NULL, NULL },\n\t{ \"certificationAuthorityReference\", SC_ASN1_PRINTABLESTRING, SC_ASN1_APP | 2, 0, NULL, NULL },\n\t{ \"publicKey\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 0x1F49, 0, NULL, NULL },\n\t{ \"certificateHolderReference\", SC_ASN1_PRINTABLESTRING, SC_ASN1_APP | 0x1F20, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_CVCERT_SIZE 3\nstatic const struct sc_asn1_entry c_asn1_cvcert[C_ASN1_CVCERT_SIZE] = {\n\t{ \"certificateBody\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 0x1F4E, 0, NULL, NULL },\n\t{ \"signature\", SC_ASN1_OCTET_STRING, SC_ASN1_APP | 0x1F37, SC_ASN1_ALLOC, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_CVC_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_cvc[C_ASN1_CVC_SIZE] = {\n\t{ \"certificate\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 0x1F21, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_AUTHREQ_SIZE 4\nstatic const struct sc_asn1_entry c_asn1_authreq[C_ASN1_AUTHREQ_SIZE] = {\n\t{ \"certificate\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 0x1F21, 0, NULL, NULL },\n\t{ \"outerCAR\", SC_ASN1_PRINTABLESTRING, SC_ASN1_APP | 2, 0, NULL, NULL },\n\t{ \"signature\", SC_ASN1_OCTET_STRING, SC_ASN1_APP | 0x1F37, SC_ASN1_ALLOC, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_REQ_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_req[C_ASN1_REQ_SIZE] = {\n\t{ \"authenticatedrequest\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_APP | 7, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n\n\nstatic int read_file(sc_pkcs15_card_t * p15card, u8 fid[2],\n\t\tu8 *efbin, size_t *len, int optional)\n{\n\tsc_path_t path;\n\tint r;\n\n\tsc_path_set(&path, SC_PATH_TYPE_FILE_ID, fid, 2, 0, 0);\n\t/* look this up with our AID */\n\tpath.aid = sc_hsm_aid;\n\t/* we don't have a pre-known size of the file */\n\tpath.count = -1;\n\tif (!p15card->opts.use_file_cache || !efbin\n\t\t\t|| SC_SUCCESS != sc_pkcs15_read_cached_file(p15card, &path, &efbin, len)) {\n\t\t/* avoid re-selection of SC-HSM */\n\t\tpath.aid.len = 0;\n\t\tr = sc_select_file(p15card->card, &path, NULL);\n\t\tif (r < 0) {\n\t\t\tsc_log(p15card->card->ctx, \"Could not select EF\");\n\t\t} else {\n\t\t\tr = sc_read_binary(p15card->card, 0, efbin, *len, 0);\n\t\t}\n\n\t\tif (r < 0) {\n\t\t\tsc_log(p15card->card->ctx, \"Could not read EF\");\n\t\t\tif (!optional) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\t/* optional files are saved as empty files to avoid card\n\t\t\t * transactions. Parsing the file's data will reveal that they were\n\t\t\t * missing. */\n\t\t\t*len = 0;\n\t\t} else {\n\t\t\t*len = r;\n\t\t}\n\n\t\tif (p15card->opts.use_file_cache) {\n\t\t\t/* save this with our AID */\n\t\t\tpath.aid = sc_hsm_aid;\n\t\t\tsc_pkcs15_cache_file(p15card, &path, efbin, *len);\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}\n\n\n\n/*\n * Decode a card verifiable certificate as defined in TR-03110.\n */\nint sc_pkcs15emu_sc_hsm_decode_cvc(sc_pkcs15_card_t * p15card,\n\t\t\t\t\t\t\t\t\t\t\tconst u8 ** buf, size_t *buflen,\n\t\t\t\t\t\t\t\t\t\t\tsc_cvc_t *cvc)\n{\n\tsc_card_t *card = p15card->card;\n\tstruct sc_asn1_entry asn1_req[C_ASN1_REQ_SIZE];\n\tstruct sc_asn1_entry asn1_authreq[C_ASN1_AUTHREQ_SIZE];\n\tstruct sc_asn1_entry asn1_cvc[C_ASN1_CVC_SIZE];\n\tstruct sc_asn1_entry asn1_cvcert[C_ASN1_CVCERT_SIZE];\n\tstruct sc_asn1_entry asn1_cvc_body[C_ASN1_CVC_BODY_SIZE];\n\tstruct sc_asn1_entry asn1_cvc_pubkey[C_ASN1_CVC_PUBKEY_SIZE];\n\tunsigned int cla,tag;\n\tsize_t taglen;\n\tsize_t lenchr = sizeof(cvc->chr);\n\tsize_t lencar = sizeof(cvc->car);\n\tsize_t lenoutercar = sizeof(cvc->outer_car);\n\tconst u8 *tbuf;\n\tint r;\n\n\tmemset(cvc, 0, sizeof(*cvc));\n\tsc_copy_asn1_entry(c_asn1_req, asn1_req);\n\tsc_copy_asn1_entry(c_asn1_authreq, asn1_authreq);\n\tsc_copy_asn1_entry(c_asn1_cvc, asn1_cvc);\n\tsc_copy_asn1_entry(c_asn1_cvcert, asn1_cvcert);\n\tsc_copy_asn1_entry(c_asn1_cvc_body, asn1_cvc_body);\n\tsc_copy_asn1_entry(c_asn1_cvc_pubkey, asn1_cvc_pubkey);\n\n\tsc_format_asn1_entry(asn1_cvc_pubkey    , &cvc->pukoid, NULL, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 1, &cvc->primeOrModulus, &cvc->primeOrModuluslen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 2, &cvc->coefficientAorExponent, &cvc->coefficientAorExponentlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 3, &cvc->coefficientB, &cvc->coefficientBlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 4, &cvc->basePointG, &cvc->basePointGlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 5, &cvc->order, &cvc->orderlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 6, &cvc->publicPoint, &cvc->publicPointlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 7, &cvc->cofactor, &cvc->cofactorlen, 0);\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 8, &cvc->modulusSize, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_cvc_body    , &cvc->cpi, NULL, 0);\n\tsc_format_asn1_entry(asn1_cvc_body + 1, &cvc->car, &lencar, 0);\n\tsc_format_asn1_entry(asn1_cvc_body + 2, &asn1_cvc_pubkey, NULL, 0);\n\tsc_format_asn1_entry(asn1_cvc_body + 3, &cvc->chr, &lenchr, 0);\n\n\tsc_format_asn1_entry(asn1_cvcert    , &asn1_cvc_body, NULL, 0);\n\tsc_format_asn1_entry(asn1_cvcert + 1, &cvc->signature, &cvc->signatureLen, 0);\n\n\tsc_format_asn1_entry(asn1_cvc , &asn1_cvcert, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_authreq    , &asn1_cvcert, NULL, 0);\n\tsc_format_asn1_entry(asn1_authreq + 1, &cvc->outer_car, &lenoutercar, 0);\n\tsc_format_asn1_entry(asn1_authreq + 2, &cvc->outerSignature, &cvc->outerSignatureLen, 0);\n\n\tsc_format_asn1_entry(asn1_req , &asn1_authreq, NULL, 0);\n\n/*\tsc_asn1_print_tags(*buf, *buflen); */\n\n\ttbuf = *buf;\n\tr = sc_asn1_read_tag(&tbuf, *buflen, &cla, &tag, &taglen);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode card verifiable certificate\");\n\n\t/*  Determine if we deal with an authenticated request, plain request or certificate */\n\tif ((cla == (SC_ASN1_TAG_APPLICATION|SC_ASN1_TAG_CONSTRUCTED)) && (tag == 7)) {\n\t\tr = sc_asn1_decode(card->ctx, asn1_req, *buf, *buflen, buf, buflen);\n\t} else {\n\t\tr = sc_asn1_decode(card->ctx, asn1_cvc, *buf, *buflen, buf, buflen);\n\t}\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode card verifiable certificate\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\n\n/*\n * Encode a card verifiable certificate as defined in TR-03110.\n */\nint sc_pkcs15emu_sc_hsm_encode_cvc(sc_pkcs15_card_t * p15card,\n\t\tsc_cvc_t *cvc,\n\t\tu8 ** buf, size_t *buflen)\n{\n\tsc_card_t *card = p15card->card;\n\tstruct sc_asn1_entry asn1_cvc[C_ASN1_CVC_SIZE];\n\tstruct sc_asn1_entry asn1_cvcert[C_ASN1_CVCERT_SIZE];\n\tstruct sc_asn1_entry asn1_cvc_body[C_ASN1_CVC_BODY_SIZE];\n\tstruct sc_asn1_entry asn1_cvc_pubkey[C_ASN1_CVC_PUBKEY_SIZE];\n\tsize_t lenchr;\n\tsize_t lencar;\n\tint r;\n\n\tsc_copy_asn1_entry(c_asn1_cvc, asn1_cvc);\n\tsc_copy_asn1_entry(c_asn1_cvcert, asn1_cvcert);\n\tsc_copy_asn1_entry(c_asn1_cvc_body, asn1_cvc_body);\n\tsc_copy_asn1_entry(c_asn1_cvc_pubkey, asn1_cvc_pubkey);\n\n\tasn1_cvc_pubkey[1].flags = SC_ASN1_OPTIONAL;\n\tasn1_cvcert[1].flags = SC_ASN1_OPTIONAL;\n\n\tsc_format_asn1_entry(asn1_cvc_pubkey    , &cvc->pukoid, NULL, 1);\n\tif (cvc->primeOrModulus && (cvc->primeOrModuluslen > 0)) {\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 1, cvc->primeOrModulus, &cvc->primeOrModuluslen, 1);\n\t}\n\tsc_format_asn1_entry(asn1_cvc_pubkey + 2, cvc->coefficientAorExponent, &cvc->coefficientAorExponentlen, 1);\n\tif (cvc->coefficientB && (cvc->coefficientBlen > 0)) {\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 3, cvc->coefficientB, &cvc->coefficientBlen, 1);\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 4, cvc->basePointG, &cvc->basePointGlen, 1);\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 5, cvc->order, &cvc->orderlen, 1);\n\t\tif (cvc->publicPoint && (cvc->publicPointlen > 0)) {\n\t\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 6, cvc->publicPoint, &cvc->publicPointlen, 1);\n\t\t}\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 7, cvc->cofactor, &cvc->cofactorlen, 1);\n\t}\n\tif (cvc->modulusSize > 0) {\n\t\tsc_format_asn1_entry(asn1_cvc_pubkey + 8, &cvc->modulusSize, NULL, 1);\n\t}\n\n\tsc_format_asn1_entry(asn1_cvc_body    , &cvc->cpi, NULL, 1);\n\tlencar = strnlen(cvc->car, sizeof cvc->car);\n\tsc_format_asn1_entry(asn1_cvc_body + 1, &cvc->car, &lencar, 1);\n\tsc_format_asn1_entry(asn1_cvc_body + 2, &asn1_cvc_pubkey, NULL, 1);\n\tlenchr = strnlen(cvc->chr, sizeof cvc->chr);\n\tsc_format_asn1_entry(asn1_cvc_body + 3, &cvc->chr, &lenchr, 1);\n\n\tsc_format_asn1_entry(asn1_cvcert    , &asn1_cvc_body, NULL, 1);\n\tif (cvc->signature && (cvc->signatureLen > 0)) {\n\t\tsc_format_asn1_entry(asn1_cvcert + 1, cvc->signature, &cvc->signatureLen, 1);\n\t}\n\n\tsc_format_asn1_entry(asn1_cvc , &asn1_cvcert, NULL, 1);\n\n\tr = sc_asn1_encode(card->ctx, asn1_cvc, buf, buflen);\n\tLOG_TEST_RET(card->ctx, r, \"Could not encode card verifiable certificate\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\n\nint sc_pkcs15emu_sc_hsm_get_curve(struct ec_curve **curve, u8 *oid, size_t oidlen)\n{\n\tint i;\n\n\tfor (i = 0; curves[i].oid.value; i++) {\n\t\tif ((curves[i].oid.len == oidlen) && !memcmp(curves[i].oid.value, oid, oidlen)) {\n\t\t\t*curve = &curves[i];\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_INVALID_DATA;\n}\n\n\n\nint sc_pkcs15emu_sc_hsm_get_curve_oid(sc_cvc_t *cvc, const struct sc_lv_data **oid)\n{\n\tint i;\n\n\tfor (i = 0; curves[i].oid.value; i++) {\n\t\tif ((curves[i].prime.len == cvc->primeOrModuluslen) && !memcmp(curves[i].prime.value, cvc->primeOrModulus, cvc->primeOrModuluslen)) {\n\t\t\t*oid = &curves[i].oid;\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_INVALID_DATA;\n}\n\n\n\nstatic int sc_pkcs15emu_sc_hsm_get_rsa_public_key(struct sc_context *ctx, sc_cvc_t *cvc, struct sc_pkcs15_pubkey *pubkey)\n{\n\tpubkey->algorithm = SC_ALGORITHM_RSA;\n\n\tpubkey->alg_id = (struct sc_algorithm_id *)calloc(1, sizeof(struct sc_algorithm_id));\n\tif (!pubkey->alg_id)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tpubkey->alg_id->algorithm = SC_ALGORITHM_RSA;\n\n\tpubkey->u.rsa.modulus.len\t= cvc->primeOrModuluslen;\n\tpubkey->u.rsa.modulus.data\t= malloc(pubkey->u.rsa.modulus.len);\n\tpubkey->u.rsa.exponent.len\t= cvc->coefficientAorExponentlen;\n\tpubkey->u.rsa.exponent.data\t= malloc(pubkey->u.rsa.exponent.len);\n\tif (!pubkey->u.rsa.modulus.data || !pubkey->u.rsa.exponent.data)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tmemcpy(pubkey->u.rsa.exponent.data, cvc->coefficientAorExponent, pubkey->u.rsa.exponent.len);\n\tmemcpy(pubkey->u.rsa.modulus.data, cvc->primeOrModulus, pubkey->u.rsa.modulus.len);\n\n\treturn SC_SUCCESS;\n}\n\n\n\nstatic int sc_pkcs15emu_sc_hsm_get_ec_public_key(struct sc_context *ctx, sc_cvc_t *cvc, struct sc_pkcs15_pubkey *pubkey)\n{\n\tstruct sc_ec_parameters *ecp;\n\tconst struct sc_lv_data *oid;\n\tint r;\n\n\tpubkey->algorithm = SC_ALGORITHM_EC;\n\n\tr = sc_pkcs15emu_sc_hsm_get_curve_oid(cvc, &oid);\n\tif (r != SC_SUCCESS)\n\t\treturn r;\n\n\tecp = calloc(1, sizeof(struct sc_ec_parameters));\n\tif (!ecp)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tecp->der.len = oid->len + 2;\n\tecp->der.value = calloc(ecp->der.len, 1);\n\tif (!ecp->der.value) {\n\t\tfree(ecp);\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\t*(ecp->der.value + 0) = 0x06;\n\t*(ecp->der.value + 1) = (u8)oid->len;\n\tmemcpy(ecp->der.value + 2, oid->value, oid->len);\n\tecp->type = 1;\t\t// Named curve\n\n\tpubkey->alg_id = (struct sc_algorithm_id *)calloc(1, sizeof(struct sc_algorithm_id));\n\tif (!pubkey->alg_id) {\n\t\tfree(ecp->der.value);\n\t\tfree(ecp);\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\tpubkey->alg_id->algorithm = SC_ALGORITHM_EC;\n\tpubkey->alg_id->params = ecp;\n\n\tpubkey->u.ec.ecpointQ.value = malloc(cvc->publicPointlen);\n\tif (!pubkey->u.ec.ecpointQ.value)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\tmemcpy(pubkey->u.ec.ecpointQ.value, cvc->publicPoint, cvc->publicPointlen);\n\tpubkey->u.ec.ecpointQ.len = cvc->publicPointlen;\n\n\tpubkey->u.ec.params.der.value = malloc(ecp->der.len);\n\tif (!pubkey->u.ec.params.der.value)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\tmemcpy(pubkey->u.ec.params.der.value, ecp->der.value, ecp->der.len);\n\tpubkey->u.ec.params.der.len = ecp->der.len;\n\n\t/* FIXME: check return value? */\n\tsc_pkcs15_fix_ec_parameters(ctx, &pubkey->u.ec.params);\n\n\treturn SC_SUCCESS;\n}\n\n\n\nint sc_pkcs15emu_sc_hsm_get_public_key(struct sc_context *ctx, sc_cvc_t *cvc, struct sc_pkcs15_pubkey *pubkey)\n{\n\tif (cvc->publicPoint && cvc->publicPointlen) {\n\t\treturn sc_pkcs15emu_sc_hsm_get_ec_public_key(ctx, cvc, pubkey);\n\t} else {\n\t\treturn sc_pkcs15emu_sc_hsm_get_rsa_public_key(ctx, cvc, pubkey);\n\t}\n}\n\n\n\nvoid sc_pkcs15emu_sc_hsm_free_cvc(sc_cvc_t *cvc)\n{\n\tif (cvc->signature) {\n\t\tfree(cvc->signature);\n\t\tcvc->signature = NULL;\n\t}\n\tif (cvc->primeOrModulus) {\n\t\tfree(cvc->primeOrModulus);\n\t\tcvc->primeOrModulus = NULL;\n\t}\n\tif (cvc->coefficientAorExponent) {\n\t\tfree(cvc->coefficientAorExponent);\n\t\tcvc->coefficientAorExponent = NULL;\n\t}\n\tif (cvc->coefficientB) {\n\t\tfree(cvc->coefficientB);\n\t\tcvc->coefficientB = NULL;\n\t}\n\tif (cvc->basePointG) {\n\t\tfree(cvc->basePointG);\n\t\tcvc->basePointG = NULL;\n\t}\n\tif (cvc->order) {\n\t\tfree(cvc->order);\n\t\tcvc->order = NULL;\n\t}\n\tif (cvc->publicPoint) {\n\t\tfree(cvc->publicPoint);\n\t\tcvc->publicPoint = NULL;\n\t}\n\tif (cvc->cofactor) {\n\t\tfree(cvc->cofactor);\n\t\tcvc->cofactor = NULL;\n\t}\n}\n\n\n\nstatic int sc_pkcs15emu_sc_hsm_add_pubkey(sc_pkcs15_card_t *p15card, u8 *efbin, size_t len, sc_pkcs15_prkey_info_t *key_info, char *label)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_pubkey_info_t pubkey_info;\n\tsc_pkcs15_object_t pubkey_obj;\n\tstruct sc_pkcs15_pubkey pubkey;\n\tsc_cvc_t cvc;\n\tu8 *cvcpo;\n\tint r;\n\n\tcvcpo = efbin;\n\n\tmemset(&cvc, 0, sizeof(cvc));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&cvcpo, &len, &cvc);\n\tLOG_TEST_RET(ctx, r, \"Could decode certificate signing request\");\n\n\tmemset(&pubkey, 0, sizeof(pubkey));\n\tr = sc_pkcs15emu_sc_hsm_get_public_key(ctx, &cvc, &pubkey);\n\tLOG_TEST_RET(card->ctx, r, \"Could not extract public key\");\n\n\tmemset(&pubkey_info, 0, sizeof(pubkey_info));\n\tmemset(&pubkey_obj, 0, sizeof(pubkey_obj));\n\n\tr = sc_pkcs15_encode_pubkey(ctx, &pubkey, &pubkey_obj.content.value, &pubkey_obj.content.len);\n\tLOG_TEST_RET(ctx, r, \"Could not encode public key\");\n\tr = sc_pkcs15_encode_pubkey(ctx, &pubkey, &pubkey_info.direct.raw.value, &pubkey_info.direct.raw.len);\n\tLOG_TEST_RET(ctx, r, \"Could not encode public key\");\n\tr = sc_pkcs15_encode_pubkey_as_spki(ctx, &pubkey, &pubkey_info.direct.spki.value, &pubkey_info.direct.spki.len);\n\tLOG_TEST_RET(ctx, r, \"Could not encode public key\");\n\n\tpubkey_info.id = key_info->id;\n\tstrlcpy(pubkey_obj.label, label, sizeof(pubkey_obj.label));\n\n\tif (pubkey.algorithm == SC_ALGORITHM_RSA) {\n\t\tpubkey_info.modulus_length = pubkey.u.rsa.modulus.len << 3;\n\t\tpubkey_info.usage = SC_PKCS15_PRKEY_USAGE_ENCRYPT|SC_PKCS15_PRKEY_USAGE_VERIFY|SC_PKCS15_PRKEY_USAGE_WRAP;\n\t\tr = sc_pkcs15emu_add_rsa_pubkey(p15card, &pubkey_obj, &pubkey_info);\n\t} else {\n\t\t/* TODO fix if support of non multiple of 8 curves are added */\n\t\tpubkey_info.field_length = cvc.primeOrModuluslen << 3;\n\t\tpubkey_info.usage = SC_PKCS15_PRKEY_USAGE_VERIFY;\n\t\tr = sc_pkcs15emu_add_ec_pubkey(p15card, &pubkey_obj, &pubkey_info);\n\t}\n\tLOG_TEST_RET(ctx, r, \"Could not add public key\");\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&cvc);\n\tsc_pkcs15_erase_pubkey(&pubkey);\n\n\treturn SC_SUCCESS;\n}\n\n\n\n/*\n * Add a key and the key description in PKCS#15 format to the framework\n */\nstatic int sc_pkcs15emu_sc_hsm_add_prkd(sc_pkcs15_card_t * p15card, u8 keyid) {\n\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_cert_info_t cert_info;\n\tsc_pkcs15_object_t cert_obj;\n\tstruct sc_pkcs15_object prkd;\n\tsc_pkcs15_prkey_info_t *key_info;\n\tu8 fid[2];\n\t/* enough to hold a complete certificate */\n\tu8 efbin[4096];\n\tu8 *ptr;\n\tsize_t len;\n\tint r;\n\n\tfid[0] = PRKD_PREFIX;\n\tfid[1] = keyid;\n\n\t/* Try to select a related EF containing the PKCS#15 description of the key */\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.PRKD\");\n\n\tptr = efbin;\n\n\tmemset(&prkd, 0, sizeof(prkd));\n\tr = sc_pkcs15_decode_prkdf_entry(p15card, &prkd, (const u8 **)&ptr, &len);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.PRKD\");\n\n\t/* All keys require user PIN authentication */\n\tprkd.auth_id.len = 1;\n\tprkd.auth_id.value[0] = 1;\n\n\t/*\n\t * Set private key flag as all keys are private anyway\n\t */\n\tprkd.flags |= SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tkey_info = (sc_pkcs15_prkey_info_t *)prkd.data;\n\tkey_info->key_reference = keyid;\n\tkey_info->path.aid.len = 0;\n\n\tif (prkd.type == SC_PKCS15_TYPE_PRKEY_RSA) {\n\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkd, key_info);\n\t} else {\n\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkd, key_info);\n\t}\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not add private key to framework\");\n\n\t/* Check if we also have a certificate for the private key */\n\tfid[0] = EE_CERTIFICATE_PREFIX;\n\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 0);\n\tLOG_TEST_RET(card->ctx, r, \"Could not read EF\");\n\n\tif (efbin[0] == 0x67) {\t\t/* Decode CSR and create public key object */\n\t\tsc_pkcs15emu_sc_hsm_add_pubkey(p15card, efbin, len, key_info, prkd.label);\n\t\tfree(key_info);\n\t\treturn SC_SUCCESS;\t\t/* Ignore any errors */\n\t}\n\n\tif (efbin[0] != 0x30) {\n\t\tfree(key_info);\n\t\treturn SC_SUCCESS;\n\t}\n\n\tmemset(&cert_info, 0, sizeof(cert_info));\n\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\tcert_info.id = key_info->id;\n\tsc_path_set(&cert_info.path, SC_PATH_TYPE_FILE_ID, fid, 2, 0, 0);\n\tcert_info.path.count = -1;\n\tif (p15card->opts.use_file_cache) {\n\t\t/* look this up with our AID, which should already be cached from the\n\t\t * call to `read_file`. This may have the side effect that OpenSC's\n\t\t * caching layer re-selects our applet *if the cached file cannot be\n\t\t * found/used* and we may loose the authentication status. We assume\n\t\t * that caching works perfectly without this side effect. */\n\t\tcert_info.path.aid = sc_hsm_aid;\n\t}\n\n\tstrlcpy(cert_obj.label, prkd.label, sizeof(cert_obj.label));\n\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\n\tfree(key_info);\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not add certificate\");\n\n\treturn SC_SUCCESS;\n}\n\n\n\n/*\n * Add a data object and description in PKCS#15 format to the framework\n */\nstatic int sc_pkcs15emu_sc_hsm_add_dcod(sc_pkcs15_card_t * p15card, u8 id) {\n\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_data_info_t *data_info;\n\tsc_pkcs15_object_t data_obj;\n\tu8 fid[2];\n\tu8 efbin[512];\n\tconst u8 *ptr;\n\tsize_t len;\n\tint r;\n\n\tfid[0] = DCOD_PREFIX;\n\tfid[1] = id;\n\n\t/* Try to select a related EF containing the PKCS#15 description of the data */\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.DCOD\");\n\n\tptr = efbin;\n\n\tmemset(&data_obj, 0, sizeof(data_obj));\n\tr = sc_pkcs15_decode_dodf_entry(p15card, &data_obj, &ptr, &len);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode optional EF.DCOD\");\n\n\tdata_info = (sc_pkcs15_data_info_t *)data_obj.data;\n\n\tr = sc_pkcs15emu_add_data_object(p15card, &data_obj, data_info);\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not add data object to framework\");\n\n\treturn SC_SUCCESS;\n}\n\n\n\n/*\n * Add a unrelated certificate object and description in PKCS#15 format to the framework\n */\nstatic int sc_pkcs15emu_sc_hsm_add_cd(sc_pkcs15_card_t * p15card, u8 id) {\n\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_cert_info_t *cert_info;\n\tsc_pkcs15_object_t obj;\n\tu8 fid[2];\n\tu8 efbin[512];\n\tconst u8 *ptr;\n\tsize_t len;\n\tint r;\n\n\tfid[0] = CD_PREFIX;\n\tfid[1] = id;\n\n\t/* Try to select a related EF containing the PKCS#15 description of the data */\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.DCOD\");\n\n\tptr = efbin;\n\n\tmemset(&obj, 0, sizeof(obj));\n\tr = sc_pkcs15_decode_cdf_entry(p15card, &obj, &ptr, &len);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.CDOD\");\n\n\tcert_info = (sc_pkcs15_cert_info_t *)obj.data;\n\n\tr = sc_pkcs15emu_add_x509_cert(p15card, &obj, cert_info);\n\n\tLOG_TEST_RET(card->ctx, r, \"Could not add data object to framework\");\n\n\treturn SC_SUCCESS;\n}\n\n\n\nstatic int sc_pkcs15emu_sc_hsm_read_tokeninfo (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tint r;\n\tu8 efbin[512];\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* Read token info */\n\tlen = sizeof efbin;\n\tr = read_file(p15card, (u8 *) \"\\x2F\\x03\", efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.TokenInfo\");\n\n\tr = sc_pkcs15_parse_tokeninfo(card->ctx, p15card->tokeninfo, efbin, len);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.TokenInfo\");\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\n\n/*\n * Initialize PKCS#15 emulation with user PIN, private keys, certificate and data objects\n *\n */\nstatic int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"Could not select SmartCard-HSM application\");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n\n\t\tif (len > 0) {\n\t\t\t/* save EF_C_DevAut for further use */\n\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\t\tif (ptr) {\n\t\t\t\tmemcpy(ptr, efbin, len);\n\t\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t\t}\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \"UserPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \"SOPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \"Could not enumerate file and key identifier\");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Error %d adding elements to framework\", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\n\nint sc_pkcs15emu_sc_hsm_init_ex(sc_pkcs15_card_t *p15card,\n\t\t\t\tstruct sc_aid *aid,\n\t\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\tif (opts && (opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)) {\n\t\treturn sc_pkcs15emu_sc_hsm_init(p15card);\n\t} else {\n\t\tif (p15card->card->type != SC_CARD_TYPE_SC_HSM\n\t\t\t\t&& p15card->card->type != SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t\t&& p15card->card->type != SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\t}\n\t\treturn sc_pkcs15emu_sc_hsm_init(p15card);\n\t}\n}\n", "/*\n * sc.c: General functions\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n#ifdef ENABLE_OPENSSL\n#include <openssl/crypto.h>     /* for OPENSSL_cleanse */\n#endif\n\n#include \"internal.h\"\n\n#ifdef PACKAGE_VERSION\nstatic const char *sc_version = PACKAGE_VERSION;\n#else\nstatic const char *sc_version = \"(undef)\";\n#endif\n\nconst char *sc_get_version(void)\n{\n    return sc_version;\n}\n\nint sc_hex_to_bin(const char *in, u8 *out, size_t *outlen)\n{\n\tint err = SC_SUCCESS;\n\tsize_t left, count = 0, in_len;\n\n\tif (in == NULL || out == NULL || outlen == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tleft = *outlen;\n\tin_len = strlen(in);\n\n\twhile (*in != '\\0') {\n\t\tint byte = 0, nybbles = 2;\n\n\t\twhile (nybbles-- && *in && *in != ':' && *in != ' ') {\n\t\t\tchar c;\n\t\t\tbyte <<= 4;\n\t\t\tc = *in++;\n\t\t\tif ('0' <= c && c <= '9')\n\t\t\t\tc -= '0';\n\t\t\telse\n\t\t\tif ('a' <= c && c <= 'f')\n\t\t\t\tc = c - 'a' + 10;\n\t\t\telse\n\t\t\tif ('A' <= c && c <= 'F')\n\t\t\t\tc = c - 'A' + 10;\n\t\t\telse {\n\t\t\t\terr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbyte |= c;\n\t\t}\n\n\t\t/* Detect premature end of string before byte is complete */\n\t\tif (in_len > 1 && *in == '\\0' && nybbles >= 0) {\n\t\t\terr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*in == ':' || *in == ' ')\n\t\t\tin++;\n\t\tif (left <= 0) {\n\t\t\terr = SC_ERROR_BUFFER_TOO_SMALL;\n\t\t\tbreak;\n\t\t}\n\t\tout[count++] = (u8) byte;\n\t\tleft--;\n\t}\n\nout:\n\t*outlen = count;\n\treturn err;\n}\n\nint sc_bin_to_hex(const u8 *in, size_t in_len, char *out, size_t out_len,\n\t\t  int in_sep)\n{\n\tunsigned int\tn, sep_len;\n\tchar\t\t*pos, *end, sep;\n\n\tsep = (char)in_sep;\n\tsep_len = sep > 0 ? 1 : 0;\n\tpos = out;\n\tend = out + out_len;\n\tfor (n = 0; n < in_len; n++) {\n\t\tif (pos + 3 + sep_len >= end)\n\t\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t\tif (n && sep_len)\n\t\t\t*pos++ = sep;\n\t\tsprintf(pos, \"%02x\", in[n]);\n\t\tpos += 2;\n\t}\n\t*pos = '\\0';\n\treturn SC_SUCCESS;\n}\n\n/*\n * Right trim all non-printable characters\n */\nsize_t sc_right_trim(u8 *buf, size_t len) {\n\n\tsize_t i;\n\n\tif (!buf)\n\t\treturn 0;\n\n\tif (len > 0) {\n\t\tfor(i = len-1; i > 0; i--) {\n\t\t\tif(!isprint(buf[i])) {\n\t\t\t\tbuf[i] = '\\0';\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn len;\n}\n\nu8 *ulong2bebytes(u8 *buf, unsigned long x)\n{\n\tif (buf != NULL) {\n\t\tbuf[3] = (u8) (x & 0xff);\n\t\tbuf[2] = (u8) ((x >> 8) & 0xff);\n\t\tbuf[1] = (u8) ((x >> 16) & 0xff);\n\t\tbuf[0] = (u8) ((x >> 24) & 0xff);\n\t}\n\treturn buf;\n}\n\nu8 *ushort2bebytes(u8 *buf, unsigned short x)\n{\n\tif (buf != NULL) {\n\t\tbuf[1] = (u8) (x & 0xff);\n\t\tbuf[0] = (u8) ((x >> 8) & 0xff);\n\t}\n\treturn buf;\n}\n\nunsigned long bebytes2ulong(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0UL;\n\treturn (unsigned long) (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]);\n}\n\nunsigned short bebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short) (buf[0] << 8 | buf[1]);\n}\n\nunsigned short lebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short)buf[1] << 8 | (unsigned short)buf[0];\n}\n\nvoid sc_init_oid(struct sc_object_id *oid)\n{\n\tint ii;\n\n\tif (!oid)\n\t\treturn;\n\tfor (ii=0; ii<SC_MAX_OBJECT_ID_OCTETS; ii++)\n\t\toid->value[ii] = -1;\n}\n\nint sc_format_oid(struct sc_object_id *oid, const char *in)\n{\n\tint        ii, ret = SC_ERROR_INVALID_ARGUMENTS;\n\tconst char *p;\n\tchar       *q;\n\n\tif (oid == NULL || in == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tsc_init_oid(oid);\n\n\tp = in;\n\tfor (ii=0; ii < SC_MAX_OBJECT_ID_OCTETS; ii++)   {\n\t\toid->value[ii] = strtol(p, &q, 10);\n\t\tif (!*q)\n\t\t\tbreak;\n\n\t\tif (!(q[0] == '.' && isdigit(q[1])))\n\t\t\tgoto out;\n\n\t\tp = q + 1;\n\t}\n\n\tif (!sc_valid_oid(oid))\n\t\tgoto out;\n\n\tret = SC_SUCCESS;\nout:\n\tif (ret)\n\t\tsc_init_oid(oid);\n\n\treturn ret;\n}\n\nint sc_compare_oid(const struct sc_object_id *oid1, const struct sc_object_id *oid2)\n{\n\tint i;\n\n\tif (oid1 == NULL || oid2 == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++)   {\n\t\tif (oid1->value[i] != oid2->value[i])\n\t\t\treturn 0;\n\t\tif (oid1->value[i] == -1)\n\t\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n\nint sc_valid_oid(const struct sc_object_id *oid)\n{\n\tint ii;\n\n\tif (!oid)\n\t\treturn 0;\n\tif (oid->value[0] == -1 || oid->value[1] == -1)\n\t\treturn 0;\n\tif (oid->value[0] > 2 || oid->value[1] > 39)\n\t\treturn 0;\n\tfor (ii=0;ii<SC_MAX_OBJECT_ID_OCTETS;ii++)\n\t\tif (oid->value[ii])\n\t\t\tbreak;\n\tif (ii==SC_MAX_OBJECT_ID_OCTETS)\n\t\treturn 0;\n\treturn 1;\n}\n\n\nint sc_detect_card_presence(sc_reader_t *reader)\n{\n\tint r;\n\tLOG_FUNC_CALLED(reader->ctx);\n\tif (reader->ops->detect_card_presence == NULL)\n\t\tLOG_FUNC_RETURN(reader->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tr = reader->ops->detect_card_presence(reader);\n\tLOG_FUNC_RETURN(reader->ctx, r);\n}\n\nint sc_path_set(sc_path_t *path, int type, const u8 *id, size_t id_len,\n\tint idx, int count)\n{\n\tif (path == NULL || id == NULL || id_len == 0 || id_len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tmemset(path, 0, sizeof(*path));\n\tmemcpy(path->value, id, id_len);\n\tpath->len   = id_len;\n\tpath->type  = type;\n\tpath->index = idx;\n\tpath->count = count;\n\n\treturn SC_SUCCESS;\n}\n\nvoid sc_format_path(const char *str, sc_path_t *path)\n{\n\tint type = SC_PATH_TYPE_PATH;\n\n\tif (path) {\n\t\tmemset(path, 0, sizeof(*path));\n\t\tif (*str == 'i' || *str == 'I') {\n\t\t\ttype = SC_PATH_TYPE_FILE_ID;\n\t\t\tstr++;\n\t\t}\n\t\tpath->len = sizeof(path->value);\n\t\tif (sc_hex_to_bin(str, path->value, &path->len) >= 0) {\n\t\t\tpath->type = type;\n\t\t}\n\t\tpath->count = -1;\n\t}\n}\n\nint sc_append_path(sc_path_t *dest, const sc_path_t *src)\n{\n\treturn sc_concatenate_path(dest, dest, src);\n}\n\nint sc_append_path_id(sc_path_t *dest, const u8 *id, size_t idlen)\n{\n\tif (dest->len + idlen > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemcpy(dest->value + dest->len, id, idlen);\n\tdest->len += idlen;\n\treturn SC_SUCCESS;\n}\n\nint sc_append_file_id(sc_path_t *dest, unsigned int fid)\n{\n\tu8 id[2] = { fid >> 8, fid & 0xff };\n\n\treturn sc_append_path_id(dest, id, 2);\n}\n\nint sc_concatenate_path(sc_path_t *d, const sc_path_t *p1, const sc_path_t *p2)\n{\n\tsc_path_t tpath;\n\n\tif (d == NULL || p1 == NULL || p2 == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tif (p1->type == SC_PATH_TYPE_DF_NAME || p2->type == SC_PATH_TYPE_DF_NAME)\n\t\t/* we do not support concatenation of AIDs at the moment */\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\n\tif (p1->len + p2->len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tmemset(&tpath, 0, sizeof(sc_path_t));\n\tmemcpy(tpath.value, p1->value, p1->len);\n\tmemcpy(tpath.value + p1->len, p2->value, p2->len);\n\ttpath.len  = p1->len + p2->len;\n\ttpath.type = SC_PATH_TYPE_PATH;\n\t/* use 'index' and 'count' entry of the second path object */\n\ttpath.index = p2->index;\n\ttpath.count = p2->count;\n\t/* the result is currently always as path */\n\ttpath.type  = SC_PATH_TYPE_PATH;\n\n\t*d = tpath;\n\n\treturn SC_SUCCESS;\n}\n\nconst char *sc_print_path(const sc_path_t *path)\n{\n\tstatic char buffer[SC_MAX_PATH_STRING_SIZE + SC_MAX_AID_STRING_SIZE];\n\n\tif (sc_path_print(buffer, sizeof(buffer), path) != SC_SUCCESS)\n\t\tbuffer[0] = '\\0';\n\n\treturn buffer;\n}\n\nint sc_path_print(char *buf, size_t buflen, const sc_path_t *path)\n{\n\tsize_t i;\n\n\tif (buf == NULL || path == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tif (buflen < path->len * 2 + path->aid.len * 2 + 1)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\n\tbuf[0] = '\\0';\n\tif (path->aid.len)   {\n\t\tfor (i = 0; i < path->aid.len; i++)\n\t\t\tsnprintf(buf + strlen(buf), buflen - strlen(buf), \"%02x\", path->aid.value[i]);\n\t\tsnprintf(buf + strlen(buf), buflen - strlen(buf), \"::\");\n\t}\n\n\tfor (i = 0; i < path->len; i++)\n\t\tsnprintf(buf + strlen(buf), buflen - strlen(buf), \"%02x\", path->value[i]);\n\tif (!path->aid.len && path->type == SC_PATH_TYPE_DF_NAME)\n\t\tsnprintf(buf + strlen(buf), buflen - strlen(buf), \"::\");\n\n\treturn SC_SUCCESS;\n}\n\nint sc_compare_path(const sc_path_t *path1, const sc_path_t *path2)\n{\n\treturn path1->len == path2->len\n\t\t&& !memcmp(path1->value, path2->value, path1->len);\n}\n\nint sc_compare_path_prefix(const sc_path_t *prefix, const sc_path_t *path)\n{\n\tsc_path_t tpath;\n\n\tif (prefix->len > path->len)\n\t\treturn 0;\n\n\ttpath     = *path;\n\ttpath.len = prefix->len;\n\n\treturn sc_compare_path(&tpath, prefix);\n}\n\nconst sc_path_t *sc_get_mf_path(void)\n{\n\tstatic const sc_path_t mf_path = {\n\t\t{0x3f, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 2,\n\t\t0,\n\t\t0,\n\t\tSC_PATH_TYPE_PATH,\n\t\t{{0},0}\n\t};\n\treturn &mf_path;\n}\n\nint sc_file_add_acl_entry(sc_file_t *file, unsigned int operation,\n                          unsigned int method, unsigned long key_ref)\n{\n\tsc_acl_entry_t *p, *_new;\n\n\tif (file == NULL || operation >= SC_MAX_AC_OPS) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tswitch (method) {\n\tcase SC_AC_NEVER:\n\t\tsc_file_clear_acl_entries(file, operation);\n\t\tfile->acl[operation] = (sc_acl_entry_t *) 1;\n\t\treturn SC_SUCCESS;\n\tcase SC_AC_NONE:\n\t\tsc_file_clear_acl_entries(file, operation);\n\t\tfile->acl[operation] = (sc_acl_entry_t *) 2;\n\t\treturn SC_SUCCESS;\n\tcase SC_AC_UNKNOWN:\n\t\tsc_file_clear_acl_entries(file, operation);\n\t\tfile->acl[operation] = (sc_acl_entry_t *) 3;\n\t\treturn SC_SUCCESS;\n\tdefault:\n\t\t/* NONE and UNKNOWN get zapped when a new AC is added.\n\t\t * If the ACL is NEVER, additional entries will be\n\t\t * dropped silently. */\n\t\tif (file->acl[operation] == (sc_acl_entry_t *) 1)\n\t\t\treturn SC_SUCCESS;\n\t\tif (file->acl[operation] == (sc_acl_entry_t *) 2\n\t\t || file->acl[operation] == (sc_acl_entry_t *) 3)\n\t\t\tfile->acl[operation] = NULL;\n\t}\n\n\t/* If the entry is already present (e.g. due to the mapping)\n\t * of the card's AC with OpenSC's), don't add it again. */\n\tfor (p = file->acl[operation]; p != NULL; p = p->next) {\n\t\tif ((p->method == method) && (p->key_ref == key_ref))\n\t\t\treturn SC_SUCCESS;\n\t}\n\n\t_new = malloc(sizeof(sc_acl_entry_t));\n\tif (_new == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t_new->method = method;\n\t_new->key_ref = key_ref;\n\t_new->next = NULL;\n\n\tp = file->acl[operation];\n\tif (p == NULL) {\n\t\tfile->acl[operation] = _new;\n\t\treturn SC_SUCCESS;\n\t}\n\twhile (p->next != NULL)\n\t\tp = p->next;\n\tp->next = _new;\n\n\treturn SC_SUCCESS;\n}\n\nconst sc_acl_entry_t * sc_file_get_acl_entry(const sc_file_t *file,\n\t\t\t\t\t\t  unsigned int operation)\n{\n\tsc_acl_entry_t *p;\n\tstatic const sc_acl_entry_t e_never = {\n\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE, {{0, 0, 0, {0}}}, NULL\n\t};\n\tstatic const sc_acl_entry_t e_none = {\n\t\tSC_AC_NONE, SC_AC_KEY_REF_NONE, {{0, 0, 0, {0}}}, NULL\n\t};\n\tstatic const sc_acl_entry_t e_unknown = {\n\t\tSC_AC_UNKNOWN, SC_AC_KEY_REF_NONE, {{0, 0, 0, {0}}}, NULL\n\t};\n\n\tif (file == NULL || operation >= SC_MAX_AC_OPS) {\n\t\treturn NULL;\n\t}\n\n\tp = file->acl[operation];\n\tif (p == (sc_acl_entry_t *) 1)\n\t\treturn &e_never;\n\tif (p == (sc_acl_entry_t *) 2)\n\t\treturn &e_none;\n\tif (p == (sc_acl_entry_t *) 3)\n\t\treturn &e_unknown;\n\n\treturn file->acl[operation];\n}\n\nvoid sc_file_clear_acl_entries(sc_file_t *file, unsigned int operation)\n{\n\tsc_acl_entry_t *e;\n\n\tif (file == NULL || operation >= SC_MAX_AC_OPS) {\n\t\treturn;\n\t}\n\n\te = file->acl[operation];\n\tif (e == (sc_acl_entry_t *) 1 ||\n\t    e == (sc_acl_entry_t *) 2 ||\n\t    e == (sc_acl_entry_t *) 3) {\n\t\tfile->acl[operation] = NULL;\n\t\treturn;\n\t}\n\n\twhile (e != NULL) {\n\t\tsc_acl_entry_t *tmp = e->next;\n\t\tfree(e);\n\t\te = tmp;\n\t}\n\tfile->acl[operation] = NULL;\n}\n\nsc_file_t * sc_file_new(void)\n{\n\tsc_file_t *file = (sc_file_t *)calloc(1, sizeof(sc_file_t));\n\tif (file == NULL)\n\t\treturn NULL;\n\n\tfile->magic = SC_FILE_MAGIC;\n\treturn file;\n}\n\nvoid sc_file_free(sc_file_t *file)\n{\n\tunsigned int i;\n\tif (file == NULL || !sc_file_valid(file))\n\t\treturn;\n\tfile->magic = 0;\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_clear_acl_entries(file, i);\n\tif (file->sec_attr)\n\t\tfree(file->sec_attr);\n\tif (file->prop_attr)\n\t\tfree(file->prop_attr);\n\tif (file->type_attr)\n\t\tfree(file->type_attr);\n\tif (file->encoded_content)\n\t\tfree(file->encoded_content);\n\tfree(file);\n}\n\nvoid sc_file_dup(sc_file_t **dest, const sc_file_t *src)\n{\n\tsc_file_t *newf;\n\tconst sc_acl_entry_t *e;\n\tunsigned int op;\n\n\t*dest = NULL;\n\tif (!sc_file_valid(src))\n\t\treturn;\n\tnewf = sc_file_new();\n\tif (newf == NULL)\n\t\treturn;\n\t*dest = newf;\n\n\tmemcpy(&newf->path, &src->path, sizeof(struct sc_path));\n\tmemcpy(&newf->name, &src->name, sizeof(src->name));\n\tnewf->namelen = src->namelen;\n\tnewf->type    = src->type;\n\tnewf->shareable    = src->shareable;\n\tnewf->ef_structure = src->ef_structure;\n\tnewf->size    = src->size;\n\tnewf->id      = src->id;\n\tnewf->status  = src->status;\n\tfor (op = 0; op < SC_MAX_AC_OPS; op++) {\n\t\tnewf->acl[op] = NULL;\n\t\te = sc_file_get_acl_entry(src, op);\n\t\tif (e != NULL) {\n\t\t\tif (sc_file_add_acl_entry(newf, op, e->method, e->key_ref) < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\tnewf->record_length = src->record_length;\n\tnewf->record_count  = src->record_count;\n\n\tif (sc_file_set_sec_attr(newf, src->sec_attr, src->sec_attr_len) < 0)\n\t\tgoto err;\n\tif (sc_file_set_prop_attr(newf, src->prop_attr, src->prop_attr_len) < 0)\n\t\tgoto err;\n\tif (sc_file_set_type_attr(newf, src->type_attr, src->type_attr_len) < 0)\n\t\tgoto err;\n\tif (sc_file_set_content(newf, src->encoded_content, src->encoded_content_len) < 0)\n\t\tgoto err;\n\treturn;\nerr:\n\tsc_file_free(newf);\n\t*dest = NULL;\n}\n\nint sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}\n\nint sc_file_set_prop_attr(sc_file_t *file, const u8 *prop_attr,\n\t\t\t size_t prop_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (prop_attr == NULL) {\n\t\tif (file->prop_attr != NULL)\n\t\t\tfree(file->prop_attr);\n\t\tfile->prop_attr = NULL;\n\t\tfile->prop_attr_len = 0;\n\t\treturn SC_SUCCESS;\n\t }\n\ttmp = (u8 *) realloc(file->prop_attr, prop_attr_len);\n\tif (!tmp) {\n\t\tif (file->prop_attr)\n\t\t\tfree(file->prop_attr);\n\t\tfile->prop_attr = NULL;\n\t\tfile->prop_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->prop_attr = tmp;\n\tmemcpy(file->prop_attr, prop_attr, prop_attr_len);\n\tfile->prop_attr_len = prop_attr_len;\n\n\treturn SC_SUCCESS;\n}\n\nint sc_file_set_type_attr(sc_file_t *file, const u8 *type_attr,\n\t\t\t size_t type_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (type_attr == NULL) {\n\t\tif (file->type_attr != NULL)\n\t\t\tfree(file->type_attr);\n\t\tfile->type_attr = NULL;\n\t\tfile->type_attr_len = 0;\n\t\treturn SC_SUCCESS;\n\t }\n\ttmp = (u8 *) realloc(file->type_attr, type_attr_len);\n\tif (!tmp) {\n\t\tif (file->type_attr)\n\t\t\tfree(file->type_attr);\n\t\tfile->type_attr = NULL;\n\t\tfile->type_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->type_attr = tmp;\n\tmemcpy(file->type_attr, type_attr, type_attr_len);\n\tfile->type_attr_len = type_attr_len;\n\n\treturn SC_SUCCESS;\n}\n\n\nint sc_file_set_content(sc_file_t *file, const u8 *content,\n\t\t\t size_t content_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (content == NULL) {\n\t\tif (file->encoded_content != NULL)\n\t\t\tfree(file->encoded_content);\n\t\tfile->encoded_content = NULL;\n\t\tfile->encoded_content_len = 0;\n\t\treturn SC_SUCCESS;\n\t}\n\n\ttmp = (u8 *) realloc(file->encoded_content, content_len);\n\tif (!tmp) {\n\t\tif (file->encoded_content)\n\t\t\tfree(file->encoded_content);\n\t\tfile->encoded_content = NULL;\n\t\tfile->encoded_content_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\tfile->encoded_content = tmp;\n\tmemcpy(file->encoded_content, content, content_len);\n\tfile->encoded_content_len = content_len;\n\n\treturn SC_SUCCESS;\n}\n\n\nint sc_file_valid(const sc_file_t *file) {\n\tif (file == NULL)\n\t\treturn 0;\n\treturn file->magic == SC_FILE_MAGIC;\n}\n\nint _sc_parse_atr(sc_reader_t *reader)\n{\n\tu8 *p = reader->atr.value;\n\tint atr_len = (int) reader->atr.len;\n\tint n_hist, x;\n\tint tx[4] = {-1, -1, -1, -1};\n\tint i, FI, DI;\n\tconst int Fi_table[] = {\n\t\t372, 372, 558, 744, 1116, 1488, 1860, -1,\n\t\t-1, 512, 768, 1024, 1536, 2048, -1, -1 };\n\tconst int f_table[] = {\n\t\t40, 50, 60, 80, 120, 160, 200, -1,\n\t\t-1, 50, 75, 100, 150, 200, -1, -1 };\n\tconst int Di_table[] = {\n\t\t-1, 1, 2, 4, 8, 16, 32, -1,\n\t\t12, 20, -1, -1, -1, -1, -1, -1 };\n\n\treader->atr_info.hist_bytes_len = 0;\n\treader->atr_info.hist_bytes = NULL;\n\n\tif (atr_len == 0) {\n\t\tsc_log(reader->ctx, \"empty ATR - card not present?\\n\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tif (p[0] != 0x3B && p[0] != 0x3F) {\n\t\tsc_log(reader->ctx, \"invalid sync byte in ATR: 0x%02X\\n\", p[0]);\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tn_hist = p[1] & 0x0F;\n\tx = p[1] >> 4;\n\tp += 2;\n\tatr_len -= 2;\n\tfor (i = 0; i < 4 && atr_len > 0; i++) {\n                if (x & (1 << i)) {\n                        tx[i] = *p;\n                        p++;\n                        atr_len--;\n                } else\n                        tx[i] = -1;\n        }\n\tif (tx[0] >= 0) {\n\t\treader->atr_info.FI = FI = tx[0] >> 4;\n\t\treader->atr_info.DI = DI = tx[0] & 0x0F;\n\t\treader->atr_info.Fi = Fi_table[FI];\n\t\treader->atr_info.f = f_table[FI];\n\t\treader->atr_info.Di = Di_table[DI];\n\t} else {\n\t\treader->atr_info.Fi = -1;\n\t\treader->atr_info.f = -1;\n\t\treader->atr_info.Di = -1;\n\t}\n\tif (tx[2] >= 0)\n\t\treader->atr_info.N = tx[3];\n\telse\n\t\treader->atr_info.N = -1;\n\twhile (tx[3] > 0 && tx[3] & 0xF0 && atr_len > 0) {\n\t\tx = tx[3] >> 4;\n\t\tfor (i = 0; i < 4 && atr_len > 0; i++) {\n\t                if (x & (1 << i)) {\n\t                        tx[i] = *p;\n\t                        p++;\n\t                        atr_len--;\n\t                } else\n\t                        tx[i] = -1;\n\t\t}\n\t}\n\tif (atr_len <= 0)\n\t\treturn SC_SUCCESS;\n\tif (n_hist > atr_len)\n\t\tn_hist = atr_len;\n\treader->atr_info.hist_bytes_len = n_hist;\n\treader->atr_info.hist_bytes = p;\n\treturn SC_SUCCESS;\n}\n\nvoid sc_mem_clear(void *ptr, size_t len)\n{\n\tif (len > 0)   {\n#ifdef ENABLE_OPENSSL\n\t\tOPENSSL_cleanse(ptr, len);\n#else\n\t\tmemset(ptr, 0, len);\n#endif\n\t}\n}\n\nint sc_mem_reverse(unsigned char *buf, size_t len)\n{\n\tunsigned char ch;\n\tsize_t ii;\n\n\tif (!buf || !len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tfor (ii = 0; ii < len / 2; ii++)   {\n\t\tch = *(buf + ii);\n\t\t*(buf + ii) = *(buf + len - 1 - ii);\n\t\t*(buf + len - 1 - ii) = ch;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int\nsc_remote_apdu_allocate(struct sc_remote_data *rdata,\n\t\tstruct sc_remote_apdu **new_rapdu)\n{\n\tstruct sc_remote_apdu *rapdu = NULL, *rr;\n\n\tif (!rdata)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\trapdu = calloc(1, sizeof(struct sc_remote_apdu));\n\tif (rapdu == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\trapdu->apdu.data = &rapdu->sbuf[0];\n\trapdu->apdu.resp = &rapdu->rbuf[0];\n\trapdu->apdu.resplen = sizeof(rapdu->rbuf);\n\n\tif (new_rapdu)\n\t\t*new_rapdu = rapdu;\n\n\tif (rdata->data == NULL)   {\n\t\trdata->data = rapdu;\n\t\trdata->length = 1;\n\t\treturn SC_SUCCESS;\n\t}\n\n\tfor (rr = rdata->data; rr->next; rr = rr->next)\n\t\t;\n\trr->next = rapdu;\n\trdata->length++;\n\n\treturn SC_SUCCESS;\n}\n\nstatic void\nsc_remote_apdu_free (struct sc_remote_data *rdata)\n{\n\tstruct sc_remote_apdu *rapdu = NULL;\n\n\tif (!rdata)\n\t\treturn;\n\n\trapdu = rdata->data;\n\twhile(rapdu)   {\n\t\tstruct sc_remote_apdu *rr = rapdu->next;\n\n\t\tfree(rapdu);\n\t\trapdu = rr;\n\t}\n}\n\nvoid sc_remote_data_init(struct sc_remote_data *rdata)\n{\n\tif (!rdata)\n\t\treturn;\n\tmemset(rdata, 0, sizeof(struct sc_remote_data));\n\n\trdata->alloc = sc_remote_apdu_allocate;\n\trdata->free = sc_remote_apdu_free;\n}\n\nstatic unsigned long  sc_CRC_tab32[256];\nstatic int sc_CRC_tab32_initialized = 0;\nunsigned sc_crc32(const unsigned char *value, size_t len)\n{\n\tsize_t ii, jj;\n\tunsigned long crc;\n\tunsigned long index, long_c;\n\n\tif (!sc_CRC_tab32_initialized)   {\n\t\tfor (ii=0; ii<256; ii++) {\n\t\t\tcrc = (unsigned long) ii;\n\t\t\tfor (jj=0; jj<8; jj++) {\n\t\t\t\tif ( crc & 0x00000001L )\n\t\t\t\t\tcrc = ( crc >> 1 ) ^ 0xEDB88320l;\n\t\t\t\telse\n\t\t\t\t\tcrc =   crc >> 1;\n\t\t\t}\n\t\t\tsc_CRC_tab32[ii] = crc;\n\t\t}\n\t\tsc_CRC_tab32_initialized = 1;\n\t}\n\n\tcrc = 0xffffffffL;\n\tfor (ii=0; ii<len; ii++)   {\n\t\tlong_c = 0x000000ffL & (unsigned long) (*(value + ii));\n\t\tindex = crc ^ long_c;\n\t\tcrc = (crc >> 8) ^ sc_CRC_tab32[ index & 0xff ];\n\t}\n\n\tcrc ^= 0xffffffff;\n\treturn  crc%0xffff;\n}\n\nconst u8 *sc_compacttlv_find_tag(const u8 *buf, size_t len, u8 tag, size_t *outlen)\n{\n\tif (buf != NULL) {\n\t\tsize_t idx;\n\t\tu8 plain_tag = tag & 0xF0;\n\t\tsize_t expected_len = tag & 0x0F;\n\n\t        for (idx = 0; idx < len; idx++) {\n\t\t\tif ((buf[idx] & 0xF0) == plain_tag && idx + expected_len < len &&\n\t\t\t    (expected_len == 0 || expected_len == (buf[idx] & 0x0F))) {\n\t\t\t\tif (outlen != NULL)\n\t\t\t\t\t*outlen = buf[idx] & 0x0F;\n\t\t\t\treturn buf + (idx + 1);\n\t\t\t}\n\t\t\tidx += (buf[idx] & 0x0F);\n                }\n        }\n\treturn NULL;\n}\n\n/**************************** mutex functions ************************/\n\nint sc_mutex_create(const sc_context_t *ctx, void **mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->create_mutex != NULL)\n\t\treturn ctx->thread_ctx->create_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n\nint sc_mutex_lock(const sc_context_t *ctx, void *mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->lock_mutex != NULL)\n\t\treturn ctx->thread_ctx->lock_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n\nint sc_mutex_unlock(const sc_context_t *ctx, void *mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->unlock_mutex != NULL)\n\t\treturn ctx->thread_ctx->unlock_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n\nint sc_mutex_destroy(const sc_context_t *ctx, void *mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->destroy_mutex != NULL)\n\t\treturn ctx->thread_ctx->destroy_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n\nunsigned long sc_thread_id(const sc_context_t *ctx)\n{\n\tif (ctx == NULL || ctx->thread_ctx == NULL ||\n\t    ctx->thread_ctx->thread_id == NULL)\n\t\treturn 0UL;\n\telse\n\t\treturn ctx->thread_ctx->thread_id();\n}\n", "/*\n * cryptoflex-tool.c: Tool for doing various Cryptoflex related stuff\n *\n * Copyright (C) 2001  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"config.h\"\n\n#include \"libopensc/sc-ossl-compat.h\"\n#include \"libopensc/internal.h\"\n#include <openssl/bn.h>\n#include <openssl/rsa.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <openssl/err.h>\n\n#include \"libopensc/pkcs15.h\"\n#include \"common/compat_strlcpy.h\"\n#include \"common/compat_strlcat.h\"\n#include \"util.h\"\n\nstatic const char *app_name = \"cryptoflex-tool\";\n\nstatic char * opt_reader = NULL;\nstatic int opt_wait = 0;\nstatic int opt_key_num = 1, opt_pin_num = -1;\nstatic int verbose = 0;\nstatic int opt_exponent = 3;\nstatic int opt_mod_length = 1024;\nstatic int opt_key_count = 1;\nstatic int opt_pin_attempts = 10;\nstatic int opt_puk_attempts = 10;\n\nstatic const char *opt_appdf = NULL, *opt_prkeyf = NULL, *opt_pubkeyf = NULL;\nstatic u8 *pincode = NULL;\n\nstatic const struct option options[] = {\n\t{ \"list-keys\",\t\t0, NULL, \t\t'l' },\n\t{ \"create-key-files\",\t1, NULL,\t\t'c' },\n\t{ \"create-pin-file\",\t1, NULL,\t\t'P' },\n\t{ \"generate-key\",\t0, NULL,\t\t'g' },\n\t{ \"read-key\",\t\t0, NULL,\t\t'R' },\n\t{ \"verify-pin\",\t\t0, NULL,\t\t'V' },\n\t{ \"key-num\",\t\t1, NULL,\t\t'k' },\n\t{ \"app-df\",\t\t1, NULL,\t\t'a' },\n\t{ \"prkey-file\",\t\t1, NULL,\t\t'p' },\n\t{ \"pubkey-file\",\t1, NULL,\t\t'u' },\n\t{ \"exponent\",\t\t1, NULL,\t\t'e' },\n\t{ \"modulus-length\",\t1, NULL,\t\t'm' },\n\t{ \"reader\",\t\t1, NULL,\t\t'r' },\n\t{ \"wait\",\t\t0, NULL,\t\t'w' },\n\t{ \"verbose\",\t\t0, NULL,\t\t'v' },\n\t{ NULL, 0, NULL, 0 }\n};\n\nstatic const char *option_help[] = {\n\t\"Lists all keys in a public key file\",\n\t\"Creates new RSA key files for <arg> keys\",\n\t\"Creates a new CHV<arg> file\",\n\t\"Generates a new RSA key pair\",\n\t\"Reads a public key from the card\",\n\t\"Verifies CHV1 before issuing commands\",\n\t\"Selects which key number to operate on [1]\",\n\t\"Selects the DF to operate in\",\n\t\"Private key file\",\n\t\"Public key file\",\n\t\"The RSA exponent to use in key generation [3]\",\n\t\"Modulus length to use in key generation [1024]\",\n\t\"Uses reader <arg>\",\n\t\"Wait for card insertion\",\n\t\"Verbose operation. Use several times to enable debug output.\",\n};\n\nstatic sc_context_t *ctx = NULL;\nstatic sc_card_t *card = NULL;\n\nstatic char *getpin(const char *prompt)\n{\n\tchar *buf, pass[20];\n\tint i;\n\n\tprintf(\"%s\", prompt);\n\tfflush(stdout);\n\tif (fgets(pass, 20, stdin) == NULL)\n\t\treturn NULL;\n\tfor (i = 0; i < 20; i++)\n\t\tif (pass[i] == '\\n')\n\t\t\tpass[i] = 0;\n\tif (strlen(pass) == 0)\n\t\treturn NULL;\n\tbuf = malloc(8);\n\tif (buf == NULL)\n\t\treturn NULL;\n\tif (strlen(pass) > 8) {\n\t\tfprintf(stderr, \"PIN code too long.\\n\");\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tmemset(buf, 0, 8);\n\tstrlcpy(buf, pass, 8);\n\treturn buf;\n}\n\nstatic int verify_pin(int pin)\n{\n\tchar prompt[50];\n\tint r, tries_left = -1;\n\n\tif (pincode == NULL) {\n\t\tsprintf(prompt, \"Please enter CHV%d: \", pin);\n\t\tpincode = (u8 *) getpin(prompt);\n\t\tif (pincode == NULL || strlen((char *) pincode) == 0)\n\t\t\treturn -1;\n\t}\n\tif (pin != 1 && pin != 2)\n\t\treturn -3;\n\tr = sc_verify(card, SC_AC_CHV, pin, pincode, 8, &tries_left);\n\tif (r) {\n\t\tmemset(pincode, 0, 8);\n\t\tfree(pincode);\n\t\tpincode = NULL;\n\t\tfprintf(stderr, \"PIN code verification failed: %s\\n\", sc_strerror(r));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int select_app_df(void)\n{\n\tsc_path_t path;\n\tsc_file_t *file;\n\tchar str[80];\n\tint r;\n\n\tstrcpy(str, \"3F00\");\n\tif (opt_appdf != NULL)\n\t\tstrlcat(str, opt_appdf, sizeof str);\n\tsc_format_path(str, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select application DF: %s\\n\", sc_strerror(r));\n\t\treturn -1;\n\t}\n\tif (file->type != SC_FILE_TYPE_DF) {\n\t\tfprintf(stderr, \"Selected application DF is not a DF.\\n\");\n\t\treturn -1;\n\t}\n\tsc_file_free(file);\n\tif (opt_pin_num >= 0)\n\t\treturn verify_pin(opt_pin_num);\n\telse\n\t\treturn 0;\n}\n\nstatic void invert_buf(u8 *dest, const u8 *src, size_t c)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < c; i++)\n\t\tdest[i] = src[c-1-i];\n}\n\nstatic BIGNUM * cf2bn(const u8 *buf, size_t bufsize, BIGNUM *num)\n{\n\tu8 tmp[512];\n\n\tinvert_buf(tmp, buf, bufsize);\n\n\treturn BN_bin2bn(tmp, bufsize, num);\n}\n\nstatic int bn2cf(const BIGNUM *num, u8 *buf)\n{\n\tu8 tmp[512];\n\tint r;\n\n\tr = BN_bn2bin(num, tmp);\n\tif (r <= 0)\n\t\treturn r;\n\tinvert_buf(buf, tmp, r);\n\n\treturn r;\n}\n\nstatic int parse_public_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *n, *e;\n\tint base;\n\n\tbase = (keysize - 7) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tn = BN_new();\n\tif (n == NULL)\n\t\treturn -1;\n\tcf2bn(p, 2 * base, n);\n\tp += 2 * base;\n\tp += base;\n\tp += 2 * base;\n\te = BN_new();\n\tif (e == NULL)\n\t\treturn -1;\n\tcf2bn(p, 4, e);\n\tif (RSA_set0_key(rsa, n, e, NULL) != 1)\n\t    return -1;\n\treturn 0;\n}\n\nstatic int gen_d(RSA *rsa)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *r0, *r1, *r2;\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_n, *rsa_e, *rsa_d;\n\tBIGNUM *rsa_n_new, *rsa_e_new, *rsa_d_new;\n\n\tbnctx = BN_CTX_new();\n\tif (bnctx == NULL)\n\t\treturn -1;\n\tBN_CTX_start(bnctx);\n\tr0 = BN_CTX_get(bnctx);\n\tr1 = BN_CTX_get(bnctx);\n\tr2 = BN_CTX_get(bnctx);\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, &rsa_d);\n\tRSA_get0_factors(rsa, &rsa_p, &rsa_q);\n\n\tBN_sub(r1, rsa_p, BN_value_one());\n\tBN_sub(r2, rsa_q, BN_value_one());\n\tBN_mul(r0, r1, r2, bnctx);\n\tif ((rsa_d_new = BN_mod_inverse(NULL, rsa_e, r0, bnctx)) == NULL) {\n\t\tfprintf(stderr, \"BN_mod_inverse() failed.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* RSA_set0_key will free previous value, and replace with new value\n\t * Thus the need to copy the contents of rsa_n and rsa_e\n\t */\n\trsa_n_new = BN_dup(rsa_n);\n\trsa_e_new = BN_dup(rsa_e);\n\tif (RSA_set0_key(rsa, rsa_n_new, rsa_e_new, rsa_d_new) != 1)\n\t\treturn -1;\n\n\tBN_CTX_end(bnctx);\n\tBN_CTX_free(bnctx);\n\treturn 0;\n}\n\nstatic int parse_private_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *bn_p, *q, *dmp1, *dmq1, *iqmp;\n\tint base;\n\n\tbase = (keysize - 3) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tbn_p = BN_new();\n\tif (bn_p == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, bn_p);\n\tp += base;\n\n\tq = BN_new();\n\tif (q == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, q);\n\tp += base;\n\n\tiqmp = BN_new();\n\tif (iqmp == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, iqmp);\n\tp += base;\n\n\tdmp1 = BN_new();\n\tif (dmp1 == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, dmp1);\n\tp += base;\n\n\tdmq1 = BN_new();\n\tif (dmq1 == NULL)\n\t\treturn -1;\n\tcf2bn(p, base, dmq1);\n\tp += base;\n\n\t\n\tif (RSA_set0_factors(rsa, bn_p, q) != 1)\n\t\treturn -1;\n\tif (RSA_set0_crt_params(rsa, dmp1, dmq1, iqmp) != 1)\n\t\treturn -1;\n\tif (gen_d(rsa))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}\n\n\nstatic int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}\n\nstatic int read_key(void)\n{\n\tRSA *rsa = RSA_new();\n\tu8 buf[1024], *p = buf;\n\tu8 b64buf[2048];\n\tint r;\n\n\tif (rsa == NULL)\n\t\treturn -1;\n\tr = read_public_key(rsa);\n\tif (r)\n\t\treturn r;\n\tr = i2d_RSA_PUBKEY(rsa, &p);\n\tif (r <= 0) {\n\t\tfprintf(stderr, \"Error encoding public key.\\n\");\n\t\treturn -1;\n\t}\n\tr = sc_base64_encode(buf, r, b64buf, sizeof(b64buf), 64);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Error in Base64 encoding: %s\\n\", sc_strerror(r));\n\t\treturn -1;\n\t}\n\tprintf(\"-----BEGIN PUBLIC KEY-----\\n%s-----END PUBLIC KEY-----\\n\", b64buf);\n\n\tr = read_private_key(rsa);\n\tif (r == 10)\n\t\treturn 0;\n\telse if (r)\n\t\treturn r;\n\tp = buf;\n\tr = i2d_RSAPrivateKey(rsa, &p);\n\tif (r <= 0) {\n\t\tfprintf(stderr, \"Error encoding private key.\\n\");\n\t\treturn -1;\n\t}\n\tr = sc_base64_encode(buf, r, b64buf, sizeof(b64buf), 64);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Error in Base64 encoding: %s\\n\", sc_strerror(r));\n\t\treturn -1;\n\t}\n\tprintf(\"-----BEGIN RSA PRIVATE KEY-----\\n%s-----END RSA PRIVATE KEY-----\\n\", b64buf);\n\n\treturn 0;\n}\n\nstatic int list_keys(void)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\tu8 buf[2048], *p = buf;\n\tsize_t keysize, i;\n\tint mod_lens[] = { 512, 768, 1024, 2048 };\n\tsize_t sizes[] = { 167, 247, 327, 647 };\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tdo {\n\t\tint mod_len = -1;\n\n\t\tr = sc_read_binary(card, idx, buf, 3, 0);\n\t\tif (r < 0) {\n\t\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\t\treturn 2;\n\t\t}\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tidx += keysize;\n\t\tfor (i = 0; i < sizeof(sizes)/sizeof(sizes[ 0]); i++)\n\t\t\tif (sizes[i] == keysize)\n\t\t\t\tmod_len = mod_lens[i];\n\t\tif (mod_len < 0)\n\t\t\tprintf(\"Key %d -- unknown modulus length\\n\", p[2] & 0x0F);\n\t\telse\n\t\t\tprintf(\"Key %d -- Modulus length %d\\n\", p[2] & 0x0F, mod_len);\n\t} while (1);\n\treturn 0;\n}\n\nstatic int generate_key(void)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[4];\n\tu8 p2;\n\tint r;\n\n\tswitch (opt_mod_length) {\n\tcase 512:\n\t\tp2 = 0x40;\n\t\tbreak;\n\tcase 768:\n\t\tp2 = 0x60;\n\t\tbreak;\n\tcase 1024:\n\t\tp2 = 0x80;\n\t\tbreak;\n\tcase 2048:\n\t\tp2 = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Invalid modulus length.\\n\");\n\t\treturn 2;\n\t}\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, (u8) opt_key_num-1, p2);\n\tapdu.cla = 0xF0;\n\tapdu.lc = 4;\n\tapdu.datalen = 4;\n\tapdu.data = sbuf;\n\tsbuf[0] = opt_exponent & 0xFF;\n\tsbuf[1] = (opt_exponent >> 8) & 0xFF;\n\tsbuf[2] = (opt_exponent >> 16) & 0xFF;\n\tsbuf[3] = (opt_exponent >> 24) & 0xFF;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tif (verbose)\n\t\tprintf(\"Generating key...\\n\");\n\tr = sc_transmit_apdu(card, &apdu);\n\tif (r) {\n\t\tfprintf(stderr, \"APDU transmit failed: %s\\n\", sc_strerror(r));\n\t\tif (r == SC_ERROR_TRANSMIT_FAILED)\n\t\t\tfprintf(stderr, \"Reader has timed out. It is still possible that the key generation has\\n\"\n\t\t\t\t\t\"succeeded.\\n\");\n\t\treturn 1;\n\t}\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\tprintf(\"Key generation successful.\\n\");\n\t\treturn 0;\n\t}\n\tif (apdu.sw1 == 0x69 && apdu.sw2 == 0x82)\n\t\tfprintf(stderr, \"CHV1 not verified or invalid exponent value.\\n\");\n\telse\n\t\tfprintf(stderr, \"Card returned SW1=%02X, SW2=%02X.\\n\", apdu.sw1, apdu.sw2);\n\treturn 1;\n}\n\nstatic int create_key_files(void)\n{\n\tsc_file_t *file;\n\tint mod_lens[] = { 512, 768, 1024, 2048 };\n\tint sizes[] = { 163, 243, 323, 643 };\n\tint size = -1;\n\tint r;\n\tsize_t i;\n\n\tfor (i = 0; i < sizeof(mod_lens) / sizeof(int); i++)\n\t\tif (mod_lens[i] == opt_mod_length) {\n\t\t\tsize = sizes[i];\n\t\t\tbreak;\n\t\t}\n\tif (size == -1) {\n\t\tfprintf(stderr, \"Invalid modulus length.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (verbose)\n\t\tprintf(\"Creating key files for %d keys.\\n\", opt_key_count);\n\n\tfile = sc_file_new();\n\tif (!file) {\n\t\tfprintf(stderr, \"out of memory.\\n\");\n\t\treturn 1;\n\t}\n\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\n\tfile->id = 0x0012;\n\tfile->size = opt_key_count * size + 3;\n\tsc_file_add_acl_entry(file, SC_AC_OP_READ, SC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_CHV, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE, SC_AC_CHV, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE, SC_AC_CHV, 1);\n\n\tif (select_app_df()) {\n\t\tsc_file_free(file);\n\t\treturn 1;\n\t}\n\tr = sc_create_file(card, file);\n\tsc_file_free(file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to create private key file: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\n\tfile = sc_file_new();\n\tif (!file) {\n\t\tfprintf(stderr, \"out of memory.\\n\");\n\t\treturn 1;\n\t}\n\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\n\tfile->id = 0x1012;\n\tfile->size = opt_key_count * (size + 4) + 3;\n\tsc_file_add_acl_entry(file, SC_AC_OP_READ, SC_AC_NONE, SC_AC_KEY_REF_NONE);\n\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_CHV, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE, SC_AC_CHV, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE, SC_AC_CHV, 1);\n\n\tif (select_app_df()) {\n\t\tsc_file_free(file);\n\t\treturn 1;\n\t}\n\tr = sc_create_file(card, file);\n\tsc_file_free(file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to create public key file: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\tif (verbose)\n\t\tprintf(\"Key files generated successfully.\\n\");\n\treturn 0;\n}\n\nstatic int read_rsa_privkey(RSA **rsa_out)\n{\n\tRSA *rsa = NULL;\n\tBIO *in = NULL;\n\tint r;\n\n\tin = BIO_new(BIO_s_file());\n\tif (opt_prkeyf == NULL) {\n\t\tfprintf(stderr, \"Private key file must be set.\\n\");\n\t\treturn 2;\n\t}\n\tr = BIO_read_filename(in, opt_prkeyf);\n\tif (r <= 0) {\n\t\tperror(opt_prkeyf);\n\t\treturn 2;\n\t}\n\trsa = PEM_read_bio_RSAPrivateKey(in, NULL, NULL, NULL);\n\tif (rsa == NULL) {\n\t\tfprintf(stderr, \"Unable to load private key.\\n\");\n\t\treturn 2;\n\t}\n\tBIO_free(in);\n\t*rsa_out = rsa;\n\treturn 0;\n}\n\nstatic int encode_private_key(RSA *rsa, u8 *key, size_t *keysize)\n{\n\tu8 buf[1024], *p = buf;\n\tu8 bnbuf[256];\n\tint base = 0;\n\tint r;\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_dmp1, *rsa_dmq1, *rsa_iqmp;\n\n\tswitch (RSA_bits(rsa)) {\n\tcase 512:\n\t\tbase = 32;\n\t\tbreak;\n\tcase 768:\n\t\tbase = 48;\n\t\tbreak;\n\tcase 1024:\n\t\tbase = 64;\n\t\tbreak;\n\tcase 2048:\n\t\tbase = 128;\n\t\tbreak;\n\t}\n\tif (base == 0) {\n\t\tfprintf(stderr, \"Key length invalid.\\n\");\n\t\treturn 2;\n\t}\n\t*p++ = (5 * base + 3) >> 8;\n\t*p++ = (5 * base + 3) & 0xFF;\n\t*p++ = opt_key_num;\n\n\tRSA_get0_factors(rsa, &rsa_p, &rsa_q);\n\n\tr = bn2cf(rsa_p, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tr = bn2cf(rsa_q, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tRSA_get0_crt_params(rsa, &rsa_dmp1, &rsa_dmq1, &rsa_iqmp);\n\n\tr = bn2cf(rsa_iqmp, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tr = bn2cf(rsa_dmp1, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tr = bn2cf(rsa_dmq1, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\n\tmemcpy(key, buf, p - buf);\n\t*keysize = p - buf;\n\n\treturn 0;\n}\n\nstatic int encode_public_key(RSA *rsa, u8 *key, size_t *keysize)\n{\n\tu8 buf[1024], *p = buf;\n\tu8 bnbuf[256];\n\tint base = 0;\n\tint r;\n\tconst BIGNUM *rsa_n, *rsa_e;\n\n\tswitch (RSA_bits(rsa)) {\n\tcase 512:\n\t\tbase = 32;\n\t\tbreak;\n\tcase 768:\n\t\tbase = 48;\n\t\tbreak;\n\tcase 1024:\n\t\tbase = 64;\n\t\tbreak;\n\tcase 2048:\n\t\tbase = 128;\n\t\tbreak;\n\t}\n\tif (base == 0) {\n\t\tfprintf(stderr, \"Key length invalid.\\n\");\n\t\treturn 2;\n\t}\n\t*p++ = (5 * base + 7) >> 8;\n\t*p++ = (5 * base + 7) & 0xFF;\n\t*p++ = opt_key_num;\n\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, NULL);\n\tr = bn2cf(rsa_n, bnbuf);\n\tif (r != 2*base) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, 2*base);\n\tp += 2*base;\n\n\tmemset(p, 0, base);\n\tp += base;\n\n\tmemset(bnbuf, 0, 2*base);\n\tmemcpy(p, bnbuf, 2*base);\n\tp += 2*base;\n\tr = bn2cf(rsa_e, bnbuf);\n\tmemcpy(p, bnbuf, 4);\n\tp += 4;\n\n\tmemcpy(key, buf, p - buf);\n\t*keysize = p - buf;\n\n\treturn 0;\n}\n\nstatic int update_public_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write public key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic int update_private_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write private key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic int store_key(void)\n{\n\tu8 prv[1024], pub[1024];\n\tsize_t prvsize, pubsize;\n\tint r;\n\tRSA *rsa;\n\n\tr = read_rsa_privkey(&rsa);\n\tif (r)\n\t\treturn r;\n\tr = encode_private_key(rsa, prv, &prvsize);\n\tif (r)\n\t\treturn r;\n\tr = encode_public_key(rsa, pub, &pubsize);\n\tif (r)\n\t\treturn r;\n\tif (verbose)\n\t\tprintf(\"Storing private key...\\n\");\n\tr = select_app_df();\n\tif (r)\n\t\treturn r;\n\tr = update_private_key(prv, prvsize);\n\tif (r)\n\t\treturn r;\n\tif (verbose)\n\t\tprintf(\"Storing public key...\\n\");\n\tr = select_app_df();\n\tif (r)\n\t\treturn r;\n\tr = update_public_key(pub, pubsize);\n\tif (r)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic int create_pin_file(const sc_path_t *inpath, int chv, const char *key_id)\n{\n\tchar prompt[40], *pin, *puk;\n\tchar buf[30], *p = buf;\n\tsc_path_t file_id, path;\n\tsc_file_t *file;\n\tsize_t len;\n\tint r;\n\n\tfile_id = *inpath;\n\tif (file_id.len < 2)\n\t\treturn -1;\n\tif (chv == 1)\n\t\tsc_format_path(\"I0000\", &file_id);\n\telse if (chv == 2)\n\t\tsc_format_path(\"I0100\", &file_id);\n\telse\n\t\treturn -1;\n\tr = sc_select_file(card, inpath, NULL);\n\tif (r)\n\t\treturn -1;\n\tr = sc_select_file(card, &file_id, NULL);\n\tif (r == 0)\n\t\treturn 0;\n\n\tsprintf(prompt, \"Please enter CHV%d%s: \", chv, key_id);\n\tpin = getpin(prompt);\n\tif (pin == NULL)\n\t\treturn -1;\n\n\tsprintf(prompt, \"Please enter PUK for CHV%d%s: \", chv, key_id);\n\tpuk = getpin(prompt);\n\tif (puk == NULL) {\n\t\tfree(pin);\n\t\treturn -1;\n\t}\n\n\tmemset(p, 0xFF, 3);\n\tp += 3;\n\tmemcpy(p, pin, 8);\n\tp += 8;\n\t*p++ = opt_pin_attempts;\n\t*p++ = opt_pin_attempts;\n\tmemcpy(p, puk, 8);\n\tp += 8;\n\t*p++ = opt_puk_attempts;\n\t*p++ = opt_puk_attempts;\n\tlen = p - buf;\n\n\tfree(pin);\n\tfree(puk);\n\n\tfile = sc_file_new();\n\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\tsc_file_add_acl_entry(file, SC_AC_OP_READ, SC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\tif (inpath->len == 2 && inpath->value[0] == 0x3F &&\n\t    inpath->value[1] == 0x00)\n\t\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_AUT, 1);\n\telse\n\t\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_CHV, 2);\n\n\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE, SC_AC_AUT, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE, SC_AC_AUT, 1);\n\tfile->size = len;\n\tfile->id = (file_id.value[0] << 8) | file_id.value[1];\n\tr = sc_create_file(card, file);\n\tsc_file_free(file);\n\tif (r) {\n\t\tfprintf(stderr, \"PIN file creation failed: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\tpath = *inpath;\n\tsc_append_path(&path, &file_id);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select created PIN file: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\tr = sc_update_binary(card, 0, (const u8 *) buf, len, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to update created PIN file: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_pin(void)\n{\n\tsc_path_t path;\n\tchar buf[80];\n\n\tif (opt_pin_num != 1 && opt_pin_num != 2) {\n\t\tfprintf(stderr, \"Invalid PIN number. Possible values: 1, 2.\\n\");\n\t\treturn 2;\n\t}\n\tstrcpy(buf, \"3F00\");\n\tif (opt_appdf != NULL)\n\t\tstrlcat(buf, opt_appdf, sizeof buf);\n\tsc_format_path(buf, &path);\n\n\treturn create_pin_file(&path, opt_pin_num, \"\");\n}\n\nint main(int argc, char *argv[])\n{\n\tint err = 0, r, c, long_optind = 0;\n\tint action_count = 0;\n\tint do_read_key = 0;\n\tint do_generate_key = 0;\n\tint do_create_key_files = 0;\n\tint do_list_keys = 0;\n\tint do_store_key = 0;\n\tint do_create_pin_file = 0;\n\tsc_context_param_t ctx_param;\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"P:Vslgc:Rk:r:p:u:e:m:vwa:\", options, &long_optind);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tif (c == '?')\n\t\t\tutil_print_usage_and_die(app_name, options, option_help, NULL);\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\tdo_list_keys = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tdo_create_pin_file = 1;\n\t\t\topt_pin_num = atoi(optarg);\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdo_read_key = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tdo_generate_key = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tdo_create_key_files = 1;\n\t\t\topt_key_count = atoi(optarg);\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tdo_store_key = 1;\n\t\t\taction_count++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\topt_key_num = atoi(optarg);\n\t\t\tif (opt_key_num < 1 || opt_key_num > 15) {\n\t\t\t\tfprintf(stderr, \"Key number invalid.\\n\");\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\topt_pin_num = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\topt_exponent = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\topt_mod_length = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\topt_prkeyf = optarg;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\topt_pubkeyf = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\topt_reader = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topt_wait = 1;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\topt_appdf = optarg;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (action_count == 0)\n\t\tutil_print_usage_and_die(app_name, options, option_help, NULL);\n\n\tmemset(&ctx_param, 0, sizeof(ctx_param));\n\tctx_param.ver      = 0;\n\tctx_param.app_name = app_name;\n\n\tr = sc_context_create(&ctx, &ctx_param);\n\tif (r) {\n\t\tfprintf(stderr, \"Failed to establish context: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\n\tif (verbose > 1) {\n\t\tctx->debug = verbose;\n\t\tsc_ctx_log_to_file(ctx, \"stderr\");\n\t}\n\n\terr = util_connect_card(ctx, &card, opt_reader, opt_wait, verbose);\n\tprintf(\"Using card driver: %s\\n\", card->driver->name);\n\n\tif (do_create_pin_file) {\n\t\tif ((err = create_pin()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_create_key_files) {\n\t\tif ((err = create_key_files()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_generate_key) {\n\t\tif ((err = generate_key()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_store_key) {\n\t\tif ((err = store_key()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_list_keys) {\n\t\tif ((err = list_keys()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (do_read_key) {\n\t\tif ((err = read_key()) != 0)\n\t\t\tgoto end;\n\t\taction_count--;\n\t}\n\tif (pincode != NULL) {\n\t\tmemset(pincode, 0, 8);\n\t\tfree(pincode);\n\t}\nend:\n\tif (card) {\n\t\tsc_unlock(card);\n\t\tsc_disconnect_card(card);\n\t}\n\tif (ctx)\n\t\tsc_release_context(ctx);\n\treturn err;\n}\n", "/*\n * Copyright (C) 2017 Frank Morgner <frankmorgner@gmail.com>\n *\n * This file is part of OpenSC.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"egk-tool-cmdline.h\"\n#include \"libopensc/log.h\"\n#include \"libopensc/opensc.h\"\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <io.h>\n#include <fcntl.h>\n#endif\n\n#ifdef ENABLE_ZLIB\n#include <zlib.h>\n\nint uncompress_gzip(void* uncompressed, size_t *uncompressed_len,\n\t\tconst void* compressed, size_t compressed_len)\n{\n\tz_stream stream;\n\tmemset(&stream, 0, sizeof stream);\n\tstream.total_in = compressed_len;\n\tstream.avail_in = compressed_len;\n\tstream.total_out = *uncompressed_len;\n\tstream.avail_out = *uncompressed_len;\n\tstream.next_in = (Bytef *) compressed;\n\tstream.next_out = (Bytef *) uncompressed;\n\n\t/* 15 window bits, and the +32 tells zlib to to detect if using gzip or zlib */\n\tif (Z_OK == inflateInit2(&stream, (15 + 32))\n\t\t\t&& Z_STREAM_END == inflate(&stream, Z_FINISH)) {\n\t\t*uncompressed_len = stream.total_out;\n\t} else {\n\t\treturn SC_ERROR_INVALID_DATA;\n\t}\n\tinflateEnd(&stream);\n\n\treturn SC_SUCCESS;\n}\n#else\nint uncompress_gzip(void* uncompressed, size_t *uncompressed_len,\n\t\tconst void* compressed, size_t compressed_len)\n{\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n#endif\n\n#define PRINT(c) (isprint(c) ? c : '?')\n\nvoid dump_binary(void *buf, size_t buf_len)\n{\n#ifdef _WIN32\n\t_setmode(fileno(stdout), _O_BINARY);\n#endif\n\tfwrite(buf, 1, buf_len, stdout);\n#ifdef _WIN32\n\t_setmode(fileno(stdout), _O_TEXT);\n#endif\n}\n\nconst unsigned char aid_hca[] = {0xD2, 0x76, 0x00, 0x00, 0x01, 0x02};\n\nstatic int initialize(int reader_id, int verbose,\n\t\tsc_context_t **ctx, sc_reader_t **reader)\n{\n\tunsigned int i, reader_count;\n\tint r;\n\n\tif (!ctx || !reader)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tr = sc_establish_context(ctx, \"\");\n\tif (r < 0 || !*ctx) {\n\t\tfprintf(stderr, \"Failed to create initial context: %s\", sc_strerror(r));\n\t\treturn r;\n\t}\n\n\t(*ctx)->debug = verbose;\n\t(*ctx)->flags |= SC_CTX_FLAG_ENABLE_DEFAULT_DRIVER;\n\n\treader_count = sc_ctx_get_reader_count(*ctx);\n\n\tif (reader_count == 0) {\n\t\tsc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"No reader not found.\\n\");\n\t\treturn SC_ERROR_NO_READERS_FOUND;\n\t}\n\n\tif (reader_id < 0) {\n\t\t/* Automatically try to skip to a reader with a card if reader not specified */\n\t\tfor (i = 0; i < reader_count; i++) {\n\t\t\t*reader = sc_ctx_get_reader(*ctx, i);\n\t\t\tif (sc_detect_card_presence(*reader) & SC_READER_CARD_PRESENT) {\n\t\t\t\treader_id = i;\n\t\t\t\tsc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"Using the first reader\"\n\t\t\t\t\t\t\" with a card: %s\", (*reader)->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((unsigned int) reader_id >= reader_count) {\n\t\t\tsc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"No card found, using the first reader.\");\n\t\t\treader_id = 0;\n\t\t}\n\t}\n\n\tif ((unsigned int) reader_id >= reader_count) {\n\t\tsc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"Invalid reader number \"\n\t\t\t\t\"(%d), only %d available.\\n\", reader_id, reader_count);\n\t\treturn SC_ERROR_NO_READERS_FOUND;\n\t}\n\n\t*reader = sc_ctx_get_reader(*ctx, reader_id);\n\n\treturn SC_SUCCESS;\n}\n\nint read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}\n\nvoid decode_version(unsigned char *bcd, unsigned int *major, unsigned int *minor, unsigned int *fix)\n{\n\t*major = 0;\n\t*minor = 0;\n\t*fix = 0;\n\n\t/* decode BCD to decimal */\n\tif ((bcd[0]>>4) < 10 && ((bcd[0]&0xF) < 10) && ((bcd[1]>>4) < 10)) {\n\t\t*major = (bcd[0]>>4)*100 + (bcd[0]&0xF)*10 + (bcd[1]>>4);\n\t}\n\tif (((bcd[1]&0xF) < 10) && ((bcd[2]>>4) < 10) && ((bcd[2]&0xF) < 10)) {\n\t\t*minor = (bcd[1]&0xF)*100 + (bcd[2]>>4)*10 + (bcd[2]&0xF);\n\t}\n\tif ((bcd[3]>>4) < 10 && ((bcd[3]&0xF) < 10)\n\t\t\t&& (bcd[4]>>4) < 10 && ((bcd[4]&0xF) < 10)) {\n\t\t*fix = (bcd[3]>>4)*1000 + (bcd[3]&0xF)*100\n\t\t\t+ (bcd[4]>>4)*10 + (bcd[4]&0xF);\n\t}\n}\n\nint\nmain (int argc, char **argv)\n{\n\tstruct gengetopt_args_info cmdline;\n\tstruct sc_path path;\n\tstruct sc_context *ctx;\n\tstruct sc_reader *reader = NULL;\n\tstruct sc_card *card;\n\tunsigned char *data = NULL;\n\tsize_t data_len = 0;\n\tint r;\n\n\tif (cmdline_parser(argc, argv, &cmdline) != 0)\n\t\texit(1);\n\n\tr = initialize(cmdline.reader_arg, cmdline.verbose_given, &ctx, &reader);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Can't initialize reader\\n\");\n\t\texit(1);\n\t}\n\n\tif (sc_connect_card(reader, &card) < 0) {\n\t\tfprintf(stderr, \"Could not connect to card\\n\");\n\t\tsc_release_context(ctx);\n\t\texit(1);\n\t}\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, aid_hca, sizeof aid_hca, 0, 0);\n\tif (SC_SUCCESS != sc_select_file(card, &path, NULL))\n\t\tgoto err;\n\n\tif (cmdline.pd_flag\n\t\t\t&& read_file(card, \"D001\", &data, &data_len)\n\t\t\t&& data_len >= 2) {\n\t\tsize_t len_pd = (data[0] << 8) | data[1];\n\n\t\tif (len_pd + 2 <= data_len) {\n\t\t\tunsigned char uncompressed[1024];\n\t\t\tsize_t uncompressed_len = sizeof uncompressed;\n\n\t\t\tif (uncompress_gzip(uncompressed, &uncompressed_len,\n\t\t\t\t\t\tdata + 2, len_pd) == SC_SUCCESS) {\n\t\t\t\tdump_binary(uncompressed, uncompressed_len);\n\t\t\t} else {\n\t\t\t\tdump_binary(data + 2, len_pd);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((cmdline.vd_flag || cmdline.gvd_flag)\n\t\t\t&& read_file(card, \"D001\", &data, &data_len)\n\t\t\t&& data_len >= 8) {\n\t\tsize_t off_vd  = (data[0] << 8) | data[1];\n\t\tsize_t end_vd  = (data[2] << 8) | data[3];\n\t\tsize_t off_gvd = (data[4] << 8) | data[5];\n\t\tsize_t end_gvd = (data[6] << 8) | data[7];\n\t\tsize_t len_vd = end_vd - off_vd + 1;\n\t\tsize_t len_gvd = end_gvd - off_gvd + 1;\n\n\t\tif (off_vd <= end_vd && end_vd < data_len\n\t\t\t\t&& off_gvd <= end_gvd && end_gvd < data_len) {\n\t\t\tunsigned char uncompressed[1024];\n\t\t\tsize_t uncompressed_len = sizeof uncompressed;\n\n\t\t\tif (cmdline.vd_flag) {\n\t\t\t\tif (uncompress_gzip(uncompressed, &uncompressed_len,\n\t\t\t\t\t\t\tdata + off_vd, len_vd) == SC_SUCCESS) {\n\t\t\t\t\tdump_binary(uncompressed, uncompressed_len);\n\t\t\t\t} else {\n\t\t\t\t\tdump_binary(data + off_vd, len_vd);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cmdline.gvd_flag) {\n\t\t\t\tif (uncompress_gzip(uncompressed, &uncompressed_len,\n\t\t\t\t\t\t\tdata + off_gvd, len_gvd) == SC_SUCCESS) {\n\t\t\t\t\tdump_binary(uncompressed, uncompressed_len);\n\t\t\t\t} else {\n\t\t\t\t\tdump_binary(data + off_gvd, len_gvd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmdline.vsd_status_flag\n\t\t\t&& read_file(card, \"D00C\", &data, &data_len)\n\t\t\t&& data_len >= 25) {\n\t\tchar *status;\n\t\tunsigned int major, minor, fix;\n\n\t\tswitch (data[0]) {\n\t\t\tcase '0':\n\t\t\t\tstatus = \"Transactions pending\";\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\tstatus = \"No transactions pending\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstatus = \"Unknown\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdecode_version(data+15, &major, &minor, &fix);\n\n\t\tprintf(\n\t\t\t\t\"Status      %s\\n\"\n\t\t\t\t\"Timestamp   %c%c.%c%c.%c%c%c%c at %c%c:%c%c:%c%c\\n\"\n\t\t\t\t\"Version     %u.%u.%u\\n\",\n\t\t\t\tstatus,\n\t\t\t\tPRINT(data[7]), PRINT(data[8]),\n\t\t\t\tPRINT(data[5]), PRINT(data[6]),\n\t\t\t\tPRINT(data[1]), PRINT(data[2]), PRINT(data[3]), PRINT(data[4]),\n\t\t\t\tPRINT(data[9]), PRINT(data[10]),\n\t\t\t\tPRINT(data[11]), PRINT(data[12]),\n\t\t\t\tPRINT(data[13]), PRINT(data[14]),\n\t\t\t\tmajor, minor, fix);\n\t}\n\nerr:\n\tsc_disconnect_card(card);\n\tsc_release_context(ctx);\n\tcmdline_parser_free (&cmdline);\n\n\treturn 0;\n}\n", "/*\n * util.c: utility functions used by OpenSC command line tools.\n *\n * Copyright (C) 2011 OpenSC Project developers\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#ifndef _WIN32\n#include <termios.h>\n#else\n#include <conio.h>\n#endif\n#include <ctype.h>\n#include \"util.h\"\n#include \"ui/notify.h\"\n\nint\nis_string_valid_atr(const char *atr_str)\n{\n\tunsigned char atr[SC_MAX_ATR_SIZE];\n\tsize_t atr_len = sizeof(atr);\n\n\tif (sc_hex_to_bin(atr_str, atr, &atr_len))\n\t\treturn 0;\n\tif (atr_len < 2)\n\t\treturn 0;\n\tif (atr[0] != 0x3B && atr[0] != 0x3F)\n\t\treturn 0;\n\treturn 1;\n}\n\nint\nutil_connect_card_ex(sc_context_t *ctx, sc_card_t **cardp,\n\t\t const char *reader_id, int do_wait, int do_lock, int verbose)\n{\n\tstruct sc_reader *reader = NULL, *found = NULL;\n\tstruct sc_card *card = NULL;\n\tint r;\n\n\tsc_notify_init();\n\n\tif (do_wait) {\n\t\tunsigned int event;\n\n\t\tif (sc_ctx_get_reader_count(ctx) == 0) {\n\t\t\tfprintf(stderr, \"Waiting for a reader to be attached...\\n\");\n\t\t\tr = sc_wait_for_event(ctx, SC_EVENT_READER_ATTACHED, &found, &event, -1, NULL);\n\t\t\tif (r < 0) {\n\t\t\t\tfprintf(stderr, \"Error while waiting for a reader: %s\\n\", sc_strerror(r));\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t\tr = sc_ctx_detect_readers(ctx);\n\t\t\tif (r < 0) {\n\t\t\t\tfprintf(stderr, \"Error while refreshing readers: %s\\n\", sc_strerror(r));\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"Waiting for a card to be inserted...\\n\");\n\t\tr = sc_wait_for_event(ctx, SC_EVENT_CARD_INSERTED, &found, &event, -1, NULL);\n\t\tif (r < 0) {\n\t\t\tfprintf(stderr, \"Error while waiting for a card: %s\\n\", sc_strerror(r));\n\t\t\treturn 3;\n\t\t}\n\t\treader = found;\n\t}\n\telse if (sc_ctx_get_reader_count(ctx) == 0) {\n\t\tfprintf(stderr, \"No smart card readers found.\\n\");\n\t\treturn 1;\n\t}\n\telse   {\n\t\tif (!reader_id) {\n\t\t\tunsigned int i;\n\t\t\t/* Automatically try to skip to a reader with a card if reader not specified */\n\t\t\tfor (i = 0; i < sc_ctx_get_reader_count(ctx); i++) {\n\t\t\t\treader = sc_ctx_get_reader(ctx, i);\n\t\t\t\tif (sc_detect_card_presence(reader) & SC_READER_CARD_PRESENT) {\n\t\t\t\t\tfprintf(stderr, \"Using reader with a card: %s\\n\", reader->name);\n\t\t\t\t\tgoto autofound;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If no reader had a card, default to the first reader */\n\t\t\treader = sc_ctx_get_reader(ctx, 0);\n\t\t}\n\t\telse {\n\t\t\t/* If the reader identifier looks like an ATR, try to find the reader with that card */\n\t\t\tif (is_string_valid_atr(reader_id))   {\n\t\t\t\tunsigned char atr_buf[SC_MAX_ATR_SIZE];\n\t\t\t\tsize_t atr_buf_len = sizeof(atr_buf);\n\t\t\t\tunsigned int i;\n\n\t\t\t\tsc_hex_to_bin(reader_id, atr_buf, &atr_buf_len);\n\t\t\t\t/* Loop readers, looking for a card with ATR */\n\t\t\t\tfor (i = 0; i < sc_ctx_get_reader_count(ctx); i++) {\n\t\t\t\t\tstruct sc_reader *rdr = sc_ctx_get_reader(ctx, i);\n\n\t\t\t\t\tif (!(sc_detect_card_presence(rdr) & SC_READER_CARD_PRESENT))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (rdr->atr.len != atr_buf_len)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (memcmp(rdr->atr.value, atr_buf, rdr->atr.len))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfprintf(stderr, \"Matched ATR in reader: %s\\n\", rdr->name);\n\t\t\t\t\treader = rdr;\n\t\t\t\t\tgoto autofound;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tchar *endptr = NULL;\n\t\t\t\tunsigned int num;\n\n\t\t\t\terrno = 0;\n\t\t\t\tnum = strtol(reader_id, &endptr, 0);\n\t\t\t\tif (!errno && endptr && *endptr == '\\0')\n\t\t\t\t\treader = sc_ctx_get_reader(ctx, num);\n\t\t\t\telse\n\t\t\t\t\treader = sc_ctx_get_reader_by_name(ctx, reader_id);\n\t\t\t}\n\t\t}\nautofound:\n\t\tif (!reader) {\n\t\t\tfprintf(stderr, \"Reader \\\"%s\\\" not found (%d reader(s) detected)\\n\",\n\t\t\t\t\treader_id, sc_ctx_get_reader_count(ctx));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (sc_detect_card_presence(reader) <= 0) {\n\t\t\tfprintf(stderr, \"Card not present.\\n\");\n\t\t\treturn 3;\n\t\t}\n\t}\n\n\tif (verbose)\n\t\tprintf(\"Connecting to card in reader %s...\\n\", reader->name);\n\tr = sc_connect_card(reader, &card);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Failed to connect to card: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\n\tif (verbose)\n\t\tprintf(\"Using card driver %s.\\n\", card->driver->name);\n\n\tif (do_lock) {\n\t\tr = sc_lock(card);\n\t\tif (r < 0) {\n\t\t\tfprintf(stderr, \"Failed to lock card: %s\\n\", sc_strerror(r));\n\t\t\tsc_disconnect_card(card);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t*cardp = card;\n\treturn 0;\n}\n\nint\nutil_connect_card(sc_context_t *ctx, sc_card_t **cardp,\n\t\t const char *reader_id, int do_wait, int verbose)\n{\n\treturn util_connect_card_ex(ctx, cardp, reader_id, do_wait, 1, verbose);\n}\n\nvoid util_print_binary(FILE *f, const u8 *buf, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned char c = buf[i];\n\t\tconst char *format;\n\t\tif (!isprint(c))\n\t\t\tformat = \"\\\\x%02X\";\n\t\telse\n\t\t\tformat = \"%c\";\n\t\tfprintf(f, format, c);\n\t}\n\t(void) fflush(f);\n}\n\nvoid util_hex_dump(FILE *f, const u8 *in, int len, const char *sep)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (sep != NULL && i)\n\t\t\tfprintf(f, \"%s\", sep);\n\t\tfprintf(f, \"%02X\", in[i]);\n\t}\n}\n\nvoid util_hex_dump_asc(FILE *f, const u8 *in, size_t count, int addr)\n{\n\tint lines = 0;\n\n \twhile (count) {\n\t\tchar ascbuf[17];\n\t\tsize_t i;\n\n\t\tif (addr >= 0) {\n\t\t\tfprintf(f, \"%08X: \", addr);\n\t\t\taddr += 16;\n\t\t}\n\t\tfor (i = 0; i < count && i < 16; i++) {\n\t\t\tfprintf(f, \"%02X \", *in);\n\t\t\tif (isprint(*in))\n\t\t\t\tascbuf[i] = *in;\n\t\t\telse\n\t\t\t\tascbuf[i] = '.';\n\t\t\tin++;\n\t\t}\n\t\tcount -= i;\n\t\tascbuf[i] = 0;\n\t\tfor (; i < 16 && lines; i++)\n\t\t\tfprintf(f, \"   \");\n\t\tfprintf(f, \"%s\\n\", ascbuf);\n\t\tlines++;\n\t}\n}\n\nNORETURN void\nutil_print_usage_and_die(const char *app_name, const struct option options[],\n\tconst char *option_help[], const char *args)\n{\n\tint i;\n\tint header_shown = 0;\n\n\tif (args)\n\t\tprintf(\"Usage: %s [OPTIONS] %s\\n\", app_name, args);\n\telse\n\t\tprintf(\"Usage: %s [OPTIONS]\\n\", app_name);\n\n\tfor (i = 0; options[i].name; i++) {\n\t\tchar buf[40];\n\t\tconst char *arg_str;\n\n\t\t/* Skip \"hidden\" options */\n\t\tif (option_help[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif (!header_shown++)\n\t\t\tprintf(\"Options:\\n\");\n\n\t\tswitch (options[i].has_arg) {\n\t\tcase 1:\n\t\t\targ_str = \" <arg>\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\targ_str = \" [arg]\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targ_str = \"\";\n\t\t\tbreak;\n\t\t}\n\t\tif (isascii(options[i].val) &&\n\t\t    isprint(options[i].val) && !isspace(options[i].val))\n\t\t\tsprintf(buf, \"-%c, --%s%s\", options[i].val, options[i].name, arg_str);\n\t\telse\n\t\t\tsprintf(buf, \"    --%s%s\", options[i].name, arg_str);\n\n\t\t/* print the line - wrap if necessary */\n\t\tif (strlen(buf) > 28) {\n\t\t\tprintf(\"  %s\\n\", buf);\n\t\t\tbuf[0] = '\\0';\n\t\t}\n\t\tprintf(\"  %-28s  %s\\n\", buf, option_help[i]);\n\t}\n\n\texit(2);\n}\n\nconst char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}\n\nNORETURN void\nutil_fatal(const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"error: \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\nAborting.\\n\");\n\tva_end(ap);\n\n\tsc_notify_close();\n\n\texit(1);\n}\n\nvoid\nutil_error(const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"error: \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n\nvoid\nutil_warn(const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"warning: \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n\nint\nutil_getpass (char **lineptr, size_t *len, FILE *stream)\n{\n#define MAX_PASS_SIZE\t128\n\tchar *buf;\n\tsize_t i;\n\tint ch = 0;\n#ifndef _WIN32\n\tstruct termios old, new;\n\n\tfflush(stdout);\n\tif (tcgetattr (fileno (stdout), &old) != 0)\n\t\treturn -1;\n\tnew = old;\n\tnew.c_lflag &= ~ECHO;\n\tif (tcsetattr (fileno (stdout), TCSAFLUSH, &new) != 0)\n\t\treturn -1;\n#endif\n\n\tbuf = calloc(1, MAX_PASS_SIZE);\n\tif (!buf)\n\t\treturn -1;\n\n\tfor (i = 0; i < MAX_PASS_SIZE - 1; i++) {\n#ifndef _WIN32\n\t\tch = getchar();\n#else\n\t\tch = _getch();\n#endif\n\t\tif (ch == 0 || ch == 3)\n\t\t\tbreak;\n\t\tif (ch == '\\n' || ch == '\\r')\n\t\t\tbreak;\n\n\t\tbuf[i] = (char) ch;\n\t}\n#ifndef _WIN32\n\ttcsetattr (fileno (stdout), TCSAFLUSH, &old);\n\tfputs(\"\\n\", stdout);\n#endif\n\tif (ch == 0 || ch == 3) {\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\n\tif (*lineptr && (!len || *len < i+1)) {\n\t\tfree(*lineptr);\n\t\t*lineptr = NULL;\n\t}\n\n\tif (*lineptr) {\n\t\tmemcpy(*lineptr,buf,i+1);\n\t\tmemset(buf, 0, MAX_PASS_SIZE);\n\t\tfree(buf);\n\t} else {\n\t\t*lineptr = buf;\n\t\tif (len)\n\t\t\t*len = MAX_PASS_SIZE;\n\t}\n\treturn i;\n}\n\nsize_t\nutil_get_pin(const char *input, const char **pin)\n{\n\tsize_t inputlen = strlen(input);\n\tsize_t pinlen = 0;\n\n\tif(inputlen > 4 && strncasecmp(input, \"env:\", 4) == 0) {\n\t\t// Get a PIN from a environment variable\n\t\t*pin = getenv(input + 4);\n\t\tpinlen = *pin ? strlen(*pin) : 0;\n\t} else {\n\t\t//Just use the input\n\t\t*pin = input;\n\t\tpinlen = inputlen;\n\t}\n\treturn pinlen;\n}\n"], "filenames": ["src/libopensc/card-cac.c", "src/libopensc/card-epass2003.c", "src/libopensc/card-muscle.c", "src/libopensc/card-tcos.c", "src/libopensc/pkcs15-esteid.c", "src/libopensc/pkcs15-gemsafeV1.c", "src/libopensc/pkcs15-sc-hsm.c", "src/libopensc/sc.c", "src/tools/cryptoflex-tool.c", "src/tools/egk-tool.c", "src/tools/util.c"], "buggy_code_start_loc": [797, 954, 521, 411, 82, 211, 840, 631, 23, 152, 342], "buggy_code_end_loc": [798, 979, 531, 437, 83, 212, 846, 632, 386, 153, 345], "fixing_code_start_loc": [797, 954, 521, 411, 82, 211, 840, 631, 24, 152, 342], "fixing_code_end_loc": [798, 981, 534, 437, 83, 212, 848, 632, 387, 153, 347], "type": "CWE-119", "message": "A single byte buffer overflow when handling responses from an esteid Card in sc_pkcs15emu_esteid_init in libopensc/pkcs15-esteid.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.", "other": {"cve": {"id": "CVE-2018-16422", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-04T00:29:00.777", "lastModified": "2019-08-06T17:15:27.587", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A single byte buffer overflow when handling responses from an esteid Card in sc_pkcs15emu_esteid_init in libopensc/pkcs15-esteid.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer por \u00fanico byte al manejar las respuestas de una esteid Card en sc_pkcs15emu_esteid_init en libopensc/pkcs15-esteid.c en OpenSC en versiones anteriores a la 0.19.0-rc1 podr\u00edan ser empleados por atacantes para proporcionar smartcards manipuladas para provocar una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n) o, posiblemente, otro tipo de impacto sin especificar."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.18.0", "matchCriteriaId": "85C3EC93-1A01-4E7D-9730-F8429C1CD145"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2154", "source": "cve@mitre.org"}, {"url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d64c08c80437cf0006ada91e50f20ba0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/releases/tag/0.19.0-rc1", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00009.html", "source": "cve@mitre.org"}, {"url": "https://www.x41-dsec.de/lab/advisories/x41-2018-002-OpenSC/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d64c08c80437cf0006ada91e50f20ba0"}}