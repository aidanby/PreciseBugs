{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid co64_box_del(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr;\n\tptr = (GF_ChunkLargeOffsetBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\nGF_Err co64_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\n\tif ((u64)ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in co64\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->offsets = (u64 *) gf_malloc(ptr->nb_entries * sizeof(u64) );\n\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\tptr->alloc_size = ptr->nb_entries;\n\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\tptr->offsets[entries] = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *co64_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkLargeOffsetBox, GF_ISOM_BOX_TYPE_CO64);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err co64_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err co64_box_size(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cprt_box_del(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->notice)\n\t\tgf_free(ptr->notice);\n\tgf_free(ptr);\n}\n\n\nGF_Box *chpl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChapterListBox, GF_ISOM_BOX_TYPE_CHPL);\n\ttmp->list = gf_list_new();\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid chpl_box_del(GF_Box *s)\n{\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\tif (ptr == NULL) return;\n\twhile (gf_list_count(ptr->list)) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, 0);\n\t}\n\tgf_list_del(ptr->list);\n\tgf_free(ptr);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err chpl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 9)\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (ptr->size<len) return GF_ISOM_INVALID_FILE;\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ce->name) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chpl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tcount = gf_list_count(ptr->list);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 len;\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tgf_bs_write_u64(bs, ce->start_time);\n\t\tif (ce->name) {\n\t\t\tlen = (u32) strlen(ce->name);\n\t\t\tif (len>255) len = 255;\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ce->name, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chpl_box_size(GF_Box *s)\n{\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tptr->size += 5;\n\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tptr->size += 9; /*64bit time stamp + 8bit str len*/\n\t\tif (ce->name) ptr->size += strlen(ce->name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Err cprt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguageCode[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[2] = gf_bs_read_int(bs, 5);\n\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguageCode[0] || ptr->packedLanguageCode[1] || ptr->packedLanguageCode[2]) {\n\t\tptr->packedLanguageCode[0] += 0x60;\n\t\tptr->packedLanguageCode[1] += 0x60;\n\t\tptr->packedLanguageCode[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguageCode[0] = 'u';\n\t\tptr->packedLanguageCode[1] = 'n';\n\t\tptr->packedLanguageCode[2] = 'd';\n\t}\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tptr->notice = (char*)gf_malloc((bytesToRead+1) * sizeof(char));\n\t\tif (ptr->notice == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->notice, bytesToRead);\n\t\tptr->notice[bytesToRead] = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *cprt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CopyrightBox, GF_ISOM_BOX_TYPE_CPRT);\n\ttmp->packedLanguageCode[0] = 'u';\n\ttmp->packedLanguageCode[1] = 'n';\n\ttmp->packedLanguageCode[2] = 'd';\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cprt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 1);\n\tif (ptr->packedLanguageCode[0]) {\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[0] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[1] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[2] - 0x60, 5);\n\t} else {\n\t\tgf_bs_write_int(bs, 0, 15);\n\t}\n\tif (ptr->notice) {\n\t\tgf_bs_write_data(bs, ptr->notice, (u32) (strlen(ptr->notice) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err cprt_box_size(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tptr->size += 2;\n\tif (ptr->notice)\n\t\tptr->size += strlen(ptr->notice) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid kind_box_del(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->schemeURI) gf_free(ptr->schemeURI);\n\tif (ptr->value) gf_free(ptr->value);\n\tgf_free(ptr);\n}\n\nGF_Err kind_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tchar *data;\n\t\tu32 schemeURIlen;\n\t\tdata = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, data, bytesToRead);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (data[bytesToRead-1]) {\n\t\t\tdata = (char*)gf_realloc(data, sizeof(char)*(bytesToRead + 1));\n\t\t\tif (!data) return GF_OUT_OF_MEM;\n\t\t\tdata[bytesToRead] = 0;\n\t\t\tbytesToRead++;\n\t\t}\n\t\tptr->schemeURI = gf_strdup(data);\n\t\tif (!ptr->schemeURI) return GF_OUT_OF_MEM;\n\t\tschemeURIlen = (u32) strlen(data);\n\t\tif (bytesToRead > schemeURIlen+1) {\n\t\t\t/* read the value */\n\t\t\tchar *data_value = data + schemeURIlen +1;\n\t\t\tptr->value = gf_strdup(data_value);\n\t\t\tif (!ptr->value) return GF_OUT_OF_MEM;\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *kind_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_KindBox, GF_ISOM_BOX_TYPE_KIND);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err kind_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->schemeURI)\n        gf_bs_write_data(bs, ptr->schemeURI, (u32) (strlen(ptr->schemeURI) + 1 ));\n    else\n        gf_bs_write_u8(bs, 0);\n\n    if (ptr->value) {\n\t\tgf_bs_write_data(bs, ptr->value, (u32) (strlen(ptr->value) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err kind_box_size(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n    ptr->size += (ptr->schemeURI ? strlen(ptr->schemeURI) : 0) + 1;\n\tif (ptr->value) {\n\t\tptr->size += strlen(ptr->value) + 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ctts_box_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\n\t\tif (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) {\n\t\t\tptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset);\n\t\t\tptr->sample_num_max_cts_delta = sampleCount;\n\t\t}\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *ctts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionOffsetBox, GF_ISOM_BOX_TYPE_CTTS);\n\treturn (GF_Box *) tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ctts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tif (ptr->version) {\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].decodingOffset, 32);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->entries[i].decodingOffset);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ctts_box_size(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cslg_box_del(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err cslg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->compositionToDTSShift = gf_bs_read_int(bs, 32);\n\tptr->leastDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->greatestDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->compositionStartTime = gf_bs_read_int(bs, 32);\n\tptr->compositionEndTime = gf_bs_read_int(bs, 32);\n\treturn GF_OK;\n}\n\nGF_Box *cslg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionToDecodeBox, GF_ISOM_BOX_TYPE_CSLG);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cslg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->compositionToDTSShift, 32);\n\tgf_bs_write_int(bs, ptr->leastDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->greatestDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->compositionStartTime, 32);\n\tgf_bs_write_int(bs, ptr->compositionEndTime, 32);\n\treturn GF_OK;\n}\n\nGF_Err cslg_box_size(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->size += 20;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ccst_box_del(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tif (ptr) gf_free(ptr);\n\treturn;\n}\n\nGF_Err ccst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);\n\tptr->intra_pred_used = gf_bs_read_int(bs, 1);\n\tptr->max_ref_per_pic = gf_bs_read_int(bs, 4);\n\tptr->reserved = gf_bs_read_int(bs, 26);\n\treturn GF_OK;\n}\n\nGF_Box *ccst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CodingConstraintsBox, GF_ISOM_BOX_TYPE_CCST);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ccst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->all_ref_pics_intra, 1);\n\tgf_bs_write_int(bs, ptr->intra_pred_used, 1);\n\tgf_bs_write_int(bs, ptr->max_ref_per_pic, 4);\n\tgf_bs_write_int(bs, 0, 26);\n\treturn GF_OK;\n}\n\nGF_Err ccst_box_size(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid url_box_del(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 location_size = (u32) ptr->size;\n\t\tif (location_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->location = (char*)gf_malloc(location_size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, location_size);\n\t\tif (ptr->location[location_size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *url_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURLBox, GF_ISOM_BOX_TYPE_URL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err url_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err url_box_size(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid urn_box_del(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tif (ptr->nameURN) gf_free(ptr->nameURN);\n\tgf_free(ptr);\n}\n\n\nGF_Err urn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\t//OK, this has both URN and URL\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\n\tif (tmpName[to_read - 1] != 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] urn box contains invalid location field\\n\" ));\n\t}\n\telse {\n\t\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\t\tif (!ptr->location) {\n\t\t\tgf_free(tmpName);\n\t\t\tgf_free(ptr->nameURN);\n\t\t\tptr->nameURN = NULL;\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\t}\n\n\tgf_free(tmpName);\n\treturn GF_OK;\n}\n\nGF_Box *urn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURNBox, GF_ISOM_BOX_TYPE_URN);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err urn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\t//to check, the spec says: First name, then location\n\t\tif (ptr->nameURN) {\n\t\t\tgf_bs_write_data(bs, ptr->nameURN, (u32)strlen(ptr->nameURN) + 1);\n\t\t}\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err urn_box_size(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->nameURN) ptr->size += 1 + strlen(ptr->nameURN);\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid unkn_box_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 bytesToRead, sub_size, sub_a;\n\tGF_BitStream *sub_bs;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (!bytesToRead) return GF_OK;\n\tif (bytesToRead>1000000) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unknown box %s (0x%08X) with payload larger than 1 MBytes, ignoring\\n\", gf_4cc_to_str(ptr->type), ptr->type ));\n\t\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\t\treturn GF_OK;\n\t}\n\n\tptr->data = (char*)gf_malloc(bytesToRead);\n\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\tptr->dataSize = bytesToRead;\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\n\t//try to parse container boxes, check if next 8 bytes match a subbox\n\tsub_bs = gf_bs_new(ptr->data, ptr->dataSize, GF_BITSTREAM_READ);\n\tsub_size = gf_bs_read_u32(sub_bs);\n\tsub_a = gf_bs_read_u8(sub_bs);\n\te = (sub_size && (sub_size <= ptr->dataSize)) ? GF_OK : GF_NOT_SUPPORTED;\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\n\tif (e == GF_OK) {\n\t\tgf_bs_seek(sub_bs, 0);\n\t\tgf_bs_set_cookie(sub_bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(s, sub_bs);\n\t}\n\tgf_bs_del(sub_bs);\n\tif (e==GF_OK) {\n\t\tgf_free(ptr->data);\n\t\tptr->data = NULL;\n\t\tptr->dataSize = 0;\n\t} else if (s->child_boxes) {\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *unkn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownBox, GF_ISOM_BOX_TYPE_UNKNOWN);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 type;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\ttype = s->type;\n\tptr->type = ptr->original_4cc;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = type;\n\tif (e) return e;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err unkn_box_size(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_parent_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err def_parent_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_full_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_full_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_full_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_parent_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err def_parent_full_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid uuid_box_del(GF_Box *s)\n{\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err uuid_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead);\n\t\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\t\tptr->dataSize = bytesToRead;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *uuid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownUUIDBox, GF_ISOM_BOX_TYPE_UUID);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err uuid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err uuid_box_size(GF_Box *s)\n{\n\tGF_UnknownUUIDBox*ptr = (GF_UnknownUUIDBox*)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dinf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_DREF:\n\t\tBOX_FIELD_ASSIGN(dref, GF_DataReferenceBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataInformationBox *dinf;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) {\n\t\treturn e;\n\t}\n\tdinf = (GF_DataInformationBox *)s;\n\tif (!dinf->dref) {\n\t\tif (! (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t}\n\t\tdinf->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *dinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataInformationBox, GF_ISOM_BOX_TYPE_DINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err dinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid dref_box_del(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err dref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *dref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataReferenceBox, GF_ISOM_BOX_TYPE_DREF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count;\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = ptr->child_boxes ? gf_list_count(ptr->child_boxes) : 0;\n\tgf_bs_write_u32(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err dref_box_size(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid edts_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err edts_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tBOX_FIELD_ASSIGN(editList, GF_EditListBox)\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err edts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *edts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditBox, GF_ISOM_BOX_TYPE_EDTS);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err edts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\treturn gf_isom_box_write_header(s, bs);\n\t} else {\n\t\ts->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err edts_box_size(GF_Box *s)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (!ptr->editList || ! gf_list_count(ptr->editList->entryList)) {\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid elst_box_del(GF_Box *s)\n{\n\tGF_EditListBox *ptr;\n\tu32 nb_entries;\n\tu32 i;\n\n\tptr = (GF_EditListBox *)s;\n\tif (ptr == NULL) return;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tfor (i = 0; i < nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (p) gf_free(p);\n\t}\n\tgf_list_del(ptr->entryList);\n\tgf_free(ptr);\n}\n\nGF_Err elst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tnb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tGF_EdtsEntry *p;\n\t\tGF_SAFEALLOC(p, GF_EdtsEntry);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tp->mediaRate = gf_bs_read_u32(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditListBox, GF_ISOM_BOX_TYPE_ELST);\n\ttmp->entryList = gf_list_new();\n\tif (!tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor (i = 0; i < nb_entries; i++ ) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (ptr->version == 1) {\n\t\t\tgf_bs_write_u64(bs, p->segmentDuration);\n\t\t\tgf_bs_write_u64(bs, p->mediaTime);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->segmentDuration);\n\t\t\tgf_bs_write_u32(bs, (s32) p->mediaTime);\n\t\t}\n\t\tgf_bs_write_u32(bs, p->mediaRate);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elst_box_size(GF_Box *s)\n{\n\tu32 durtimebytes;\n\tu32 i, nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\t//entry count\n\tptr->size += 4;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->version = 0;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif ((p->segmentDuration>0xFFFFFFFF) || (p->mediaTime>0xFFFFFFFF)) {\n\t\t\tptr->version = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdurtimebytes = (ptr->version == 1 ? 16 : 8) + 4;\n\tptr->size += (nb_entries * durtimebytes);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid esds_box_del(GF_Box *s)\n{\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tif (ptr == NULL)\treturn;\n\tif (ptr->desc) gf_odf_desc_del((GF_Descriptor *)ptr->desc);\n\tgf_free(ptr);\n}\n\n\nGF_Err esds_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e=GF_OK;\n\tu32 descSize;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\tdescSize = (u32) (ptr->size);\n\n\tif (descSize) {\n\t\tchar *enc_desc = (char*)gf_malloc(sizeof(char) * descSize);\n\t\tif (!enc_desc) return GF_OUT_OF_MEM;\n\t\t//get the payload\n\t\tgf_bs_read_data(bs, enc_desc, descSize);\n\t\t//send it to the OD Codec\n\t\te = gf_odf_desc_read(enc_desc, descSize, (GF_Descriptor **) &ptr->desc);\n\t\t//OK, free our desc\n\t\tgf_free(enc_desc);\n\n\t\tif (ptr->desc && (ptr->desc->tag!=GF_ODF_ESD_TAG) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor tag 0x%x in esds\\n\", ptr->desc->tag));\n\t\t\tgf_odf_desc_del((GF_Descriptor*)ptr->desc);\n\t\t\tptr->desc=NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (e) {\n\t\t\tptr->desc = NULL;\n\t\t} else {\n\t\t\t/*fix broken files*/\n\t\t\tif (ptr->desc && !ptr->desc->URLString) {\n\t\t\t\tif (!ptr->desc->slConfig) {\n\t\t\t\t\tptr->desc->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t} else if (ptr->desc->slConfig->predefined != SLPredef_MP4) {\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t\tgf_odf_slc_set_pref(ptr->desc->slConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *esds_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ESDBox, GF_ISOM_BOX_TYPE_ESDS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err esds_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu8 *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\t//free our buffer\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}\n\nGF_Err esds_box_size(GF_Box *s)\n{\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\tdescSize = gf_odf_desc_size((GF_Descriptor *)ptr->desc);\n\tptr->size += descSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid free_box_del(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err free_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\n\tif (ptr->size > 0xFFFFFFFF) return GF_IO_ERR;\n\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, bytesToRead);\n\t\tptr->dataSize = bytesToRead;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *free_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FreeSpaceBox, GF_ISOM_BOX_TYPE_FREE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err free_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->original_4cc) {\n\t\tu32 t = s->type;\n\t\ts->type=ptr->original_4cc;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type=t;\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t}\n\tif (e) return e;\n\tif (ptr->dataSize)\t{\n\t\tif (ptr->data) {\n\t\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t\t} else {\n\t\t\tu32 i = 0;\n\t\t\twhile (i<ptr->dataSize) {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err free_box_size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ftyp_box_del(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\tif (ptr->altBrand) gf_free(ptr->altBrand);\n\tgf_free(ptr);\n}\n\nGF_Box *ftyp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FileTypeBox, GF_ISOM_BOX_TYPE_FTYP);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err ftyp_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->majorBrand = gf_bs_read_u32(bs);\n\tptr->minorVersion = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->altCount = ( (u32) (ptr->size)) / 4;\n\tif (!ptr->altCount) return GF_OK;\n\n\tptr->altBrand = (u32*)gf_malloc(sizeof(u32)*ptr->altCount);\n\tif (!ptr->altBrand) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i<ptr->altCount; i++) {\n\t\tptr->altBrand[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ftyp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ftyp_box_size(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tptr->size += 8 + ptr->altCount * 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnrm_box_del(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericSampleEntryBox, GF_ISOM_BOX_TYPE_GNRM);\n\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n//dummy\nGF_Err gnrm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_box_size(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRM;\n\tptr->size += 8+ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gnrv_box_del(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrv_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRV);\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRV;\n\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)ptr, bs);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_box_size(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnra_box_del(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericAudioSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err gnra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRA;\n\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox *)ptr, bs);\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gnra_box_size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hdlr_box_del(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nameUTF8) gf_free(ptr->nameUTF8);\n\tgf_free(ptr);\n}\n\n\nGF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 cookie;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->reserved1 = gf_bs_read_u32(bs);\n\tptr->handlerType = gf_bs_read_u32(bs);\n\tgf_bs_read_data(bs, (char*)ptr->reserved2, 12);\n\n\tcookie = gf_bs_get_cookie(bs);\n\tif (ptr->handlerType==GF_ISOM_MEDIA_VISUAL)\n\t\tcookie |= GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\telse\n\t\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (ptr->size) {\n\t\tu32 name_size = (u32) ptr->size;\n\t\tif (name_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in hdlr\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->nameUTF8 = (char*)gf_malloc(name_size);\n\t\tif (!ptr->nameUTF8) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->nameUTF8, name_size);\n\n\t\t//patch for old QT files - we cannot rely on checking if str[0]==len(str+1) since we may have\n\t\t//cases where the first character of the string decimal value is indeed the same as the string length!!\n\t\t//we had this issue with encryption_import test\n\t\t//we therefore only check if last char is null, and if not so assume old QT style\n\t\tif (ptr->nameUTF8[name_size-1]) {\n\t\t\tif (name_size > 1)\n\t\t\t\tmemmove(ptr->nameUTF8, ptr->nameUTF8+1, sizeof(char) * (u32) (name_size-1) );\n\t\t\tptr->nameUTF8[name_size-1] = 0;\n\t\t\tptr->store_counted_string = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *hdlr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->reserved1);\n\tgf_bs_write_u32(bs, ptr->handlerType);\n\tgf_bs_write_data(bs, (char*)ptr->reserved2, 12);\n\n\tif (ptr->nameUTF8) {\n\t\tu32 len = (u32)strlen(ptr->nameUTF8);\n\t\tif (ptr->store_counted_string) {\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hdlr_box_size(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tptr->size += 20 + 1; //null term or counted string\n\tif (ptr->nameUTF8) {\n\t\tptr->size += strlen(ptr->nameUTF8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid hinf_box_del(GF_Box *s)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tgf_free(hinf);\n}\n\nGF_Box *hinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintInfoBox, GF_ISOM_BOX_TYPE_HINF);\n\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err hinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MAXR:\n\t\tif (!is_rem) {\n\t\t\tu32 i=0;\n\t\t\tGF_MAXRBox *maxR;\n\t\t\twhile ((maxR = (GF_MAXRBox *)gf_list_enum(hinf->child_boxes, &i))) {\n\t\t\t\tif ((maxR->type==GF_ISOM_BOX_TYPE_MAXR) && (maxR->granularity == ((GF_MAXRBox *)a)->granularity))\n\t\t\t\t\tERROR_ON_DUPLICATED_BOX(a, s)\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_HintInfoBox *ptr = (GF_HintInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err hinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hmhd_box_del(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err hmhd_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tptr->maxPDUSize = gf_bs_read_u16(bs);\n\tptr->avgPDUSize = gf_bs_read_u16(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\tptr->slidingAverageBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *hmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintMediaHeaderBox, GF_ISOM_BOX_TYPE_HMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->maxPDUSize);\n\tgf_bs_write_u16(bs, ptr->avgPDUSize);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\tgf_bs_write_u32(bs, ptr->slidingAverageBitrate);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_box_size(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tptr->size += 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintTrackInfoBox, GF_ISOM_BOX_TYPE_HNTI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid hnti_box_del(GF_Box *a)\n{\n\tgf_free(a);\n}\n\nGF_Err hnti_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintTrackInfoBox *ptr = (GF_HintTrackInfoBox *)s;\n\tif (!ptr || !a) return GF_BAD_PARAM;\n\n\tswitch (a->type) {\n\t//this is the value for GF_RTPBox - same as HintSampleEntry for RTP !!!\n\tcase GF_ISOM_BOX_TYPE_RTP:\n\tcase GF_ISOM_BOX_TYPE_SDP:\n\t\tBOX_FIELD_ASSIGN(SDP, GF_Box)\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\n\nGF_Err hnti_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tGF_SDPBox\n**********************************************************/\n\nvoid sdp_box_del(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err sdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in sdp box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *sdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SDPBox, GF_ISOM_BOX_TYPE_SDP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//don't write the NULL char!!!\n\tif (ptr->sdpText)\n\t\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\nGF_Err sdp_box_size(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\t//don't count the NULL char!!!\n\tif (ptr->sdpText)\n\t\tptr->size += strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid rtp_hnti_box_del(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err rtp_hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subType = gf_bs_read_u32(bs);\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in rtp_hnti box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\n\nGF_Box *rtp_hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtp_hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subType);\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_box_size(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tptr->size += 4 + strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTRPY GF_Box\n**********************************************************/\n\nvoid trpy_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err trpy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *trpy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TRPYBox, GF_ISOM_BOX_TYPE_TRPY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trpy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err trpy_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTOTL GF_Box\n**********************************************************/\n\nvoid totl_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err totl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *totl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TOTLBox, GF_ISOM_BOX_TYPE_TOTL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err totl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err totl_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNUMP GF_Box\n**********************************************************/\n\nvoid nump_box_del(GF_Box *s)\n{\n\tgf_free((GF_NUMPBox *)s);\n}\nGF_Err nump_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbPackets = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *nump_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err nump_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err nump_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNPCK GF_Box\n**********************************************************/\n\nvoid npck_box_del(GF_Box *s)\n{\n\tgf_free((GF_NPCKBox *)s);\n}\nGF_Err npck_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *npck_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err npck_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err npck_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTPYL GF_Box\n**********************************************************/\n\nvoid tpyl_box_del(GF_Box *s)\n{\n\tgf_free((GF_NTYLBox *)s);\n}\nGF_Err tpyl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *tpyl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NTYLBox, GF_ISOM_BOX_TYPE_TPYL);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpyl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpyl_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTPAY GF_Box\n**********************************************************/\n\nvoid tpay_box_del(GF_Box *s)\n{\n\tgf_free((GF_TPAYBox *)s);\n}\nGF_Err tpay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tpay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TPAYBox, GF_ISOM_BOX_TYPE_TPAY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tMAXR GF_Box\n**********************************************************/\n\nvoid maxr_box_del(GF_Box *s)\n{\n\tgf_free((GF_MAXRBox *)s);\n}\nGF_Err maxr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->granularity = gf_bs_read_u32(bs);\n\tptr->maxDataRate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *maxr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MAXRBox, GF_ISOM_BOX_TYPE_MAXR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err maxr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}\nGF_Err maxr_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMED GF_Box\n**********************************************************/\n\nvoid dmed_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMEDBox *)s);\n}\nGF_Err dmed_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dmed_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMEDBox, GF_ISOM_BOX_TYPE_DMED);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmed_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dmed_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDIMM GF_Box\n**********************************************************/\n\nvoid dimm_box_del(GF_Box *s)\n{\n\tgf_free((GF_DIMMBox *)s);\n}\nGF_Err dimm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dimm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMMBox, GF_ISOM_BOX_TYPE_DIMM);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dimm_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDREP GF_Box\n**********************************************************/\n\nvoid drep_box_del(GF_Box *s)\n{\n\tgf_free((GF_DREPBox *)s);\n}\nGF_Err drep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *drep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DREPBox, GF_ISOM_BOX_TYPE_DREP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err drep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err drep_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/**********************************************************\n\t\tTMIN GF_Box\n**********************************************************/\n\nvoid tmin_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMINBox *)s);\n}\nGF_Err tmin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->minTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMINBox, GF_ISOM_BOX_TYPE_TMIN);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->minTime);\n\treturn GF_OK;\n}\nGF_Err tmin_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTMAX GF_Box\n**********************************************************/\n\nvoid tmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMAXBox *)s);\n}\nGF_Err tmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxTime);\n\treturn GF_OK;\n}\nGF_Err tmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPMAX GF_Box\n**********************************************************/\n\nvoid pmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_PMAXBox *)s);\n}\nGF_Err pmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *pmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PMAXBox, GF_ISOM_BOX_TYPE_PMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxSize);\n\treturn GF_OK;\n}\nGF_Err pmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMAX GF_Box\n**********************************************************/\n\nvoid dmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMAXBox *)s);\n}\nGF_Err dmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxDur = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *dmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMAXBox, GF_ISOM_BOX_TYPE_DMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxDur);\n\treturn GF_OK;\n}\nGF_Err dmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid payt_box_del(GF_Box *s)\n{\n\tGF_PAYTBox *payt = (GF_PAYTBox *)s;\n\tif (payt->payloadString) gf_free(payt->payloadString);\n\tgf_free(payt);\n}\nGF_Err payt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5 );\n\tptr->payloadCode = gf_bs_read_u32(bs);\n\tlength = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, length);\n\tptr->payloadString = (char*)gf_malloc(sizeof(char) * (length+1) );\n\tif (! ptr->payloadString) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->payloadString, length);\n\tptr->payloadString[length] = 0;\n\n\treturn GF_OK;\n}\nGF_Box *payt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PAYTBox, GF_ISOM_BOX_TYPE_PAYT);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err payt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->payloadCode);\n    len = ptr->payloadString ? (u32) strlen(ptr->payloadString) : 0;\n\tgf_bs_write_u8(bs, len);\n\tif (len) gf_bs_write_data(bs, ptr->payloadString, len);\n\treturn GF_OK;\n}\nGF_Err payt_box_size(GF_Box *s)\n{\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\ts->size += 4 + 1;\n\tif (ptr->payloadString) ptr->size += strlen(ptr->payloadString);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid name_box_del(GF_Box *s)\n{\n\tGF_NameBox *name = (GF_NameBox *)s;\n\tif (name->string) gf_free(name->string);\n\tgf_free(name);\n}\nGF_Err name_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in name box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->string = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (! ptr->string) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->string, length);\n\tptr->string[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *name_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NameBox, GF_ISOM_BOX_TYPE_NAME);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err name_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->string) {\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string) + 1);\n\t}\n\treturn GF_OK;\n}\nGF_Err name_box_size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tssy_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err tssy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tgf_bs_read_int(bs, 6);\n\tptr->timestamp_sync = gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\nGF_Box *tssy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeStampSynchronyBox, GF_ISOM_BOX_TYPE_TSSY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tssy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->timestamp_sync, 2);\n\treturn GF_OK;\n}\nGF_Err tssy_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid srpp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err srpp_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SchemeInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tBOX_FIELD_ASSIGN(scheme_type, GF_SchemeTypeBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err srpp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 16)\n\tptr->encryption_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->encryption_algorithm_rtcp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtcp = gf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\nGF_Box *srpp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err srpp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtcp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtcp);\n\n\treturn GF_OK;\n}\nGF_Err srpp_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\ts->size += 16;\n\tgf_isom_check_position(s, (GF_Box*)ptr->info, &pos);\n\tgf_isom_check_position(s, (GF_Box*)ptr->scheme_type, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid rssr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err rssr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->ssrc = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *rssr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ReceivedSsrcBox, GF_ISOM_BOX_TYPE_RSSR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rssr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}\nGF_Err rssr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid iods_box_del(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->descriptor) gf_odf_desc_del(ptr->descriptor);\n\tgf_free(ptr);\n}\n\n\nGF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tif (!desc) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\n\tif (e) return e;\n\tswitch (ptr->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor in iods, tag %u found but only %u or %u allowed\\n\", ptr->descriptor->tag, GF_ODF_ISOM_IOD_TAG, GF_ODF_ISOM_OD_TAG ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *iods_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ObjectDescriptorBox, GF_ISOM_BOX_TYPE_IODS);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iods_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tu8 *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//call our OD codec\n\te = gf_odf_desc_write(ptr->descriptor, &desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, desc, descSize);\n\t//and free our stuff maybe!!\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\nGF_Err iods_box_size(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\tptr->size += gf_odf_desc_size(ptr->descriptor);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdat_box_del(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (!s) return;\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdat_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tptr->dataSize = s->size;\n\tptr->bsOffset = gf_bs_get_position(bs);\n\n\t//store idat for rewrite\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IDAT) {\n\t\tptr->data = gf_malloc(sizeof(u8) * (size_t)ptr->dataSize);\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, (u32) ptr->dataSize);\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\t//then skip these bytes\n\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *mdat_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaDataBox, GF_ISOM_BOX_TYPE_MDAT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdat_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//make sure we have some data ...\n\t//if not, we handle that independently (edit files)\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, (u32) ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdat_box_size(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdhd_box_del(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mdhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28)\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Media header timescale is 0 - defaulting to 90000\\n\" ));\n\t\tptr->timeScale = 90000;\n\t}\n\n\tptr->original_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\t//our padding bit\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguage[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[2] = gf_bs_read_int(bs, 5);\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguage[0] || ptr->packedLanguage[1] || ptr->packedLanguage[2]) {\n\t\tptr->packedLanguage[0] += 0x60;\n\t\tptr->packedLanguage[1] += 0x60;\n\t\tptr->packedLanguage[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguage[0] = 'u';\n\t\tptr->packedLanguage[1] = 'n';\n\t\tptr->packedLanguage[2] = 'd';\n\t}\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mdhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);\n\n\ttmp->packedLanguage[0] = 'u';\n\ttmp->packedLanguage[1] = 'n';\n\ttmp->packedLanguage[2] = 'd';\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\t//SPECS: BIT(1) of padding\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_box_size(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += 4;\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mdia_box_del(GF_Box *s)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nalu_parser) gf_bs_del(ptr->nalu_parser);\n\tif (ptr->nalu_out_bs) gf_bs_del(ptr->nalu_out_bs);\n\tif (ptr->nalu_ps_bs) gf_bs_del(ptr->nalu_ps_bs);\n\tif (ptr->extracted_bs) gf_bs_del(ptr->extracted_bs);\n\tif (ptr->extracted_samp) gf_isom_sample_del(&ptr->extracted_samp);\n\tif (ptr->in_sample_buffer) gf_free(ptr->in_sample_buffer);\n\tif (ptr->tmp_nal_copy_buffer) gf_free(ptr->tmp_nal_copy_buffer);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdia_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tBOX_FIELD_ASSIGN(mediaHeader, GF_MediaHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tBOX_FIELD_ASSIGN(handler, GF_HandlerBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tBOX_FIELD_ASSIGN(information, GF_MediaInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs);\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mdia_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_MDIA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdia_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mdia_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box*)ptr->mediaHeader, &pos);\n\t//then handler\n\tgf_isom_check_position(s, (GF_Box*)ptr->handler, &pos);\n\n#if 0\n\t//elng before info for CMAF info - we deactiveate for now, no specific errors raised and CMAF should not impose any order\n\tGF_Box *elng = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\tif (elng)\n\t\tgf_isom_check_position(s, elng, &pos);\n#endif\n\n\t//then info\n\tgf_isom_check_position(s, (GF_Box*)ptr->information, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mfra_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->tfra_list);\n\tgf_free(ptr);\n}\n\nGF_Box *mfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_MFRA);\n\ttmp->tfra_list = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfra_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\tBOX_FIELD_LIST_ASSIGN(tfra_list);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tBOX_FIELD_ASSIGN(mfro, GF_MovieFragmentRandomAccessOffsetBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mfra_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tgf_isom_check_position_list(s, ptr->tfra_list, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfro, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tfra_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Box *tfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_TFRA);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err tfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_RandomAccessEntry *p = 0;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\n\tptr->track_id = gf_bs_read_u32(bs);\n\tif (gf_bs_read_int(bs, 26) != 0)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->traf_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->trun_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->sample_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (ptr->nb_entries > ptr->size / (16+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (ptr->nb_entries > ptr->size / (8+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tif ((u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_RandomAccessEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tp = (GF_RandomAccessEntry *) gf_malloc(sizeof(GF_RandomAccessEntry) * ptr->nb_entries);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t}\n\n\tptr->entries = p;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tmemset(p, 0, sizeof(GF_RandomAccessEntry));\n\n\t\tif (ptr->version == 1) {\n\t\t\tp->time = gf_bs_read_u64(bs);\n\t\t\tp->moof_offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tp->time = gf_bs_read_u32(bs);\n\t\t\tp->moof_offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tp->traf_number = gf_bs_read_int(bs, ptr->traf_bits);\n\t\tp->trun_number = gf_bs_read_int(bs, ptr->trun_bits);\n\t\tp->sample_number = gf_bs_read_int(bs, ptr->sample_bits);\n\n\t\t++p;\n\t}\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, sap_nb_entries;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->track_id);\n\tgf_bs_write_int(bs, 0, 26);\n\n\tgf_bs_write_int(bs, ptr->traf_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->trun_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->sample_bits/8 - 1, 2);\n\n\tsap_nb_entries = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (p->trun_number) sap_nb_entries++;\n\t}\n\n\tgf_bs_write_u32(bs, sap_nb_entries);\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tif (ptr->version==1) {\n\t\t\tgf_bs_write_u64(bs, p->time);\n\t\t\tgf_bs_write_u64(bs, p->moof_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->time);\n\t\t\tgf_bs_write_u32(bs, (u32) p->moof_offset);\n\t\t}\n\t\tgf_bs_write_int(bs, p->traf_number, ptr->traf_bits);\n\t\tgf_bs_write_int(bs, p->trun_number, ptr->trun_bits);\n\t\tgf_bs_write_int(bs, p->sample_number, ptr->sample_bits);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfra_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tptr->size += 12;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tptr->size +=  ((ptr->version==1) ? 16 : 8 ) + ptr->traf_bits/8 + ptr->trun_bits/8 + ptr->sample_bits/8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mfro_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Box *mfro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessOffsetBox, GF_ISOM_BOX_TYPE_MFRO);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->container_size = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->container_size);\n\treturn GF_OK;\n}\n\nGF_Err mfro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid elng_box_del(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->extended_language) gf_free(ptr->extended_language);\n\tgf_free(ptr);\n}\n\nGF_Err elng_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->extended_language = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->extended_language == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->extended_language, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->extended_language[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tif (!str) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(str, ptr->extended_language, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->extended_language);\n\t\t\tptr->extended_language = str;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elng_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_ELNG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elng_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->extended_language) {\n\t\tgf_bs_write_data(bs, ptr->extended_language, (u32)(strlen(ptr->extended_language)+1));\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elng_box_size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mfhd_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sequence_number = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentHeaderBox, GF_ISOM_BOX_TYPE_MFHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid minf_box_del(GF_Box *s)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\t//if we have a Handler not self-contained, delete it (the self-contained belongs to the movie)\n\tif (ptr->dataHandler) {\n\t\tgf_isom_datamap_close(ptr);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err minf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_NMHD:\n\tcase GF_ISOM_BOX_TYPE_STHD:\n\tcase GF_ISOM_BOX_TYPE_VMHD:\n\tcase GF_ISOM_BOX_TYPE_SMHD:\n\tcase GF_ISOM_BOX_TYPE_HMHD:\n\tcase GF_ISOM_BOX_TYPE_GMHD:\n\t\tBOX_FIELD_ASSIGN(InfoHeader, GF_Box)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tBOX_FIELD_ASSIGN(dataInformation, GF_DataInformationBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_STBL:\n\t\tBOX_FIELD_ASSIGN(sampleTable, GF_SampleTableBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err minf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\n\te = gf_isom_box_array_read(s, bs);\n\n\tif (!e && ! ptr->dataInformation) {\n\t\tGF_Box *url;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tptr->dataInformation = (GF_DataInformationBox *) gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!ptr->dataInformation) return GF_OUT_OF_MEM;\n\n\t\tptr->dataInformation->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&ptr->dataInformation->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!ptr->dataInformation->dref) return GF_OUT_OF_MEM;\n\n\t\turl = gf_isom_box_new_parent(&ptr->dataInformation->dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t}\n\treturn e;\n}\n\nGF_Box *minf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaInformationBox, GF_ISOM_BOX_TYPE_MINF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err minf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err minf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->InfoHeader, &pos);\n\t//then dataInfo\n\tgf_isom_check_position(s, (GF_Box *)ptr->dataInformation, &pos);\n\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_MVCI), &pos);\n\t//then sampleTable\n\tgf_isom_check_position(s, (GF_Box *)ptr->sampleTable, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid moof_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tgf_list_del(ptr->TrackList);\n\tif (ptr->PSSHs) gf_list_del(ptr->PSSHs);\n\tif (ptr->mdat) gf_free(ptr->mdat);\n\tgf_free(ptr);\n}\n\nGF_Err moof_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tBOX_FIELD_ASSIGN(mfhd, GF_MovieFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tBOX_FIELD_LIST_ASSIGN(PSSHs)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moof_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentBox, GF_ISOM_BOX_TYPE_MOOF);\n\ttmp->TrackList = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err moof_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moof_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\t//Header First\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfhd, &pos);\n\t//then PSSH\n\tgf_isom_check_position_list(s, ptr->PSSHs, &pos);\n\t//then the track list\n\tgf_isom_check_position_list(s, ptr->TrackList, &pos);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nvoid moov_box_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->trackList);\n\tgf_free(ptr);\n}\n\nGF_Err moov_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tBOX_FIELD_ASSIGN(iods, GF_ObjectDescriptorBox)\n\t\t//if no IOD, delete the box\n\t\tif (ptr->iods && !ptr->iods->descriptor) {\n\t\t\tptr->iods = NULL;\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t}\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tBOX_FIELD_ASSIGN(mvhd, GF_MovieHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tBOX_FIELD_ASSIGN(mvex, GF_MovieExtendsBox)\n\t\tif (ptr->mvex)\n\t\t\tptr->mvex->mov = ptr->mov;\n\t\treturn GF_OK;\n#endif\n\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tif (is_rem) {\n\t\t\tgf_list_del_item(ptr->trackList, a);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t{\n\t\t\tGF_TrackBox *tk = (GF_TrackBox *)a;\n\t\t\t//set our pointer to this obj\n\t\t\ttk->moov = ptr;\n\t\t\ttk->index = gf_list_count(ptr->trackList);\n\t\t\tif (tk->References) {\n\t\t\t\tGF_TrackReferenceTypeBox *dpnd=NULL;\n\t\t\t\tTrack_FindRef(tk, GF_ISOM_REF_BASE, &dpnd);\n\t\t\t\tif (dpnd)\n\t\t\t\t\ttk->nb_base_refs = dpnd->trackIDCount;\n\t\t\t}\n\t\t}\n\t\treturn gf_list_add(ptr->trackList, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err moov_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moov_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err moov_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moov_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *) ptr->mvhd, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->iods, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->meta, &pos);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && !ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\tgf_isom_check_position_list(s, ptr->trackList, &pos);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid audio_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err audio_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *wave = NULL;\n\tBool drop_wave=GF_FALSE;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DOPS:\n\t\tBOX_FIELD_ASSIGN(cfg_opus, GF_OpusSpecificBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DMLP:\n\t\tBOX_FIELD_ASSIGN(cfg_mlp, GF_TrueHDConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MHAC:\n\t\tBOX_FIELD_ASSIGN(cfg_mha, GF_MHAConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DFLA:\n\t\tBOX_FIELD_ASSIGN(cfg_flac, GF_FLACConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\twave = (GF_UnknownBox *)a;\n\t\t/*HACK for QT files: get the esds box from the track*/\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tif (is_rem) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(wave->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(wave->child_boxes, i);\n                    if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) {\n                        ptr->esd = (GF_ESDBox *)inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tptr->compression_id = 0;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n            gf_isom_box_del_parent(&ptr->child_boxes, a);\n            return GF_ISOM_INVALID_MEDIA;\n\n\t\t}\n \t\tptr->qtff_mode &= ~GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n\n \t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n\t\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\t}\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_WAVE:\n\t{\n\t\tu32 subtype = 0;\n\t\tGF_Box **cfg_ptr = NULL;\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->esd;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_ESDS;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_AC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DAC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_EC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DEC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_OPUS) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_opus;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DOPS;\n\t\t}\n\t\telse if ((s->type == GF_ISOM_BOX_TYPE_MHA1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHA2)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM2)\n\t\t) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mha;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_MHAC;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mlp;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DMLP;\n\t\t}\n\n\t\tif (cfg_ptr) {\n\t\t\tif (is_rem) {\n\t\t\t\t*cfg_ptr = NULL;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (*cfg_ptr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif (gf_list_count(a->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(a->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(a->child_boxes, i);\n                    if (inner_box->type == subtype) {\n                        *cfg_ptr = inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->compression_id = 0;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n\t\t}\n\t}\n \t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err audio_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_QT_CONV) {\n \t\tptr->qtff_mode |= GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n \t}\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (!e) {\n\t\tif (s->type==GF_ISOM_BOX_TYPE_ENCA) {\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\t\tif (ptr->cfg_3gpp) ptr->cfg_3gpp->cfg.type = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tif (!data) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *)ptr->esd);\n\t\t\tptr->esd = NULL;\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\n\t\t\tif ((e==GF_OK) && (ptr->esd->type == GF_ISOM_BOX_TYPE_ESDS)) {\n\t\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(ptr->child_boxes, ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n\nGF_Box *audio_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_MP4A);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *enca_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_ENCA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err audio_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox*)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err audio_sample_entry_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox*)s);\n\tif (ptr->qtff_mode)\n\t\treturn GF_OK;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_opus, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_ac3, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_flac, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mlp, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gen_sample_entry_box_del(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(ptr);\n}\n\n\nGF_Err gen_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)s, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(s, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *gen_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEntryBox, GF_QT_SUBTYPE_C608);//type will be overriten\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gen_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err gen_sample_entry_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mp4s_box_del(GF_Box *s)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err mp4s_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mp4s_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mp4s_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n    return GF_OK;\n}\n\nGF_Err mp4s_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n    return GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid video_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\t/*for publishing*/\n\tif (ptr->emul_esd) gf_odf_desc_del((GF_Descriptor *)ptr->emul_esd);\n\tgf_free(ptr);\n}\n\nGF_Err video_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tBOX_FIELD_ASSIGN(rinf, GF_RestrictedSchemeInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\t\tBOX_FIELD_ASSIGN(avc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tBOX_FIELD_ASSIGN(hevc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VVCC:\n\t\tBOX_FIELD_ASSIGN(vvc_config, GF_VVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\t\tBOX_FIELD_ASSIGN(svc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tBOX_FIELD_ASSIGN(mvc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHVC:\n\t\tBOX_FIELD_ASSIGN(lhvc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tBOX_FIELD_ASSIGN(av1_config, GF_AV1ConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VPCC:\n\t\tBOX_FIELD_ASSIGN(vp_config, GF_VPConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DVCC:\n\tcase GF_ISOM_BOX_TYPE_DVVC:\n\t\tBOX_FIELD_ASSIGN(dovi_config, GF_DOVIConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (! memcmp(((GF_UnknownUUIDBox*)a)->uuid, GF_ISOM_IPOD_EXT, 16)) {\n\t\t\tBOX_FIELD_ASSIGN(ipod_ext, GF_UnknownUUIDBox)\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tif (ptr->cfg_3gpp)\n\t\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_JP2H:\n\t\tBOX_FIELD_ASSIGN(jp2h, GF_J2KHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_PASP:\n\tcase GF_ISOM_BOX_TYPE_CLAP:\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\tcase GF_ISOM_BOX_TYPE_MDCV:\n\tcase GF_ISOM_BOX_TYPE_CLLI:\n\tcase GF_ISOM_BOX_TYPE_CCST:\n\tcase GF_ISOM_BOX_TYPE_AUXI:\n\tcase GF_ISOM_BOX_TYPE_RVCC:\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (!is_rem && !gf_isom_box_check_unique(s->child_boxes, a)) {\n\t\t\tERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGVisualSampleEntryBox *mp4v = (GF_MPEGVisualSampleEntryBox*)s;\n\tGF_Err e;\n\te = gf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *)s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\t/*this is an AVC sample desc*/\n\tif (mp4v->avc_config || mp4v->svc_config || mp4v->mvc_config)\n\t\tAVC_RewriteESDescriptor(mp4v);\n\t/*this is an HEVC sample desc*/\n\tif (mp4v->hevc_config || mp4v->lhvc_config || (mp4v->type==GF_ISOM_BOX_TYPE_HVT1))\n\t\tHEVC_RewriteESDescriptor(mp4v);\n\t/*this is an AV1 sample desc*/\n\tif (mp4v->av1_config)\n\t\tAV1_RewriteESDescriptor(mp4v);\n\t/*this is a VP8-9 sample desc*/\n\tif (mp4v->vp_config)\n\t\tVP9_RewriteESDescriptor(mp4v);\n\n\tif (s->type==GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\tif (sinf && sinf->original_format) {\n\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\tswitch (type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tif (mp4v->cfg_3gpp) mp4v->cfg_3gpp->cfg.type = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *video_sample_entry_box_new()\n{\n\tGF_MPEGVisualSampleEntryBox *tmp;\n\tGF_SAFEALLOC(tmp, GF_MPEGVisualSampleEntryBox);\n\tif (tmp == NULL) return NULL;\n\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox *)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err video_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\t\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mvex_box_del(GF_Box *s)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->TrackExList);\n\tgf_list_del(ptr->TrackExPropList);\n\tgf_free(ptr);\n}\n\n\nGF_Err mvex_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TREX:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREP:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExPropList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MEHD:\n\t\tBOX_FIELD_ASSIGN(mehd, GF_MovieExtendsHeaderBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err mvex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsBox, GF_ISOM_BOX_TYPE_MVEX);\n\ttmp->TrackExList = gf_list_new();\n\tif (!tmp->TrackExList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\ttmp->TrackExPropList = gf_list_new();\n\tif (!tmp->TrackExPropList) {\n\t\tgf_list_del(tmp->TrackExList);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mvex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mvex_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *) s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->mehd, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExList, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExPropList, &pos);\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *mehd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsHeaderBox, GF_ISOM_BOX_TYPE_MEHD);\n\treturn (GF_Box *)tmp;\n}\nvoid mehd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err mehd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->fragment_duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->fragment_duration = (u64) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mehd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration);\n\t}\n\treturn GF_OK;\n}\nGF_Err mehd_box_size(GF_Box *s)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tptr->version = (ptr->fragment_duration>0xFFFFFFFF) ? 1 : 0;\n\ts->size += (ptr->version == 1) ? 8 : 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid mvhd_box_del(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err mvhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 80);\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n\nGF_Box *mvhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieHeaderBox, GF_ISOM_BOX_TYPE_MVHD);\n\n\ttmp->preferredRate = (1<<16);\n\ttmp->preferredVolume = (1<<8);\n\n\ttmp->matrixA = (1<<16);\n\ttmp->matrixD = (1<<16);\n\ttmp->matrixW = (1<<30);\n\n\ttmp->nextTrackID = 1;\n\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->preferredRate);\n\tgf_bs_write_u16(bs, ptr->preferredVolume);\n\tgf_bs_write_data(bs, ptr->reserved, 10);\n\tgf_bs_write_u32(bs, ptr->matrixA);\n\tgf_bs_write_u32(bs, ptr->matrixB);\n\tgf_bs_write_u32(bs, ptr->matrixU);\n\tgf_bs_write_u32(bs, ptr->matrixC);\n\tgf_bs_write_u32(bs, ptr->matrixD);\n\tgf_bs_write_u32(bs, ptr->matrixV);\n\tgf_bs_write_u32(bs, ptr->matrixX);\n\tgf_bs_write_u32(bs, ptr->matrixY);\n\tgf_bs_write_u32(bs, ptr->matrixW);\n\tgf_bs_write_u32(bs, ptr->previewTime);\n\tgf_bs_write_u32(bs, ptr->previewDuration);\n\tgf_bs_write_u32(bs, ptr->posterTime);\n\tgf_bs_write_u32(bs, ptr->selectionTime);\n\tgf_bs_write_u32(bs, ptr->selectionDuration);\n\tgf_bs_write_u32(bs, ptr->currentTime);\n\tgf_bs_write_u32(bs, ptr->nextTrackID);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_box_size(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\tptr->size += 80;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid nmhd_box_del(GF_Box *s)\n{\n\tGF_MPEGMediaHeaderBox *ptr = (GF_MPEGMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\n\nGF_Err nmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\nGF_Box *nmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGMediaHeaderBox, GF_ISOM_BOX_TYPE_NMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err nmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err nmhd_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid padb_box_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}\n\n\nGF_Err padb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SampleCount = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->SampleCount/2) //half byte per sample\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->padbits = (u8 *)gf_malloc(sizeof(u8)*ptr->SampleCount);\n\tif (!ptr->padbits) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_read_int(bs, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tptr->padbits[i+1] = gf_bs_read_int(bs, 3);\n\t\t} else {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tgf_bs_read_int(bs, 1);\n\t\tptr->padbits[i] = gf_bs_read_int(bs, 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *padb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PaddingBitsBox, GF_ISOM_BOX_TYPE_PADB);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err padb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->SampleCount, 32);\n\n\tfor (i=0 ; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tgf_bs_write_int(bs, ptr->padbits[i+1], 3);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, ptr->padbits[i], 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err padb_box_size(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\tptr->size += 4;\n\tif (ptr->SampleCount) ptr->size += (ptr->SampleCount + 1) / 2;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rely_box_del(GF_Box *s)\n{\n\tGF_RelyHintBox *rely = (GF_RelyHintBox *)s;\n\tgf_free(rely);\n}\n\nGF_Err rely_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tptr->reserved = gf_bs_read_int(bs, 6);\n\tptr->preferred = gf_bs_read_int(bs, 1);\n\tptr->required = gf_bs_read_int(bs, 1);\n\treturn GF_OK;\n}\n\nGF_Box *rely_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RelyHintBox, GF_ISOM_BOX_TYPE_RELY);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rely_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 6);\n\tgf_bs_write_int(bs, ptr->preferred, 1);\n\tgf_bs_write_int(bs, ptr->required, 1);\n\treturn GF_OK;\n}\n\nGF_Err rely_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rtpo_box_del(GF_Box *s)\n{\n\tGF_RTPOBox *rtpo = (GF_RTPOBox *)s;\n\tgf_free(rtpo);\n}\n\nGF_Err rtpo_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *rtpo_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtpo_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//here we have no pb, just remembed that some entries will have to\n\t//be 4-bytes aligned ...\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid smhd_box_del(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tif (ptr == NULL ) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err smhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *smhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SoundMediaHeaderBox, GF_ISOM_BOX_TYPE_SMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err smhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err smhd_box_size(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\n\tptr->reserved = 0;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid snro_box_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}\n\nGF_Err snro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SeqOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *snro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SeqOffHintEntryBox, GF_ISOM_BOX_TYPE_SNRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err snro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}\n\nGF_Err snro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stbl_box_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tif (ptr->traf_map) {\n\t\tif (ptr->traf_map->frag_starts) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->traf_map->nb_entries; i++) {\n\t\t\t\tif (ptr->traf_map->frag_starts[i].moof_template)\n\t\t\t\t\tgf_free(ptr->traf_map->frag_starts[i].moof_template);\n\t\t\t}\n\t\t\tgf_free(ptr->traf_map->frag_starts);\n\t\t}\n\t\tgf_free(ptr->traf_map);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err stbl_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STTS:\n\t\tBOX_FIELD_ASSIGN(TimeToSample, GF_TimeToSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CTTS:\n\t\tBOX_FIELD_ASSIGN(CompositionOffset, GF_CompositionOffsetBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CSLG:\n\t\tBOX_FIELD_ASSIGN(CompositionToDecode, GF_CompositionToDecodeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSS:\n\t\tBOX_FIELD_ASSIGN(SyncSample, GF_SyncSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\tBOX_FIELD_ASSIGN(SampleDescription, GF_SampleDescriptionBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STZ2:\n\tcase GF_ISOM_BOX_TYPE_STSZ:\n\t\tBOX_FIELD_ASSIGN(SampleSize, GF_SampleSizeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSC:\n\t\tBOX_FIELD_ASSIGN(SampleToChunk, GF_SampleToChunkBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PADB:\n\t\tBOX_FIELD_ASSIGN(PaddingBits, GF_PaddingBitsBox)\n\t\tbreak;\n\n\t//WARNING: AS THIS MAY CHANGE DYNAMICALLY DURING EDIT,\n\tcase GF_ISOM_BOX_TYPE_CO64:\n\tcase GF_ISOM_BOX_TYPE_STCO:\n\t\tBOX_FIELD_ASSIGN(ChunkOffset, GF_Box)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSH:\n\t\tBOX_FIELD_ASSIGN(ShadowSync, GF_ShadowSyncBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STDP:\n\t\tBOX_FIELD_ASSIGN(DegradationPriority, GF_DegradationPriorityBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(SampleDep, GF_SampleDependencyTypeBox)\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\t//check subsample box\n\t\tif (!is_rem) {\n\t\t\tGF_SubSampleInformationBox *subs = (GF_SubSampleInformationBox *)a;\n\t\t\tGF_SubSampleInfoEntry *ent = gf_list_get(subs->Samples, 0);\n\t\t\tif (!ent) {\n\t\t\t\tgf_list_rem(subs->Samples, 0);\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable is invalid\\n\"));\n\t\t\t}\n\t\t\telse if (ent->sample_delta==0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable has sample_delta of 0, should be one. Fixing\\n\"));\n\t\t\t\tent->sample_delta = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\t//we need to parse DegPrior in a special way\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_stbl_boxes = gf_list_count(ptr->child_boxes);\n\n\tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_CLONE_TRACK)\n\t\treturn GF_OK;\n//\treturn GF_OK;\n\n#define CHECK_BOX(_name) \\\n\tif (!ptr->_name) {\\\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Mandatory box %s is missing\\n\", #_name)); \\\n\t\treturn GF_ISOM_INVALID_FILE; \\\n\t}\n\n\tCHECK_BOX(SampleToChunk)\n\tCHECK_BOX(SampleSize)\n\tCHECK_BOX(ChunkOffset)\n\tCHECK_BOX(TimeToSample)\n\n\t//sanity check\n\tif (ptr->SampleSize->sampleCount) {\n\t\tif (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tu32 i, max_chunks=0;\n\tif (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\telse if (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\n\t//sanity check on stsc vs chunk offset tables\n\tfor (i=0; i<ptr->SampleToChunk->nb_entries; i++) {\n\t\tGF_StscEntry *ent = &ptr->SampleToChunk->entries[i];\n\t\tif (!i && (ent->firstChunk!=1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk of first entry shall be 1 but is %u\\n\", ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (ptr->SampleToChunk->entries[i].firstChunk > max_chunks) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk is %u but number of chunks defined %u\\n\", ptr->SampleToChunk->entries[i].firstChunk, max_chunks));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i+1 == ptr->SampleToChunk->nb_entries) break;\n\t\tGF_StscEntry *next_ent = &ptr->SampleToChunk->entries[i+1];\n\t\tif (next_ent->firstChunk < ent->firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk (%u) for entry %u is greater than first_chunk (%u) for entry %u\\n\", i+1, ent->firstChunk, i+2, next_ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stbl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\t//maxSamplePer chunk is 10 by default\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stbl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err stbl_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDescription, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->TimeToSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionToDecode, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SyncSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ShadowSync, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleToChunk, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleSize, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ChunkOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->DegradationPriority, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDep, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->PaddingBits, &pos);\n\n\tif (ptr->sub_samples) {\n\t\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t}\n\tif (ptr->sampleGroups) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t}\n\tif (ptr->sai_sizes) {\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t}\n\tif (ptr->sai_offsets) {\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stco_box_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\n\nGF_Err stco_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->nb_entries > ptr->size / 4 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stco\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tptr->offsets = (u32 *) gf_malloc(ptr->nb_entries * sizeof(u32) );\n\t\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->nb_entries;\n\n\t\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\t\tptr->offsets[entries] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stco_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkOffsetBox, GF_ISOM_BOX_TYPE_STCO);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stco_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stco_box_size(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stdp_box_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}\n\n//this is called through stbl_read...\nGF_Err stdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\t/*out-of-order stdp, assume no padding at the end and take the entire remaining data for entries*/\n\tif (!ptr->nb_entries) ptr->nb_entries = (u32) ptr->size / 2;\n\telse if (ptr->nb_entries > ptr->size / 2) return GF_ISOM_INVALID_FILE;\n\n\tptr->priorities = (u16 *) gf_malloc(ptr->nb_entries * sizeof(u16));\n\tif (ptr->priorities == NULL) return GF_OUT_OF_MEM;\n\tfor (entry = 0; entry < ptr->nb_entries; entry++) {\n\t\tptr->priorities[entry] = gf_bs_read_u16(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, (2*ptr->nb_entries) );\n\treturn GF_OK;\n}\n\nGF_Box *stdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DegradationPriorityBox, GF_ISOM_BOX_TYPE_STDP);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->priorities[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stdp_box_size(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\tptr->size += (2 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsc_box_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 12 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_StscEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsc\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = NULL;\n\tif (ptr->nb_entries) {\n\t\tptr->entries = gf_malloc(sizeof(GF_StscEntry)*ptr->alloc_size);\n\t\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].firstChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].samplesPerChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDescriptionIndex = gf_bs_read_u32(bs);\n\t\tptr->entries[i].isEdited = 0;\n\t\tptr->entries[i].nextChunk = 0;\n\t\tif (!ptr->entries[i].firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] invalid first chunk 0 in stsc entry\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//update the next chunk in the previous entry\n\t\tif (i) ptr->entries[i-1].nextChunk = ptr->entries[i].firstChunk;\n\t}\n\tptr->currentIndex = 0;\n\tptr->firstSampleInCurrentChunk = 0;\n\tptr->currentChunk = 0;\n\tptr->ghostNumber = 0;\n\treturn GF_OK;\n}\n\nGF_Box *stsc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleToChunkBox, GF_ISOM_BOX_TYPE_STSC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].firstChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].samplesPerChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDescriptionIndex);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsc_box_size(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->size += 4 + (12 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsd_box_del(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err stsd_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *def;\n\tif (!a) return GF_OK;\n\n\tif (is_rem || gf_box_valid_in_parent(a, \"stsd\")) {\n\t\treturn GF_OK;\n\t}\n\tswitch (a->type) {\n\t//unknown sample description: we need a specific box to handle the data ref index\n\t//rather than a default box ...\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tdef = (GF_UnknownBox *)a;\n\t\t/*we need at least 8 bytes for unknown sample entries*/\n\t\tif (def->dataSize < 8) {\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t}\n\t\treturn GF_OK;\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Cannot process box of type %s\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n}\n\n\nGF_Err stsd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tISOM_DECREASE_SIZE(s, 4)\n\tgf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read_ex(s, bs, GF_ISOM_BOX_TYPE_STSD);\n}\n\nGF_Box *stsd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 nb_entries;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->child_boxes);\n\tgf_bs_write_u32(bs, nb_entries);\n\treturn GF_OK;\n}\n\nGF_Err stsd_box_size(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsh_box_del(GF_Box *s)\n{\n\tu32 i = 0;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tif (ptr == NULL) return;\n\twhile ( (ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i)) ) {\n\t\tgf_free(ent);\n\t}\n\tgf_list_del(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tcount = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i = 0; i < count; i++) {\n\t\tGF_StshEntry *ent = (GF_StshEntry *) gf_malloc(sizeof(GF_StshEntry));\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->shadowedSampleNumber = gf_bs_read_u32(bs);\n\t\tent->syncSampleNumber = gf_bs_read_u32(bs);\n\t\te = gf_list_add(ptr->entries, ent);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);\n\n\ttmp->entries = gf_list_new();\n\tif (!tmp->entries) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsh_box_size(GF_Box *s)\n{\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tptr->size += 4 + (8 * gf_list_count(ptr->entries));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stss_box_del(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sampleNumbers) gf_free(ptr->sampleNumbers);\n\tgf_free(ptr);\n}\n\nGF_Err stss_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 4 <  ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stss\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->sampleNumbers = (u32 *) gf_malloc( ptr->alloc_size * sizeof(u32));\n\tif (ptr->sampleNumbers == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->sampleNumbers[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stss_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SyncSampleBox, GF_ISOM_BOX_TYPE_STSS);\n\treturn (GF_Box*)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stss_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->sampleNumbers[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stss_box_size(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsz_box_del(GF_Box *s)\n{\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sizes) gf_free(ptr->sizes);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, estSize;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//support for CompactSizes\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sampleSize = gf_bs_read_u32(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t} else {\n\t\t//24-reserved\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tgf_bs_read_int(bs, 24);\n\t\ti = gf_bs_read_u8(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t\tswitch (i) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tptr->sampleSize = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//try to fix the file\n\t\t\t//no samples, no parsing pb\n\t\t\tif (!ptr->sampleCount) {\n\t\t\t\tptr->sampleSize = 16;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\testSize = (u32) (ptr->size) / ptr->sampleCount;\n\t\t\tif (!estSize && ((ptr->sampleCount+1)/2 == (ptr->size)) ) {\n\t\t\t\tptr->sampleSize = 4;\n\t\t\t\tbreak;\n\t\t\t} else if (estSize == 1 || estSize == 2) {\n\t\t\t\tptr->sampleSize = 8 * estSize;\n\t\t\t} else {\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\tif (ptr->sampleCount && (u64)ptr->sampleCount > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize && ptr->sampleCount) {\n\t\t\tif (ptr->sampleCount > ptr->size / 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\t\tptr->alloc_size = ptr->sampleCount;\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tptr->sizes[i] = gf_bs_read_u32(bs);\n\t\t\t\tif (ptr->max_size < ptr->sizes[i])\n\t\t\t\t\tptr->max_size = ptr->sizes[i];\n\t\t\t\tptr->total_size += ptr->sizes[i];\n\t\t\t\tptr->total_samples++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (ptr->sampleSize==4) {\n\t\t\tif (ptr->sampleCount / 2 > ptr->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->sampleCount > ptr->size / (ptr->sampleSize/8)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t\t//note we could optimize the mem usage by keeping the table compact\n\t\t//in memory. But that would complicate both caching and editing\n\t\t//we therefore keep all sizes as u32 and uncompress the table\n\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->sampleCount;\n\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tu32 s_size;\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, 4);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\ts_size = ptr->sizes[i+1] = gf_bs_read_int(bs, 4);\n\t\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\t\tptr->total_size += s_size;\n\t\t\t\t\tptr->total_samples++;\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, ptr->sampleSize);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleSizeBox, 0);\n\n\t//type is unknown here, can be regular or compact table\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//in both versions this is still valid\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_bs_write_u32(bs, ptr->sampleSize);\n\t} else {\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u8(bs, ptr->sampleSize);\n\t}\n\tgf_bs_write_u32(bs, ptr->sampleCount);\n\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize) {\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tgf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i+1], 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\n\t//regular table\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) continue;\n\t\t//switch to 8-bit table\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\t//switch to 16-bit table\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\t//switch to 32-bit table\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\n\t\t//check the size\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\t//if all samples are of the same size, switch to regular (more compact)\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t}\n\n\tif (fieldSize == 32) {\n\t\t//oops, doesn't fit in a compact table\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\t//make sure we are a compact table (no need to change the mem representation)\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\t//do not forget the 0 padding field for odd count\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stts_box_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastDTS = 0;\n#endif\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_SttsEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_SttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDelta = gf_bs_read_u32(bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tptr->w_currentSampleNum += ptr->entries[i].sampleCount;\n\t\tptr->w_LastDTS += (u64)ptr->entries[i].sampleCount * ptr->entries[i].sampleDelta;\n#endif\n\t\tif (ptr->max_ts_delta<ptr->entries[i].sampleDelta)\n\t\t\tptr->max_ts_delta = ptr->entries[i].sampleDelta;\n\n\t\tif (!ptr->entries[i].sampleDelta) {\n\t\t\tif ((i+1<ptr->nb_entries) ) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found stts entry with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t} else if (ptr->entries[i].sampleCount>1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] more than one stts entry at the end of the track with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t}\n\t\t}\n\t\t//cf issue 1644: some media streams may have sample duration > 2^31 (ttml mostly), we cannot patch this\n\t\t//for now we disable the check, one opt could be to have the check only for some media types, or only for the first entry\n#if 0\n\t\telse if ((s32) ptr->entries[i].sampleDelta < 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] stts entry %d has negative duration %d - forbidden ! Fixing to 1, sync may get lost (consider reimport raw media)\\n\", i, (s32) ptr->entries[i].sampleDelta ));\n\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t}\n#endif\n\n\t}\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries*8);\n\n\t//remove the last sample delta.\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (ptr->nb_entries) ptr->w_LastDTS -= ptr->entries[ptr->nb_entries-1].sampleDelta;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeToSampleBox, GF_ISOM_BOX_TYPE_STTS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDelta);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stts_box_size(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid tfhd_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err tfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->base_data_offset = gf_bs_read_u64(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->sample_desc_index = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_size = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err tfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->trackID);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_bs_write_u64(bs, ptr->base_data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tgf_bs_write_u32(bs, ptr->sample_desc_index);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfhd_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tims_box_del(GF_Box *s)\n{\n\tGF_TSHintEntryBox *tims = (GF_TSHintEntryBox *)s;\n\tgf_free(tims);\n}\n\nGF_Err tims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeScale = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeScale);\n\treturn GF_OK;\n}\n\nGF_Err tims_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tkhd_box_del(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err tkhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 32);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tptr->initial_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 60);\n\tptr->reserved2[0] = gf_bs_read_u32(bs);\n\tptr->reserved2[1] = gf_bs_read_u32(bs);\n\tptr->layer = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->volume = gf_bs_read_u16(bs);\n\tptr->reserved3 = gf_bs_read_u16(bs);\n\tptr->matrix[0] = gf_bs_read_u32(bs);\n\tptr->matrix[1] = gf_bs_read_u32(bs);\n\tptr->matrix[2] = gf_bs_read_u32(bs);\n\tptr->matrix[3] = gf_bs_read_u32(bs);\n\tptr->matrix[4] = gf_bs_read_u32(bs);\n\tptr->matrix[5] = gf_bs_read_u32(bs);\n\tptr->matrix[6] = gf_bs_read_u32(bs);\n\tptr->matrix[7] = gf_bs_read_u32(bs);\n\tptr->matrix[8] = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tkhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackHeaderBox, GF_ISOM_BOX_TYPE_TKHD);\n\ttmp->matrix[0] = 0x00010000;\n\ttmp->matrix[4] = 0x00010000;\n\ttmp->matrix[8] = 0x40000000;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tkhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_box_size(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\tptr->size += (ptr->version == 1) ? 32 : 20;\n\tptr->size += 60;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid traf_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tgf_list_del(ptr->TrackRuns);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tgf_free(ptr);\n}\n\nGF_Err traf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tBOX_FIELD_ASSIGN(tfhd, GF_TrackFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackRuns)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(sdtp, GF_SampleDependencyTypeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tBOX_FIELD_ASSIGN(tfdt, GF_TFBaseMediaDecodeTimeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\treturn GF_OK;\n\t//we will throw an error if both PIFF_PSEC and SENC are found. Not such files seen yet\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\tif (!is_rem)\n\t\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFXD) {\n\t\t\tBOX_FIELD_ASSIGN(tfxd, GF_MSSTimeExtBox)\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFRF) {\n\t\t\tBOX_FIELD_ASSIGN(tfrf, GF_MSSTimeRefBox)\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\tif (!is_rem)\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err traf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *traf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentBox, GF_ISOM_BOX_TYPE_TRAF);\n\ttmp->TrackRuns = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err traf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err traf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfhd, &pos);\n\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfdt, &pos);\n\n\t//cmaf-like\n\tif (ptr->truns_first) {\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\t//senc MUST be after saio in GPAC, as senc writing uses info from saio writing\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\t//subsamples will be last\n\t} else {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t}\n\n\t//when sdtp is present (smooth-like) write it after the trun box\n\tgf_isom_check_position(s, (GF_Box *)ptr->sdtp, &pos);\n\n\t//tfxd should be last ...\n\tif (ptr->tfxd)\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->tfxd, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tfxd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeExtBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFXD;\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfxd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err tfxd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tif (ptr->version == 0x01) {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfxd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tif (ptr->version) {\n\t\tgf_bs_write_u64(bs, ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration_in_track_timescale);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration_in_track_timescale);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfxd_box_size(GF_Box *s)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\ts->size += 4 + (ptr->version ? 16 : 8);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n\nGF_Box *tfrf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeRefBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFRF;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfrf_box_del(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tif (ptr->frags) gf_free(ptr->frags);\n\tgf_free(s);\n}\n\n\nGF_Err tfrf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tptr->frags_count = gf_bs_read_u8(bs);\n\tptr->frags = gf_malloc(sizeof(GF_MSSTimeEntry) * ptr->frags_count);\n\tif (!ptr->frags) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version == 0x01) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfrf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tgf_bs_write_u8(bs, ptr->frags_count);\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version==0x01) {\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfrf_box_size(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\ts->size += 5;\n\tif (ptr->version) s->size += 16 * ptr->frags_count;\n\telse s->size += 8 * ptr->frags_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid trak_box_del(GF_Box *s)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->chunk_cache)\n\t\tgf_bs_del(ptr->chunk_cache);\n#endif\n\tgf_free(s);\n}\n\nstatic GF_Err gf_isom_check_sample_desc(GF_TrackBox *trak)\n{\n\tGF_BitStream *bs;\n\tGF_UnknownBox *a;\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\n\tif (!trak->Media || !trak->Media->information) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no media box !\\n\" ));\n\t\treturn GF_OK;\n\t}\n\tif (!trak->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample table !\\n\" ));\n\t\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\t}\n\tstbl = trak->Media->information->sampleTable;\n\n\tif (!stbl->SampleDescription) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample description box !\\n\" ));\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\treturn GF_OK;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_UnknownBox*)gf_list_enum(stbl->SampleDescription->child_boxes, &i))) {\n\t\tGF_ProtectionSchemeInfoBox *sinf;\n\t\tu32 base_ent_type = 0;\n\t\tu32 type = a->type;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!sinf || !sinf->original_format) return GF_ISOM_INVALID_FILE;\n\t\t\ttype = sinf->original_format->data_format;\n\t\t\tbase_ent_type = ((GF_SampleEntryBox *)a)->internal_type;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_MP4S)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Protected sample entry %s uses incompatible sample description %s\\n\", gf_4cc_to_str(a->type), gf_4cc_to_str(type) ));\n\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_ISOM_BOX_TYPE_MHA1:\n\t\tcase GF_ISOM_BOX_TYPE_MHA2:\n\t\tcase GF_ISOM_BOX_TYPE_MHM1:\n\t\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tcase GF_ISOM_BOX_TYPE_OPUS:\n\t\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_ISOM_BOX_TYPE_IPCM:\n\t\tcase GF_ISOM_BOX_TYPE_FPCM:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_AUDIO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VP08:\n\t\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tcase GF_ISOM_BOX_TYPE_JPEG:\n\t\tcase GF_ISOM_BOX_TYPE_PNG:\n\t\tcase GF_ISOM_BOX_TYPE_JP2K:\n\t\tcase GF_ISOM_BOX_TYPE_MJP2:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_VIDEO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tcase GF_ISOM_BOX_TYPE_GHNT:\n\t\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_DIMS:\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_GENERIC))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (gf_box_valid_in_parent((GF_Box *) a, \"stsd\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unexpected box %s in stsd!\\n\", gf_4cc_to_str(a->type)));\n\t\t\tcontinue;\n\t\t}\n\t\t//we are sure to have an unknown box here\n\t\tassert(a->type==GF_ISOM_BOX_TYPE_UNKNOWN);\n\n\t\tif (!a->data || (a->dataSize<8) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Sample description %s does not have at least 8 bytes!\\n\", gf_4cc_to_str(a->original_4cc) ));\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a->dataSize > a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Sample description %s has wrong data size %d!\\n\", gf_4cc_to_str(a->original_4cc), a->dataSize));\n\t\t\tcontinue;\n\t\t}\n\n#define STSD_SWITCH_BOX(_box) \\\n\t\tif (gf_bs_available(bs)) { \\\n\t\t\tu64 pos = gf_bs_get_position(bs); \\\n\t\t\tu32 count_subb = 0; \\\n\t\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS);\\\n\t\t\te = gf_isom_box_array_read((GF_Box *) _box, bs); \\\n\t\t\tcount_subb = _box->child_boxes ? gf_list_count(_box->child_boxes) : 0; \\\n\t\t\tif (count_subb && !e) { \\\n\t\t\t\tgf_bs_seek(bs, pos); \\\n\t\t\t\t_box->data_size = (u32) gf_bs_available(bs); \\\n\t\t\t\tif (_box->data_size) { \\\n\t\t\t\t\t_box->data = a->data; \\\n\t\t\t\t\ta->data = NULL; \\\n\t\t\t\t\tmemmove(_box->data, _box->data + pos, _box->data_size); \\\n\t\t\t\t} \\\n\t\t\t} else { \\\n\t\t\t\t_box->data_size = 0; \\\n\t\t\t} \\\n\t\t} \\\n\t\tgf_bs_del(bs); \\\n\t\tif (!_box->data_size && _box->data) { \\\n\t\t\tgf_free(_box->data); \\\n\t\t\t_box->data = NULL; \\\n\t\t} \\\n\t\t_box->size = 0; \\\n\t\t_box->EntryType = a->original_4cc; \\\n\t\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, i-1); \\\n\t\tgf_isom_box_del((GF_Box *)a); \\\n\t\tgf_list_insert(trak->Media->information->sampleTable->SampleDescription->child_boxes, _box, i-1); \\\n\n\n\t\t/*only process visual or audio\n\t\tnote: no need for new_box_parent here since we always store sample descriptions in child_boxes*/\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t{\n\t\t\tGF_GenericVisualSampleEntryBox *genv = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgenv->size = a->size-8;\n\t\t\tgf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *) genv, bs);\n\n\t\t\tSTSD_SWITCH_BOX(genv)\n\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t{\n\t\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tgena->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox *) gena, bs);\n\n\t\t\tSTSD_SWITCH_BOX(gena)\n\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tgenm->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\n\t\t\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)genm, bs);\n\t\t\tif (e) return e;\n\n\t\t\tSTSD_SWITCH_BOX(genm)\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TKHD:\n\t\tBOX_FIELD_ASSIGN(Header, GF_TrackHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EDTS:\n\t\tBOX_FIELD_ASSIGN(editBox, GF_EditBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREF:\n\t\tBOX_FIELD_ASSIGN(References, GF_TrackReferenceBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MDIA:\n\t\tBOX_FIELD_ASSIGN(Media, GF_MediaBox)\n\t\tif (!is_rem)\n\t\t\t((GF_MediaBox *)a)->mediaTrack = ptr;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRGR:\n\t\tBOX_FIELD_ASSIGN(groups, GF_TrackGroupBox)\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_TAPT:\n\t\tBOX_FIELD_ASSIGN(Aperture, GF_Box)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UnknownUUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\te = gf_isom_check_sample_desc(ptr);\n\tif (e) return e;\n\n\tif (!ptr->Header) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information || !ptr->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information->sampleTable->SampleSize || (ptr->Media->information->sampleTable->SampleSize->sampleCount==0)) {\n\t\tif (ptr->Header->initial_duration) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Track with no samples but duration defined, ignoring duration\\n\"));\n\t\t\tptr->Header->initial_duration = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(ptr->Media->information->sampleTable->child_boxes); i++) {\n\t\tGF_Box *a = gf_list_get(ptr->Media->information->sampleTable->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *) a;\n\t\t\tbreak;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *)a;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *trak_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackBox, GF_ISOM_BOX_TYPE_TRAK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trak_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stri_box_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}\n\nGF_Err stri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->attribute_count = ptr->size / 4;\n\tif ((u64)ptr->attribute_count > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in stri\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stri_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->switch_group);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u32(bs, ptr->sub_track_id);\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->attribute_list[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stri_box_size(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\n\tptr->size += 8 + 4 * ptr->attribute_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsg_box_del(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->group_description_index) gf_free(ptr->group_description_index);\n\tgf_free(ptr);\n}\n\nGF_Err stsg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tISOM_DECREASE_SIZE(s, 6);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tptr->nb_groups = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(s, ptr->nb_groups*4);\n\tGF_SAFE_ALLOC_N(ptr->group_description_index, ptr->nb_groups, u32);\n\tif (!ptr->group_description_index) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tptr->group_description_index[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackSampleGroupBox, GF_ISOM_BOX_TYPE_STSG);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\tgf_bs_write_u16(bs, ptr->nb_groups);\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tgf_bs_write_u32(bs, ptr->group_description_index[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsg_box_size(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tptr->size += 6 + 4 * ptr->nb_groups;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid strk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err strk_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STRI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SubTrackInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STRD:\n\t\tBOX_FIELD_ASSIGN(strd, GF_Box)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err strk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->info) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing SubTrackInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *strk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackBox, GF_ISOM_BOX_TYPE_STRK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err strk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err strk_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tref_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err tref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\nGF_Box *tref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceBox, GF_ISOM_BOX_TYPE_TREF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err tref_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid reftype_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->trackIDs) gf_free(ptr->trackIDs);\n\tgf_free(ptr);\n}\n\n\nGF_Err reftype_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\n\tbytesToRead = (u32) (ptr->size);\n\tif (!bytesToRead) return GF_OK;\n\n\tptr->trackIDCount = (u32) (bytesToRead) / sizeof(u32);\n\tptr->trackIDs = (GF_ISOTrackID *) gf_malloc(ptr->trackIDCount * sizeof(GF_ISOTrackID));\n\tif (!ptr->trackIDs) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tptr->trackIDs[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *reftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}\n\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, GF_ISOTrackID trackID, u16 *outRefIndex)\n{\n\tu32 i;\n\tif (!ref || !trackID) return GF_BAD_PARAM;\n\n\tif (outRefIndex) *outRefIndex = 0;\n\t//don't add a dep if already here !!\n\tfor (i = 0; i < ref->trackIDCount; i++) {\n\t\tif (ref->trackIDs[i] == trackID) {\n\t\t\tif (outRefIndex) *outRefIndex = i+1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tref->trackIDs = (GF_ISOTrackID *) gf_realloc(ref->trackIDs, (ref->trackIDCount + 1) * sizeof(GF_ISOTrackID) );\n\tif (!ref->trackIDs) return GF_OUT_OF_MEM;\n\tref->trackIDs[ref->trackIDCount] = trackID;\n\tref->trackIDCount++;\n\tif (outRefIndex) *outRefIndex = ref->trackIDCount;\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err reftype_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tptr->type = ptr->reference_type;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFT;\n\tif (e) return e;\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->trackIDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err reftype_box_size(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->trackIDCount)\n\t\tptr->size += (ptr->trackIDCount * sizeof(u32));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trex_box_del(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->trackID = gf_bs_read_u32(bs);\n\tptr->def_sample_desc_index = gf_bs_read_u32(bs);\n\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\tptr->def_sample_size = gf_bs_read_u32(bs);\n\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *trex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\t//we always write 1 in trex default sample desc as using 0 breaks chrome/opera/...\n\tgf_bs_write_u32(bs, ptr->def_sample_desc_index ? ptr->def_sample_desc_index : 1);\n\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\treturn GF_OK;\n}\n\nGF_Err trex_box_size(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tptr->size += 20;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid trep_box_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *trep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtensionPropertiesBox, GF_ISOM_BOX_TYPE_TREP);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\treturn GF_OK;\n}\n\nGF_Err trep_box_size(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trun_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->samples) gf_free(ptr->samples);\n\tif (ptr->cache) gf_bs_del(ptr->cache);\n\tif (ptr->sample_order) gf_free(ptr->sample_order);\n\tgf_free(ptr);\n}\n\n#ifdef GF_ENABLE_CTRN\n\nstatic u32 ctrn_field_size(u32 field_idx)\n{\n\tif (field_idx==3) return 4;\n\treturn field_idx;\n}\n\nu32 gf_isom_ctrn_field_size_bits(u32 field_idx)\n{\n\tif (field_idx==3) return 32;\n\treturn field_idx*8;\n}\nstatic u32 ctrn_read_flags(GF_BitStream *bs, u32 nbbits)\n{\n\tu32 val = gf_bs_read_int(bs, nbbits);\n\tif (nbbits==16) val <<= 16;\n\telse if (nbbits==8) val <<= 24;\n\treturn val;\n}\n\nstatic GF_Err ctrn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count, flags, first_idx=0;\n\tBool inherit_dur, inherit_size, inherit_flags, inherit_ctso;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tflags = ptr->flags;\n\tptr->ctrn_flags = flags;\n\tptr->flags = 0;\n\n\tptr->sample_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tptr->data_offset = gf_bs_read_u16(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\t} else {\n\t\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t}\n\t\tptr->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t}\n\tif (flags & GF_ISOM_CTRN_CTSO_MULTIPLIER) {\n\t\tptr->ctso_multiplier = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t}\n\t/*no sample dur/sample_flag/size/ctso for first or following, create a pack sample */\n\tif (! (flags & 0x00FFFF00)) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->nb_pack = ptr->sample_count;\n\t\tgf_list_add(ptr->entries, ent);\n\t\treturn GF_OK;\n\t}\n\t/*allocate all entries*/\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->entries, ent);\n\t}\n\t//unpack flags\n\tptr->ctrn_first_dur = (flags>>22) & 0x3;\n\tptr->ctrn_first_size = (flags>>20) & 0x3;\n\tptr->ctrn_first_sample_flags = (flags>>18) & 0x3;\n\tptr->ctrn_first_ctts = (flags>>16) & 0x3;\n\tptr->ctrn_dur = (flags>>14) & 0x3;\n\tptr->ctrn_size = (flags>>12) & 0x3;\n\tptr->ctrn_sample_flags = (flags>>10) & 0x3;\n\tptr->ctrn_ctts = (flags>>8) & 0x3;\n\n\tinherit_dur = flags & GF_ISOM_CTRN_INHERIT_DUR;\n\tinherit_size = flags & GF_ISOM_CTRN_INHERIT_SIZE;\n\tinherit_flags = flags & GF_ISOM_CTRN_INHERIT_FLAGS;\n\tinherit_ctso = flags & GF_ISOM_CTRN_INHERIT_CTSO;\n\n\tif (flags & GF_ISOM_CTRN_FIRST_SAMPLE) {\n\t\tent = gf_list_get(ptr->entries, 0);\n\t\tfirst_idx = 1;\n\t\tif (!inherit_dur && ptr->ctrn_first_dur) {\n\t\t\tent->Duration = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_dur) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_dur) );\n\t\t}\n\t\tif (!inherit_size && ptr->ctrn_first_size) {\n\t\t\tent->size = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_size) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_size) );\n\t\t}\n\t\tif (!inherit_flags && ptr->ctrn_first_sample_flags) {\n\t\t\tent->flags = ctrn_read_flags(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_sample_flags) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_sample_flags) );\n\t\t}\n\t\tif (!inherit_ctso && ptr->ctrn_first_ctts) {\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_ctts) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_ctts) );\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\tcount = ptr->sample_count - first_idx;\n\tif (!inherit_dur && ptr->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_dur);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->Duration = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_size && ptr->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_size);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->size = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_flags && ptr->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_sample_flags);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->flags = ctrn_read_flags(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_ctso && ptr->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_ctts);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, nbbits);\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->type == GF_ISOM_BOX_TYPE_CTRN) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_TRUN;\n\t\tptr->use_ctrn = GF_TRUE;\n\t\treturn ctrn_box_read(s, bs);\n\t}\n#endif\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t}\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\t//memset to 0 !!\n\t\tmemset(ptr->samples, 0, sizeof(GF_TrunEntry));\n\t\tptr->sample_alloc = ptr->nb_samples = 1;\n\t\tptr->samples[0].nb_pack = ptr->sample_count;\n\t} else {\n\t\t//if we get here, at least one flag (so at least 4 bytes) is set, check size\n\t\tif (ptr->sample_count * 4 > ptr->size) {\n\t\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count*4);\n\t\t}\n\t\tif ((u64)ptr->sample_count > (u64)SIZE_MAX/sizeof(GF_TrunEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of samples %d in trun\\n\", ptr->sample_count));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry) * ptr->sample_count);\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\tptr->sample_alloc = ptr->nb_samples = ptr->sample_count;\n\t\t//memset to 0 upfront\n\t\tmemset(ptr->samples, 0, ptr->sample_count * sizeof(GF_TrunEntry));\n\n\t\t//read each entry (even though nothing may be written)\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tu32 trun_size = 0;\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t\t} else {\n\t\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t\t}\n\t}\n\t/*todo parse sample reorder*/\n\tif (ptr->size) {\n\t\tgf_bs_skip_bytes(bs, ptr->size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trun_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#ifdef GF_ENABLE_CTRN\nstatic void ctrn_write_sample_flags(GF_BitStream *bs, u32 flags, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (field_size==8) flags = flags>>24;\n\telse if (field_size==16) flags = flags>>16;\n\tgf_bs_write_int(bs, flags, field_size);\n}\n\n\nstatic void ctrn_write_ctso(GF_TrackFragmentRunBox *ctrn, GF_BitStream *bs, u32 ctso, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_int(bs, ctso / ctrn->ctso_multiplier, field_size);\n\t} else {\n\t\tgf_bs_write_int(bs, ctso, field_size);\n\t}\n}\n\nGF_Err ctrn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, count, flags;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ctrn = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tflags = ctrn->flags;\n\tctrn->flags = ctrn->ctrn_flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_CTRN;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tctrn->flags = flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_TRUN;\n\n\tgf_bs_write_u16(bs, ctrn->sample_count);\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (ctrn->ctrn_flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tgf_bs_write_u16(bs, ctrn->data_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, ctrn->data_offset);\n\t\t}\n\t}\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_u16(bs, ctrn->ctso_multiplier);\n\t}\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tgf_bs_write_int(bs, ent->Duration, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_dur) );\n\tgf_bs_write_int(bs, ent->size, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_size) );\n\tctrn_write_sample_flags(bs, ent->flags, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_sample_flags) );\n\tctrn_write_ctso(ctrn,bs, ent->CTS_Offset, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_ctts) );\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_dur);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->Duration, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_size);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->size, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_sample_flags);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_sample_flags(bs, a_ent->flags, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_ctts);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_ctso(ctrn, bs, a_ent->CTS_Offset, nbbits);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_write(s, bs);\n#endif\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tgf_bs_write_u32(bs, ptr->data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tgf_bs_write_u32(bs, ptr->first_sample_flags);\n\t}\n\n\tif (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) )  {\n\t\tfor (i=0; i<ptr->nb_samples; i++) {\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tgf_bs_write_u32(bs, p->Duration);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tgf_bs_write_u32(bs, p->size);\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tgf_bs_write_u32(bs, p->flags);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->CTS_Offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) p->CTS_Offset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bits = 8;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bits = 32;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bits = 24;\n\t\telse if (ptr->sample_count>0xFF) nb_bits = 16;\n\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tgf_bs_write_int(bs, ptr->sample_order[i], nb_bits);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic u32 ctrn_sample_flags_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val & 0x0000FFFF)\n\t\treturn 3;\n\tif (val & 0x00FF0000)\n\t\treturn 2;\n\treturn 1;\n}\nstatic u32 ctrn_u32_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val<=255) return 1;\n\tif (val<=65535) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_s32_to_index(s32 val)\n{\n\tif (!val) return 0;\n\tif (ABS(val)<=127) return 1;\n\tif (ABS(val)<=32767) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_ctts_to_index(GF_TrackFragmentRunBox *ctrn, s32 ctts)\n{\n\tif (!(ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET))\n\t\treturn 0;\n\n\tif (!ctts) return 0;\n\n\tif (ctrn->version) {\n\t\tif (ctrn->ctso_multiplier) return ctrn_s32_to_index(ctts / ctrn->ctso_multiplier);\n\t\treturn ctrn_s32_to_index(ctts);\n\t}\n\tassert(ctts>0);\n\tif (ctrn->ctso_multiplier) return ctrn_u32_to_index((u32)ctts / ctrn->ctso_multiplier);\n\treturn ctrn_s32_to_index((u32)ctts);\n}\n\nstatic GF_Err ctrn_box_size(GF_TrackFragmentRunBox *ctrn)\n{\n\tBool use_ctso_multi = GF_TRUE;\n\tu32 i, count;\n\tGF_TrunEntry *ent;\n\n\tctrn->ctrn_flags = 0;\n\tctrn->ctrn_first_dur = ctrn->ctrn_first_size = ctrn->ctrn_first_sample_flags = ctrn->ctrn_first_ctts = 0;\n\tctrn->ctrn_dur = ctrn->ctrn_size = ctrn->ctrn_sample_flags = ctrn->ctrn_ctts = 0;\n\n\tctrn->size += 2; //16 bits for sample count\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tctrn->ctrn_flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t\tif (ABS(ctrn->data_offset) < 32767) {\n\t\t\tctrn->size += 2;\n\t\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_DATAOFFSET_16;\n\t\t} else\n\t\t\tctrn->size += 4;\n\t}\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctso_multiplier && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET) && (ctrn->ctso_multiplier<=0xFFFF) ) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tif (a_ent->CTS_Offset % ctrn->ctso_multiplier) {\n\t\t\t\tuse_ctso_multi = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuse_ctso_multi = GF_FALSE;\n\t}\n\tif (ctrn->use_inherit) {\n\t\tuse_ctso_multi = GF_FALSE;\n\t\tctrn->ctrn_flags |= 0xB0; //duration=1,size=0,flags=1,cts=1 << 4\n\t}\n\n\tif (use_ctso_multi) {\n\t\tctrn->size += 2;\n\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_CTSO_MULTIPLIER;\n\t} else {\n\t\tctrn->ctso_multiplier = 0;\n\t}\n\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tctrn->ctrn_flags |= GF_ISOM_CTRN_FIRST_SAMPLE;\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\tctrn->ctrn_first_dur = ctrn_u32_to_index(ent->Duration);\n\t\tif (ctrn->ctrn_first_dur) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_dur);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_dur<<22;\n\t\t}\n\t}\n\n\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\tctrn->ctrn_first_size = ctrn_u32_to_index(ent->size);\n\t\tif (ctrn->ctrn_first_size) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_size);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_size<<20;\n\t\t}\n\t}\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\tctrn->ctrn_first_sample_flags = ctrn_sample_flags_to_index(ent->flags);\n\t\tif (ctrn->ctrn_first_sample_flags) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_sample_flags);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_sample_flags<<18;\n\t\t}\n\t}\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET)) {\n\t\tctrn->ctrn_first_ctts = ctrn_ctts_to_index(ctrn, ent->CTS_Offset);\n\t\tif (ctrn->ctrn_first_ctts) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_ctts);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_ctts<<16;\n\t\t}\n\t}\n\n\tfor (i=1; i<count; i++) {\n\t\tu8 field_idx;\n\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->Duration);\n\t\t\tif (ctrn->ctrn_dur < field_idx)\n\t\t\t\tctrn->ctrn_dur = field_idx;\n\t\t}\n\t\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->size);\n\t\t\tif (ctrn->ctrn_size < field_idx)\n\t\t\t\tctrn->ctrn_size = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\t\tfield_idx = ctrn_sample_flags_to_index(a_ent->flags);\n\t\t\tif (ctrn->ctrn_sample_flags < field_idx)\n\t\t\t\tctrn->ctrn_sample_flags = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit) {\n\t\t\tfield_idx = ctrn_ctts_to_index(ctrn, a_ent->CTS_Offset);\n\t\t\tif (ctrn->ctrn_ctts < field_idx)\n\t\t\t\tctrn->ctrn_ctts = field_idx;\n\t\t}\n\t}\n\tcount-=1;\n\tif (ctrn->ctrn_dur) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_dur);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_dur<<14;\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_size);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_size<<12;\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_sample_flags);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_sample_flags<<10;\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_ctts);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_ctts<<8;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_size(ptr);\n#endif\n\n\tptr->size += 4;\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) ptr->size += 4;\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bytes = 1;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bytes = 4;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bytes = 3;\n\t\telse if (ptr->sample_count>0xFF) nb_bytes = 2;\n\t\tptr->size += ptr->sample_count*nb_bytes;\n\t}\n\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\treturn GF_OK;\n\t}\n\n\t//if nothing to do, this will be skipped automatically\n\tif (ptr->flags & GF_ISOM_TRUN_DURATION) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_SIZE) ptr->size += 4*ptr->nb_samples;\n\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) ptr->size += 4*ptr->nb_samples;\n\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tsro_box_del(GF_Box *s)\n{\n\tGF_TimeOffHintEntryBox *tsro = (GF_TimeOffHintEntryBox *)s;\n\tgf_free(tsro);\n}\n\nGF_Err tsro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->TimeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tsro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeOffHintEntryBox, GF_ISOM_BOX_TYPE_TSRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tsro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->TimeOffset);\n\treturn GF_OK;\n}\n\nGF_Err tsro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid udta_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (ptr == NULL) return;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\tgf_list_del(ptr->recordList);\n\tgf_free(ptr);\n}\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tif (ptr == NULL) return NULL;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tif (map->boxType == box_type) {\n\t\t\tif ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map;\n\t\t\tif (!memcmp(map->uuid, *uuid, 16)) return map;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_Err udta_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Err e;\n\tu32 box_type;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\tif (!a) return GF_OK;\n\n\t//detach from parent list if any\n\tgf_list_del_item(ptr->child_boxes, a);\n\n\t/* for unknown udta boxes, we reference them by their original box type */\n\tbox_type = a->type;\n\tif (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox* unkn = (GF_UnknownBox *)a;\n\t\tbox_type = unkn->original_4cc;\n\t}\n\n\tmap = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);\n\tif (map == NULL) {\n\t\tif (is_rem) return GF_OK;\n\n\t\tmap = (GF_UserDataMap *) gf_malloc(sizeof(GF_UserDataMap));\n\t\tif (map == NULL) return GF_OUT_OF_MEM;\n\t\tmemset(map, 0, sizeof(GF_UserDataMap));\n\n\t\tmap->boxType = box_type;\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UUID)\n\t\t\tmemcpy(map->uuid, ((GF_UUIDBox *)a)->uuid, 16);\n\t\tmap->boxes = gf_list_new();\n\t\tif (!map->boxes) {\n\t\t\tgf_free(map);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(ptr->recordList, map);\n\t\tif (e) return e;\n\t}\n\tif (is_rem) {\n\t\tgf_list_del_item(map->boxes, a);\n\t\treturn GF_OK;\n\t}\n\treturn gf_list_add(map->boxes, a);\n}\n\n\nGF_Err udta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\tif (s->size==4) {\n\t\tu32 val = gf_bs_read_u32(bs);\n\t\ts->size = 0;\n\t\tif (val) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] udta has 4 remaining bytes set to %08X but they should be 0\\n\", val));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *udta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err udta_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_write(s, map->boxes, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err udta_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_size(s, map->boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vmhd_box_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err vmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\nGF_Box *vmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VideoMediaHeaderBox, GF_ISOM_BOX_TYPE_VMHD);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid void_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n\nGF_Box *void_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);\n\treturn tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err void_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err void_box_size(GF_Box *s)\n{\n\ts->size = 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *pdin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProgressiveDownloadBox, GF_ISOM_BOX_TYPE_PDIN);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pdin_box_del(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->rates) gf_free(ptr->rates);\n\tif (ptr->times) gf_free(ptr->times);\n\tgf_free(ptr);\n}\n\n\nGF_Err pdin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\n\tptr->count = (u32) (ptr->size) / 8;\n\tptr->rates = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->rates) return GF_OUT_OF_MEM;\n\tptr->times = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->times) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tptr->rates[i] = gf_bs_read_u32(bs);\n\t\tptr->times[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pdin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->rates[i]);\n\t\tgf_bs_write_u32(bs, ptr->times[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pdin_box_size(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\tptr->size += 8*ptr->count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *sdtp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDependencyTypeBox, GF_ISOM_BOX_TYPE_SDTP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid sdtp_box_del(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info) gf_free(ptr->sample_info);\n\tgf_free(ptr);\n}\n\n\nGF_Err sdtp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\n\t/*out-of-order sdtp, assume no padding at the end*/\n\tif (!ptr->sampleCount) ptr->sampleCount = (u32) ptr->size;\n\telse if (ptr->sampleCount > (u32) ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_info = (u8 *) gf_malloc(sizeof(u8)*ptr->sampleCount);\n\tif (!ptr->sample_info) return GF_OUT_OF_MEM;\n\tptr->sample_alloc = ptr->sampleCount;\n\tgf_bs_read_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\tISOM_DECREASE_SIZE(ptr, ptr->sampleCount);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sdtp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_box_size(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\tptr->size += ptr->sampleCount;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *pasp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PixelAspectRatioBox, GF_ISOM_BOX_TYPE_PASP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pasp_box_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err pasp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->hSpacing = gf_bs_read_u32(bs);\n\tptr->vSpacing = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}\n\nGF_Err pasp_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *clap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanApertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid clap_box_del(GF_Box *s)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err clap_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 32);\n\tptr->cleanApertureWidthN = gf_bs_read_u32(bs);\n\tptr->cleanApertureWidthD = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightN = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightD = gf_bs_read_u32(bs);\n\tptr->horizOffN = (s32) gf_bs_read_u32(bs);\n\tptr->horizOffD = gf_bs_read_u32(bs);\n\tptr->vertOffN = (s32) gf_bs_read_u32(bs);\n\tptr->vertOffD = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthD);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightD);\n\tgf_bs_write_u32(bs, (u32) ptr->horizOffN);\n\tgf_bs_write_u32(bs, ptr->horizOffD);\n\tgf_bs_write_u32(bs, (u32) ptr->vertOffN);\n\tgf_bs_write_u32(bs, ptr->vertOffD);\n\treturn GF_OK;\n}\n\nGF_Err clap_box_size(GF_Box *s)\n{\n\ts->size += 32;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *metx_box_new()\n{\n\t//type is overridden by the box constructor\n\tISOM_DECL_BOX_ALLOC(GF_MetaDataSampleEntryBox, GF_ISOM_BOX_TYPE_METX);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid metx_box_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tgf_free(ptr);\n}\n\n\nGF_Err metx_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TXTC:\n\t\t//we allow the config box on metx\n\t\tBOX_FIELD_ASSIGN(config, GF_TextConfigBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err metx_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tGF_Err e;\n\tchar *str;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tsize = (u32) ptr->size;\n\tstr = gf_malloc(sizeof(char)*size);\n\tif (!str) return GF_OUT_OF_MEM;\n\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i>1) {\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t} else {\n\t\t\tptr->content_encoding = gf_strdup(str);\n\t\t}\n\t}\n\n\ti=0;\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t\t}\n\t\t}\n\n\t\ti=0;\n\t\twhile (size) {\n\t\t\tstr[i] = gf_bs_read_u8(bs);\n\t\t\tsize--;\n\t\t\tif (!str[i]) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!size && i>1 && str[i-1]) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\t\tgf_free(str);\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->mime_type = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t}\n\t\t}\n\t}\n\t//mett, sbtt, stxt, stpp\n\telse {\n\t\tif (i>1) ptr->mime_type = gf_strdup(str);\n\t}\n\tptr->size = size;\n\tgf_free(str);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err metx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, (u32) strlen(ptr->content_encoding));\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tgf_bs_write_data(bs, ptr->xml_namespace, (u32) strlen(ptr->xml_namespace));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tgf_bs_write_data(bs, ptr->xml_schema_loc, (u32) strlen(ptr->xml_schema_loc));\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err metx_box_size(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* SimpleTextSampleEntry */\nGF_Box *txtc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextConfigBox, GF_ISOM_BOX_TYPE_TXTC);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid txtc_box_del(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->config) gf_free(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err txtc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in txtc box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->config = (char *)gf_malloc(sizeof(char)*((u32) ptr->size+1));\n\tif (!ptr->config) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->config, (u32) ptr->size);\n\tptr->config[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err txtc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->config)\n\t\tgf_bs_write_data(bs, ptr->config, (u32) strlen(ptr->config));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err txtc_box_size(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tif (ptr->config)\n\t\tptr->size += strlen(ptr->config);\n\tptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *dec3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dac3_box_del(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tgf_free(ptr);\n}\n\n\nGF_Err dac3_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\treturn gf_odf_ac3_config_parse_bs(bs, ptr->cfg.is_ec3, &ptr->cfg);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\t\n\treturn gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n}\n\nGF_Err dac3_box_size(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\ts->size += 2;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\ts->size += 3;\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub)\n\t\t\t\ts->size += 1;\n\t\t}\n\t} else {\n\t\ts->size += 3;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid lsrc_box_del(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->hdr) gf_free(ptr->hdr);\n\tgf_free(ptr);\n}\n\n\nGF_Err lsrc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->hdr_size = (u32) ptr->size;\n\tptr->hdr = gf_malloc(sizeof(char)*ptr->hdr_size);\n\tif (!ptr->hdr) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Box *lsrc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASERConfigurationBox, GF_ISOM_BOX_TYPE_LSRC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err lsrc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Err lsrc_box_size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid lsr1_box_del(GF_Box *s)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err lsr1_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_LSRC:\n\t\tBOX_FIELD_ASSIGN(lsr_config, GF_LASERConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tBOX_FIELD_ASSIGN(descr, GF_MPEG4ExtensionDescriptorsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *lsr1_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err lsr1_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->lsr_config, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid sidx_box_del(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->refs) gf_free(ptr->refs);\n\tgf_free(ptr);\n}\n\nGF_Err sidx_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tif (!ptr->refs) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *sidx_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sidx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->reference_ID);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->earliest_presentation_time);\n\t\tgf_bs_write_u32(bs, (u32) ptr->first_offset);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->earliest_presentation_time);\n\t\tgf_bs_write_u64(bs, ptr->first_offset);\n\t}\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_type, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_size, 31);\n\t\tgf_bs_write_u32(bs, ptr->refs[i].subsegment_duration);\n\t\tgf_bs_write_int(bs, ptr->refs[i].starts_with_SAP, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_type, 3);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_delta_time, 28);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sidx_box_size(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->size += 12;\n\tif (ptr->version==0) {\n\t\tptr->size += 8;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size += ptr->nb_refs * 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ssix_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->subsegments) {\n\t\tfor (i = 0; i < ptr->subsegment_alloc; i++) {\n\t\t\tGF_SubsegmentInfo *subsegment = &ptr->subsegments[i];\n\t\t\tif (subsegment->ranges) gf_free(subsegment->ranges);\n\t\t}\n\t\tgf_free(ptr->subsegments);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err ssix_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\t//each subseg has at least one range_count (4 bytes), abort if not enough bytes (broken box)\n\tif (ptr->size / 4 < ptr->subsegment_count || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentInfo))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->subsegment_alloc = ptr->subsegment_count;\n\tGF_SAFE_ALLOC_N(ptr->subsegments, ptr->subsegment_count, GF_SubsegmentInfo);\n\tif (!ptr->subsegments)\n\t    return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_SubsegmentInfo *subseg = &ptr->subsegments[i];\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\t//each range is 4 bytes, abort if not enough bytes\n\t\tif (ptr->size / 4 < subseg->range_count || (u64)subseg->range_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentRangeInfo))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tsubseg->ranges = (GF_SubsegmentRangeInfo*) gf_malloc(sizeof(GF_SubsegmentRangeInfo) * subseg->range_count);\n\t\tif (!subseg->ranges) return GF_OUT_OF_MEM;\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tsubseg->ranges[j].level = gf_bs_read_u8(bs);\n\t\t\tsubseg->ranges[j].range_size = gf_bs_read_u24(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ssix_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ssix_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i = 0; i<ptr->subsegment_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->subsegments[i].range_count);\n\t\tfor (j = 0; j < ptr->subsegments[i].range_count; j++) {\n\t\t\tgf_bs_write_u8(bs, ptr->subsegments[i].ranges[j].level);\n\t\t\tgf_bs_write_u24(bs, ptr->subsegments[i].ranges[j].range_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ssix_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tptr->size += 4;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tptr->size += 4 + 4 * ptr->subsegments[i].range_count;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid leva_box_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}\n\nGF_Err leva_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->level_count = gf_bs_read_u8(bs);\n\t//each level is at least 5 bytes\n\tif (ptr->size / 5 < ptr->level_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment);\n\tif (!ptr->levels) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tGF_LevelAssignment *level = &ptr->levels[i];\n\t\tu8 tmp;\n\t\tif (!level || ptr->size < 5) return GF_BAD_PARAM;\n\t\tISOM_DECREASE_SIZE(ptr, 5)\n\n\t\tlevel->track_id = gf_bs_read_u32(bs);\n\t\ttmp = gf_bs_read_u8(bs);\n\t\tlevel->padding_flag = tmp >> 7;\n\t\tlevel->type = tmp & 0x7F;\n\t\tif (level->type == 0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t\tlevel->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 4) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->sub_track_id = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *leva_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LevelAssignmentBox, GF_ISOM_BOX_TYPE_LEVA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err leva_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->level_count);\n\tfor (i = 0; i<ptr->level_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->levels[i].track_id);\n\t\tgf_bs_write_u8(bs, ptr->levels[i].padding_flag << 7 | (ptr->levels[i].type & 0x7F));\n\t\tif (ptr->levels[i].type == 0) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type_parameter);\n\t\t}\n\t\telse if (ptr->levels[i].type == 4) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].sub_track_id);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err leva_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pcrb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PcrInfoBox, GF_ISOM_BOX_TYPE_PCRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pcrb_box_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}\n\nGF_Err pcrb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\n\tif ((u64)ptr->subsegment_count > ptr->size / 8 || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of subsegment %d in pcrb\\n\", ptr->subsegment_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->pcr_values = gf_malloc(sizeof(u64)*ptr->subsegment_count);\n\tif (!ptr->pcr_values) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->subsegment_count; i++) {\n\t\tu64 data1 = gf_bs_read_u32(bs);\n\t\tu64 data2 = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 6);\n\t\tptr->pcr_values[i] = (data1 << 10) | (data2 >> 6);\n\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pcrb_box_size(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->size += 4;\n\tptr->size += ptr->subsegment_count * 6;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid subs_box_del(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->Samples)) {\n\t\tGF_SubSampleInfoEntry *pSamp;\n\t\tpSamp = (GF_SubSampleInfoEntry*)gf_list_get(ptr->Samples, 0);\n\t\twhile (gf_list_count(pSamp->SubSamples)) {\n\t\t\tGF_SubSampleEntry *pSubSamp;\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, 0);\n\t\t\tgf_free(pSubSamp);\n\t\t\tgf_list_rem(pSamp->SubSamples, 0);\n\t\t}\n\t\tgf_list_del(pSamp->SubSamples);\n\t\tgf_free(pSamp);\n\t\tgf_list_rem(ptr->Samples, 0);\n\t}\n\tgf_list_del(ptr->Samples);\n\tgf_free(ptr);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err subs_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, entry_count;\n\tu16 subsample_count;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_bs_write_u32(bs, entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\tgf_bs_write_u32(bs, pSamp->sample_delta);\n\t\tgf_bs_write_u16(bs, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tif (ptr->version == 1) {\n\t\t\t\tgf_bs_write_u32(bs, pSubSamp->subsample_size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, pSubSamp->subsample_size);\n\t\t\t}\n\t\t\tgf_bs_write_u8(bs, pSubSamp->subsample_priority);\n\t\t\tgf_bs_write_u8(bs, pSubSamp->discardable);\n\t\t\tgf_bs_write_u32(bs, pSubSamp->reserved);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Err subs_box_size(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\tu32 entry_count, i;\n\tu16 subsample_count;\n\n\t// add 4 byte for entry_count\n\tptr->size += 4;\n\tentry_count = gf_list_count(ptr->Samples);\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\t// 4 byte for sample_delta, 2 byte for subsample_count\n\t\t// and 6 + (4 or 2) bytes for each subsample\n\t\tptr->size += 4 + 2 + subsample_count * (6 + (ptr->version==1 ? 4 : 2));\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err subs_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tentry_count = gf_bs_read_u32(bs);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tu32 subs_size=0;\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_malloc(sizeof(GF_SubSampleInfoEntry));\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\n\t\tmemset(pSamp, 0, sizeof(GF_SubSampleInfoEntry));\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tpSamp->sample_delta = gf_bs_read_u32(bs);\n\t\tsubsample_count = gf_bs_read_u16(bs);\n\t\tsubs_size=6;\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_malloc(sizeof(GF_SubSampleEntry));\n\t\t\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\n\t\t\tmemset(pSubSamp, 0, sizeof(GF_SubSampleEntry));\n\t\t\tif (ptr->version==1) {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u32(bs);\n\t\t\t\tsubs_size+=4;\n\t\t\t} else {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u16(bs);\n\t\t\t\tsubs_size+=2;\n\t\t\t}\n\t\t\tpSubSamp->subsample_priority = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->discardable = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->reserved = gf_bs_read_u32(bs);\n\t\t\tsubs_size+=6;\n\n\t\t\tgf_list_add(pSamp->SubSamples, pSubSamp);\n\t\t}\n\t\tgf_list_add(ptr->Samples, pSamp);\n\t\tISOM_DECREASE_SIZE(ptr, subs_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Box *tfdt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfdt_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfdt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u64(bs, ptr->baseMediaDecodeTime);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->baseMediaDecodeTime);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfdt_box_size(GF_Box *s)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (!ptr->version && (ptr->baseMediaDecodeTime<=0xFFFFFFFF)) {\n\t\t//ptr->version = 0;\n\t\tptr->size += 4;\n\t} else {\n\t\tptr->version = 1;\n\t\tptr->size += 8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Box *rvcc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RVCConfigurationBox, GF_ISOM_BOX_TYPE_RVCC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid rvcc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err rvcc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->predefined_rvc_config = gf_bs_read_u16(bs);\n\tif (!ptr->predefined_rvc_config) {\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->rvc_meta_idx = gf_bs_read_u16(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err rvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->predefined_rvc_config);\n\tif (!ptr->predefined_rvc_config) {\n\t\tgf_bs_write_u16(bs, ptr->rvc_meta_idx);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rvcc_box_size(GF_Box *s)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox *)s;\n\tptr->size += 2;\n\tif (! ptr->predefined_rvc_config) ptr->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *sbgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupBox, GF_ISOM_BOX_TYPE_SBGP);\n\treturn (GF_Box *)tmp;\n}\nvoid sbgp_box_del(GF_Box *a)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox *)a;\n\tif (p->sample_entries) gf_free(p->sample_entries);\n\tgf_free(p);\n}\n\nGF_Err sbgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(GF_SampleGroupEntry)*ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_SampleGroupEntry))\n\t    return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sbgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version==1)\n\t\tgf_bs_write_u32(bs, p->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, p->entry_count);\n\tfor (i = 0; i<p->entry_count; i++ ) {\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].sample_count);\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].group_description_index);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sbgp_box_size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}\n\nvoid sgpd_del_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_free(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tif (seig->key_info) gf_free(seig->key_info);\n\t\tgf_free(entry);\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tif (spor->subp_track_ref_idx) gf_free(spor->subp_track_ref_idx);\n\t\tgf_free(spor);\n\t}\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tif (sulm->groupIDs) gf_free(sulm->groupIDs);\n\t\tgf_free(sulm);\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->data) gf_free(ptr->data);\n\t\tgf_free(ptr);\n\t}\n\t}\n}\n\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tgf_bs_write_int(bs, ((GF_RollRecoveryEntry*)entry)->roll_distance, 16);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->dependent_flag, 1);\n\t\tgf_bs_write_int(bs, 0, 3);\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->SAP_type, 4);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tgf_bs_write_int(bs, ((GF_SYNCEntry*)entry)->NALU_type, 6);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tgf_bs_write_int(bs, ((GF_TemporalLevelEntry*)entry)->level_independently_decodable, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0];\n\t\tu32 nb_keys = 1;\n\t\tif (use_mkey) {\n\t\t\tnb_keys = seig->key_info[1];\n\t\t\tnb_keys<<=8;\n\t\t\tnb_keys |= seig->key_info[2];\n\t\t}\n\t\tgf_bs_write_int(bs, use_mkey ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, seig->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, seig->skip_byte_block, 4);\n\t\tgf_bs_write_u8(bs, seig->IsProtected);\n\t\tif (nb_keys>1) {\n\t\t\tgf_bs_write_data(bs, seig->key_info+1, seig->key_info_size-1);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, seig->key_info+3, seig->key_info_size - 3);\n\t\t}\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_write_entry(entry, bs);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_write_entry(entry, bs);\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *) entry;\n\t\tgf_bs_write_int(bs, spor->subpic_id_info_flag, 1);\n\t\tgf_bs_write_int(bs, spor->num_subpic_ref_idx, 15);\n\t\tfor (i=0; i<spor->num_subpic_ref_idx; i++) {\n\t\t\tgf_bs_write_u16(bs, spor->subp_track_ref_idx[i]);\n\t\t}\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_len_minus1, 4);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_bit_pos, 12);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.start_code_emul_flag, 1);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.pps_sps_subpic_id_flag, 1);\n\t\t\tif (spor->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 6);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 4);\n\t\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tgf_bs_write_u32(bs, sulm->groupID_info_4cc);\n\t\tgf_bs_write_u16(bs, sulm->nb_entries - 1);\n\t\tfor (i=0; i<sulm->nb_entries; i++) {\n\t\t\tgf_bs_write_u16(bs, sulm->groupIDs[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->length)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->data, ptr->length);\n\t}\n\t}\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 sgpd_size_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\treturn 1;\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\treturn 20;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\treturn 0;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0] ? GF_TRUE : GF_FALSE;\n\t\tif (use_mkey) {\n\t\t\treturn 3 + seig->key_info_size-1;\n\t\t}\n\t\treturn seig->key_info_size; //== 3 + (seig->key_info_size-3);\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\treturn gf_isom_oinf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn gf_isom_linf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tu32 s = 2 + 2*spor->num_subpic_ref_idx;\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\ts += 3;\n\t\t}\n\t\treturn s;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\treturn 6 + 2*sulm->nb_entries;\n\t}\n\n\tdefault:\n\t\treturn ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;\n\t}\n}\n#endif\n\nGF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\t/*version 0 is deprecated, use v1 by default*/\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid sgpd_box_del(GF_Box *a)\n{\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)a;\n\twhile (gf_list_count(p->group_descriptions)) {\n\t\tvoid *ptr = gf_list_last(p->group_descriptions);\n\t\tsgpd_del_entry(p->grouping_type, ptr);\n\t\tgf_list_rem_last(p->group_descriptions);\n\t}\n\tgf_list_del(p->group_descriptions);\n\tgf_free(p);\n}\n\nGF_Err sgpd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\tp->grouping_type = gf_bs_read_u32(bs);\n\n\tif (p->version>=1) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t}\n\tif (p->version>=2) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p->grouping_type, bs, (s32) p->size, size, &parsed_bytes);\n\t\t//don't return an error, just stop parsing so that we skip over the sgpd box\n\t\tif (!ptr) return GF_OK;\n\t\tgf_list_add(p->group_descriptions, ptr);\n\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sgpd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, nb_descs;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tGF_Err e;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version>=1) gf_bs_write_u32(bs, p->default_length);\n\tif (p->version>=2) gf_bs_write_u32(bs, p->default_description_index);\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tgf_bs_write_u32(bs, nb_descs);\n\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tif ((p->version >= 1) && !p->default_length) {\n\t\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\t\tgf_bs_write_u32(bs, size);\n\t\t}\n\t\tsgpd_write_entry(p->grouping_type, ptr, bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sgpd_box_size(GF_Box *s)\n{\n\tu32 i, nb_descs;\n\tBool use_def_size = GF_TRUE;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->size += 8;\n\n\t//we force all sample groups to version 1, v0 being deprecated\n\tif (!p->version)\n\t\tp->version = 1;\n\tp->size += 4;\n\n\tif (p->version>=2)\n\t\tp->size += 4;\n\tp->default_length = 0;\n\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (use_def_size && !p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tuse_def_size = GF_FALSE;\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += nb_descs * 4;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid saiz_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info_size) gf_free(ptr->sample_info_size);\n\tgf_free(ptr);\n}\n\n\nGF_Err saiz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->default_sample_info_size = gf_bs_read_u8(bs);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\tif (ptr->default_sample_info_size == 0) {\n\t\tif (ptr->size < ptr->sample_count)\n\t\t    return GF_ISOM_INVALID_FILE;\n\n\t\tptr->sample_info_size = gf_malloc(sizeof(u8)*ptr->sample_count);\n\t\tptr->sample_alloc = ptr->sample_count;\n\t\tif (!ptr->sample_info_size)\n\t\t    return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count);\n\t\tgf_bs_read_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saiz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoSizeBox, GF_ISOM_BOX_TYPE_SAIZ);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saiz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\tgf_bs_write_u8(bs, ptr->default_sample_info_size);\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\tif (!ptr->default_sample_info_size) {\n\t\tif (!ptr->sample_info_size)\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\telse\n\t\t\tgf_bs_write_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saiz_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nvoid saio_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tif (ptr->cached_data) gf_free(ptr->cached_data);\n\tgf_free(ptr);\n}\n\n\nGF_Err saio_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->size / (ptr->version == 0 ? 4 : 8) < ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(u64))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->offsets = gf_malloc(sizeof(u64)*ptr->entry_count);\n\t\tif (!ptr->offsets)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tptr->entry_alloc = ptr->entry_count;\n\t\tif (ptr->version==0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u32(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saio_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoOffsetBox, GF_ISOM_BOX_TYPE_SAIO);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saio_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\t//store position in bitstream before writing data - offsets can be NULL if a single offset is rewritten later on (cf senc_box_write)\n\t\tptr->offset_first_offset_field = gf_bs_get_position(bs);\n\t\tif (ptr->version==0) {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->offsets[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saio_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 4;\n\t//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed\n\tswitch (ptr->aux_info_type) {\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\t\tif (ptr->offsets) gf_free(ptr->offsets);\n\t\tptr->offsets = NULL;\n\t\tptr->entry_alloc = 0;\n\t\tptr->entry_count = 1;\n\t\tbreak;\n\t}\n\n\tptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nvoid prft_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err prft_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tptr->refTrackID = gf_bs_read_u32(bs);\n\tptr->ntp = gf_bs_read_u64(bs);\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->timestamp = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->timestamp = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err prft_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->refTrackID);\n\tgf_bs_write_u64(bs, ptr->ntp);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->timestamp);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->timestamp);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err prft_box_size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *trgr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgr_box_del(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->groups);\n\tgf_free(ptr);\n}\n\n\nGF_Err trgr_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tBOX_FIELD_LIST_ASSIGN(groups)\n\treturn gf_list_add(ptr->groups, a);\n}\n\n\nGF_Err trgr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trgr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trgr_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s;\n\tgf_isom_check_position_list(s, ptr->groups, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *trgt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgt_box_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err trgt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}\n\nGF_Err trgt_box_size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tptr->size+= 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *stvi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_StereoVideoBox, GF_ISOM_BOX_TYPE_STVI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid stvi_box_del(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->stereo_indication_type) gf_free(ptr->stereo_indication_type);\n\tgf_free(ptr);\n}\n\nGF_Err stvi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tif (!ptr->stereo_indication_type) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stvi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 30);\n\tgf_bs_write_int(bs, ptr->single_view_allowed, 2);\n\tgf_bs_write_u32(bs, ptr->stereo_scheme);\n\tgf_bs_write_u32(bs, ptr->sit_len);\n\tgf_bs_write_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\n\treturn GF_OK;\n}\n\nGF_Err stvi_box_size(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tptr->size+= 12 + ptr->sit_len;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fiin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err fiin_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tBOX_FIELD_LIST_ASSIGN(partition_entries)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tBOX_FIELD_ASSIGN(session_info, FDSessionGroupBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tBOX_FIELD_ASSIGN(group_id_to_name, GroupIdToNameBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\ts->size+= 2;\n\tgf_isom_check_position_list(s, ptr->partition_entries, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *paen_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid paen_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err paen_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FPAR:\n\t\tBOX_FIELD_ASSIGN(blocks_and_symbols, FilePartitionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FECR:\n\t\tBOX_FIELD_ASSIGN(FEC_symbol_locations, FECReservoirBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FIRE:\n\t\tBOX_FIELD_ASSIGN(File_symbol_locations, FileReservoirBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err paen_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *fpar_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FilePartitionBox, GF_ISOM_BOX_TYPE_FPAR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fpar_box_del(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_specific_info) gf_free(ptr->scheme_specific_info);\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str)\n{\n\tu32 len=10;\n\tu32 i=0;\n\n\t*out_str = gf_malloc(sizeof(char)*len);\n\tif (! *out_str) return GF_OUT_OF_MEM;\n\n\tif (!s->size) {\n\t\t*out_str[0] = 0;\n\t\treturn GF_OK;\n\t}\n\n\twhile (1) {\n\t\tISOM_DECREASE_SIZE(s, 1 );\n\t\t(*out_str)[i] = gf_bs_read_u8(bs);\n\t\tif (!(*out_str)[i]) break;\n\t\ti++;\n\t\tif (i==len) {\n\t\t\tlen += 10;\n\t\t\t*out_str = gf_realloc(*out_str, sizeof(char)*len);\n\t\t}\n\t\tif (gf_bs_available(bs) == 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] missing null character in null terminated string\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (i >= size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] string bigger than container, probably missing null character\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, ((ptr->version ? 4 : 2) + 12) );\n\tptr->itemID = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tptr->packet_payload_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->FEC_encoding_ID = gf_bs_read_u8(bs);\n\tptr->FEC_instance_ID = gf_bs_read_u16(bs);\n\tptr->max_source_block_length = gf_bs_read_u16(bs);\n\tptr->encoding_symbol_length = gf_bs_read_u16(bs);\n\tptr->max_number_of_encoding_symbols = gf_bs_read_u16(bs);\n\n\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_specific_info);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tif (ptr->nb_entries > ptr->size / 6 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FilePartitionEntry))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * 6 );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FilePartitionEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tptr->entries[i].block_size = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fpar_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->itemID, ptr->version ? 32 : 16);\n\tgf_bs_write_u16(bs, ptr->packet_payload_size);\n\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->FEC_encoding_ID);\n\tgf_bs_write_u16(bs, ptr->FEC_instance_ID);\n\tgf_bs_write_u16(bs, ptr->max_source_block_length);\n\tgf_bs_write_u16(bs, ptr->encoding_symbol_length);\n\tgf_bs_write_u16(bs, ptr->max_number_of_encoding_symbols);\n\tif (ptr->scheme_specific_info) {\n\t\tgf_bs_write_data(bs, ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\t}\n\t//null terminated string\n\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->entries[i].block_count);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].block_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_size(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tptr->size += 13 + (ptr->version ? 8 : 4);\n\tif (ptr->scheme_specific_info)\n\t\tptr->size += strlen(ptr->scheme_specific_info);\n\n\tptr->size+= ptr->nb_entries * 6;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *fecr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FECReservoirBox, GF_ISOM_BOX_TYPE_FECR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fecr_box_del(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err fecr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\n\tif (ptr->nb_entries > ptr->size / (ptr->version ? 8 : 6) || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FECReservoirEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fecr\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\t\tptr->entries[i].symbol_count = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fecr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].item_id, ptr->version ? 32 : 16);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].symbol_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fecr_box_size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *segr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid segr_box_del(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tif (ptr->session_groups[i].group_ids) gf_free(ptr->session_groups[i].group_ids);\n\t\tif (ptr->session_groups[i].channels) gf_free(ptr->session_groups[i].channels);\n\t}\n\tif (ptr->session_groups) gf_free(ptr->session_groups);\n\tgf_free(ptr);\n}\n\nGF_Err segr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->num_session_groups = gf_bs_read_u16(bs);\n\tif (ptr->size < ptr->num_session_groups) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in segr\\n\", ptr->num_session_groups));\n\t\tptr->num_session_groups = 0;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->session_groups, ptr->num_session_groups, SessionGroupEntry);\n\tif (!ptr->session_groups) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->session_groups[i].nb_groups = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_groups*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].group_ids, ptr->session_groups[i].nb_groups, u32);\n\t\tif (!ptr->session_groups[i].group_ids) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tptr->session_groups[i].group_ids[k] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tptr->session_groups[i].nb_channels = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_channels*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].channels, ptr->session_groups[i].nb_channels, u32);\n\t\tif (!ptr->session_groups[i].channels) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tptr->session_groups[i].channels[k] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err segr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tGF_Err e;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->num_session_groups);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tgf_bs_write_u8(bs, ptr->session_groups[i].nb_groups);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].group_ids[k]);\n\t\t}\n\n\t\tgf_bs_write_u16(bs, ptr->session_groups[i].nb_channels);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].channels[k]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err segr_box_size(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->size += 1 + 4*ptr->session_groups[i].nb_groups;\n\t\tptr->size += 2 + 4*ptr->session_groups[i].nb_channels;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *gitn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GroupIdToNameBox, GF_ISOM_BOX_TYPE_GITN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gitn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 4 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, GroupIdNameEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->entries[i].group_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->entries[i].name);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gitn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Box *fdpa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FDpacketBox, GF_ISOM_BOX_TYPE_FDPA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fdpa_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->headers) {\n\t\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\t\tif (ptr->headers[i].data) gf_free(ptr->headers[i].data);\n\t\t}\n\t\tgf_free(ptr->headers);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err fdpa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->info.sender_current_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.expected_residual_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.session_close_bit = gf_bs_read_int(bs, 1);\n\tptr->info.object_close_bit = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->header_ext_count = gf_bs_read_u16(bs);\n\tif (ptr->size / 2 < ptr->header_ext_count) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fdpa\\n\", ptr->header_ext_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->headers, ptr->header_ext_count, GF_LCTheaderExtension);\n\tif (!ptr->headers) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->headers[i].header_extension_type = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\t\tgf_bs_read_data(bs, (char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\t\tptr->headers[i].data_length = gf_bs_read_u8(bs);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tptr->headers[i].data_length = 4*ptr->headers[i].data_length - 2;\n\t\t\t\tif (ptr->size < sizeof(char) * ptr->headers[i].data_length)\n\t\t\t\t    return GF_ISOM_INVALID_FILE;\n\t\t\t\tptr->headers[i].data = gf_malloc(sizeof(char) * ptr->headers[i].data_length);\n\t\t\t\tif (!ptr->headers[i].data) return GF_OUT_OF_MEM;\n\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->headers[i].data_length);\n\t\t\t\tgf_bs_read_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdpa_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tptr->size += 5;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->size += 1;\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tptr->size += 3;\n\t\t} else {\n\t\t\tptr->size += 1 + ptr->headers[i].data_length;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *extr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid extr_box_del(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err extr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (!ptr->feci || ptr->feci->size > ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err extr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->feci) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->feci, bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err extr_box_size(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tptr->size += ptr->data_length;\n\tif (ptr->feci) {\n\t\tGF_Err e = gf_isom_box_size((GF_Box*)ptr->feci);\n\t\tif (e) return e;\n\t\tptr->size += ptr->feci->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fdsa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintSample, GF_ISOM_BOX_TYPE_FDSA);\n\tif (!tmp) return NULL;\n\ttmp->packetTable = gf_list_new();\n\ttmp->hint_subtype = GF_ISOM_BOX_TYPE_FDP_STSD;\n\treturn (GF_Box*)tmp;\n}\n\nvoid fdsa_box_del(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tgf_list_del(ptr->packetTable);\n\tgf_free(ptr);\n}\n\nGF_Err fdsa_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tBOX_FIELD_LIST_ASSIGN(packetTable)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tBOX_FIELD_ASSIGN(extra_data, GF_ExtraDataBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err fdsa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdsa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdsa_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\nvoid trik_box_del(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err trik_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tif ((u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_TrickPlayBoxEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in trik\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trik_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrickPlayBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trik_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i < ptr->entry_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].pic_type, 2);\n\t\tgf_bs_write_int(bs, ptr->entries[i].dependency_level, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trik_box_size(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->size += 8 * ptr->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid bloc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err bloc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->baseLocation, 256);\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->basePurlLocation, 256);\n\tISOM_DECREASE_SIZE(s, 512)\n\tgf_bs_skip_bytes(bs, 512);\n\treturn GF_OK;\n}\n\nGF_Box *bloc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err bloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err bloc_box_size(GF_Box *s)\n{\n\ts->size += 1024;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ainf_box_del(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tif (ptr->APID) gf_free(ptr->APID);\n\tgf_free(s);\n}\n\nGF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}\n\nGF_Box *ainf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AssetInformationBox, GF_ISOM_BOX_TYPE_AINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ainf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->profile_version);\n    if (ptr->APID)\n        gf_bs_write_data(bs, ptr->APID, (u32) strlen(ptr->APID) );\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err ainf_box_size(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n    s->size += 4 + (ptr->APID ? strlen(ptr->APID) : 0 ) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mhac_box_del(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\tif (ptr->mha_config) gf_free(ptr->mha_config);\n\tgf_free(s);\n}\n\nGF_Err mhac_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->configuration_version = gf_bs_read_u8(bs);\n\tptr->mha_pl_indication = gf_bs_read_u8(bs);\n\tptr->reference_channel_layout = gf_bs_read_u8(bs);\n\tptr->mha_config_size = gf_bs_read_u16(bs);\n\tif (ptr->mha_config_size) {\n\t\tISOM_DECREASE_SIZE(s, ptr->mha_config_size)\n\n\t\tptr->mha_config = gf_malloc(sizeof(char)*ptr->mha_config_size);\n\t\tif (!ptr->mha_config) return GF_OUT_OF_MEM;\n\n\t\tgf_bs_read_data(bs, ptr->mha_config, ptr->mha_config_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhac_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHAConfigBox, GF_ISOM_BOX_TYPE_MHAC);\n\ttmp->configuration_version = 1;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhac_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->configuration_version);\n\tgf_bs_write_u8(bs, ptr->mha_pl_indication);\n\tgf_bs_write_u8(bs, ptr->reference_channel_layout);\n\tgf_bs_write_u16(bs, ptr->mha_config ? ptr->mha_config_size : 0);\n\tif (ptr->mha_config && ptr->mha_config_size)\n\t\tgf_bs_write_data(bs, ptr->mha_config, ptr->mha_config_size);\n\n\treturn GF_OK;\n}\n\nGF_Err mhac_box_size(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\ts->size += 5;\n\tif (ptr->mha_config_size && ptr->mha_config) s->size += ptr->mha_config_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mhap_box_del(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\tif (ptr->compat_profiles) gf_free(ptr->compat_profiles);\n\tgf_free(s);\n}\n\nGF_Err mhap_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->num_profiles = gf_bs_read_u8(bs);\n\tif (!ptr->num_profiles) return GF_OK;\n\n\tISOM_DECREASE_SIZE(s, ptr->num_profiles)\n\tptr->compat_profiles = gf_malloc(sizeof(u8) * ptr->num_profiles);\n\tif (!ptr->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tptr->compat_profiles[i] = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHACompatibleProfilesBox, GF_ISOM_BOX_TYPE_MHAP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->num_profiles);\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tgf_bs_write_u8(bs, ptr->compat_profiles[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mhap_box_size(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\ts->size += 1 + ptr->num_profiles;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid jp2h_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err jp2h_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_J2KHeaderBox *ptr = (GF_J2KHeaderBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_IHDR:\n\t\tBOX_FIELD_ASSIGN(ihdr, GF_J2KImageHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\t\tBOX_FIELD_ASSIGN(colr, GF_ColourInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\nGF_Box *jp2h_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KHeaderBox, GF_ISOM_BOX_TYPE_JP2H);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err jp2h_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err jp2h_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid ihdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err ihdr_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 14)\n\n\tptr->height = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->nb_comp = gf_bs_read_u16(bs);\n\tptr->bpc = gf_bs_read_u8(bs);\n\tptr->Comp = gf_bs_read_u8(bs);\n\tptr->UnkC = gf_bs_read_u8(bs);\n\tptr->IPR = gf_bs_read_u8(bs);\n\n\treturn GF_OK;\n}\n\nGF_Box *ihdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KImageHeaderBox, GF_ISOM_BOX_TYPE_IHDR);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ihdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->height);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u16(bs, ptr->nb_comp);\n\tgf_bs_write_u8(bs, ptr->bpc);\n\tgf_bs_write_u8(bs, ptr->Comp);\n\tgf_bs_write_u8(bs, ptr->UnkC);\n\tgf_bs_write_u8(bs, ptr->IPR);\n\treturn GF_OK;\n}\n\nGF_Err ihdr_box_size(GF_Box *s)\n{\n\ts->size += 14;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* Dolby Vision */\n\nGF_Box *dvcC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVCC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvcC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvcC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tISOM_DECREASE_SIZE(ptr, 24)\n\tptr->DOVIConfig.dv_version_major = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_version_minor = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_profile = gf_bs_read_int(bs, 7);\n\tptr->DOVIConfig.dv_level = gf_bs_read_int(bs, 6);\n\tptr->DOVIConfig.rpu_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.el_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.bl_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.dv_bl_signal_compatibility_id = gf_bs_read_int(bs, 4);\n\tif (gf_bs_read_int(bs, 28) != 0)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (gf_bs_read_u32(bs) != 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\t\t}\n\t}\n\tif (ptr->DOVIConfig.dv_profile==8) {\n\t\tif (!ptr->DOVIConfig.dv_bl_signal_compatibility_id || (ptr->DOVIConfig.dv_bl_signal_compatibility_id>2) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC profile 8 but compatibility ID %d is not 1 or 2, patching to 2\\n\", ptr->DOVIConfig.dv_bl_signal_compatibility_id));\n\t\t\tptr->DOVIConfig.dv_bl_signal_compatibility_id = 2;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvcC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_major);\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_minor);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_profile, 7);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_level, 6);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.rpu_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.el_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.bl_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_bl_signal_compatibility_id, 4);\n\tgf_bs_write_int(bs, 0, 28);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\n\treturn GF_OK;\n}\n\nGF_Err dvcC_box_size(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\tptr->size += 24;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dvvC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVVC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvvC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvvC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvvC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_write(s, bs);\n}\n\nGF_Err dvvC_box_size(GF_Box *s)\n{\n\treturn dvcC_box_size(s);\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dOps_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OpusSpecificBox, GF_ISOM_BOX_TYPE_DOPS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dOps_box_del(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (ptr) gf_free(ptr);\n}\n\nGF_Err dOps_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->OutputChannelCount = gf_bs_read_u8(bs);\n\tptr->PreSkip = gf_bs_read_u16(bs);\n\tptr->InputSampleRate = gf_bs_read_u32(bs);\n\tptr->OutputGain = gf_bs_read_u16(bs);\n\tptr->ChannelMappingFamily = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 11)\n\tif (ptr->size) {\n\t\tISOM_DECREASE_SIZE(ptr, 2+ptr->OutputChannelCount);\n\t\tptr->StreamCount = gf_bs_read_u8(bs);\n\t\tptr->CoupledCount = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->ChannelMapping, ptr->OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u8(bs, ptr->OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->PreSkip);\n\tgf_bs_write_u32(bs, ptr->InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->OutputGain);\n\tgf_bs_write_u8(bs, ptr->ChannelMappingFamily);\n\tif (ptr->ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->ChannelMapping, ptr->OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dOps_box_size(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->size += 11;\n\tif (ptr->ChannelMappingFamily)\n\t\tptr->size += 2 + ptr->OutputChannelCount;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dfla_box_del(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *dfla_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FLACConfigBox, GF_ISOM_BOX_TYPE_DFLA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dfla_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Err dfla_box_size(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mvcg_box_del(GF_Box *s)\n{\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err mvcg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tISOM_DECREASE_SIZE(s, 7)\n\tptr->multiview_group_id = gf_bs_read_u32(bs);\n\tptr->num_entries = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->entries = gf_malloc(ptr->num_entries * sizeof(MVCIEntry));\n\tmemset(ptr->entries, 0, ptr->num_entries * sizeof(MVCIEntry));\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->entries[i].entry_type = gf_bs_read_u8(bs);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tISOM_DECREASE_SIZE(s, 6)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tptr->entries[i].tierID = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tptr->entries[i].output_view_id = gf_bs_read_int(bs, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tgf_bs_read_int(bs, 6)\t;\n\t\t\tptr->entries[i].start_view_id = gf_bs_read_int(bs, 10);\n\t\t\tptr->entries[i].view_count = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvcg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MultiviewGroupBox, GF_ISOM_BOX_TYPE_MVCG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvcg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\n\tgf_bs_write_u32(bs, ptr->multiview_group_id);\n\tgf_bs_write_u16(bs, ptr->num_entries);\n\tgf_bs_write_u8(bs, 0);\n\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tgf_bs_write_u8(bs, ptr->entries[i].entry_type);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].tierID);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgf_bs_write_int(bs, 0, 6);\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].output_view_id, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgf_bs_write_int(bs, 0, 6)\t;\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].start_view_id, 10);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].view_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vwid_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tif (ptr->views) {\n\t\tfor (i=0; i<ptr->num_views; i++) {\n\t\t\tif (ptr->views[i].view_refs)\n\t\t\t\tgf_free(ptr->views[i].view_refs);\n\t\t}\n\t\tgf_free(ptr->views);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (ptr->num_views > ptr->size / 6)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tmemset(ptr->views, 0, sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\n\t\tif (ptr->views[i].num_ref_views > ptr->size / 2)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vwid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tgf_bs_write_int(bs, ptr->min_temporal_id, 3);\n\tgf_bs_write_int(bs, ptr->max_temporal_id, 3);\n\tgf_bs_write_u16(bs, ptr->num_views);\n\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_id, 10);\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_order_index, 10);\n\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].base_view_type, 2);\n\t\tgf_bs_write_int(bs, ptr->views[i].num_ref_views, 10);\n\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].dep_comp_idc, 2);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].ref_view_id, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err vwid_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tptr->size += 3;\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tptr->size += 6 + 2 * ptr->views[i].num_ref_views;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid pcmC_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err pcmC_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 2)\n\tptr->format_flags = gf_bs_read_u8(bs);\n\tptr->PCM_sample_size = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\nGF_Box *pcmC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PCMConfigBox, GF_ISOM_BOX_TYPE_PCMC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}\n\nGF_Err pcmC_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid chnl_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *chnl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChannelLayoutBox, GF_ISOM_BOX_TYPE_CHNL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}\n\nvoid emsg_box_del(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_id_uri) gf_free(ptr->scheme_id_uri);\n\tif (ptr->value) gf_free(ptr->value);\n\tif (ptr->message_data) gf_free(ptr->message_data);\n\tgf_free(ptr);\n}\n\nGF_Err emsg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version==0) {\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u32(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\t} else if (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u64(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tif (ptr->size) {\n\t\tif (ptr->size>0xFFFFFFFUL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] emsg message data size too big (\"LLU\") to be loaded\\n\", ptr->size));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tptr->message_data_size = (u32) ptr->size;\n\t\tptr->message_data = gf_malloc(ptr->message_data_size);\n\t\tif (!ptr->message_data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->message_data, ptr->message_data_size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err emsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u64(bs, ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\n\tlen = ptr->scheme_id_uri ? (u32) strlen(ptr->scheme_id_uri) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->scheme_id_uri, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tlen = ptr->value ? (u32) strlen(ptr->value) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->value, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\tif (ptr->message_data)\n\t\tgf_bs_write_data(bs, ptr->message_data, ptr->message_data_size);\n\treturn GF_OK;\n}\n\nGF_Err emsg_box_size(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tptr->size += 4;\n\tif (ptr->version) {\n\t\tptr->size += 20;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size+=2; //1 NULL-terminated strings\n\tif (ptr->scheme_id_uri) ptr->size += strlen(ptr->scheme_id_uri);\n\tif (ptr->value) ptr->size += strlen(ptr->value);\n\tif (ptr->message_data)\n\t\tptr->size += ptr->message_data_size;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n\n\nGF_Box *csgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompactSampleGroupBox, GF_ISOM_BOX_TYPE_CSGP);\n\treturn (GF_Box *)tmp;\n}\nvoid csgp_box_del(GF_Box *a)\n{\n\tGF_CompactSampleGroupBox *p = (GF_CompactSampleGroupBox *)a;\n\tif (p->patterns) {\n\t\tu32 i;\n\t\tfor (i=0; i<p->pattern_count; i++) {\n\t\t\tgf_free(p->patterns[i].sample_group_description_indices);\n\t\t}\n\t\tgf_free(p->patterns);\n\t}\n\tgf_free(p);\n}\n\nu32 get_size_by_code(u32 code)\n{\n\tif (code==0) return 4;\n\tif (code==1) return 8;\n\tif (code==2) return 16;\n\treturn 32;\n}\nGF_Err csgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, bits, gidx_mask;\n\tBool index_msb_indicates_fragment_local_description, grouping_type_parameter_present;\n\tu32 pattern_size, scount_size, index_size;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tindex_msb_indicates_fragment_local_description = (ptr->flags & (1<<7)) ? GF_TRUE : GF_FALSE;\n\tgrouping_type_parameter_present = (ptr->flags & (1<<6)) ? GF_TRUE : GF_FALSE;\n\n\tpattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tscount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tindex_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tif (((pattern_size==4) && (scount_size!=4)) || ((pattern_size!=4) && (scount_size==4))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample gorup pattern_size and sample_count_size mare not both 4 bits\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tif (grouping_type_parameter_present) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->pattern_count = gf_bs_read_u32(bs);\n\n\n\tif ( (ptr->size / ( (pattern_size + scount_size) / 8 ) < ptr->pattern_count) || (u64)ptr->pattern_count > (u64)SIZE_MAX/sizeof(GF_CompactSampleGroupPattern) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample gorup pattern_count value (%lu) invalid\\n\", ptr->pattern_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->patterns = gf_malloc(sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\tif (!ptr->patterns) return GF_OUT_OF_MEM;\n\n\tbits = 0;\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tptr->patterns[i].length = gf_bs_read_int(bs, pattern_size);\n\t\tptr->patterns[i].sample_count = gf_bs_read_int(bs, scount_size);\n\t\tbits += pattern_size + scount_size;\n\t\tif (! (bits % 8)) {\n\t\t\tbits/=8;\n\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\tbits=0;\n\t\t}\n\t\tif ( (u64)ptr->patterns[i].length > (u64)SIZE_MAX/sizeof(u32) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample gorup pattern #%d value (%lu) invalid\\n\", i, ptr->patterns[i].length));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->patterns[i].sample_group_description_indices = gf_malloc(sizeof(u32) * ptr->patterns[i].length);\n\t\tif (!ptr->patterns[i].sample_group_description_indices) return GF_OUT_OF_MEM;\n\t}\n\tbits = 0;\n\tgidx_mask = ((u32)1) << (index_size-1);\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = gf_bs_read_int(bs, index_size);\n\t\t\tif (index_msb_indicates_fragment_local_description) {\n\t\t\t\t//MSB set, this is a index of a group described in the fragment\n\t\t\t\tif (idx & gidx_mask) {\n\t\t\t\t\tidx += 0x10000;\n\t\t\t\t\tidx &= ~gidx_mask;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->patterns[i].sample_group_description_indices[j] = idx;\n\t\t\tbits += index_size;\n\n\t\t\tif (! (bits % 8)) {\n\t\t\t\tbits/=8;\n\t\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\t\tbits=0;\n\t\t\t}\n\t\t}\n\t}\n\tif (bits)\n\t\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err csgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_int(bs, ptr->flags, 24);\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\n\tif (ptr->flags & (1<<6))\n\t\tgf_bs_write_u32(bs, ptr->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, ptr->pattern_count);\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->patterns[i].length, pattern_size);\n\t\tgf_bs_write_int(bs, ptr->patterns[i].sample_count, scount_size);\n\t}\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = ptr->patterns[i].sample_group_description_indices[j];\n\t\t\tif (idx > 0x10000) {\n\t\t\t\tidx -= 0x10000;\n\t\t\t\tgf_bs_write_int(bs, 1, 1);\n\t\t\t\tgf_bs_write_int(bs, idx, index_size-1);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, idx, index_size);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\nGF_Err csgp_box_size(GF_Box *s)\n{\n\tu32 i, bits;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tptr->size += 12; //v, flags , grouping_type, pattern_length\n\tif (ptr->flags & (1<<6))\n\t\tptr->size+=4;\n\n\tptr->size += ptr->pattern_count * (pattern_size + scount_size) / 8;\n\tbits=0;\n\tfor (i=0; i<ptr->pattern_count; i++)\n\t\tbits += ptr->patterns[i].length * index_size;\n\tptr->size += bits/8;\n\tif (bits % 8) ptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dmlp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrueHDConfigBox, GF_ISOM_BOX_TYPE_DMLP);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dmlp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dmlp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 10)\n\tptr->format_info = gf_bs_read_u32(bs);\n\tptr->peak_data_rate = gf_bs_read_int(bs, 15);\n\tgf_bs_read_int(bs, 1);\n\tgf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dmlp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->format_info);\n\tgf_bs_write_int(bs, ptr->peak_data_rate, 15);\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err dmlp_box_size(GF_Box *s)\n{\n\ts->size += 10;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *xtra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_XtraBox, GF_ISOM_BOX_TYPE_XTRA);\n\ttmp->tags = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid xtra_box_del(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (gf_list_count(ptr->tags)) {\n\t\tGF_XtraTag *tag = gf_list_pop_back(ptr->tags);\n\t\tif (tag->name) gf_free(tag->name);\n\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\tgf_free(tag);\n\t}\n\tgf_list_del(ptr->tags);\n\tgf_free(s);\n}\n\nGF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err xtra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tu32 tag_size = 16;\n\t\tu32 name_len = tag->name ? (u32) strlen(tag->name) : 0;\n\t\ttag_size += name_len;\n\t\tif (tag->prop_value) {\n\t\t\ttag_size += 2 + tag->prop_size;\n\t\t}\n\t\tgf_bs_write_u32(bs, tag_size);\n\t\tgf_bs_write_u32(bs, name_len);\n\t\tgf_bs_write_data(bs, tag->name, name_len);\n\t\tgf_bs_write_u32(bs, tag->flags);\n\t\tgf_bs_write_u32(bs, 6 + tag->prop_size);\n\t\tgf_bs_write_u16(bs, tag->prop_type);\n\t\tgf_bs_write_data(bs, tag->prop_value, tag->prop_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err xtra_box_size(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tptr->size += 18 + (u32) strlen(tag->name) + tag->prop_size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *st3d_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Stereo3DBox, GF_ISOM_BOX_TYPE_ST3D);\n\treturn (GF_Box *)tmp;\n}\n\nvoid st3d_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err st3d_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->stereo_type = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err st3d_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->stereo_type);\n\treturn GF_OK;\n}\n\nGF_Err st3d_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *svhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SphericalVideoInfoBox, GF_ISOM_BOX_TYPE_SVHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid svhd_box_del(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string) gf_free(ptr->string);\n\tgf_free(s);\n}\n\n\nGF_Err svhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->string = gf_malloc(sizeof(char) * ((u32) ptr->size+1));\n\tif (!ptr->string) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->string, (u32) ptr->size);\n\tptr->string[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err svhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->string)\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *prhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionHeaderBox, GF_ISOM_BOX_TYPE_PRHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid prhd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err prhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12)\n\tptr->yaw = (s32) gf_bs_read_u32(bs);\n\tptr->pitch = (s32) gf_bs_read_u32(bs);\n\tptr->roll = (s32) gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err prhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->yaw);\n\tgf_bs_write_u32(bs, ptr->pitch);\n\tgf_bs_write_u32(bs, ptr->roll);\n\treturn GF_OK;\n}\n\nGF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *proj_type_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionTypeBox, GF_ISOM_BOX_TYPE_EQUI); //will be overwritten\n\treturn (GF_Box *)tmp;\n}\n\nvoid proj_type_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err proj_type_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tgf_bs_write_u32(bs, ptr->layout);\n\t\tgf_bs_write_u32(bs, ptr->padding);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tgf_bs_write_u32(bs, ptr->bounds_top);\n\t\tgf_bs_write_u32(bs, ptr->bounds_bottom);\n\t\tgf_bs_write_u32(bs, ptr->bounds_left);\n\t\tgf_bs_write_u32(bs, ptr->bounds_right);\n\t} else {\n\t\tgf_bs_write_u32(bs, ptr->crc);\n\t\tgf_bs_write_u32(bs, ptr->encoding_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid co64_box_del(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr;\n\tptr = (GF_ChunkLargeOffsetBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\nGF_Err co64_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\n\tif ((u64)ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in co64\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->offsets = (u64 *) gf_malloc(ptr->nb_entries * sizeof(u64) );\n\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\tptr->alloc_size = ptr->nb_entries;\n\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\tptr->offsets[entries] = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *co64_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkLargeOffsetBox, GF_ISOM_BOX_TYPE_CO64);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err co64_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err co64_box_size(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cprt_box_del(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->notice)\n\t\tgf_free(ptr->notice);\n\tgf_free(ptr);\n}\n\n\nGF_Box *chpl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChapterListBox, GF_ISOM_BOX_TYPE_CHPL);\n\ttmp->list = gf_list_new();\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid chpl_box_del(GF_Box *s)\n{\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\tif (ptr == NULL) return;\n\twhile (gf_list_count(ptr->list)) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, 0);\n\t}\n\tgf_list_del(ptr->list);\n\tgf_free(ptr);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err chpl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 9)\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (ptr->size<len) return GF_ISOM_INVALID_FILE;\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ce->name) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chpl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tcount = gf_list_count(ptr->list);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 len;\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tgf_bs_write_u64(bs, ce->start_time);\n\t\tif (ce->name) {\n\t\t\tlen = (u32) strlen(ce->name);\n\t\t\tif (len>255) len = 255;\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ce->name, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chpl_box_size(GF_Box *s)\n{\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tptr->size += 5;\n\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tptr->size += 9; /*64bit time stamp + 8bit str len*/\n\t\tif (ce->name) ptr->size += strlen(ce->name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Err cprt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguageCode[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[2] = gf_bs_read_int(bs, 5);\n\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguageCode[0] || ptr->packedLanguageCode[1] || ptr->packedLanguageCode[2]) {\n\t\tptr->packedLanguageCode[0] += 0x60;\n\t\tptr->packedLanguageCode[1] += 0x60;\n\t\tptr->packedLanguageCode[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguageCode[0] = 'u';\n\t\tptr->packedLanguageCode[1] = 'n';\n\t\tptr->packedLanguageCode[2] = 'd';\n\t}\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tptr->notice = (char*)gf_malloc((bytesToRead+1) * sizeof(char));\n\t\tif (ptr->notice == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->notice, bytesToRead);\n\t\tptr->notice[bytesToRead] = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *cprt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CopyrightBox, GF_ISOM_BOX_TYPE_CPRT);\n\ttmp->packedLanguageCode[0] = 'u';\n\ttmp->packedLanguageCode[1] = 'n';\n\ttmp->packedLanguageCode[2] = 'd';\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cprt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 1);\n\tif (ptr->packedLanguageCode[0]) {\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[0] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[1] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[2] - 0x60, 5);\n\t} else {\n\t\tgf_bs_write_int(bs, 0, 15);\n\t}\n\tif (ptr->notice) {\n\t\tgf_bs_write_data(bs, ptr->notice, (u32) (strlen(ptr->notice) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err cprt_box_size(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tptr->size += 2;\n\tif (ptr->notice)\n\t\tptr->size += strlen(ptr->notice) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid kind_box_del(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->schemeURI) gf_free(ptr->schemeURI);\n\tif (ptr->value) gf_free(ptr->value);\n\tgf_free(ptr);\n}\n\nGF_Err kind_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tchar *data;\n\t\tu32 schemeURIlen;\n\t\tdata = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, data, bytesToRead);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (data[bytesToRead-1]) {\n\t\t\tdata = (char*)gf_realloc(data, sizeof(char)*(bytesToRead + 1));\n\t\t\tif (!data) return GF_OUT_OF_MEM;\n\t\t\tdata[bytesToRead] = 0;\n\t\t\tbytesToRead++;\n\t\t}\n\t\tptr->schemeURI = gf_strdup(data);\n\t\tif (!ptr->schemeURI) return GF_OUT_OF_MEM;\n\t\tschemeURIlen = (u32) strlen(data);\n\t\tif (bytesToRead > schemeURIlen+1) {\n\t\t\t/* read the value */\n\t\t\tchar *data_value = data + schemeURIlen +1;\n\t\t\tptr->value = gf_strdup(data_value);\n\t\t\tif (!ptr->value) return GF_OUT_OF_MEM;\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *kind_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_KindBox, GF_ISOM_BOX_TYPE_KIND);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err kind_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->schemeURI)\n        gf_bs_write_data(bs, ptr->schemeURI, (u32) (strlen(ptr->schemeURI) + 1 ));\n    else\n        gf_bs_write_u8(bs, 0);\n\n    if (ptr->value) {\n\t\tgf_bs_write_data(bs, ptr->value, (u32) (strlen(ptr->value) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err kind_box_size(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n    ptr->size += (ptr->schemeURI ? strlen(ptr->schemeURI) : 0) + 1;\n\tif (ptr->value) {\n\t\tptr->size += strlen(ptr->value) + 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ctts_box_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\n\t\tif (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) {\n\t\t\tptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset);\n\t\t\tptr->sample_num_max_cts_delta = sampleCount;\n\t\t}\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *ctts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionOffsetBox, GF_ISOM_BOX_TYPE_CTTS);\n\treturn (GF_Box *) tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ctts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tif (ptr->version) {\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].decodingOffset, 32);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->entries[i].decodingOffset);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ctts_box_size(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cslg_box_del(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err cslg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->compositionToDTSShift = gf_bs_read_int(bs, 32);\n\tptr->leastDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->greatestDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->compositionStartTime = gf_bs_read_int(bs, 32);\n\tptr->compositionEndTime = gf_bs_read_int(bs, 32);\n\treturn GF_OK;\n}\n\nGF_Box *cslg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionToDecodeBox, GF_ISOM_BOX_TYPE_CSLG);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cslg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->compositionToDTSShift, 32);\n\tgf_bs_write_int(bs, ptr->leastDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->greatestDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->compositionStartTime, 32);\n\tgf_bs_write_int(bs, ptr->compositionEndTime, 32);\n\treturn GF_OK;\n}\n\nGF_Err cslg_box_size(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->size += 20;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ccst_box_del(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tif (ptr) gf_free(ptr);\n\treturn;\n}\n\nGF_Err ccst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);\n\tptr->intra_pred_used = gf_bs_read_int(bs, 1);\n\tptr->max_ref_per_pic = gf_bs_read_int(bs, 4);\n\tptr->reserved = gf_bs_read_int(bs, 26);\n\treturn GF_OK;\n}\n\nGF_Box *ccst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CodingConstraintsBox, GF_ISOM_BOX_TYPE_CCST);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ccst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->all_ref_pics_intra, 1);\n\tgf_bs_write_int(bs, ptr->intra_pred_used, 1);\n\tgf_bs_write_int(bs, ptr->max_ref_per_pic, 4);\n\tgf_bs_write_int(bs, 0, 26);\n\treturn GF_OK;\n}\n\nGF_Err ccst_box_size(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid url_box_del(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 location_size = (u32) ptr->size;\n\t\tif (location_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->location = (char*)gf_malloc(location_size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, location_size);\n\t\tif (ptr->location[location_size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *url_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURLBox, GF_ISOM_BOX_TYPE_URL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err url_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err url_box_size(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid urn_box_del(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tif (ptr->nameURN) gf_free(ptr->nameURN);\n\tgf_free(ptr);\n}\n\n\nGF_Err urn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\t//OK, this has both URN and URL\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\n\tif (tmpName[to_read - 1] != 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] urn box contains invalid location field\\n\" ));\n\t}\n\telse {\n\t\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\t\tif (!ptr->location) {\n\t\t\tgf_free(tmpName);\n\t\t\tgf_free(ptr->nameURN);\n\t\t\tptr->nameURN = NULL;\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\t}\n\n\tgf_free(tmpName);\n\treturn GF_OK;\n}\n\nGF_Box *urn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURNBox, GF_ISOM_BOX_TYPE_URN);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err urn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\t//to check, the spec says: First name, then location\n\t\tif (ptr->nameURN) {\n\t\t\tgf_bs_write_data(bs, ptr->nameURN, (u32)strlen(ptr->nameURN) + 1);\n\t\t}\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err urn_box_size(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->nameURN) ptr->size += 1 + strlen(ptr->nameURN);\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid unkn_box_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 bytesToRead, sub_size, sub_a;\n\tGF_BitStream *sub_bs;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (!bytesToRead) return GF_OK;\n\tif (bytesToRead>1000000) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unknown box %s (0x%08X) with payload larger than 1 MBytes, ignoring\\n\", gf_4cc_to_str(ptr->type), ptr->type ));\n\t\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\t\treturn GF_OK;\n\t}\n\n\tptr->data = (char*)gf_malloc(bytesToRead);\n\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\tptr->dataSize = bytesToRead;\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\n\t//try to parse container boxes, check if next 8 bytes match a subbox\n\tsub_bs = gf_bs_new(ptr->data, ptr->dataSize, GF_BITSTREAM_READ);\n\tsub_size = gf_bs_read_u32(sub_bs);\n\tsub_a = gf_bs_read_u8(sub_bs);\n\te = (sub_size && (sub_size <= ptr->dataSize)) ? GF_OK : GF_NOT_SUPPORTED;\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\n\tif (e == GF_OK) {\n\t\tgf_bs_seek(sub_bs, 0);\n\t\tgf_bs_set_cookie(sub_bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(s, sub_bs);\n\t}\n\tgf_bs_del(sub_bs);\n\tif (e==GF_OK) {\n\t\tgf_free(ptr->data);\n\t\tptr->data = NULL;\n\t\tptr->dataSize = 0;\n\t} else if (s->child_boxes) {\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *unkn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownBox, GF_ISOM_BOX_TYPE_UNKNOWN);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 type;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\ttype = s->type;\n\tptr->type = ptr->original_4cc;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = type;\n\tif (e) return e;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err unkn_box_size(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_parent_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err def_parent_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_full_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_full_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_full_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_parent_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err def_parent_full_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid uuid_box_del(GF_Box *s)\n{\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err uuid_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead);\n\t\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\t\tptr->dataSize = bytesToRead;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *uuid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownUUIDBox, GF_ISOM_BOX_TYPE_UUID);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err uuid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err uuid_box_size(GF_Box *s)\n{\n\tGF_UnknownUUIDBox*ptr = (GF_UnknownUUIDBox*)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dinf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_DREF:\n\t\tBOX_FIELD_ASSIGN(dref, GF_DataReferenceBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataInformationBox *dinf;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) {\n\t\treturn e;\n\t}\n\tdinf = (GF_DataInformationBox *)s;\n\tif (!dinf->dref) {\n\t\tif (! (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t}\n\t\tdinf->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *dinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataInformationBox, GF_ISOM_BOX_TYPE_DINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err dinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid dref_box_del(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err dref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *dref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataReferenceBox, GF_ISOM_BOX_TYPE_DREF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count;\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = ptr->child_boxes ? gf_list_count(ptr->child_boxes) : 0;\n\tgf_bs_write_u32(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err dref_box_size(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid edts_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err edts_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tBOX_FIELD_ASSIGN(editList, GF_EditListBox)\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err edts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *edts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditBox, GF_ISOM_BOX_TYPE_EDTS);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err edts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\treturn gf_isom_box_write_header(s, bs);\n\t} else {\n\t\ts->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err edts_box_size(GF_Box *s)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (!ptr->editList || ! gf_list_count(ptr->editList->entryList)) {\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid elst_box_del(GF_Box *s)\n{\n\tGF_EditListBox *ptr;\n\tu32 nb_entries;\n\tu32 i;\n\n\tptr = (GF_EditListBox *)s;\n\tif (ptr == NULL) return;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tfor (i = 0; i < nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (p) gf_free(p);\n\t}\n\tgf_list_del(ptr->entryList);\n\tgf_free(ptr);\n}\n\nGF_Err elst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tnb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tGF_EdtsEntry *p;\n\t\tGF_SAFEALLOC(p, GF_EdtsEntry);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tp->mediaRate = gf_bs_read_u32(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditListBox, GF_ISOM_BOX_TYPE_ELST);\n\ttmp->entryList = gf_list_new();\n\tif (!tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor (i = 0; i < nb_entries; i++ ) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (ptr->version == 1) {\n\t\t\tgf_bs_write_u64(bs, p->segmentDuration);\n\t\t\tgf_bs_write_u64(bs, p->mediaTime);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->segmentDuration);\n\t\t\tgf_bs_write_u32(bs, (s32) p->mediaTime);\n\t\t}\n\t\tgf_bs_write_u32(bs, p->mediaRate);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elst_box_size(GF_Box *s)\n{\n\tu32 durtimebytes;\n\tu32 i, nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\t//entry count\n\tptr->size += 4;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->version = 0;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif ((p->segmentDuration>0xFFFFFFFF) || (p->mediaTime>0xFFFFFFFF)) {\n\t\t\tptr->version = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdurtimebytes = (ptr->version == 1 ? 16 : 8) + 4;\n\tptr->size += (nb_entries * durtimebytes);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid esds_box_del(GF_Box *s)\n{\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tif (ptr == NULL)\treturn;\n\tif (ptr->desc) gf_odf_desc_del((GF_Descriptor *)ptr->desc);\n\tgf_free(ptr);\n}\n\n\nGF_Err esds_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e=GF_OK;\n\tu32 descSize;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\tdescSize = (u32) (ptr->size);\n\n\tif (descSize) {\n\t\tchar *enc_desc = (char*)gf_malloc(sizeof(char) * descSize);\n\t\tif (!enc_desc) return GF_OUT_OF_MEM;\n\t\t//get the payload\n\t\tgf_bs_read_data(bs, enc_desc, descSize);\n\t\t//send it to the OD Codec\n\t\te = gf_odf_desc_read(enc_desc, descSize, (GF_Descriptor **) &ptr->desc);\n\t\t//OK, free our desc\n\t\tgf_free(enc_desc);\n\n\t\tif (ptr->desc && (ptr->desc->tag!=GF_ODF_ESD_TAG) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor tag 0x%x in esds\\n\", ptr->desc->tag));\n\t\t\tgf_odf_desc_del((GF_Descriptor*)ptr->desc);\n\t\t\tptr->desc=NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (e) {\n\t\t\tptr->desc = NULL;\n\t\t} else {\n\t\t\t/*fix broken files*/\n\t\t\tif (ptr->desc && !ptr->desc->URLString) {\n\t\t\t\tif (!ptr->desc->slConfig) {\n\t\t\t\t\tptr->desc->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t} else if (ptr->desc->slConfig->predefined != SLPredef_MP4) {\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t\tgf_odf_slc_set_pref(ptr->desc->slConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *esds_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ESDBox, GF_ISOM_BOX_TYPE_ESDS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err esds_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu8 *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\t//free our buffer\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}\n\nGF_Err esds_box_size(GF_Box *s)\n{\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\tdescSize = gf_odf_desc_size((GF_Descriptor *)ptr->desc);\n\tptr->size += descSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid free_box_del(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err free_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\n\tif (ptr->size > 0xFFFFFFFF) return GF_IO_ERR;\n\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, bytesToRead);\n\t\tptr->dataSize = bytesToRead;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *free_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FreeSpaceBox, GF_ISOM_BOX_TYPE_FREE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err free_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->original_4cc) {\n\t\tu32 t = s->type;\n\t\ts->type=ptr->original_4cc;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type=t;\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t}\n\tif (e) return e;\n\tif (ptr->dataSize)\t{\n\t\tif (ptr->data) {\n\t\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t\t} else {\n\t\t\tu32 i = 0;\n\t\t\twhile (i<ptr->dataSize) {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err free_box_size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ftyp_box_del(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\tif (ptr->altBrand) gf_free(ptr->altBrand);\n\tgf_free(ptr);\n}\n\nGF_Box *ftyp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FileTypeBox, GF_ISOM_BOX_TYPE_FTYP);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err ftyp_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->majorBrand = gf_bs_read_u32(bs);\n\tptr->minorVersion = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->altCount = ( (u32) (ptr->size)) / 4;\n\tif (!ptr->altCount) return GF_OK;\n\n\tptr->altBrand = (u32*)gf_malloc(sizeof(u32)*ptr->altCount);\n\tif (!ptr->altBrand) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i<ptr->altCount; i++) {\n\t\tptr->altBrand[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ftyp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ftyp_box_size(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tptr->size += 8 + ptr->altCount * 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnrm_box_del(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericSampleEntryBox, GF_ISOM_BOX_TYPE_GNRM);\n\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n//dummy\nGF_Err gnrm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_box_size(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRM;\n\tptr->size += 8+ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gnrv_box_del(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrv_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRV);\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRV;\n\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)ptr, bs);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_box_size(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnra_box_del(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericAudioSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err gnra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRA;\n\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox *)ptr, bs);\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gnra_box_size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hdlr_box_del(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nameUTF8) gf_free(ptr->nameUTF8);\n\tgf_free(ptr);\n}\n\n\nGF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 cookie;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->reserved1 = gf_bs_read_u32(bs);\n\tptr->handlerType = gf_bs_read_u32(bs);\n\tgf_bs_read_data(bs, (char*)ptr->reserved2, 12);\n\n\tcookie = gf_bs_get_cookie(bs);\n\tif (ptr->handlerType==GF_ISOM_MEDIA_VISUAL)\n\t\tcookie |= GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\telse\n\t\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (ptr->size) {\n\t\tu32 name_size = (u32) ptr->size;\n\t\tif (name_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in hdlr\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->nameUTF8 = (char*)gf_malloc(name_size);\n\t\tif (!ptr->nameUTF8) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->nameUTF8, name_size);\n\n\t\t//patch for old QT files - we cannot rely on checking if str[0]==len(str+1) since we may have\n\t\t//cases where the first character of the string decimal value is indeed the same as the string length!!\n\t\t//we had this issue with encryption_import test\n\t\t//we therefore only check if last char is null, and if not so assume old QT style\n\t\tif (ptr->nameUTF8[name_size-1]) {\n\t\t\tif (name_size > 1)\n\t\t\t\tmemmove(ptr->nameUTF8, ptr->nameUTF8+1, sizeof(char) * (u32) (name_size-1) );\n\t\t\tptr->nameUTF8[name_size-1] = 0;\n\t\t\tptr->store_counted_string = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *hdlr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->reserved1);\n\tgf_bs_write_u32(bs, ptr->handlerType);\n\tgf_bs_write_data(bs, (char*)ptr->reserved2, 12);\n\n\tif (ptr->nameUTF8) {\n\t\tu32 len = (u32)strlen(ptr->nameUTF8);\n\t\tif (ptr->store_counted_string) {\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hdlr_box_size(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tptr->size += 20 + 1; //null term or counted string\n\tif (ptr->nameUTF8) {\n\t\tptr->size += strlen(ptr->nameUTF8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid hinf_box_del(GF_Box *s)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tgf_free(hinf);\n}\n\nGF_Box *hinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintInfoBox, GF_ISOM_BOX_TYPE_HINF);\n\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err hinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MAXR:\n\t\tif (!is_rem) {\n\t\t\tu32 i=0;\n\t\t\tGF_MAXRBox *maxR;\n\t\t\twhile ((maxR = (GF_MAXRBox *)gf_list_enum(hinf->child_boxes, &i))) {\n\t\t\t\tif ((maxR->type==GF_ISOM_BOX_TYPE_MAXR) && (maxR->granularity == ((GF_MAXRBox *)a)->granularity))\n\t\t\t\t\tERROR_ON_DUPLICATED_BOX(a, s)\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_HintInfoBox *ptr = (GF_HintInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err hinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hmhd_box_del(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err hmhd_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tptr->maxPDUSize = gf_bs_read_u16(bs);\n\tptr->avgPDUSize = gf_bs_read_u16(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\tptr->slidingAverageBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *hmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintMediaHeaderBox, GF_ISOM_BOX_TYPE_HMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->maxPDUSize);\n\tgf_bs_write_u16(bs, ptr->avgPDUSize);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\tgf_bs_write_u32(bs, ptr->slidingAverageBitrate);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_box_size(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tptr->size += 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintTrackInfoBox, GF_ISOM_BOX_TYPE_HNTI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid hnti_box_del(GF_Box *a)\n{\n\tgf_free(a);\n}\n\nGF_Err hnti_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintTrackInfoBox *ptr = (GF_HintTrackInfoBox *)s;\n\tif (!ptr || !a) return GF_BAD_PARAM;\n\n\tswitch (a->type) {\n\t//this is the value for GF_RTPBox - same as HintSampleEntry for RTP !!!\n\tcase GF_ISOM_BOX_TYPE_RTP:\n\tcase GF_ISOM_BOX_TYPE_SDP:\n\t\tBOX_FIELD_ASSIGN(SDP, GF_Box)\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\n\nGF_Err hnti_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tGF_SDPBox\n**********************************************************/\n\nvoid sdp_box_del(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err sdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in sdp box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *sdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SDPBox, GF_ISOM_BOX_TYPE_SDP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//don't write the NULL char!!!\n\tif (ptr->sdpText)\n\t\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\nGF_Err sdp_box_size(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\t//don't count the NULL char!!!\n\tif (ptr->sdpText)\n\t\tptr->size += strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid rtp_hnti_box_del(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err rtp_hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subType = gf_bs_read_u32(bs);\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in rtp_hnti box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\n\nGF_Box *rtp_hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtp_hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subType);\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_box_size(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tptr->size += 4 + strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTRPY GF_Box\n**********************************************************/\n\nvoid trpy_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err trpy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *trpy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TRPYBox, GF_ISOM_BOX_TYPE_TRPY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trpy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err trpy_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTOTL GF_Box\n**********************************************************/\n\nvoid totl_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err totl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *totl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TOTLBox, GF_ISOM_BOX_TYPE_TOTL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err totl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err totl_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNUMP GF_Box\n**********************************************************/\n\nvoid nump_box_del(GF_Box *s)\n{\n\tgf_free((GF_NUMPBox *)s);\n}\nGF_Err nump_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbPackets = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *nump_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err nump_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err nump_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNPCK GF_Box\n**********************************************************/\n\nvoid npck_box_del(GF_Box *s)\n{\n\tgf_free((GF_NPCKBox *)s);\n}\nGF_Err npck_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *npck_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err npck_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err npck_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTPYL GF_Box\n**********************************************************/\n\nvoid tpyl_box_del(GF_Box *s)\n{\n\tgf_free((GF_NTYLBox *)s);\n}\nGF_Err tpyl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *tpyl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NTYLBox, GF_ISOM_BOX_TYPE_TPYL);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpyl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpyl_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTPAY GF_Box\n**********************************************************/\n\nvoid tpay_box_del(GF_Box *s)\n{\n\tgf_free((GF_TPAYBox *)s);\n}\nGF_Err tpay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tpay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TPAYBox, GF_ISOM_BOX_TYPE_TPAY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tMAXR GF_Box\n**********************************************************/\n\nvoid maxr_box_del(GF_Box *s)\n{\n\tgf_free((GF_MAXRBox *)s);\n}\nGF_Err maxr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->granularity = gf_bs_read_u32(bs);\n\tptr->maxDataRate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *maxr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MAXRBox, GF_ISOM_BOX_TYPE_MAXR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err maxr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}\nGF_Err maxr_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMED GF_Box\n**********************************************************/\n\nvoid dmed_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMEDBox *)s);\n}\nGF_Err dmed_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dmed_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMEDBox, GF_ISOM_BOX_TYPE_DMED);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmed_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dmed_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDIMM GF_Box\n**********************************************************/\n\nvoid dimm_box_del(GF_Box *s)\n{\n\tgf_free((GF_DIMMBox *)s);\n}\nGF_Err dimm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dimm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMMBox, GF_ISOM_BOX_TYPE_DIMM);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dimm_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDREP GF_Box\n**********************************************************/\n\nvoid drep_box_del(GF_Box *s)\n{\n\tgf_free((GF_DREPBox *)s);\n}\nGF_Err drep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *drep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DREPBox, GF_ISOM_BOX_TYPE_DREP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err drep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err drep_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/**********************************************************\n\t\tTMIN GF_Box\n**********************************************************/\n\nvoid tmin_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMINBox *)s);\n}\nGF_Err tmin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->minTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMINBox, GF_ISOM_BOX_TYPE_TMIN);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->minTime);\n\treturn GF_OK;\n}\nGF_Err tmin_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTMAX GF_Box\n**********************************************************/\n\nvoid tmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMAXBox *)s);\n}\nGF_Err tmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxTime);\n\treturn GF_OK;\n}\nGF_Err tmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPMAX GF_Box\n**********************************************************/\n\nvoid pmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_PMAXBox *)s);\n}\nGF_Err pmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *pmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PMAXBox, GF_ISOM_BOX_TYPE_PMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxSize);\n\treturn GF_OK;\n}\nGF_Err pmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMAX GF_Box\n**********************************************************/\n\nvoid dmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMAXBox *)s);\n}\nGF_Err dmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxDur = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *dmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMAXBox, GF_ISOM_BOX_TYPE_DMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxDur);\n\treturn GF_OK;\n}\nGF_Err dmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid payt_box_del(GF_Box *s)\n{\n\tGF_PAYTBox *payt = (GF_PAYTBox *)s;\n\tif (payt->payloadString) gf_free(payt->payloadString);\n\tgf_free(payt);\n}\nGF_Err payt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5 );\n\tptr->payloadCode = gf_bs_read_u32(bs);\n\tlength = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, length);\n\tptr->payloadString = (char*)gf_malloc(sizeof(char) * (length+1) );\n\tif (! ptr->payloadString) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->payloadString, length);\n\tptr->payloadString[length] = 0;\n\n\treturn GF_OK;\n}\nGF_Box *payt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PAYTBox, GF_ISOM_BOX_TYPE_PAYT);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err payt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->payloadCode);\n    len = ptr->payloadString ? (u32) strlen(ptr->payloadString) : 0;\n\tgf_bs_write_u8(bs, len);\n\tif (len) gf_bs_write_data(bs, ptr->payloadString, len);\n\treturn GF_OK;\n}\nGF_Err payt_box_size(GF_Box *s)\n{\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\ts->size += 4 + 1;\n\tif (ptr->payloadString) ptr->size += strlen(ptr->payloadString);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid name_box_del(GF_Box *s)\n{\n\tGF_NameBox *name = (GF_NameBox *)s;\n\tif (name->string) gf_free(name->string);\n\tgf_free(name);\n}\nGF_Err name_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in name box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->string = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (! ptr->string) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->string, length);\n\tptr->string[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *name_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NameBox, GF_ISOM_BOX_TYPE_NAME);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err name_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->string) {\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string) + 1);\n\t}\n\treturn GF_OK;\n}\nGF_Err name_box_size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tssy_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err tssy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tgf_bs_read_int(bs, 6);\n\tptr->timestamp_sync = gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\nGF_Box *tssy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeStampSynchronyBox, GF_ISOM_BOX_TYPE_TSSY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tssy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->timestamp_sync, 2);\n\treturn GF_OK;\n}\nGF_Err tssy_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid srpp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err srpp_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SchemeInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tBOX_FIELD_ASSIGN(scheme_type, GF_SchemeTypeBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err srpp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 16)\n\tptr->encryption_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->encryption_algorithm_rtcp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtcp = gf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\nGF_Box *srpp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err srpp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtcp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtcp);\n\n\treturn GF_OK;\n}\nGF_Err srpp_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\ts->size += 16;\n\tgf_isom_check_position(s, (GF_Box*)ptr->info, &pos);\n\tgf_isom_check_position(s, (GF_Box*)ptr->scheme_type, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid rssr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err rssr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->ssrc = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *rssr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ReceivedSsrcBox, GF_ISOM_BOX_TYPE_RSSR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rssr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}\nGF_Err rssr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid iods_box_del(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->descriptor) gf_odf_desc_del(ptr->descriptor);\n\tgf_free(ptr);\n}\n\n\nGF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tif (!desc) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\n\tif (e) return e;\n\tswitch (ptr->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor in iods, tag %u found but only %u or %u allowed\\n\", ptr->descriptor->tag, GF_ODF_ISOM_IOD_TAG, GF_ODF_ISOM_OD_TAG ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *iods_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ObjectDescriptorBox, GF_ISOM_BOX_TYPE_IODS);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iods_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tu8 *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//call our OD codec\n\te = gf_odf_desc_write(ptr->descriptor, &desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, desc, descSize);\n\t//and free our stuff maybe!!\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\nGF_Err iods_box_size(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\tptr->size += gf_odf_desc_size(ptr->descriptor);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdat_box_del(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (!s) return;\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdat_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tptr->dataSize = s->size;\n\tptr->bsOffset = gf_bs_get_position(bs);\n\n\t//store idat for rewrite\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IDAT) {\n\t\tptr->data = gf_malloc(sizeof(u8) * (size_t)ptr->dataSize);\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, (u32) ptr->dataSize);\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\t//then skip these bytes\n\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *mdat_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaDataBox, GF_ISOM_BOX_TYPE_MDAT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdat_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//make sure we have some data ...\n\t//if not, we handle that independently (edit files)\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, (u32) ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdat_box_size(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdhd_box_del(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mdhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28)\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Media header timescale is 0 - defaulting to 90000\\n\" ));\n\t\tptr->timeScale = 90000;\n\t}\n\n\tptr->original_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\t//our padding bit\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguage[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[2] = gf_bs_read_int(bs, 5);\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguage[0] || ptr->packedLanguage[1] || ptr->packedLanguage[2]) {\n\t\tptr->packedLanguage[0] += 0x60;\n\t\tptr->packedLanguage[1] += 0x60;\n\t\tptr->packedLanguage[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguage[0] = 'u';\n\t\tptr->packedLanguage[1] = 'n';\n\t\tptr->packedLanguage[2] = 'd';\n\t}\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mdhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);\n\n\ttmp->packedLanguage[0] = 'u';\n\ttmp->packedLanguage[1] = 'n';\n\ttmp->packedLanguage[2] = 'd';\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\t//SPECS: BIT(1) of padding\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_box_size(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += 4;\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mdia_box_del(GF_Box *s)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nalu_parser) gf_bs_del(ptr->nalu_parser);\n\tif (ptr->nalu_out_bs) gf_bs_del(ptr->nalu_out_bs);\n\tif (ptr->nalu_ps_bs) gf_bs_del(ptr->nalu_ps_bs);\n\tif (ptr->extracted_bs) gf_bs_del(ptr->extracted_bs);\n\tif (ptr->extracted_samp) gf_isom_sample_del(&ptr->extracted_samp);\n\tif (ptr->in_sample_buffer) gf_free(ptr->in_sample_buffer);\n\tif (ptr->tmp_nal_copy_buffer) gf_free(ptr->tmp_nal_copy_buffer);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdia_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tBOX_FIELD_ASSIGN(mediaHeader, GF_MediaHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tBOX_FIELD_ASSIGN(handler, GF_HandlerBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tBOX_FIELD_ASSIGN(information, GF_MediaInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs);\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mdia_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_MDIA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdia_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mdia_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box*)ptr->mediaHeader, &pos);\n\t//then handler\n\tgf_isom_check_position(s, (GF_Box*)ptr->handler, &pos);\n\n#if 0\n\t//elng before info for CMAF info - we deactiveate for now, no specific errors raised and CMAF should not impose any order\n\tGF_Box *elng = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\tif (elng)\n\t\tgf_isom_check_position(s, elng, &pos);\n#endif\n\n\t//then info\n\tgf_isom_check_position(s, (GF_Box*)ptr->information, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mfra_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->tfra_list);\n\tgf_free(ptr);\n}\n\nGF_Box *mfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_MFRA);\n\ttmp->tfra_list = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfra_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\tBOX_FIELD_LIST_ASSIGN(tfra_list);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tBOX_FIELD_ASSIGN(mfro, GF_MovieFragmentRandomAccessOffsetBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mfra_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tgf_isom_check_position_list(s, ptr->tfra_list, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfro, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tfra_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Box *tfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_TFRA);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err tfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_RandomAccessEntry *p = 0;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\n\tptr->track_id = gf_bs_read_u32(bs);\n\tif (gf_bs_read_int(bs, 26) != 0)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->traf_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->trun_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->sample_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (ptr->nb_entries > ptr->size / (16+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (ptr->nb_entries > ptr->size / (8+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tif ((u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_RandomAccessEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tp = (GF_RandomAccessEntry *) gf_malloc(sizeof(GF_RandomAccessEntry) * ptr->nb_entries);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t}\n\n\tptr->entries = p;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tmemset(p, 0, sizeof(GF_RandomAccessEntry));\n\n\t\tif (ptr->version == 1) {\n\t\t\tp->time = gf_bs_read_u64(bs);\n\t\t\tp->moof_offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tp->time = gf_bs_read_u32(bs);\n\t\t\tp->moof_offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tp->traf_number = gf_bs_read_int(bs, ptr->traf_bits);\n\t\tp->trun_number = gf_bs_read_int(bs, ptr->trun_bits);\n\t\tp->sample_number = gf_bs_read_int(bs, ptr->sample_bits);\n\n\t\t++p;\n\t}\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, sap_nb_entries;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->track_id);\n\tgf_bs_write_int(bs, 0, 26);\n\n\tgf_bs_write_int(bs, ptr->traf_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->trun_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->sample_bits/8 - 1, 2);\n\n\tsap_nb_entries = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (p->trun_number) sap_nb_entries++;\n\t}\n\n\tgf_bs_write_u32(bs, sap_nb_entries);\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tif (ptr->version==1) {\n\t\t\tgf_bs_write_u64(bs, p->time);\n\t\t\tgf_bs_write_u64(bs, p->moof_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->time);\n\t\t\tgf_bs_write_u32(bs, (u32) p->moof_offset);\n\t\t}\n\t\tgf_bs_write_int(bs, p->traf_number, ptr->traf_bits);\n\t\tgf_bs_write_int(bs, p->trun_number, ptr->trun_bits);\n\t\tgf_bs_write_int(bs, p->sample_number, ptr->sample_bits);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfra_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tptr->size += 12;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tptr->size +=  ((ptr->version==1) ? 16 : 8 ) + ptr->traf_bits/8 + ptr->trun_bits/8 + ptr->sample_bits/8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mfro_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Box *mfro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessOffsetBox, GF_ISOM_BOX_TYPE_MFRO);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->container_size = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->container_size);\n\treturn GF_OK;\n}\n\nGF_Err mfro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid elng_box_del(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->extended_language) gf_free(ptr->extended_language);\n\tgf_free(ptr);\n}\n\nGF_Err elng_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->extended_language = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->extended_language == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->extended_language, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->extended_language[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tif (!str) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(str, ptr->extended_language, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->extended_language);\n\t\t\tptr->extended_language = str;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elng_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_ELNG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elng_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->extended_language) {\n\t\tgf_bs_write_data(bs, ptr->extended_language, (u32)(strlen(ptr->extended_language)+1));\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elng_box_size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mfhd_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sequence_number = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentHeaderBox, GF_ISOM_BOX_TYPE_MFHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid minf_box_del(GF_Box *s)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\t//if we have a Handler not self-contained, delete it (the self-contained belongs to the movie)\n\tif (ptr->dataHandler) {\n\t\tgf_isom_datamap_close(ptr);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err minf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_NMHD:\n\tcase GF_ISOM_BOX_TYPE_STHD:\n\tcase GF_ISOM_BOX_TYPE_VMHD:\n\tcase GF_ISOM_BOX_TYPE_SMHD:\n\tcase GF_ISOM_BOX_TYPE_HMHD:\n\tcase GF_ISOM_BOX_TYPE_GMHD:\n\t\tBOX_FIELD_ASSIGN(InfoHeader, GF_Box)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tBOX_FIELD_ASSIGN(dataInformation, GF_DataInformationBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_STBL:\n\t\tBOX_FIELD_ASSIGN(sampleTable, GF_SampleTableBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err minf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\n\te = gf_isom_box_array_read(s, bs);\n\n\tif (!e && ! ptr->dataInformation) {\n\t\tGF_Box *url;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tptr->dataInformation = (GF_DataInformationBox *) gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!ptr->dataInformation) return GF_OUT_OF_MEM;\n\n\t\tptr->dataInformation->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&ptr->dataInformation->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!ptr->dataInformation->dref) return GF_OUT_OF_MEM;\n\n\t\turl = gf_isom_box_new_parent(&ptr->dataInformation->dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t}\n\treturn e;\n}\n\nGF_Box *minf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaInformationBox, GF_ISOM_BOX_TYPE_MINF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err minf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err minf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->InfoHeader, &pos);\n\t//then dataInfo\n\tgf_isom_check_position(s, (GF_Box *)ptr->dataInformation, &pos);\n\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_MVCI), &pos);\n\t//then sampleTable\n\tgf_isom_check_position(s, (GF_Box *)ptr->sampleTable, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid moof_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tgf_list_del(ptr->TrackList);\n\tif (ptr->PSSHs) gf_list_del(ptr->PSSHs);\n\tif (ptr->mdat) gf_free(ptr->mdat);\n\tgf_free(ptr);\n}\n\nGF_Err moof_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tBOX_FIELD_ASSIGN(mfhd, GF_MovieFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tBOX_FIELD_LIST_ASSIGN(PSSHs)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moof_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentBox, GF_ISOM_BOX_TYPE_MOOF);\n\ttmp->TrackList = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err moof_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moof_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\t//Header First\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfhd, &pos);\n\t//then PSSH\n\tgf_isom_check_position_list(s, ptr->PSSHs, &pos);\n\t//then the track list\n\tgf_isom_check_position_list(s, ptr->TrackList, &pos);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nvoid moov_box_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->trackList);\n\tgf_free(ptr);\n}\n\nGF_Err moov_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tBOX_FIELD_ASSIGN(iods, GF_ObjectDescriptorBox)\n\t\t//if no IOD, delete the box\n\t\tif (ptr->iods && !ptr->iods->descriptor) {\n\t\t\tptr->iods = NULL;\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t}\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tBOX_FIELD_ASSIGN(mvhd, GF_MovieHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tBOX_FIELD_ASSIGN(mvex, GF_MovieExtendsBox)\n\t\tif (ptr->mvex)\n\t\t\tptr->mvex->mov = ptr->mov;\n\t\treturn GF_OK;\n#endif\n\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tif (is_rem) {\n\t\t\tgf_list_del_item(ptr->trackList, a);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t{\n\t\t\tGF_TrackBox *tk = (GF_TrackBox *)a;\n\t\t\t//set our pointer to this obj\n\t\t\ttk->moov = ptr;\n\t\t\ttk->index = gf_list_count(ptr->trackList);\n\t\t\tif (tk->References) {\n\t\t\t\tGF_TrackReferenceTypeBox *dpnd=NULL;\n\t\t\t\tTrack_FindRef(tk, GF_ISOM_REF_BASE, &dpnd);\n\t\t\t\tif (dpnd)\n\t\t\t\t\ttk->nb_base_refs = dpnd->trackIDCount;\n\t\t\t}\n\t\t}\n\t\treturn gf_list_add(ptr->trackList, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err moov_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moov_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err moov_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moov_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *) ptr->mvhd, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->iods, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->meta, &pos);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && !ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\tgf_isom_check_position_list(s, ptr->trackList, &pos);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid audio_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err audio_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *wave = NULL;\n\tBool drop_wave=GF_FALSE;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DOPS:\n\t\tBOX_FIELD_ASSIGN(cfg_opus, GF_OpusSpecificBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DMLP:\n\t\tBOX_FIELD_ASSIGN(cfg_mlp, GF_TrueHDConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MHAC:\n\t\tBOX_FIELD_ASSIGN(cfg_mha, GF_MHAConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DFLA:\n\t\tBOX_FIELD_ASSIGN(cfg_flac, GF_FLACConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\twave = (GF_UnknownBox *)a;\n\t\t/*HACK for QT files: get the esds box from the track*/\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tif (is_rem) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(wave->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(wave->child_boxes, i);\n                    if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) {\n                        ptr->esd = (GF_ESDBox *)inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tptr->compression_id = 0;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n            gf_isom_box_del_parent(&ptr->child_boxes, a);\n            return GF_ISOM_INVALID_MEDIA;\n\n\t\t}\n \t\tptr->qtff_mode &= ~GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n\n \t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n\t\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\t}\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_WAVE:\n\t{\n\t\tu32 subtype = 0;\n\t\tGF_Box **cfg_ptr = NULL;\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->esd;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_ESDS;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_AC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DAC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_EC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DEC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_OPUS) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_opus;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DOPS;\n\t\t}\n\t\telse if ((s->type == GF_ISOM_BOX_TYPE_MHA1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHA2)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM2)\n\t\t) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mha;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_MHAC;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mlp;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DMLP;\n\t\t}\n\n\t\tif (cfg_ptr) {\n\t\t\tif (is_rem) {\n\t\t\t\t*cfg_ptr = NULL;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (*cfg_ptr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif (gf_list_count(a->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(a->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(a->child_boxes, i);\n                    if (inner_box->type == subtype) {\n                        *cfg_ptr = inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->compression_id = 0;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n\t\t}\n\t}\n \t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err audio_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_QT_CONV) {\n \t\tptr->qtff_mode |= GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n \t}\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (!e) {\n\t\tif (s->type==GF_ISOM_BOX_TYPE_ENCA) {\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\t\tif (ptr->cfg_3gpp) ptr->cfg_3gpp->cfg.type = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tif (!data) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *)ptr->esd);\n\t\t\tptr->esd = NULL;\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\n\t\t\tif ((e==GF_OK) && (ptr->esd->type == GF_ISOM_BOX_TYPE_ESDS)) {\n\t\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(ptr->child_boxes, ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n\nGF_Box *audio_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_MP4A);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *enca_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_ENCA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err audio_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox*)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err audio_sample_entry_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox*)s);\n\tif (ptr->qtff_mode)\n\t\treturn GF_OK;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_opus, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_ac3, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_flac, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mlp, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gen_sample_entry_box_del(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(ptr);\n}\n\n\nGF_Err gen_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)s, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(s, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *gen_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEntryBox, GF_QT_SUBTYPE_C608);//type will be overriten\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gen_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err gen_sample_entry_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mp4s_box_del(GF_Box *s)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err mp4s_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mp4s_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mp4s_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n    return GF_OK;\n}\n\nGF_Err mp4s_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n    return GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid video_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\t/*for publishing*/\n\tif (ptr->emul_esd) gf_odf_desc_del((GF_Descriptor *)ptr->emul_esd);\n\tgf_free(ptr);\n}\n\nGF_Err video_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tBOX_FIELD_ASSIGN(rinf, GF_RestrictedSchemeInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\t\tBOX_FIELD_ASSIGN(avc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tBOX_FIELD_ASSIGN(hevc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VVCC:\n\t\tBOX_FIELD_ASSIGN(vvc_config, GF_VVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\t\tBOX_FIELD_ASSIGN(svc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tBOX_FIELD_ASSIGN(mvc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHVC:\n\t\tBOX_FIELD_ASSIGN(lhvc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tBOX_FIELD_ASSIGN(av1_config, GF_AV1ConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VPCC:\n\t\tBOX_FIELD_ASSIGN(vp_config, GF_VPConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DVCC:\n\tcase GF_ISOM_BOX_TYPE_DVVC:\n\t\tBOX_FIELD_ASSIGN(dovi_config, GF_DOVIConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (! memcmp(((GF_UnknownUUIDBox*)a)->uuid, GF_ISOM_IPOD_EXT, 16)) {\n\t\t\tBOX_FIELD_ASSIGN(ipod_ext, GF_UnknownUUIDBox)\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tif (ptr->cfg_3gpp)\n\t\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_JP2H:\n\t\tBOX_FIELD_ASSIGN(jp2h, GF_J2KHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_PASP:\n\tcase GF_ISOM_BOX_TYPE_CLAP:\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\tcase GF_ISOM_BOX_TYPE_MDCV:\n\tcase GF_ISOM_BOX_TYPE_CLLI:\n\tcase GF_ISOM_BOX_TYPE_CCST:\n\tcase GF_ISOM_BOX_TYPE_AUXI:\n\tcase GF_ISOM_BOX_TYPE_RVCC:\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (!is_rem && !gf_isom_box_check_unique(s->child_boxes, a)) {\n\t\t\tERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGVisualSampleEntryBox *mp4v = (GF_MPEGVisualSampleEntryBox*)s;\n\tGF_Err e;\n\te = gf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *)s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\t/*this is an AVC sample desc*/\n\tif (mp4v->avc_config || mp4v->svc_config || mp4v->mvc_config)\n\t\tAVC_RewriteESDescriptor(mp4v);\n\t/*this is an HEVC sample desc*/\n\tif (mp4v->hevc_config || mp4v->lhvc_config || (mp4v->type==GF_ISOM_BOX_TYPE_HVT1))\n\t\tHEVC_RewriteESDescriptor(mp4v);\n\t/*this is an AV1 sample desc*/\n\tif (mp4v->av1_config)\n\t\tAV1_RewriteESDescriptor(mp4v);\n\t/*this is a VP8-9 sample desc*/\n\tif (mp4v->vp_config)\n\t\tVP9_RewriteESDescriptor(mp4v);\n\n\tif (s->type==GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\tif (sinf && sinf->original_format) {\n\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\tswitch (type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tif (mp4v->cfg_3gpp) mp4v->cfg_3gpp->cfg.type = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *video_sample_entry_box_new()\n{\n\tGF_MPEGVisualSampleEntryBox *tmp;\n\tGF_SAFEALLOC(tmp, GF_MPEGVisualSampleEntryBox);\n\tif (tmp == NULL) return NULL;\n\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox *)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err video_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\t\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mvex_box_del(GF_Box *s)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->TrackExList);\n\tgf_list_del(ptr->TrackExPropList);\n\tgf_free(ptr);\n}\n\n\nGF_Err mvex_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TREX:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREP:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExPropList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MEHD:\n\t\tBOX_FIELD_ASSIGN(mehd, GF_MovieExtendsHeaderBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err mvex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsBox, GF_ISOM_BOX_TYPE_MVEX);\n\ttmp->TrackExList = gf_list_new();\n\tif (!tmp->TrackExList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\ttmp->TrackExPropList = gf_list_new();\n\tif (!tmp->TrackExPropList) {\n\t\tgf_list_del(tmp->TrackExList);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mvex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mvex_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *) s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->mehd, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExList, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExPropList, &pos);\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *mehd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsHeaderBox, GF_ISOM_BOX_TYPE_MEHD);\n\treturn (GF_Box *)tmp;\n}\nvoid mehd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err mehd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->fragment_duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->fragment_duration = (u64) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mehd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration);\n\t}\n\treturn GF_OK;\n}\nGF_Err mehd_box_size(GF_Box *s)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tptr->version = (ptr->fragment_duration>0xFFFFFFFF) ? 1 : 0;\n\ts->size += (ptr->version == 1) ? 8 : 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid mvhd_box_del(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err mvhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 80);\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n\nGF_Box *mvhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieHeaderBox, GF_ISOM_BOX_TYPE_MVHD);\n\n\ttmp->preferredRate = (1<<16);\n\ttmp->preferredVolume = (1<<8);\n\n\ttmp->matrixA = (1<<16);\n\ttmp->matrixD = (1<<16);\n\ttmp->matrixW = (1<<30);\n\n\ttmp->nextTrackID = 1;\n\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->preferredRate);\n\tgf_bs_write_u16(bs, ptr->preferredVolume);\n\tgf_bs_write_data(bs, ptr->reserved, 10);\n\tgf_bs_write_u32(bs, ptr->matrixA);\n\tgf_bs_write_u32(bs, ptr->matrixB);\n\tgf_bs_write_u32(bs, ptr->matrixU);\n\tgf_bs_write_u32(bs, ptr->matrixC);\n\tgf_bs_write_u32(bs, ptr->matrixD);\n\tgf_bs_write_u32(bs, ptr->matrixV);\n\tgf_bs_write_u32(bs, ptr->matrixX);\n\tgf_bs_write_u32(bs, ptr->matrixY);\n\tgf_bs_write_u32(bs, ptr->matrixW);\n\tgf_bs_write_u32(bs, ptr->previewTime);\n\tgf_bs_write_u32(bs, ptr->previewDuration);\n\tgf_bs_write_u32(bs, ptr->posterTime);\n\tgf_bs_write_u32(bs, ptr->selectionTime);\n\tgf_bs_write_u32(bs, ptr->selectionDuration);\n\tgf_bs_write_u32(bs, ptr->currentTime);\n\tgf_bs_write_u32(bs, ptr->nextTrackID);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_box_size(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\tptr->size += 80;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid nmhd_box_del(GF_Box *s)\n{\n\tGF_MPEGMediaHeaderBox *ptr = (GF_MPEGMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\n\nGF_Err nmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\nGF_Box *nmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGMediaHeaderBox, GF_ISOM_BOX_TYPE_NMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err nmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err nmhd_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid padb_box_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}\n\n\nGF_Err padb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SampleCount = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->SampleCount/2) //half byte per sample\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->padbits = (u8 *)gf_malloc(sizeof(u8)*ptr->SampleCount);\n\tif (!ptr->padbits) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_read_int(bs, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tptr->padbits[i+1] = gf_bs_read_int(bs, 3);\n\t\t} else {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tgf_bs_read_int(bs, 1);\n\t\tptr->padbits[i] = gf_bs_read_int(bs, 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *padb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PaddingBitsBox, GF_ISOM_BOX_TYPE_PADB);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err padb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->SampleCount, 32);\n\n\tfor (i=0 ; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tgf_bs_write_int(bs, ptr->padbits[i+1], 3);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, ptr->padbits[i], 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err padb_box_size(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\tptr->size += 4;\n\tif (ptr->SampleCount) ptr->size += (ptr->SampleCount + 1) / 2;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rely_box_del(GF_Box *s)\n{\n\tGF_RelyHintBox *rely = (GF_RelyHintBox *)s;\n\tgf_free(rely);\n}\n\nGF_Err rely_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tptr->reserved = gf_bs_read_int(bs, 6);\n\tptr->preferred = gf_bs_read_int(bs, 1);\n\tptr->required = gf_bs_read_int(bs, 1);\n\treturn GF_OK;\n}\n\nGF_Box *rely_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RelyHintBox, GF_ISOM_BOX_TYPE_RELY);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rely_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 6);\n\tgf_bs_write_int(bs, ptr->preferred, 1);\n\tgf_bs_write_int(bs, ptr->required, 1);\n\treturn GF_OK;\n}\n\nGF_Err rely_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rtpo_box_del(GF_Box *s)\n{\n\tGF_RTPOBox *rtpo = (GF_RTPOBox *)s;\n\tgf_free(rtpo);\n}\n\nGF_Err rtpo_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *rtpo_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtpo_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//here we have no pb, just remembed that some entries will have to\n\t//be 4-bytes aligned ...\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid smhd_box_del(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tif (ptr == NULL ) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err smhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *smhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SoundMediaHeaderBox, GF_ISOM_BOX_TYPE_SMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err smhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err smhd_box_size(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\n\tptr->reserved = 0;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid snro_box_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}\n\nGF_Err snro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SeqOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *snro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SeqOffHintEntryBox, GF_ISOM_BOX_TYPE_SNRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err snro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}\n\nGF_Err snro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stbl_box_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tif (ptr->traf_map) {\n\t\tif (ptr->traf_map->frag_starts) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->traf_map->nb_entries; i++) {\n\t\t\t\tif (ptr->traf_map->frag_starts[i].moof_template)\n\t\t\t\t\tgf_free(ptr->traf_map->frag_starts[i].moof_template);\n\t\t\t}\n\t\t\tgf_free(ptr->traf_map->frag_starts);\n\t\t}\n\t\tgf_free(ptr->traf_map);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err stbl_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STTS:\n\t\tBOX_FIELD_ASSIGN(TimeToSample, GF_TimeToSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CTTS:\n\t\tBOX_FIELD_ASSIGN(CompositionOffset, GF_CompositionOffsetBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CSLG:\n\t\tBOX_FIELD_ASSIGN(CompositionToDecode, GF_CompositionToDecodeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSS:\n\t\tBOX_FIELD_ASSIGN(SyncSample, GF_SyncSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\tBOX_FIELD_ASSIGN(SampleDescription, GF_SampleDescriptionBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STZ2:\n\tcase GF_ISOM_BOX_TYPE_STSZ:\n\t\tBOX_FIELD_ASSIGN(SampleSize, GF_SampleSizeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSC:\n\t\tBOX_FIELD_ASSIGN(SampleToChunk, GF_SampleToChunkBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PADB:\n\t\tBOX_FIELD_ASSIGN(PaddingBits, GF_PaddingBitsBox)\n\t\tbreak;\n\n\t//WARNING: AS THIS MAY CHANGE DYNAMICALLY DURING EDIT,\n\tcase GF_ISOM_BOX_TYPE_CO64:\n\tcase GF_ISOM_BOX_TYPE_STCO:\n\t\tBOX_FIELD_ASSIGN(ChunkOffset, GF_Box)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSH:\n\t\tBOX_FIELD_ASSIGN(ShadowSync, GF_ShadowSyncBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STDP:\n\t\tBOX_FIELD_ASSIGN(DegradationPriority, GF_DegradationPriorityBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(SampleDep, GF_SampleDependencyTypeBox)\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\t//check subsample box\n\t\tif (!is_rem) {\n\t\t\tGF_SubSampleInformationBox *subs = (GF_SubSampleInformationBox *)a;\n\t\t\tGF_SubSampleInfoEntry *ent = gf_list_get(subs->Samples, 0);\n\t\t\tif (!ent) {\n\t\t\t\tgf_list_rem(subs->Samples, 0);\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable is invalid\\n\"));\n\t\t\t}\n\t\t\telse if (ent->sample_delta==0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable has sample_delta of 0, should be one. Fixing\\n\"));\n\t\t\t\tent->sample_delta = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\t//we need to parse DegPrior in a special way\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_stbl_boxes = gf_list_count(ptr->child_boxes);\n\n\tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_CLONE_TRACK)\n\t\treturn GF_OK;\n//\treturn GF_OK;\n\n#define CHECK_BOX(_name) \\\n\tif (!ptr->_name) {\\\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Mandatory box %s is missing\\n\", #_name)); \\\n\t\treturn GF_ISOM_INVALID_FILE; \\\n\t}\n\n\tCHECK_BOX(SampleToChunk)\n\tCHECK_BOX(SampleSize)\n\tCHECK_BOX(ChunkOffset)\n\tCHECK_BOX(TimeToSample)\n\n\t//sanity check\n\tif (ptr->SampleSize->sampleCount) {\n\t\tif (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tu32 i, max_chunks=0;\n\tif (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\telse if (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\n\t//sanity check on stsc vs chunk offset tables\n\tfor (i=0; i<ptr->SampleToChunk->nb_entries; i++) {\n\t\tGF_StscEntry *ent = &ptr->SampleToChunk->entries[i];\n\t\tif (!i && (ent->firstChunk!=1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk of first entry shall be 1 but is %u\\n\", ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (ptr->SampleToChunk->entries[i].firstChunk > max_chunks) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk is %u but number of chunks defined %u\\n\", ptr->SampleToChunk->entries[i].firstChunk, max_chunks));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i+1 == ptr->SampleToChunk->nb_entries) break;\n\t\tGF_StscEntry *next_ent = &ptr->SampleToChunk->entries[i+1];\n\t\tif (next_ent->firstChunk < ent->firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk (%u) for entry %u is greater than first_chunk (%u) for entry %u\\n\", i+1, ent->firstChunk, i+2, next_ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stbl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\t//maxSamplePer chunk is 10 by default\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stbl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err stbl_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDescription, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->TimeToSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionToDecode, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SyncSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ShadowSync, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleToChunk, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleSize, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ChunkOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->DegradationPriority, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDep, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->PaddingBits, &pos);\n\n\tif (ptr->sub_samples) {\n\t\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t}\n\tif (ptr->sampleGroups) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t}\n\tif (ptr->sai_sizes) {\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t}\n\tif (ptr->sai_offsets) {\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stco_box_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\n\nGF_Err stco_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->nb_entries > ptr->size / 4 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stco\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tptr->offsets = (u32 *) gf_malloc(ptr->nb_entries * sizeof(u32) );\n\t\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->nb_entries;\n\n\t\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\t\tptr->offsets[entries] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stco_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkOffsetBox, GF_ISOM_BOX_TYPE_STCO);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stco_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stco_box_size(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stdp_box_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}\n\n//this is called through stbl_read...\nGF_Err stdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\t/*out-of-order stdp, assume no padding at the end and take the entire remaining data for entries*/\n\tif (!ptr->nb_entries) ptr->nb_entries = (u32) ptr->size / 2;\n\telse if (ptr->nb_entries > ptr->size / 2) return GF_ISOM_INVALID_FILE;\n\n\tptr->priorities = (u16 *) gf_malloc(ptr->nb_entries * sizeof(u16));\n\tif (ptr->priorities == NULL) return GF_OUT_OF_MEM;\n\tfor (entry = 0; entry < ptr->nb_entries; entry++) {\n\t\tptr->priorities[entry] = gf_bs_read_u16(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, (2*ptr->nb_entries) );\n\treturn GF_OK;\n}\n\nGF_Box *stdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DegradationPriorityBox, GF_ISOM_BOX_TYPE_STDP);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->priorities[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stdp_box_size(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\tptr->size += (2 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsc_box_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 12 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_StscEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsc\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = NULL;\n\tif (ptr->nb_entries) {\n\t\tptr->entries = gf_malloc(sizeof(GF_StscEntry)*ptr->alloc_size);\n\t\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].firstChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].samplesPerChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDescriptionIndex = gf_bs_read_u32(bs);\n\t\tptr->entries[i].isEdited = 0;\n\t\tptr->entries[i].nextChunk = 0;\n\t\tif (!ptr->entries[i].firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] invalid first chunk 0 in stsc entry\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//update the next chunk in the previous entry\n\t\tif (i) ptr->entries[i-1].nextChunk = ptr->entries[i].firstChunk;\n\t}\n\tptr->currentIndex = 0;\n\tptr->firstSampleInCurrentChunk = 0;\n\tptr->currentChunk = 0;\n\tptr->ghostNumber = 0;\n\treturn GF_OK;\n}\n\nGF_Box *stsc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleToChunkBox, GF_ISOM_BOX_TYPE_STSC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].firstChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].samplesPerChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDescriptionIndex);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsc_box_size(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->size += 4 + (12 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsd_box_del(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err stsd_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *def;\n\tif (!a) return GF_OK;\n\n\tif (is_rem || gf_box_valid_in_parent(a, \"stsd\")) {\n\t\treturn GF_OK;\n\t}\n\tswitch (a->type) {\n\t//unknown sample description: we need a specific box to handle the data ref index\n\t//rather than a default box ...\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tdef = (GF_UnknownBox *)a;\n\t\t/*we need at least 8 bytes for unknown sample entries*/\n\t\tif (def->dataSize < 8) {\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t}\n\t\treturn GF_OK;\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Cannot process box of type %s\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n}\n\n\nGF_Err stsd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tISOM_DECREASE_SIZE(s, 4)\n\tgf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read_ex(s, bs, GF_ISOM_BOX_TYPE_STSD);\n}\n\nGF_Box *stsd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 nb_entries;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->child_boxes);\n\tgf_bs_write_u32(bs, nb_entries);\n\treturn GF_OK;\n}\n\nGF_Err stsd_box_size(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsh_box_del(GF_Box *s)\n{\n\tu32 i = 0;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tif (ptr == NULL) return;\n\twhile ( (ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i)) ) {\n\t\tgf_free(ent);\n\t}\n\tgf_list_del(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tcount = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i = 0; i < count; i++) {\n\t\tGF_StshEntry *ent = (GF_StshEntry *) gf_malloc(sizeof(GF_StshEntry));\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->shadowedSampleNumber = gf_bs_read_u32(bs);\n\t\tent->syncSampleNumber = gf_bs_read_u32(bs);\n\t\te = gf_list_add(ptr->entries, ent);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);\n\n\ttmp->entries = gf_list_new();\n\tif (!tmp->entries) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsh_box_size(GF_Box *s)\n{\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tptr->size += 4 + (8 * gf_list_count(ptr->entries));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stss_box_del(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sampleNumbers) gf_free(ptr->sampleNumbers);\n\tgf_free(ptr);\n}\n\nGF_Err stss_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 4 <  ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stss\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->sampleNumbers = (u32 *) gf_malloc( ptr->alloc_size * sizeof(u32));\n\tif (ptr->sampleNumbers == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->sampleNumbers[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stss_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SyncSampleBox, GF_ISOM_BOX_TYPE_STSS);\n\treturn (GF_Box*)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stss_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->sampleNumbers[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stss_box_size(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsz_box_del(GF_Box *s)\n{\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sizes) gf_free(ptr->sizes);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, estSize;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//support for CompactSizes\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sampleSize = gf_bs_read_u32(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t} else {\n\t\t//24-reserved\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tgf_bs_read_int(bs, 24);\n\t\ti = gf_bs_read_u8(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t\tswitch (i) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tptr->sampleSize = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//try to fix the file\n\t\t\t//no samples, no parsing pb\n\t\t\tif (!ptr->sampleCount) {\n\t\t\t\tptr->sampleSize = 16;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\testSize = (u32) (ptr->size) / ptr->sampleCount;\n\t\t\tif (!estSize && ((ptr->sampleCount+1)/2 == (ptr->size)) ) {\n\t\t\t\tptr->sampleSize = 4;\n\t\t\t\tbreak;\n\t\t\t} else if (estSize == 1 || estSize == 2) {\n\t\t\t\tptr->sampleSize = 8 * estSize;\n\t\t\t} else {\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\tif (ptr->sampleCount && (u64)ptr->sampleCount > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize && ptr->sampleCount) {\n\t\t\tif (ptr->sampleCount > ptr->size / 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\t\tptr->alloc_size = ptr->sampleCount;\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tptr->sizes[i] = gf_bs_read_u32(bs);\n\t\t\t\tif (ptr->max_size < ptr->sizes[i])\n\t\t\t\t\tptr->max_size = ptr->sizes[i];\n\t\t\t\tptr->total_size += ptr->sizes[i];\n\t\t\t\tptr->total_samples++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (ptr->sampleSize==4) {\n\t\t\tif (ptr->sampleCount / 2 > ptr->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->sampleCount > ptr->size / (ptr->sampleSize/8)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t\t//note we could optimize the mem usage by keeping the table compact\n\t\t//in memory. But that would complicate both caching and editing\n\t\t//we therefore keep all sizes as u32 and uncompress the table\n\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->sampleCount;\n\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tu32 s_size;\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, 4);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\ts_size = ptr->sizes[i+1] = gf_bs_read_int(bs, 4);\n\t\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\t\tptr->total_size += s_size;\n\t\t\t\t\tptr->total_samples++;\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, ptr->sampleSize);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleSizeBox, 0);\n\n\t//type is unknown here, can be regular or compact table\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//in both versions this is still valid\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_bs_write_u32(bs, ptr->sampleSize);\n\t} else {\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u8(bs, ptr->sampleSize);\n\t}\n\tgf_bs_write_u32(bs, ptr->sampleCount);\n\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize) {\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tgf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i+1], 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\n\t//regular table\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) continue;\n\t\t//switch to 8-bit table\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\t//switch to 16-bit table\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\t//switch to 32-bit table\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\n\t\t//check the size\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\t//if all samples are of the same size, switch to regular (more compact)\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t}\n\n\tif (fieldSize == 32) {\n\t\t//oops, doesn't fit in a compact table\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\t//make sure we are a compact table (no need to change the mem representation)\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\t//do not forget the 0 padding field for odd count\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stts_box_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastDTS = 0;\n#endif\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_SttsEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_SttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDelta = gf_bs_read_u32(bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tptr->w_currentSampleNum += ptr->entries[i].sampleCount;\n\t\tptr->w_LastDTS += (u64)ptr->entries[i].sampleCount * ptr->entries[i].sampleDelta;\n#endif\n\t\tif (ptr->max_ts_delta<ptr->entries[i].sampleDelta)\n\t\t\tptr->max_ts_delta = ptr->entries[i].sampleDelta;\n\n\t\tif (!ptr->entries[i].sampleDelta) {\n\t\t\tif ((i+1<ptr->nb_entries) ) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found stts entry with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t} else if (ptr->entries[i].sampleCount>1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] more than one stts entry at the end of the track with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t}\n\t\t}\n\t\t//cf issue 1644: some media streams may have sample duration > 2^31 (ttml mostly), we cannot patch this\n\t\t//for now we disable the check, one opt could be to have the check only for some media types, or only for the first entry\n#if 0\n\t\telse if ((s32) ptr->entries[i].sampleDelta < 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] stts entry %d has negative duration %d - forbidden ! Fixing to 1, sync may get lost (consider reimport raw media)\\n\", i, (s32) ptr->entries[i].sampleDelta ));\n\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t}\n#endif\n\n\t}\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries*8);\n\n\t//remove the last sample delta.\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (ptr->nb_entries) ptr->w_LastDTS -= ptr->entries[ptr->nb_entries-1].sampleDelta;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeToSampleBox, GF_ISOM_BOX_TYPE_STTS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDelta);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stts_box_size(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid tfhd_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err tfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->base_data_offset = gf_bs_read_u64(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->sample_desc_index = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_size = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err tfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->trackID);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_bs_write_u64(bs, ptr->base_data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tgf_bs_write_u32(bs, ptr->sample_desc_index);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfhd_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tims_box_del(GF_Box *s)\n{\n\tGF_TSHintEntryBox *tims = (GF_TSHintEntryBox *)s;\n\tgf_free(tims);\n}\n\nGF_Err tims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeScale = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeScale);\n\treturn GF_OK;\n}\n\nGF_Err tims_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tkhd_box_del(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err tkhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 32);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tptr->initial_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 60);\n\tptr->reserved2[0] = gf_bs_read_u32(bs);\n\tptr->reserved2[1] = gf_bs_read_u32(bs);\n\tptr->layer = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->volume = gf_bs_read_u16(bs);\n\tptr->reserved3 = gf_bs_read_u16(bs);\n\tptr->matrix[0] = gf_bs_read_u32(bs);\n\tptr->matrix[1] = gf_bs_read_u32(bs);\n\tptr->matrix[2] = gf_bs_read_u32(bs);\n\tptr->matrix[3] = gf_bs_read_u32(bs);\n\tptr->matrix[4] = gf_bs_read_u32(bs);\n\tptr->matrix[5] = gf_bs_read_u32(bs);\n\tptr->matrix[6] = gf_bs_read_u32(bs);\n\tptr->matrix[7] = gf_bs_read_u32(bs);\n\tptr->matrix[8] = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tkhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackHeaderBox, GF_ISOM_BOX_TYPE_TKHD);\n\ttmp->matrix[0] = 0x00010000;\n\ttmp->matrix[4] = 0x00010000;\n\ttmp->matrix[8] = 0x40000000;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tkhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_box_size(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\tptr->size += (ptr->version == 1) ? 32 : 20;\n\tptr->size += 60;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid traf_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tgf_list_del(ptr->TrackRuns);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tgf_free(ptr);\n}\n\nGF_Err traf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tBOX_FIELD_ASSIGN(tfhd, GF_TrackFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackRuns)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(sdtp, GF_SampleDependencyTypeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tBOX_FIELD_ASSIGN(tfdt, GF_TFBaseMediaDecodeTimeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\treturn GF_OK;\n\t//we will throw an error if both PIFF_PSEC and SENC are found. Not such files seen yet\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\tif (!is_rem)\n\t\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFXD) {\n\t\t\tBOX_FIELD_ASSIGN(tfxd, GF_MSSTimeExtBox)\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFRF) {\n\t\t\tBOX_FIELD_ASSIGN(tfrf, GF_MSSTimeRefBox)\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\tif (!is_rem)\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err traf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *traf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentBox, GF_ISOM_BOX_TYPE_TRAF);\n\ttmp->TrackRuns = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err traf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err traf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfhd, &pos);\n\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfdt, &pos);\n\n\t//cmaf-like\n\tif (ptr->truns_first) {\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\t//senc MUST be after saio in GPAC, as senc writing uses info from saio writing\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\t//subsamples will be last\n\t} else {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t}\n\n\t//when sdtp is present (smooth-like) write it after the trun box\n\tgf_isom_check_position(s, (GF_Box *)ptr->sdtp, &pos);\n\n\t//tfxd should be last ...\n\tif (ptr->tfxd)\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->tfxd, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tfxd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeExtBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFXD;\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfxd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err tfxd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tif (ptr->version == 0x01) {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfxd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tif (ptr->version) {\n\t\tgf_bs_write_u64(bs, ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration_in_track_timescale);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration_in_track_timescale);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfxd_box_size(GF_Box *s)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\ts->size += 4 + (ptr->version ? 16 : 8);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n\nGF_Box *tfrf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeRefBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFRF;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfrf_box_del(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tif (ptr->frags) gf_free(ptr->frags);\n\tgf_free(s);\n}\n\n\nGF_Err tfrf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tptr->frags_count = gf_bs_read_u8(bs);\n\tptr->frags = gf_malloc(sizeof(GF_MSSTimeEntry) * ptr->frags_count);\n\tif (!ptr->frags) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version == 0x01) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfrf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tgf_bs_write_u8(bs, ptr->frags_count);\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version==0x01) {\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfrf_box_size(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\ts->size += 5;\n\tif (ptr->version) s->size += 16 * ptr->frags_count;\n\telse s->size += 8 * ptr->frags_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid trak_box_del(GF_Box *s)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->chunk_cache)\n\t\tgf_bs_del(ptr->chunk_cache);\n#endif\n\tgf_free(s);\n}\n\nstatic GF_Err gf_isom_check_sample_desc(GF_TrackBox *trak)\n{\n\tGF_BitStream *bs;\n\tGF_UnknownBox *a;\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\n\tif (!trak->Media || !trak->Media->information) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no media box !\\n\" ));\n\t\treturn GF_OK;\n\t}\n\tif (!trak->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample table !\\n\" ));\n\t\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\t}\n\tstbl = trak->Media->information->sampleTable;\n\n\tif (!stbl->SampleDescription) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample description box !\\n\" ));\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\treturn GF_OK;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_UnknownBox*)gf_list_enum(stbl->SampleDescription->child_boxes, &i))) {\n\t\tGF_ProtectionSchemeInfoBox *sinf;\n\t\tu32 base_ent_type = 0;\n\t\tu32 type = a->type;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!sinf || !sinf->original_format) return GF_ISOM_INVALID_FILE;\n\t\t\ttype = sinf->original_format->data_format;\n\t\t\tbase_ent_type = ((GF_SampleEntryBox *)a)->internal_type;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_MP4S)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Protected sample entry %s uses incompatible sample description %s\\n\", gf_4cc_to_str(a->type), gf_4cc_to_str(type) ));\n\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_ISOM_BOX_TYPE_MHA1:\n\t\tcase GF_ISOM_BOX_TYPE_MHA2:\n\t\tcase GF_ISOM_BOX_TYPE_MHM1:\n\t\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tcase GF_ISOM_BOX_TYPE_OPUS:\n\t\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_ISOM_BOX_TYPE_IPCM:\n\t\tcase GF_ISOM_BOX_TYPE_FPCM:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_AUDIO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VP08:\n\t\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tcase GF_ISOM_BOX_TYPE_JPEG:\n\t\tcase GF_ISOM_BOX_TYPE_PNG:\n\t\tcase GF_ISOM_BOX_TYPE_JP2K:\n\t\tcase GF_ISOM_BOX_TYPE_MJP2:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_VIDEO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tcase GF_ISOM_BOX_TYPE_GHNT:\n\t\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_DIMS:\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_GENERIC))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (gf_box_valid_in_parent((GF_Box *) a, \"stsd\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unexpected box %s in stsd!\\n\", gf_4cc_to_str(a->type)));\n\t\t\tcontinue;\n\t\t}\n\t\t//we are sure to have an unknown box here\n\t\tassert(a->type==GF_ISOM_BOX_TYPE_UNKNOWN);\n\n\t\tif (!a->data || (a->dataSize<8) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Sample description %s does not have at least 8 bytes!\\n\", gf_4cc_to_str(a->original_4cc) ));\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a->dataSize > a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Sample description %s has wrong data size %d!\\n\", gf_4cc_to_str(a->original_4cc), a->dataSize));\n\t\t\tcontinue;\n\t\t}\n\n#define STSD_SWITCH_BOX(_box) \\\n\t\tif (gf_bs_available(bs)) { \\\n\t\t\tu64 pos = gf_bs_get_position(bs); \\\n\t\t\tu32 count_subb = 0; \\\n\t\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS);\\\n\t\t\te = gf_isom_box_array_read((GF_Box *) _box, bs); \\\n\t\t\tcount_subb = _box->child_boxes ? gf_list_count(_box->child_boxes) : 0; \\\n\t\t\tif (count_subb && !e) { \\\n\t\t\t\tgf_bs_seek(bs, pos); \\\n\t\t\t\t_box->data_size = (u32) gf_bs_available(bs); \\\n\t\t\t\tif (_box->data_size) { \\\n\t\t\t\t\t_box->data = a->data; \\\n\t\t\t\t\ta->data = NULL; \\\n\t\t\t\t\tmemmove(_box->data, _box->data + pos, _box->data_size); \\\n\t\t\t\t} \\\n\t\t\t} else { \\\n\t\t\t\t_box->data_size = 0; \\\n\t\t\t} \\\n\t\t} \\\n\t\tgf_bs_del(bs); \\\n\t\tif (!_box->data_size && _box->data) { \\\n\t\t\tgf_free(_box->data); \\\n\t\t\t_box->data = NULL; \\\n\t\t} \\\n\t\t_box->size = 0; \\\n\t\t_box->EntryType = a->original_4cc; \\\n\t\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, i-1); \\\n\t\tgf_isom_box_del((GF_Box *)a); \\\n\t\tgf_list_insert(trak->Media->information->sampleTable->SampleDescription->child_boxes, _box, i-1); \\\n\n\n\t\t/*only process visual or audio\n\t\tnote: no need for new_box_parent here since we always store sample descriptions in child_boxes*/\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t{\n\t\t\tGF_GenericVisualSampleEntryBox *genv = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgenv->size = a->size-8;\n\t\t\tgf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *) genv, bs);\n\n\t\t\tSTSD_SWITCH_BOX(genv)\n\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t{\n\t\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tgena->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox *) gena, bs);\n\n\t\t\tSTSD_SWITCH_BOX(gena)\n\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tgenm->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\n\t\t\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)genm, bs);\n\t\t\tif (e) return e;\n\n\t\t\tSTSD_SWITCH_BOX(genm)\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TKHD:\n\t\tBOX_FIELD_ASSIGN(Header, GF_TrackHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EDTS:\n\t\tBOX_FIELD_ASSIGN(editBox, GF_EditBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREF:\n\t\tBOX_FIELD_ASSIGN(References, GF_TrackReferenceBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MDIA:\n\t\tBOX_FIELD_ASSIGN(Media, GF_MediaBox)\n\t\tif (!is_rem)\n\t\t\t((GF_MediaBox *)a)->mediaTrack = ptr;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRGR:\n\t\tBOX_FIELD_ASSIGN(groups, GF_TrackGroupBox)\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_TAPT:\n\t\tBOX_FIELD_ASSIGN(Aperture, GF_Box)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UnknownUUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\te = gf_isom_check_sample_desc(ptr);\n\tif (e) return e;\n\n\tif (!ptr->Header) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information || !ptr->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information->sampleTable->SampleSize || (ptr->Media->information->sampleTable->SampleSize->sampleCount==0)) {\n\t\tif (ptr->Header->initial_duration) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Track with no samples but duration defined, ignoring duration\\n\"));\n\t\t\tptr->Header->initial_duration = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(ptr->Media->information->sampleTable->child_boxes); i++) {\n\t\tGF_Box *a = gf_list_get(ptr->Media->information->sampleTable->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *) a;\n\t\t\tbreak;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *)a;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *trak_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackBox, GF_ISOM_BOX_TYPE_TRAK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trak_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stri_box_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}\n\nGF_Err stri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->attribute_count = ptr->size / 4;\n\tif ((u64)ptr->attribute_count > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in stri\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stri_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->switch_group);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u32(bs, ptr->sub_track_id);\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->attribute_list[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stri_box_size(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\n\tptr->size += 8 + 4 * ptr->attribute_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsg_box_del(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->group_description_index) gf_free(ptr->group_description_index);\n\tgf_free(ptr);\n}\n\nGF_Err stsg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tISOM_DECREASE_SIZE(s, 6);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tptr->nb_groups = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(s, ptr->nb_groups*4);\n\tGF_SAFE_ALLOC_N(ptr->group_description_index, ptr->nb_groups, u32);\n\tif (!ptr->group_description_index) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tptr->group_description_index[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackSampleGroupBox, GF_ISOM_BOX_TYPE_STSG);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\tgf_bs_write_u16(bs, ptr->nb_groups);\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tgf_bs_write_u32(bs, ptr->group_description_index[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsg_box_size(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tptr->size += 6 + 4 * ptr->nb_groups;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid strk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err strk_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STRI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SubTrackInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STRD:\n\t\tBOX_FIELD_ASSIGN(strd, GF_Box)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err strk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->info) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing SubTrackInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *strk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackBox, GF_ISOM_BOX_TYPE_STRK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err strk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err strk_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tref_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err tref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\nGF_Box *tref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceBox, GF_ISOM_BOX_TYPE_TREF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err tref_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid reftype_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->trackIDs) gf_free(ptr->trackIDs);\n\tgf_free(ptr);\n}\n\n\nGF_Err reftype_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\n\tbytesToRead = (u32) (ptr->size);\n\tif (!bytesToRead) return GF_OK;\n\n\tptr->trackIDCount = (u32) (bytesToRead) / sizeof(u32);\n\tptr->trackIDs = (GF_ISOTrackID *) gf_malloc(ptr->trackIDCount * sizeof(GF_ISOTrackID));\n\tif (!ptr->trackIDs) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tptr->trackIDs[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *reftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}\n\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, GF_ISOTrackID trackID, u16 *outRefIndex)\n{\n\tu32 i;\n\tif (!ref || !trackID) return GF_BAD_PARAM;\n\n\tif (outRefIndex) *outRefIndex = 0;\n\t//don't add a dep if already here !!\n\tfor (i = 0; i < ref->trackIDCount; i++) {\n\t\tif (ref->trackIDs[i] == trackID) {\n\t\t\tif (outRefIndex) *outRefIndex = i+1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tref->trackIDs = (GF_ISOTrackID *) gf_realloc(ref->trackIDs, (ref->trackIDCount + 1) * sizeof(GF_ISOTrackID) );\n\tif (!ref->trackIDs) return GF_OUT_OF_MEM;\n\tref->trackIDs[ref->trackIDCount] = trackID;\n\tref->trackIDCount++;\n\tif (outRefIndex) *outRefIndex = ref->trackIDCount;\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err reftype_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tptr->type = ptr->reference_type;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFT;\n\tif (e) return e;\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->trackIDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err reftype_box_size(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->trackIDCount)\n\t\tptr->size += (ptr->trackIDCount * sizeof(u32));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trex_box_del(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->trackID = gf_bs_read_u32(bs);\n\tptr->def_sample_desc_index = gf_bs_read_u32(bs);\n\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\tptr->def_sample_size = gf_bs_read_u32(bs);\n\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *trex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\t//we always write 1 in trex default sample desc as using 0 breaks chrome/opera/...\n\tgf_bs_write_u32(bs, ptr->def_sample_desc_index ? ptr->def_sample_desc_index : 1);\n\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\treturn GF_OK;\n}\n\nGF_Err trex_box_size(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tptr->size += 20;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid trep_box_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *trep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtensionPropertiesBox, GF_ISOM_BOX_TYPE_TREP);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\treturn GF_OK;\n}\n\nGF_Err trep_box_size(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trun_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->samples) gf_free(ptr->samples);\n\tif (ptr->cache) gf_bs_del(ptr->cache);\n\tif (ptr->sample_order) gf_free(ptr->sample_order);\n\tgf_free(ptr);\n}\n\n#ifdef GF_ENABLE_CTRN\n\nstatic u32 ctrn_field_size(u32 field_idx)\n{\n\tif (field_idx==3) return 4;\n\treturn field_idx;\n}\n\nu32 gf_isom_ctrn_field_size_bits(u32 field_idx)\n{\n\tif (field_idx==3) return 32;\n\treturn field_idx*8;\n}\nstatic u32 ctrn_read_flags(GF_BitStream *bs, u32 nbbits)\n{\n\tu32 val = gf_bs_read_int(bs, nbbits);\n\tif (nbbits==16) val <<= 16;\n\telse if (nbbits==8) val <<= 24;\n\treturn val;\n}\n\nstatic GF_Err ctrn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count, flags, first_idx=0;\n\tBool inherit_dur, inherit_size, inherit_flags, inherit_ctso;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tflags = ptr->flags;\n\tptr->ctrn_flags = flags;\n\tptr->flags = 0;\n\n\tptr->sample_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tptr->data_offset = gf_bs_read_u16(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\t} else {\n\t\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t}\n\t\tptr->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t}\n\tif (flags & GF_ISOM_CTRN_CTSO_MULTIPLIER) {\n\t\tptr->ctso_multiplier = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t}\n\t/*no sample dur/sample_flag/size/ctso for first or following, create a pack sample */\n\tif (! (flags & 0x00FFFF00)) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->nb_pack = ptr->sample_count;\n\t\tgf_list_add(ptr->entries, ent);\n\t\treturn GF_OK;\n\t}\n\t/*allocate all entries*/\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->entries, ent);\n\t}\n\t//unpack flags\n\tptr->ctrn_first_dur = (flags>>22) & 0x3;\n\tptr->ctrn_first_size = (flags>>20) & 0x3;\n\tptr->ctrn_first_sample_flags = (flags>>18) & 0x3;\n\tptr->ctrn_first_ctts = (flags>>16) & 0x3;\n\tptr->ctrn_dur = (flags>>14) & 0x3;\n\tptr->ctrn_size = (flags>>12) & 0x3;\n\tptr->ctrn_sample_flags = (flags>>10) & 0x3;\n\tptr->ctrn_ctts = (flags>>8) & 0x3;\n\n\tinherit_dur = flags & GF_ISOM_CTRN_INHERIT_DUR;\n\tinherit_size = flags & GF_ISOM_CTRN_INHERIT_SIZE;\n\tinherit_flags = flags & GF_ISOM_CTRN_INHERIT_FLAGS;\n\tinherit_ctso = flags & GF_ISOM_CTRN_INHERIT_CTSO;\n\n\tif (flags & GF_ISOM_CTRN_FIRST_SAMPLE) {\n\t\tent = gf_list_get(ptr->entries, 0);\n\t\tfirst_idx = 1;\n\t\tif (!inherit_dur && ptr->ctrn_first_dur) {\n\t\t\tent->Duration = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_dur) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_dur) );\n\t\t}\n\t\tif (!inherit_size && ptr->ctrn_first_size) {\n\t\t\tent->size = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_size) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_size) );\n\t\t}\n\t\tif (!inherit_flags && ptr->ctrn_first_sample_flags) {\n\t\t\tent->flags = ctrn_read_flags(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_sample_flags) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_sample_flags) );\n\t\t}\n\t\tif (!inherit_ctso && ptr->ctrn_first_ctts) {\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_ctts) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_ctts) );\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\tcount = ptr->sample_count - first_idx;\n\tif (!inherit_dur && ptr->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_dur);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->Duration = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_size && ptr->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_size);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->size = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_flags && ptr->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_sample_flags);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->flags = ctrn_read_flags(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_ctso && ptr->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_ctts);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, nbbits);\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->type == GF_ISOM_BOX_TYPE_CTRN) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_TRUN;\n\t\tptr->use_ctrn = GF_TRUE;\n\t\treturn ctrn_box_read(s, bs);\n\t}\n#endif\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t}\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\t//memset to 0 !!\n\t\tmemset(ptr->samples, 0, sizeof(GF_TrunEntry));\n\t\tptr->sample_alloc = ptr->nb_samples = 1;\n\t\tptr->samples[0].nb_pack = ptr->sample_count;\n\t} else {\n\t\t//if we get here, at least one flag (so at least 4 bytes) is set, check size\n\t\tif (ptr->sample_count * 4 > ptr->size) {\n\t\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count*4);\n\t\t}\n\t\tif ((u64)ptr->sample_count > (u64)SIZE_MAX/sizeof(GF_TrunEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of samples %d in trun\\n\", ptr->sample_count));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry) * ptr->sample_count);\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\tptr->sample_alloc = ptr->nb_samples = ptr->sample_count;\n\t\t//memset to 0 upfront\n\t\tmemset(ptr->samples, 0, ptr->sample_count * sizeof(GF_TrunEntry));\n\n\t\t//read each entry (even though nothing may be written)\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tu32 trun_size = 0;\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t\t} else {\n\t\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t\t}\n\t}\n\t/*todo parse sample reorder*/\n\tif (ptr->size) {\n\t\tgf_bs_skip_bytes(bs, ptr->size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trun_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#ifdef GF_ENABLE_CTRN\nstatic void ctrn_write_sample_flags(GF_BitStream *bs, u32 flags, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (field_size==8) flags = flags>>24;\n\telse if (field_size==16) flags = flags>>16;\n\tgf_bs_write_int(bs, flags, field_size);\n}\n\n\nstatic void ctrn_write_ctso(GF_TrackFragmentRunBox *ctrn, GF_BitStream *bs, u32 ctso, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_int(bs, ctso / ctrn->ctso_multiplier, field_size);\n\t} else {\n\t\tgf_bs_write_int(bs, ctso, field_size);\n\t}\n}\n\nGF_Err ctrn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, count, flags;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ctrn = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tflags = ctrn->flags;\n\tctrn->flags = ctrn->ctrn_flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_CTRN;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tctrn->flags = flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_TRUN;\n\n\tgf_bs_write_u16(bs, ctrn->sample_count);\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (ctrn->ctrn_flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tgf_bs_write_u16(bs, ctrn->data_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, ctrn->data_offset);\n\t\t}\n\t}\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_u16(bs, ctrn->ctso_multiplier);\n\t}\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tgf_bs_write_int(bs, ent->Duration, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_dur) );\n\tgf_bs_write_int(bs, ent->size, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_size) );\n\tctrn_write_sample_flags(bs, ent->flags, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_sample_flags) );\n\tctrn_write_ctso(ctrn,bs, ent->CTS_Offset, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_ctts) );\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_dur);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->Duration, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_size);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->size, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_sample_flags);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_sample_flags(bs, a_ent->flags, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_ctts);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_ctso(ctrn, bs, a_ent->CTS_Offset, nbbits);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_write(s, bs);\n#endif\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tgf_bs_write_u32(bs, ptr->data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tgf_bs_write_u32(bs, ptr->first_sample_flags);\n\t}\n\n\tif (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) )  {\n\t\tfor (i=0; i<ptr->nb_samples; i++) {\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tgf_bs_write_u32(bs, p->Duration);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tgf_bs_write_u32(bs, p->size);\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tgf_bs_write_u32(bs, p->flags);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->CTS_Offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) p->CTS_Offset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bits = 8;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bits = 32;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bits = 24;\n\t\telse if (ptr->sample_count>0xFF) nb_bits = 16;\n\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tgf_bs_write_int(bs, ptr->sample_order[i], nb_bits);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic u32 ctrn_sample_flags_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val & 0x0000FFFF)\n\t\treturn 3;\n\tif (val & 0x00FF0000)\n\t\treturn 2;\n\treturn 1;\n}\nstatic u32 ctrn_u32_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val<=255) return 1;\n\tif (val<=65535) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_s32_to_index(s32 val)\n{\n\tif (!val) return 0;\n\tif (ABS(val)<=127) return 1;\n\tif (ABS(val)<=32767) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_ctts_to_index(GF_TrackFragmentRunBox *ctrn, s32 ctts)\n{\n\tif (!(ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET))\n\t\treturn 0;\n\n\tif (!ctts) return 0;\n\n\tif (ctrn->version) {\n\t\tif (ctrn->ctso_multiplier) return ctrn_s32_to_index(ctts / ctrn->ctso_multiplier);\n\t\treturn ctrn_s32_to_index(ctts);\n\t}\n\tassert(ctts>0);\n\tif (ctrn->ctso_multiplier) return ctrn_u32_to_index((u32)ctts / ctrn->ctso_multiplier);\n\treturn ctrn_s32_to_index((u32)ctts);\n}\n\nstatic GF_Err ctrn_box_size(GF_TrackFragmentRunBox *ctrn)\n{\n\tBool use_ctso_multi = GF_TRUE;\n\tu32 i, count;\n\tGF_TrunEntry *ent;\n\n\tctrn->ctrn_flags = 0;\n\tctrn->ctrn_first_dur = ctrn->ctrn_first_size = ctrn->ctrn_first_sample_flags = ctrn->ctrn_first_ctts = 0;\n\tctrn->ctrn_dur = ctrn->ctrn_size = ctrn->ctrn_sample_flags = ctrn->ctrn_ctts = 0;\n\n\tctrn->size += 2; //16 bits for sample count\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tctrn->ctrn_flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t\tif (ABS(ctrn->data_offset) < 32767) {\n\t\t\tctrn->size += 2;\n\t\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_DATAOFFSET_16;\n\t\t} else\n\t\t\tctrn->size += 4;\n\t}\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctso_multiplier && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET) && (ctrn->ctso_multiplier<=0xFFFF) ) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tif (a_ent->CTS_Offset % ctrn->ctso_multiplier) {\n\t\t\t\tuse_ctso_multi = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuse_ctso_multi = GF_FALSE;\n\t}\n\tif (ctrn->use_inherit) {\n\t\tuse_ctso_multi = GF_FALSE;\n\t\tctrn->ctrn_flags |= 0xB0; //duration=1,size=0,flags=1,cts=1 << 4\n\t}\n\n\tif (use_ctso_multi) {\n\t\tctrn->size += 2;\n\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_CTSO_MULTIPLIER;\n\t} else {\n\t\tctrn->ctso_multiplier = 0;\n\t}\n\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tctrn->ctrn_flags |= GF_ISOM_CTRN_FIRST_SAMPLE;\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\tctrn->ctrn_first_dur = ctrn_u32_to_index(ent->Duration);\n\t\tif (ctrn->ctrn_first_dur) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_dur);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_dur<<22;\n\t\t}\n\t}\n\n\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\tctrn->ctrn_first_size = ctrn_u32_to_index(ent->size);\n\t\tif (ctrn->ctrn_first_size) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_size);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_size<<20;\n\t\t}\n\t}\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\tctrn->ctrn_first_sample_flags = ctrn_sample_flags_to_index(ent->flags);\n\t\tif (ctrn->ctrn_first_sample_flags) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_sample_flags);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_sample_flags<<18;\n\t\t}\n\t}\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET)) {\n\t\tctrn->ctrn_first_ctts = ctrn_ctts_to_index(ctrn, ent->CTS_Offset);\n\t\tif (ctrn->ctrn_first_ctts) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_ctts);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_ctts<<16;\n\t\t}\n\t}\n\n\tfor (i=1; i<count; i++) {\n\t\tu8 field_idx;\n\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->Duration);\n\t\t\tif (ctrn->ctrn_dur < field_idx)\n\t\t\t\tctrn->ctrn_dur = field_idx;\n\t\t}\n\t\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->size);\n\t\t\tif (ctrn->ctrn_size < field_idx)\n\t\t\t\tctrn->ctrn_size = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\t\tfield_idx = ctrn_sample_flags_to_index(a_ent->flags);\n\t\t\tif (ctrn->ctrn_sample_flags < field_idx)\n\t\t\t\tctrn->ctrn_sample_flags = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit) {\n\t\t\tfield_idx = ctrn_ctts_to_index(ctrn, a_ent->CTS_Offset);\n\t\t\tif (ctrn->ctrn_ctts < field_idx)\n\t\t\t\tctrn->ctrn_ctts = field_idx;\n\t\t}\n\t}\n\tcount-=1;\n\tif (ctrn->ctrn_dur) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_dur);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_dur<<14;\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_size);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_size<<12;\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_sample_flags);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_sample_flags<<10;\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_ctts);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_ctts<<8;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_size(ptr);\n#endif\n\n\tptr->size += 4;\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) ptr->size += 4;\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bytes = 1;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bytes = 4;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bytes = 3;\n\t\telse if (ptr->sample_count>0xFF) nb_bytes = 2;\n\t\tptr->size += ptr->sample_count*nb_bytes;\n\t}\n\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\treturn GF_OK;\n\t}\n\n\t//if nothing to do, this will be skipped automatically\n\tif (ptr->flags & GF_ISOM_TRUN_DURATION) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_SIZE) ptr->size += 4*ptr->nb_samples;\n\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) ptr->size += 4*ptr->nb_samples;\n\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tsro_box_del(GF_Box *s)\n{\n\tGF_TimeOffHintEntryBox *tsro = (GF_TimeOffHintEntryBox *)s;\n\tgf_free(tsro);\n}\n\nGF_Err tsro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->TimeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tsro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeOffHintEntryBox, GF_ISOM_BOX_TYPE_TSRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tsro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->TimeOffset);\n\treturn GF_OK;\n}\n\nGF_Err tsro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid udta_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (ptr == NULL) return;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\tgf_list_del(ptr->recordList);\n\tgf_free(ptr);\n}\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tif (ptr == NULL) return NULL;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tif (map->boxType == box_type) {\n\t\t\tif ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map;\n\t\t\tif (!memcmp(map->uuid, *uuid, 16)) return map;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_Err udta_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Err e;\n\tu32 box_type;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\tif (!a) return GF_OK;\n\n\t//detach from parent list if any\n\tgf_list_del_item(ptr->child_boxes, a);\n\n\t/* for unknown udta boxes, we reference them by their original box type */\n\tbox_type = a->type;\n\tif (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox* unkn = (GF_UnknownBox *)a;\n\t\tbox_type = unkn->original_4cc;\n\t}\n\n\tmap = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);\n\tif (map == NULL) {\n\t\tif (is_rem) return GF_OK;\n\n\t\tmap = (GF_UserDataMap *) gf_malloc(sizeof(GF_UserDataMap));\n\t\tif (map == NULL) return GF_OUT_OF_MEM;\n\t\tmemset(map, 0, sizeof(GF_UserDataMap));\n\n\t\tmap->boxType = box_type;\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UUID)\n\t\t\tmemcpy(map->uuid, ((GF_UUIDBox *)a)->uuid, 16);\n\t\tmap->boxes = gf_list_new();\n\t\tif (!map->boxes) {\n\t\t\tgf_free(map);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(ptr->recordList, map);\n\t\tif (e) return e;\n\t}\n\tif (is_rem) {\n\t\tgf_list_del_item(map->boxes, a);\n\t\treturn GF_OK;\n\t}\n\treturn gf_list_add(map->boxes, a);\n}\n\n\nGF_Err udta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\tif (s->size==4) {\n\t\tu32 val = gf_bs_read_u32(bs);\n\t\ts->size = 0;\n\t\tif (val) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] udta has 4 remaining bytes set to %08X but they should be 0\\n\", val));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *udta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err udta_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_write(s, map->boxes, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err udta_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_size(s, map->boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vmhd_box_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err vmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\nGF_Box *vmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VideoMediaHeaderBox, GF_ISOM_BOX_TYPE_VMHD);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid void_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n\nGF_Box *void_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);\n\treturn tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err void_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err void_box_size(GF_Box *s)\n{\n\ts->size = 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *pdin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProgressiveDownloadBox, GF_ISOM_BOX_TYPE_PDIN);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pdin_box_del(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->rates) gf_free(ptr->rates);\n\tif (ptr->times) gf_free(ptr->times);\n\tgf_free(ptr);\n}\n\n\nGF_Err pdin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\n\tptr->count = (u32) (ptr->size) / 8;\n\tptr->rates = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->rates) return GF_OUT_OF_MEM;\n\tptr->times = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->times) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tptr->rates[i] = gf_bs_read_u32(bs);\n\t\tptr->times[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pdin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->rates[i]);\n\t\tgf_bs_write_u32(bs, ptr->times[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pdin_box_size(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\tptr->size += 8*ptr->count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *sdtp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDependencyTypeBox, GF_ISOM_BOX_TYPE_SDTP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid sdtp_box_del(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info) gf_free(ptr->sample_info);\n\tgf_free(ptr);\n}\n\n\nGF_Err sdtp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\n\t/*out-of-order sdtp, assume no padding at the end*/\n\tif (!ptr->sampleCount) ptr->sampleCount = (u32) ptr->size;\n\telse if (ptr->sampleCount > (u32) ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_info = (u8 *) gf_malloc(sizeof(u8)*ptr->sampleCount);\n\tif (!ptr->sample_info) return GF_OUT_OF_MEM;\n\tptr->sample_alloc = ptr->sampleCount;\n\tgf_bs_read_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\tISOM_DECREASE_SIZE(ptr, ptr->sampleCount);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sdtp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_box_size(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\tptr->size += ptr->sampleCount;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *pasp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PixelAspectRatioBox, GF_ISOM_BOX_TYPE_PASP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pasp_box_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err pasp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->hSpacing = gf_bs_read_u32(bs);\n\tptr->vSpacing = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}\n\nGF_Err pasp_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *clap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanApertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid clap_box_del(GF_Box *s)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err clap_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 32);\n\tptr->cleanApertureWidthN = gf_bs_read_u32(bs);\n\tptr->cleanApertureWidthD = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightN = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightD = gf_bs_read_u32(bs);\n\tptr->horizOffN = (s32) gf_bs_read_u32(bs);\n\tptr->horizOffD = gf_bs_read_u32(bs);\n\tptr->vertOffN = (s32) gf_bs_read_u32(bs);\n\tptr->vertOffD = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthD);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightD);\n\tgf_bs_write_u32(bs, (u32) ptr->horizOffN);\n\tgf_bs_write_u32(bs, ptr->horizOffD);\n\tgf_bs_write_u32(bs, (u32) ptr->vertOffN);\n\tgf_bs_write_u32(bs, ptr->vertOffD);\n\treturn GF_OK;\n}\n\nGF_Err clap_box_size(GF_Box *s)\n{\n\ts->size += 32;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *metx_box_new()\n{\n\t//type is overridden by the box constructor\n\tISOM_DECL_BOX_ALLOC(GF_MetaDataSampleEntryBox, GF_ISOM_BOX_TYPE_METX);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid metx_box_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tgf_free(ptr);\n}\n\n\nGF_Err metx_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TXTC:\n\t\t//we allow the config box on metx\n\t\tBOX_FIELD_ASSIGN(config, GF_TextConfigBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err metx_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tGF_Err e;\n\tchar *str;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tsize = (u32) ptr->size;\n\tstr = gf_malloc(sizeof(char)*size);\n\tif (!str) return GF_OUT_OF_MEM;\n\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i>1) {\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t} else {\n\t\t\tptr->content_encoding = gf_strdup(str);\n\t\t}\n\t}\n\n\ti=0;\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t\t}\n\t\t}\n\n\t\ti=0;\n\t\twhile (size) {\n\t\t\tstr[i] = gf_bs_read_u8(bs);\n\t\t\tsize--;\n\t\t\tif (!str[i]) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!size && i>1 && str[i-1]) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\t\tgf_free(str);\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->mime_type = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t}\n\t\t}\n\t}\n\t//mett, sbtt, stxt, stpp\n\telse {\n\t\tif (i>1) ptr->mime_type = gf_strdup(str);\n\t}\n\tptr->size = size;\n\tgf_free(str);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err metx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, (u32) strlen(ptr->content_encoding));\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tgf_bs_write_data(bs, ptr->xml_namespace, (u32) strlen(ptr->xml_namespace));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tgf_bs_write_data(bs, ptr->xml_schema_loc, (u32) strlen(ptr->xml_schema_loc));\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err metx_box_size(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* SimpleTextSampleEntry */\nGF_Box *txtc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextConfigBox, GF_ISOM_BOX_TYPE_TXTC);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid txtc_box_del(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->config) gf_free(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err txtc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in txtc box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->config = (char *)gf_malloc(sizeof(char)*((u32) ptr->size+1));\n\tif (!ptr->config) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->config, (u32) ptr->size);\n\tptr->config[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err txtc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->config)\n\t\tgf_bs_write_data(bs, ptr->config, (u32) strlen(ptr->config));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err txtc_box_size(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tif (ptr->config)\n\t\tptr->size += strlen(ptr->config);\n\tptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *dec3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dac3_box_del(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tgf_free(ptr);\n}\n\n\nGF_Err dac3_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\treturn gf_odf_ac3_config_parse_bs(bs, ptr->cfg.is_ec3, &ptr->cfg);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\t\n\treturn gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n}\n\nGF_Err dac3_box_size(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\ts->size += 2;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\ts->size += 3;\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub)\n\t\t\t\ts->size += 1;\n\t\t}\n\t} else {\n\t\ts->size += 3;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid lsrc_box_del(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->hdr) gf_free(ptr->hdr);\n\tgf_free(ptr);\n}\n\n\nGF_Err lsrc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->hdr_size = (u32) ptr->size;\n\tptr->hdr = gf_malloc(sizeof(char)*ptr->hdr_size);\n\tif (!ptr->hdr) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Box *lsrc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASERConfigurationBox, GF_ISOM_BOX_TYPE_LSRC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err lsrc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Err lsrc_box_size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid lsr1_box_del(GF_Box *s)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err lsr1_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_LSRC:\n\t\tBOX_FIELD_ASSIGN(lsr_config, GF_LASERConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tBOX_FIELD_ASSIGN(descr, GF_MPEG4ExtensionDescriptorsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *lsr1_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err lsr1_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->lsr_config, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid sidx_box_del(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->refs) gf_free(ptr->refs);\n\tgf_free(ptr);\n}\n\nGF_Err sidx_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tif (!ptr->refs) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *sidx_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sidx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->reference_ID);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->earliest_presentation_time);\n\t\tgf_bs_write_u32(bs, (u32) ptr->first_offset);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->earliest_presentation_time);\n\t\tgf_bs_write_u64(bs, ptr->first_offset);\n\t}\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_type, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_size, 31);\n\t\tgf_bs_write_u32(bs, ptr->refs[i].subsegment_duration);\n\t\tgf_bs_write_int(bs, ptr->refs[i].starts_with_SAP, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_type, 3);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_delta_time, 28);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sidx_box_size(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->size += 12;\n\tif (ptr->version==0) {\n\t\tptr->size += 8;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size += ptr->nb_refs * 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ssix_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->subsegments) {\n\t\tfor (i = 0; i < ptr->subsegment_alloc; i++) {\n\t\t\tGF_SubsegmentInfo *subsegment = &ptr->subsegments[i];\n\t\t\tif (subsegment->ranges) gf_free(subsegment->ranges);\n\t\t}\n\t\tgf_free(ptr->subsegments);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err ssix_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\t//each subseg has at least one range_count (4 bytes), abort if not enough bytes (broken box)\n\tif (ptr->size / 4 < ptr->subsegment_count || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentInfo))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->subsegment_alloc = ptr->subsegment_count;\n\tGF_SAFE_ALLOC_N(ptr->subsegments, ptr->subsegment_count, GF_SubsegmentInfo);\n\tif (!ptr->subsegments)\n\t    return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_SubsegmentInfo *subseg = &ptr->subsegments[i];\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\t//each range is 4 bytes, abort if not enough bytes\n\t\tif (ptr->size / 4 < subseg->range_count || (u64)subseg->range_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentRangeInfo))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tsubseg->ranges = (GF_SubsegmentRangeInfo*) gf_malloc(sizeof(GF_SubsegmentRangeInfo) * subseg->range_count);\n\t\tif (!subseg->ranges) return GF_OUT_OF_MEM;\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tsubseg->ranges[j].level = gf_bs_read_u8(bs);\n\t\t\tsubseg->ranges[j].range_size = gf_bs_read_u24(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ssix_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ssix_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i = 0; i<ptr->subsegment_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->subsegments[i].range_count);\n\t\tfor (j = 0; j < ptr->subsegments[i].range_count; j++) {\n\t\t\tgf_bs_write_u8(bs, ptr->subsegments[i].ranges[j].level);\n\t\t\tgf_bs_write_u24(bs, ptr->subsegments[i].ranges[j].range_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ssix_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tptr->size += 4;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tptr->size += 4 + 4 * ptr->subsegments[i].range_count;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid leva_box_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}\n\nGF_Err leva_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->level_count = gf_bs_read_u8(bs);\n\t//each level is at least 5 bytes\n\tif (ptr->size / 5 < ptr->level_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment);\n\tif (!ptr->levels) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tGF_LevelAssignment *level = &ptr->levels[i];\n\t\tu8 tmp;\n\t\tif (!level || ptr->size < 5) return GF_BAD_PARAM;\n\t\tISOM_DECREASE_SIZE(ptr, 5)\n\n\t\tlevel->track_id = gf_bs_read_u32(bs);\n\t\ttmp = gf_bs_read_u8(bs);\n\t\tlevel->padding_flag = tmp >> 7;\n\t\tlevel->type = tmp & 0x7F;\n\t\tif (level->type == 0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t\tlevel->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 4) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->sub_track_id = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *leva_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LevelAssignmentBox, GF_ISOM_BOX_TYPE_LEVA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err leva_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->level_count);\n\tfor (i = 0; i<ptr->level_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->levels[i].track_id);\n\t\tgf_bs_write_u8(bs, ptr->levels[i].padding_flag << 7 | (ptr->levels[i].type & 0x7F));\n\t\tif (ptr->levels[i].type == 0) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type_parameter);\n\t\t}\n\t\telse if (ptr->levels[i].type == 4) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].sub_track_id);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err leva_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pcrb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PcrInfoBox, GF_ISOM_BOX_TYPE_PCRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pcrb_box_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}\n\nGF_Err pcrb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\n\tif ((u64)ptr->subsegment_count > ptr->size / 8 || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of subsegment %d in pcrb\\n\", ptr->subsegment_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->pcr_values = gf_malloc(sizeof(u64)*ptr->subsegment_count);\n\tif (!ptr->pcr_values) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->subsegment_count; i++) {\n\t\tu64 data1 = gf_bs_read_u32(bs);\n\t\tu64 data2 = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 6);\n\t\tptr->pcr_values[i] = (data1 << 10) | (data2 >> 6);\n\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pcrb_box_size(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->size += 4;\n\tptr->size += ptr->subsegment_count * 6;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid subs_box_del(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->Samples)) {\n\t\tGF_SubSampleInfoEntry *pSamp;\n\t\tpSamp = (GF_SubSampleInfoEntry*)gf_list_get(ptr->Samples, 0);\n\t\twhile (gf_list_count(pSamp->SubSamples)) {\n\t\t\tGF_SubSampleEntry *pSubSamp;\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, 0);\n\t\t\tgf_free(pSubSamp);\n\t\t\tgf_list_rem(pSamp->SubSamples, 0);\n\t\t}\n\t\tgf_list_del(pSamp->SubSamples);\n\t\tgf_free(pSamp);\n\t\tgf_list_rem(ptr->Samples, 0);\n\t}\n\tgf_list_del(ptr->Samples);\n\tgf_free(ptr);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err subs_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, entry_count;\n\tu16 subsample_count;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_bs_write_u32(bs, entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\tgf_bs_write_u32(bs, pSamp->sample_delta);\n\t\tgf_bs_write_u16(bs, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tif (ptr->version == 1) {\n\t\t\t\tgf_bs_write_u32(bs, pSubSamp->subsample_size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, pSubSamp->subsample_size);\n\t\t\t}\n\t\t\tgf_bs_write_u8(bs, pSubSamp->subsample_priority);\n\t\t\tgf_bs_write_u8(bs, pSubSamp->discardable);\n\t\t\tgf_bs_write_u32(bs, pSubSamp->reserved);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Err subs_box_size(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\tu32 entry_count, i;\n\tu16 subsample_count;\n\n\t// add 4 byte for entry_count\n\tptr->size += 4;\n\tentry_count = gf_list_count(ptr->Samples);\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\t// 4 byte for sample_delta, 2 byte for subsample_count\n\t\t// and 6 + (4 or 2) bytes for each subsample\n\t\tptr->size += 4 + 2 + subsample_count * (6 + (ptr->version==1 ? 4 : 2));\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err subs_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tentry_count = gf_bs_read_u32(bs);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tu32 subs_size=0;\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_malloc(sizeof(GF_SubSampleInfoEntry));\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\n\t\tmemset(pSamp, 0, sizeof(GF_SubSampleInfoEntry));\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tpSamp->sample_delta = gf_bs_read_u32(bs);\n\t\tsubsample_count = gf_bs_read_u16(bs);\n\t\tsubs_size=6;\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_malloc(sizeof(GF_SubSampleEntry));\n\t\t\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\n\t\t\tmemset(pSubSamp, 0, sizeof(GF_SubSampleEntry));\n\t\t\tif (ptr->version==1) {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u32(bs);\n\t\t\t\tsubs_size+=4;\n\t\t\t} else {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u16(bs);\n\t\t\t\tsubs_size+=2;\n\t\t\t}\n\t\t\tpSubSamp->subsample_priority = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->discardable = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->reserved = gf_bs_read_u32(bs);\n\t\t\tsubs_size+=6;\n\n\t\t\tgf_list_add(pSamp->SubSamples, pSubSamp);\n\t\t}\n\t\tgf_list_add(ptr->Samples, pSamp);\n\t\tISOM_DECREASE_SIZE(ptr, subs_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Box *tfdt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfdt_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfdt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u64(bs, ptr->baseMediaDecodeTime);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->baseMediaDecodeTime);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfdt_box_size(GF_Box *s)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (!ptr->version && (ptr->baseMediaDecodeTime<=0xFFFFFFFF)) {\n\t\t//ptr->version = 0;\n\t\tptr->size += 4;\n\t} else {\n\t\tptr->version = 1;\n\t\tptr->size += 8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Box *rvcc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RVCConfigurationBox, GF_ISOM_BOX_TYPE_RVCC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid rvcc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err rvcc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->predefined_rvc_config = gf_bs_read_u16(bs);\n\tif (!ptr->predefined_rvc_config) {\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->rvc_meta_idx = gf_bs_read_u16(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err rvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->predefined_rvc_config);\n\tif (!ptr->predefined_rvc_config) {\n\t\tgf_bs_write_u16(bs, ptr->rvc_meta_idx);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rvcc_box_size(GF_Box *s)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox *)s;\n\tptr->size += 2;\n\tif (! ptr->predefined_rvc_config) ptr->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *sbgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupBox, GF_ISOM_BOX_TYPE_SBGP);\n\treturn (GF_Box *)tmp;\n}\nvoid sbgp_box_del(GF_Box *a)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox *)a;\n\tif (p->sample_entries) gf_free(p->sample_entries);\n\tgf_free(p);\n}\n\nGF_Err sbgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(GF_SampleGroupEntry)*ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_SampleGroupEntry))\n\t    return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sbgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version==1)\n\t\tgf_bs_write_u32(bs, p->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, p->entry_count);\n\tfor (i = 0; i<p->entry_count; i++ ) {\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].sample_count);\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].group_description_index);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sbgp_box_size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}\n\nvoid sgpd_del_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_free(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tif (seig->key_info) gf_free(seig->key_info);\n\t\tgf_free(entry);\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tif (spor->subp_track_ref_idx) gf_free(spor->subp_track_ref_idx);\n\t\tgf_free(spor);\n\t}\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tif (sulm->groupIDs) gf_free(sulm->groupIDs);\n\t\tgf_free(sulm);\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->data) gf_free(ptr->data);\n\t\tgf_free(ptr);\n\t}\n\t}\n}\n\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tgf_bs_write_int(bs, ((GF_RollRecoveryEntry*)entry)->roll_distance, 16);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->dependent_flag, 1);\n\t\tgf_bs_write_int(bs, 0, 3);\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->SAP_type, 4);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tgf_bs_write_int(bs, ((GF_SYNCEntry*)entry)->NALU_type, 6);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tgf_bs_write_int(bs, ((GF_TemporalLevelEntry*)entry)->level_independently_decodable, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0];\n\t\tu32 nb_keys = 1;\n\t\tif (use_mkey) {\n\t\t\tnb_keys = seig->key_info[1];\n\t\t\tnb_keys<<=8;\n\t\t\tnb_keys |= seig->key_info[2];\n\t\t}\n\t\tgf_bs_write_int(bs, use_mkey ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, seig->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, seig->skip_byte_block, 4);\n\t\tgf_bs_write_u8(bs, seig->IsProtected);\n\t\tif (nb_keys>1) {\n\t\t\tgf_bs_write_data(bs, seig->key_info+1, seig->key_info_size-1);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, seig->key_info+3, seig->key_info_size - 3);\n\t\t}\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_write_entry(entry, bs);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_write_entry(entry, bs);\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *) entry;\n\t\tgf_bs_write_int(bs, spor->subpic_id_info_flag, 1);\n\t\tgf_bs_write_int(bs, spor->num_subpic_ref_idx, 15);\n\t\tfor (i=0; i<spor->num_subpic_ref_idx; i++) {\n\t\t\tgf_bs_write_u16(bs, spor->subp_track_ref_idx[i]);\n\t\t}\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_len_minus1, 4);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_bit_pos, 12);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.start_code_emul_flag, 1);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.pps_sps_subpic_id_flag, 1);\n\t\t\tif (spor->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 6);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 4);\n\t\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tgf_bs_write_u32(bs, sulm->groupID_info_4cc);\n\t\tgf_bs_write_u16(bs, sulm->nb_entries - 1);\n\t\tfor (i=0; i<sulm->nb_entries; i++) {\n\t\t\tgf_bs_write_u16(bs, sulm->groupIDs[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->length)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->data, ptr->length);\n\t}\n\t}\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 sgpd_size_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\treturn 1;\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\treturn 20;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\treturn 0;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0] ? GF_TRUE : GF_FALSE;\n\t\tif (use_mkey) {\n\t\t\treturn 3 + seig->key_info_size-1;\n\t\t}\n\t\treturn seig->key_info_size; //== 3 + (seig->key_info_size-3);\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\treturn gf_isom_oinf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn gf_isom_linf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tu32 s = 2 + 2*spor->num_subpic_ref_idx;\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\ts += 3;\n\t\t}\n\t\treturn s;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\treturn 6 + 2*sulm->nb_entries;\n\t}\n\n\tdefault:\n\t\treturn ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;\n\t}\n}\n#endif\n\nGF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\t/*version 0 is deprecated, use v1 by default*/\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid sgpd_box_del(GF_Box *a)\n{\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)a;\n\twhile (gf_list_count(p->group_descriptions)) {\n\t\tvoid *ptr = gf_list_last(p->group_descriptions);\n\t\tsgpd_del_entry(p->grouping_type, ptr);\n\t\tgf_list_rem_last(p->group_descriptions);\n\t}\n\tgf_list_del(p->group_descriptions);\n\tgf_free(p);\n}\n\nGF_Err sgpd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\tp->grouping_type = gf_bs_read_u32(bs);\n\n\tif (p->version>=1) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t}\n\tif (p->version>=2) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p->grouping_type, bs, (s32) p->size, size, &parsed_bytes);\n\t\t//don't return an error, just stop parsing so that we skip over the sgpd box\n\t\tif (!ptr) return GF_OK;\n\t\tgf_list_add(p->group_descriptions, ptr);\n\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sgpd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, nb_descs;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tGF_Err e;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version>=1) gf_bs_write_u32(bs, p->default_length);\n\tif (p->version>=2) gf_bs_write_u32(bs, p->default_description_index);\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tgf_bs_write_u32(bs, nb_descs);\n\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tif ((p->version >= 1) && !p->default_length) {\n\t\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\t\tgf_bs_write_u32(bs, size);\n\t\t}\n\t\tsgpd_write_entry(p->grouping_type, ptr, bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sgpd_box_size(GF_Box *s)\n{\n\tu32 i, nb_descs;\n\tBool use_def_size = GF_TRUE;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->size += 8;\n\n\t//we force all sample groups to version 1, v0 being deprecated\n\tif (!p->version)\n\t\tp->version = 1;\n\tp->size += 4;\n\n\tif (p->version>=2)\n\t\tp->size += 4;\n\tp->default_length = 0;\n\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (use_def_size && !p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tuse_def_size = GF_FALSE;\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += nb_descs * 4;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid saiz_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info_size) gf_free(ptr->sample_info_size);\n\tgf_free(ptr);\n}\n\n\nGF_Err saiz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->default_sample_info_size = gf_bs_read_u8(bs);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\tif (ptr->default_sample_info_size == 0) {\n\t\tif (ptr->size < ptr->sample_count)\n\t\t    return GF_ISOM_INVALID_FILE;\n\n\t\tptr->sample_info_size = gf_malloc(sizeof(u8)*ptr->sample_count);\n\t\tptr->sample_alloc = ptr->sample_count;\n\t\tif (!ptr->sample_info_size)\n\t\t    return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count);\n\t\tgf_bs_read_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saiz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoSizeBox, GF_ISOM_BOX_TYPE_SAIZ);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saiz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\tgf_bs_write_u8(bs, ptr->default_sample_info_size);\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\tif (!ptr->default_sample_info_size) {\n\t\tif (!ptr->sample_info_size)\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\telse\n\t\t\tgf_bs_write_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saiz_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nvoid saio_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tif (ptr->cached_data) gf_free(ptr->cached_data);\n\tgf_free(ptr);\n}\n\n\nGF_Err saio_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->size / (ptr->version == 0 ? 4 : 8) < ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(u64))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->offsets = gf_malloc(sizeof(u64)*ptr->entry_count);\n\t\tif (!ptr->offsets)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tptr->entry_alloc = ptr->entry_count;\n\t\tif (ptr->version==0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u32(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saio_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoOffsetBox, GF_ISOM_BOX_TYPE_SAIO);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saio_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\t//store position in bitstream before writing data - offsets can be NULL if a single offset is rewritten later on (cf senc_box_write)\n\t\tptr->offset_first_offset_field = gf_bs_get_position(bs);\n\t\tif (ptr->version==0) {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->offsets[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saio_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 4;\n\t//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed\n\tswitch (ptr->aux_info_type) {\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\t\tif (ptr->offsets) gf_free(ptr->offsets);\n\t\tptr->offsets = NULL;\n\t\tptr->entry_alloc = 0;\n\t\tptr->entry_count = 1;\n\t\tbreak;\n\t}\n\n\tptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nvoid prft_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err prft_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tptr->refTrackID = gf_bs_read_u32(bs);\n\tptr->ntp = gf_bs_read_u64(bs);\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->timestamp = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->timestamp = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err prft_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->refTrackID);\n\tgf_bs_write_u64(bs, ptr->ntp);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->timestamp);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->timestamp);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err prft_box_size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *trgr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgr_box_del(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->groups);\n\tgf_free(ptr);\n}\n\n\nGF_Err trgr_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tBOX_FIELD_LIST_ASSIGN(groups)\n\treturn gf_list_add(ptr->groups, a);\n}\n\n\nGF_Err trgr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trgr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trgr_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s;\n\tgf_isom_check_position_list(s, ptr->groups, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *trgt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgt_box_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err trgt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}\n\nGF_Err trgt_box_size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tptr->size+= 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *stvi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_StereoVideoBox, GF_ISOM_BOX_TYPE_STVI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid stvi_box_del(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->stereo_indication_type) gf_free(ptr->stereo_indication_type);\n\tgf_free(ptr);\n}\n\nGF_Err stvi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tif (!ptr->stereo_indication_type) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stvi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 30);\n\tgf_bs_write_int(bs, ptr->single_view_allowed, 2);\n\tgf_bs_write_u32(bs, ptr->stereo_scheme);\n\tgf_bs_write_u32(bs, ptr->sit_len);\n\tgf_bs_write_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\n\treturn GF_OK;\n}\n\nGF_Err stvi_box_size(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tptr->size+= 12 + ptr->sit_len;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fiin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err fiin_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tBOX_FIELD_LIST_ASSIGN(partition_entries)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tBOX_FIELD_ASSIGN(session_info, FDSessionGroupBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tBOX_FIELD_ASSIGN(group_id_to_name, GroupIdToNameBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\ts->size+= 2;\n\tgf_isom_check_position_list(s, ptr->partition_entries, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *paen_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid paen_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err paen_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FPAR:\n\t\tBOX_FIELD_ASSIGN(blocks_and_symbols, FilePartitionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FECR:\n\t\tBOX_FIELD_ASSIGN(FEC_symbol_locations, FECReservoirBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FIRE:\n\t\tBOX_FIELD_ASSIGN(File_symbol_locations, FileReservoirBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err paen_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *fpar_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FilePartitionBox, GF_ISOM_BOX_TYPE_FPAR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fpar_box_del(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_specific_info) gf_free(ptr->scheme_specific_info);\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str)\n{\n\tu32 len=10;\n\tu32 i=0;\n\n\t*out_str = gf_malloc(sizeof(char)*len);\n\tif (! *out_str) return GF_OUT_OF_MEM;\n\n\tif (!s->size) {\n\t\t*out_str[0] = 0;\n\t\treturn GF_OK;\n\t}\n\n\twhile (1) {\n\t\tISOM_DECREASE_SIZE(s, 1 );\n\t\t(*out_str)[i] = gf_bs_read_u8(bs);\n\t\tif (!(*out_str)[i]) break;\n\t\ti++;\n\t\tif (i==len) {\n\t\t\tlen += 10;\n\t\t\t*out_str = gf_realloc(*out_str, sizeof(char)*len);\n\t\t}\n\t\tif (gf_bs_available(bs) == 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] missing null character in null terminated string\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (i >= size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] string bigger than container, probably missing null character\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, ((ptr->version ? 4 : 2) + 12) );\n\tptr->itemID = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tptr->packet_payload_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->FEC_encoding_ID = gf_bs_read_u8(bs);\n\tptr->FEC_instance_ID = gf_bs_read_u16(bs);\n\tptr->max_source_block_length = gf_bs_read_u16(bs);\n\tptr->encoding_symbol_length = gf_bs_read_u16(bs);\n\tptr->max_number_of_encoding_symbols = gf_bs_read_u16(bs);\n\n\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_specific_info);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tif (ptr->nb_entries > ptr->size / 6 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FilePartitionEntry))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * 6 );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FilePartitionEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tptr->entries[i].block_size = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fpar_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->itemID, ptr->version ? 32 : 16);\n\tgf_bs_write_u16(bs, ptr->packet_payload_size);\n\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->FEC_encoding_ID);\n\tgf_bs_write_u16(bs, ptr->FEC_instance_ID);\n\tgf_bs_write_u16(bs, ptr->max_source_block_length);\n\tgf_bs_write_u16(bs, ptr->encoding_symbol_length);\n\tgf_bs_write_u16(bs, ptr->max_number_of_encoding_symbols);\n\tif (ptr->scheme_specific_info) {\n\t\tgf_bs_write_data(bs, ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\t}\n\t//null terminated string\n\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->entries[i].block_count);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].block_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_size(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tptr->size += 13 + (ptr->version ? 8 : 4);\n\tif (ptr->scheme_specific_info)\n\t\tptr->size += strlen(ptr->scheme_specific_info);\n\n\tptr->size+= ptr->nb_entries * 6;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *fecr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FECReservoirBox, GF_ISOM_BOX_TYPE_FECR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fecr_box_del(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err fecr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\n\tif (ptr->nb_entries > ptr->size / (ptr->version ? 8 : 6) || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FECReservoirEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fecr\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\t\tptr->entries[i].symbol_count = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fecr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].item_id, ptr->version ? 32 : 16);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].symbol_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fecr_box_size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *segr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid segr_box_del(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tif (ptr->session_groups[i].group_ids) gf_free(ptr->session_groups[i].group_ids);\n\t\tif (ptr->session_groups[i].channels) gf_free(ptr->session_groups[i].channels);\n\t}\n\tif (ptr->session_groups) gf_free(ptr->session_groups);\n\tgf_free(ptr);\n}\n\nGF_Err segr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->num_session_groups = gf_bs_read_u16(bs);\n\tif (ptr->size < ptr->num_session_groups) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in segr\\n\", ptr->num_session_groups));\n\t\tptr->num_session_groups = 0;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->session_groups, ptr->num_session_groups, SessionGroupEntry);\n\tif (!ptr->session_groups) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->session_groups[i].nb_groups = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_groups*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].group_ids, ptr->session_groups[i].nb_groups, u32);\n\t\tif (!ptr->session_groups[i].group_ids) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tptr->session_groups[i].group_ids[k] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tptr->session_groups[i].nb_channels = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_channels*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].channels, ptr->session_groups[i].nb_channels, u32);\n\t\tif (!ptr->session_groups[i].channels) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tptr->session_groups[i].channels[k] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err segr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tGF_Err e;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->num_session_groups);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tgf_bs_write_u8(bs, ptr->session_groups[i].nb_groups);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].group_ids[k]);\n\t\t}\n\n\t\tgf_bs_write_u16(bs, ptr->session_groups[i].nb_channels);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].channels[k]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err segr_box_size(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->size += 1 + 4*ptr->session_groups[i].nb_groups;\n\t\tptr->size += 2 + 4*ptr->session_groups[i].nb_channels;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *gitn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GroupIdToNameBox, GF_ISOM_BOX_TYPE_GITN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err gitn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 4 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, GroupIdNameEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->entries[i].group_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->entries[i].name);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gitn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Box *fdpa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FDpacketBox, GF_ISOM_BOX_TYPE_FDPA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fdpa_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->headers) {\n\t\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\t\tif (ptr->headers[i].data) gf_free(ptr->headers[i].data);\n\t\t}\n\t\tgf_free(ptr->headers);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err fdpa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->info.sender_current_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.expected_residual_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.session_close_bit = gf_bs_read_int(bs, 1);\n\tptr->info.object_close_bit = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->header_ext_count = gf_bs_read_u16(bs);\n\tif (ptr->size / 2 < ptr->header_ext_count) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fdpa\\n\", ptr->header_ext_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->headers, ptr->header_ext_count, GF_LCTheaderExtension);\n\tif (!ptr->headers) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->headers[i].header_extension_type = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\t\tgf_bs_read_data(bs, (char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\t\tptr->headers[i].data_length = gf_bs_read_u8(bs);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tptr->headers[i].data_length = 4*ptr->headers[i].data_length - 2;\n\t\t\t\tif (ptr->size < sizeof(char) * ptr->headers[i].data_length)\n\t\t\t\t    return GF_ISOM_INVALID_FILE;\n\t\t\t\tptr->headers[i].data = gf_malloc(sizeof(char) * ptr->headers[i].data_length);\n\t\t\t\tif (!ptr->headers[i].data) return GF_OUT_OF_MEM;\n\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->headers[i].data_length);\n\t\t\t\tgf_bs_read_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdpa_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tptr->size += 5;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->size += 1;\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tptr->size += 3;\n\t\t} else {\n\t\t\tptr->size += 1 + ptr->headers[i].data_length;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *extr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid extr_box_del(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err extr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (!ptr->feci || ptr->feci->size > ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err extr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->feci) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->feci, bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err extr_box_size(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tptr->size += ptr->data_length;\n\tif (ptr->feci) {\n\t\tGF_Err e = gf_isom_box_size((GF_Box*)ptr->feci);\n\t\tif (e) return e;\n\t\tptr->size += ptr->feci->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fdsa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintSample, GF_ISOM_BOX_TYPE_FDSA);\n\tif (!tmp) return NULL;\n\ttmp->packetTable = gf_list_new();\n\ttmp->hint_subtype = GF_ISOM_BOX_TYPE_FDP_STSD;\n\treturn (GF_Box*)tmp;\n}\n\nvoid fdsa_box_del(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tgf_list_del(ptr->packetTable);\n\tgf_free(ptr);\n}\n\nGF_Err fdsa_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tBOX_FIELD_LIST_ASSIGN(packetTable)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tBOX_FIELD_ASSIGN(extra_data, GF_ExtraDataBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err fdsa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdsa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdsa_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\nvoid trik_box_del(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err trik_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tif ((u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_TrickPlayBoxEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in trik\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trik_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrickPlayBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trik_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i < ptr->entry_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].pic_type, 2);\n\t\tgf_bs_write_int(bs, ptr->entries[i].dependency_level, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trik_box_size(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->size += 8 * ptr->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid bloc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err bloc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->baseLocation, 256);\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->basePurlLocation, 256);\n\tISOM_DECREASE_SIZE(s, 512)\n\tgf_bs_skip_bytes(bs, 512);\n\treturn GF_OK;\n}\n\nGF_Box *bloc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err bloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err bloc_box_size(GF_Box *s)\n{\n\ts->size += 1024;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ainf_box_del(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tif (ptr->APID) gf_free(ptr->APID);\n\tgf_free(s);\n}\n\nGF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}\n\nGF_Box *ainf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AssetInformationBox, GF_ISOM_BOX_TYPE_AINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ainf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->profile_version);\n    if (ptr->APID)\n        gf_bs_write_data(bs, ptr->APID, (u32) strlen(ptr->APID) );\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err ainf_box_size(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n    s->size += 4 + (ptr->APID ? strlen(ptr->APID) : 0 ) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mhac_box_del(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\tif (ptr->mha_config) gf_free(ptr->mha_config);\n\tgf_free(s);\n}\n\nGF_Err mhac_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->configuration_version = gf_bs_read_u8(bs);\n\tptr->mha_pl_indication = gf_bs_read_u8(bs);\n\tptr->reference_channel_layout = gf_bs_read_u8(bs);\n\tptr->mha_config_size = gf_bs_read_u16(bs);\n\tif (ptr->mha_config_size) {\n\t\tISOM_DECREASE_SIZE(s, ptr->mha_config_size)\n\n\t\tptr->mha_config = gf_malloc(sizeof(char)*ptr->mha_config_size);\n\t\tif (!ptr->mha_config) return GF_OUT_OF_MEM;\n\n\t\tgf_bs_read_data(bs, ptr->mha_config, ptr->mha_config_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhac_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHAConfigBox, GF_ISOM_BOX_TYPE_MHAC);\n\ttmp->configuration_version = 1;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhac_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->configuration_version);\n\tgf_bs_write_u8(bs, ptr->mha_pl_indication);\n\tgf_bs_write_u8(bs, ptr->reference_channel_layout);\n\tgf_bs_write_u16(bs, ptr->mha_config ? ptr->mha_config_size : 0);\n\tif (ptr->mha_config && ptr->mha_config_size)\n\t\tgf_bs_write_data(bs, ptr->mha_config, ptr->mha_config_size);\n\n\treturn GF_OK;\n}\n\nGF_Err mhac_box_size(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\ts->size += 5;\n\tif (ptr->mha_config_size && ptr->mha_config) s->size += ptr->mha_config_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mhap_box_del(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\tif (ptr->compat_profiles) gf_free(ptr->compat_profiles);\n\tgf_free(s);\n}\n\nGF_Err mhap_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->num_profiles = gf_bs_read_u8(bs);\n\tif (!ptr->num_profiles) return GF_OK;\n\n\tISOM_DECREASE_SIZE(s, ptr->num_profiles)\n\tptr->compat_profiles = gf_malloc(sizeof(u8) * ptr->num_profiles);\n\tif (!ptr->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tptr->compat_profiles[i] = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHACompatibleProfilesBox, GF_ISOM_BOX_TYPE_MHAP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->num_profiles);\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tgf_bs_write_u8(bs, ptr->compat_profiles[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mhap_box_size(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\ts->size += 1 + ptr->num_profiles;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid jp2h_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err jp2h_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_J2KHeaderBox *ptr = (GF_J2KHeaderBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_IHDR:\n\t\tBOX_FIELD_ASSIGN(ihdr, GF_J2KImageHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\t\tBOX_FIELD_ASSIGN(colr, GF_ColourInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, s->type);\n}\n\nGF_Box *jp2h_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KHeaderBox, GF_ISOM_BOX_TYPE_JP2H);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err jp2h_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err jp2h_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid ihdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err ihdr_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 14)\n\n\tptr->height = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->nb_comp = gf_bs_read_u16(bs);\n\tptr->bpc = gf_bs_read_u8(bs);\n\tptr->Comp = gf_bs_read_u8(bs);\n\tptr->UnkC = gf_bs_read_u8(bs);\n\tptr->IPR = gf_bs_read_u8(bs);\n\n\treturn GF_OK;\n}\n\nGF_Box *ihdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KImageHeaderBox, GF_ISOM_BOX_TYPE_IHDR);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ihdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->height);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u16(bs, ptr->nb_comp);\n\tgf_bs_write_u8(bs, ptr->bpc);\n\tgf_bs_write_u8(bs, ptr->Comp);\n\tgf_bs_write_u8(bs, ptr->UnkC);\n\tgf_bs_write_u8(bs, ptr->IPR);\n\treturn GF_OK;\n}\n\nGF_Err ihdr_box_size(GF_Box *s)\n{\n\ts->size += 14;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* Dolby Vision */\n\nGF_Box *dvcC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVCC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvcC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvcC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tISOM_DECREASE_SIZE(ptr, 24)\n\tptr->DOVIConfig.dv_version_major = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_version_minor = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_profile = gf_bs_read_int(bs, 7);\n\tptr->DOVIConfig.dv_level = gf_bs_read_int(bs, 6);\n\tptr->DOVIConfig.rpu_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.el_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.bl_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.dv_bl_signal_compatibility_id = gf_bs_read_int(bs, 4);\n\tif (gf_bs_read_int(bs, 28) != 0)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (gf_bs_read_u32(bs) != 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\t\t}\n\t}\n\tif (ptr->DOVIConfig.dv_profile==8) {\n\t\tif (!ptr->DOVIConfig.dv_bl_signal_compatibility_id || (ptr->DOVIConfig.dv_bl_signal_compatibility_id>2) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC profile 8 but compatibility ID %d is not 1 or 2, patching to 2\\n\", ptr->DOVIConfig.dv_bl_signal_compatibility_id));\n\t\t\tptr->DOVIConfig.dv_bl_signal_compatibility_id = 2;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvcC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_major);\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_minor);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_profile, 7);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_level, 6);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.rpu_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.el_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.bl_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_bl_signal_compatibility_id, 4);\n\tgf_bs_write_int(bs, 0, 28);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\n\treturn GF_OK;\n}\n\nGF_Err dvcC_box_size(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\tptr->size += 24;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dvvC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVVC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvvC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvvC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvvC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_write(s, bs);\n}\n\nGF_Err dvvC_box_size(GF_Box *s)\n{\n\treturn dvcC_box_size(s);\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dOps_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OpusSpecificBox, GF_ISOM_BOX_TYPE_DOPS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dOps_box_del(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (ptr) gf_free(ptr);\n}\n\nGF_Err dOps_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->OutputChannelCount = gf_bs_read_u8(bs);\n\tptr->PreSkip = gf_bs_read_u16(bs);\n\tptr->InputSampleRate = gf_bs_read_u32(bs);\n\tptr->OutputGain = gf_bs_read_u16(bs);\n\tptr->ChannelMappingFamily = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 11)\n\tif (ptr->size) {\n\t\tISOM_DECREASE_SIZE(ptr, 2+ptr->OutputChannelCount);\n\t\tptr->StreamCount = gf_bs_read_u8(bs);\n\t\tptr->CoupledCount = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->ChannelMapping, ptr->OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u8(bs, ptr->OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->PreSkip);\n\tgf_bs_write_u32(bs, ptr->InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->OutputGain);\n\tgf_bs_write_u8(bs, ptr->ChannelMappingFamily);\n\tif (ptr->ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->ChannelMapping, ptr->OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dOps_box_size(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->size += 11;\n\tif (ptr->ChannelMappingFamily)\n\t\tptr->size += 2 + ptr->OutputChannelCount;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dfla_box_del(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *dfla_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FLACConfigBox, GF_ISOM_BOX_TYPE_DFLA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dfla_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Err dfla_box_size(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mvcg_box_del(GF_Box *s)\n{\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err mvcg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tISOM_DECREASE_SIZE(s, 7)\n\tptr->multiview_group_id = gf_bs_read_u32(bs);\n\tptr->num_entries = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->entries = gf_malloc(ptr->num_entries * sizeof(MVCIEntry));\n\tmemset(ptr->entries, 0, ptr->num_entries * sizeof(MVCIEntry));\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->entries[i].entry_type = gf_bs_read_u8(bs);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tISOM_DECREASE_SIZE(s, 6)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tptr->entries[i].tierID = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tptr->entries[i].output_view_id = gf_bs_read_int(bs, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tgf_bs_read_int(bs, 6)\t;\n\t\t\tptr->entries[i].start_view_id = gf_bs_read_int(bs, 10);\n\t\t\tptr->entries[i].view_count = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvcg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MultiviewGroupBox, GF_ISOM_BOX_TYPE_MVCG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvcg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\n\tgf_bs_write_u32(bs, ptr->multiview_group_id);\n\tgf_bs_write_u16(bs, ptr->num_entries);\n\tgf_bs_write_u8(bs, 0);\n\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tgf_bs_write_u8(bs, ptr->entries[i].entry_type);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].tierID);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgf_bs_write_int(bs, 0, 6);\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].output_view_id, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgf_bs_write_int(bs, 0, 6)\t;\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].start_view_id, 10);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].view_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vwid_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tif (ptr->views) {\n\t\tfor (i=0; i<ptr->num_views; i++) {\n\t\t\tif (ptr->views[i].view_refs)\n\t\t\t\tgf_free(ptr->views[i].view_refs);\n\t\t}\n\t\tgf_free(ptr->views);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (ptr->num_views > ptr->size / 6)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tmemset(ptr->views, 0, sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\n\t\tif (ptr->views[i].num_ref_views > ptr->size / 2)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vwid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tgf_bs_write_int(bs, ptr->min_temporal_id, 3);\n\tgf_bs_write_int(bs, ptr->max_temporal_id, 3);\n\tgf_bs_write_u16(bs, ptr->num_views);\n\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_id, 10);\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_order_index, 10);\n\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].base_view_type, 2);\n\t\tgf_bs_write_int(bs, ptr->views[i].num_ref_views, 10);\n\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].dep_comp_idc, 2);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].ref_view_id, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err vwid_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tptr->size += 3;\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tptr->size += 6 + 2 * ptr->views[i].num_ref_views;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid pcmC_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err pcmC_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 2)\n\tptr->format_flags = gf_bs_read_u8(bs);\n\tptr->PCM_sample_size = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\nGF_Box *pcmC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PCMConfigBox, GF_ISOM_BOX_TYPE_PCMC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}\n\nGF_Err pcmC_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid chnl_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *chnl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChannelLayoutBox, GF_ISOM_BOX_TYPE_CHNL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}\n\nvoid emsg_box_del(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_id_uri) gf_free(ptr->scheme_id_uri);\n\tif (ptr->value) gf_free(ptr->value);\n\tif (ptr->message_data) gf_free(ptr->message_data);\n\tgf_free(ptr);\n}\n\nGF_Err emsg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version==0) {\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u32(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\t} else if (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u64(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tif (ptr->size) {\n\t\tif (ptr->size>0xFFFFFFFUL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] emsg message data size too big (\"LLU\") to be loaded\\n\", ptr->size));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tptr->message_data_size = (u32) ptr->size;\n\t\tptr->message_data = gf_malloc(ptr->message_data_size);\n\t\tif (!ptr->message_data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->message_data, ptr->message_data_size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err emsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u64(bs, ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\n\tlen = ptr->scheme_id_uri ? (u32) strlen(ptr->scheme_id_uri) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->scheme_id_uri, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tlen = ptr->value ? (u32) strlen(ptr->value) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->value, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\tif (ptr->message_data)\n\t\tgf_bs_write_data(bs, ptr->message_data, ptr->message_data_size);\n\treturn GF_OK;\n}\n\nGF_Err emsg_box_size(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tptr->size += 4;\n\tif (ptr->version) {\n\t\tptr->size += 20;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size+=2; //1 NULL-terminated strings\n\tif (ptr->scheme_id_uri) ptr->size += strlen(ptr->scheme_id_uri);\n\tif (ptr->value) ptr->size += strlen(ptr->value);\n\tif (ptr->message_data)\n\t\tptr->size += ptr->message_data_size;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n\n\nGF_Box *csgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompactSampleGroupBox, GF_ISOM_BOX_TYPE_CSGP);\n\treturn (GF_Box *)tmp;\n}\nvoid csgp_box_del(GF_Box *a)\n{\n\tGF_CompactSampleGroupBox *p = (GF_CompactSampleGroupBox *)a;\n\tif (p->patterns) {\n\t\tu32 i;\n\t\tfor (i=0; i<p->pattern_count; i++) {\n\t\t\tgf_free(p->patterns[i].sample_group_description_indices);\n\t\t}\n\t\tgf_free(p->patterns);\n\t}\n\tgf_free(p);\n}\n\nu32 get_size_by_code(u32 code)\n{\n\tif (code==0) return 4;\n\tif (code==1) return 8;\n\tif (code==2) return 16;\n\treturn 32;\n}\nGF_Err csgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, bits, gidx_mask;\n\tBool index_msb_indicates_fragment_local_description, grouping_type_parameter_present;\n\tu32 pattern_size, scount_size, index_size;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tindex_msb_indicates_fragment_local_description = (ptr->flags & (1<<7)) ? GF_TRUE : GF_FALSE;\n\tgrouping_type_parameter_present = (ptr->flags & (1<<6)) ? GF_TRUE : GF_FALSE;\n\n\tpattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tscount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tindex_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tif (((pattern_size==4) && (scount_size!=4)) || ((pattern_size!=4) && (scount_size==4))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample gorup pattern_size and sample_count_size mare not both 4 bits\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tif (grouping_type_parameter_present) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->pattern_count = gf_bs_read_u32(bs);\n\n\n\tif ( (ptr->size / ( (pattern_size + scount_size) / 8 ) < ptr->pattern_count) || (u64)ptr->pattern_count > (u64)SIZE_MAX/sizeof(GF_CompactSampleGroupPattern) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample gorup pattern_count value (%lu) invalid\\n\", ptr->pattern_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->patterns = gf_malloc(sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\tif (!ptr->patterns) return GF_OUT_OF_MEM;\n\n\tbits = 0;\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tptr->patterns[i].length = gf_bs_read_int(bs, pattern_size);\n\t\tptr->patterns[i].sample_count = gf_bs_read_int(bs, scount_size);\n\t\tbits += pattern_size + scount_size;\n\t\tif (! (bits % 8)) {\n\t\t\tbits/=8;\n\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\tbits=0;\n\t\t}\n\t\tif ( (u64)ptr->patterns[i].length > (u64)SIZE_MAX/sizeof(u32) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample gorup pattern #%d value (%lu) invalid\\n\", i, ptr->patterns[i].length));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->patterns[i].sample_group_description_indices = gf_malloc(sizeof(u32) * ptr->patterns[i].length);\n\t\tif (!ptr->patterns[i].sample_group_description_indices) return GF_OUT_OF_MEM;\n\t}\n\tbits = 0;\n\tgidx_mask = ((u32)1) << (index_size-1);\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = gf_bs_read_int(bs, index_size);\n\t\t\tif (index_msb_indicates_fragment_local_description) {\n\t\t\t\t//MSB set, this is a index of a group described in the fragment\n\t\t\t\tif (idx & gidx_mask) {\n\t\t\t\t\tidx += 0x10000;\n\t\t\t\t\tidx &= ~gidx_mask;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->patterns[i].sample_group_description_indices[j] = idx;\n\t\t\tbits += index_size;\n\n\t\t\tif (! (bits % 8)) {\n\t\t\t\tbits/=8;\n\t\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\t\tbits=0;\n\t\t\t}\n\t\t}\n\t}\n\tif (bits)\n\t\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err csgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_int(bs, ptr->flags, 24);\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\n\tif (ptr->flags & (1<<6))\n\t\tgf_bs_write_u32(bs, ptr->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, ptr->pattern_count);\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->patterns[i].length, pattern_size);\n\t\tgf_bs_write_int(bs, ptr->patterns[i].sample_count, scount_size);\n\t}\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = ptr->patterns[i].sample_group_description_indices[j];\n\t\t\tif (idx > 0x10000) {\n\t\t\t\tidx -= 0x10000;\n\t\t\t\tgf_bs_write_int(bs, 1, 1);\n\t\t\t\tgf_bs_write_int(bs, idx, index_size-1);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, idx, index_size);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\nGF_Err csgp_box_size(GF_Box *s)\n{\n\tu32 i, bits;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tptr->size += 12; //v, flags , grouping_type, pattern_length\n\tif (ptr->flags & (1<<6))\n\t\tptr->size+=4;\n\n\tptr->size += ptr->pattern_count * (pattern_size + scount_size) / 8;\n\tbits=0;\n\tfor (i=0; i<ptr->pattern_count; i++)\n\t\tbits += ptr->patterns[i].length * index_size;\n\tptr->size += bits/8;\n\tif (bits % 8) ptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dmlp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrueHDConfigBox, GF_ISOM_BOX_TYPE_DMLP);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dmlp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dmlp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 10)\n\tptr->format_info = gf_bs_read_u32(bs);\n\tptr->peak_data_rate = gf_bs_read_int(bs, 15);\n\tgf_bs_read_int(bs, 1);\n\tgf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dmlp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->format_info);\n\tgf_bs_write_int(bs, ptr->peak_data_rate, 15);\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err dmlp_box_size(GF_Box *s)\n{\n\ts->size += 10;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *xtra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_XtraBox, GF_ISOM_BOX_TYPE_XTRA);\n\ttmp->tags = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid xtra_box_del(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (gf_list_count(ptr->tags)) {\n\t\tGF_XtraTag *tag = gf_list_pop_back(ptr->tags);\n\t\tif (tag->name) gf_free(tag->name);\n\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\tgf_free(tag);\n\t}\n\tgf_list_del(ptr->tags);\n\tgf_free(s);\n}\n\nGF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err xtra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tu32 tag_size = 16;\n\t\tu32 name_len = tag->name ? (u32) strlen(tag->name) : 0;\n\t\ttag_size += name_len;\n\t\tif (tag->prop_value) {\n\t\t\ttag_size += 2 + tag->prop_size;\n\t\t}\n\t\tgf_bs_write_u32(bs, tag_size);\n\t\tgf_bs_write_u32(bs, name_len);\n\t\tgf_bs_write_data(bs, tag->name, name_len);\n\t\tgf_bs_write_u32(bs, tag->flags);\n\t\tgf_bs_write_u32(bs, 6 + tag->prop_size);\n\t\tgf_bs_write_u16(bs, tag->prop_type);\n\t\tgf_bs_write_data(bs, tag->prop_value, tag->prop_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err xtra_box_size(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tptr->size += 18 + (u32) strlen(tag->name) + tag->prop_size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *st3d_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Stereo3DBox, GF_ISOM_BOX_TYPE_ST3D);\n\treturn (GF_Box *)tmp;\n}\n\nvoid st3d_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err st3d_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->stereo_type = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err st3d_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->stereo_type);\n\treturn GF_OK;\n}\n\nGF_Err st3d_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *svhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SphericalVideoInfoBox, GF_ISOM_BOX_TYPE_SVHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid svhd_box_del(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string) gf_free(ptr->string);\n\tgf_free(s);\n}\n\n\nGF_Err svhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->string = gf_malloc(sizeof(char) * ((u32) ptr->size+1));\n\tif (!ptr->string) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->string, (u32) ptr->size);\n\tptr->string[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err svhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->string)\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *prhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionHeaderBox, GF_ISOM_BOX_TYPE_PRHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid prhd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err prhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12)\n\tptr->yaw = (s32) gf_bs_read_u32(bs);\n\tptr->pitch = (s32) gf_bs_read_u32(bs);\n\tptr->roll = (s32) gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err prhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->yaw);\n\tgf_bs_write_u32(bs, ptr->pitch);\n\tgf_bs_write_u32(bs, ptr->roll);\n\treturn GF_OK;\n}\n\nGF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *proj_type_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionTypeBox, GF_ISOM_BOX_TYPE_EQUI); //will be overwritten\n\treturn (GF_Box *)tmp;\n}\n\nvoid proj_type_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err proj_type_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tgf_bs_write_u32(bs, ptr->layout);\n\t\tgf_bs_write_u32(bs, ptr->padding);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tgf_bs_write_u32(bs, ptr->bounds_top);\n\t\tgf_bs_write_u32(bs, ptr->bounds_bottom);\n\t\tgf_bs_write_u32(bs, ptr->bounds_left);\n\t\tgf_bs_write_u32(bs, ptr->bounds_right);\n\t} else {\n\t\tgf_bs_write_u32(bs, ptr->crc);\n\t\tgf_bs_write_u32(bs, ptr->encoding_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/box_code_base.c"], "buggy_code_start_loc": [11086], "buggy_code_end_loc": [11090], "fixing_code_start_loc": [11086], "fixing_code_end_loc": [11092], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 1.1.0.", "other": {"cve": {"id": "CVE-2021-4043", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-04T23:15:12.250", "lastModified": "2023-05-27T04:15:20.003", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 1.1.0."}, {"lang": "es", "value": "Una Desreferencia de Puntero NULL en el repositorio de GitHub gpac/gpac versiones anteriores a 1.1.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.0", "matchCriteriaId": "5E981F29-FDD8-4C5F-B6A8-0DF0E294057F"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/64a2e1b799352ac7d7aad1989bc06e7b0f2b01db", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/d7a534cb-df7a-48ba-8ce3-46b1551a9c47", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/64a2e1b799352ac7d7aad1989bc06e7b0f2b01db"}}