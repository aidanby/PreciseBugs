{"buggy_code": ["<!-- doc/src/sgml/protocol.sgml -->\n\n<chapter id=\"protocol\">\n <title>Frontend/Backend Protocol</title>\n\n <indexterm zone=\"protocol\">\n  <primary>protocol</primary>\n  <secondary>frontend-backend</secondary>\n </indexterm>\n\n <para>\n  <productname>PostgreSQL</productname> uses a message-based protocol\n  for communication between frontends and backends (clients and servers).\n  The protocol is supported over <acronym>TCP/IP</acronym> and also over\n  Unix-domain sockets.  Port number 5432 has been registered with IANA as\n  the customary TCP port number for servers supporting this protocol, but\n  in practice any non-privileged port number can be used.\n </para>\n\n <para>\n  This document describes version 3.0 of the protocol, implemented in\n  <productname>PostgreSQL</productname> 7.4 and later.  For descriptions\n  of the earlier protocol versions, see previous releases of the\n  <productname>PostgreSQL</productname> documentation.  A single server\n  can support multiple protocol versions.  The initial startup-request\n  message tells the server which protocol version the client is attempting to\n  use.  If the major version requested by the client is not supported by\n  the server, the connection will be rejected (for example, this would occur\n  if the client requested protocol version 4.0, which does not exist as of\n  this writing).  If the minor version requested by the client is not\n  supported by the server (e.g., the client requests version 3.1, but the\n  server supports only 3.0), the server may either reject the connection or\n  may respond with a NegotiateProtocolVersion message containing the highest\n  minor protocol version which it supports.  The client may then choose either\n  to continue with the connection using the specified protocol version or\n  to abort the connection.\n </para>\n\n  <para>\n   In order to serve multiple clients efficiently, the server launches\n   a new <quote>backend</quote> process for each client.\n   In the current implementation, a new child\n   process is created immediately after an incoming connection is detected.\n   This is transparent to the protocol, however.  For purposes of the\n   protocol, the terms <quote>backend</quote> and <quote>server</quote> are\n   interchangeable; likewise <quote>frontend</quote> and <quote>client</quote>\n   are interchangeable.\n  </para>\n\n <sect1 id=\"protocol-overview\">\n  <title>Overview</title>\n\n  <para>\n   The protocol has separate phases for startup and normal operation.\n   In the startup phase, the frontend opens a connection to the server\n   and authenticates itself to the satisfaction of the server.  (This might\n   involve a single message, or multiple messages depending on the\n   authentication method being used.)  If all goes well, the server then sends\n   status information to the frontend, and finally enters normal operation.\n   Except for the initial startup-request message, this part of the\n   protocol is driven by the server.\n  </para>\n\n  <para>\n   During normal operation, the frontend sends queries and\n   other commands to the backend, and the backend sends back query results\n   and other responses.  There are a few cases (such as <command>NOTIFY</command>)\n   wherein the\n   backend will send unsolicited messages, but for the most part this portion\n   of a session is driven by frontend requests.\n  </para>\n\n  <para>\n   Termination of the session is normally by frontend choice, but can be\n   forced by the backend in certain cases.  In any case, when the backend\n   closes the connection, it will roll back any open (incomplete) transaction\n   before exiting.\n  </para>\n\n  <para>\n   Within normal operation, SQL commands can be executed through either of\n   two sub-protocols.  In the <quote>simple query</quote> protocol, the frontend\n   just sends a textual query string, which is parsed and immediately\n   executed by the backend.  In the <quote>extended query</quote> protocol,\n   processing of queries is separated into multiple steps: parsing,\n   binding of parameter values, and execution.  This offers flexibility\n   and performance benefits, at the cost of extra complexity.\n  </para>\n\n  <para>\n   Normal operation has additional sub-protocols for special operations\n   such as <command>COPY</command>.\n  </para>\n\n <sect2 id=\"protocol-message-concepts\">\n  <title>Messaging Overview</title>\n\n  <para>\n   All communication is through a stream of messages.  The first byte of a\n   message identifies the message type, and the next four bytes specify the\n   length of the rest of the message (this length count includes itself, but\n   not the message-type byte).  The remaining contents of the message are\n   determined by the message type.  For historical reasons, the very first\n   message sent by the client (the startup message) has no initial\n   message-type byte.\n  </para>\n\n  <para>\n   To avoid losing synchronization with the message stream, both servers and\n   clients typically read an entire message into a buffer (using the byte\n   count) before attempting to process its contents.  This allows easy\n   recovery if an error is detected while processing the contents.  In\n   extreme situations (such as not having enough memory to buffer the\n   message), the receiver can use the byte count to determine how much\n   input to skip before it resumes reading messages.\n  </para>\n\n  <para>\n   Conversely, both servers and clients must take care never to send an\n   incomplete message.  This is commonly done by marshaling the entire message\n   in a buffer before beginning to send it.  If a communications failure\n   occurs partway through sending or receiving a message, the only sensible\n   response is to abandon the connection, since there is little hope of\n   recovering message-boundary synchronization.\n  </para>\n </sect2>\n\n  <sect2 id=\"protocol-query-concepts\">\n   <title>Extended Query Overview</title>\n\n   <para>\n    In the extended-query protocol, execution of SQL commands is divided\n    into multiple steps.  The state retained between steps is represented\n    by two types of objects: <firstterm>prepared statements</firstterm> and\n    <firstterm>portals</firstterm>.  A prepared statement represents the result of\n    parsing and semantic analysis of a textual query string.\n    A prepared statement is not in itself ready to execute, because it might\n    lack specific values for <firstterm>parameters</firstterm>.  A portal represents\n    a ready-to-execute or already-partially-executed statement, with any\n    missing parameter values filled in.  (For <command>SELECT</command> statements,\n    a portal is equivalent to an open cursor, but we choose to use a different\n    term since cursors don't handle non-<command>SELECT</command> statements.)\n   </para>\n\n   <para>\n    The overall execution cycle consists of a <firstterm>parse</firstterm> step,\n    which creates a prepared statement from a textual query string; a\n    <firstterm>bind</firstterm> step, which creates a portal given a prepared\n    statement and values for any needed parameters; and an\n    <firstterm>execute</firstterm> step that runs a portal's query.  In the case of\n    a query that returns rows (<command>SELECT</command>, <command>SHOW</command>, etc),\n    the execute step can be told to fetch only\n    a limited number of rows, so that multiple execute steps might be needed\n    to complete the operation.\n   </para>\n\n   <para>\n    The backend can keep track of multiple prepared statements and portals\n    (but note that these exist only within a session, and are never shared\n    across sessions).  Existing prepared statements and portals are\n    referenced by names assigned when they were created.  In addition,\n    an <quote>unnamed</quote> prepared statement and portal exist.  Although these\n    behave largely the same as named objects, operations on them are optimized\n    for the case of executing a query only once and then discarding it,\n    whereas operations on named objects are optimized on the expectation\n    of multiple uses.\n   </para>\n  </sect2>\n\n  <sect2 id=\"protocol-format-codes\">\n   <title>Formats and Format Codes</title>\n\n   <para>\n    Data of a particular data type might be transmitted in any of several\n    different <firstterm>formats</firstterm>.  As of <productname>PostgreSQL</productname> 7.4\n    the only supported formats are <quote>text</quote> and <quote>binary</quote>,\n    but the protocol makes provision for future extensions.  The desired\n    format for any value is specified by a <firstterm>format code</firstterm>.\n    Clients can specify a format code for each transmitted parameter value\n    and for each column of a query result.  Text has format code zero,\n    binary has format code one, and all other format codes are reserved\n    for future definition.\n   </para>\n\n   <para>\n    The text representation of values is whatever strings are produced\n    and accepted by the input/output conversion functions for the\n    particular data type.  In the transmitted representation, there is\n    no trailing null character; the frontend must add one to received\n    values if it wants to process them as C strings.\n    (The text format does not allow embedded nulls, by the way.)\n   </para>\n\n   <para>\n    Binary representations for integers use network byte order (most\n    significant byte first).  For other data types consult the documentation\n    or source code to learn about the binary representation.  Keep in mind\n    that binary representations for complex data types might change across\n    server versions; the text format is usually the more portable choice.\n   </para>\n  </sect2>\n </sect1>\n\n <sect1 id=\"protocol-flow\">\n  <title>Message Flow</title>\n\n  <para>\n   This section describes the message flow and the semantics of each\n   message type.  (Details of the exact representation of each message\n   appear in <xref linkend=\"protocol-message-formats\"/>.)  There are\n   several different sub-protocols depending on the state of the\n   connection: start-up, query, function call,\n   <command>COPY</command>, and termination.  There are also special\n   provisions for asynchronous operations (including notification\n   responses and command cancellation), which can occur at any time\n   after the start-up phase.\n  </para>\n\n  <sect2>\n   <title>Start-up</title>\n\n   <para>\n    To begin a session, a frontend opens a connection to the server and sends\n    a startup message.  This message includes the names of the user and of the\n    database the user wants to connect to; it also identifies the particular\n    protocol version to be used.  (Optionally, the startup message can include\n    additional settings for run-time parameters.)\n    The server then uses this information and\n    the contents of its configuration files (such as\n    <filename>pg_hba.conf</filename>) to determine\n    whether the connection is provisionally acceptable, and what additional\n    authentication is required (if any).\n   </para>\n\n   <para>\n    The server then sends an appropriate authentication request message,\n    to which the frontend must reply with an appropriate authentication\n    response message (such as a password).\n    For all authentication methods except GSSAPI, SSPI and SASL, there is at\n    most one request and one response. In some methods, no response\n    at all is needed from the frontend, and so no authentication request\n    occurs. For GSSAPI, SSPI and SASL, multiple exchanges of packets may be\n    needed to complete the authentication.\n   </para>\n\n   <para>\n    The authentication cycle ends with the server either rejecting the\n    connection attempt (ErrorResponse), or sending AuthenticationOk.\n   </para>\n\n   <para>\n    The possible messages from the server in this phase are:\n\n    <variablelist>\n     <varlistentry>\n      <term>ErrorResponse</term>\n      <listitem>\n       <para>\n        The connection attempt has been rejected.\n        The server then immediately closes the connection.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationOk</term>\n      <listitem>\n       <para>\n        The authentication exchange is successfully completed.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationKerberosV5</term>\n      <listitem>\n       <para>\n        The frontend must now take part in a Kerberos V5\n        authentication dialog (not described here, part of the\n        Kerberos specification) with the server.  If this is\n        successful, the server responds with an AuthenticationOk,\n        otherwise it responds with an ErrorResponse. This is no\n        longer supported.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationCleartextPassword</term>\n      <listitem>\n       <para>\n        The frontend must now send a PasswordMessage containing the\n        password in clear-text form.  If\n        this is the correct password, the server responds with an\n        AuthenticationOk, otherwise it responds with an ErrorResponse.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationMD5Password</term>\n      <listitem>\n       <para>\n        The frontend must now send a PasswordMessage containing the\n        password (with user name) encrypted via MD5, then encrypted\n        again using the 4-byte random salt specified in the\n        AuthenticationMD5Password message.  If this is the correct\n        password, the server responds with an AuthenticationOk,\n        otherwise it responds with an ErrorResponse.  The actual\n        PasswordMessage can be computed in SQL as <literal>concat('md5',\n        md5(concat(md5(concat(password, username)), random-salt)))</literal>.\n        (Keep in mind the <function>md5()</function> function returns its\n        result as a hex string.)\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSCMCredential</term>\n      <listitem>\n       <para>\n        This response is only possible for local Unix-domain connections\n        on platforms that support SCM credential messages.  The frontend\n        must issue an SCM credential message and then send a single data\n        byte.  (The contents of the data byte are uninteresting; it's\n        only used to ensure that the server waits long enough to receive\n        the credential message.)  If the credential is acceptable,\n        the server responds with an\n        AuthenticationOk, otherwise it responds with an ErrorResponse.\n        (This message type is only issued by pre-9.1 servers.  It may\n        eventually be removed from the protocol specification.)\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationGSS</term>\n      <listitem>\n       <para>\n        The frontend must now initiate a GSSAPI negotiation. The frontend\n        will send a GSSResponse message with the first part of the GSSAPI\n        data stream in response to this. If further messages are needed,\n        the server will respond with AuthenticationGSSContinue.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSSPI</term>\n      <listitem>\n       <para>\n        The frontend must now initiate an SSPI negotiation. The frontend\n        will send a GSSResponse with the first part of the SSPI\n        data stream in response to this. If further messages are needed,\n        the server will respond with AuthenticationGSSContinue.\n       </para>\n      </listitem>\n\n     </varlistentry>\n     <varlistentry>\n      <term>AuthenticationGSSContinue</term>\n      <listitem>\n       <para>\n        This message contains the response data from the previous step\n        of GSSAPI or SSPI negotiation (AuthenticationGSS, AuthenticationSSPI\n        or a previous AuthenticationGSSContinue). If the GSSAPI\n        or SSPI data in this message\n        indicates more data is needed to complete the authentication,\n        the frontend must send that data as another GSSResponse message. If\n        GSSAPI or SSPI authentication is completed by this message, the server\n        will next send AuthenticationOk to indicate successful authentication\n        or ErrorResponse to indicate failure.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSASL</term>\n      <listitem>\n       <para>\n        The frontend must now initiate a SASL negotiation, using one of the\n        SASL mechanisms listed in the message. The frontend will send a\n        SASLInitialResponse with the name of the selected mechanism, and the\n        first part of the SASL data stream in response to this. If further\n        messages are needed, the server will respond with\n        AuthenticationSASLContinue. See <xref linkend=\"sasl-authentication\"/>\n        for details.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSASLContinue</term>\n      <listitem>\n       <para>\n        This message contains challenge data from the previous step of SASL\n        negotiation (AuthenticationSASL, or a previous\n        AuthenticationSASLContinue). The frontend must respond with a\n        SASLResponse message.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSASLFinal</term>\n      <listitem>\n       <para>\n        SASL authentication has completed with additional mechanism-specific\n        data for the client. The server will next send AuthenticationOk to\n        indicate successful authentication, or an ErrorResponse to indicate\n        failure. This message is sent only if the SASL mechanism specifies\n        additional data to be sent from server to client at completion.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>NegotiateProtocolVersion</term>\n      <listitem>\n       <para>\n        The server does not support the minor protocol version requested\n        by the client, but does support an earlier version of the protocol;\n        this message indicates the highest supported minor version.  This\n        message will also be sent if the client requested unsupported protocol\n        options (i.e., beginning with <literal>_pq_.</literal>) in the\n        startup packet.  This message will be followed by an ErrorResponse or\n        a message indicating the success or failure of authentication.\n       </para>\n      </listitem>\n     </varlistentry>\n\n    </variablelist>\n   </para>\n\n   <para>\n    If the frontend does not support the authentication method\n    requested by the server, then it should immediately close the\n    connection.\n   </para>\n\n   <para>\n    After having received AuthenticationOk, the frontend must wait\n    for further messages from the server.  In this phase a backend process\n    is being started, and the frontend is just an interested bystander.\n    It is still possible for the startup attempt\n    to fail (ErrorResponse) or the server to decline support for the requested\n    minor protocol version (NegotiateProtocolVersion), but in the normal case\n    the backend will send some ParameterStatus messages, BackendKeyData, and\n    finally ReadyForQuery.\n   </para>\n\n   <para>\n    During this phase the backend will attempt to apply any additional\n    run-time parameter settings that were given in the startup message.\n    If successful, these values become session defaults.  An error causes\n    ErrorResponse and exit.\n   </para>\n\n   <para>\n    The possible messages from the backend in this phase are:\n\n    <variablelist>\n     <varlistentry>\n      <term>BackendKeyData</term>\n      <listitem>\n       <para>\n        This message provides secret-key data that the frontend must\n        save if it wants to be able to issue cancel requests later.\n        The frontend should not respond to this message, but should\n        continue listening for a ReadyForQuery message.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ParameterStatus</term>\n      <listitem>\n       <para>\n        This message informs the frontend about the current (initial)\n         setting of backend parameters, such as <xref\n         linkend=\"guc-client-encoding\"/> or <xref linkend=\"guc-datestyle\"/>.\n         The frontend can ignore this message, or record the settings\n         for its future use; see <xref linkend=\"protocol-async\"/> for\n         more details.  The frontend should not respond to this\n         message, but should continue listening for a ReadyForQuery\n         message.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ReadyForQuery</term>\n      <listitem>\n       <para>\n        Start-up is completed.  The frontend can now issue commands.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ErrorResponse</term>\n      <listitem>\n       <para>\n        Start-up failed.  The connection is closed after sending this\n        message.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>NoticeResponse</term>\n      <listitem>\n       <para>\n        A warning message has been issued.  The frontend should\n        display the message but continue listening for ReadyForQuery\n        or ErrorResponse.\n       </para>\n      </listitem>\n     </varlistentry>\n    </variablelist>\n   </para>\n\n   <para>\n    The ReadyForQuery message is the same one that the backend will\n    issue after each command cycle.  Depending on the coding needs of\n    the frontend, it is reasonable to consider ReadyForQuery as\n    starting a command cycle, or to consider ReadyForQuery as ending the\n    start-up phase and each subsequent command cycle.\n   </para>\n  </sect2>\n\n  <sect2>\n   <title>Simple Query</title>\n\n   <para>\n    A simple query cycle is initiated by the frontend sending a Query message\n    to the backend.  The message includes an SQL command (or commands)\n    expressed as a text string.\n    The backend then sends one or more response\n    messages depending on the contents of the query command string,\n    and finally a ReadyForQuery response message.  ReadyForQuery\n    informs the frontend that it can safely send a new command.\n    (It is not actually necessary for the frontend to wait for\n    ReadyForQuery before issuing another command, but the frontend must\n    then take responsibility for figuring out what happens if the earlier\n    command fails and already-issued later commands succeed.)\n   </para>\n\n   <para>\n    The possible response messages from the backend are:\n\n    <variablelist>\n     <varlistentry>\n      <term>CommandComplete</term>\n      <listitem>\n       <para>\n        An SQL command completed normally.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>CopyInResponse</term>\n      <listitem>\n       <para>\n        The backend is ready to copy data from the frontend to a\n        table; see <xref linkend=\"protocol-copy\"/>.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>CopyOutResponse</term>\n      <listitem>\n       <para>\n        The backend is ready to copy data from a table to the\n        frontend; see <xref linkend=\"protocol-copy\"/>.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>RowDescription</term>\n      <listitem>\n       <para>\n        Indicates that rows are about to be returned in response to\n        a <command>SELECT</command>, <command>FETCH</command>, etc query.\n        The contents of this message describe the column layout of the rows.\n        This will be followed by a DataRow message for each row being returned\n        to the frontend.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>DataRow</term>\n      <listitem>\n       <para>\n        One of the set of rows returned by\n        a <command>SELECT</command>, <command>FETCH</command>, etc query.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>EmptyQueryResponse</term>\n      <listitem>\n       <para>\n        An empty query string was recognized.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ErrorResponse</term>\n      <listitem>\n       <para>\n        An error has occurred.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ReadyForQuery</term>\n      <listitem>\n       <para>\n        Processing of the query string is complete.  A separate\n        message is sent to indicate this because the query string might\n        contain multiple SQL commands.  (CommandComplete marks the\n        end of processing one SQL command, not the whole string.)\n        ReadyForQuery will always be sent, whether processing\n        terminates successfully or with an error.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>NoticeResponse</term>\n      <listitem>\n       <para>\n        A warning message has been issued in relation to the query.\n        Notices are in addition to other responses, i.e., the backend\n        will continue processing the command.\n       </para>\n      </listitem>\n     </varlistentry>\n\n    </variablelist>\n   </para>\n\n   <para>\n    The response to a <command>SELECT</command> query (or other queries that\n    return row sets, such as <command>EXPLAIN</command> or <command>SHOW</command>)\n    normally consists of RowDescription, zero or more\n    DataRow messages, and then CommandComplete.\n    <command>COPY</command> to or from the frontend invokes special protocol\n    as described in <xref linkend=\"protocol-copy\"/>.\n    All other query types normally produce only\n    a CommandComplete message.\n   </para>\n\n   <para>\n    Since a query string could contain several queries (separated by\n    semicolons), there might be several such response sequences before the\n    backend finishes processing the query string.  ReadyForQuery is issued\n    when the entire string has been processed and the backend is ready to\n    accept a new query string.\n   </para>\n\n   <para>\n    If a completely empty (no contents other than whitespace) query string\n    is received, the response is EmptyQueryResponse followed by ReadyForQuery.\n   </para>\n\n   <para>\n    In the event of an error, ErrorResponse is issued followed by\n    ReadyForQuery.  All further processing of the query string is aborted by\n    ErrorResponse (even if more queries remained in it).  Note that this\n    might occur partway through the sequence of messages generated by an\n    individual query.\n   </para>\n\n   <para>\n    In simple Query mode, the format of retrieved values is always text,\n    except when the given command is a <command>FETCH</command> from a cursor\n    declared with the <literal>BINARY</literal> option.  In that case, the\n    retrieved values are in binary format.  The format codes given in\n    the RowDescription message tell which format is being used.\n   </para>\n\n   <para>\n    A frontend must be prepared to accept ErrorResponse and\n    NoticeResponse messages whenever it is expecting any other type of\n    message.  See also <xref linkend=\"protocol-async\"/> concerning messages\n    that the backend might generate due to outside events.\n   </para>\n\n   <para>\n    Recommended practice is to code frontends in a state-machine style\n    that will accept any message type at any time that it could make sense,\n    rather than wiring in assumptions about the exact sequence of messages.\n   </para>\n\n   <sect3 id=\"protocol-flow-multi-statement\">\n    <title>Multiple Statements in a Simple Query</title>\n\n    <para>\n     When a simple Query message contains more than one SQL statement\n     (separated by semicolons), those statements are executed as a single\n     transaction, unless explicit transaction control commands are included\n     to force a different behavior.  For example, if the message contains\n<programlisting>\nINSERT INTO mytable VALUES(1);\nSELECT 1/0;\nINSERT INTO mytable VALUES(2);\n</programlisting>\n     then the divide-by-zero failure in the <command>SELECT</command> will force\n     rollback of the first <command>INSERT</command>.  Furthermore, because\n     execution of the message is abandoned at the first error, the second\n     <command>INSERT</command> is never attempted at all.\n    </para>\n\n    <para>\n     If instead the message contains\n<programlisting>\nBEGIN;\nINSERT INTO mytable VALUES(1);\nCOMMIT;\nINSERT INTO mytable VALUES(2);\nSELECT 1/0;\n</programlisting>\n     then the first <command>INSERT</command> is committed by the\n     explicit <command>COMMIT</command> command.  The second <command>INSERT</command>\n     and the <command>SELECT</command> are still treated as a single transaction,\n     so that the divide-by-zero failure will roll back the\n     second <command>INSERT</command>, but not the first one.\n    </para>\n\n    <para>\n     This behavior is implemented by running the statements in a\n     multi-statement Query message in an <firstterm>implicit transaction\n     block</firstterm> unless there is some explicit transaction block for them to\n     run in.  The main difference between an implicit transaction block and\n     a regular one is that an implicit block is closed automatically at the\n     end of the Query message, either by an implicit commit if there was no\n     error, or an implicit rollback if there was an error.  This is similar\n     to the implicit commit or rollback that happens for a statement\n     executed by itself (when not in a transaction block).\n    </para>\n\n    <para>\n     If the session is already in a transaction block, as a result of\n     a <command>BEGIN</command> in some previous message, then the Query message\n     simply continues that transaction block, whether the message contains\n     one statement or several.  However, if the Query message contains\n     a <command>COMMIT</command> or <command>ROLLBACK</command> closing the existing\n     transaction block, then any following statements are executed in an\n     implicit transaction block.\n     Conversely, if a <command>BEGIN</command> appears in a multi-statement Query\n     message, then it starts a regular transaction block that will only be\n     terminated by an explicit <command>COMMIT</command> or <command>ROLLBACK</command>,\n     whether that appears in this Query message or a later one.\n     If the <command>BEGIN</command> follows some statements that were executed as\n     an implicit transaction block, those statements are not immediately\n     committed; in effect, they are retroactively included into the new\n     regular transaction block.\n    </para>\n\n    <para>\n     A <command>COMMIT</command> or <command>ROLLBACK</command> appearing in an implicit\n     transaction block is executed as normal, closing the implicit block;\n     however, a warning will be issued since a <command>COMMIT</command>\n     or <command>ROLLBACK</command> without a previous <command>BEGIN</command> might\n     represent a mistake.  If more statements follow, a new implicit\n     transaction block will be started for them.\n    </para>\n\n    <para>\n     Savepoints are not allowed in an implicit transaction block, since\n     they would conflict with the behavior of automatically closing the\n     block upon any error.\n    </para>\n\n    <para>\n     Remember that, regardless of any transaction control commands that may\n     be present, execution of the Query message stops at the first error.\n     Thus for example given\n<programlisting>\nBEGIN;\nSELECT 1/0;\nROLLBACK;\n</programlisting>\n     in a single Query message, the session will be left inside a failed\n     regular transaction block, since the <command>ROLLBACK</command> is not\n     reached after the divide-by-zero error.  Another <command>ROLLBACK</command>\n     will be needed to restore the session to a usable state.\n    </para>\n\n    <para>\n     Another behavior of note is that initial lexical and syntactic\n     analysis is done on the entire query string before any of it is\n     executed.  Thus simple errors (such as a misspelled keyword) in later\n     statements can prevent execution of any of the statements.  This\n     is normally invisible to users since the statements would all roll\n     back anyway when done as an implicit transaction block.  However,\n     it can be visible when attempting to do multiple transactions within a\n     multi-statement Query.  For instance, if a typo turned our previous\n     example into\n<programlisting>\nBEGIN;\nINSERT INTO mytable VALUES(1);\nCOMMIT;\nINSERT INTO mytable VALUES(2);\nSELCT 1/0;<!-- this typo is intentional -->\n</programlisting>\n     then none of the statements would get run, resulting in the visible\n     difference that the first <command>INSERT</command> is not committed.\n     Errors detected at semantic analysis or later, such as a misspelled\n     table or column name, do not have this effect.\n    </para>\n   </sect3>\n  </sect2>\n\n  <sect2 id=\"protocol-flow-ext-query\">\n   <title>Extended Query</title>\n\n   <para>\n    The extended query protocol breaks down the above-described simple\n    query protocol into multiple steps.  The results of preparatory\n    steps can be re-used multiple times for improved efficiency.\n    Furthermore, additional features are available, such as the possibility\n    of supplying data values as separate parameters instead of having to\n    insert them directly into a query string.\n   </para>\n\n   <para>\n    In the extended protocol, the frontend first sends a Parse message,\n    which contains a textual query string, optionally some information\n    about data types of parameter placeholders, and the\n    name of a destination prepared-statement object (an empty string\n    selects the unnamed prepared statement).  The response is\n    either ParseComplete or ErrorResponse.  Parameter data types can be\n    specified by OID; if not given, the parser attempts to infer the\n    data types in the same way as it would do for untyped literal string\n    constants.\n   </para>\n\n   <note>\n    <para>\n     A parameter data type can be left unspecified by setting it to zero,\n     or by making the array of parameter type OIDs shorter than the\n     number of parameter symbols (<literal>$</literal><replaceable>n</replaceable>)\n     used in the query string.  Another special case is that a parameter's\n     type can be specified as <type>void</type> (that is, the OID of the\n     <type>void</type> pseudo-type).  This is meant to allow parameter symbols\n     to be used for function parameters that are actually OUT parameters.\n     Ordinarily there is no context in which a <type>void</type> parameter\n     could be used, but if such a parameter symbol appears in a function's\n     parameter list, it is effectively ignored.  For example, a function\n     call such as <literal>foo($1,$2,$3,$4)</literal> could match a function with\n     two IN and two OUT arguments, if <literal>$3</literal> and <literal>$4</literal>\n     are specified as having type <type>void</type>.\n    </para>\n   </note>\n\n   <note>\n    <para>\n     The query string contained in a Parse message cannot include more\n     than one SQL statement; else a syntax error is reported.  This\n     restriction does not exist in the simple-query protocol, but it\n     does exist in the extended protocol, because allowing prepared\n     statements or portals to contain multiple commands would complicate\n     the protocol unduly.\n    </para>\n   </note>\n\n   <para>\n    If successfully created, a named prepared-statement object lasts till\n    the end of the current session, unless explicitly destroyed.  An unnamed\n    prepared statement lasts only until the next Parse statement specifying\n    the unnamed statement as destination is issued.  (Note that a simple\n    Query message also destroys the unnamed statement.)  Named prepared\n    statements must be explicitly closed before they can be redefined by\n    another Parse message, but this is not required for the unnamed statement.\n    Named prepared statements can also be created and accessed at the SQL\n    command level, using <command>PREPARE</command> and <command>EXECUTE</command>.\n   </para>\n\n   <para>\n    Once a prepared statement exists, it can be readied for execution using a\n    Bind message.  The Bind message gives the name of the source prepared\n    statement (empty string denotes the unnamed prepared statement), the name\n    of the destination portal (empty string denotes the unnamed portal), and\n    the values to use for any parameter placeholders present in the prepared\n    statement.  The\n    supplied parameter set must match those needed by the prepared statement.\n    (If you declared any <type>void</type> parameters in the Parse message,\n    pass NULL values for them in the Bind message.)\n    Bind also specifies the format to use for any data returned\n    by the query; the format can be specified overall, or per-column.\n    The response is either BindComplete or ErrorResponse.\n   </para>\n\n   <note>\n    <para>\n     The choice between text and binary output is determined by the format\n     codes given in Bind, regardless of the SQL command involved.  The\n     <literal>BINARY</literal> attribute in cursor declarations is irrelevant when\n     using extended query protocol.\n    </para>\n   </note>\n\n   <para>\n    Query planning typically occurs when the Bind message is processed.\n    If the prepared statement has no parameters, or is executed repeatedly,\n    the server might save the created plan and re-use it during subsequent\n    Bind messages for the same prepared statement.  However, it will do so\n    only if it finds that a generic plan can be created that is not much\n    less efficient than a plan that depends on the specific parameter values\n    supplied.  This happens transparently so far as the protocol is concerned.\n   </para>\n\n   <para>\n    If successfully created, a named portal object lasts till the end of the\n    current transaction, unless explicitly destroyed.  An unnamed portal is\n    destroyed at the end of the transaction, or as soon as the next Bind\n    statement specifying the unnamed portal as destination is issued.  (Note\n    that a simple Query message also destroys the unnamed portal.)  Named\n    portals must be explicitly closed before they can be redefined by another\n    Bind message, but this is not required for the unnamed portal.\n    Named portals can also be created and accessed at the SQL\n    command level, using <command>DECLARE CURSOR</command> and <command>FETCH</command>.\n   </para>\n\n   <para>\n    Once a portal exists, it can be executed using an Execute message.\n    The Execute message specifies the portal name (empty string denotes the\n    unnamed portal) and\n    a maximum result-row count (zero meaning <quote>fetch all rows</quote>).\n    The result-row count is only meaningful for portals\n    containing commands that return row sets; in other cases the command is\n    always executed to completion, and the row count is ignored.\n    The possible\n    responses to Execute are the same as those described above for queries\n    issued via simple query protocol, except that Execute doesn't cause\n    ReadyForQuery or RowDescription to be issued.\n   </para>\n\n   <para>\n    If Execute terminates before completing the execution of a portal\n    (due to reaching a nonzero result-row count), it will send a\n    PortalSuspended message; the appearance of this message tells the frontend\n    that another Execute should be issued against the same portal to\n    complete the operation.  The CommandComplete message indicating\n    completion of the source SQL command is not sent until\n    the portal's execution is completed.  Therefore, an Execute phase is\n    always terminated by the appearance of exactly one of these messages:\n    CommandComplete, EmptyQueryResponse (if the portal was created from\n    an empty query string), ErrorResponse, or PortalSuspended.\n   </para>\n\n   <para>\n    At completion of each series of extended-query messages, the frontend\n    should issue a Sync message.  This parameterless message causes the\n    backend to close the current transaction if it's not inside a\n    <command>BEGIN</command>/<command>COMMIT</command> transaction block (<quote>close</quote>\n    meaning to commit if no error, or roll back if error).  Then a\n    ReadyForQuery response is issued.  The purpose of Sync is to provide\n    a resynchronization point for error recovery.  When an error is detected\n    while processing any extended-query message, the backend issues\n    ErrorResponse, then reads and discards messages until a Sync is reached,\n    then issues ReadyForQuery and returns to normal message processing.\n    (But note that no skipping occurs if an error is detected\n    <emphasis>while</emphasis> processing Sync &mdash; this ensures that there is one\n    and only one ReadyForQuery sent for each Sync.)\n   </para>\n\n   <note>\n    <para>\n     Sync does not cause a transaction block opened with <command>BEGIN</command>\n     to be closed.  It is possible to detect this situation since the\n     ReadyForQuery message includes transaction status information.\n    </para>\n   </note>\n\n   <para>\n    In addition to these fundamental, required operations, there are several\n    optional operations that can be used with extended-query protocol.\n   </para>\n\n   <para>\n    The Describe message (portal variant) specifies the name of an existing\n    portal (or an empty string for the unnamed portal).  The response is a\n    RowDescription message describing the rows that will be returned by\n    executing the portal; or a NoData message if the portal does not contain a\n    query that will return rows; or ErrorResponse if there is no such portal.\n   </para>\n\n   <para>\n    The Describe message (statement variant) specifies the name of an existing\n    prepared statement (or an empty string for the unnamed prepared\n    statement).  The response is a ParameterDescription message describing the\n    parameters needed by the statement, followed by a RowDescription message\n    describing the rows that will be returned when the statement is eventually\n    executed (or a NoData message if the statement will not return rows).\n    ErrorResponse is issued if there is no such prepared statement.  Note that\n    since Bind has not yet been issued, the formats to be used for returned\n    columns are not yet known to the backend; the format code fields in the\n    RowDescription message will be zeroes in this case.\n   </para>\n\n   <tip>\n    <para>\n     In most scenarios the frontend should issue one or the other variant\n     of Describe before issuing Execute, to ensure that it knows how to\n     interpret the results it will get back.\n    </para>\n   </tip>\n\n   <para>\n    The Close message closes an existing prepared statement or portal\n    and releases resources.  It is not an error to issue Close against\n    a nonexistent statement or portal name.  The response is normally\n    CloseComplete, but could be ErrorResponse if some difficulty is\n    encountered while releasing resources.  Note that closing a prepared\n    statement implicitly closes any open portals that were constructed\n    from that statement.\n   </para>\n\n   <para>\n    The Flush message does not cause any specific output to be generated,\n    but forces the backend to deliver any data pending in its output\n    buffers.  A Flush must be sent after any extended-query command except\n    Sync, if the frontend wishes to examine the results of that command before\n    issuing more commands.  Without Flush, messages returned by the backend\n    will be combined into the minimum possible number of packets to minimize\n    network overhead.\n   </para>\n\n   <note>\n    <para>\n     The simple Query message is approximately equivalent to the series Parse,\n     Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared\n     statement and portal objects and no parameters.  One difference is that\n     it will accept multiple SQL statements in the query string, automatically\n     performing the bind/describe/execute sequence for each one in succession.\n     Another difference is that it will not return ParseComplete, BindComplete,\n     CloseComplete, or NoData messages.\n    </para>\n   </note>\n  </sect2>\n\n  <sect2>\n   <title>Function Call</title>\n\n   <para>\n    The Function Call sub-protocol allows the client to request a direct\n    call of any function that exists in the database's\n    <structname>pg_proc</structname> system catalog.  The client must have\n    execute permission for the function.\n   </para>\n\n   <note>\n    <para>\n     The Function Call sub-protocol is a legacy feature that is probably best\n     avoided in new code.  Similar results can be accomplished by setting up\n     a prepared statement that does <literal>SELECT function($1, ...)</literal>.\n     The Function Call cycle can then be replaced with Bind/Execute.\n    </para>\n   </note>\n\n   <para>\n    A Function Call cycle is initiated by the frontend sending a\n    FunctionCall message to the backend.  The backend then sends one\n    or more response messages depending on the results of the function\n    call, and finally a ReadyForQuery response message.  ReadyForQuery\n    informs the frontend that it can safely send a new query or\n    function call.\n   </para>\n\n   <para>\n    The possible response messages from the backend are:\n\n    <variablelist>\n     <varlistentry>\n      <term>ErrorResponse</term>\n      <listitem>\n       <para>\n        An error has occurred.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>FunctionCallResponse</term>\n      <listitem>\n       <para>\n        The function call was completed and returned the result given\n        in the message.\n        (Note that the Function Call protocol can only handle a single\n        scalar result, not a row type or set of results.)\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ReadyForQuery</term>\n      <listitem>\n       <para>\n        Processing of the function call is complete.  ReadyForQuery\n        will always be sent, whether processing terminates\n        successfully or with an error.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>NoticeResponse</term>\n      <listitem>\n       <para>\n        A warning message has been issued in relation to the function\n        call.  Notices are in addition to other responses, i.e., the\n        backend will continue processing the command.\n       </para>\n      </listitem>\n     </varlistentry>\n    </variablelist>\n   </para>\n  </sect2>\n\n  <sect2 id=\"protocol-copy\">\n   <title>COPY Operations</title>\n\n   <para>\n    The <command>COPY</command> command allows high-speed bulk data transfer\n    to or from the server.  Copy-in and copy-out operations each switch\n    the connection into a distinct sub-protocol, which lasts until the\n    operation is completed.\n   </para>\n\n   <para>\n    Copy-in mode (data transfer to the server) is initiated when the\n    backend executes a <command>COPY FROM STDIN</command> SQL statement.  The backend\n    sends a CopyInResponse message to the frontend.  The frontend should\n    then send zero or more CopyData messages, forming a stream of input\n    data.  (The message boundaries are not required to have anything to do\n    with row boundaries, although that is often a reasonable choice.)\n    The frontend can terminate the copy-in mode by sending either a CopyDone\n    message (allowing successful termination) or a CopyFail message (which\n    will cause the <command>COPY</command> SQL statement to fail with an\n    error).  The backend then reverts to the command-processing mode it was\n    in before the <command>COPY</command> started, which will be either simple or\n    extended query protocol.  It will next send either CommandComplete\n    (if successful) or ErrorResponse (if not).\n   </para>\n\n   <para>\n    In the event of a backend-detected error during copy-in mode (including\n    receipt of a CopyFail message), the backend will issue an ErrorResponse\n    message.  If the <command>COPY</command> command was issued via an extended-query\n    message, the backend will now discard frontend messages until a Sync\n    message is received, then it will issue ReadyForQuery and return to normal\n    processing.  If the <command>COPY</command> command was issued in a simple\n    Query message, the rest of that message is discarded and ReadyForQuery\n    is issued.  In either case, any subsequent CopyData, CopyDone, or CopyFail\n    messages issued by the frontend will simply be dropped.\n   </para>\n\n   <para>\n    The backend will ignore Flush and Sync messages received during copy-in\n    mode.  Receipt of any other non-copy message type constitutes an error\n    that will abort the copy-in state as described above.  (The exception for\n    Flush and Sync is for the convenience of client libraries that always\n    send Flush or Sync after an Execute message, without checking whether\n    the command to be executed is a <command>COPY FROM STDIN</command>.)\n   </para>\n\n   <para>\n    Copy-out mode (data transfer from the server) is initiated when the\n    backend executes a <command>COPY TO STDOUT</command> SQL statement.  The backend\n    sends a CopyOutResponse message to the frontend, followed by\n    zero or more CopyData messages (always one per row), followed by CopyDone.\n    The backend then reverts to the command-processing mode it was\n    in before the <command>COPY</command> started, and sends CommandComplete.\n    The frontend cannot abort the transfer (except by closing the connection\n    or issuing a Cancel request),\n    but it can discard unwanted CopyData and CopyDone messages.\n   </para>\n\n   <para>\n    In the event of a backend-detected error during copy-out mode,\n    the backend will issue an ErrorResponse message and revert to normal\n    processing.  The frontend should treat receipt of ErrorResponse as\n    terminating the copy-out mode.\n   </para>\n\n   <para>\n    It is possible for NoticeResponse and ParameterStatus messages to be\n    interspersed between CopyData messages; frontends must handle these cases,\n    and should be prepared for other asynchronous message types as well (see\n    <xref linkend=\"protocol-async\"/>).  Otherwise, any message type other than\n    CopyData or CopyDone may be treated as terminating copy-out mode.\n   </para>\n\n   <para>\n    There is another Copy-related mode called copy-both, which allows\n    high-speed bulk data transfer to <emphasis>and</emphasis> from the server.\n    Copy-both mode is initiated when a backend in walsender mode\n    executes a <command>START_REPLICATION</command> statement.  The\n    backend sends a CopyBothResponse message to the frontend.  Both\n    the backend and the frontend may then send CopyData messages\n    until either end sends a CopyDone message. After the client\n    sends a CopyDone message, the connection goes from copy-both mode to\n    copy-out mode, and the client may not send any more CopyData messages.\n    Similarly, when the server sends a CopyDone message, the connection\n    goes into copy-in mode, and the server may not send any more CopyData\n    messages. After both sides have sent a CopyDone message, the copy mode\n    is terminated, and the backend reverts to the command-processing mode.\n    In the event of a backend-detected error during copy-both mode,\n    the backend will issue an ErrorResponse message, discard frontend messages\n    until a Sync message is received, and then issue ReadyForQuery and return\n    to normal processing.  The frontend should treat receipt of ErrorResponse\n    as terminating the copy in both directions; no CopyDone should be sent\n    in this case.  See <xref linkend=\"protocol-replication\"/> for more\n    information on the subprotocol transmitted over copy-both mode.\n   </para>\n\n   <para>\n    The CopyInResponse, CopyOutResponse and CopyBothResponse messages\n    include fields that inform the frontend of the number of columns\n    per row and the format codes being used for each column.  (As of\n    the present implementation, all columns in a given <command>COPY</command>\n    operation will use the same format, but the message design does not\n    assume this.)\n   </para>\n\n  </sect2>\n\n  <sect2 id=\"protocol-async\">\n   <title>Asynchronous Operations</title>\n\n   <para>\n    There are several cases in which the backend will send messages that\n    are not specifically prompted by the frontend's command stream.\n    Frontends must be prepared to deal with these messages at any time,\n    even when not engaged in a query.\n    At minimum, one should check for these cases before beginning to\n    read a query response.\n   </para>\n\n   <para>\n    It is possible for NoticeResponse messages to be generated due to\n    outside activity; for example, if the database administrator commands\n    a <quote>fast</quote> database shutdown, the backend will send a NoticeResponse\n    indicating this fact before closing the connection.  Accordingly,\n    frontends should always be prepared to accept and display NoticeResponse\n    messages, even when the connection is nominally idle.\n   </para>\n\n   <para>\n    ParameterStatus messages will be generated whenever the active\n    value changes for any of the parameters the backend believes the\n    frontend should know about.  Most commonly this occurs in response\n    to a <command>SET</command> SQL command executed by the frontend, and\n    this case is effectively synchronous &mdash; but it is also possible\n    for parameter status changes to occur because the administrator\n    changed a configuration file and then sent the\n    <systemitem>SIGHUP</systemitem> signal to the server.  Also,\n    if a <command>SET</command> command is rolled back, an appropriate\n    ParameterStatus message will be generated to report the current\n    effective value.\n   </para>\n\n   <para>\n    At present there is a hard-wired set of parameters for which\n    ParameterStatus will be generated: they are\n    <varname>server_version</varname>,\n    <varname>server_encoding</varname>,\n    <varname>client_encoding</varname>,\n    <varname>application_name</varname>,\n    <varname>default_transaction_read_only</varname>,\n    <varname>in_hot_standby</varname>,\n    <varname>is_superuser</varname>,\n    <varname>session_authorization</varname>,\n    <varname>DateStyle</varname>,\n    <varname>IntervalStyle</varname>,\n    <varname>TimeZone</varname>,\n    <varname>integer_datetimes</varname>, and\n    <varname>standard_conforming_strings</varname>.\n    (<varname>server_encoding</varname>, <varname>TimeZone</varname>, and\n    <varname>integer_datetimes</varname> were not reported by releases before 8.0;\n    <varname>standard_conforming_strings</varname> was not reported by releases\n    before 8.1;\n    <varname>IntervalStyle</varname> was not reported by releases before 8.4;\n    <varname>application_name</varname> was not reported by releases before\n    9.0;\n    <varname>default_transaction_read_only</varname> and\n    <varname>in_hot_standby</varname> were not reported by releases before\n    14.)\n    Note that\n    <varname>server_version</varname>,\n    <varname>server_encoding</varname> and\n    <varname>integer_datetimes</varname>\n    are pseudo-parameters that cannot change after startup.\n    This set might change in the future, or even become configurable.\n    Accordingly, a frontend should simply ignore ParameterStatus for\n    parameters that it does not understand or care about.\n   </para>\n\n   <para>\n    If a frontend issues a <command>LISTEN</command> command, then the\n    backend will send a NotificationResponse message (not to be\n    confused with NoticeResponse!)  whenever a\n    <command>NOTIFY</command> command is executed for the same\n    channel name.\n   </para>\n\n   <note>\n    <para>\n     At present, NotificationResponse can only be sent outside a\n     transaction, and thus it will not occur in the middle of a\n     command-response series, though it might occur just before ReadyForQuery.\n     It is unwise to design frontend logic that assumes that, however.\n     Good practice is to be able to accept NotificationResponse at any\n     point in the protocol.\n    </para>\n   </note>\n  </sect2>\n\n  <sect2>\n   <title>Canceling Requests in Progress</title>\n\n   <para>\n    During the processing of a query, the frontend might request\n    cancellation of the query.  The cancel request is not sent\n    directly on the open connection to the backend for reasons of\n    implementation efficiency: we don't want to have the backend\n    constantly checking for new input from the frontend during query\n    processing.  Cancel requests should be relatively infrequent, so\n    we make them slightly cumbersome in order to avoid a penalty in\n    the normal case.\n   </para>\n\n   <para>\n    To issue a cancel request, the frontend opens a new connection to\n    the server and sends a CancelRequest message, rather than the\n    StartupMessage message that would ordinarily be sent across a new\n    connection.  The server will process this request and then close\n    the connection.  For security reasons, no direct reply is made to\n    the cancel request message.\n   </para>\n\n   <para>\n    A CancelRequest message will be ignored unless it contains the\n    same key data (PID and secret key) passed to the frontend during\n    connection start-up.  If the request matches the PID and secret\n    key for a currently executing backend, the processing of the\n    current query is aborted.  (In the existing implementation, this is\n    done by sending a special signal to the backend process that is\n    processing the query.)\n   </para>\n\n   <para>\n    The cancellation signal might or might not have any effect &mdash; for\n    example, if it arrives after the backend has finished processing\n    the query, then it will have no effect.  If the cancellation is\n    effective, it results in the current command being terminated\n    early with an error message.\n   </para>\n\n   <para>\n    The upshot of all this is that for reasons of both security and\n    efficiency, the frontend has no direct way to tell whether a\n    cancel request has succeeded.  It must continue to wait for the\n    backend to respond to the query.  Issuing a cancel simply improves\n    the odds that the current query will finish soon, and improves the\n    odds that it will fail with an error message instead of\n    succeeding.\n   </para>\n\n   <para>\n    Since the cancel request is sent across a new connection to the\n    server and not across the regular frontend/backend communication\n    link, it is possible for the cancel request to be issued by any\n    process, not just the frontend whose query is to be canceled.\n    This might provide additional flexibility when building\n    multiple-process applications.  It also introduces a security\n    risk, in that unauthorized persons might try to cancel queries.\n    The security risk is addressed by requiring a dynamically\n    generated secret key to be supplied in cancel requests.\n   </para>\n  </sect2>\n\n  <sect2>\n   <title>Termination</title>\n\n   <para>\n    The normal, graceful termination procedure is that the frontend\n    sends a Terminate message and immediately closes the connection.\n    On receipt of this message, the backend closes the connection and\n    terminates.\n   </para>\n\n   <para>\n    In rare cases (such as an administrator-commanded database shutdown)\n    the backend might disconnect without any frontend request to do so.\n    In such cases the backend will attempt to send an error or notice message\n    giving the reason for the disconnection before it closes the connection.\n   </para>\n\n   <para>\n    Other termination scenarios arise from various failure cases, such as core\n    dump at one end or the other, loss of the communications link, loss of\n    message-boundary synchronization, etc.  If either frontend or backend sees\n    an unexpected closure of the connection, it should clean\n    up and terminate.  The frontend has the option of launching a new backend\n    by recontacting the server if it doesn't want to terminate itself.\n    Closing the connection is also advisable if an unrecognizable message type\n    is received, since this probably indicates loss of message-boundary sync.\n   </para>\n\n   <para>\n    For either normal or abnormal termination, any open transaction is\n    rolled back, not committed.  One should note however that if a\n    frontend disconnects while a non-<command>SELECT</command> query\n    is being processed, the backend will probably finish the query\n    before noticing the disconnection.  If the query is outside any\n    transaction block (<command>BEGIN</command> ... <command>COMMIT</command>\n    sequence) then its results might be committed before the\n    disconnection is recognized.\n   </para>\n  </sect2>\n\n  <sect2>\n   <title><acronym>SSL</acronym> Session Encryption</title>\n\n   <para>\n    If <productname>PostgreSQL</productname> was built with\n    <acronym>SSL</acronym> support, frontend/backend communications\n    can be encrypted using <acronym>SSL</acronym>.  This provides\n    communication security in environments where attackers might be\n    able to capture the session traffic. For more information on\n    encrypting <productname>PostgreSQL</productname> sessions with\n    <acronym>SSL</acronym>, see <xref linkend=\"ssl-tcp\"/>.\n   </para>\n\n   <para>\n    To initiate an <acronym>SSL</acronym>-encrypted connection, the\n    frontend initially sends an SSLRequest message rather than a\n    StartupMessage.  The server then responds with a single byte\n    containing <literal>S</literal> or <literal>N</literal>, indicating that it is\n    willing or unwilling to perform <acronym>SSL</acronym>,\n    respectively.  The frontend might close the connection at this point\n    if it is dissatisfied with the response.  To continue after\n    <literal>S</literal>, perform an <acronym>SSL</acronym> startup handshake\n    (not described here, part of the <acronym>SSL</acronym>\n    specification) with the server.  If this is successful, continue\n    with sending the usual StartupMessage.  In this case the\n    StartupMessage and all subsequent data will be\n    <acronym>SSL</acronym>-encrypted.  To continue after\n    <literal>N</literal>, send the usual StartupMessage and proceed without\n    encryption.\n    (Alternatively, it is permissible to issue a GSSENCRequest message\n    after an <literal>N</literal> response to try to\n    use <acronym>GSSAPI</acronym> encryption instead\n    of <acronym>SSL</acronym>.)\n   </para>\n\n   <para>\n    The frontend should also be prepared to handle an ErrorMessage\n    response to SSLRequest from the server.  This would only occur if\n    the server predates the addition of <acronym>SSL</acronym> support\n    to <productname>PostgreSQL</productname>.  (Such servers are now very ancient,\n    and likely do not exist in the wild anymore.)\n    In this case the connection must\n    be closed, but the frontend might choose to open a fresh connection\n    and proceed without requesting <acronym>SSL</acronym>.\n   </para>\n\n   <para>\n    An initial SSLRequest can also be used in a connection that is being\n    opened to send a CancelRequest message.\n   </para>\n\n   <para>\n    While the protocol itself does not provide a way for the server to\n    force <acronym>SSL</acronym> encryption, the administrator can\n    configure the server to reject unencrypted sessions as a byproduct\n    of authentication checking.\n   </para>\n  </sect2>\n\n  <sect2>\n   <title><acronym>GSSAPI</acronym> Session Encryption</title>\n\n   <para>\n    If <productname>PostgreSQL</productname> was built with\n    <acronym>GSSAPI</acronym> support, frontend/backend communications\n    can be encrypted using <acronym>GSSAPI</acronym>.  This provides\n    communication security in environments where attackers might be\n    able to capture the session traffic. For more information on\n    encrypting <productname>PostgreSQL</productname> sessions with\n    <acronym>GSSAPI</acronym>, see <xref linkend=\"gssapi-enc\"/>.\n   </para>\n\n   <para>\n    To initiate a <acronym>GSSAPI</acronym>-encrypted connection, the\n    frontend initially sends a GSSENCRequest message rather than a\n    StartupMessage.  The server then responds with a single byte\n    containing <literal>G</literal> or <literal>N</literal>, indicating that it\n    is willing or unwilling to perform <acronym>GSSAPI</acronym> encryption,\n    respectively.  The frontend might close the connection at this point\n    if it is dissatisfied with the response.  To continue after\n    <literal>G</literal>, using the GSSAPI C bindings as discussed in\n    <ulink url=\"https://tools.ietf.org/html/rfc2744\">RFC 2744</ulink>\n    or equivalent, perform a <acronym>GSSAPI</acronym> initialization by\n    calling <function>gss_init_sec_context()</function> in a loop and sending\n    the result to the server, starting with an empty input and then with each\n    result from the server, until it returns no output.  When sending the\n    results of <function>gss_init_sec_context()</function> to the server,\n    prepend the length of the message as a four byte integer in network byte\n    order.\n    To continue after\n    <literal>N</literal>, send the usual StartupMessage and proceed without\n    encryption.\n    (Alternatively, it is permissible to issue an SSLRequest message\n    after an <literal>N</literal> response to try to\n    use <acronym>SSL</acronym> encryption instead\n    of <acronym>GSSAPI</acronym>.)\n   </para>\n\n   <para>\n    The frontend should also be prepared to handle an ErrorMessage\n    response to GSSENCRequest from the server.  This would only occur if\n    the server predates the addition of <acronym>GSSAPI</acronym> encryption\n    support to <productname>PostgreSQL</productname>.  In this case the\n    connection must be closed, but the frontend might choose to open a fresh\n    connection and proceed without requesting <acronym>GSSAPI</acronym>\n    encryption.\n   </para>\n\n   <para>\n    An initial GSSENCRequest can also be used in a connection that is being\n    opened to send a CancelRequest message.\n   </para>\n\n   <para>\n    Once <acronym>GSSAPI</acronym> encryption has been successfully\n    established, use <function>gss_wrap()</function> to\n    encrypt the usual StartupMessage and all subsequent data, prepending the\n    length of the result from <function>gss_wrap()</function> as a four byte\n    integer in network byte order to the actual encrypted payload.  Note that\n    the server will only accept encrypted packets from the client which are less\n    than 16kB; <function>gss_wrap_size_limit()</function> should be used by the\n    client to determine the size of the unencrypted message which will fit\n    within this limit and larger messages should be broken up into multiple\n    <function>gss_wrap()</function> calls.  Typical segments are 8kB of\n    unencrypted data, resulting in encrypted packets of slightly larger than 8kB\n    but well within the 16kB maximum.  The server can be expected to not send\n    encrypted packets of larger than 16kB to the client.\n   </para>\n\n   <para>\n    While the protocol itself does not provide a way for the server to\n    force <acronym>GSSAPI</acronym> encryption, the administrator can\n    configure the server to reject unencrypted sessions as a byproduct\n    of authentication checking.\n   </para>\n  </sect2>\n </sect1>\n\n<sect1 id=\"sasl-authentication\">\n<title>SASL Authentication</title>\n\n<para>\n<firstterm>SASL</firstterm> is a framework for authentication in connection-oriented\nprotocols. At the moment, <productname>PostgreSQL</productname> implements two SASL\nauthentication mechanisms, SCRAM-SHA-256 and SCRAM-SHA-256-PLUS. More\nmight be added in the future. The below steps illustrate how SASL\nauthentication is performed in general, while the next subsection gives\nmore details on SCRAM-SHA-256 and SCRAM-SHA-256-PLUS.\n</para>\n\n<procedure>\n<title>SASL Authentication Message Flow</title>\n\n<step id=\"sasl-auth-begin\">\n<para>\n  To begin a SASL authentication exchange, the server sends an\n  AuthenticationSASL message. It includes a list of SASL authentication\n  mechanisms that the server can accept, in the server's preferred order.\n</para>\n</step>\n\n<step id=\"sasl-auth-initial-response\">\n<para>\n  The client selects one of the supported mechanisms from the list, and sends\n  a SASLInitialResponse message to the server. The message includes the name\n  of the selected mechanism, and an optional Initial Client Response, if the\n  selected mechanism uses that.\n</para>\n</step>\n\n<step id=\"sasl-auth-continue\">\n<para>\n  One or more server-challenge and client-response message will follow. Each\n  server-challenge is sent in an AuthenticationSASLContinue message, followed\n  by a response from client in a SASLResponse message. The particulars of\n  the messages are mechanism specific.\n</para>\n</step>\n\n<step id=\"sasl-auth-end\">\n<para>\n  Finally, when the authentication exchange is completed successfully, the\n  server sends an AuthenticationSASLFinal message, followed\n  immediately by an AuthenticationOk message. The AuthenticationSASLFinal\n  contains additional server-to-client data, whose content is particular to the\n  selected authentication mechanism. If the authentication mechanism doesn't\n  use additional data that's sent at completion, the AuthenticationSASLFinal\n  message is not sent.\n</para>\n</step>\n</procedure>\n\n<para>\nOn error, the server can abort the authentication at any stage, and send an\nErrorMessage.\n</para>\n\n <sect2 id=\"sasl-scram-sha-256\">\n  <title>SCRAM-SHA-256 Authentication</title>\n\n  <para>\n   The implemented SASL mechanisms at the moment\n   are <literal>SCRAM-SHA-256</literal> and its variant with channel\n   binding <literal>SCRAM-SHA-256-PLUS</literal>. They are described in\n   detail in <ulink url=\"https://tools.ietf.org/html/rfc7677\">RFC 7677</ulink>\n   and <ulink url=\"https://tools.ietf.org/html/rfc5802\">RFC 5802</ulink>.\n  </para>\n\n  <para>\nWhen SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name\nthat the client sends in the <structname>client-first-message</structname>. The user name\nthat was already sent in the startup message is used instead.\n<productname>PostgreSQL</productname> supports multiple character encodings, while SCRAM\ndictates UTF-8 to be used for the user name, so it might be impossible to\nrepresent the PostgreSQL user name in UTF-8.\n  </para>\n\n  <para>\nThe SCRAM specification dictates that the password is also in UTF-8, and is\nprocessed with the <firstterm>SASLprep</firstterm> algorithm.\n<productname>PostgreSQL</productname>, however, does not require UTF-8 to be used for\nthe password. When a user's password is set, it is processed with SASLprep\nas if it was in UTF-8, regardless of the actual encoding used. However, if\nit is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences\nthat are prohibited by the SASLprep algorithm, the raw password will be used\nwithout SASLprep processing, instead of throwing an error. This allows the\npassword to be normalized when it is in UTF-8, but still allows a non-UTF-8\npassword to be used, and doesn't require the system to know which encoding\nthe password is in.\n  </para>\n\n  <para>\n<firstterm>Channel binding</firstterm> is supported in PostgreSQL builds with\nSSL support. The SASL mechanism name for SCRAM with channel binding is\n<literal>SCRAM-SHA-256-PLUS</literal>.  The channel binding type used by\nPostgreSQL is <literal>tls-server-end-point</literal>.\n  </para>\n\n  <para>\n   In <acronym>SCRAM</acronym> without channel binding, the server chooses\n   a random number that is transmitted to the client to be mixed with the\n   user-supplied password in the transmitted password hash.  While this\n   prevents the password hash from being successfully retransmitted in\n   a later session, it does not prevent a fake server between the real\n   server and client from passing through the server's random value\n   and successfully authenticating.\n  </para>\n\n  <para>\n   <acronym>SCRAM</acronym> with channel binding prevents such\n   man-in-the-middle attacks by mixing the signature of the server's\n   certificate into the transmitted password hash. While a fake server can\n   retransmit the real server's certificate, it doesn't have access to the\n   private key matching that certificate, and therefore cannot prove it is\n   the owner, causing SSL connection failure.\n  </para>\n\n<procedure>\n<title>Example</title>\n  <step id=\"scram-begin\">\n<para>\n  The server sends an AuthenticationSASL message. It includes a list of\n  SASL authentication mechanisms that the server can accept.\n  This will be <literal>SCRAM-SHA-256-PLUS</literal>\n  and <literal>SCRAM-SHA-256</literal> if the server is built with SSL\n  support, or else just the latter.\n</para>\n</step>\n<step id=\"scram-client-first\">\n<para>\n  The client responds by sending a SASLInitialResponse message, which\n  indicates the chosen mechanism, <literal>SCRAM-SHA-256</literal> or\n  <literal>SCRAM-SHA-256-PLUS</literal>. (A client is free to choose either\n  mechanism, but for better security it should choose the channel-binding\n  variant if it can support it.) In the Initial Client response field, the\n  message contains the SCRAM <structname>client-first-message</structname>.\n  The <structname>client-first-message</structname> also contains the channel\n  binding type chosen by the client.\n</para>\n</step>\n<step id=\"scram-server-first\">\n<para>\n  Server sends an AuthenticationSASLContinue message, with a SCRAM\n  <structname>server-first-message</structname> as the content.\n</para>\n</step>\n<step id=\"scram-client-final\">\n<para>\n  Client sends a SASLResponse message, with SCRAM\n  <structname>client-final-message</structname> as the content.\n</para>\n</step>\n<step id=\"scram-server-final\">\n<para>\n  Server sends an AuthenticationSASLFinal message, with the SCRAM\n  <structname>server-final-message</structname>, followed immediately by\n  an AuthenticationOk message.\n</para>\n</step>\n</procedure>\n</sect2>\n</sect1>\n\n<sect1 id=\"protocol-replication\">\n<title>Streaming Replication Protocol</title>\n\n<para>\nTo initiate streaming replication, the frontend sends the\n<literal>replication</literal> parameter in the startup message. A Boolean\nvalue of <literal>true</literal> (or <literal>on</literal>,\n<literal>yes</literal>, <literal>1</literal>) tells the backend to go into\nphysical replication walsender mode, wherein a small set of replication\ncommands, shown below, can be issued instead of SQL statements.\n</para>\n\n<para>\nPassing <literal>database</literal> as the value for the\n<literal>replication</literal> parameter instructs the backend to go into\nlogical replication walsender mode, connecting to the database specified in\nthe <literal>dbname</literal> parameter.  In logical replication walsender\nmode, the replication commands shown below as well as normal SQL commands can\nbe issued.\n</para>\n\n<para>\nIn either physical replication or logical replication walsender mode, only the\nsimple query protocol can be used.\n</para>\n\n<para>\n For the purpose of testing replication commands, you can make a replication\n connection via <application>psql</application> or any other\n <application>libpq</application>-using tool with a connection string including\n the <literal>replication</literal> option,\n e.g.:\n<programlisting>\npsql \"dbname=postgres replication=database\" -c \"IDENTIFY_SYSTEM;\"\n</programlisting>\n However, it is often more useful to use\n <xref linkend=\"app-pgreceivewal\"/> (for physical replication) or\n <xref linkend=\"app-pgrecvlogical\"/> (for logical replication).\n</para>\n\n<para>\nReplication commands are logged in the server log when\n<xref linkend=\"guc-log-replication-commands\"/> is enabled.\n</para>\n\n<para>\nThe commands accepted in replication mode are:\n<variablelist>\n  <varlistentry>\n    <term><literal>IDENTIFY_SYSTEM</literal>\n     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Requests the server to identify itself. Server replies with a result\n      set of a single row, containing four fields:\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n       <literal>systemid</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       The unique system identifier identifying the cluster. This\n       can be used to check that the base backup used to initialize the\n       standby came from the same cluster.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      <varlistentry>\n      <term>\n       <literal>timeline</literal> (<type>int4</type>)\n      </term>\n      <listitem>\n      <para>\n       Current timeline ID. Also useful to check that the standby is\n       consistent with the primary.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      <varlistentry>\n      <term>\n       <literal>xlogpos</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       Current WAL flush location. Useful to get a known location in the\n       write-ahead log where streaming can start.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      <varlistentry>\n      <term>\n       <literal>dbname</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       Database connected to or null.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>SHOW</literal> <replaceable class=\"parameter\">name</replaceable>\n     <indexterm><primary>SHOW</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Requests the server to send the current setting of a run-time parameter.\n      This is similar to the SQL command <xref linkend=\"sql-show\"/>.\n     </para>\n\n     <variablelist>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">name</replaceable></term>\n       <listitem>\n         <para>\n          The name of a run-time parameter. Available parameters are documented\n          in <xref linkend=\"runtime-config\"/>.\n         </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>TIMELINE_HISTORY</literal> <replaceable class=\"parameter\">tli</replaceable>\n     <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Requests the server to send over the timeline history file for timeline\n      <replaceable class=\"parameter\">tli</replaceable>.  Server replies with a\n      result set of a single row, containing two fields.  While the fields\n      are labeled as <type>text</type>, they effectively return raw bytes,\n      with no encoding conversion:\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n       <literal>filename</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       File name of the timeline history file, e.g., <filename>00000002.history</filename>.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      <varlistentry>\n      <term>\n       <literal>content</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       Contents of the timeline history file.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry id=\"protocol-replication-create-slot\" xreflabel=\"CREATE_REPLICATION_SLOT\">\n   <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> | <literal>LOGICAL</literal> } [ ( <replaceable class=\"parameter\">option</replaceable> [, ...] ) ]\n     <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Create a physical or logical replication\n      slot. See <xref linkend=\"streaming-replication-slots\"/> for more about\n      replication slots.\n     </para>\n     <variablelist>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">slot_name</replaceable></term>\n       <listitem>\n         <para>\n          The name of the slot to create. Must be a valid replication slot\n          name (see <xref linkend=\"streaming-replication-slots-manipulation\"/>).\n         </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><replaceable class=\"parameter\">output_plugin</replaceable></term>\n       <listitem>\n         <para>\n          The name of the output plugin used for logical decoding\n          (see <xref linkend=\"logicaldecoding-output-plugin\"/>).\n         </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><literal>TEMPORARY</literal></term>\n       <listitem>\n        <para>\n         Specify that this replication slot is a temporary one. Temporary\n         slots are not saved to disk and are automatically dropped on error\n         or when the session has finished.\n        </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n\n     <para>The following options are supported:</para>\n\n     <variablelist>\n      <varlistentry>\n       <term><literal>TWO_PHASE [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n       <listitem>\n        <para>\n         If true, this logical replication slot supports decoding of two-phase\n         transactions. With this option, two-phase commands like\n         <literal>PREPARE TRANSACTION</literal>, <literal>COMMIT PREPARED</literal>\n         and <literal>ROLLBACK PREPARED</literal> are decoded and transmitted.\n         The transaction will be decoded and transmitted at\n         <literal>PREPARE TRANSACTION</literal> time.\n         The default is false.\n        </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><literal>RESERVE_WAL [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n       <listitem>\n        <para>\n         If true, this physical replication slot reserves <acronym>WAL</acronym>\n         immediately.  Otherwise, <acronym>WAL</acronym> is only reserved upon\n         connection from a streaming replication client.\n         The default is false.\n        </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><literal>SNAPSHOT { 'export' | 'use' | 'nothing' }</literal></term>\n       <listitem>\n        <para>\n         Decides what to do with the snapshot created during logical slot\n         initialization. <literal>'export'</literal>, which is the default,\n         will export the snapshot for use in other sessions. This option can't\n         be used inside a transaction.  <literal>'use'</literal> will use the\n         snapshot for the current transaction executing the command. This\n         option must be used in a transaction, and\n         <literal>CREATE_REPLICATION_SLOT</literal> must be the first command\n         run in that transaction.  Finally, <literal>'nothing'</literal> will\n         just use the snapshot for logical decoding as normal but won't do\n         anything else with it.\n        </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n\n     <para>\n      In response to this command, the server will send a one-row result set\n      containing the following fields:\n\n      <variablelist>\n       <varlistentry>\n        <term><literal>slot_name</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The name of the newly-created replication slot.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>consistent_point</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The WAL location at which the slot became consistent.  This is the\n          earliest location from which streaming can start on this replication\n          slot.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>snapshot_name</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The identifier of the snapshot exported by the command.  The\n          snapshot is valid until a new command is executed on this connection\n          or the replication connection is closed.  Null if the created slot\n          is physical.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>output_plugin</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The name of the output plugin used by the newly-created replication\n          slot.  Null if the created slot is physical.\n         </para>\n        </listitem>\n       </varlistentry>\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable class=\"parameter\">output_plugin</replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | <literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> | <literal>TWO_PHASE</literal> ] }\n    </term>\n    <listitem>\n     <para>\n      For compatibility with older releases, this alternative syntax for\n      the <literal>CREATE_REPLICATION_SLOT</literal> command is still supported.\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>READ_REPLICATION_SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable>\n      <indexterm><primary>READ_REPLICATION_SLOT</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Read some information associated to a replication slot. Returns a tuple\n      with <literal>NULL</literal> values if the replication slot does not\n      exist. This command is currently only supported for physical replication\n      slots.\n     </para>\n     <para>\n      In response to this command, the server will return a one-row result set,\n      containing the following fields:\n      <variablelist>\n       <varlistentry>\n        <term><literal>slot_type</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The replication slot's type, either <literal>physical</literal> or\n          <literal>NULL</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>restart_lsn</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The replication slot's <literal>restart_lsn</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>restart_tli</literal> (<type>int8</type>)</term>\n        <listitem>\n         <para>\n          The timeline ID associated to <literal>restart_lsn</literal>,\n          following the current timeline history.\n         </para>\n        </listitem>\n       </varlistentry>\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class=\"parameter\">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class=\"parameter\">tli</replaceable> ]\n     <indexterm><primary>START_REPLICATION</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Instructs server to start streaming WAL, starting at\n      WAL location <replaceable class=\"parameter\">XXX/XXX</replaceable>.\n      If <literal>TIMELINE</literal> option is specified,\n      streaming starts on timeline <replaceable class=\"parameter\">tli</replaceable>;\n      otherwise, the server's current timeline is selected. The server can\n      reply with an error, for example if the requested section of WAL has already\n      been recycled. On success, server responds with a CopyBothResponse\n      message, and then starts to stream WAL to the frontend.\n     </para>\n\n     <para>\n      If a slot's name is provided\n      via <replaceable class=\"parameter\">slot_name</replaceable>, it will be updated\n      as replication progresses so that the server knows which WAL segments,\n      and if <varname>hot_standby_feedback</varname> is on which transactions,\n      are still needed by the standby.\n     </para>\n\n     <para>\n      If the client requests a timeline that's not the latest but is part of\n      the history of the server, the server will stream all the WAL on that\n      timeline starting from the requested start point up to the point where\n      the server switched to another timeline. If the client requests\n      streaming at exactly the end of an old timeline, the server skips COPY\n      mode entirely.\n     </para>\n\n     <para>\n      After streaming all the WAL on a timeline that is not the latest one,\n      the server will end streaming by exiting the COPY mode. When the client\n      acknowledges this by also exiting COPY mode, the server sends a result\n      set with one row and two columns, indicating the next timeline in this\n      server's history. The first column is the next timeline's ID (type <type>int8</type>), and the\n      second column is the WAL location where the switch happened (type <type>text</type>). Usually,\n      the switch position is the end of the WAL that was streamed, but there\n      are corner cases where the server can send some WAL from the old\n      timeline that it has not itself replayed before promoting. Finally, the\n      server sends two CommandComplete messages (one that ends the CopyData\n      and the other ends the <literal>START_REPLICATION</literal> itself), and\n      is ready to accept a new command.\n     </para>\n\n     <para>\n      WAL data is sent as a series of CopyData messages.  (This allows\n      other information to be intermixed; in particular the server can send\n      an ErrorResponse message if it encounters a failure after beginning\n      to stream.)  The payload of each CopyData message from server to the\n      client contains a message of one of the following formats:\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          XLogData (B)\n      </term>\n      <listitem>\n      <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Byte1('w')\n      </term>\n      <listitem>\n      <para>\n          Identifies the message as WAL data.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The starting point of the WAL data in this message.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The current end of WAL on the server.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The server's system clock at the time of transmission, as\n          microseconds since midnight on 2000-01-01.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Byte<replaceable>n</replaceable>\n      </term>\n      <listitem>\n      <para>\n          A section of the WAL data stream.\n      </para>\n      <para>\n          A single WAL record is never split across two XLogData messages.\n          When a WAL record crosses a WAL page boundary, and is therefore\n          already split using continuation records, it can be split at the page\n          boundary. In other words, the first main WAL record and its\n          continuation records can be sent in different XLogData messages.\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Primary keepalive message (B)\n      </term>\n      <listitem>\n      <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Byte1('k')\n      </term>\n      <listitem>\n      <para>\n          Identifies the message as a sender keepalive.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The current end of WAL on the server.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The server's system clock at the time of transmission, as\n          microseconds since midnight on 2000-01-01.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Byte1\n      </term>\n      <listitem>\n      <para>\n          1 means that the client should reply to this message as soon as\n          possible, to avoid a timeout disconnect. 0 otherwise.\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n     </para>\n\n     <para>\n       The receiving process can send replies back to the sender at any time,\n       using one of the following message formats (also in the payload of a\n       CopyData message):\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Standby status update (F)\n      </term>\n      <listitem>\n      <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Byte1('r')\n      </term>\n      <listitem>\n      <para>\n          Identifies the message as a receiver status update.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The location of the last WAL byte + 1 received and written to disk\n          in the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The location of the last WAL byte + 1 flushed to disk in\n          the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The location of the last WAL byte + 1 applied in the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The client's system clock at the time of transmission, as\n          microseconds since midnight on 2000-01-01.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Byte1\n      </term>\n      <listitem>\n      <para>\n          If 1, the client requests the server to reply to this message\n          immediately. This can be used to ping the server, to test if\n          the connection is still healthy.\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Hot Standby feedback message (F)\n      </term>\n      <listitem>\n      <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Byte1('h')\n      </term>\n      <listitem>\n      <para>\n          Identifies the message as a Hot Standby feedback message.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The client's system clock at the time of transmission, as\n          microseconds since midnight on 2000-01-01.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int32\n      </term>\n      <listitem>\n      <para>\n          The standby's current global xmin, excluding the catalog_xmin from any\n          replication slots. If both this value and the following\n          catalog_xmin are 0 this is treated as a notification that Hot Standby\n          feedback will no longer be sent on this connection. Later non-zero\n          messages may reinitiate the feedback mechanism.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int32\n      </term>\n      <listitem>\n      <para>\n          The epoch of the global xmin xid on the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int32\n      </term>\n      <listitem>\n      <para>\n          The lowest catalog_xmin of any replication slots on the standby. Set to 0\n          if no catalog_xmin exists on the standby or if hot standby feedback is being\n          disabled.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int32\n      </term>\n      <listitem>\n      <para>\n          The epoch of the catalog_xmin xid on the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n  <varlistentry>\n    <term><literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> <literal>LOGICAL</literal> <replaceable class=\"parameter\">XXX/XXX</replaceable> [ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</replaceable> ] [, ...] ) ]</term>\n    <listitem>\n     <para>\n      Instructs server to start streaming WAL for logical replication,\n      starting at either WAL location <replaceable\n      class=\"parameter\">XXX/XXX</replaceable> or the slot's\n      <literal>confirmed_flush_lsn</literal> (see <xref\n      linkend=\"view-pg-replication-slots\"/>), whichever is greater. This\n      behavior makes it easier for clients to avoid updating their local LSN\n      status when there is no data to process. However, starting at a\n      different LSN than requested might not catch certain kinds of client\n      errors; so the client may wish to check that\n      <literal>confirmed_flush_lsn</literal> matches its expectations before\n      issuing <literal>START_REPLICATION</literal>.\n     </para>\n\n     <para>\n      The server can reply with an error, for example if the\n      slot does not exist. On success, server responds with a CopyBothResponse\n      message, and then starts to stream WAL to the frontend.\n     </para>\n\n     <para>\n      The messages inside the CopyBothResponse messages are of the same format\n      documented for <literal>START_REPLICATION ... PHYSICAL</literal>, including\n      two CommandComplete messages.\n     </para>\n\n     <para>\n      The output plugin associated with the selected slot is used\n      to process the output for streaming.\n     </para>\n\n     <variablelist>\n      <varlistentry>\n       <term><literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable></term>\n       <listitem>\n         <para>\n          The name of the slot to stream changes from. This parameter is required,\n          and must correspond to an existing logical replication slot created\n          with <literal>CREATE_REPLICATION_SLOT</literal> in\n          <literal>LOGICAL</literal> mode.\n         </para>\n       </listitem>\n      </varlistentry>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">XXX/XXX</replaceable></term>\n       <listitem>\n        <para>\n         The WAL location to begin streaming at.\n        </para>\n       </listitem>\n      </varlistentry>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">option_name</replaceable></term>\n       <listitem>\n        <para>\n         The name of an option passed to the slot's logical decoding plugin.\n        </para>\n       </listitem>\n      </varlistentry>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">option_value</replaceable></term>\n       <listitem>\n        <para>\n         Optional value, in the form of a string constant, associated with the\n         specified option.\n        </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term>\n     <literal>DROP_REPLICATION_SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> <optional> <literal>WAIT</literal> </optional>\n     <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Drops a replication slot, freeing any reserved server-side resources.\n      If the slot is a logical slot that was created in a database other than\n      the database the walsender is connected to, this command fails.\n     </para>\n     <variablelist>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">slot_name</replaceable></term>\n       <listitem>\n         <para>\n          The name of the slot to drop.\n         </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><literal>WAIT</literal></term>\n       <listitem>\n        <para>\n         This option causes the command to wait if the slot is active until\n         it becomes inactive, instead of the default behavior of raising an\n         error.\n        </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry id=\"protocol-replication-base-backup\" xreflabel=\"BASE_BACKUP\">\n    <term><literal>BASE_BACKUP</literal> [ ( <replaceable class=\"parameter\">option</replaceable> [, ...] ) ]\n     <indexterm><primary>BASE_BACKUP</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Instructs the server to start streaming a base backup.\n      The system will automatically be put in backup mode before the backup\n      is started, and taken out of it when the backup is complete. The\n      following options are accepted:\n      <variablelist>\n       <varlistentry>\n        <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>\n        <listitem>\n         <para>\n          Sets the label of the backup. If none is specified, a backup label\n          of <literal>base backup</literal> will be used. The quoting rules\n          for the label are the same as a standard SQL string with\n          <xref linkend=\"guc-standard-conforming-strings\"/> turned on.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>PROGRESS [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If set to true, request information required to generate a progress\n          report. This will send back an approximate size in the header of each\n          tablespace, which can be used to calculate how far along the stream\n          is done. This is calculated by enumerating all the file sizes once\n          before the transfer is even started, and might as such have a\n          negative impact on the performance.  In particular, it might take\n          longer before the first data\n          is streamed. Since the database files can change during the backup,\n          the size is only approximate and might both grow and shrink between\n          the time of approximation and the sending of the actual files.\n          The default is false.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>CHECKPOINT { 'fast' | 'spread' }</literal></term>\n        <listitem>\n         <para>\n          Sets the type of checkpoint to be performed at the beginning of the\n          base backup. The default is <literal>spread</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>WAL [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If set to true, include the necessary WAL segments in the backup.\n          This will include all the files between start and stop backup in the\n          <filename>pg_wal</filename> directory of the base directory tar\n          file. The default is false.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>WAIT [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If set to true, the backup will wait until the last required WAL\n          segment has been archived, or emit a warning if log archiving is\n          not enabled. If false, the backup will neither wait nor warn,\n          leaving the client responsible for ensuring the required log is\n          available. The default is true.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>MAX_RATE</literal> <replaceable>rate</replaceable></term>\n        <listitem>\n         <para>\n          Limit (throttle) the maximum amount of data transferred from server\n          to client per unit of time.  The expected unit is kilobytes per second.\n          If this option is specified, the value must either be equal to zero\n          or it must fall within the range from 32 kB through 1 GB (inclusive).\n          If zero is passed or the option is not specified, no restriction is\n          imposed on the transfer.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>TABLESPACE_MAP [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If true, include information about symbolic links present in the\n          directory <filename>pg_tblspc</filename> in a file named\n          <filename>tablespace_map</filename>. The tablespace map file includes\n          each symbolic link name as it exists in the directory\n          <filename>pg_tblspc/</filename> and the full path of that symbolic link.\n          The default is false.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>VERIFY_CHECKSUMS [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If true, checksums are verified during a base backup if they are\n          enabled. If false, this is skipped. The default is true.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>MANIFEST</literal> <replaceable>manifest_option</replaceable></term>\n        <listitem>\n         <para>\n          When this option is specified with a value of <literal>yes</literal>\n          or <literal>force-encode</literal>, a backup manifest is created\n          and sent along with the backup.  The manifest is a list of every\n          file present in the backup with the exception of any WAL files that\n          may be included. It also stores the size, last modification time, and\n          optionally a checksum for each file.\n          A value of <literal>force-encode</literal> forces all filenames\n          to be hex-encoded; otherwise, this type of encoding is performed only\n          for files whose names are non-UTF8 octet sequences.\n          <literal>force-encode</literal> is intended primarily for testing\n          purposes, to be sure that clients which read the backup manifest\n          can handle this case. For compatibility with previous releases,\n          the default is <literal>MANIFEST 'no'</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable></term>\n        <listitem>\n         <para>\n          Specifies the checksum algorithm that should be applied to each file included\n          in the backup manifest. Currently, the available\n          algorithms are <literal>NONE</literal>, <literal>CRC32C</literal>,\n          <literal>SHA224</literal>, <literal>SHA256</literal>,\n          <literal>SHA384</literal>, and <literal>SHA512</literal>.\n          The default is <literal>CRC32C</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n      </variablelist>\n     </para>\n     <para>\n      When the backup is started, the server will first send two\n      ordinary result sets, followed by one or more CopyOutResponse\n      results.\n     </para>\n     <para>\n      The first ordinary result set contains the starting position of the\n      backup, in a single row with two columns. The first column contains\n      the start position given in XLogRecPtr format, and the second column\n      contains the corresponding timeline ID.\n     </para>\n     <para>\n      The second ordinary result set has one row for each tablespace.\n      The fields in this row are:\n      <variablelist>\n       <varlistentry>\n        <term><literal>spcoid</literal> (<type>oid</type>)</term>\n        <listitem>\n         <para>\n          The OID of the tablespace, or null if it's the base\n          directory.\n         </para>\n        </listitem>\n       </varlistentry>\n       <varlistentry>\n        <term><literal>spclocation</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The full path of the tablespace directory, or null\n          if it's the base directory.\n         </para>\n        </listitem>\n       </varlistentry>\n       <varlistentry>\n        <term><literal>size</literal> (<type>int8</type>)</term>\n        <listitem>\n         <para>\n          The approximate size of the tablespace, in kilobytes (1024 bytes),\n          if progress report has been requested; otherwise it's null.\n         </para>\n        </listitem>\n       </varlistentry>\n      </variablelist>\n     </para>\n\n     <para>\n      After the second regular result set, one or more CopyOutResponse results\n      will be sent, one for the main data directory and one for each additional tablespace other\n      than <literal>pg_default</literal> and <literal>pg_global</literal>. The data in\n      the CopyOutResponse results will be a tar format (following the\n      <quote>ustar interchange format</quote> specified in the POSIX 1003.1-2008\n      standard) dump of the tablespace contents, except that the two trailing\n      blocks of zeroes specified in the standard are omitted.\n      After the tar data is complete, and if a backup manifest was requested,\n      another CopyOutResponse result is sent, containing the manifest data for the\n      current base backup. In any case, a final ordinary result set will be\n      sent, containing the WAL end position of the backup, in the same format as\n      the start position.\n     </para>\n\n     <para>\n      The tar archive for the data directory and each tablespace will contain\n      all files in the directories, regardless of whether they are\n      <productname>PostgreSQL</productname> files or other files added to the same\n      directory. The only excluded files are:\n      <itemizedlist spacing=\"compact\" mark=\"bullet\">\n       <listitem>\n        <para>\n         <filename>postmaster.pid</filename>\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         <filename>postmaster.opts</filename>\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         <filename>pg_internal.init</filename> (found in multiple directories)\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         Various temporary files and directories created during the operation\n         of the PostgreSQL server, such as any file or directory beginning\n         with <filename>pgsql_tmp</filename> and temporary relations.\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         Unlogged relations, except for the init fork which is required to\n         recreate the (empty) unlogged relation on recovery.\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         <filename>pg_wal</filename>, including subdirectories. If the backup is run\n         with WAL files included, a synthesized version of <filename>pg_wal</filename> will be\n         included, but it will only contain the files necessary for the\n         backup to work, not the rest of the contents.\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         <filename>pg_dynshmem</filename>, <filename>pg_notify</filename>,\n         <filename>pg_replslot</filename>, <filename>pg_serial</filename>,\n         <filename>pg_snapshots</filename>, <filename>pg_stat_tmp</filename>, and\n         <filename>pg_subtrans</filename> are copied as empty directories (even if\n         they are symbolic links).\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         Files other than regular files and directories, such as symbolic\n         links (other than for the directories listed above) and special\n         device files, are skipped.  (Symbolic links\n         in <filename>pg_tblspc</filename> are maintained.)\n        </para>\n       </listitem>\n      </itemizedlist>\n      Owner, group, and file mode are set if the underlying file system on\n      the server supports it.\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ] [ <literal>MANIFEST</literal> <replaceable>manifest_option</replaceable> ] [ <literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable> ]\n    </term>\n    <listitem>\n     <para>\n      For compatibility with older releases, this alternative syntax for\n      the <literal>BASE_BACKUP</literal> command is still supported.\n     </para>\n    </listitem>\n  </varlistentry>\n</variablelist>\n\n</para>\n\n</sect1>\n\n<sect1 id=\"protocol-logical-replication\">\n <title>Logical Streaming Replication Protocol</title>\n\n <para>\n  This section describes the logical replication protocol, which is the message\n  flow started by the <literal>START_REPLICATION</literal>\n  <literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable>\n  <literal>LOGICAL</literal> replication command.\n </para>\n\n <para>\n  The logical streaming replication protocol builds on the primitives of\n  the physical streaming replication protocol.\n </para>\n\n <sect2 id=\"protocol-logical-replication-params\">\n  <title>Logical Streaming Replication Parameters</title>\n\n  <para>\n   The logical replication <literal>START_REPLICATION</literal> command\n   accepts following parameters:\n\n   <variablelist>\n    <varlistentry>\n     <term>\n      proto_version\n     </term>\n     <listitem>\n      <para>\n       Protocol version. Currently versions <literal>1</literal>, <literal>2</literal>,\n       and <literal>3</literal> are supported.\n      </para>\n      <para>\n       Version <literal>2</literal> is supported only for server version 14\n       and above, and it allows streaming of large in-progress transactions.\n      </para>\n      <para>\n       Version <literal>3</literal> is supported only for server version 15\n       and above, and it allows streaming of two-phase transactions.\n      </para>\n     </listitem>\n    </varlistentry>\n\n    <varlistentry>\n     <term>\n      publication_names\n     </term>\n     <listitem>\n      <para>\n       Comma separated list of publication names for which to subscribe\n       (receive changes). The individual publication names are treated\n       as standard objects names and can be quoted the same as needed.\n      </para>\n     </listitem>\n    </varlistentry>\n   </variablelist>\n\n  </para>\n </sect2>\n\n <sect2 id=\"protocol-logical-messages\">\n  <title>Logical Replication Protocol Messages</title>\n\n  <para>\n   The individual protocol messages are discussed in the following\n   subsections. Individual messages are described in\n   <xref linkend=\"protocol-logicalrep-message-formats\"/>.\n  </para>\n\n  <para>\n   All top-level protocol messages begin with a message type byte.\n   While represented in code as a character, this is a signed byte with no\n   associated encoding.\n  </para>\n\n  <para>\n   Since the streaming replication protocol supplies a message length there\n   is no need for top-level protocol messages to embed a length in their\n   header.\n  </para>\n\n </sect2>\n\n <sect2 id=\"protocol-logical-messages-flow\">\n  <title>Logical Replication Protocol Message Flow</title>\n\n  <para>\n   With the exception of the <literal>START_REPLICATION</literal> command and\n   the replay progress messages, all information flows only from the backend\n   to the frontend.\n  </para>\n\n  <para>\n   The logical replication protocol sends individual transactions one by one.\n   This means that all messages between a pair of Begin and Commit messages\n   belong to the same transaction. Similarly, all messages between a pair of\n   Begin Prepare and Prepare messages belong to the same transaction.\n   It also sends changes of large in-progress transactions between a pair of\n   Stream Start and Stream Stop messages. The last stream of such a transaction\n   contains a Stream Commit or Stream Abort message.\n  </para>\n\n  <para>\n   Every sent transaction contains zero or more DML messages (Insert,\n   Update, Delete). In case of a cascaded setup it can also contain Origin\n   messages. The origin message indicates that the transaction originated on\n   different replication node. Since a replication node in the scope of logical\n   replication protocol can be pretty much anything, the only identifier\n   is the origin name. It's downstream's responsibility to handle this as\n   needed (if needed). The Origin message is always sent before any DML\n   messages in the transaction.\n  </para>\n\n  <para>\n   Every DML message contains an arbitrary relation ID, which can be mapped to\n   an ID in the Relation messages. The Relation messages describe the schema of the\n   given relation. The Relation message is sent for a given relation either\n   because it is the first time we send a DML message for given relation in the\n   current session or because the relation definition has changed since the\n   last Relation message was sent for it. The protocol assumes that the client\n   is capable of caching the metadata for as many relations as needed.\n  </para>\n </sect2>\n</sect1>\n\n<sect1 id=\"protocol-message-types\">\n<title>Message Data Types</title>\n\n<para>\nThis section describes the base data types used in messages.\n\n<variablelist>\n\n<varlistentry>\n<term>\n        Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)\n</term>\n<listitem>\n<para>\n                An <replaceable>n</replaceable>-bit integer in network byte\n                order (most significant byte first).\n                If <replaceable>i</replaceable> is specified it\n                is the exact value that will appear, otherwise the value\n                is variable.  Eg. Int16, Int32(42).\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]\n</term>\n<listitem>\n<para>\n                An array of <replaceable>k</replaceable>\n                <replaceable>n</replaceable>-bit integers, each in network\n                byte order.  The array length <replaceable>k</replaceable>\n                is always determined by an earlier field in the message.\n                Eg. Int16[M].\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        String(<replaceable>s</replaceable>)\n</term>\n<listitem>\n<para>\n                A null-terminated string (C-style string).  There is no\n                specific length limitation on strings.\n                If <replaceable>s</replaceable> is specified it is the exact\n                value that will appear, otherwise the value is variable.\n                Eg. String, String(\"user\").\n</para>\n\n<note>\n<para>\n<emphasis>There is no predefined limit</emphasis> on the length of a string\nthat can be returned by the backend.  Good coding strategy for a frontend\nis to use an expandable buffer so that anything that fits in memory can be\naccepted.  If that's not feasible, read the full string and discard trailing\ncharacters that don't fit into your fixed-size buffer.\n</para>\n</note>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)\n</term>\n<listitem>\n<para>\n                Exactly <replaceable>n</replaceable> bytes.  If the field\n                width <replaceable>n</replaceable> is not a constant, it is\n                always determinable from an earlier field in the message.\n                If <replaceable>c</replaceable> is specified it is the exact\n                value.  Eg. Byte2, Byte1('\\n').\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</sect1>\n\n<sect1 id=\"protocol-message-formats\">\n<title>Message Formats</title>\n\n<para>\nThis section describes the detailed format of each message.  Each is marked to\nindicate that it can be sent by a frontend (F), a backend (B), or both\n(F &amp; B).\nNotice that although each message includes a byte count at the beginning,\nthe message format is defined so that the message end can be found without\nreference to the byte count.  This aids validity checking.  (The CopyData\nmessage is an exception, because it forms part of a data stream; the contents\nof any individual CopyData message cannot be interpretable on their own.)\n</para>\n\n<variablelist>\n\n\n<varlistentry>\n<term>\nAuthenticationOk (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(0)\n</term>\n<listitem>\n<para>\n                Specifies that the authentication was successful.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationKerberosV5 (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(2)\n</term>\n<listitem>\n<para>\n                Specifies that Kerberos V5 authentication is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationCleartextPassword (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(3)\n</term>\n<listitem>\n<para>\n                Specifies that a clear-text password is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationMD5Password (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(12)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(5)\n</term>\n<listitem>\n<para>\n                Specifies that an MD5-encrypted password is required.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte4\n</term>\n<listitem>\n<para>\n                The salt to use when encrypting the password.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSCMCredential (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(6)\n</term>\n<listitem>\n<para>\n                Specifies that an SCM credentials message is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationGSS (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(7)\n</term>\n<listitem>\n<para>\n                Specifies that GSSAPI authentication is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationGSSContinue (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Specifies that this message contains GSSAPI or SSPI data.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                GSSAPI or SSPI authentication data.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSSPI (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(9)\n</term>\n<listitem>\n<para>\n                Specifies that SSPI authentication is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSASL (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(10)\n</term>\n<listitem>\n<para>\n                Specifies that SASL authentication is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\nThe message body is a list of SASL authentication mechanisms, in the\nserver's order of preference. A zero byte is required as terminator after\nthe last authentication mechanism name. For each mechanism, there is the\nfollowing:\n<variablelist>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of a SASL authentication mechanism.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSASLContinue (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(11)\n</term>\n<listitem>\n<para>\n                Specifies that this message contains a SASL challenge.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                SASL data, specific to the SASL mechanism being used.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSASLFinal (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(12)\n</term>\n<listitem>\n<para>\n                Specifies that SASL authentication has completed.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                SASL outcome \"additional data\", specific to the SASL mechanism\n                being used.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nBackendKeyData (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('K')\n</term>\n<listitem>\n<para>\n                Identifies the message as cancellation key data.\n                The frontend must save these values if it wishes to be\n                able to issue CancelRequest messages later.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(12)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The process ID of this backend.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The secret key of this backend.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nBind (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('B')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Bind command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the destination portal\n                (an empty string selects the unnamed portal).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the source prepared statement\n                (an empty string selects the unnamed prepared statement).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of parameter format codes that follow\n                (denoted <replaceable>C</replaceable> below).\n                This can be zero to indicate that there are no parameters\n                or that the parameters all use the default format (text);\n                or one, in which case the specified format code is applied\n                to all parameters; or it can equal the actual number of\n                parameters.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>C</replaceable>]\n</term>\n<listitem>\n<para>\n                The parameter format codes.  Each must presently be\n                zero (text) or one (binary).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of parameter values that follow (possibly zero).\n                This must match the number of parameters needed by the query.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, the following pair of fields appear for each parameter:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The length of the parameter value, in bytes (this count\n                does not include itself).  Can be zero.\n                As a special case, -1 indicates a NULL parameter value.\n                No value bytes follow in the NULL case.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the parameter, in the format indicated by the\n                associated format code.\n                <replaceable>n</replaceable> is the above length.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        After the last parameter, the following fields appear:\n<variablelist>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of result-column format codes that follow\n                (denoted <replaceable>R</replaceable> below).\n                This can be zero to indicate that there are no result columns\n                or that the result columns should all use the default format\n                (text);\n                or one, in which case the specified format code is applied\n                to all result columns (if any); or it can equal the actual\n                number of result columns of the query.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>R</replaceable>]\n</term>\n<listitem>\n<para>\n                The result-column format codes.  Each must presently be\n                zero (text) or one (binary).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nBindComplete (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('2')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Bind-complete indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCancelRequest (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int32(16)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(80877102)\n</term>\n<listitem>\n<para>\n                The cancel request code.  The value is chosen to contain\n                <literal>1234</literal> in the most significant 16 bits, and <literal>5678</literal> in the\n                least significant 16 bits.  (To avoid confusion, this code\n                must not be the same as any protocol version number.)\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The process ID of the target backend.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The secret key for the target backend.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nClose (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('C')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Close command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                '<literal>S</literal>' to close a prepared statement; or\n                '<literal>P</literal>' to close a portal.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the prepared statement or portal to close\n                (an empty string selects the unnamed prepared statement\n                or portal).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCloseComplete (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('3')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Close-complete indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCommandComplete (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('C')\n</term>\n<listitem>\n<para>\n                Identifies the message as a command-completed response.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n       <para>\n        The command tag.  This is usually a single\n        word that identifies which SQL command was completed.\n       </para>\n\n       <para>\n        For an <command>INSERT</command> command, the tag is\n        <literal>INSERT <replaceable>oid</replaceable>\n        <replaceable>rows</replaceable></literal>, where\n        <replaceable>rows</replaceable> is the number of rows\n        inserted. <replaceable>oid</replaceable> used to be the object ID\n        of the inserted row if <replaceable>rows</replaceable> was 1\n        and the target table had OIDs, but OIDs system columns are\n        not supported anymore; therefore <replaceable>oid</replaceable>\n        is always 0.\n       </para>\n\n       <para>\n        For a <command>DELETE</command> command, the tag is\n        <literal>DELETE <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows deleted.\n       </para>\n\n       <para>\n        For an <command>UPDATE</command> command, the tag is\n        <literal>UPDATE <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows updated.\n       </para>\n\n       <para>\n        For a <command>SELECT</command> or <command>CREATE TABLE AS</command>\n        command, the tag is <literal>SELECT <replaceable>rows</replaceable></literal>\n        where <replaceable>rows</replaceable> is the number of rows retrieved.\n       </para>\n\n       <para>\n        For a <command>MOVE</command> command, the tag is\n        <literal>MOVE <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows the\n        cursor's position has been changed by.\n       </para>\n\n       <para>\n        For a <command>FETCH</command> command, the tag is\n        <literal>FETCH <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows that\n        have been retrieved from the cursor.\n       </para>\n\n       <para>\n        For a <command>COPY</command> command, the tag is\n        <literal>COPY <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows copied.\n        (Note: the row count appears only in\n        <productname>PostgreSQL</productname> 8.2 and later.)\n       </para>\n\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyData (F &amp; B)\n</term>\n<listitem>\n<para>\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('d')\n</term>\n<listitem>\n<para>\n                Identifies the message as <command>COPY</command> data.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                Data that forms part of a <command>COPY</command> data stream.  Messages sent\n                from the backend will always correspond to single data rows,\n                but messages sent by frontends might divide the data stream\n                arbitrarily.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyDone (F &amp; B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('c')\n</term>\n<listitem>\n<para>\n                Identifies the message as a <command>COPY</command>-complete indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyFail (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('f')\n</term>\n<listitem>\n<para>\n                Identifies the message as a <command>COPY</command>-failure indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                An error message to report as the cause of failure.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyInResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('G')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Start Copy In response.\n                The frontend must now send copy-in data (if not\n                prepared to do so, send a CopyFail message).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                0 indicates the overall <command>COPY</command> format is textual (rows\n                separated by newlines, columns separated by separator\n                characters, etc).\n                1 indicates the overall copy format is binary (similar\n                to DataRow format).\n                See <xref linkend=\"sql-copy\"/>\n                for more information.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of columns in the data to be copied\n                (denoted <replaceable>N</replaceable> below).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>N</replaceable>]\n</term>\n<listitem>\n<para>\n                The format codes to be used for each column.\n                Each must presently be zero (text) or one (binary).\n                All must be zero if the overall copy format is textual.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyOutResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('H')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Start Copy Out response.\n                This message will be followed by copy-out data.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                0 indicates the overall <command>COPY</command> format\n                is textual (rows separated by newlines, columns\n                separated by separator characters, etc). 1 indicates\n                the overall copy format is binary (similar to DataRow\n                format). See <xref linkend=\"sql-copy\"/> for more information.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of columns in the data to be copied\n                (denoted <replaceable>N</replaceable> below).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>N</replaceable>]\n</term>\n<listitem>\n<para>\n                The format codes to be used for each column.\n                Each must presently be zero (text) or one (binary).\n                All must be zero if the overall copy format is textual.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyBothResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('W')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Start Copy Both response.\n                This message is used only for Streaming Replication.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                0 indicates the overall <command>COPY</command> format\n                is textual (rows separated by newlines, columns\n                separated by separator characters, etc). 1 indicates\n                the overall copy format is binary (similar to DataRow\n                format). See <xref linkend=\"sql-copy\"/> for more information.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of columns in the data to be copied\n                (denoted <replaceable>N</replaceable> below).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>N</replaceable>]\n</term>\n<listitem>\n<para>\n                The format codes to be used for each column.\n                Each must presently be zero (text) or one (binary).\n                All must be zero if the overall copy format is textual.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nDataRow (B)\n</term>\n<listitem>\n<para>\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('D')\n</term>\n<listitem>\n<para>\n                Identifies the message as a data row.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of column values that follow (possibly zero).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, the following pair of fields appear for each column:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The length of the column value, in bytes (this count\n                does not include itself).  Can be zero.\n                As a special case, -1 indicates a NULL column value.\n                No value bytes follow in the NULL case.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the column, in the format indicated by the\n                associated format code.\n                <replaceable>n</replaceable> is the above length.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nDescribe (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('D')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Describe command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                '<literal>S</literal>' to describe a prepared statement; or\n                '<literal>P</literal>' to describe a portal.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the prepared statement or portal to describe\n                (an empty string selects the unnamed prepared statement\n                or portal).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nEmptyQueryResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('I')\n</term>\n<listitem>\n<para>\n                Identifies the message as a response to an empty query string.\n                (This substitutes for CommandComplete.)\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nErrorResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('E')\n</term>\n<listitem>\n<para>\n                Identifies the message as an error.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        The message body consists of one or more identified fields,\n        followed by a zero byte as a terminator.  Fields can appear in\n        any order.  For each field there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                A code identifying the field type; if zero, this is\n                the message terminator and no string follows.\n                The presently defined field types are listed in\n                <xref linkend=\"protocol-error-fields\"/>.\n                Since more field types might be added in future,\n                frontends should silently ignore fields of unrecognized\n                type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The field value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nExecute (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('E')\n</term>\n<listitem>\n<para>\n                Identifies the message as an Execute command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the portal to execute\n                (an empty string selects the unnamed portal).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Maximum number of rows to return, if portal contains\n                a query that returns rows (ignored otherwise).  Zero\n                denotes <quote>no limit</quote>.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nFlush (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('H')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Flush command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nFunctionCall (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('F')\n</term>\n<listitem>\n<para>\n                Identifies the message as a function call.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Specifies the object ID of the function to call.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of argument format codes that follow\n                (denoted <replaceable>C</replaceable> below).\n                This can be zero to indicate that there are no arguments\n                or that the arguments all use the default format (text);\n                or one, in which case the specified format code is applied\n                to all arguments; or it can equal the actual number of\n                arguments.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>C</replaceable>]\n</term>\n<listitem>\n<para>\n                The argument format codes.  Each must presently be\n                zero (text) or one (binary).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                Specifies the number of arguments being supplied to the\n                function.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, the following pair of fields appear for each argument:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The length of the argument value, in bytes (this count\n                does not include itself).  Can be zero.\n                As a special case, -1 indicates a NULL argument value.\n                No value bytes follow in the NULL case.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the argument, in the format indicated by the\n                associated format code.\n                <replaceable>n</replaceable> is the above length.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        After the last argument, the following field appears:\n<variablelist>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The format code for the function result. Must presently be\n                zero (text) or one (binary).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nFunctionCallResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('V')\n</term>\n<listitem>\n<para>\n                Identifies the message as a function call result.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The length of the function result value, in bytes (this count\n                does not include itself).  Can be zero.\n                As a special case, -1 indicates a NULL function result.\n                No value bytes follow in the NULL case.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the function result, in the format indicated by\n                the associated format code.\n                <replaceable>n</replaceable> is the above length.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nGSSENCRequest (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(80877104)\n</term>\n<listitem>\n<para>\n                The <acronym>GSSAPI</acronym> Encryption request code.  The value is chosen to contain\n                <literal>1234</literal> in the most significant 16 bits, and <literal>5680</literal> in the\n                least significant 16 bits.  (To avoid confusion, this code\n                must not be the same as any protocol version number.)\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nGSSResponse (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('p')\n</term>\n<listitem>\n<para>\n                Identifies the message as a GSSAPI or SSPI response. Note that\n                this is also used for SASL and password response messages.\n                The exact message type can be deduced from the context.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                GSSAPI/SSPI specific message data.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nNegotiateProtocolVersion (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('v')\n</term>\n<listitem>\n<para>\n                Identifies the message as a protocol version negotiation\n                message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Newest minor protocol version supported by the server\n                for the major protocol version requested by the client.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Number of protocol options not recognized by the server.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Then, for protocol option not recognized by the server, there\n        is the following:\n<variablelist>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The option name.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nNoData (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('n')\n</term>\n<listitem>\n<para>\n                Identifies the message as a no-data indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nNoticeResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('N')\n</term>\n<listitem>\n<para>\n                Identifies the message as a notice.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        The message body consists of one or more identified fields,\n        followed by a zero byte as a terminator.  Fields can appear in\n        any order.  For each field there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                A code identifying the field type; if zero, this is\n                the message terminator and no string follows.\n                The presently defined field types are listed in\n                <xref linkend=\"protocol-error-fields\"/>.\n                Since more field types might be added in future,\n                frontends should silently ignore fields of unrecognized\n                type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The field value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nNotificationResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('A')\n</term>\n<listitem>\n<para>\n                Identifies the message as a notification response.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The process ID of the notifying backend process.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the channel that the notify has been raised on.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The <quote>payload</quote> string passed from the notifying process.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nParameterDescription (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('t')\n</term>\n<listitem>\n<para>\n                Identifies the message as a parameter description.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of parameters used by the statement\n                (can be zero).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Then, for each parameter, there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Specifies the object ID of the parameter data type.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nParameterStatus (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('S')\n</term>\n<listitem>\n<para>\n                Identifies the message as a run-time parameter status report.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the run-time parameter being reported.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The current value of the parameter.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nParse (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('P')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Parse command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the destination prepared statement\n                (an empty string selects the unnamed prepared statement).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The query string to be parsed.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of parameter data types specified\n                (can be zero).  Note that this is not an indication of\n                the number of parameters that might appear in the\n                query string, only the number that the frontend wants to\n                prespecify types for.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Then, for each parameter, there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Specifies the object ID of the parameter data type.\n                Placing a zero here is equivalent to leaving the type\n                unspecified.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nParseComplete (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('1')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Parse-complete indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nPasswordMessage (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('p')\n</term>\n<listitem>\n<para>\n                Identifies the message as a password response. Note that\n                this is also used for GSSAPI, SSPI and SASL response messages.\n                The exact message type can be deduced from the context.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The password (encrypted, if requested).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nPortalSuspended (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('s')\n</term>\n<listitem>\n<para>\n                Identifies the message as a portal-suspended indicator.\n                Note this only appears if an Execute message's row-count limit\n                was reached.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nQuery (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('Q')\n</term>\n<listitem>\n<para>\n                Identifies the message as a simple query.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The query string itself.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nReadyForQuery (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('Z')\n</term>\n<listitem>\n<para>\n                Identifies the message type.  ReadyForQuery is sent\n                whenever the backend is ready for a new query cycle.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(5)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                Current backend transaction status indicator.\n                Possible values are '<literal>I</literal>' if idle (not in\n                a transaction block); '<literal>T</literal>' if in a transaction\n                block; or '<literal>E</literal>' if in a failed transaction\n                block (queries will be rejected until block is ended).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nRowDescription (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('T')\n</term>\n<listitem>\n<para>\n                Identifies the message as a row description.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                Specifies the number of fields in a row (can be zero).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Then, for each field, there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The field name.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                If the field can be identified as a column of a specific\n                table, the object ID of the table; otherwise zero.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                If the field can be identified as a column of a specific\n                table, the attribute number of the column; otherwise zero.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The object ID of the field's data type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The data type size (see <varname>pg_type.typlen</varname>).\n                Note that negative values denote variable-width types.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The type modifier (see <varname>pg_attribute.atttypmod</varname>).\n                The meaning of the modifier is type-specific.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The format code being used for the field.  Currently will\n                be zero (text) or one (binary).  In a RowDescription\n                returned from the statement variant of Describe, the\n                format code is not yet known and will always be zero.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nSASLInitialResponse (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('p')\n</term>\n<listitem>\n<para>\n                Identifies the message as an initial SASL response. Note that\n                this is also used for GSSAPI, SSPI and password response messages.\n                The exact message type is deduced from the context.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of the SASL authentication mechanism that the client\n                selected.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of SASL mechanism specific \"Initial Client Response\" that\n                follows, or -1 if there is no Initial Response.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                SASL mechanism specific \"Initial Response\".\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nSASLResponse (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('p')\n</term>\n<listitem>\n<para>\n                Identifies the message as a SASL response. Note that\n                this is also used for GSSAPI, SSPI and password response messages.\n                The exact message type can be deduced from the context.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                SASL mechanism specific message data.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nSSLRequest (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(80877103)\n</term>\n<listitem>\n<para>\n                The <acronym>SSL</acronym> request code.  The value is chosen to contain\n                <literal>1234</literal> in the most significant 16 bits, and <literal>5679</literal> in the\n                least significant 16 bits.  (To avoid confusion, this code\n                must not be the same as any protocol version number.)\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nStartupMessage (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(196608)\n</term>\n<listitem>\n<para>\n                The protocol version number.  The most significant 16 bits are\n                the major version number (3 for the protocol described here).\n                The least significant 16 bits are the minor version number\n                (0 for the protocol described here).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        The protocol version number is followed by one or more pairs of\n        parameter name and value strings.  A zero byte is required as a\n        terminator after the last name/value pair.\n        Parameters can appear in any\n        order.  <literal>user</literal> is required, others are optional.\n        Each parameter is specified as:\n<variablelist>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The parameter name.  Currently recognized names are:\n\n<variablelist>\n<varlistentry>\n<term>\n                <literal>user</literal>\n</term>\n<listitem>\n<para>\n                        The database user name to connect as.  Required;\n                        there is no default.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n                <literal>database</literal>\n</term>\n<listitem>\n<para>\n                        The database to connect to.  Defaults to the user name.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n                <literal>options</literal>\n</term>\n<listitem>\n<para>\n                        Command-line arguments for the backend.  (This is\n                        deprecated in favor of setting individual run-time\n                        parameters.)  Spaces within this string are\n                        considered to separate arguments, unless escaped with\n                        a backslash (<literal>\\</literal>); write <literal>\\\\</literal> to\n                        represent a literal backslash.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n                <literal>replication</literal>\n</term>\n<listitem>\n<para>\n                        Used to connect in streaming replication mode, where\n                        a small set of replication commands can be issued\n                        instead of SQL statements. Value can be\n                        <literal>true</literal>, <literal>false</literal>, or\n                        <literal>database</literal>, and the default is\n                        <literal>false</literal>. See\n                        <xref linkend=\"protocol-replication\"/> for details.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n                In addition to the above, other parameters may be listed.\n                Parameter names beginning with <literal>_pq_.</literal> are\n                reserved for use as protocol extensions, while others are\n                treated as run-time parameters to be set at backend start\n                time.  Such settings will be applied during backend start\n                (after parsing the command-line arguments if any) and will\n                act as session defaults.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The parameter value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nSync (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('S')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Sync command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nTerminate (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('X')\n</term>\n<listitem>\n<para>\n                Identifies the message as a termination.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n</variablelist>\n\n</sect1>\n\n\n<sect1 id=\"protocol-error-fields\">\n<title>Error and Notice Message Fields</title>\n\n<para>\nThis section describes the fields that can appear in ErrorResponse and\nNoticeResponse messages.  Each field type has a single-byte identification\ntoken.  Note that any given field type should appear at most once per\nmessage.\n</para>\n\n<variablelist>\n\n<varlistentry>\n<term>\n<literal>S</literal>\n</term>\n<listitem>\n<para>\n        Severity: the field contents are\n        <literal>ERROR</literal>, <literal>FATAL</literal>, or\n        <literal>PANIC</literal> (in an error message), or\n        <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,\n        <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message),\n        or a localized translation of one of these.  Always present.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>V</literal>\n</term>\n<listitem>\n<para>\n        Severity: the field contents are\n        <literal>ERROR</literal>, <literal>FATAL</literal>, or\n        <literal>PANIC</literal> (in an error message), or\n        <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,\n        <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message).\n        This is identical to the <literal>S</literal> field except\n        that the contents are never localized.  This is present only in\n        messages generated by <productname>PostgreSQL</productname> versions 9.6\n        and later.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>C</literal>\n</term>\n<listitem>\n<para>\n        Code: the SQLSTATE code for the error (see <xref\n        linkend=\"errcodes-appendix\"/>).  Not localizable.  Always present.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>M</literal>\n</term>\n<listitem>\n<para>\n        Message: the primary human-readable error message.\n        This should be accurate but terse (typically one line).\n        Always present.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>D</literal>\n</term>\n<listitem>\n<para>\n        Detail: an optional secondary error message carrying more\n        detail about the problem.  Might run to multiple lines.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>H</literal>\n</term>\n<listitem>\n<para>\n        Hint: an optional suggestion what to do about the problem.\n        This is intended to differ from Detail in that it offers advice\n        (potentially inappropriate) rather than hard facts.\n        Might run to multiple lines.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>P</literal>\n</term>\n<listitem>\n<para>\n        Position: the field value is a decimal ASCII integer, indicating\n        an error cursor position as an index into the original query string.\n        The first character has index 1, and positions are measured in\n        characters not bytes.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>p</literal>\n</term>\n<listitem>\n<para>\n        Internal position: this is defined the same as the <literal>P</literal>\n        field, but it is used when the cursor position refers to an internally\n        generated command rather than the one submitted by the client.\n        The <literal>q</literal> field will always appear when this field appears.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>q</literal>\n</term>\n<listitem>\n<para>\n        Internal query: the text of a failed internally-generated command.\n        This could be, for example, an SQL query issued by a PL/pgSQL function.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>W</literal>\n</term>\n<listitem>\n<para>\n        Where: an indication of the context in which the error occurred.\n        Presently this includes a call stack traceback of active\n        procedural language functions and internally-generated queries.\n        The trace is one entry per line, most recent first.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>s</literal>\n</term>\n<listitem>\n<para>\n        Schema name: if the error was associated with a specific database\n        object, the name of the schema containing that object, if any.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>t</literal>\n</term>\n<listitem>\n<para>\n        Table name: if the error was associated with a specific table, the\n        name of the table.  (Refer to the schema name field for the name of\n        the table's schema.)\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>c</literal>\n</term>\n<listitem>\n<para>\n        Column name: if the error was associated with a specific table column,\n        the name of the column.  (Refer to the schema and table name fields to\n        identify the table.)\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>d</literal>\n</term>\n<listitem>\n<para>\n        Data type name: if the error was associated with a specific data type,\n        the name of the data type.  (Refer to the schema name field for the\n        name of the data type's schema.)\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>n</literal>\n</term>\n<listitem>\n<para>\n        Constraint name: if the error was associated with a specific\n        constraint, the name of the constraint.  Refer to fields listed above\n        for the associated table or domain.  (For this purpose, indexes are\n        treated as constraints, even if they weren't created with constraint\n        syntax.)\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>F</literal>\n</term>\n<listitem>\n<para>\n        File: the file name of the source-code location where the error\n        was reported.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>L</literal>\n</term>\n<listitem>\n<para>\n        Line: the line number of the source-code location where the error\n        was reported.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>R</literal>\n</term>\n<listitem>\n<para>\n        Routine: the name of the source-code routine reporting the error.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n<note>\n <para>\n  The fields for schema name, table name, column name, data type name, and\n  constraint name are supplied only for a limited number of error types;\n  see <xref linkend=\"errcodes-appendix\"/>.  Frontends should not assume that\n  the presence of any of these fields guarantees the presence of another\n  field.  Core error sources observe the interrelationships noted above, but\n  user-defined functions may use these fields in other ways.  In the same\n  vein, clients should not assume that these fields denote contemporary\n  objects in the current database.\n </para>\n</note>\n\n<para>\nThe client is responsible for formatting displayed information to meet its\nneeds; in particular it should break long lines as needed.  Newline characters\nappearing in the error message fields should be treated as paragraph breaks,\nnot line breaks.\n</para>\n\n</sect1>\n\n<sect1 id=\"protocol-logicalrep-message-formats\">\n<title>Logical Replication Message Formats</title>\n\n<para>\nThis section describes the detailed format of each logical replication\nmessage.  These messages are either returned by the replication slot SQL\ninterface or are sent by a walsender.  In the case of a walsender they are\nencapsulated inside replication protocol WAL messages as described in\n<xref linkend=\"protocol-replication\"/>, and generally obey the same message\nflow as physical replication.\n</para>\n\n<variablelist>\n\n<varlistentry>\n<term>\nBegin\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('B')\n</term>\n<listitem>\n<para>\n                Identifies the message as a begin message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The final LSN of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem>\n<para>\n                Commit timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nMessage\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('M')\n</term>\n<listitem>\n<para>\n                Identifies the message as a logical decoding message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction (only present for streamed transactions).\n                This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                Flags; Either 0 for no flags or 1 if the logical decoding\n                message is transactional.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The LSN of the logical decoding message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The prefix of the logical decoding message.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of the content.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The content of the logical decoding message.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nCommit\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('C')\n</term>\n<listitem>\n<para>\n                Identifies the message as a commit message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem>\n<para>\n                Flags; currently unused.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The LSN of the commit.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The end LSN of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem>\n<para>\n                Commit timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nOrigin\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('O')\n</term>\n<listitem>\n<para>\n                Identifies the message as an origin message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The LSN of the commit on the origin server.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of the origin.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n\n<para>\n  Note that there can be multiple Origin messages inside a single transaction.\n</para>\n\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nRelation\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as a relation message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Namespace (empty string for <literal>pg_catalog</literal>).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Relation name.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                Replica identity setting for the relation (same as\n                <structfield>relreplident</structfield> in <structname>pg_class</structname>).\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                Number of columns.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, the following message part appears for each column (except generated columns):\n<variablelist>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                Flags for the column. Currently can be either 0 for no flags\n                or 1 which marks the column as part of the key.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of the column.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the column's data type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Type modifier of the column (<structfield>atttypmod</structfield>).\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nType\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('Y')\n</term>\n<listitem>\n<para>\n                Identifies the message as a type message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the data type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Namespace (empty string for <literal>pg_catalog</literal>).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of the data type.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nInsert\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('I')\n</term>\n<listitem>\n<para>\n                Identifies the message as an insert message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction (only present for streamed transactions).\n                This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation corresponding to the ID in the relation\n                message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte1('N')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData message as a new tuple.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        TupleData\n</term>\n<listitem>\n<para>\n                TupleData message part representing the contents of new tuple.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nUpdate\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('U')\n</term>\n<listitem>\n<para>\n                Identifies the message as an update message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation corresponding to the ID in the relation\n                message.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('K')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData submessage as a key.\n                This field is optional and is only present if\n                the update changed data in any of the column(s) that are\n                part of the REPLICA IDENTITY index.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('O')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData submessage as an old tuple.\n                This field is optional and is only present if table in which\n                the update happened has REPLICA IDENTITY set to FULL.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        TupleData\n</term>\n<listitem>\n<para>\n                TupleData message part representing the contents of the old tuple\n                or primary key. Only present if the previous 'O' or 'K' part\n                is present.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('N')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData message as a new tuple.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        TupleData\n</term>\n<listitem>\n<para>\n                TupleData message part representing the contents of a new tuple.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n\n<para>\n    The Update message may contain either a 'K' message part or an 'O' message part\n    or neither of them, but never both of them.\n</para>\n\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nDelete\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('D')\n</term>\n<listitem>\n<para>\n                Identifies the message as a delete message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation corresponding to the ID in the relation\n                message.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('K')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData submessage as a key.\n                This field is present if the table in which the delete has\n                happened uses an index as REPLICA IDENTITY.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('O')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData message as an old tuple.\n                This field is present if the table in which the delete\n                happened has REPLICA IDENTITY set to FULL.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        TupleData\n</term>\n<listitem>\n<para>\n                TupleData message part representing the contents of the old tuple\n                or primary key, depending on the previous field.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n\n<para>\n    The Delete message may contain either a 'K' message part or an 'O' message part,\n    but never both of them.\n</para>\n\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nTruncate\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('T')\n</term>\n<listitem>\n<para>\n                Identifies the message as a truncate message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Number of relations\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                Option bits for <command>TRUNCATE</command>:\n                1 for <literal>CASCADE</literal>, 2 for <literal>RESTART IDENTITY</literal>\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation corresponding to the ID in the relation\n                message.  This field is repeated for each relation.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n<para>\n\nThe following messages (Stream Start, Stream Stop, Stream Commit, and\nStream Abort) are available since protocol version 2.\n\n</para>\n\n<variablelist>\n\n<varlistentry>\n<term>\nStream Start\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('S')\n</term>\n<listitem>\n<para>\n                Identifies the message as a stream start message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                A value of 1 indicates this is the first stream segment for\n                this XID, 0 for any other stream segment.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nStream Stop\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('E')\n</term>\n<listitem>\n<para>\n                Identifies the message as a stream stop message.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nStream Commit\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('c')\n</term>\n<listitem>\n<para>\n                Identifies the message as a stream commit message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem>\n<para>\n                Flags; currently unused.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The LSN of the commit.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The end LSN of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem>\n<para>\n                Commit timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nStream Abort\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('A')\n</term>\n<listitem>\n<para>\n                Identifies the message as a stream abort message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the subtransaction (will be same as xid of the transaction for top-level\n                transactions).\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n<para>\nThe following messages (Begin Prepare, Prepare, Commit Prepared, Rollback Prepared, Stream Prepare)\nare available since protocol version 3.\n</para>\n\n<variablelist>\n\n<varlistentry>\n\n<term>Begin Prepare</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('b')</term>\n<listitem><para>\n                Identifies the message as the beginning of a two-phase transaction message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The LSN of the prepare.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Prepare timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n\n<term>Prepare</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('P')</term>\n<listitem><para>\n                Identifies the message as a two-phase prepared transaction message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem><para>\n                Flags; currently unused.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The LSN of the prepare.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Prepare timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n\n<term>Commit Prepared</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('K')</term>\n<listitem><para>\n                Identifies the message as the commit of a two-phase transaction message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem><para>\n                Flags; currently unused.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The LSN of the commit prepared.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the commit prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Commit timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n\n<term>Rollback Prepared</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('r')</term>\n<listitem><para>\n                Identifies the message as the rollback of a two-phase transaction message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem><para>\n                Flags; currently unused.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the rollback prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Prepare timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Rollback timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n\n<term>Stream Prepare</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('p')</term>\n<listitem><para>\n                Identifies the message as a two-phase stream prepare message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem><para>\n                Flags; currently unused.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The LSN of the prepare.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the prepare transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Prepare timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n<para>\n\nThe following message parts are shared by the above messages.\n\n</para>\n\n<variablelist>\n\n<varlistentry>\n<term>\nTupleData\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                Number of columns.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, one of the following submessages appears for each column (except generated columns):\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('n')\n</term>\n<listitem>\n<para>\n                Identifies the data as NULL value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Or\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('u')\n</term>\n<listitem>\n<para>\n                Identifies unchanged TOASTed value (the actual value is not\n                sent).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Or\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('t')\n</term>\n<listitem>\n<para>\n                Identifies the data as text formatted value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Or\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('b')\n</term>\n<listitem>\n<para>\n                Identifies the data as binary formatted value.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of the column value.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the column, either in binary or in text format.\n                (As specified in the preceding format byte).\n                <replaceable>n</replaceable> is the above length.\n\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n</sect1>\n\n<sect1 id=\"protocol-changes\">\n<title>Summary of Changes since Protocol 2.0</title>\n\n<para>\nThis section provides a quick checklist of changes, for the benefit of\ndevelopers trying to update existing client libraries to protocol 3.0.\n</para>\n\n<para>\nThe initial startup packet uses a flexible list-of-strings format\ninstead of a fixed format.  Notice that session default values for run-time\nparameters can now be specified directly in the startup packet.  (Actually,\nyou could do that before using the <literal>options</literal> field, but given the\nlimited width of <literal>options</literal> and the lack of any way to quote\nwhitespace in the values, it wasn't a very safe technique.)\n</para>\n\n<para>\nAll messages now have a length count immediately following the message type\nbyte (except for startup packets, which have no type byte).  Also note that\nPasswordMessage now has a type byte.\n</para>\n\n<para>\nErrorResponse and NoticeResponse ('<literal>E</literal>' and '<literal>N</literal>')\nmessages now contain multiple fields, from which the client code can\nassemble an error message of the desired level of verbosity.  Note that\nindividual fields will typically not end with a newline, whereas the single\nstring sent in the older protocol always did.\n</para>\n\n<para>\nThe ReadyForQuery ('<literal>Z</literal>') message includes a transaction status\nindicator.\n</para>\n\n<para>\nThe distinction between BinaryRow and DataRow message types is gone; the\nsingle DataRow message type serves for returning data in all formats.\nNote that the layout of DataRow has changed to make it easier to parse.\nAlso, the representation of binary values has changed: it is no longer\ndirectly tied to the server's internal representation.\n</para>\n\n<para>\nThere is a new <quote>extended query</quote> sub-protocol, which adds the frontend\nmessage types Parse, Bind, Execute, Describe, Close, Flush, and Sync, and the\nbackend message types ParseComplete, BindComplete, PortalSuspended,\nParameterDescription, NoData, and CloseComplete.  Existing clients do not\nhave to concern themselves with this sub-protocol, but making use of it\nmight allow improvements in performance or functionality.\n</para>\n\n<para>\n<command>COPY</command> data is now encapsulated into CopyData and CopyDone messages.  There\nis a well-defined way to recover from errors during <command>COPY</command>.  The special\n<quote><literal>\\.</literal></quote> last line is not needed anymore, and is not sent\nduring <command>COPY OUT</command>.\n(It is still recognized as a terminator during <command>COPY IN</command>, but its use is\ndeprecated and will eventually be removed.)  Binary <command>COPY</command> is supported.\nThe CopyInResponse and CopyOutResponse messages include fields indicating\nthe number of columns and the format of each column.\n</para>\n\n<para>\nThe layout of FunctionCall and FunctionCallResponse messages has changed.\nFunctionCall can now support passing NULL arguments to functions.  It also\ncan handle passing parameters and retrieving results in either text or\nbinary format.  There is no longer any reason to consider FunctionCall a\npotential security hole, since it does not offer direct access to internal\nserver data representations.\n</para>\n\n<para>\nThe backend sends ParameterStatus ('<literal>S</literal>') messages during connection\nstartup for all parameters it considers interesting to the client library.\nSubsequently, a ParameterStatus message is sent whenever the active value\nchanges for any of these parameters.\n</para>\n\n<para>\nThe RowDescription ('<literal>T</literal>') message carries new table OID and column\nnumber fields for each column of the described row.  It also shows the format\ncode for each column.\n</para>\n\n<para>\nThe CursorResponse ('<literal>P</literal>') message is no longer generated by\nthe backend.\n</para>\n\n<para>\nThe NotificationResponse ('<literal>A</literal>') message has an additional string\nfield, which can carry a <quote>payload</quote> string passed\nfrom the <command>NOTIFY</command> event sender.\n</para>\n\n<para>\nThe EmptyQueryResponse ('<literal>I</literal>') message used to include an empty\nstring parameter; this has been removed.\n</para>\n\n</sect1>\n\n</chapter>\n", "/*-------------------------------------------------------------------------\n *\n * fe-connect.c\n *\t  functions related to setting up a connection to the backend\n *\n * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/interfaces/libpq/fe-connect.c\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"postgres_fe.h\"\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"common/ip.h\"\n#include \"common/link-canary.h\"\n#include \"common/scram-common.h\"\n#include \"common/string.h\"\n#include \"fe-auth.h\"\n#include \"libpq-fe.h\"\n#include \"libpq-int.h\"\n#include \"mb/pg_wchar.h\"\n#include \"pg_config_paths.h\"\n#include \"port/pg_bswap.h\"\n\n#ifdef WIN32\n#include \"win32.h\"\n#ifdef _WIN32_IE\n#undef _WIN32_IE\n#endif\n#define _WIN32_IE 0x0500\n#ifdef near\n#undef near\n#endif\n#define near\n#include <shlobj.h>\n#ifdef _MSC_VER\t\t\t\t\t/* mstcpip.h is missing on mingw */\n#include <mstcpip.h>\n#endif\n#else\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#ifdef HAVE_NETINET_TCP_H\n#include <netinet/tcp.h>\n#endif\n#endif\n\n#ifdef ENABLE_THREAD_SAFETY\n#ifdef WIN32\n#include \"pthread-win32.h\"\n#else\n#include <pthread.h>\n#endif\n#endif\n\n#ifdef USE_LDAP\n#ifdef WIN32\n#include <winldap.h>\n#else\n/* OpenLDAP deprecates RFC 1823, but we want standard conformance */\n#define LDAP_DEPRECATED 1\n#include <ldap.h>\ntypedef struct timeval LDAP_TIMEVAL;\n#endif\nstatic int\tldapServiceLookup(const char *purl, PQconninfoOption *options,\n\t\t\t\t\t\t\t  PQExpBuffer errorMessage);\n#endif\n\n#ifndef WIN32\n#define PGPASSFILE \".pgpass\"\n#else\n#define PGPASSFILE \"pgpass.conf\"\n#endif\n\n/*\n * Pre-9.0 servers will return this SQLSTATE if asked to set\n * application_name in a startup packet.  We hard-wire the value rather\n * than looking into errcodes.h since it reflects historical behavior\n * rather than that of the current code.\n */\n#define ERRCODE_APPNAME_UNKNOWN \"42704\"\n\n/* This is part of the protocol so just define it */\n#define ERRCODE_INVALID_PASSWORD \"28P01\"\n/* This too */\n#define ERRCODE_CANNOT_CONNECT_NOW \"57P03\"\n\n/*\n * Cope with the various platform-specific ways to spell TCP keepalive socket\n * options.  This doesn't cover Windows, which as usual does its own thing.\n */\n#if defined(TCP_KEEPIDLE)\n/* TCP_KEEPIDLE is the name of this option on Linux and *BSD */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPIDLE\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPIDLE\"\n#elif defined(TCP_KEEPALIVE_THRESHOLD)\n/* TCP_KEEPALIVE_THRESHOLD is the name of this option on Solaris >= 11 */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPALIVE_THRESHOLD\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPALIVE_THRESHOLD\"\n#elif defined(TCP_KEEPALIVE) && defined(__darwin__)\n/* TCP_KEEPALIVE is the name of this option on macOS */\n/* Caution: Solaris has this symbol but it means something different */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPALIVE\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPALIVE\"\n#endif\n\n/*\n * fall back options if they are not specified by arguments or defined\n * by environment variables\n */\n#define DefaultHost\t\t\"localhost\"\n#define DefaultOption\t\"\"\n#ifdef USE_SSL\n#define DefaultChannelBinding\t\"prefer\"\n#else\n#define DefaultChannelBinding\t\"disable\"\n#endif\n#define DefaultTargetSessionAttrs\t\"any\"\n#ifdef USE_SSL\n#define DefaultSSLMode \"prefer\"\n#else\n#define DefaultSSLMode\t\"disable\"\n#endif\n#ifdef ENABLE_GSS\n#include \"fe-gssapi-common.h\"\n#define DefaultGSSMode \"prefer\"\n#else\n#define DefaultGSSMode \"disable\"\n#endif\n\n/* ----------\n * Definition of the conninfo parameters and their fallback resources.\n *\n * If Environment-Var and Compiled-in are specified as NULL, no\n * fallback is available. If after all no value can be determined\n * for an option, an error is returned.\n *\n * The value for the username is treated specially in conninfo_add_defaults.\n * If the value is not obtained any other way, the username is determined\n * by pg_fe_getauthname().\n *\n * The Label and Disp-Char entries are provided for applications that\n * want to use PQconndefaults() to create a generic database connection\n * dialog. Disp-Char is defined as follows:\n *\t\t\"\"\t\tNormal input field\n *\t\t\"*\"\t\tPassword field - hide value\n *\t\t\"D\"\t\tDebug option - don't show by default\n *\n * PQconninfoOptions[] is a constant static array that we use to initialize\n * a dynamically allocated working copy.  All the \"val\" fields in\n * PQconninfoOptions[] *must* be NULL.  In a working copy, non-null \"val\"\n * fields point to malloc'd strings that should be freed when the working\n * array is freed (see PQconninfoFree).\n *\n * The first part of each struct is identical to the one in libpq-fe.h,\n * which is required since we memcpy() data between the two!\n * ----------\n */\ntypedef struct _internalPQconninfoOption\n{\n\tchar\t   *keyword;\t\t/* The keyword of the option\t\t\t*/\n\tchar\t   *envvar;\t\t\t/* Fallback environment variable name\t*/\n\tchar\t   *compiled;\t\t/* Fallback compiled in default value\t*/\n\tchar\t   *val;\t\t\t/* Option's current value, or NULL\t\t*/\n\tchar\t   *label;\t\t\t/* Label for field in connect dialog\t*/\n\tchar\t   *dispchar;\t\t/* Indicates how to display this field in a\n\t\t\t\t\t\t\t\t * connect dialog. Values are: \"\" Display\n\t\t\t\t\t\t\t\t * entered value as is \"*\" Password field -\n\t\t\t\t\t\t\t\t * hide value \"D\"  Debug option - don't show\n\t\t\t\t\t\t\t\t * by default */\n\tint\t\t\tdispsize;\t\t/* Field size in characters for dialog\t*/\n\t/* ---\n\t * Anything above this comment must be synchronized with\n\t * PQconninfoOption in libpq-fe.h, since we memcpy() data\n\t * between them!\n\t * ---\n\t */\n\toff_t\t\tconnofs;\t\t/* Offset into PGconn struct, -1 if not there */\n} internalPQconninfoOption;\n\nstatic const internalPQconninfoOption PQconninfoOptions[] = {\n\t{\"service\", \"PGSERVICE\", NULL, NULL,\n\t\"Database-Service\", \"\", 20, -1},\n\n\t{\"user\", \"PGUSER\", NULL, NULL,\n\t\t\"Database-User\", \"\", 20,\n\toffsetof(struct pg_conn, pguser)},\n\n\t{\"password\", \"PGPASSWORD\", NULL, NULL,\n\t\t\"Database-Password\", \"*\", 20,\n\toffsetof(struct pg_conn, pgpass)},\n\n\t{\"passfile\", \"PGPASSFILE\", NULL, NULL,\n\t\t\"Database-Password-File\", \"\", 64,\n\toffsetof(struct pg_conn, pgpassfile)},\n\n\t{\"channel_binding\", \"PGCHANNELBINDING\", DefaultChannelBinding, NULL,\n\t\t\"Channel-Binding\", \"\", 8,\t/* sizeof(\"require\") == 8 */\n\toffsetof(struct pg_conn, channel_binding)},\n\n\t{\"connect_timeout\", \"PGCONNECT_TIMEOUT\", NULL, NULL,\n\t\t\"Connect-timeout\", \"\", 10,\t/* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, connect_timeout)},\n\n\t{\"dbname\", \"PGDATABASE\", NULL, NULL,\n\t\t\"Database-Name\", \"\", 20,\n\toffsetof(struct pg_conn, dbName)},\n\n\t{\"host\", \"PGHOST\", NULL, NULL,\n\t\t\"Database-Host\", \"\", 40,\n\toffsetof(struct pg_conn, pghost)},\n\n\t{\"hostaddr\", \"PGHOSTADDR\", NULL, NULL,\n\t\t\"Database-Host-IP-Address\", \"\", 45,\n\toffsetof(struct pg_conn, pghostaddr)},\n\n\t{\"port\", \"PGPORT\", DEF_PGPORT_STR, NULL,\n\t\t\"Database-Port\", \"\", 6,\n\toffsetof(struct pg_conn, pgport)},\n\n\t{\"client_encoding\", \"PGCLIENTENCODING\", NULL, NULL,\n\t\t\"Client-Encoding\", \"\", 10,\n\toffsetof(struct pg_conn, client_encoding_initial)},\n\n\t{\"options\", \"PGOPTIONS\", DefaultOption, NULL,\n\t\t\"Backend-Options\", \"\", 40,\n\toffsetof(struct pg_conn, pgoptions)},\n\n\t{\"application_name\", \"PGAPPNAME\", NULL, NULL,\n\t\t\"Application-Name\", \"\", 64,\n\toffsetof(struct pg_conn, appname)},\n\n\t{\"fallback_application_name\", NULL, NULL, NULL,\n\t\t\"Fallback-Application-Name\", \"\", 64,\n\toffsetof(struct pg_conn, fbappname)},\n\n\t{\"keepalives\", NULL, NULL, NULL,\n\t\t\"TCP-Keepalives\", \"\", 1,\t/* should be just '0' or '1' */\n\toffsetof(struct pg_conn, keepalives)},\n\n\t{\"keepalives_idle\", NULL, NULL, NULL,\n\t\t\"TCP-Keepalives-Idle\", \"\", 10,\t/* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, keepalives_idle)},\n\n\t{\"keepalives_interval\", NULL, NULL, NULL,\n\t\t\"TCP-Keepalives-Interval\", \"\", 10,\t/* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, keepalives_interval)},\n\n\t{\"keepalives_count\", NULL, NULL, NULL,\n\t\t\"TCP-Keepalives-Count\", \"\", 10, /* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, keepalives_count)},\n\n\t{\"tcp_user_timeout\", NULL, NULL, NULL,\n\t\t\"TCP-User-Timeout\", \"\", 10, /* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, pgtcp_user_timeout)},\n\n\t/*\n\t * ssl options are allowed even without client SSL support because the\n\t * client can still handle SSL modes \"disable\" and \"allow\". Other\n\t * parameters have no effect on non-SSL connections, so there is no reason\n\t * to exclude them since none of them are mandatory.\n\t */\n\t{\"sslmode\", \"PGSSLMODE\", DefaultSSLMode, NULL,\n\t\t\"SSL-Mode\", \"\", 12,\t\t/* sizeof(\"verify-full\") == 12 */\n\toffsetof(struct pg_conn, sslmode)},\n\n\t{\"sslcompression\", \"PGSSLCOMPRESSION\", \"0\", NULL,\n\t\t\"SSL-Compression\", \"\", 1,\n\toffsetof(struct pg_conn, sslcompression)},\n\n\t{\"sslcert\", \"PGSSLCERT\", NULL, NULL,\n\t\t\"SSL-Client-Cert\", \"\", 64,\n\toffsetof(struct pg_conn, sslcert)},\n\n\t{\"sslkey\", \"PGSSLKEY\", NULL, NULL,\n\t\t\"SSL-Client-Key\", \"\", 64,\n\toffsetof(struct pg_conn, sslkey)},\n\n\t{\"sslpassword\", NULL, NULL, NULL,\n\t\t\"SSL-Client-Key-Password\", \"*\", 20,\n\toffsetof(struct pg_conn, sslpassword)},\n\n\t{\"sslrootcert\", \"PGSSLROOTCERT\", NULL, NULL,\n\t\t\"SSL-Root-Certificate\", \"\", 64,\n\toffsetof(struct pg_conn, sslrootcert)},\n\n\t{\"sslcrl\", \"PGSSLCRL\", NULL, NULL,\n\t\t\"SSL-Revocation-List\", \"\", 64,\n\toffsetof(struct pg_conn, sslcrl)},\n\n\t{\"sslcrldir\", \"PGSSLCRLDIR\", NULL, NULL,\n\t\t\"SSL-Revocation-List-Dir\", \"\", 64,\n\toffsetof(struct pg_conn, sslcrldir)},\n\n\t{\"sslsni\", \"PGSSLSNI\", \"1\", NULL,\n\t\t\"SSL-SNI\", \"\", 1,\n\toffsetof(struct pg_conn, sslsni)},\n\n\t{\"requirepeer\", \"PGREQUIREPEER\", NULL, NULL,\n\t\t\"Require-Peer\", \"\", 10,\n\toffsetof(struct pg_conn, requirepeer)},\n\n\t{\"ssl_min_protocol_version\", \"PGSSLMINPROTOCOLVERSION\", \"TLSv1.2\", NULL,\n\t\t\"SSL-Minimum-Protocol-Version\", \"\", 8,\t/* sizeof(\"TLSv1.x\") == 8 */\n\toffsetof(struct pg_conn, ssl_min_protocol_version)},\n\n\t{\"ssl_max_protocol_version\", \"PGSSLMAXPROTOCOLVERSION\", NULL, NULL,\n\t\t\"SSL-Maximum-Protocol-Version\", \"\", 8,\t/* sizeof(\"TLSv1.x\") == 8 */\n\toffsetof(struct pg_conn, ssl_max_protocol_version)},\n\n\t/*\n\t * As with SSL, all GSS options are exposed even in builds that don't have\n\t * support.\n\t */\n\t{\"gssencmode\", \"PGGSSENCMODE\", DefaultGSSMode, NULL,\n\t\t\"GSSENC-Mode\", \"\", 8,\t/* sizeof(\"disable\") == 8 */\n\toffsetof(struct pg_conn, gssencmode)},\n\n\t/* Kerberos and GSSAPI authentication support specifying the service name */\n\t{\"krbsrvname\", \"PGKRBSRVNAME\", PG_KRB_SRVNAM, NULL,\n\t\t\"Kerberos-service-name\", \"\", 20,\n\toffsetof(struct pg_conn, krbsrvname)},\n\n\t{\"gsslib\", \"PGGSSLIB\", NULL, NULL,\n\t\t\"GSS-library\", \"\", 7,\t/* sizeof(\"gssapi\") == 7 */\n\toffsetof(struct pg_conn, gsslib)},\n\n\t{\"replication\", NULL, NULL, NULL,\n\t\t\"Replication\", \"D\", 5,\n\toffsetof(struct pg_conn, replication)},\n\n\t{\"target_session_attrs\", \"PGTARGETSESSIONATTRS\",\n\t\tDefaultTargetSessionAttrs, NULL,\n\t\t\"Target-Session-Attrs\", \"\", 15, /* sizeof(\"prefer-standby\") = 15 */\n\toffsetof(struct pg_conn, target_session_attrs)},\n\n\t/* Terminating entry --- MUST BE LAST */\n\t{NULL, NULL, NULL, NULL,\n\tNULL, NULL, 0}\n};\n\nstatic const PQEnvironmentOption EnvironmentOptions[] =\n{\n\t/* common user-interface settings */\n\t{\n\t\t\"PGDATESTYLE\", \"datestyle\"\n\t},\n\t{\n\t\t\"PGTZ\", \"timezone\"\n\t},\n\t/* internal performance-related settings */\n\t{\n\t\t\"PGGEQO\", \"geqo\"\n\t},\n\t{\n\t\tNULL, NULL\n\t}\n};\n\n/* The connection URI must start with either of the following designators: */\nstatic const char uri_designator[] = \"postgresql://\";\nstatic const char short_uri_designator[] = \"postgres://\";\n\nstatic bool connectOptions1(PGconn *conn, const char *conninfo);\nstatic bool connectOptions2(PGconn *conn);\nstatic int\tconnectDBStart(PGconn *conn);\nstatic int\tconnectDBComplete(PGconn *conn);\nstatic PGPing internal_ping(PGconn *conn);\nstatic PGconn *makeEmptyPGconn(void);\nstatic bool fillPGconn(PGconn *conn, PQconninfoOption *connOptions);\nstatic void freePGconn(PGconn *conn);\nstatic void closePGconn(PGconn *conn);\nstatic void release_conn_addrinfo(PGconn *conn);\nstatic void sendTerminateConn(PGconn *conn);\nstatic PQconninfoOption *conninfo_init(PQExpBuffer errorMessage);\nstatic PQconninfoOption *parse_connection_string(const char *conninfo,\n\t\t\t\t\t\t\t\t\t\t\t\t PQExpBuffer errorMessage, bool use_defaults);\nstatic int\turi_prefix_length(const char *connstr);\nstatic bool recognized_connection_string(const char *connstr);\nstatic PQconninfoOption *conninfo_parse(const char *conninfo,\n\t\t\t\t\t\t\t\t\t\tPQExpBuffer errorMessage, bool use_defaults);\nstatic PQconninfoOption *conninfo_array_parse(const char *const *keywords,\n\t\t\t\t\t\t\t\t\t\t\t  const char *const *values, PQExpBuffer errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  bool use_defaults, int expand_dbname);\nstatic bool conninfo_add_defaults(PQconninfoOption *options,\n\t\t\t\t\t\t\t\t  PQExpBuffer errorMessage);\nstatic PQconninfoOption *conninfo_uri_parse(const char *uri,\n\t\t\t\t\t\t\t\t\t\t\tPQExpBuffer errorMessage, bool use_defaults);\nstatic bool conninfo_uri_parse_options(PQconninfoOption *options,\n\t\t\t\t\t\t\t\t\t   const char *uri, PQExpBuffer errorMessage);\nstatic bool conninfo_uri_parse_params(char *params,\n\t\t\t\t\t\t\t\t\t  PQconninfoOption *connOptions,\n\t\t\t\t\t\t\t\t\t  PQExpBuffer errorMessage);\nstatic char *conninfo_uri_decode(const char *str, PQExpBuffer errorMessage);\nstatic bool get_hexdigit(char digit, int *value);\nstatic const char *conninfo_getval(PQconninfoOption *connOptions,\n\t\t\t\t\t\t\t\t   const char *keyword);\nstatic PQconninfoOption *conninfo_storeval(PQconninfoOption *connOptions,\n\t\t\t\t\t\t\t\t\t\t   const char *keyword, const char *value,\n\t\t\t\t\t\t\t\t\t\t   PQExpBuffer errorMessage, bool ignoreMissing, bool uri_decode);\nstatic PQconninfoOption *conninfo_find(PQconninfoOption *connOptions,\n\t\t\t\t\t\t\t\t\t   const char *keyword);\nstatic void defaultNoticeReceiver(void *arg, const PGresult *res);\nstatic void defaultNoticeProcessor(void *arg, const char *message);\nstatic int\tparseServiceInfo(PQconninfoOption *options,\n\t\t\t\t\t\t\t PQExpBuffer errorMessage);\nstatic int\tparseServiceFile(const char *serviceFile,\n\t\t\t\t\t\t\t const char *service,\n\t\t\t\t\t\t\t PQconninfoOption *options,\n\t\t\t\t\t\t\t PQExpBuffer errorMessage,\n\t\t\t\t\t\t\t bool *group_found);\nstatic char *pwdfMatchesString(char *buf, const char *token);\nstatic char *passwordFromFile(const char *hostname, const char *port, const char *dbname,\n\t\t\t\t\t\t\t  const char *username, const char *pgpassfile);\nstatic void pgpassfileWarning(PGconn *conn);\nstatic void default_threadlock(int acquire);\nstatic bool sslVerifyProtocolVersion(const char *version);\nstatic bool sslVerifyProtocolRange(const char *min, const char *max);\n\n\n/* global variable because fe-auth.c needs to access it */\npgthreadlock_t pg_g_threadlock = default_threadlock;\n\n\n/*\n *\t\tpqDropConnection\n *\n * Close any physical connection to the server, and reset associated\n * state inside the connection object.  We don't release state that\n * would be needed to reconnect, though, nor local state that might still\n * be useful later.\n *\n * We can always flush the output buffer, since there's no longer any hope\n * of sending that data.  However, unprocessed input data might still be\n * valuable, so the caller must tell us whether to flush that or not.\n */\nvoid\npqDropConnection(PGconn *conn, bool flushInput)\n{\n\t/* Drop any SSL state */\n\tpqsecure_close(conn);\n\n\t/* Close the socket itself */\n\tif (conn->sock != PGINVALID_SOCKET)\n\t\tclosesocket(conn->sock);\n\tconn->sock = PGINVALID_SOCKET;\n\n\t/* Optionally discard any unread data */\n\tif (flushInput)\n\t\tconn->inStart = conn->inCursor = conn->inEnd = 0;\n\n\t/* Always discard any unsent data */\n\tconn->outCount = 0;\n\n\t/* Free authentication/encryption state */\n#ifdef ENABLE_GSS\n\t{\n\t\tOM_uint32\tmin_s;\n\n\t\tif (conn->gcred != GSS_C_NO_CREDENTIAL)\n\t\t{\n\t\t\tgss_release_cred(&min_s, &conn->gcred);\n\t\t\tconn->gcred = GSS_C_NO_CREDENTIAL;\n\t\t}\n\t\tif (conn->gctx)\n\t\t\tgss_delete_sec_context(&min_s, &conn->gctx, GSS_C_NO_BUFFER);\n\t\tif (conn->gtarg_nam)\n\t\t\tgss_release_name(&min_s, &conn->gtarg_nam);\n\t\tif (conn->gss_SendBuffer)\n\t\t{\n\t\t\tfree(conn->gss_SendBuffer);\n\t\t\tconn->gss_SendBuffer = NULL;\n\t\t}\n\t\tif (conn->gss_RecvBuffer)\n\t\t{\n\t\t\tfree(conn->gss_RecvBuffer);\n\t\t\tconn->gss_RecvBuffer = NULL;\n\t\t}\n\t\tif (conn->gss_ResultBuffer)\n\t\t{\n\t\t\tfree(conn->gss_ResultBuffer);\n\t\t\tconn->gss_ResultBuffer = NULL;\n\t\t}\n\t\tconn->gssenc = false;\n\t}\n#endif\n#ifdef ENABLE_SSPI\n\tif (conn->sspitarget)\n\t{\n\t\tfree(conn->sspitarget);\n\t\tconn->sspitarget = NULL;\n\t}\n\tif (conn->sspicred)\n\t{\n\t\tFreeCredentialsHandle(conn->sspicred);\n\t\tfree(conn->sspicred);\n\t\tconn->sspicred = NULL;\n\t}\n\tif (conn->sspictx)\n\t{\n\t\tDeleteSecurityContext(conn->sspictx);\n\t\tfree(conn->sspictx);\n\t\tconn->sspictx = NULL;\n\t}\n\tconn->usesspi = 0;\n#endif\n\tif (conn->sasl_state)\n\t{\n\t\tconn->sasl->free(conn->sasl_state);\n\t\tconn->sasl_state = NULL;\n\t}\n}\n\n/*\n * pqFreeCommandQueue\n * Free all the entries of PGcmdQueueEntry queue passed.\n */\nstatic void\npqFreeCommandQueue(PGcmdQueueEntry *queue)\n{\n\twhile (queue != NULL)\n\t{\n\t\tPGcmdQueueEntry *cur = queue;\n\n\t\tqueue = cur->next;\n\t\tif (cur->query)\n\t\t\tfree(cur->query);\n\t\tfree(cur);\n\t}\n}\n\n/*\n *\t\tpqDropServerData\n *\n * Clear all connection state data that was received from (or deduced about)\n * the server.  This is essential to do between connection attempts to\n * different servers, else we may incorrectly hold over some data from the\n * old server.\n *\n * It would be better to merge this into pqDropConnection, perhaps, but\n * right now we cannot because that function is called immediately on\n * detection of connection loss (cf. pqReadData, for instance).  This data\n * should be kept until we are actually starting a new connection.\n */\nstatic void\npqDropServerData(PGconn *conn)\n{\n\tPGnotify   *notify;\n\tpgParameterStatus *pstatus;\n\n\t/* Forget pending notifies */\n\tnotify = conn->notifyHead;\n\twhile (notify != NULL)\n\t{\n\t\tPGnotify   *prev = notify;\n\n\t\tnotify = notify->next;\n\t\tfree(prev);\n\t}\n\tconn->notifyHead = conn->notifyTail = NULL;\n\n\tpqFreeCommandQueue(conn->cmd_queue_head);\n\tconn->cmd_queue_head = conn->cmd_queue_tail = NULL;\n\n\tpqFreeCommandQueue(conn->cmd_queue_recycle);\n\tconn->cmd_queue_recycle = NULL;\n\n\t/* Reset ParameterStatus data, as well as variables deduced from it */\n\tpstatus = conn->pstatus;\n\twhile (pstatus != NULL)\n\t{\n\t\tpgParameterStatus *prev = pstatus;\n\n\t\tpstatus = pstatus->next;\n\t\tfree(prev);\n\t}\n\tconn->pstatus = NULL;\n\tconn->client_encoding = PG_SQL_ASCII;\n\tconn->std_strings = false;\n\tconn->default_transaction_read_only = PG_BOOL_UNKNOWN;\n\tconn->in_hot_standby = PG_BOOL_UNKNOWN;\n\tconn->sversion = 0;\n\n\t/* Drop large-object lookup data */\n\tif (conn->lobjfuncs)\n\t\tfree(conn->lobjfuncs);\n\tconn->lobjfuncs = NULL;\n\n\t/* Reset assorted other per-connection state */\n\tconn->last_sqlstate[0] = '\\0';\n\tconn->auth_req_received = false;\n\tconn->password_needed = false;\n\tconn->write_failed = false;\n\tif (conn->write_err_msg)\n\t\tfree(conn->write_err_msg);\n\tconn->write_err_msg = NULL;\n\tconn->be_pid = 0;\n\tconn->be_key = 0;\n}\n\n\n/*\n *\t\tConnecting to a Database\n *\n * There are now six different ways a user of this API can connect to the\n * database.  Two are not recommended for use in new code, because of their\n * lack of extensibility with respect to the passing of options to the\n * backend.  These are PQsetdb and PQsetdbLogin (the former now being a macro\n * to the latter).\n *\n * If it is desired to connect in a synchronous (blocking) manner, use the\n * function PQconnectdb or PQconnectdbParams. The former accepts a string of\n * option = value pairs (or a URI) which must be parsed; the latter takes two\n * NULL terminated arrays instead.\n *\n * To connect in an asynchronous (non-blocking) manner, use the functions\n * PQconnectStart or PQconnectStartParams (which differ in the same way as\n * PQconnectdb and PQconnectdbParams) and PQconnectPoll.\n *\n * Internally, the static functions connectDBStart, connectDBComplete\n * are part of the connection procedure.\n */\n\n/*\n *\t\tPQconnectdbParams\n *\n * establishes a connection to a postgres backend through the postmaster\n * using connection information in two arrays.\n *\n * The keywords array is defined as\n *\n *\t   const char *params[] = {\"option1\", \"option2\", NULL}\n *\n * The values array is defined as\n *\n *\t   const char *values[] = {\"value1\", \"value2\", NULL}\n *\n * Returns a PGconn* which is needed for all subsequent libpq calls, or NULL\n * if a memory allocation failed.\n * If the status field of the connection returned is CONNECTION_BAD,\n * then some fields may be null'ed out instead of having valid values.\n *\n * You should call PQfinish (if conn is not NULL) regardless of whether this\n * call succeeded.\n */\nPGconn *\nPQconnectdbParams(const char *const *keywords,\n\t\t\t\t  const char *const *values,\n\t\t\t\t  int expand_dbname)\n{\n\tPGconn\t   *conn = PQconnectStartParams(keywords, values, expand_dbname);\n\n\tif (conn && conn->status != CONNECTION_BAD)\n\t\t(void) connectDBComplete(conn);\n\n\treturn conn;\n\n}\n\n/*\n *\t\tPQpingParams\n *\n * check server status, accepting parameters identical to PQconnectdbParams\n */\nPGPing\nPQpingParams(const char *const *keywords,\n\t\t\t const char *const *values,\n\t\t\t int expand_dbname)\n{\n\tPGconn\t   *conn = PQconnectStartParams(keywords, values, expand_dbname);\n\tPGPing\t\tret;\n\n\tret = internal_ping(conn);\n\tPQfinish(conn);\n\n\treturn ret;\n}\n\n/*\n *\t\tPQconnectdb\n *\n * establishes a connection to a postgres backend through the postmaster\n * using connection information in a string.\n *\n * The conninfo string is either a whitespace-separated list of\n *\n *\t   option = value\n *\n * definitions or a URI (refer to the documentation for details.) Value\n * might be a single value containing no whitespaces or a single quoted\n * string. If a single quote should appear anywhere in the value, it must be\n * escaped with a backslash like \\'\n *\n * Returns a PGconn* which is needed for all subsequent libpq calls, or NULL\n * if a memory allocation failed.\n * If the status field of the connection returned is CONNECTION_BAD,\n * then some fields may be null'ed out instead of having valid values.\n *\n * You should call PQfinish (if conn is not NULL) regardless of whether this\n * call succeeded.\n */\nPGconn *\nPQconnectdb(const char *conninfo)\n{\n\tPGconn\t   *conn = PQconnectStart(conninfo);\n\n\tif (conn && conn->status != CONNECTION_BAD)\n\t\t(void) connectDBComplete(conn);\n\n\treturn conn;\n}\n\n/*\n *\t\tPQping\n *\n * check server status, accepting parameters identical to PQconnectdb\n */\nPGPing\nPQping(const char *conninfo)\n{\n\tPGconn\t   *conn = PQconnectStart(conninfo);\n\tPGPing\t\tret;\n\n\tret = internal_ping(conn);\n\tPQfinish(conn);\n\n\treturn ret;\n}\n\n/*\n *\t\tPQconnectStartParams\n *\n * Begins the establishment of a connection to a postgres backend through the\n * postmaster using connection information in a struct.\n *\n * See comment for PQconnectdbParams for the definition of the string format.\n *\n * Returns a PGconn*.  If NULL is returned, a malloc error has occurred, and\n * you should not attempt to proceed with this connection.  If the status\n * field of the connection returned is CONNECTION_BAD, an error has\n * occurred. In this case you should call PQfinish on the result, (perhaps\n * inspecting the error message first).  Other fields of the structure may not\n * be valid if that occurs.  If the status field is not CONNECTION_BAD, then\n * this stage has succeeded - call PQconnectPoll, using select(2) to see when\n * this is necessary.\n *\n * See PQconnectPoll for more info.\n */\nPGconn *\nPQconnectStartParams(const char *const *keywords,\n\t\t\t\t\t const char *const *values,\n\t\t\t\t\t int expand_dbname)\n{\n\tPGconn\t   *conn;\n\tPQconninfoOption *connOptions;\n\n\t/*\n\t * Allocate memory for the conn structure.  Note that we also expect this\n\t * to initialize conn->errorMessage to empty.  All subsequent steps during\n\t * connection initialization will only append to that buffer.\n\t */\n\tconn = makeEmptyPGconn();\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Parse the conninfo arrays\n\t */\n\tconnOptions = conninfo_array_parse(keywords, values,\n\t\t\t\t\t\t\t\t\t   &conn->errorMessage,\n\t\t\t\t\t\t\t\t\t   true, expand_dbname);\n\tif (connOptions == NULL)\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\t/* errorMessage is already set */\n\t\treturn conn;\n\t}\n\n\t/*\n\t * Move option values into conn structure\n\t */\n\tif (!fillPGconn(conn, connOptions))\n\t{\n\t\tPQconninfoFree(connOptions);\n\t\treturn conn;\n\t}\n\n\t/*\n\t * Free the option info - all is in conn now\n\t */\n\tPQconninfoFree(connOptions);\n\n\t/*\n\t * Compute derived options\n\t */\n\tif (!connectOptions2(conn))\n\t\treturn conn;\n\n\t/*\n\t * Connect to the database\n\t */\n\tif (!connectDBStart(conn))\n\t{\n\t\t/* Just in case we failed to set it in connectDBStart */\n\t\tconn->status = CONNECTION_BAD;\n\t}\n\n\treturn conn;\n}\n\n/*\n *\t\tPQconnectStart\n *\n * Begins the establishment of a connection to a postgres backend through the\n * postmaster using connection information in a string.\n *\n * See comment for PQconnectdb for the definition of the string format.\n *\n * Returns a PGconn*.  If NULL is returned, a malloc error has occurred, and\n * you should not attempt to proceed with this connection.  If the status\n * field of the connection returned is CONNECTION_BAD, an error has\n * occurred. In this case you should call PQfinish on the result, (perhaps\n * inspecting the error message first).  Other fields of the structure may not\n * be valid if that occurs.  If the status field is not CONNECTION_BAD, then\n * this stage has succeeded - call PQconnectPoll, using select(2) to see when\n * this is necessary.\n *\n * See PQconnectPoll for more info.\n */\nPGconn *\nPQconnectStart(const char *conninfo)\n{\n\tPGconn\t   *conn;\n\n\t/*\n\t * Allocate memory for the conn structure.  Note that we also expect this\n\t * to initialize conn->errorMessage to empty.  All subsequent steps during\n\t * connection initialization will only append to that buffer.\n\t */\n\tconn = makeEmptyPGconn();\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Parse the conninfo string\n\t */\n\tif (!connectOptions1(conn, conninfo))\n\t\treturn conn;\n\n\t/*\n\t * Compute derived options\n\t */\n\tif (!connectOptions2(conn))\n\t\treturn conn;\n\n\t/*\n\t * Connect to the database\n\t */\n\tif (!connectDBStart(conn))\n\t{\n\t\t/* Just in case we failed to set it in connectDBStart */\n\t\tconn->status = CONNECTION_BAD;\n\t}\n\n\treturn conn;\n}\n\n/*\n * Move option values into conn structure\n *\n * Don't put anything cute here --- intelligence should be in\n * connectOptions2 ...\n *\n * Returns true on success. On failure, returns false and sets error message.\n */\nstatic bool\nfillPGconn(PGconn *conn, PQconninfoOption *connOptions)\n{\n\tconst internalPQconninfoOption *option;\n\n\tfor (option = PQconninfoOptions; option->keyword; option++)\n\t{\n\t\tif (option->connofs >= 0)\n\t\t{\n\t\t\tconst char *tmp = conninfo_getval(connOptions, option->keyword);\n\n\t\t\tif (tmp)\n\t\t\t{\n\t\t\t\tchar\t  **connmember = (char **) ((char *) conn + option->connofs);\n\n\t\t\t\tif (*connmember)\n\t\t\t\t\tfree(*connmember);\n\t\t\t\t*connmember = strdup(tmp);\n\t\t\t\tif (*connmember == NULL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/*\n *\t\tconnectOptions1\n *\n * Internal subroutine to set up connection parameters given an already-\n * created PGconn and a conninfo string.  Derived settings should be\n * processed by calling connectOptions2 next.  (We split them because\n * PQsetdbLogin overrides defaults in between.)\n *\n * Returns true if OK, false if trouble (in which case errorMessage is set\n * and so is conn->status).\n */\nstatic bool\nconnectOptions1(PGconn *conn, const char *conninfo)\n{\n\tPQconninfoOption *connOptions;\n\n\t/*\n\t * Parse the conninfo string\n\t */\n\tconnOptions = parse_connection_string(conninfo, &conn->errorMessage, true);\n\tif (connOptions == NULL)\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\t/* errorMessage is already set */\n\t\treturn false;\n\t}\n\n\t/*\n\t * Move option values into conn structure\n\t */\n\tif (!fillPGconn(conn, connOptions))\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\tPQconninfoFree(connOptions);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Free the option info - all is in conn now\n\t */\n\tPQconninfoFree(connOptions);\n\n\treturn true;\n}\n\n/*\n * Count the number of elements in a simple comma-separated list.\n */\nstatic int\ncount_comma_separated_elems(const char *input)\n{\n\tint\t\t\tn;\n\n\tn = 1;\n\tfor (; *input != '\\0'; input++)\n\t{\n\t\tif (*input == ',')\n\t\t\tn++;\n\t}\n\n\treturn n;\n}\n\n/*\n * Parse a simple comma-separated list.\n *\n * On each call, returns a malloc'd copy of the next element, and sets *more\n * to indicate whether there are any more elements in the list after this,\n * and updates *startptr to point to the next element, if any.\n *\n * On out of memory, returns NULL.\n */\nstatic char *\nparse_comma_separated_list(char **startptr, bool *more)\n{\n\tchar\t   *p;\n\tchar\t   *s = *startptr;\n\tchar\t   *e;\n\tint\t\t\tlen;\n\n\t/*\n\t * Search for the end of the current element; a comma or end-of-string\n\t * acts as a terminator.\n\t */\n\te = s;\n\twhile (*e != '\\0' && *e != ',')\n\t\t++e;\n\t*more = (*e == ',');\n\n\tlen = e - s;\n\tp = (char *) malloc(sizeof(char) * (len + 1));\n\tif (p)\n\t{\n\t\tmemcpy(p, s, len);\n\t\tp[len] = '\\0';\n\t}\n\t*startptr = e + 1;\n\n\treturn p;\n}\n\n/*\n *\t\tconnectOptions2\n *\n * Compute derived connection options after absorbing all user-supplied info.\n *\n * Returns true if OK, false if trouble (in which case errorMessage is set\n * and so is conn->status).\n */\nstatic bool\nconnectOptions2(PGconn *conn)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Allocate memory for details about each host to which we might possibly\n\t * try to connect.  For that, count the number of elements in the hostaddr\n\t * or host options.  If neither is given, assume one host.\n\t */\n\tconn->whichhost = 0;\n\tif (conn->pghostaddr && conn->pghostaddr[0] != '\\0')\n\t\tconn->nconnhost = count_comma_separated_elems(conn->pghostaddr);\n\telse if (conn->pghost && conn->pghost[0] != '\\0')\n\t\tconn->nconnhost = count_comma_separated_elems(conn->pghost);\n\telse\n\t\tconn->nconnhost = 1;\n\tconn->connhost = (pg_conn_host *)\n\t\tcalloc(conn->nconnhost, sizeof(pg_conn_host));\n\tif (conn->connhost == NULL)\n\t\tgoto oom_error;\n\n\t/*\n\t * We now have one pg_conn_host structure per possible host.  Fill in the\n\t * host and hostaddr fields for each, by splitting the parameter strings.\n\t */\n\tif (conn->pghostaddr != NULL && conn->pghostaddr[0] != '\\0')\n\t{\n\t\tchar\t   *s = conn->pghostaddr;\n\t\tbool\t\tmore = true;\n\n\t\tfor (i = 0; i < conn->nconnhost && more; i++)\n\t\t{\n\t\t\tconn->connhost[i].hostaddr = parse_comma_separated_list(&s, &more);\n\t\t\tif (conn->connhost[i].hostaddr == NULL)\n\t\t\t\tgoto oom_error;\n\t\t}\n\n\t\t/*\n\t\t * If hostaddr was given, the array was allocated according to the\n\t\t * number of elements in the hostaddr list, so it really should be the\n\t\t * right size.\n\t\t */\n\t\tAssert(!more);\n\t\tAssert(i == conn->nconnhost);\n\t}\n\n\tif (conn->pghost != NULL && conn->pghost[0] != '\\0')\n\t{\n\t\tchar\t   *s = conn->pghost;\n\t\tbool\t\tmore = true;\n\n\t\tfor (i = 0; i < conn->nconnhost && more; i++)\n\t\t{\n\t\t\tconn->connhost[i].host = parse_comma_separated_list(&s, &more);\n\t\t\tif (conn->connhost[i].host == NULL)\n\t\t\t\tgoto oom_error;\n\t\t}\n\n\t\t/* Check for wrong number of host items. */\n\t\tif (more || i != conn->nconnhost)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"could not match %d host names to %d hostaddr values\\n\"),\n\t\t\t\t\t\t\t  count_comma_separated_elems(conn->pghost), conn->nconnhost);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Now, for each host slot, identify the type of address spec, and fill in\n\t * the default address if nothing was given.\n\t */\n\tfor (i = 0; i < conn->nconnhost; i++)\n\t{\n\t\tpg_conn_host *ch = &conn->connhost[i];\n\n\t\tif (ch->hostaddr != NULL && ch->hostaddr[0] != '\\0')\n\t\t\tch->type = CHT_HOST_ADDRESS;\n\t\telse if (ch->host != NULL && ch->host[0] != '\\0')\n\t\t{\n\t\t\tch->type = CHT_HOST_NAME;\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\tif (is_unixsock_path(ch->host))\n\t\t\t\tch->type = CHT_UNIX_SOCKET;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (ch->host)\n\t\t\t\tfree(ch->host);\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\tif (DEFAULT_PGSOCKET_DIR[0])\n\t\t\t{\n\t\t\t\tch->host = strdup(DEFAULT_PGSOCKET_DIR);\n\t\t\t\tch->type = CHT_UNIX_SOCKET;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tch->host = strdup(DefaultHost);\n\t\t\t\tch->type = CHT_HOST_NAME;\n\t\t\t}\n\t\t\tif (ch->host == NULL)\n\t\t\t\tgoto oom_error;\n\t\t}\n\t}\n\n\t/*\n\t * Next, work out the port number corresponding to each host name.\n\t *\n\t * Note: unlike the above for host names, this could leave the port fields\n\t * as null or empty strings.  We will substitute DEF_PGPORT whenever we\n\t * read such a port field.\n\t */\n\tif (conn->pgport != NULL && conn->pgport[0] != '\\0')\n\t{\n\t\tchar\t   *s = conn->pgport;\n\t\tbool\t\tmore = true;\n\n\t\tfor (i = 0; i < conn->nconnhost && more; i++)\n\t\t{\n\t\t\tconn->connhost[i].port = parse_comma_separated_list(&s, &more);\n\t\t\tif (conn->connhost[i].port == NULL)\n\t\t\t\tgoto oom_error;\n\t\t}\n\n\t\t/*\n\t\t * If exactly one port was given, use it for every host.  Otherwise,\n\t\t * there must be exactly as many ports as there were hosts.\n\t\t */\n\t\tif (i == 1 && !more)\n\t\t{\n\t\t\tfor (i = 1; i < conn->nconnhost; i++)\n\t\t\t{\n\t\t\t\tconn->connhost[i].port = strdup(conn->connhost[0].port);\n\t\t\t\tif (conn->connhost[i].port == NULL)\n\t\t\t\t\tgoto oom_error;\n\t\t\t}\n\t\t}\n\t\telse if (more || i != conn->nconnhost)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"could not match %d port numbers to %d hosts\\n\"),\n\t\t\t\t\t\t\t  count_comma_separated_elems(conn->pgport), conn->nconnhost);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If user name was not given, fetch it.  (Most likely, the fetch will\n\t * fail, since the only way we get here is if pg_fe_getauthname() failed\n\t * during conninfo_add_defaults().  But now we want an error message.)\n\t */\n\tif (conn->pguser == NULL || conn->pguser[0] == '\\0')\n\t{\n\t\tif (conn->pguser)\n\t\t\tfree(conn->pguser);\n\t\tconn->pguser = pg_fe_getauthname(&conn->errorMessage);\n\t\tif (!conn->pguser)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If database name was not given, default it to equal user name\n\t */\n\tif (conn->dbName == NULL || conn->dbName[0] == '\\0')\n\t{\n\t\tif (conn->dbName)\n\t\t\tfree(conn->dbName);\n\t\tconn->dbName = strdup(conn->pguser);\n\t\tif (!conn->dbName)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * If password was not given, try to look it up in password file.  Note\n\t * that the result might be different for each host/port pair.\n\t */\n\tif (conn->pgpass == NULL || conn->pgpass[0] == '\\0')\n\t{\n\t\t/* If password file wasn't specified, use ~/PGPASSFILE */\n\t\tif (conn->pgpassfile == NULL || conn->pgpassfile[0] == '\\0')\n\t\t{\n\t\t\tchar\t\thomedir[MAXPGPATH];\n\n\t\t\tif (pqGetHomeDirectory(homedir, sizeof(homedir)))\n\t\t\t{\n\t\t\t\tif (conn->pgpassfile)\n\t\t\t\t\tfree(conn->pgpassfile);\n\t\t\t\tconn->pgpassfile = malloc(MAXPGPATH);\n\t\t\t\tif (!conn->pgpassfile)\n\t\t\t\t\tgoto oom_error;\n\t\t\t\tsnprintf(conn->pgpassfile, MAXPGPATH, \"%s/%s\",\n\t\t\t\t\t\t homedir, PGPASSFILE);\n\t\t\t}\n\t\t}\n\n\t\tif (conn->pgpassfile != NULL && conn->pgpassfile[0] != '\\0')\n\t\t{\n\t\t\tfor (i = 0; i < conn->nconnhost; i++)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Try to get a password for this host from file.  We use host\n\t\t\t\t * for the hostname search key if given, else hostaddr (at\n\t\t\t\t * least one of them is guaranteed nonempty by now).\n\t\t\t\t */\n\t\t\t\tconst char *pwhost = conn->connhost[i].host;\n\n\t\t\t\tif (pwhost == NULL || pwhost[0] == '\\0')\n\t\t\t\t\tpwhost = conn->connhost[i].hostaddr;\n\n\t\t\t\tconn->connhost[i].password =\n\t\t\t\t\tpasswordFromFile(pwhost,\n\t\t\t\t\t\t\t\t\t conn->connhost[i].port,\n\t\t\t\t\t\t\t\t\t conn->dbName,\n\t\t\t\t\t\t\t\t\t conn->pguser,\n\t\t\t\t\t\t\t\t\t conn->pgpassfile);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * validate channel_binding option\n\t */\n\tif (conn->channel_binding)\n\t{\n\t\tif (strcmp(conn->channel_binding, \"disable\") != 0\n\t\t\t&& strcmp(conn->channel_binding, \"prefer\") != 0\n\t\t\t&& strcmp(conn->channel_binding, \"require\") != 0)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  \"channel_binding\", conn->channel_binding);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconn->channel_binding = strdup(DefaultChannelBinding);\n\t\tif (!conn->channel_binding)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * validate sslmode option\n\t */\n\tif (conn->sslmode)\n\t{\n\t\tif (strcmp(conn->sslmode, \"disable\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"allow\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"prefer\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"require\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"verify-ca\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"verify-full\") != 0)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  \"sslmode\", conn->sslmode);\n\t\t\treturn false;\n\t\t}\n\n#ifndef USE_SSL\n\t\tswitch (conn->sslmode[0])\n\t\t{\n\t\t\tcase 'a':\t\t\t/* \"allow\" */\n\t\t\tcase 'p':\t\t\t/* \"prefer\" */\n\n\t\t\t\t/*\n\t\t\t\t * warn user that an SSL connection will never be negotiated\n\t\t\t\t * since SSL was not compiled in?\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\t\t\t/* \"require\" */\n\t\t\tcase 'v':\t\t\t/* \"verify-ca\" or \"verify-full\" */\n\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"sslmode value \\\"%s\\\" invalid when SSL support is not compiled in\\n\"),\n\t\t\t\t\t\t\t\t  conn->sslmode);\n\t\t\t\treturn false;\n\t\t}\n#endif\n\t}\n\telse\n\t{\n\t\tconn->sslmode = strdup(DefaultSSLMode);\n\t\tif (!conn->sslmode)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * Validate TLS protocol versions for ssl_min_protocol_version and\n\t * ssl_max_protocol_version.\n\t */\n\tif (!sslVerifyProtocolVersion(conn->ssl_min_protocol_version))\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t  \"ssl_min_protocol_version\",\n\t\t\t\t\t\t  conn->ssl_min_protocol_version);\n\t\treturn false;\n\t}\n\tif (!sslVerifyProtocolVersion(conn->ssl_max_protocol_version))\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t  \"ssl_max_protocol_version\",\n\t\t\t\t\t\t  conn->ssl_max_protocol_version);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check if the range of SSL protocols defined is correct.  This is done\n\t * at this early step because this is independent of the SSL\n\t * implementation used, and this avoids unnecessary cycles with an\n\t * already-built SSL context when the connection is being established, as\n\t * it would be doomed anyway.\n\t */\n\tif (!sslVerifyProtocolRange(conn->ssl_min_protocol_version,\n\t\t\t\t\t\t\t\tconn->ssl_max_protocol_version))\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"invalid SSL protocol version range\\n\"));\n\t\treturn false;\n\t}\n\n\t/*\n\t * validate gssencmode option\n\t */\n\tif (conn->gssencmode)\n\t{\n\t\tif (strcmp(conn->gssencmode, \"disable\") != 0 &&\n\t\t\tstrcmp(conn->gssencmode, \"prefer\") != 0 &&\n\t\t\tstrcmp(conn->gssencmode, \"require\") != 0)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  \"gssencmode\",\n\t\t\t\t\t\t\t  conn->gssencmode);\n\t\t\treturn false;\n\t\t}\n#ifndef ENABLE_GSS\n\t\tif (strcmp(conn->gssencmode, \"require\") == 0)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"gssencmode value \\\"%s\\\" invalid when GSSAPI support is not compiled in\\n\"),\n\t\t\t\t\t\t\t  conn->gssencmode);\n\t\t\treturn false;\n\t\t}\n#endif\n\t}\n\telse\n\t{\n\t\tconn->gssencmode = strdup(DefaultGSSMode);\n\t\tif (!conn->gssencmode)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * validate target_session_attrs option, and set target_server_type\n\t */\n\tif (conn->target_session_attrs)\n\t{\n\t\tif (strcmp(conn->target_session_attrs, \"any\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_ANY;\n\t\telse if (strcmp(conn->target_session_attrs, \"read-write\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_READ_WRITE;\n\t\telse if (strcmp(conn->target_session_attrs, \"read-only\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_READ_ONLY;\n\t\telse if (strcmp(conn->target_session_attrs, \"primary\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_PRIMARY;\n\t\telse if (strcmp(conn->target_session_attrs, \"standby\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_STANDBY;\n\t\telse if (strcmp(conn->target_session_attrs, \"prefer-standby\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_PREFER_STANDBY;\n\t\telse\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  \"target_session_attrs\",\n\t\t\t\t\t\t\t  conn->target_session_attrs);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t\tconn->target_server_type = SERVER_TYPE_ANY;\n\n\t/*\n\t * Resolve special \"auto\" client_encoding from the locale\n\t */\n\tif (conn->client_encoding_initial &&\n\t\tstrcmp(conn->client_encoding_initial, \"auto\") == 0)\n\t{\n\t\tfree(conn->client_encoding_initial);\n\t\tconn->client_encoding_initial = strdup(pg_encoding_to_char(pg_get_encoding_from_locale(NULL, true)));\n\t\tif (!conn->client_encoding_initial)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * Only if we get this far is it appropriate to try to connect. (We need a\n\t * state flag, rather than just the boolean result of this function, in\n\t * case someone tries to PQreset() the PGconn.)\n\t */\n\tconn->options_valid = true;\n\n\treturn true;\n\noom_error:\n\tconn->status = CONNECTION_BAD;\n\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\treturn false;\n}\n\n/*\n *\t\tPQconndefaults\n *\n * Construct a default connection options array, which identifies all the\n * available options and shows any default values that are available from the\n * environment etc.  On error (eg out of memory), NULL is returned.\n *\n * Using this function, an application may determine all possible options\n * and their current default values.\n *\n * NOTE: as of PostgreSQL 7.0, the returned array is dynamically allocated\n * and should be freed when no longer needed via PQconninfoFree().  (In prior\n * versions, the returned array was static, but that's not thread-safe.)\n * Pre-7.0 applications that use this function will see a small memory leak\n * until they are updated to call PQconninfoFree.\n */\nPQconninfoOption *\nPQconndefaults(void)\n{\n\tPQExpBufferData errorBuf;\n\tPQconninfoOption *connOptions;\n\n\t/* We don't actually report any errors here, but callees want a buffer */\n\tinitPQExpBuffer(&errorBuf);\n\tif (PQExpBufferDataBroken(errorBuf))\n\t\treturn NULL;\t\t\t/* out of memory already :-( */\n\n\tconnOptions = conninfo_init(&errorBuf);\n\tif (connOptions != NULL)\n\t{\n\t\t/* pass NULL errorBuf to ignore errors */\n\t\tif (!conninfo_add_defaults(connOptions, NULL))\n\t\t{\n\t\t\tPQconninfoFree(connOptions);\n\t\t\tconnOptions = NULL;\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&errorBuf);\n\treturn connOptions;\n}\n\n/* ----------------\n *\t\tPQsetdbLogin\n *\n * establishes a connection to a postgres backend through the postmaster\n * at the specified host and port.\n *\n * returns a PGconn* which is needed for all subsequent libpq calls\n *\n * if the status field of the connection returned is CONNECTION_BAD,\n * then only the errorMessage is likely to be useful.\n * ----------------\n */\nPGconn *\nPQsetdbLogin(const char *pghost, const char *pgport, const char *pgoptions,\n\t\t\t const char *pgtty, const char *dbName, const char *login,\n\t\t\t const char *pwd)\n{\n\tPGconn\t   *conn;\n\n\t/*\n\t * Allocate memory for the conn structure.  Note that we also expect this\n\t * to initialize conn->errorMessage to empty.  All subsequent steps during\n\t * connection initialization will only append to that buffer.\n\t */\n\tconn = makeEmptyPGconn();\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * If the dbName parameter contains what looks like a connection string,\n\t * parse it into conn struct using connectOptions1.\n\t */\n\tif (dbName && recognized_connection_string(dbName))\n\t{\n\t\tif (!connectOptions1(conn, dbName))\n\t\t\treturn conn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Old-style path: first, parse an empty conninfo string in order to\n\t\t * set up the same defaults that PQconnectdb() would use.\n\t\t */\n\t\tif (!connectOptions1(conn, \"\"))\n\t\t\treturn conn;\n\n\t\t/* Insert dbName parameter value into struct */\n\t\tif (dbName && dbName[0] != '\\0')\n\t\t{\n\t\t\tif (conn->dbName)\n\t\t\t\tfree(conn->dbName);\n\t\t\tconn->dbName = strdup(dbName);\n\t\t\tif (!conn->dbName)\n\t\t\t\tgoto oom_error;\n\t\t}\n\t}\n\n\t/*\n\t * Insert remaining parameters into struct, overriding defaults (as well\n\t * as any conflicting data from dbName taken as a conninfo).\n\t */\n\tif (pghost && pghost[0] != '\\0')\n\t{\n\t\tif (conn->pghost)\n\t\t\tfree(conn->pghost);\n\t\tconn->pghost = strdup(pghost);\n\t\tif (!conn->pghost)\n\t\t\tgoto oom_error;\n\t}\n\n\tif (pgport && pgport[0] != '\\0')\n\t{\n\t\tif (conn->pgport)\n\t\t\tfree(conn->pgport);\n\t\tconn->pgport = strdup(pgport);\n\t\tif (!conn->pgport)\n\t\t\tgoto oom_error;\n\t}\n\n\tif (pgoptions && pgoptions[0] != '\\0')\n\t{\n\t\tif (conn->pgoptions)\n\t\t\tfree(conn->pgoptions);\n\t\tconn->pgoptions = strdup(pgoptions);\n\t\tif (!conn->pgoptions)\n\t\t\tgoto oom_error;\n\t}\n\n\tif (login && login[0] != '\\0')\n\t{\n\t\tif (conn->pguser)\n\t\t\tfree(conn->pguser);\n\t\tconn->pguser = strdup(login);\n\t\tif (!conn->pguser)\n\t\t\tgoto oom_error;\n\t}\n\n\tif (pwd && pwd[0] != '\\0')\n\t{\n\t\tif (conn->pgpass)\n\t\t\tfree(conn->pgpass);\n\t\tconn->pgpass = strdup(pwd);\n\t\tif (!conn->pgpass)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * Compute derived options\n\t */\n\tif (!connectOptions2(conn))\n\t\treturn conn;\n\n\t/*\n\t * Connect to the database\n\t */\n\tif (connectDBStart(conn))\n\t\t(void) connectDBComplete(conn);\n\n\treturn conn;\n\noom_error:\n\tconn->status = CONNECTION_BAD;\n\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\treturn conn;\n}\n\n\n/* ----------\n * connectNoDelay -\n * Sets the TCP_NODELAY socket option.\n * Returns 1 if successful, 0 if not.\n * ----------\n */\nstatic int\nconnectNoDelay(PGconn *conn)\n{\n#ifdef\tTCP_NODELAY\n\tint\t\t\ton = 1;\n\n\tif (setsockopt(conn->sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t\t\t   (char *) &on,\n\t\t\t\t   sizeof(on)) < 0)\n\t{\n\t\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"could not set socket to TCP no delay mode: %s\\n\"),\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\n/* ----------\n * Write currently connected IP address into host_addr (of len host_addr_len).\n * If unable to, set it to the empty string.\n * ----------\n */\nstatic void\ngetHostaddr(PGconn *conn, char *host_addr, int host_addr_len)\n{\n\tstruct sockaddr_storage *addr = &conn->raddr.addr;\n\n\tif (addr->ss_family == AF_INET)\n\t{\n\t\tif (pg_inet_net_ntop(AF_INET,\n\t\t\t\t\t\t\t &((struct sockaddr_in *) addr)->sin_addr.s_addr,\n\t\t\t\t\t\t\t 32,\n\t\t\t\t\t\t\t host_addr, host_addr_len) == NULL)\n\t\t\thost_addr[0] = '\\0';\n\t}\n#ifdef HAVE_IPV6\n\telse if (addr->ss_family == AF_INET6)\n\t{\n\t\tif (pg_inet_net_ntop(AF_INET6,\n\t\t\t\t\t\t\t &((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr,\n\t\t\t\t\t\t\t 128,\n\t\t\t\t\t\t\t host_addr, host_addr_len) == NULL)\n\t\t\thost_addr[0] = '\\0';\n\t}\n#endif\n\telse\n\t\thost_addr[0] = '\\0';\n}\n\n/*\n * emitHostIdentityInfo -\n * Speculatively append \"connection to server so-and-so failed: \" to\n * conn->errorMessage once we've identified the current connection target\n * address.  This ensures that any subsequent error message will be properly\n * attributed to the server we couldn't connect to.  conn->raddr must be\n * valid, and the result of getHostaddr() must be supplied.\n */\nstatic void\nemitHostIdentityInfo(PGconn *conn, const char *host_addr)\n{\n#ifdef HAVE_UNIX_SOCKETS\n\tif (IS_AF_UNIX(conn->raddr.addr.ss_family))\n\t{\n\t\tchar\t\tservice[NI_MAXHOST];\n\n\t\tpg_getnameinfo_all(&conn->raddr.addr, conn->raddr.salen,\n\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t   service, sizeof(service),\n\t\t\t\t\t\t   NI_NUMERICSERV);\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"connection to server on socket \\\"%s\\\" failed: \"),\n\t\t\t\t\t\t  service);\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* HAVE_UNIX_SOCKETS */\n\t{\n\t\tconst char *displayed_host;\n\t\tconst char *displayed_port;\n\n\t\t/* To which host and port were we actually connecting? */\n\t\tif (conn->connhost[conn->whichhost].type == CHT_HOST_ADDRESS)\n\t\t\tdisplayed_host = conn->connhost[conn->whichhost].hostaddr;\n\t\telse\n\t\t\tdisplayed_host = conn->connhost[conn->whichhost].host;\n\t\tdisplayed_port = conn->connhost[conn->whichhost].port;\n\t\tif (displayed_port == NULL || displayed_port[0] == '\\0')\n\t\t\tdisplayed_port = DEF_PGPORT_STR;\n\n\t\t/*\n\t\t * If the user did not supply an IP address using 'hostaddr', and\n\t\t * 'host' was missing or does not match our lookup, display the\n\t\t * looked-up IP address.\n\t\t */\n\t\tif (conn->connhost[conn->whichhost].type != CHT_HOST_ADDRESS &&\n\t\t\thost_addr[0] &&\n\t\t\tstrcmp(displayed_host, host_addr) != 0)\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"connection to server at \\\"%s\\\" (%s), port %s failed: \"),\n\t\t\t\t\t\t\t  displayed_host, host_addr,\n\t\t\t\t\t\t\t  displayed_port);\n\t\telse\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"connection to server at \\\"%s\\\", port %s failed: \"),\n\t\t\t\t\t\t\t  displayed_host,\n\t\t\t\t\t\t\t  displayed_port);\n\t}\n}\n\n/* ----------\n * connectFailureMessage -\n * create a friendly error message on connection failure,\n * using the given errno value.  Use this for error cases that\n * imply that there's no server there.\n * ----------\n */\nstatic void\nconnectFailureMessage(PGconn *conn, int errorno)\n{\n\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t  \"%s\\n\",\n\t\t\t\t\t  SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));\n\n#ifdef HAVE_UNIX_SOCKETS\n\tif (IS_AF_UNIX(conn->raddr.addr.ss_family))\n\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"\\tIs the server running locally and accepting connections on that socket?\\n\"));\n\telse\n#endif\n\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"\\tIs the server running on that host and accepting TCP/IP connections?\\n\"));\n}\n\n/*\n * Should we use keepalives?  Returns 1 if yes, 0 if no, and -1 if\n * conn->keepalives is set to a value which is not parseable as an\n * integer.\n */\nstatic int\nuseKeepalives(PGconn *conn)\n{\n\tchar\t   *ep;\n\tint\t\t\tval;\n\n\tif (conn->keepalives == NULL)\n\t\treturn 1;\n\tval = strtol(conn->keepalives, &ep, 10);\n\tif (*ep)\n\t\treturn -1;\n\treturn val != 0 ? 1 : 0;\n}\n\n/*\n * Parse and try to interpret \"value\" as an integer value, and if successful,\n * store it in *result, complaining if there is any trailing garbage or an\n * overflow.  This allows any number of leading and trailing whitespaces.\n */\nstatic bool\nparse_int_param(const char *value, int *result, PGconn *conn,\n\t\t\t\tconst char *context)\n{\n\tchar\t   *end;\n\tlong\t\tnumval;\n\n\tAssert(value != NULL);\n\n\t*result = 0;\n\n\t/* strtol(3) skips leading whitespaces */\n\terrno = 0;\n\tnumval = strtol(value, &end, 10);\n\n\t/*\n\t * If no progress was done during the parsing or an error happened, fail.\n\t * This tests properly for overflows of the result.\n\t */\n\tif (value == end || errno != 0 || numval != (int) numval)\n\t\tgoto error;\n\n\t/*\n\t * Skip any trailing whitespace; if anything but whitespace remains before\n\t * the terminating character, fail\n\t */\n\twhile (*end != '\\0' && isspace((unsigned char) *end))\n\t\tend++;\n\n\tif (*end != '\\0')\n\t\tgoto error;\n\n\t*result = numval;\n\treturn true;\n\nerror:\n\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t  libpq_gettext(\"invalid integer value \\\"%s\\\" for connection option \\\"%s\\\"\\n\"),\n\t\t\t\t\t  value, context);\n\treturn false;\n}\n\n#ifndef WIN32\n/*\n * Set the keepalive idle timer.\n */\nstatic int\nsetKeepalivesIdle(PGconn *conn)\n{\n\tint\t\t\tidle;\n\n\tif (conn->keepalives_idle == NULL)\n\t\treturn 1;\n\n\tif (!parse_int_param(conn->keepalives_idle, &idle, conn,\n\t\t\t\t\t\t \"keepalives_idle\"))\n\t\treturn 0;\n\tif (idle < 0)\n\t\tidle = 0;\n\n#ifdef PG_TCP_KEEPALIVE_IDLE\n\tif (setsockopt(conn->sock, IPPROTO_TCP, PG_TCP_KEEPALIVE_IDLE,\n\t\t\t\t   (char *) &idle, sizeof(idle)) < 0)\n\t{\n\t\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t  PG_TCP_KEEPALIVE_IDLE_STR,\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\n/*\n * Set the keepalive interval.\n */\nstatic int\nsetKeepalivesInterval(PGconn *conn)\n{\n\tint\t\t\tinterval;\n\n\tif (conn->keepalives_interval == NULL)\n\t\treturn 1;\n\n\tif (!parse_int_param(conn->keepalives_interval, &interval, conn,\n\t\t\t\t\t\t \"keepalives_interval\"))\n\t\treturn 0;\n\tif (interval < 0)\n\t\tinterval = 0;\n\n#ifdef TCP_KEEPINTVL\n\tif (setsockopt(conn->sock, IPPROTO_TCP, TCP_KEEPINTVL,\n\t\t\t\t   (char *) &interval, sizeof(interval)) < 0)\n\t{\n\t\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t  \"TCP_KEEPINTVL\",\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\n/*\n * Set the count of lost keepalive packets that will trigger a connection\n * break.\n */\nstatic int\nsetKeepalivesCount(PGconn *conn)\n{\n\tint\t\t\tcount;\n\n\tif (conn->keepalives_count == NULL)\n\t\treturn 1;\n\n\tif (!parse_int_param(conn->keepalives_count, &count, conn,\n\t\t\t\t\t\t \"keepalives_count\"))\n\t\treturn 0;\n\tif (count < 0)\n\t\tcount = 0;\n\n#ifdef TCP_KEEPCNT\n\tif (setsockopt(conn->sock, IPPROTO_TCP, TCP_KEEPCNT,\n\t\t\t\t   (char *) &count, sizeof(count)) < 0)\n\t{\n\t\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t  \"TCP_KEEPCNT\",\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n#else\t\t\t\t\t\t\t/* WIN32 */\n#ifdef SIO_KEEPALIVE_VALS\n/*\n * Enable keepalives and set the keepalive values on Win32,\n * where they are always set in one batch.\n */\nstatic int\nsetKeepalivesWin32(PGconn *conn)\n{\n\tstruct tcp_keepalive ka;\n\tDWORD\t\tretsize;\n\tint\t\t\tidle = 0;\n\tint\t\t\tinterval = 0;\n\n\tif (conn->keepalives_idle &&\n\t\t!parse_int_param(conn->keepalives_idle, &idle, conn,\n\t\t\t\t\t\t \"keepalives_idle\"))\n\t\treturn 0;\n\tif (idle <= 0)\n\t\tidle = 2 * 60 * 60;\t\t/* 2 hours = default */\n\n\tif (conn->keepalives_interval &&\n\t\t!parse_int_param(conn->keepalives_interval, &interval, conn,\n\t\t\t\t\t\t \"keepalives_interval\"))\n\t\treturn 0;\n\tif (interval <= 0)\n\t\tinterval = 1;\t\t\t/* 1 second = default */\n\n\tka.onoff = 1;\n\tka.keepalivetime = idle * 1000;\n\tka.keepaliveinterval = interval * 1000;\n\n\tif (WSAIoctl(conn->sock,\n\t\t\t\t SIO_KEEPALIVE_VALS,\n\t\t\t\t (LPVOID) &ka,\n\t\t\t\t sizeof(ka),\n\t\t\t\t NULL,\n\t\t\t\t 0,\n\t\t\t\t &retsize,\n\t\t\t\t NULL,\n\t\t\t\t NULL)\n\t\t!= 0)\n\t{\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: error code %d\\n\"),\n\t\t\t\t\t\t  \"WSAIoctl\", \"SIO_KEEPALIVE_VALS\",\n\t\t\t\t\t\t  WSAGetLastError());\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n#endif\t\t\t\t\t\t\t/* SIO_KEEPALIVE_VALS */\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n/*\n * Set the TCP user timeout.\n */\nstatic int\nsetTCPUserTimeout(PGconn *conn)\n{\n\tint\t\t\ttimeout;\n\n\tif (conn->pgtcp_user_timeout == NULL)\n\t\treturn 1;\n\n\tif (!parse_int_param(conn->pgtcp_user_timeout, &timeout, conn,\n\t\t\t\t\t\t \"tcp_user_timeout\"))\n\t\treturn 0;\n\n\tif (timeout < 0)\n\t\ttimeout = 0;\n\n#ifdef TCP_USER_TIMEOUT\n\tif (setsockopt(conn->sock, IPPROTO_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t   (char *) &timeout, sizeof(timeout)) < 0)\n\t{\n\t\tchar\t\tsebuf[256];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t  \"TCP_USER_TIMEOUT\",\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\n/* ----------\n * connectDBStart -\n *\t\tBegin the process of making a connection to the backend.\n *\n * Returns 1 if successful, 0 if not.\n * ----------\n */\nstatic int\nconnectDBStart(PGconn *conn)\n{\n\tif (!conn)\n\t\treturn 0;\n\n\tif (!conn->options_valid)\n\t\tgoto connect_errReturn;\n\n\t/*\n\t * Check for bad linking to backend-internal versions of src/common\n\t * functions (see comments in link-canary.c for the reason we need this).\n\t * Nobody but developers should see this message, so we don't bother\n\t * translating it.\n\t */\n\tif (!pg_link_canary_is_frontend())\n\t{\n\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t \"libpq is incorrectly linked to backend functions\\n\");\n\t\tgoto connect_errReturn;\n\t}\n\n\t/* Ensure our buffers are empty */\n\tconn->inStart = conn->inCursor = conn->inEnd = 0;\n\tconn->outCount = 0;\n\n\t/*\n\t * Set up to try to connect to the first host.  (Setting whichhost = -1 is\n\t * a bit of a cheat, but PQconnectPoll will advance it to 0 before\n\t * anything else looks at it.)\n\t */\n\tconn->whichhost = -1;\n\tconn->try_next_addr = false;\n\tconn->try_next_host = true;\n\tconn->status = CONNECTION_NEEDED;\n\n\t/* Also reset the target_server_type state if needed */\n\tif (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY_PASS2)\n\t\tconn->target_server_type = SERVER_TYPE_PREFER_STANDBY;\n\n\t/*\n\t * The code for processing CONNECTION_NEEDED state is in PQconnectPoll(),\n\t * so that it can easily be re-executed if needed again during the\n\t * asynchronous startup process.  However, we must run it once here,\n\t * because callers expect a success return from this routine to mean that\n\t * we are in PGRES_POLLING_WRITING connection state.\n\t */\n\tif (PQconnectPoll(conn) == PGRES_POLLING_WRITING)\n\t\treturn 1;\n\nconnect_errReturn:\n\n\t/*\n\t * If we managed to open a socket, close it immediately rather than\n\t * waiting till PQfinish.  (The application cannot have gotten the socket\n\t * from PQsocket yet, so this doesn't risk breaking anything.)\n\t */\n\tpqDropConnection(conn, true);\n\tconn->status = CONNECTION_BAD;\n\treturn 0;\n}\n\n\n/*\n *\t\tconnectDBComplete\n *\n * Block and complete a connection.\n *\n * Returns 1 on success, 0 on failure.\n */\nstatic int\nconnectDBComplete(PGconn *conn)\n{\n\tPostgresPollingStatusType flag = PGRES_POLLING_WRITING;\n\ttime_t\t\tfinish_time = ((time_t) -1);\n\tint\t\t\ttimeout = 0;\n\tint\t\t\tlast_whichhost = -2;\t/* certainly different from whichhost */\n\tstruct addrinfo *last_addr_cur = NULL;\n\n\tif (conn == NULL || conn->status == CONNECTION_BAD)\n\t\treturn 0;\n\n\t/*\n\t * Set up a time limit, if connect_timeout isn't zero.\n\t */\n\tif (conn->connect_timeout != NULL)\n\t{\n\t\tif (!parse_int_param(conn->connect_timeout, &timeout, conn,\n\t\t\t\t\t\t\t \"connect_timeout\"))\n\t\t{\n\t\t\t/* mark the connection as bad to report the parsing failure */\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (timeout > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Rounding could cause connection to fail unexpectedly quickly;\n\t\t\t * to prevent possibly waiting hardly-at-all, insist on at least\n\t\t\t * two seconds.\n\t\t\t */\n\t\t\tif (timeout < 2)\n\t\t\t\ttimeout = 2;\n\t\t}\n\t\telse\t\t\t\t\t/* negative means 0 */\n\t\t\ttimeout = 0;\n\t}\n\n\tfor (;;)\n\t{\n\t\tint\t\t\tret = 0;\n\n\t\t/*\n\t\t * (Re)start the connect_timeout timer if it's active and we are\n\t\t * considering a different host than we were last time through.  If\n\t\t * we've already succeeded, though, needn't recalculate.\n\t\t */\n\t\tif (flag != PGRES_POLLING_OK &&\n\t\t\ttimeout > 0 &&\n\t\t\t(conn->whichhost != last_whichhost ||\n\t\t\t conn->addr_cur != last_addr_cur))\n\t\t{\n\t\t\tfinish_time = time(NULL) + timeout;\n\t\t\tlast_whichhost = conn->whichhost;\n\t\t\tlast_addr_cur = conn->addr_cur;\n\t\t}\n\n\t\t/*\n\t\t * Wait, if necessary.  Note that the initial state (just after\n\t\t * PQconnectStart) is to wait for the socket to select for writing.\n\t\t */\n\t\tswitch (flag)\n\t\t{\n\t\t\tcase PGRES_POLLING_OK:\n\t\t\t\treturn 1;\t\t/* success! */\n\n\t\t\tcase PGRES_POLLING_READING:\n\t\t\t\tret = pqWaitTimed(1, 0, conn, finish_time);\n\t\t\t\tif (ret == -1)\n\t\t\t\t{\n\t\t\t\t\t/* hard failure, eg select() problem, aborts everything */\n\t\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PGRES_POLLING_WRITING:\n\t\t\t\tret = pqWaitTimed(0, 1, conn, finish_time);\n\t\t\t\tif (ret == -1)\n\t\t\t\t{\n\t\t\t\t\t/* hard failure, eg select() problem, aborts everything */\n\t\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* Just in case we failed to set it in PQconnectPoll */\n\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (ret == 1)\t\t\t/* connect_timeout elapsed */\n\t\t{\n\t\t\t/*\n\t\t\t * Give up on current server/address, try the next one.\n\t\t\t */\n\t\t\tconn->try_next_addr = true;\n\t\t\tconn->status = CONNECTION_NEEDED;\n\t\t}\n\n\t\t/*\n\t\t * Now try to advance the state machine.\n\t\t */\n\t\tflag = PQconnectPoll(conn);\n\t}\n}\n\n/* ----------------\n *\t\tPQconnectPoll\n *\n * Poll an asynchronous connection.\n *\n * Returns a PostgresPollingStatusType.\n * Before calling this function, use select(2) to determine when data\n * has arrived..\n *\n * You must call PQfinish whether or not this fails.\n *\n * This function and PQconnectStart are intended to allow connections to be\n * made without blocking the execution of your program on remote I/O. However,\n * there are a number of caveats:\n *\n *\t o\tIf you call PQtrace, ensure that the stream object into which you trace\n *\t\twill not block.\n *\t o\tIf you do not supply an IP address for the remote host (i.e. you\n *\t\tsupply a host name instead) then PQconnectStart will block on\n *\t\tgethostbyname.  You will be fine if using Unix sockets (i.e. by\n *\t\tsupplying neither a host name nor a host address).\n *\t o\tIf your backend wants to use Kerberos authentication then you must\n *\t\tsupply both a host name and a host address, otherwise this function\n *\t\tmay block on gethostname.\n *\n * ----------------\n */\nPostgresPollingStatusType\nPQconnectPoll(PGconn *conn)\n{\n\tbool\t\treset_connection_state_machine = false;\n\tbool\t\tneed_new_connection = false;\n\tPGresult   *res;\n\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\tint\t\t\toptval;\n\n\tif (conn == NULL)\n\t\treturn PGRES_POLLING_FAILED;\n\n\t/* Get the new data */\n\tswitch (conn->status)\n\t{\n\t\t\t/*\n\t\t\t * We really shouldn't have been polled in these two cases, but we\n\t\t\t * can handle it.\n\t\t\t */\n\t\tcase CONNECTION_BAD:\n\t\t\treturn PGRES_POLLING_FAILED;\n\t\tcase CONNECTION_OK:\n\t\t\treturn PGRES_POLLING_OK;\n\n\t\t\t/* These are reading states */\n\t\tcase CONNECTION_AWAITING_RESPONSE:\n\t\tcase CONNECTION_AUTH_OK:\n\t\tcase CONNECTION_CHECK_WRITABLE:\n\t\tcase CONNECTION_CONSUME:\n\t\tcase CONNECTION_CHECK_STANDBY:\n\t\t\t{\n\t\t\t\t/* Load waiting data */\n\t\t\t\tint\t\t\tn = pqReadData(conn);\n\n\t\t\t\tif (n < 0)\n\t\t\t\t\tgoto error_return;\n\t\t\t\tif (n == 0)\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* These are writing states, so we just proceed. */\n\t\tcase CONNECTION_STARTED:\n\t\tcase CONNECTION_MADE:\n\t\t\tbreak;\n\n\t\t\t/* Special cases: proceed without waiting. */\n\t\tcase CONNECTION_SSL_STARTUP:\n\t\tcase CONNECTION_NEEDED:\n\t\tcase CONNECTION_GSS_STARTUP:\n\t\tcase CONNECTION_CHECK_TARGET:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t libpq_gettext(\"invalid connection state, probably indicative of memory corruption\\n\"));\n\t\t\tgoto error_return;\n\t}\n\n\nkeep_going:\t\t\t\t\t\t/* We will come back to here until there is\n\t\t\t\t\t\t\t\t * nothing left to do. */\n\n\t/* Time to advance to next address, or next host if no more addresses? */\n\tif (conn->try_next_addr)\n\t{\n\t\tif (conn->addr_cur && conn->addr_cur->ai_next)\n\t\t{\n\t\t\tconn->addr_cur = conn->addr_cur->ai_next;\n\t\t\treset_connection_state_machine = true;\n\t\t}\n\t\telse\n\t\t\tconn->try_next_host = true;\n\t\tconn->try_next_addr = false;\n\t}\n\n\t/* Time to advance to next connhost[] entry? */\n\tif (conn->try_next_host)\n\t{\n\t\tpg_conn_host *ch;\n\t\tstruct addrinfo hint;\n\t\tint\t\t\tthisport;\n\t\tint\t\t\tret;\n\t\tchar\t\tportstr[MAXPGPATH];\n\n\t\tif (conn->whichhost + 1 < conn->nconnhost)\n\t\t\tconn->whichhost++;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Oops, no more hosts.\n\t\t\t *\n\t\t\t * If we are trying to connect in \"prefer-standby\" mode, then drop\n\t\t\t * the standby requirement and start over.\n\t\t\t *\n\t\t\t * Otherwise, an appropriate error message is already set up, so\n\t\t\t * we just need to set the right status.\n\t\t\t */\n\t\t\tif (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY &&\n\t\t\t\tconn->nconnhost > 0)\n\t\t\t{\n\t\t\t\tconn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2;\n\t\t\t\tconn->whichhost = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto error_return;\n\t\t}\n\n\t\t/* Drop any address info for previous host */\n\t\trelease_conn_addrinfo(conn);\n\n\t\t/*\n\t\t * Look up info for the new host.  On failure, log the problem in\n\t\t * conn->errorMessage, then loop around to try the next host.  (Note\n\t\t * we don't clear try_next_host until we've succeeded.)\n\t\t */\n\t\tch = &conn->connhost[conn->whichhost];\n\n\t\t/* Initialize hint structure */\n\t\tMemSet(&hint, 0, sizeof(hint));\n\t\thint.ai_socktype = SOCK_STREAM;\n\t\tconn->addrlist_family = hint.ai_family = AF_UNSPEC;\n\n\t\t/* Figure out the port number we're going to use. */\n\t\tif (ch->port == NULL || ch->port[0] == '\\0')\n\t\t\tthisport = DEF_PGPORT;\n\t\telse\n\t\t{\n\t\t\tif (!parse_int_param(ch->port, &thisport, conn, \"port\"))\n\t\t\t\tgoto error_return;\n\n\t\t\tif (thisport < 1 || thisport > 65535)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid port number: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  ch->port);\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\t\t}\n\t\tsnprintf(portstr, sizeof(portstr), \"%d\", thisport);\n\n\t\t/* Use pg_getaddrinfo_all() to resolve the address */\n\t\tswitch (ch->type)\n\t\t{\n\t\t\tcase CHT_HOST_NAME:\n\t\t\t\tret = pg_getaddrinfo_all(ch->host, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not translate host name \\\"%s\\\" to address: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  ch->host, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CHT_HOST_ADDRESS:\n\t\t\t\thint.ai_flags = AI_NUMERICHOST;\n\t\t\t\tret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not parse network address \\\"%s\\\": %s\\n\"),\n\t\t\t\t\t\t\t\t\t  ch->hostaddr, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CHT_UNIX_SOCKET:\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\t\tconn->addrlist_family = hint.ai_family = AF_UNIX;\n\t\t\t\tUNIXSOCK_PATH(portstr, thisport, ch->host);\n\t\t\t\tif (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"Unix-domain socket path \\\"%s\\\" is too long (maximum %d bytes)\\n\"),\n\t\t\t\t\t\t\t\t\t  portstr,\n\t\t\t\t\t\t\t\t\t  (int) (UNIXSOCK_PATH_BUFLEN - 1));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * NULL hostname tells pg_getaddrinfo_all to parse the service\n\t\t\t\t * name as a Unix-domain socket path.\n\t\t\t\t */\n\t\t\t\tret = pg_getaddrinfo_all(NULL, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not translate Unix-domain socket path \\\"%s\\\" to address: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  portstr, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n#else\n\t\t\t\tAssert(false);\n#endif\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, scan this addrlist for a working server address */\n\t\tconn->addr_cur = conn->addrlist;\n\t\treset_connection_state_machine = true;\n\t\tconn->try_next_host = false;\n\t}\n\n\t/* Reset connection state machine? */\n\tif (reset_connection_state_machine)\n\t{\n\t\t/*\n\t\t * (Re) initialize our connection control variables for a set of\n\t\t * connection attempts to a single server address.  These variables\n\t\t * must persist across individual connection attempts, but we must\n\t\t * reset them when we start to consider a new server.\n\t\t */\n\t\tconn->pversion = PG_PROTOCOL(3, 0);\n\t\tconn->send_appname = true;\n#ifdef USE_SSL\n\t\t/* initialize these values based on SSL mode */\n\t\tconn->allow_ssl_try = (conn->sslmode[0] != 'd');\t/* \"disable\" */\n\t\tconn->wait_ssl_try = (conn->sslmode[0] == 'a'); /* \"allow\" */\n#endif\n#ifdef ENABLE_GSS\n\t\tconn->try_gss = (conn->gssencmode[0] != 'd');\t/* \"disable\" */\n#endif\n\n\t\treset_connection_state_machine = false;\n\t\tneed_new_connection = true;\n\t}\n\n\t/* Force a new connection (perhaps to the same server as before)? */\n\tif (need_new_connection)\n\t{\n\t\t/* Drop any existing connection */\n\t\tpqDropConnection(conn, true);\n\n\t\t/* Reset all state obtained from old server */\n\t\tpqDropServerData(conn);\n\n\t\t/* Drop any PGresult we might have, too */\n\t\tconn->asyncStatus = PGASYNC_IDLE;\n\t\tconn->xactStatus = PQTRANS_IDLE;\n\t\tconn->pipelineStatus = PQ_PIPELINE_OFF;\n\t\tpqClearAsyncResult(conn);\n\n\t\t/* Reset conn->status to put the state machine in the right state */\n\t\tconn->status = CONNECTION_NEEDED;\n\n\t\tneed_new_connection = false;\n\t}\n\n\t/* Now try to advance the state machine for this connection */\n\tswitch (conn->status)\n\t{\n\t\tcase CONNECTION_NEEDED:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Try to initiate a connection to one of the addresses\n\t\t\t\t * returned by pg_getaddrinfo_all().  conn->addr_cur is the\n\t\t\t\t * next one to try.\n\t\t\t\t *\n\t\t\t\t * The extra level of braces here is historical.  It's not\n\t\t\t\t * worth reindenting this whole switch case to remove 'em.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tstruct addrinfo *addr_cur = conn->addr_cur;\n\t\t\t\t\tchar\t\thost_addr[NI_MAXHOST];\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Advance to next possible host, if we've tried all of\n\t\t\t\t\t * the addresses for the current host.\n\t\t\t\t\t */\n\t\t\t\t\tif (addr_cur == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Remember current address for possible use later */\n\t\t\t\t\tmemcpy(&conn->raddr.addr, addr_cur->ai_addr,\n\t\t\t\t\t\t   addr_cur->ai_addrlen);\n\t\t\t\t\tconn->raddr.salen = addr_cur->ai_addrlen;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set connip, too.  Note we purposely ignore strdup\n\t\t\t\t\t * failure; not a big problem if it fails.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->connip != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(conn->connip);\n\t\t\t\t\t\tconn->connip = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgetHostaddr(conn, host_addr, NI_MAXHOST);\n\t\t\t\t\tif (host_addr[0])\n\t\t\t\t\t\tconn->connip = strdup(host_addr);\n\n\t\t\t\t\t/* Try to create the socket */\n\t\t\t\t\tconn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);\n\t\t\t\t\tif (conn->sock == PGINVALID_SOCKET)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\terrorno = SOCK_ERRNO;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Silently ignore socket() failure if we have more\n\t\t\t\t\t\t * addresses to try; this reduces useless chatter in\n\t\t\t\t\t\t * cases where the address list includes both IPv4 and\n\t\t\t\t\t\t * IPv6 but kernel only accepts one family.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (addr_cur->ai_next != NULL ||\n\t\t\t\t\t\t\tconn->whichhost + 1 < conn->nconnhost)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t\temitHostIdentityInfo(conn, host_addr);\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not create socket: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Once we've identified a target address, all errors\n\t\t\t\t\t * except the preceding socket()-failure case should be\n\t\t\t\t\t * prefixed with host-identity information.  (If the\n\t\t\t\t\t * connection succeeds, the contents of conn->errorMessage\n\t\t\t\t\t * won't matter, so this is harmless.)\n\t\t\t\t\t */\n\t\t\t\t\temitHostIdentityInfo(conn, host_addr);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Select socket options: no delay of outgoing data for\n\t\t\t\t\t * TCP sockets, nonblock mode, close-on-exec.  Try the\n\t\t\t\t\t * next address if any of this fails.\n\t\t\t\t\t */\n\t\t\t\t\tif (!IS_AF_UNIX(addr_cur->ai_family))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!connectNoDelay(conn))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* error message already created */\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!pg_set_noblock(conn->sock))\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not set socket to nonblocking mode: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n#ifdef F_SETFD\n\t\t\t\t\tif (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not set socket to close-on-exec mode: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* F_SETFD */\n\n\t\t\t\t\tif (!IS_AF_UNIX(addr_cur->ai_family))\n\t\t\t\t\t{\n#ifndef WIN32\n\t\t\t\t\t\tint\t\t\ton = 1;\n#endif\n\t\t\t\t\t\tint\t\t\tusekeepalives = useKeepalives(conn);\n\t\t\t\t\t\tint\t\t\terr = 0;\n\n\t\t\t\t\t\tif (usekeepalives < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"keepalives parameter must be an integer\\n\"));\n\t\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (usekeepalives == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Do nothing */\n\t\t\t\t\t\t}\n#ifndef WIN32\n\t\t\t\t\t\telse if (setsockopt(conn->sock,\n\t\t\t\t\t\t\t\t\t\t\tSOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t\t\t\t\t\t\t\t(char *) &on, sizeof(on)) < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t\t\t\t\t\t  \"SO_KEEPALIVE\",\n\t\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!setKeepalivesIdle(conn)\n\t\t\t\t\t\t\t\t || !setKeepalivesInterval(conn)\n\t\t\t\t\t\t\t\t || !setKeepalivesCount(conn))\n\t\t\t\t\t\t\terr = 1;\n#else\t\t\t\t\t\t\t/* WIN32 */\n#ifdef SIO_KEEPALIVE_VALS\n\t\t\t\t\t\telse if (!setKeepalivesWin32(conn))\n\t\t\t\t\t\t\terr = 1;\n#endif\t\t\t\t\t\t\t/* SIO_KEEPALIVE_VALS */\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t\t\telse if (!setTCPUserTimeout(conn))\n\t\t\t\t\t\t\terr = 1;\n\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*----------\n\t\t\t\t\t * We have three methods of blocking SIGPIPE during\n\t\t\t\t\t * send() calls to this socket:\n\t\t\t\t\t *\n\t\t\t\t\t *\t- setsockopt(sock, SO_NOSIGPIPE)\n\t\t\t\t\t *\t- send(sock, ..., MSG_NOSIGNAL)\n\t\t\t\t\t *\t- setting the signal mask to SIG_IGN during send()\n\t\t\t\t\t *\n\t\t\t\t\t * The third method requires three syscalls per send,\n\t\t\t\t\t * so we prefer either of the first two, but they are\n\t\t\t\t\t * less portable.  The state is tracked in the following\n\t\t\t\t\t * members of PGconn:\n\t\t\t\t\t *\n\t\t\t\t\t * conn->sigpipe_so\t\t- we have set up SO_NOSIGPIPE\n\t\t\t\t\t * conn->sigpipe_flag\t- we're specifying MSG_NOSIGNAL\n\t\t\t\t\t *\n\t\t\t\t\t * If we can use SO_NOSIGPIPE, then set sigpipe_so here\n\t\t\t\t\t * and we're done.  Otherwise, set sigpipe_flag so that\n\t\t\t\t\t * we will try MSG_NOSIGNAL on sends.  If we get an error\n\t\t\t\t\t * with MSG_NOSIGNAL, we'll clear that flag and revert to\n\t\t\t\t\t * signal masking.\n\t\t\t\t\t *----------\n\t\t\t\t\t */\n\t\t\t\t\tconn->sigpipe_so = false;\n#ifdef MSG_NOSIGNAL\n\t\t\t\t\tconn->sigpipe_flag = true;\n#else\n\t\t\t\t\tconn->sigpipe_flag = false;\n#endif\t\t\t\t\t\t\t/* MSG_NOSIGNAL */\n\n#ifdef SO_NOSIGPIPE\n\t\t\t\t\toptval = 1;\n\t\t\t\t\tif (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE,\n\t\t\t\t\t\t\t\t   (char *) &optval, sizeof(optval)) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->sigpipe_so = true;\n\t\t\t\t\t\tconn->sigpipe_flag = false;\n\t\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* SO_NOSIGPIPE */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Start/make connection.  This should not block, since we\n\t\t\t\t\t * are in nonblock mode.  If it does, well, too bad.\n\t\t\t\t\t */\n\t\t\t\t\tif (connect(conn->sock, addr_cur->ai_addr,\n\t\t\t\t\t\t\t\taddr_cur->ai_addrlen) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (SOCK_ERRNO == EINPROGRESS ||\n#ifdef WIN32\n\t\t\t\t\t\t\tSOCK_ERRNO == EWOULDBLOCK ||\n#endif\n\t\t\t\t\t\t\tSOCK_ERRNO == EINTR)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * This is fine - we're in non-blocking mode, and\n\t\t\t\t\t\t\t * the connection is in progress.  Tell caller to\n\t\t\t\t\t\t\t * wait for write-ready on socket.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconn->status = CONNECTION_STARTED;\n\t\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* otherwise, trouble */\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Hm, we're connected already --- seems the \"nonblock\n\t\t\t\t\t\t * connection\" wasn't.  Advance the state machine and\n\t\t\t\t\t\t * go do the next stuff.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_STARTED;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * This connection failed.  Add the error report to\n\t\t\t\t\t * conn->errorMessage, then try the next address if any.\n\t\t\t\t\t */\n\t\t\t\t\tconnectFailureMessage(conn, SOCK_ERRNO);\n\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase CONNECTION_STARTED:\n\t\t\t{\n\t\t\t\tACCEPT_TYPE_ARG3 optlen = sizeof(optval);\n\n\t\t\t\t/*\n\t\t\t\t * Write ready, since we've made it here, so the connection\n\t\t\t\t * has been made ... or has failed.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Now check (using getsockopt) that there is not an error\n\t\t\t\t * state waiting for us on the socket.\n\t\t\t\t */\n\n\t\t\t\tif (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,\n\t\t\t\t\t\t\t   (char *) &optval, &optlen) == -1)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get socket error status: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\telse if (optval != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * When using a nonblocking connect, we will typically see\n\t\t\t\t\t * connect failures at this point, so provide a friendly\n\t\t\t\t\t * error message.\n\t\t\t\t\t */\n\t\t\t\t\tconnectFailureMessage(conn, optval);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Try the next address if any, just as in the case where\n\t\t\t\t\t * connect() returned failure immediately.\n\t\t\t\t\t */\n\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Fill in the client address */\n\t\t\t\tconn->laddr.salen = sizeof(conn->laddr.addr);\n\t\t\t\tif (getsockname(conn->sock,\n\t\t\t\t\t\t\t\t(struct sockaddr *) &conn->laddr.addr,\n\t\t\t\t\t\t\t\t&conn->laddr.salen) < 0)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get client address from socket: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make sure we can write before advancing to next step.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t}\n\n\t\tcase CONNECTION_MADE:\n\t\t\t{\n\t\t\t\tchar\t   *startpacket;\n\t\t\t\tint\t\t\tpacketlen;\n\n\t\t\t\t/*\n\t\t\t\t * Implement requirepeer check, if requested and it's a\n\t\t\t\t * Unix-domain socket.\n\t\t\t\t */\n\t\t\t\tif (conn->requirepeer && conn->requirepeer[0] &&\n\t\t\t\t\tIS_AF_UNIX(conn->raddr.addr.ss_family))\n\t\t\t\t{\n#ifndef WIN32\n\t\t\t\t\tchar\t\tpwdbuf[BUFSIZ];\n\t\t\t\t\tstruct passwd pass_buf;\n\t\t\t\t\tstruct passwd *pass;\n\t\t\t\t\tint\t\t\tpasserr;\n#endif\n\t\t\t\t\tuid_t\t\tuid;\n\t\t\t\t\tgid_t\t\tgid;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tif (getpeereid(conn->sock, &uid, &gid) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Provide special error message if getpeereid is a\n\t\t\t\t\t\t * stub\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (errno == ENOSYS)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"requirepeer parameter is not supported on this platform\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get peer credentials: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  strerror_r(errno, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n#ifndef WIN32\n\t\t\t\t\tpasserr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass);\n\t\t\t\t\tif (pass == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (passerr != 0)\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not look up local user ID %d: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  (int) uid,\n\t\t\t\t\t\t\t\t\t\t\t  strerror_r(passerr, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"local user with ID %d does not exist\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  (int) uid);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (strcmp(pass->pw_name, conn->requirepeer) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"requirepeer specifies \\\"%s\\\", but actual peer user name is \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t\t  conn->requirepeer, pass->pw_name);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n#else\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t\t/* should have failed with ENOSYS above */\n\t\t\t\t\tAssert(false);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t}\n\n\t\t\t\tif (IS_AF_UNIX(conn->raddr.addr.ss_family))\n\t\t\t\t{\n\t\t\t\t\t/* Don't request SSL or GSSAPI over Unix sockets */\n#ifdef USE_SSL\n\t\t\t\t\tconn->allow_ssl_try = false;\n#endif\n#ifdef ENABLE_GSS\n\t\t\t\t\tconn->try_gss = false;\n#endif\n\t\t\t\t}\n\n#ifdef ENABLE_GSS\n\n\t\t\t\t/*\n\t\t\t\t * If GSSAPI encryption is enabled, then call\n\t\t\t\t * pg_GSS_have_cred_cache() which will return true if we can\n\t\t\t\t * acquire credentials (and give us a handle to use in\n\t\t\t\t * conn->gcred), and then send a packet to the server asking\n\t\t\t\t * for GSSAPI Encryption (and skip past SSL negotiation and\n\t\t\t\t * regular startup below).\n\t\t\t\t */\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t\tconn->try_gss = pg_GSS_have_cred_cache(&conn->gcred);\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t{\n\t\t\t\t\tProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);\n\n\t\t\t\t\tif (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send GSSAPI negotiation packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Ok, wait for response */\n\t\t\t\t\tconn->status = CONNECTION_GSS_STARTUP;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\t\t\t\telse if (!conn->gctx && conn->gssencmode[0] == 'r')\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\\n\"));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n#endif\n\n#ifdef USE_SSL\n\n\t\t\t\t/*\n\t\t\t\t * Enable the libcrypto callbacks before checking if SSL needs\n\t\t\t\t * to be done.  This is done before sending the startup packet\n\t\t\t\t * as depending on the type of authentication done, like MD5\n\t\t\t\t * or SCRAM that use cryptohashes, the callbacks would be\n\t\t\t\t * required even without a SSL connection\n\t\t\t\t */\n\t\t\t\tif (pqsecure_initialize(conn, false, true) < 0)\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\t/*\n\t\t\t\t * If SSL is enabled and we haven't already got encryption of\n\t\t\t\t * some sort running, request SSL instead of sending the\n\t\t\t\t * startup message.\n\t\t\t\t */\n\t\t\t\tif (conn->allow_ssl_try && !conn->wait_ssl_try &&\n\t\t\t\t\t!conn->ssl_in_use\n#ifdef ENABLE_GSS\n\t\t\t\t\t&& !conn->gssenc\n#endif\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tProtocolVersion pv;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Send the SSL request packet.\n\t\t\t\t\t *\n\t\t\t\t\t * Theoretically, this could block, but it really\n\t\t\t\t\t * shouldn't since we only got here if the socket is\n\t\t\t\t\t * write-ready.\n\t\t\t\t\t */\n\t\t\t\t\tpv = pg_hton32(NEGOTIATE_SSL_CODE);\n\t\t\t\t\tif (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send SSL negotiation packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\t/* Ok, wait for response */\n\t\t\t\t\tconn->status = CONNECTION_SSL_STARTUP;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_SSL */\n\n\t\t\t\t/*\n\t\t\t\t * Build the startup packet.\n\t\t\t\t */\n\t\t\t\tstartpacket = pqBuildStartupPacket3(conn, &packetlen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEnvironmentOptions);\n\t\t\t\tif (!startpacket)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Send the startup packet.\n\t\t\t\t *\n\t\t\t\t * Theoretically, this could block, but it really shouldn't\n\t\t\t\t * since we only got here if the socket is write-ready.\n\t\t\t\t */\n\t\t\t\tif (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send startup packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tfree(startpacket);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\tfree(startpacket);\n\n\t\t\t\tconn->status = CONNECTION_AWAITING_RESPONSE;\n\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Handle SSL negotiation: wait for postmaster messages and\n\t\t\t * respond as necessary.\n\t\t\t */\n\t\tcase CONNECTION_SSL_STARTUP:\n\t\t\t{\n#ifdef USE_SSL\n\t\t\t\tPostgresPollingStatusType pollres;\n\n\t\t\t\t/*\n\t\t\t\t * On first time through, get the postmaster's response to our\n\t\t\t\t * SSL negotiation packet.\n\t\t\t\t */\n\t\t\t\tif (!conn->ssl_in_use)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We use pqReadData here since it has the logic to\n\t\t\t\t\t * distinguish no-data-yet from connection closure. Since\n\t\t\t\t\t * conn->ssl isn't set, a plain recv() will occur.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tSSLok;\n\t\t\t\t\tint\t\t\trdresult;\n\n\t\t\t\t\trdresult = pqReadData(conn);\n\t\t\t\t\tif (rdresult < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* errorMessage is already filled in */\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\tif (rdresult == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* caller failed to wait for data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\tif (pqGetc(&SSLok, conn) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* should not happen really */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\tif (SSLok == 'S')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Set up global SSL state if required.  The crypto\n\t\t\t\t\t\t * state has already been set if libpq took care of\n\t\t\t\t\t\t * doing that, so there is no need to make that happen\n\t\t\t\t\t\t * again.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (pqsecure_initialize(conn, true, false) != 0)\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\telse if (SSLok == 'N')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\t\tconn->inStart = conn->inCursor;\n\t\t\t\t\t\t/* OK to do without SSL? */\n\t\t\t\t\t\tif (conn->sslmode[0] == 'r' ||\t/* \"require\" */\n\t\t\t\t\t\t\tconn->sslmode[0] == 'v')\t/* \"verify-ca\" or\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * \"verify-full\" */\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Require SSL, but server does not want it */\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server does not support SSL, but SSL was required\\n\"));\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Otherwise, proceed with normal startup */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\t/* We can proceed using this connection */\n\t\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t}\n\t\t\t\t\telse if (SSLok == 'E')\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Server failure of some sort, such as failure to\n\t\t\t\t\t\t * fork a backend process.  We need to process and\n\t\t\t\t\t\t * report the error message, which might be formatted\n\t\t\t\t\t\t * according to either protocol 2 or protocol 3.\n\t\t\t\t\t\t * Rather than duplicate the code for that, we flip\n\t\t\t\t\t\t * into AWAITING_RESPONSE state and let the code there\n\t\t\t\t\t\t * deal with it.  Note we have *not* consumed the \"E\"\n\t\t\t\t\t\t * byte here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_AWAITING_RESPONSE;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"received invalid response to SSL negotiation: %c\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SSLok);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Begin or continue the SSL negotiation process.\n\t\t\t\t */\n\t\t\t\tpollres = pqsecure_open_client(conn);\n\t\t\t\tif (pollres == PGRES_POLLING_OK)\n\t\t\t\t{\n\t\t\t\t\t/* SSL handshake done, ready to send startup packet */\n\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t}\n\t\t\t\tif (pollres == PGRES_POLLING_FAILED)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Failed ... if sslmode is \"prefer\" then do a non-SSL\n\t\t\t\t\t * retry\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'p' /* \"prefer\" */\n\t\t\t\t\t\t&& conn->allow_ssl_try\t/* redundant? */\n\t\t\t\t\t\t&& !conn->wait_ssl_try) /* redundant? */\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else it's a hard failure */\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\t/* Else, return POLLING_READING or POLLING_WRITING status */\n\t\t\t\treturn pollres;\n#else\t\t\t\t\t\t\t/* !USE_SSL */\n\t\t\t\t/* can't get here */\n\t\t\t\tgoto error_return;\n#endif\t\t\t\t\t\t\t/* USE_SSL */\n\t\t\t}\n\n\t\tcase CONNECTION_GSS_STARTUP:\n\t\t\t{\n#ifdef ENABLE_GSS\n\t\t\t\tPostgresPollingStatusType pollres;\n\n\t\t\t\t/*\n\t\t\t\t * If we haven't yet, get the postmaster's response to our\n\t\t\t\t * negotiation packet\n\t\t\t\t */\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tgss_ok;\n\t\t\t\t\tint\t\t\trdresult = pqReadData(conn);\n\n\t\t\t\t\tif (rdresult < 0)\n\t\t\t\t\t\t/* pqReadData fills in error message */\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\telse if (rdresult == 0)\n\t\t\t\t\t\t/* caller failed to wait for data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\tif (pqGetc(&gss_ok, conn) < 0)\n\t\t\t\t\t\t/* shouldn't happen... */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\t\tif (gss_ok == 'E')\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Server failure of some sort.  Assume it's a\n\t\t\t\t\t\t * protocol version support failure, and let's see if\n\t\t\t\t\t\t * we can't recover (if it's not, we'll get a better\n\t\t\t\t\t\t * error message on retry).  Server gets fussy if we\n\t\t\t\t\t\t * don't hang up the socket, though.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\tif (gss_ok == 'N')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Server doesn't want GSSAPI; fall back if we can */\n\t\t\t\t\t\tif (conn->gssencmode[0] == 'r')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server doesn't support GSSAPI encryption, but it was required\\n\"));\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\t/* We can proceed using this connection */\n\t\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t}\n\t\t\t\t\telse if (gss_ok != 'G')\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"received invalid response to GSSAPI negotiation: %c\\n\"),\n\t\t\t\t\t\t\t\t\t\t  gss_ok);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Begin or continue GSSAPI negotiation */\n\t\t\t\tpollres = pqsecure_open_gss(conn);\n\t\t\t\tif (pollres == PGRES_POLLING_OK)\n\t\t\t\t{\n\t\t\t\t\t/* All set for startup packet */\n\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t}\n\t\t\t\telse if (pollres == PGRES_POLLING_FAILED &&\n\t\t\t\t\t\t conn->gssencmode[0] == 'p')\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We failed, but we can retry on \"prefer\".  Have to drop\n\t\t\t\t\t * the current connection to do so, though.\n\t\t\t\t\t */\n\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\treturn pollres;\n#else\t\t\t\t\t\t\t/* !ENABLE_GSS */\n\t\t\t\t/* unreachable */\n\t\t\t\tgoto error_return;\n#endif\t\t\t\t\t\t\t/* ENABLE_GSS */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Handle authentication exchange: wait for postmaster messages\n\t\t\t * and respond as necessary.\n\t\t\t */\n\t\tcase CONNECTION_AWAITING_RESPONSE:\n\t\t\t{\n\t\t\t\tchar\t\tberesp;\n\t\t\t\tint\t\t\tmsgLength;\n\t\t\t\tint\t\t\tavail;\n\t\t\t\tAuthRequest areq;\n\t\t\t\tint\t\t\tres;\n\n\t\t\t\t/*\n\t\t\t\t * Scan the message from current point (note that if we find\n\t\t\t\t * the message is incomplete, we will return without advancing\n\t\t\t\t * inStart, and resume here next time).\n\t\t\t\t */\n\t\t\t\tconn->inCursor = conn->inStart;\n\n\t\t\t\t/* Read type byte */\n\t\t\t\tif (pqGetc(&beresp, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Validate message type: we expect only an authentication\n\t\t\t\t * request or an error here.  Anything else probably means\n\t\t\t\t * it's not Postgres on the other end at all.\n\t\t\t\t */\n\t\t\t\tif (!(beresp == 'R' || beresp == 'E'))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"expected authentication request from server, but received %c\\n\"),\n\t\t\t\t\t\t\t\t\t  beresp);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* Read message length word */\n\t\t\t\tif (pqGetInt(&msgLength, 4, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Try to validate message length before using it.\n\t\t\t\t * Authentication requests can't be very large, although GSS\n\t\t\t\t * auth requests may not be that small.  Errors can be a\n\t\t\t\t * little larger, but not huge.  If we see a large apparent\n\t\t\t\t * length in an error, it means we're really talking to a\n\t\t\t\t * pre-3.0-protocol server; cope.  (Before version 14, the\n\t\t\t\t * server also used the old protocol for errors that happened\n\t\t\t\t * before processing the startup packet.)\n\t\t\t\t */\n\t\t\t\tif (beresp == 'R' && (msgLength < 8 || msgLength > 2000))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"expected authentication request from server, but received %c\\n\"),\n\t\t\t\t\t\t\t\t\t  beresp);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\tif (beresp == 'E' && (msgLength < 8 || msgLength > 30000))\n\t\t\t\t{\n\t\t\t\t\t/* Handle error from a pre-3.0 server */\n\t\t\t\t\tconn->inCursor = conn->inStart + 1; /* reread data */\n\t\t\t\t\tif (pqGets_append(&conn->errorMessage, conn))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\t/* OK, we read the message; mark data consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Before 7.2, the postmaster didn't always end its\n\t\t\t\t\t * messages with a newline, so add one if needed to\n\t\t\t\t\t * conform to libpq conventions.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->errorMessage.len == 0 ||\n\t\t\t\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferChar(&conn->errorMessage, '\\n');\n\t\t\t\t\t}\n\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Can't process if message body isn't all here yet.\n\t\t\t\t */\n\t\t\t\tmsgLength -= 4;\n\t\t\t\tavail = conn->inEnd - conn->inCursor;\n\t\t\t\tif (avail < msgLength)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Before returning, try to enlarge the input buffer if\n\t\t\t\t\t * needed to hold the whole message; see notes in\n\t\t\t\t\t * pqParseInput3.\n\t\t\t\t\t */\n\t\t\t\t\tif (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength,\n\t\t\t\t\t\t\t\t\t\t\t conn))\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/* Handle errors. */\n\t\t\t\tif (beresp == 'E')\n\t\t\t\t{\n\t\t\t\t\tif (pqGetErrorNotice3(conn, true))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\t/* OK, we read the message; mark data consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If error is \"cannot connect now\", try the next host if\n\t\t\t\t\t * any (but we don't want to consider additional addresses\n\t\t\t\t\t * for this host, nor is there much point in changing SSL\n\t\t\t\t\t * or GSS mode).  This is helpful when dealing with\n\t\t\t\t\t * standby servers that might not be in hot-standby state.\n\t\t\t\t\t */\n\t\t\t\t\tif (strcmp(conn->last_sqlstate,\n\t\t\t\t\t\t\t   ERRCODE_CANNOT_CONNECT_NOW) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check to see if we should mention pgpassfile */\n\t\t\t\t\tpgpassfileWarning(conn);\n\n#ifdef ENABLE_GSS\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If gssencmode is \"prefer\" and we're using GSSAPI, retry\n\t\t\t\t\t * without it.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->gssenc && conn->gssencmode[0] == 'p')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\n\n#ifdef USE_SSL\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if sslmode is \"allow\" and we haven't tried an SSL\n\t\t\t\t\t * connection already, then retry with an SSL connection\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'a' /* \"allow\" */\n\t\t\t\t\t\t&& !conn->ssl_in_use\n\t\t\t\t\t\t&& conn->allow_ssl_try\n\t\t\t\t\t\t&& conn->wait_ssl_try)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->wait_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if sslmode is \"prefer\" and we're in an SSL connection,\n\t\t\t\t\t * then do a non-SSL retry\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'p' /* \"prefer\" */\n\t\t\t\t\t\t&& conn->ssl_in_use\n\t\t\t\t\t\t&& conn->allow_ssl_try\t/* redundant? */\n\t\t\t\t\t\t&& !conn->wait_ssl_try) /* redundant? */\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\n\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* It is an authentication request. */\n\t\t\t\tconn->auth_req_received = true;\n\n\t\t\t\t/* Get the type of request. */\n\t\t\t\tif (pqGetInt((int *) &areq, 4, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there are more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\t\t\t\tmsgLength -= 4;\n\n\t\t\t\t/*\n\t\t\t\t * Process the rest of the authentication request message, and\n\t\t\t\t * respond to it if necessary.\n\t\t\t\t *\n\t\t\t\t * Note that conn->pghost must be non-NULL if we are going to\n\t\t\t\t * avoid the Kerberos code doing a hostname look-up.\n\t\t\t\t */\n\t\t\t\tres = pg_fe_sendauth(areq, msgLength, conn);\n\n\t\t\t\t/* OK, we have processed the message; mark data consumed */\n\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\tif (res != STATUS_OK)\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\t/*\n\t\t\t\t * Just make sure that any data sent by pg_fe_sendauth is\n\t\t\t\t * flushed out.  Although this theoretically could block, it\n\t\t\t\t * really shouldn't since we don't send large auth responses.\n\t\t\t\t */\n\t\t\t\tif (pqFlush(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (areq == AUTH_REQ_OK)\n\t\t\t\t{\n\t\t\t\t\t/* We are done with authentication exchange */\n\t\t\t\t\tconn->status = CONNECTION_AUTH_OK;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set asyncStatus so that PQgetResult will think that\n\t\t\t\t\t * what comes back next is the result of a query.  See\n\t\t\t\t\t * below.\n\t\t\t\t\t */\n\t\t\t\t\tconn->asyncStatus = PGASYNC_BUSY;\n\t\t\t\t}\n\n\t\t\t\t/* Look to see if we have more data yet. */\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_AUTH_OK:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Now we expect to hear from the backend. A ReadyForQuery\n\t\t\t\t * message indicates that startup is successful, but we might\n\t\t\t\t * also get an Error message indicating failure. (Notice\n\t\t\t\t * messages indicating nonfatal warnings are also allowed by\n\t\t\t\t * the protocol, as are ParameterStatus and BackendKeyData\n\t\t\t\t * messages.) Easiest way to handle this is to let\n\t\t\t\t * PQgetResult() read the messages. We just have to fake it\n\t\t\t\t * out about the state of the connection, by setting\n\t\t\t\t * asyncStatus = PGASYNC_BUSY (done above).\n\t\t\t\t */\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\tres = PQgetResult(conn);\n\n\t\t\t\t/*\n\t\t\t\t * NULL return indicating we have gone to IDLE state is\n\t\t\t\t * expected\n\t\t\t\t */\n\t\t\t\tif (res)\n\t\t\t\t{\n\t\t\t\t\tif (res->resultStatus != PGRES_FATAL_ERROR)\n\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"unexpected message from server during startup\\n\"));\n\t\t\t\t\telse if (conn->send_appname &&\n\t\t\t\t\t\t\t (conn->appname || conn->fbappname))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If we tried to send application_name, check to see\n\t\t\t\t\t\t * if the error is about that --- pre-9.0 servers will\n\t\t\t\t\t\t * reject it at this stage of the process.  If so,\n\t\t\t\t\t\t * close the connection and retry without sending\n\t\t\t\t\t\t * application_name.  We could possibly get a false\n\t\t\t\t\t\t * SQLSTATE match here and retry uselessly, but there\n\t\t\t\t\t\t * seems no great harm in that; we'll just get the\n\t\t\t\t\t\t * same error again if it's unrelated.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst char *sqlstate;\n\n\t\t\t\t\t\tsqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);\n\t\t\t\t\t\tif (sqlstate &&\n\t\t\t\t\t\t\tstrcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPQclear(res);\n\t\t\t\t\t\t\tconn->send_appname = false;\n\t\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if the resultStatus is FATAL, then conn->errorMessage\n\t\t\t\t\t * already has a copy of the error; needn't copy it back.\n\t\t\t\t\t * But add a newline if it's not there already, since\n\t\t\t\t\t * postmaster error messages may not have one.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->errorMessage.len <= 0 ||\n\t\t\t\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')\n\t\t\t\t\t\tappendPQExpBufferChar(&conn->errorMessage, '\\n');\n\t\t\t\t\tPQclear(res);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* Almost there now ... */\n\t\t\t\tconn->status = CONNECTION_CHECK_TARGET;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_TARGET:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If a read-write, read-only, primary, or standby connection\n\t\t\t\t * is required, see if we have one.\n\t\t\t\t */\n\t\t\t\tif (conn->target_server_type == SERVER_TYPE_READ_WRITE ||\n\t\t\t\t\tconn->target_server_type == SERVER_TYPE_READ_ONLY)\n\t\t\t\t{\n\t\t\t\t\tbool\t\tread_only_server;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the server didn't report\n\t\t\t\t\t * \"default_transaction_read_only\" or \"in_hot_standby\" at\n\t\t\t\t\t * startup, we must determine its state by sending the\n\t\t\t\t\t * query \"SHOW transaction_read_only\".  This GUC exists in\n\t\t\t\t\t * all server versions that support 3.0 protocol.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->default_transaction_read_only == PG_BOOL_UNKNOWN ||\n\t\t\t\t\t\tconn->in_hot_standby == PG_BOOL_UNKNOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We use PQsendQueryContinue so that\n\t\t\t\t\t\t * conn->errorMessage does not get cleared.  We need\n\t\t\t\t\t\t * to preserve any error messages related to previous\n\t\t\t\t\t\t * hosts we have tried and failed to connect to.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tif (!PQsendQueryContinue(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t \"SHOW transaction_read_only\"))\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t/* We'll return to this state when we have the answer */\n\t\t\t\t\t\tconn->status = CONNECTION_CHECK_WRITABLE;\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* OK, we can make the test */\n\t\t\t\t\tread_only_server =\n\t\t\t\t\t\t(conn->default_transaction_read_only == PG_BOOL_YES ||\n\t\t\t\t\t\t conn->in_hot_standby == PG_BOOL_YES);\n\n\t\t\t\t\tif ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ?\n\t\t\t\t\t\tread_only_server : !read_only_server)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Wrong server state, reject and try the next host */\n\t\t\t\t\t\tif (conn->target_server_type == SERVER_TYPE_READ_WRITE)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"session is read-only\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"session is not read-only\\n\"));\n\n\t\t\t\t\t\t/* Close connection politely. */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Try next host if any, but we don't want to consider\n\t\t\t\t\t\t * additional addresses for this host.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (conn->target_server_type == SERVER_TYPE_PRIMARY ||\n\t\t\t\t\t\t conn->target_server_type == SERVER_TYPE_STANDBY ||\n\t\t\t\t\t\t conn->target_server_type == SERVER_TYPE_PREFER_STANDBY)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If the server didn't report \"in_hot_standby\" at\n\t\t\t\t\t * startup, we must determine its state by sending the\n\t\t\t\t\t * query \"SELECT pg_catalog.pg_is_in_recovery()\".  Servers\n\t\t\t\t\t * before 9.0 don't have that function, but by the same\n\t\t\t\t\t * token they don't have any standby mode, so we may just\n\t\t\t\t\t * assume the result.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sversion < 90000)\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\n\t\t\t\t\tif (conn->in_hot_standby == PG_BOOL_UNKNOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We use PQsendQueryContinue so that\n\t\t\t\t\t\t * conn->errorMessage does not get cleared.  We need\n\t\t\t\t\t\t * to preserve any error messages related to previous\n\t\t\t\t\t\t * hosts we have tried and failed to connect to.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tif (!PQsendQueryContinue(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t \"SELECT pg_catalog.pg_is_in_recovery()\"))\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t/* We'll return to this state when we have the answer */\n\t\t\t\t\t\tconn->status = CONNECTION_CHECK_STANDBY;\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* OK, we can make the test */\n\t\t\t\t\tif ((conn->target_server_type == SERVER_TYPE_PRIMARY) ?\n\t\t\t\t\t\t(conn->in_hot_standby == PG_BOOL_YES) :\n\t\t\t\t\t\t(conn->in_hot_standby == PG_BOOL_NO))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Wrong server state, reject and try the next host */\n\t\t\t\t\t\tif (conn->target_server_type == SERVER_TYPE_PRIMARY)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server is in hot standby mode\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server is not in hot standby mode\\n\"));\n\n\t\t\t\t\t\t/* Close connection politely. */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Try next host if any, but we don't want to consider\n\t\t\t\t\t\t * additional addresses for this host.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* We can release the address list now. */\n\t\t\t\trelease_conn_addrinfo(conn);\n\n\t\t\t\t/*\n\t\t\t\t * Contents of conn->errorMessage are no longer interesting\n\t\t\t\t * (and it seems some clients expect it to be empty after a\n\t\t\t\t * successful connection).\n\t\t\t\t */\n\t\t\t\tresetPQExpBuffer(&conn->errorMessage);\n\n\t\t\t\t/* We are open for business! */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\treturn PGRES_POLLING_OK;\n\t\t\t}\n\n\t\tcase CONNECTION_CONSUME:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This state just makes sure the connection is idle after\n\t\t\t\t * we've obtained the result of a SHOW or SELECT query.  Once\n\t\t\t\t * we're clear, return to CONNECTION_CHECK_TARGET state to\n\t\t\t\t * decide what to do next.  We must transiently set status =\n\t\t\t\t * CONNECTION_OK in order to use the result-consuming\n\t\t\t\t * subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/* Call PQgetResult() again until we get a NULL result */\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res != NULL)\n\t\t\t\t{\n\t\t\t\t\tPQclear(res);\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tconn->status = CONNECTION_CHECK_TARGET;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_WRITABLE:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Waiting for result of \"SHOW transaction_read_only\".  We\n\t\t\t\t * must transiently set status = CONNECTION_OK in order to use\n\t\t\t\t * the result-consuming subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CHECK_WRITABLE;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res && PQresultStatus(res) == PGRES_TUPLES_OK &&\n\t\t\t\t\tPQntuples(res) == 1)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *val = PQgetvalue(res, 0, 0);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * \"transaction_read_only = on\" proves that at least one\n\t\t\t\t\t * of default_transaction_read_only and in_hot_standby is\n\t\t\t\t\t * on, but we don't actually know which.  We don't care\n\t\t\t\t\t * though for the purpose of identifying a read-only\n\t\t\t\t\t * session, so satisfy the CONNECTION_CHECK_TARGET code by\n\t\t\t\t\t * claiming they are both on.  On the other hand, if it's\n\t\t\t\t\t * a read-write session, they are certainly both off.\n\t\t\t\t\t */\n\t\t\t\t\tif (strncmp(val, \"on\", 2) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->default_transaction_read_only = PG_BOOL_YES;\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_YES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->default_transaction_read_only = PG_BOOL_NO;\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\t\t\t\t\t}\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t\t/* Finish reading messages before continuing */\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Something went wrong with \"SHOW transaction_read_only\". */\n\t\t\t\tif (res)\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t/* Append error report to conn->errorMessage. */\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"\\\"%s\\\" failed\\n\"),\n\t\t\t\t\t\t\t\t  \"SHOW transaction_read_only\");\n\n\t\t\t\t/* Close connection politely. */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t/* Try next host. */\n\t\t\t\tconn->try_next_host = true;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_STANDBY:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Waiting for result of \"SELECT pg_is_in_recovery()\".  We\n\t\t\t\t * must transiently set status = CONNECTION_OK in order to use\n\t\t\t\t * the result-consuming subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CHECK_STANDBY;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res && PQresultStatus(res) == PGRES_TUPLES_OK &&\n\t\t\t\t\tPQntuples(res) == 1)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *val = PQgetvalue(res, 0, 0);\n\n\t\t\t\t\tif (strncmp(val, \"t\", 1) == 0)\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_YES;\n\t\t\t\t\telse\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t\t/* Finish reading messages before continuing */\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Something went wrong with \"SELECT pg_is_in_recovery()\". */\n\t\t\t\tif (res)\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t/* Append error report to conn->errorMessage. */\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"\\\"%s\\\" failed\\n\"),\n\t\t\t\t\t\t\t\t  \"SELECT pg_is_in_recovery()\");\n\n\t\t\t\t/* Close connection politely. */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t/* Try next host. */\n\t\t\t\tconn->try_next_host = true;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection state %d, \"\n\t\t\t\t\t\t\t\t\t\t\t\"probably indicative of memory corruption\\n\"),\n\t\t\t\t\t\t\t  conn->status);\n\t\t\tgoto error_return;\n\t}\n\n\t/* Unreachable */\n\nerror_return:\n\n\t/*\n\t * We used to close the socket at this point, but that makes it awkward\n\t * for those above us if they wish to remove this socket from their own\n\t * records (an fd_set for example).  We'll just have this socket closed\n\t * when PQfinish is called (which is compulsory even after an error, since\n\t * the connection structure must be freed).\n\t */\n\tconn->status = CONNECTION_BAD;\n\treturn PGRES_POLLING_FAILED;\n}\n\n\n/*\n * internal_ping\n *\t\tDetermine if a server is running and if we can connect to it.\n *\n * The argument is a connection that's been started, but not completed.\n */\nstatic PGPing\ninternal_ping(PGconn *conn)\n{\n\t/* Say \"no attempt\" if we never got to PQconnectPoll */\n\tif (!conn || !conn->options_valid)\n\t\treturn PQPING_NO_ATTEMPT;\n\n\t/* Attempt to complete the connection */\n\tif (conn->status != CONNECTION_BAD)\n\t\t(void) connectDBComplete(conn);\n\n\t/* Definitely OK if we succeeded */\n\tif (conn->status != CONNECTION_BAD)\n\t\treturn PQPING_OK;\n\n\t/*\n\t * Here begins the interesting part of \"ping\": determine the cause of the\n\t * failure in sufficient detail to decide what to return.  We do not want\n\t * to report that the server is not up just because we didn't have a valid\n\t * password, for example.  In fact, any sort of authentication request\n\t * implies the server is up.  (We need this check since the libpq side of\n\t * things might have pulled the plug on the connection before getting an\n\t * error as such from the postmaster.)\n\t */\n\tif (conn->auth_req_received)\n\t\treturn PQPING_OK;\n\n\t/*\n\t * If we failed to get any ERROR response from the postmaster, report\n\t * PQPING_NO_RESPONSE.  This result could be somewhat misleading for a\n\t * pre-7.4 server, since it won't send back a SQLSTATE, but those are long\n\t * out of support.  Another corner case where the server could return a\n\t * failure without a SQLSTATE is fork failure, but PQPING_NO_RESPONSE\n\t * isn't totally unreasonable for that anyway.  We expect that every other\n\t * failure case in a modern server will produce a report with a SQLSTATE.\n\t *\n\t * NOTE: whenever we get around to making libpq generate SQLSTATEs for\n\t * client-side errors, we should either not store those into\n\t * last_sqlstate, or add an extra flag so we can tell client-side errors\n\t * apart from server-side ones.\n\t */\n\tif (strlen(conn->last_sqlstate) != 5)\n\t\treturn PQPING_NO_RESPONSE;\n\n\t/*\n\t * Report PQPING_REJECT if server says it's not accepting connections. (We\n\t * distinguish this case mainly for the convenience of pg_ctl.)\n\t */\n\tif (strcmp(conn->last_sqlstate, ERRCODE_CANNOT_CONNECT_NOW) == 0)\n\t\treturn PQPING_REJECT;\n\n\t/*\n\t * Any other SQLSTATE can be taken to indicate that the server is up.\n\t * Presumably it didn't like our username, password, or database name; or\n\t * perhaps it had some transient failure, but that should not be taken as\n\t * meaning \"it's down\".\n\t */\n\treturn PQPING_OK;\n}\n\n\n/*\n * makeEmptyPGconn\n *\t - create a PGconn data structure with (as yet) no interesting data\n */\nstatic PGconn *\nmakeEmptyPGconn(void)\n{\n\tPGconn\t   *conn;\n\n#ifdef WIN32\n\n\t/*\n\t * Make sure socket support is up and running in this process.\n\t *\n\t * Note: the Windows documentation says that we should eventually do a\n\t * matching WSACleanup() call, but experience suggests that that is at\n\t * least as likely to cause problems as fix them.  So we don't.\n\t */\n\tstatic bool wsastartup_done = false;\n\n\tif (!wsastartup_done)\n\t{\n\t\tWSADATA\t\twsaData;\n\n\t\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\t\treturn NULL;\n\t\twsastartup_done = true;\n\t}\n\n\t/* Forget any earlier error */\n\tWSASetLastError(0);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tconn = (PGconn *) malloc(sizeof(PGconn));\n\tif (conn == NULL)\n\t\treturn conn;\n\n\t/* Zero all pointers and booleans */\n\tMemSet(conn, 0, sizeof(PGconn));\n\n\t/* install default notice hooks */\n\tconn->noticeHooks.noticeRec = defaultNoticeReceiver;\n\tconn->noticeHooks.noticeProc = defaultNoticeProcessor;\n\n\tconn->status = CONNECTION_BAD;\n\tconn->asyncStatus = PGASYNC_IDLE;\n\tconn->pipelineStatus = PQ_PIPELINE_OFF;\n\tconn->xactStatus = PQTRANS_IDLE;\n\tconn->options_valid = false;\n\tconn->nonblocking = false;\n\tconn->client_encoding = PG_SQL_ASCII;\n\tconn->std_strings = false;\t/* unless server says differently */\n\tconn->default_transaction_read_only = PG_BOOL_UNKNOWN;\n\tconn->in_hot_standby = PG_BOOL_UNKNOWN;\n\tconn->verbosity = PQERRORS_DEFAULT;\n\tconn->show_context = PQSHOW_CONTEXT_ERRORS;\n\tconn->sock = PGINVALID_SOCKET;\n\tconn->Pfdebug = NULL;\n\n\t/*\n\t * We try to send at least 8K at a time, which is the usual size of pipe\n\t * buffers on Unix systems.  That way, when we are sending a large amount\n\t * of data, we avoid incurring extra kernel context swaps for partial\n\t * bufferloads.  The output buffer is initially made 16K in size, and we\n\t * try to dump it after accumulating 8K.\n\t *\n\t * With the same goal of minimizing context swaps, the input buffer will\n\t * be enlarged anytime it has less than 8K free, so we initially allocate\n\t * twice that.\n\t */\n\tconn->inBufSize = 16 * 1024;\n\tconn->inBuffer = (char *) malloc(conn->inBufSize);\n\tconn->outBufSize = 16 * 1024;\n\tconn->outBuffer = (char *) malloc(conn->outBufSize);\n\tconn->rowBufLen = 32;\n\tconn->rowBuf = (PGdataValue *) malloc(conn->rowBufLen * sizeof(PGdataValue));\n\tinitPQExpBuffer(&conn->errorMessage);\n\tinitPQExpBuffer(&conn->workBuffer);\n\n\tif (conn->inBuffer == NULL ||\n\t\tconn->outBuffer == NULL ||\n\t\tconn->rowBuf == NULL ||\n\t\tPQExpBufferBroken(&conn->errorMessage) ||\n\t\tPQExpBufferBroken(&conn->workBuffer))\n\t{\n\t\t/* out of memory already :-( */\n\t\tfreePGconn(conn);\n\t\tconn = NULL;\n\t}\n\n\treturn conn;\n}\n\n/*\n * freePGconn\n *\t - free an idle (closed) PGconn data structure\n *\n * NOTE: this should not overlap any functionality with closePGconn().\n * Clearing/resetting of transient state belongs there; what we do here is\n * release data that is to be held for the life of the PGconn structure.\n * If a value ought to be cleared/freed during PQreset(), do it there not here.\n */\nstatic void\nfreePGconn(PGconn *conn)\n{\n\tint\t\t\ti;\n\n\t/* let any event procs clean up their state data */\n\tfor (i = 0; i < conn->nEvents; i++)\n\t{\n\t\tPGEventConnDestroy evt;\n\n\t\tevt.conn = conn;\n\t\t(void) conn->events[i].proc(PGEVT_CONNDESTROY, &evt,\n\t\t\t\t\t\t\t\t\tconn->events[i].passThrough);\n\t\tfree(conn->events[i].name);\n\t}\n\n\t/* clean up pg_conn_host structures */\n\tif (conn->connhost != NULL)\n\t{\n\t\tfor (i = 0; i < conn->nconnhost; ++i)\n\t\t{\n\t\t\tif (conn->connhost[i].host != NULL)\n\t\t\t\tfree(conn->connhost[i].host);\n\t\t\tif (conn->connhost[i].hostaddr != NULL)\n\t\t\t\tfree(conn->connhost[i].hostaddr);\n\t\t\tif (conn->connhost[i].port != NULL)\n\t\t\t\tfree(conn->connhost[i].port);\n\t\t\tif (conn->connhost[i].password != NULL)\n\t\t\t{\n\t\t\t\texplicit_bzero(conn->connhost[i].password, strlen(conn->connhost[i].password));\n\t\t\t\tfree(conn->connhost[i].password);\n\t\t\t}\n\t\t}\n\t\tfree(conn->connhost);\n\t}\n\n\tif (conn->client_encoding_initial)\n\t\tfree(conn->client_encoding_initial);\n\tif (conn->events)\n\t\tfree(conn->events);\n\tif (conn->pghost)\n\t\tfree(conn->pghost);\n\tif (conn->pghostaddr)\n\t\tfree(conn->pghostaddr);\n\tif (conn->pgport)\n\t\tfree(conn->pgport);\n\tif (conn->connect_timeout)\n\t\tfree(conn->connect_timeout);\n\tif (conn->pgtcp_user_timeout)\n\t\tfree(conn->pgtcp_user_timeout);\n\tif (conn->pgoptions)\n\t\tfree(conn->pgoptions);\n\tif (conn->appname)\n\t\tfree(conn->appname);\n\tif (conn->fbappname)\n\t\tfree(conn->fbappname);\n\tif (conn->dbName)\n\t\tfree(conn->dbName);\n\tif (conn->replication)\n\t\tfree(conn->replication);\n\tif (conn->pguser)\n\t\tfree(conn->pguser);\n\tif (conn->pgpass)\n\t{\n\t\texplicit_bzero(conn->pgpass, strlen(conn->pgpass));\n\t\tfree(conn->pgpass);\n\t}\n\tif (conn->pgpassfile)\n\t\tfree(conn->pgpassfile);\n\tif (conn->channel_binding)\n\t\tfree(conn->channel_binding);\n\tif (conn->keepalives)\n\t\tfree(conn->keepalives);\n\tif (conn->keepalives_idle)\n\t\tfree(conn->keepalives_idle);\n\tif (conn->keepalives_interval)\n\t\tfree(conn->keepalives_interval);\n\tif (conn->keepalives_count)\n\t\tfree(conn->keepalives_count);\n\tif (conn->sslmode)\n\t\tfree(conn->sslmode);\n\tif (conn->sslcert)\n\t\tfree(conn->sslcert);\n\tif (conn->sslkey)\n\t\tfree(conn->sslkey);\n\tif (conn->sslpassword)\n\t{\n\t\texplicit_bzero(conn->sslpassword, strlen(conn->sslpassword));\n\t\tfree(conn->sslpassword);\n\t}\n\tif (conn->sslrootcert)\n\t\tfree(conn->sslrootcert);\n\tif (conn->sslcrl)\n\t\tfree(conn->sslcrl);\n\tif (conn->sslcrldir)\n\t\tfree(conn->sslcrldir);\n\tif (conn->sslcompression)\n\t\tfree(conn->sslcompression);\n\tif (conn->sslsni)\n\t\tfree(conn->sslsni);\n\tif (conn->requirepeer)\n\t\tfree(conn->requirepeer);\n\tif (conn->ssl_min_protocol_version)\n\t\tfree(conn->ssl_min_protocol_version);\n\tif (conn->ssl_max_protocol_version)\n\t\tfree(conn->ssl_max_protocol_version);\n\tif (conn->gssencmode)\n\t\tfree(conn->gssencmode);\n\tif (conn->krbsrvname)\n\t\tfree(conn->krbsrvname);\n\tif (conn->gsslib)\n\t\tfree(conn->gsslib);\n\tif (conn->connip)\n\t\tfree(conn->connip);\n\t/* Note that conn->Pfdebug is not ours to close or free */\n\tif (conn->write_err_msg)\n\t\tfree(conn->write_err_msg);\n\tif (conn->inBuffer)\n\t\tfree(conn->inBuffer);\n\tif (conn->outBuffer)\n\t\tfree(conn->outBuffer);\n\tif (conn->rowBuf)\n\t\tfree(conn->rowBuf);\n\tif (conn->target_session_attrs)\n\t\tfree(conn->target_session_attrs);\n\ttermPQExpBuffer(&conn->errorMessage);\n\ttermPQExpBuffer(&conn->workBuffer);\n\n\tfree(conn);\n}\n\n/*\n * release_conn_addrinfo\n *\t - Free any addrinfo list in the PGconn.\n */\nstatic void\nrelease_conn_addrinfo(PGconn *conn)\n{\n\tif (conn->addrlist)\n\t{\n\t\tpg_freeaddrinfo_all(conn->addrlist_family, conn->addrlist);\n\t\tconn->addrlist = NULL;\n\t\tconn->addr_cur = NULL;\t/* for safety */\n\t}\n}\n\n/*\n * sendTerminateConn\n *\t - Send a terminate message to backend.\n */\nstatic void\nsendTerminateConn(PGconn *conn)\n{\n\t/*\n\t * Note that the protocol doesn't allow us to send Terminate messages\n\t * during the startup phase.\n\t */\n\tif (conn->sock != PGINVALID_SOCKET && conn->status == CONNECTION_OK)\n\t{\n\t\t/*\n\t\t * Try to send \"close connection\" message to backend. Ignore any\n\t\t * error.\n\t\t */\n\t\tpqPutMsgStart('X', conn);\n\t\tpqPutMsgEnd(conn);\n\t\t(void) pqFlush(conn);\n\t}\n}\n\n/*\n * closePGconn\n *\t - properly close a connection to the backend\n *\n * This should reset or release all transient state, but NOT the connection\n * parameters.  On exit, the PGconn should be in condition to start a fresh\n * connection with the same parameters (see PQreset()).\n */\nstatic void\nclosePGconn(PGconn *conn)\n{\n\t/*\n\t * If possible, send Terminate message to close the connection politely.\n\t */\n\tsendTerminateConn(conn);\n\n\t/*\n\t * Must reset the blocking status so a possible reconnect will work.\n\t *\n\t * Don't call PQsetnonblocking() because it will fail if it's unable to\n\t * flush the connection.\n\t */\n\tconn->nonblocking = false;\n\n\t/*\n\t * Close the connection, reset all transient state, flush I/O buffers.\n\t * Note that this includes clearing conn->errorMessage; we're no longer\n\t * interested in any failures associated with the old connection, and we\n\t * want a clean slate for any new connection attempt.\n\t */\n\tpqDropConnection(conn, true);\n\tconn->status = CONNECTION_BAD;\t/* Well, not really _bad_ - just absent */\n\tconn->asyncStatus = PGASYNC_IDLE;\n\tconn->xactStatus = PQTRANS_IDLE;\n\tconn->pipelineStatus = PQ_PIPELINE_OFF;\n\tpqClearAsyncResult(conn);\t/* deallocate result */\n\tresetPQExpBuffer(&conn->errorMessage);\n\trelease_conn_addrinfo(conn);\n\n\t/* Reset all state obtained from server, too */\n\tpqDropServerData(conn);\n}\n\n/*\n * PQfinish: properly close a connection to the backend. Also frees\n * the PGconn data structure so it shouldn't be re-used after this.\n */\nvoid\nPQfinish(PGconn *conn)\n{\n\tif (conn)\n\t{\n\t\tclosePGconn(conn);\n\t\tfreePGconn(conn);\n\t}\n}\n\n/*\n * PQreset: resets the connection to the backend by closing the\n * existing connection and creating a new one.\n */\nvoid\nPQreset(PGconn *conn)\n{\n\tif (conn)\n\t{\n\t\tclosePGconn(conn);\n\n\t\tif (connectDBStart(conn) && connectDBComplete(conn))\n\t\t{\n\t\t\t/*\n\t\t\t * Notify event procs of successful reset.  We treat an event proc\n\t\t\t * failure as disabling the connection ... good idea?\n\t\t\t */\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < conn->nEvents; i++)\n\t\t\t{\n\t\t\t\tPGEventConnReset evt;\n\n\t\t\t\tevt.conn = conn;\n\t\t\t\tif (!conn->events[i].proc(PGEVT_CONNRESET, &evt,\n\t\t\t\t\t\t\t\t\t\t  conn->events[i].passThrough))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"PGEventProc \\\"%s\\\" failed during PGEVT_CONNRESET event\\n\"),\n\t\t\t\t\t\t\t\t\t  conn->events[i].name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/*\n * PQresetStart:\n * resets the connection to the backend\n * closes the existing connection and makes a new one\n * Returns 1 on success, 0 on failure.\n */\nint\nPQresetStart(PGconn *conn)\n{\n\tif (conn)\n\t{\n\t\tclosePGconn(conn);\n\n\t\treturn connectDBStart(conn);\n\t}\n\n\treturn 0;\n}\n\n\n/*\n * PQresetPoll:\n * resets the connection to the backend\n * closes the existing connection and makes a new one\n */\nPostgresPollingStatusType\nPQresetPoll(PGconn *conn)\n{\n\tif (conn)\n\t{\n\t\tPostgresPollingStatusType status = PQconnectPoll(conn);\n\n\t\tif (status == PGRES_POLLING_OK)\n\t\t{\n\t\t\t/*\n\t\t\t * Notify event procs of successful reset.  We treat an event proc\n\t\t\t * failure as disabling the connection ... good idea?\n\t\t\t */\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < conn->nEvents; i++)\n\t\t\t{\n\t\t\t\tPGEventConnReset evt;\n\n\t\t\t\tevt.conn = conn;\n\t\t\t\tif (!conn->events[i].proc(PGEVT_CONNRESET, &evt,\n\t\t\t\t\t\t\t\t\t\t  conn->events[i].passThrough))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"PGEventProc \\\"%s\\\" failed during PGEVT_CONNRESET event\\n\"),\n\t\t\t\t\t\t\t\t\t  conn->events[i].name);\n\t\t\t\t\treturn PGRES_POLLING_FAILED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn status;\n\t}\n\n\treturn PGRES_POLLING_FAILED;\n}\n\n/*\n * PQgetCancel: get a PGcancel structure corresponding to a connection.\n *\n * A copy is needed to be able to cancel a running query from a different\n * thread. If the same structure is used all structure members would have\n * to be individually locked (if the entire structure was locked, it would\n * be impossible to cancel a synchronous query because the structure would\n * have to stay locked for the duration of the query).\n */\nPGcancel *\nPQgetCancel(PGconn *conn)\n{\n\tPGcancel   *cancel;\n\n\tif (!conn)\n\t\treturn NULL;\n\n\tif (conn->sock == PGINVALID_SOCKET)\n\t\treturn NULL;\n\n\tcancel = malloc(sizeof(PGcancel));\n\tif (cancel == NULL)\n\t\treturn NULL;\n\n\tmemcpy(&cancel->raddr, &conn->raddr, sizeof(SockAddr));\n\tcancel->be_pid = conn->be_pid;\n\tcancel->be_key = conn->be_key;\n\n\treturn cancel;\n}\n\n/* PQfreeCancel: free a cancel structure */\nvoid\nPQfreeCancel(PGcancel *cancel)\n{\n\tif (cancel)\n\t\tfree(cancel);\n}\n\n\n/*\n * PQcancel and PQrequestCancel: attempt to request cancellation of the\n * current operation.\n *\n * The return value is true if the cancel request was successfully\n * dispatched, false if not (in which case an error message is available).\n * Note: successful dispatch is no guarantee that there will be any effect at\n * the backend.  The application must read the operation result as usual.\n *\n * CAUTION: we want this routine to be safely callable from a signal handler\n * (for example, an application might want to call it in a SIGINT handler).\n * This means we cannot use any C library routine that might be non-reentrant.\n * malloc/free are often non-reentrant, and anything that might call them is\n * just as dangerous.  We avoid sprintf here for that reason.  Building up\n * error messages with strcpy/strcat is tedious but should be quite safe.\n * We also save/restore errno in case the signal handler support doesn't.\n *\n * internal_cancel() is an internal helper function to make code-sharing\n * between the two versions of the cancel function possible.\n */\nstatic int\ninternal_cancel(SockAddr *raddr, int be_pid, int be_key,\n\t\t\t\tchar *errbuf, int errbufsize)\n{\n\tint\t\t\tsave_errno = SOCK_ERRNO;\n\tpgsocket\ttmpsock = PGINVALID_SOCKET;\n\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\tint\t\t\tmaxlen;\n\tstruct\n\t{\n\t\tuint32\t\tpacketlen;\n\t\tCancelRequestPacket cp;\n\t}\t\t\tcrp;\n\n\t/*\n\t * We need to open a temporary connection to the postmaster. Do this with\n\t * only kernel calls.\n\t */\n\tif ((tmpsock = socket(raddr->addr.ss_family, SOCK_STREAM, 0)) == PGINVALID_SOCKET)\n\t{\n\t\tstrlcpy(errbuf, \"PQcancel() -- socket() failed: \", errbufsize);\n\t\tgoto cancel_errReturn;\n\t}\nretry3:\n\tif (connect(tmpsock, (struct sockaddr *) &raddr->addr,\n\t\t\t\traddr->salen) < 0)\n\t{\n\t\tif (SOCK_ERRNO == EINTR)\n\t\t\t/* Interrupted system call - we'll just try again */\n\t\t\tgoto retry3;\n\t\tstrlcpy(errbuf, \"PQcancel() -- connect() failed: \", errbufsize);\n\t\tgoto cancel_errReturn;\n\t}\n\n\t/*\n\t * We needn't set nonblocking I/O or NODELAY options here.\n\t */\n\n\t/* Create and send the cancel request packet. */\n\n\tcrp.packetlen = pg_hton32((uint32) sizeof(crp));\n\tcrp.cp.cancelRequestCode = (MsgType) pg_hton32(CANCEL_REQUEST_CODE);\n\tcrp.cp.backendPID = pg_hton32(be_pid);\n\tcrp.cp.cancelAuthCode = pg_hton32(be_key);\n\nretry4:\n\tif (send(tmpsock, (char *) &crp, sizeof(crp), 0) != (int) sizeof(crp))\n\t{\n\t\tif (SOCK_ERRNO == EINTR)\n\t\t\t/* Interrupted system call - we'll just try again */\n\t\t\tgoto retry4;\n\t\tstrlcpy(errbuf, \"PQcancel() -- send() failed: \", errbufsize);\n\t\tgoto cancel_errReturn;\n\t}\n\n\t/*\n\t * Wait for the postmaster to close the connection, which indicates that\n\t * it's processed the request.  Without this delay, we might issue another\n\t * command only to find that our cancel zaps that command instead of the\n\t * one we thought we were canceling.  Note we don't actually expect this\n\t * read to obtain any data, we are just waiting for EOF to be signaled.\n\t */\nretry5:\n\tif (recv(tmpsock, (char *) &crp, 1, 0) < 0)\n\t{\n\t\tif (SOCK_ERRNO == EINTR)\n\t\t\t/* Interrupted system call - we'll just try again */\n\t\t\tgoto retry5;\n\t\t/* we ignore other error conditions */\n\t}\n\n\t/* All done */\n\tclosesocket(tmpsock);\n\tSOCK_ERRNO_SET(save_errno);\n\treturn true;\n\ncancel_errReturn:\n\n\t/*\n\t * Make sure we don't overflow the error buffer. Leave space for the \\n at\n\t * the end, and for the terminating zero.\n\t */\n\tmaxlen = errbufsize - strlen(errbuf) - 2;\n\tif (maxlen >= 0)\n\t{\n\t\tstrncat(errbuf, SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)),\n\t\t\t\tmaxlen);\n\t\tstrcat(errbuf, \"\\n\");\n\t}\n\tif (tmpsock != PGINVALID_SOCKET)\n\t\tclosesocket(tmpsock);\n\tSOCK_ERRNO_SET(save_errno);\n\treturn false;\n}\n\n/*\n * PQcancel: request query cancel\n *\n * Returns true if able to send the cancel request, false if not.\n *\n * On failure, an error message is stored in *errbuf, which must be of size\n * errbufsize (recommended size is 256 bytes).  *errbuf is not changed on\n * success return.\n */\nint\nPQcancel(PGcancel *cancel, char *errbuf, int errbufsize)\n{\n\tif (!cancel)\n\t{\n\t\tstrlcpy(errbuf, \"PQcancel() -- no cancel object supplied\", errbufsize);\n\t\treturn false;\n\t}\n\n\treturn internal_cancel(&cancel->raddr, cancel->be_pid, cancel->be_key,\n\t\t\t\t\t\t   errbuf, errbufsize);\n}\n\n/*\n * PQrequestCancel: old, not thread-safe function for requesting query cancel\n *\n * Returns true if able to send the cancel request, false if not.\n *\n * On failure, the error message is saved in conn->errorMessage; this means\n * that this can't be used when there might be other active operations on\n * the connection object.\n *\n * NOTE: error messages will be cut off at the current size of the\n * error message buffer, since we dare not try to expand conn->errorMessage!\n */\nint\nPQrequestCancel(PGconn *conn)\n{\n\tint\t\t\tr;\n\n\t/* Check we have an open connection */\n\tif (!conn)\n\t\treturn false;\n\n\tif (conn->sock == PGINVALID_SOCKET)\n\t{\n\t\tstrlcpy(conn->errorMessage.data,\n\t\t\t\t\"PQrequestCancel() -- connection is not open\\n\",\n\t\t\t\tconn->errorMessage.maxlen);\n\t\tconn->errorMessage.len = strlen(conn->errorMessage.data);\n\n\t\treturn false;\n\t}\n\n\tr = internal_cancel(&conn->raddr, conn->be_pid, conn->be_key,\n\t\t\t\t\t\tconn->errorMessage.data, conn->errorMessage.maxlen);\n\n\tif (!r)\n\t\tconn->errorMessage.len = strlen(conn->errorMessage.data);\n\n\treturn r;\n}\n\n\n/*\n * pqPacketSend() -- convenience routine to send a message to server.\n *\n * pack_type: the single-byte message type code.  (Pass zero for startup\n * packets, which have no message type code.)\n *\n * buf, buf_len: contents of message.  The given length includes only what\n * is in buf; the message type and message length fields are added here.\n *\n * RETURNS: STATUS_ERROR if the write fails, STATUS_OK otherwise.\n * SIDE_EFFECTS: may block.\n */\nint\npqPacketSend(PGconn *conn, char pack_type,\n\t\t\t const void *buf, size_t buf_len)\n{\n\t/* Start the message. */\n\tif (pqPutMsgStart(pack_type, conn))\n\t\treturn STATUS_ERROR;\n\n\t/* Send the message body. */\n\tif (pqPutnchar(buf, buf_len, conn))\n\t\treturn STATUS_ERROR;\n\n\t/* Finish the message. */\n\tif (pqPutMsgEnd(conn))\n\t\treturn STATUS_ERROR;\n\n\t/* Flush to ensure backend gets it. */\n\tif (pqFlush(conn))\n\t\treturn STATUS_ERROR;\n\n\treturn STATUS_OK;\n}\n\n#ifdef USE_LDAP\n\n#define LDAP_URL\t\"ldap://\"\n#define LDAP_DEF_PORT\t389\n#define PGLDAP_TIMEOUT 2\n\n#define ld_is_sp_tab(x) ((x) == ' ' || (x) == '\\t')\n#define ld_is_nl_cr(x) ((x) == '\\r' || (x) == '\\n')\n\n\n/*\n *\t\tldapServiceLookup\n *\n * Search the LDAP URL passed as first argument, treat the result as a\n * string of connection options that are parsed and added to the array of\n * options passed as second argument.\n *\n * LDAP URLs must conform to RFC 1959 without escape sequences.\n *\tldap://host:port/dn?attributes?scope?filter?extensions\n *\n * Returns\n *\t0 if the lookup was successful,\n *\t1 if the connection to the LDAP server could be established but\n *\t  the search was unsuccessful,\n *\t2 if a connection could not be established, and\n *\t3 if a fatal error occurred.\n *\n * An error message is appended to *errorMessage for return codes 1 and 3.\n */\nstatic int\nldapServiceLookup(const char *purl, PQconninfoOption *options,\n\t\t\t\t  PQExpBuffer errorMessage)\n{\n\tint\t\t\tport = LDAP_DEF_PORT,\n\t\t\t\tscope,\n\t\t\t\trc,\n\t\t\t\tsize,\n\t\t\t\tstate,\n\t\t\t\toldstate,\n\t\t\t\ti;\n#ifndef WIN32\n\tint\t\t\tmsgid;\n#endif\n\tbool\t\tfound_keyword;\n\tchar\t   *url,\n\t\t\t   *hostname,\n\t\t\t   *portstr,\n\t\t\t   *endptr,\n\t\t\t   *dn,\n\t\t\t   *scopestr,\n\t\t\t   *filter,\n\t\t\t   *result,\n\t\t\t   *p,\n\t\t\t   *p1 = NULL,\n\t\t\t   *optname = NULL,\n\t\t\t   *optval = NULL;\n\tchar\t   *attrs[2] = {NULL, NULL};\n\tLDAP\t   *ld = NULL;\n\tLDAPMessage *res,\n\t\t\t   *entry;\n\tstruct berval **values;\n\tLDAP_TIMEVAL time = {PGLDAP_TIMEOUT, 0};\n\n\tif ((url = strdup(purl)) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage, libpq_gettext(\"out of memory\\n\"));\n\t\treturn 3;\n\t}\n\n\t/*\n\t * Parse URL components, check for correctness.  Basically, url has '\\0'\n\t * placed at component boundaries and variables are pointed at each\n\t * component.\n\t */\n\n\tif (pg_strncasecmp(url, LDAP_URL, strlen(LDAP_URL)) != 0)\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": scheme must be ldap://\\n\"), purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\n\t/* hostname */\n\thostname = url + strlen(LDAP_URL);\n\tif (*hostname == '/')\t\t/* no hostname? */\n\t\thostname = DefaultHost; /* the default */\n\n\t/* dn, \"distinguished name\" */\n\tp = strchr(url + strlen(LDAP_URL), '/');\n\tif (p == NULL || *(p + 1) == '\\0' || *(p + 1) == '?')\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": missing distinguished name\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\t*p = '\\0';\t\t\t\t\t/* terminate hostname */\n\tdn = p + 1;\n\n\t/* attribute */\n\tif ((p = strchr(dn, '?')) == NULL || *(p + 1) == '\\0' || *(p + 1) == '?')\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": must have exactly one attribute\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\t*p = '\\0';\n\tattrs[0] = p + 1;\n\n\t/* scope */\n\tif ((p = strchr(attrs[0], '?')) == NULL || *(p + 1) == '\\0' || *(p + 1) == '?')\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": must have search scope (base/one/sub)\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\t*p = '\\0';\n\tscopestr = p + 1;\n\n\t/* filter */\n\tif ((p = strchr(scopestr, '?')) == NULL || *(p + 1) == '\\0' || *(p + 1) == '?')\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": no filter\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\t*p = '\\0';\n\tfilter = p + 1;\n\tif ((p = strchr(filter, '?')) != NULL)\n\t\t*p = '\\0';\n\n\t/* port number? */\n\tif ((p1 = strchr(hostname, ':')) != NULL)\n\t{\n\t\tlong\t\tlport;\n\n\t\t*p1 = '\\0';\n\t\tportstr = p1 + 1;\n\t\terrno = 0;\n\t\tlport = strtol(portstr, &endptr, 10);\n\t\tif (*portstr == '\\0' || *endptr != '\\0' || errno || lport < 0 || lport > 65535)\n\t\t{\n\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": invalid port number\\n\"),\n\t\t\t\t\t\t\t  purl);\n\t\t\tfree(url);\n\t\t\treturn 3;\n\t\t}\n\t\tport = (int) lport;\n\t}\n\n\t/* Allow only one attribute */\n\tif (strchr(attrs[0], ',') != NULL)\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": must have exactly one attribute\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\n\t/* set scope */\n\tif (pg_strcasecmp(scopestr, \"base\") == 0)\n\t\tscope = LDAP_SCOPE_BASE;\n\telse if (pg_strcasecmp(scopestr, \"one\") == 0)\n\t\tscope = LDAP_SCOPE_ONELEVEL;\n\telse if (pg_strcasecmp(scopestr, \"sub\") == 0)\n\t\tscope = LDAP_SCOPE_SUBTREE;\n\telse\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": must have search scope (base/one/sub)\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\n\t/* initialize LDAP structure */\n\tif ((ld = ldap_init(hostname, port)) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"could not create LDAP structure\\n\"));\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\n\t/*\n\t * Perform an explicit anonymous bind.\n\t *\n\t * LDAP does not require that an anonymous bind is performed explicitly,\n\t * but we want to distinguish between the case where LDAP bind does not\n\t * succeed within PGLDAP_TIMEOUT seconds (return 2 to continue parsing the\n\t * service control file) and the case where querying the LDAP server fails\n\t * (return 1 to end parsing).\n\t *\n\t * Unfortunately there is no way of setting a timeout that works for both\n\t * Windows and OpenLDAP.\n\t */\n#ifdef WIN32\n\t/* the nonstandard ldap_connect function performs an anonymous bind */\n\tif (ldap_connect(ld, &time) != LDAP_SUCCESS)\n\t{\n\t\t/* error or timeout in ldap_connect */\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 2;\n\t}\n#else\t\t\t\t\t\t\t/* !WIN32 */\n\t/* in OpenLDAP, use the LDAP_OPT_NETWORK_TIMEOUT option */\n\tif (ldap_set_option(ld, LDAP_OPT_NETWORK_TIMEOUT, &time) != LDAP_SUCCESS)\n\t{\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 3;\n\t}\n\n\t/* anonymous bind */\n\tif ((msgid = ldap_simple_bind(ld, NULL, NULL)) == -1)\n\t{\n\t\t/* error or network timeout */\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 2;\n\t}\n\n\t/* wait some time for the connection to succeed */\n\tres = NULL;\n\tif ((rc = ldap_result(ld, msgid, LDAP_MSG_ALL, &time, &res)) == -1 ||\n\t\tres == NULL)\n\t{\n\t\t/* error or timeout */\n\t\tif (res != NULL)\n\t\t\tldap_msgfree(res);\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 2;\n\t}\n\tldap_msgfree(res);\n\n\t/* reset timeout */\n\ttime.tv_sec = -1;\n\tif (ldap_set_option(ld, LDAP_OPT_NETWORK_TIMEOUT, &time) != LDAP_SUCCESS)\n\t{\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 3;\n\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t/* search */\n\tres = NULL;\n\tif ((rc = ldap_search_st(ld, dn, scope, filter, attrs, 0, &time, &res))\n\t\t!= LDAP_SUCCESS)\n\t{\n\t\tif (res != NULL)\n\t\t\tldap_msgfree(res);\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"lookup on LDAP server failed: %s\\n\"),\n\t\t\t\t\t\t  ldap_err2string(rc));\n\t\tldap_unbind(ld);\n\t\tfree(url);\n\t\treturn 1;\n\t}\n\n\t/* complain if there was not exactly one result */\n\tif ((rc = ldap_count_entries(ld, res)) != 1)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t rc ? libpq_gettext(\"more than one entry found on LDAP lookup\\n\")\n\t\t\t\t\t\t\t : libpq_gettext(\"no entry found on LDAP lookup\\n\"));\n\t\tldap_msgfree(res);\n\t\tldap_unbind(ld);\n\t\tfree(url);\n\t\treturn 1;\n\t}\n\n\t/* get entry */\n\tif ((entry = ldap_first_entry(ld, res)) == NULL)\n\t{\n\t\t/* should never happen */\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"no entry found on LDAP lookup\\n\"));\n\t\tldap_msgfree(res);\n\t\tldap_unbind(ld);\n\t\tfree(url);\n\t\treturn 1;\n\t}\n\n\t/* get values */\n\tif ((values = ldap_get_values_len(ld, entry, attrs[0])) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"attribute has no values on LDAP lookup\\n\"));\n\t\tldap_msgfree(res);\n\t\tldap_unbind(ld);\n\t\tfree(url);\n\t\treturn 1;\n\t}\n\n\tldap_msgfree(res);\n\tfree(url);\n\n\tif (values[0] == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"attribute has no values on LDAP lookup\\n\"));\n\t\tldap_value_free_len(values);\n\t\tldap_unbind(ld);\n\t\treturn 1;\n\t}\n\n\t/* concatenate values into a single string with newline terminators */\n\tsize = 1;\t\t\t\t\t/* for the trailing null */\n\tfor (i = 0; values[i] != NULL; i++)\n\t\tsize += values[i]->bv_len + 1;\n\tif ((result = malloc(size)) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\tldap_value_free_len(values);\n\t\tldap_unbind(ld);\n\t\treturn 3;\n\t}\n\tp = result;\n\tfor (i = 0; values[i] != NULL; i++)\n\t{\n\t\tmemcpy(p, values[i]->bv_val, values[i]->bv_len);\n\t\tp += values[i]->bv_len;\n\t\t*(p++) = '\\n';\n\t}\n\t*p = '\\0';\n\n\tldap_value_free_len(values);\n\tldap_unbind(ld);\n\n\t/* parse result string */\n\toldstate = state = 0;\n\tfor (p = result; *p != '\\0'; ++p)\n\t{\n\t\tswitch (state)\n\t\t{\n\t\t\tcase 0:\t\t\t\t/* between entries */\n\t\t\t\tif (!ld_is_sp_tab(*p) && !ld_is_nl_cr(*p))\n\t\t\t\t{\n\t\t\t\t\toptname = p;\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\t\t\t\t/* in option name */\n\t\t\t\tif (ld_is_sp_tab(*p))\n\t\t\t\t{\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse if (ld_is_nl_cr(*p))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"missing \\\"=\\\" after \\\"%s\\\" in connection info string\\n\"),\n\t\t\t\t\t\t\t\t\t  optname);\n\t\t\t\t\tfree(result);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\telse if (*p == '=')\n\t\t\t\t{\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\t\t\t\t/* after option name */\n\t\t\t\tif (*p == '=')\n\t\t\t\t{\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t\telse if (!ld_is_sp_tab(*p))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"missing \\\"=\\\" after \\\"%s\\\" in connection info string\\n\"),\n\t\t\t\t\t\t\t\t\t  optname);\n\t\t\t\t\tfree(result);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\t\t\t\t/* before option value */\n\t\t\t\tif (*p == '\\'')\n\t\t\t\t{\n\t\t\t\t\toptval = p + 1;\n\t\t\t\t\tp1 = p + 1;\n\t\t\t\t\tstate = 5;\n\t\t\t\t}\n\t\t\t\telse if (ld_is_nl_cr(*p))\n\t\t\t\t{\n\t\t\t\t\toptval = optname + strlen(optname); /* empty */\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse if (!ld_is_sp_tab(*p))\n\t\t\t\t{\n\t\t\t\t\toptval = p;\n\t\t\t\t\tstate = 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\t\t\t\t/* in unquoted option value */\n\t\t\t\tif (ld_is_sp_tab(*p) || ld_is_nl_cr(*p))\n\t\t\t\t{\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\t\t\t\t/* in quoted option value */\n\t\t\t\tif (*p == '\\'')\n\t\t\t\t{\n\t\t\t\t\t*p1 = '\\0';\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse if (*p == '\\\\')\n\t\t\t\t\tstate = 6;\n\t\t\t\telse\n\t\t\t\t\t*(p1++) = *p;\n\t\t\t\tbreak;\n\t\t\tcase 6:\t\t\t\t/* in quoted option value after escape */\n\t\t\t\t*(p1++) = *p;\n\t\t\t\tstate = 5;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (state == 0 && oldstate != 0)\n\t\t{\n\t\t\tfound_keyword = false;\n\t\t\tfor (i = 0; options[i].keyword; i++)\n\t\t\t{\n\t\t\t\tif (strcmp(options[i].keyword, optname) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (options[i].val == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions[i].val = strdup(optval);\n\t\t\t\t\t\tif (!options[i].val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\t\t\tfree(result);\n\t\t\t\t\t\t\treturn 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfound_keyword = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found_keyword)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection option \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  optname);\n\t\t\t\tfree(result);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\toptname = NULL;\n\t\t\toptval = NULL;\n\t\t}\n\t\toldstate = state;\n\t}\n\n\tfree(result);\n\n\tif (state == 5 || state == 6)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"unterminated quoted string in connection info string\\n\"));\n\t\treturn 3;\n\t}\n\n\treturn 0;\n}\n\n#endif\t\t\t\t\t\t\t/* USE_LDAP */\n\n/*\n * parseServiceInfo: if a service name has been given, look it up and absorb\n * connection options from it into *options.\n *\n * Returns 0 on success, nonzero on failure.  On failure, if errorMessage\n * isn't null, also store an error message there.  (Note: the only reason\n * this function and related ones don't dump core on errorMessage == NULL\n * is the undocumented fact that printfPQExpBuffer does nothing when passed\n * a null PQExpBuffer pointer.)\n */\nstatic int\nparseServiceInfo(PQconninfoOption *options, PQExpBuffer errorMessage)\n{\n\tconst char *service = conninfo_getval(options, \"service\");\n\tchar\t\tserviceFile[MAXPGPATH];\n\tchar\t   *env;\n\tbool\t\tgroup_found = false;\n\tint\t\t\tstatus;\n\tstruct stat stat_buf;\n\n\t/*\n\t * We have to special-case the environment variable PGSERVICE here, since\n\t * this is and should be called before inserting environment defaults for\n\t * other connection options.\n\t */\n\tif (service == NULL)\n\t\tservice = getenv(\"PGSERVICE\");\n\n\t/* If no service name given, nothing to do */\n\tif (service == NULL)\n\t\treturn 0;\n\n\t/*\n\t * Try PGSERVICEFILE if specified, else try ~/.pg_service.conf (if that\n\t * exists).\n\t */\n\tif ((env = getenv(\"PGSERVICEFILE\")) != NULL)\n\t\tstrlcpy(serviceFile, env, sizeof(serviceFile));\n\telse\n\t{\n\t\tchar\t\thomedir[MAXPGPATH];\n\n\t\tif (!pqGetHomeDirectory(homedir, sizeof(homedir)))\n\t\t\tgoto next_file;\n\t\tsnprintf(serviceFile, MAXPGPATH, \"%s/%s\", homedir, \".pg_service.conf\");\n\t\tif (stat(serviceFile, &stat_buf) != 0)\n\t\t\tgoto next_file;\n\t}\n\n\tstatus = parseServiceFile(serviceFile, service, options, errorMessage, &group_found);\n\tif (group_found || status != 0)\n\t\treturn status;\n\nnext_file:\n\n\t/*\n\t * This could be used by any application so we can't use the binary\n\t * location to find our config files.\n\t */\n\tsnprintf(serviceFile, MAXPGPATH, \"%s/pg_service.conf\",\n\t\t\t getenv(\"PGSYSCONFDIR\") ? getenv(\"PGSYSCONFDIR\") : SYSCONFDIR);\n\tif (stat(serviceFile, &stat_buf) != 0)\n\t\tgoto last_file;\n\n\tstatus = parseServiceFile(serviceFile, service, options, errorMessage, &group_found);\n\tif (status != 0)\n\t\treturn status;\n\nlast_file:\n\tif (!group_found)\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"definition of service \\\"%s\\\" not found\\n\"), service);\n\t\treturn 3;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nparseServiceFile(const char *serviceFile,\n\t\t\t\t const char *service,\n\t\t\t\t PQconninfoOption *options,\n\t\t\t\t PQExpBuffer errorMessage,\n\t\t\t\t bool *group_found)\n{\n\tint\t\t\tresult = 0,\n\t\t\t\tlinenr = 0,\n\t\t\t\ti;\n\tFILE\t   *f;\n\tchar\t   *line;\n\tchar\t\tbuf[1024];\n\n\t*group_found = false;\n\n\tf = fopen(serviceFile, \"r\");\n\tif (f == NULL)\n\t{\n\t\tappendPQExpBuffer(errorMessage, libpq_gettext(\"service file \\\"%s\\\" not found\\n\"),\n\t\t\t\t\t\t  serviceFile);\n\t\treturn 1;\n\t}\n\n\twhile ((line = fgets(buf, sizeof(buf), f)) != NULL)\n\t{\n\t\tint\t\t\tlen;\n\n\t\tlinenr++;\n\n\t\tif (strlen(line) >= sizeof(buf) - 1)\n\t\t{\n\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"line %d too long in service file \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  linenr,\n\t\t\t\t\t\t\t  serviceFile);\n\t\t\tresult = 2;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* ignore whitespace at end of line, especially the newline */\n\t\tlen = strlen(line);\n\t\twhile (len > 0 && isspace((unsigned char) line[len - 1]))\n\t\t\tline[--len] = '\\0';\n\n\t\t/* ignore leading whitespace too */\n\t\twhile (*line && isspace((unsigned char) line[0]))\n\t\t\tline++;\n\n\t\t/* ignore comments and empty lines */\n\t\tif (line[0] == '\\0' || line[0] == '#')\n\t\t\tcontinue;\n\n\t\t/* Check for right groupname */\n\t\tif (line[0] == '[')\n\t\t{\n\t\t\tif (*group_found)\n\t\t\t{\n\t\t\t\t/* end of desired group reached; return success */\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (strncmp(line + 1, service, strlen(service)) == 0 &&\n\t\t\t\tline[strlen(service) + 1] == ']')\n\t\t\t\t*group_found = true;\n\t\t\telse\n\t\t\t\t*group_found = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (*group_found)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Finally, we are in the right group and can parse the line\n\t\t\t\t */\n\t\t\t\tchar\t   *key,\n\t\t\t\t\t\t   *val;\n\t\t\t\tbool\t\tfound_keyword;\n\n#ifdef USE_LDAP\n\t\t\t\tif (strncmp(line, \"ldap\", 4) == 0)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\trc = ldapServiceLookup(line, options, errorMessage);\n\n\t\t\t\t\t/* if rc = 2, go on reading for fallback */\n\t\t\t\t\tswitch (rc)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tresult = 3;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n\t\t\t\tkey = line;\n\t\t\t\tval = strchr(line, '=');\n\t\t\t\tif (val == NULL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"syntax error in service file \\\"%s\\\", line %d\\n\"),\n\t\t\t\t\t\t\t\t\t  serviceFile,\n\t\t\t\t\t\t\t\t\t  linenr);\n\t\t\t\t\tresult = 3;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\t*val++ = '\\0';\n\n\t\t\t\tif (strcmp(key, \"service\") == 0)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"nested service specifications not supported in service file \\\"%s\\\", line %d\\n\"),\n\t\t\t\t\t\t\t\t\t  serviceFile,\n\t\t\t\t\t\t\t\t\t  linenr);\n\t\t\t\t\tresult = 3;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Set the parameter --- but don't override any previous\n\t\t\t\t * explicit setting.\n\t\t\t\t */\n\t\t\t\tfound_keyword = false;\n\t\t\t\tfor (i = 0; options[i].keyword; i++)\n\t\t\t\t{\n\t\t\t\t\tif (strcmp(options[i].keyword, key) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (options[i].val == NULL)\n\t\t\t\t\t\t\toptions[i].val = strdup(val);\n\t\t\t\t\t\tif (!options[i].val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\t\t\tresult = 3;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfound_keyword = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!found_keyword)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"syntax error in service file \\\"%s\\\", line %d\\n\"),\n\t\t\t\t\t\t\t\t\t  serviceFile,\n\t\t\t\t\t\t\t\t\t  linenr);\n\t\t\t\t\tresult = 3;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tfclose(f);\n\n\treturn result;\n}\n\n\n/*\n *\t\tPQconninfoParse\n *\n * Parse a string like PQconnectdb() would do and return the\n * resulting connection options array.  NULL is returned on failure.\n * The result contains only options specified directly in the string,\n * not any possible default values.\n *\n * If errmsg isn't NULL, *errmsg is set to NULL on success, or a malloc'd\n * string on failure (use PQfreemem to free it).  In out-of-memory conditions\n * both *errmsg and the result could be NULL.\n *\n * NOTE: the returned array is dynamically allocated and should\n * be freed when no longer needed via PQconninfoFree().\n */\nPQconninfoOption *\nPQconninfoParse(const char *conninfo, char **errmsg)\n{\n\tPQExpBufferData errorBuf;\n\tPQconninfoOption *connOptions;\n\n\tif (errmsg)\n\t\t*errmsg = NULL;\t\t\t/* default */\n\tinitPQExpBuffer(&errorBuf);\n\tif (PQExpBufferDataBroken(errorBuf))\n\t\treturn NULL;\t\t\t/* out of memory already :-( */\n\tconnOptions = parse_connection_string(conninfo, &errorBuf, false);\n\tif (connOptions == NULL && errmsg)\n\t\t*errmsg = errorBuf.data;\n\telse\n\t\ttermPQExpBuffer(&errorBuf);\n\treturn connOptions;\n}\n\n/*\n * Build a working copy of the constant PQconninfoOptions array.\n */\nstatic PQconninfoOption *\nconninfo_init(PQExpBuffer errorMessage)\n{\n\tPQconninfoOption *options;\n\tPQconninfoOption *opt_dest;\n\tconst internalPQconninfoOption *cur_opt;\n\n\t/*\n\t * Get enough memory for all options in PQconninfoOptions, even if some\n\t * end up being filtered out.\n\t */\n\toptions = (PQconninfoOption *) malloc(sizeof(PQconninfoOption) * sizeof(PQconninfoOptions) / sizeof(PQconninfoOptions[0]));\n\tif (options == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\treturn NULL;\n\t}\n\topt_dest = options;\n\n\tfor (cur_opt = PQconninfoOptions; cur_opt->keyword; cur_opt++)\n\t{\n\t\t/* Only copy the public part of the struct, not the full internal */\n\t\tmemcpy(opt_dest, cur_opt, sizeof(PQconninfoOption));\n\t\topt_dest++;\n\t}\n\tMemSet(opt_dest, 0, sizeof(PQconninfoOption));\n\n\treturn options;\n}\n\n/*\n * Connection string parser\n *\n * Returns a malloc'd PQconninfoOption array, if parsing is successful.\n * Otherwise, NULL is returned and an error message is added to errorMessage.\n *\n * If use_defaults is true, default values are filled in (from a service file,\n * environment variables, etc).\n */\nstatic PQconninfoOption *\nparse_connection_string(const char *connstr, PQExpBuffer errorMessage,\n\t\t\t\t\t\tbool use_defaults)\n{\n\t/* Parse as URI if connection string matches URI prefix */\n\tif (uri_prefix_length(connstr) != 0)\n\t\treturn conninfo_uri_parse(connstr, errorMessage, use_defaults);\n\n\t/* Parse as default otherwise */\n\treturn conninfo_parse(connstr, errorMessage, use_defaults);\n}\n\n/*\n * Checks if connection string starts with either of the valid URI prefix\n * designators.\n *\n * Returns the URI prefix length, 0 if the string doesn't contain a URI prefix.\n *\n * XXX this is duplicated in psql/common.c.\n */\nstatic int\nuri_prefix_length(const char *connstr)\n{\n\tif (strncmp(connstr, uri_designator,\n\t\t\t\tsizeof(uri_designator) - 1) == 0)\n\t\treturn sizeof(uri_designator) - 1;\n\n\tif (strncmp(connstr, short_uri_designator,\n\t\t\t\tsizeof(short_uri_designator) - 1) == 0)\n\t\treturn sizeof(short_uri_designator) - 1;\n\n\treturn 0;\n}\n\n/*\n * Recognized connection string either starts with a valid URI prefix or\n * contains a \"=\" in it.\n *\n * Must be consistent with parse_connection_string: anything for which this\n * returns true should at least look like it's parseable by that routine.\n *\n * XXX this is duplicated in psql/common.c\n */\nstatic bool\nrecognized_connection_string(const char *connstr)\n{\n\treturn uri_prefix_length(connstr) != 0 || strchr(connstr, '=') != NULL;\n}\n\n/*\n * Subroutine for parse_connection_string\n *\n * Deal with a string containing key=value pairs.\n */\nstatic PQconninfoOption *\nconninfo_parse(const char *conninfo, PQExpBuffer errorMessage,\n\t\t\t   bool use_defaults)\n{\n\tchar\t   *pname;\n\tchar\t   *pval;\n\tchar\t   *buf;\n\tchar\t   *cp;\n\tchar\t   *cp2;\n\tPQconninfoOption *options;\n\n\t/* Make a working copy of PQconninfoOptions */\n\toptions = conninfo_init(errorMessage);\n\tif (options == NULL)\n\t\treturn NULL;\n\n\t/* Need a modifiable copy of the input string */\n\tif ((buf = strdup(conninfo)) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\tPQconninfoFree(options);\n\t\treturn NULL;\n\t}\n\tcp = buf;\n\n\twhile (*cp)\n\t{\n\t\t/* Skip blanks before the parameter name */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the parameter name */\n\t\tpname = cp;\n\t\twhile (*cp)\n\t\t{\n\t\t\tif (*cp == '=')\n\t\t\t\tbreak;\n\t\t\tif (isspace((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\twhile (*cp)\n\t\t\t\t{\n\t\t\t\t\tif (!isspace((unsigned char) *cp))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcp++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcp++;\n\t\t}\n\n\t\t/* Check that there is a following '=' */\n\t\tif (*cp != '=')\n\t\t{\n\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"missing \\\"=\\\" after \\\"%s\\\" in connection info string\\n\"),\n\t\t\t\t\t\t\t  pname);\n\t\t\tPQconninfoFree(options);\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t*cp++ = '\\0';\n\n\t\t/* Skip blanks after the '=' */\n\t\twhile (*cp)\n\t\t{\n\t\t\tif (!isspace((unsigned char) *cp))\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t}\n\n\t\t/* Get the parameter value */\n\t\tpval = cp;\n\n\t\tif (*cp != '\\'')\n\t\t{\n\t\t\tcp2 = pval;\n\t\t\twhile (*cp)\n\t\t\t{\n\t\t\t\tif (isspace((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tcp++;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\t*cp2++ = *cp++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t*cp2++ = *cp++;\n\t\t\t}\n\t\t\t*cp2 = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcp2 = pval;\n\t\t\tcp++;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tif (*cp == '\\0')\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"unterminated quoted string in connection info string\\n\"));\n\t\t\t\t\tPQconninfoFree(options);\n\t\t\t\t\tfree(buf);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tcp++;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\t*cp2++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\'')\n\t\t\t\t{\n\t\t\t\t\t*cp2 = '\\0';\n\t\t\t\t\tcp++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*cp2++ = *cp++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now that we have the name and the value, store the record.\n\t\t */\n\t\tif (!conninfo_storeval(options, pname, pval, errorMessage, false, false))\n\t\t{\n\t\t\tPQconninfoFree(options);\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Done with the modifiable input string */\n\tfree(buf);\n\n\t/*\n\t * Add in defaults if the caller wants that.\n\t */\n\tif (use_defaults)\n\t{\n\t\tif (!conninfo_add_defaults(options, errorMessage))\n\t\t{\n\t\t\tPQconninfoFree(options);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn options;\n}\n\n/*\n * Conninfo array parser routine\n *\n * If successful, a malloc'd PQconninfoOption array is returned.\n * If not successful, NULL is returned and an error message is\n * appended to errorMessage.\n * Defaults are supplied (from a service file, environment variables, etc)\n * for unspecified options, but only if use_defaults is true.\n *\n * If expand_dbname is non-zero, and the value passed for the first occurrence\n * of \"dbname\" keyword is a connection string (as indicated by\n * recognized_connection_string) then parse and process it, overriding any\n * previously processed conflicting keywords. Subsequent keywords will take\n * precedence, however. In-tree programs generally specify expand_dbname=true,\n * so command-line arguments naming a database can use a connection string.\n * Some code acquires arbitrary database names from known-literal sources like\n * PQdb(), PQconninfoParse() and pg_database.datname.  When connecting to such\n * a database, in-tree code first wraps the name in a connection string.\n */\nstatic PQconninfoOption *\nconninfo_array_parse(const char *const *keywords, const char *const *values,\n\t\t\t\t\t PQExpBuffer errorMessage, bool use_defaults,\n\t\t\t\t\t int expand_dbname)\n{\n\tPQconninfoOption *options;\n\tPQconninfoOption *dbname_options = NULL;\n\tPQconninfoOption *option;\n\tint\t\t\ti = 0;\n\n\t/*\n\t * If expand_dbname is non-zero, check keyword \"dbname\" to see if val is\n\t * actually a recognized connection string.\n\t */\n\twhile (expand_dbname && keywords[i])\n\t{\n\t\tconst char *pname = keywords[i];\n\t\tconst char *pvalue = values[i];\n\n\t\t/* first find \"dbname\" if any */\n\t\tif (strcmp(pname, \"dbname\") == 0 && pvalue)\n\t\t{\n\t\t\t/*\n\t\t\t * If value is a connection string, parse it, but do not use\n\t\t\t * defaults here -- those get picked up later. We only want to\n\t\t\t * override for those parameters actually passed.\n\t\t\t */\n\t\t\tif (recognized_connection_string(pvalue))\n\t\t\t{\n\t\t\t\tdbname_options = parse_connection_string(pvalue, errorMessage, false);\n\t\t\t\tif (dbname_options == NULL)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t++i;\n\t}\n\n\t/* Make a working copy of PQconninfoOptions */\n\toptions = conninfo_init(errorMessage);\n\tif (options == NULL)\n\t{\n\t\tPQconninfoFree(dbname_options);\n\t\treturn NULL;\n\t}\n\n\t/* Parse the keywords/values arrays */\n\ti = 0;\n\twhile (keywords[i])\n\t{\n\t\tconst char *pname = keywords[i];\n\t\tconst char *pvalue = values[i];\n\n\t\tif (pvalue != NULL && pvalue[0] != '\\0')\n\t\t{\n\t\t\t/* Search for the param record */\n\t\t\tfor (option = options; option->keyword != NULL; option++)\n\t\t\t{\n\t\t\t\tif (strcmp(option->keyword, pname) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check for invalid connection option */\n\t\t\tif (option->keyword == NULL)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection option \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  pname);\n\t\t\t\tPQconninfoFree(options);\n\t\t\t\tPQconninfoFree(dbname_options);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we are on the first dbname parameter, and we have a parsed\n\t\t\t * connection string, copy those parameters across, overriding any\n\t\t\t * existing previous settings.\n\t\t\t */\n\t\t\tif (strcmp(pname, \"dbname\") == 0 && dbname_options)\n\t\t\t{\n\t\t\t\tPQconninfoOption *str_option;\n\n\t\t\t\tfor (str_option = dbname_options; str_option->keyword != NULL; str_option++)\n\t\t\t\t{\n\t\t\t\t\tif (str_option->val != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tk;\n\n\t\t\t\t\t\tfor (k = 0; options[k].keyword; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (strcmp(options[k].keyword, str_option->keyword) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (options[k].val)\n\t\t\t\t\t\t\t\t\tfree(options[k].val);\n\t\t\t\t\t\t\t\toptions[k].val = strdup(str_option->val);\n\t\t\t\t\t\t\t\tif (!options[k].val)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\t\t\t\t\tPQconninfoFree(options);\n\t\t\t\t\t\t\t\t\tPQconninfoFree(dbname_options);\n\t\t\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Forget the parsed connection string, so that any subsequent\n\t\t\t\t * dbname parameters will not be expanded.\n\t\t\t\t */\n\t\t\t\tPQconninfoFree(dbname_options);\n\t\t\t\tdbname_options = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Store the value, overriding previous settings\n\t\t\t\t */\n\t\t\t\tif (option->val)\n\t\t\t\t\tfree(option->val);\n\t\t\t\toption->val = strdup(pvalue);\n\t\t\t\tif (!option->val)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\tPQconninfoFree(options);\n\t\t\t\t\tPQconninfoFree(dbname_options);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++i;\n\t}\n\tPQconninfoFree(dbname_options);\n\n\t/*\n\t * Add in defaults if the caller wants that.\n\t */\n\tif (use_defaults)\n\t{\n\t\tif (!conninfo_add_defaults(options, errorMessage))\n\t\t{\n\t\t\tPQconninfoFree(options);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn options;\n}\n\n/*\n * Add the default values for any unspecified options to the connection\n * options array.\n *\n * Defaults are obtained from a service file, environment variables, etc.\n *\n * Returns true if successful, otherwise false; errorMessage, if supplied,\n * is filled in upon failure.  Note that failure to locate a default value\n * is not an error condition here --- we just leave the option's value as\n * NULL.\n */\nstatic bool\nconninfo_add_defaults(PQconninfoOption *options, PQExpBuffer errorMessage)\n{\n\tPQconninfoOption *option;\n\tchar\t   *tmp;\n\n\t/*\n\t * If there's a service spec, use it to obtain any not-explicitly-given\n\t * parameters.  Ignore error if no error message buffer is passed because\n\t * there is no way to pass back the failure message.\n\t */\n\tif (parseServiceInfo(options, errorMessage) != 0 && errorMessage)\n\t\treturn false;\n\n\t/*\n\t * Get the fallback resources for parameters not specified in the conninfo\n\t * string nor the service.\n\t */\n\tfor (option = options; option->keyword != NULL; option++)\n\t{\n\t\tif (option->val != NULL)\n\t\t\tcontinue;\t\t\t/* Value was in conninfo or service */\n\n\t\t/*\n\t\t * Try to get the environment variable fallback\n\t\t */\n\t\tif (option->envvar != NULL)\n\t\t{\n\t\t\tif ((tmp = getenv(option->envvar)) != NULL)\n\t\t\t{\n\t\t\t\toption->val = strdup(tmp);\n\t\t\t\tif (!option->val)\n\t\t\t\t{\n\t\t\t\t\tif (errorMessage)\n\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Interpret the deprecated PGREQUIRESSL environment variable.  Per\n\t\t * tradition, translate values starting with \"1\" to sslmode=require,\n\t\t * and ignore other values.  Given both PGREQUIRESSL=1 and PGSSLMODE,\n\t\t * PGSSLMODE takes precedence; the opposite was true before v9.3.\n\t\t */\n\t\tif (strcmp(option->keyword, \"sslmode\") == 0)\n\t\t{\n\t\t\tconst char *requiresslenv = getenv(\"PGREQUIRESSL\");\n\n\t\t\tif (requiresslenv != NULL && requiresslenv[0] == '1')\n\t\t\t{\n\t\t\t\toption->val = strdup(\"require\");\n\t\t\t\tif (!option->val)\n\t\t\t\t{\n\t\t\t\t\tif (errorMessage)\n\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * No environment variable specified or the variable isn't set - try\n\t\t * compiled-in default\n\t\t */\n\t\tif (option->compiled != NULL)\n\t\t{\n\t\t\toption->val = strdup(option->compiled);\n\t\t\tif (!option->val)\n\t\t\t{\n\t\t\t\tif (errorMessage)\n\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Special handling for \"user\" option.  Note that if pg_fe_getauthname\n\t\t * fails, we just leave the value as NULL; there's no need for this to\n\t\t * be an error condition if the caller provides a user name.  The only\n\t\t * reason we do this now at all is so that callers of PQconndefaults\n\t\t * will see a correct default (barring error, of course).\n\t\t */\n\t\tif (strcmp(option->keyword, \"user\") == 0)\n\t\t{\n\t\t\toption->val = pg_fe_getauthname(NULL);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/*\n * Subroutine for parse_connection_string\n *\n * Deal with a URI connection string.\n */\nstatic PQconninfoOption *\nconninfo_uri_parse(const char *uri, PQExpBuffer errorMessage,\n\t\t\t\t   bool use_defaults)\n{\n\tPQconninfoOption *options;\n\n\t/* Make a working copy of PQconninfoOptions */\n\toptions = conninfo_init(errorMessage);\n\tif (options == NULL)\n\t\treturn NULL;\n\n\tif (!conninfo_uri_parse_options(options, uri, errorMessage))\n\t{\n\t\tPQconninfoFree(options);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Add in defaults if the caller wants that.\n\t */\n\tif (use_defaults)\n\t{\n\t\tif (!conninfo_add_defaults(options, errorMessage))\n\t\t{\n\t\t\tPQconninfoFree(options);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn options;\n}\n\n/*\n * conninfo_uri_parse_options\n *\t\tActual URI parser.\n *\n * If successful, returns true while the options array is filled with parsed\n * options from the URI.\n * If not successful, returns false and fills errorMessage accordingly.\n *\n * Parses the connection URI string in 'uri' according to the URI syntax (RFC\n * 3986):\n *\n * postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&...]\n *\n * where \"netloc\" is a hostname, an IPv4 address, or an IPv6 address surrounded\n * by literal square brackets.  As an extension, we also allow multiple\n * netloc[:port] specifications, separated by commas:\n *\n * postgresql://[user[:password]@][netloc][:port][,...][/dbname][?param1=value1&...]\n *\n * Any of the URI parts might use percent-encoding (%xy).\n */\nstatic bool\nconninfo_uri_parse_options(PQconninfoOption *options, const char *uri,\n\t\t\t\t\t\t   PQExpBuffer errorMessage)\n{\n\tint\t\t\tprefix_len;\n\tchar\t   *p;\n\tchar\t   *buf = NULL;\n\tchar\t   *start;\n\tchar\t\tprevchar = '\\0';\n\tchar\t   *user = NULL;\n\tchar\t   *host = NULL;\n\tbool\t\tretval = false;\n\tPQExpBufferData hostbuf;\n\tPQExpBufferData portbuf;\n\n\tinitPQExpBuffer(&hostbuf);\n\tinitPQExpBuffer(&portbuf);\n\tif (PQExpBufferDataBroken(hostbuf) || PQExpBufferDataBroken(portbuf))\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\tgoto cleanup;\n\t}\n\n\t/* need a modifiable copy of the input URI */\n\tbuf = strdup(uri);\n\tif (buf == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\tgoto cleanup;\n\t}\n\tstart = buf;\n\n\t/* Skip the URI prefix */\n\tprefix_len = uri_prefix_length(uri);\n\tif (prefix_len == 0)\n\t{\n\t\t/* Should never happen */\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid URI propagated to internal parser routine: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t  uri);\n\t\tgoto cleanup;\n\t}\n\tstart += prefix_len;\n\tp = start;\n\n\t/* Look ahead for possible user credentials designator */\n\twhile (*p && *p != '@' && *p != '/')\n\t\t++p;\n\tif (*p == '@')\n\t{\n\t\t/*\n\t\t * Found username/password designator, so URI should be of the form\n\t\t * \"scheme://user[:password]@[netloc]\".\n\t\t */\n\t\tuser = start;\n\n\t\tp = user;\n\t\twhile (*p != ':' && *p != '@')\n\t\t\t++p;\n\n\t\t/* Save last char and cut off at end of user name */\n\t\tprevchar = *p;\n\t\t*p = '\\0';\n\n\t\tif (*user &&\n\t\t\t!conninfo_storeval(options, \"user\", user,\n\t\t\t\t\t\t\t   errorMessage, false, true))\n\t\t\tgoto cleanup;\n\n\t\tif (prevchar == ':')\n\t\t{\n\t\t\tconst char *password = p + 1;\n\n\t\t\twhile (*p != '@')\n\t\t\t\t++p;\n\t\t\t*p = '\\0';\n\n\t\t\tif (*password &&\n\t\t\t\t!conninfo_storeval(options, \"password\", password,\n\t\t\t\t\t\t\t\t   errorMessage, false, true))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Advance past end of parsed user name or password token */\n\t\t++p;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No username/password designator found.  Reset to start of URI.\n\t\t */\n\t\tp = start;\n\t}\n\n\t/*\n\t * There may be multiple netloc[:port] pairs, each separated from the next\n\t * by a comma.  When we initially enter this loop, \"p\" has been\n\t * incremented past optional URI credential information at this point and\n\t * now points at the \"netloc\" part of the URI.  On subsequent loop\n\t * iterations, \"p\" has been incremented past the comma separator and now\n\t * points at the start of the next \"netloc\".\n\t */\n\tfor (;;)\n\t{\n\t\t/*\n\t\t * Look for IPv6 address.\n\t\t */\n\t\tif (*p == '[')\n\t\t{\n\t\t\thost = ++p;\n\t\t\twhile (*p && *p != ']')\n\t\t\t\t++p;\n\t\t\tif (!*p)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"end of string reached when looking for matching \\\"]\\\" in IPv6 host address in URI: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  uri);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (p == host)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"IPv6 host address may not be empty in URI: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  uri);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/* Cut off the bracket and advance */\n\t\t\t*(p++) = '\\0';\n\n\t\t\t/*\n\t\t\t * The address may be followed by a port specifier or a slash or a\n\t\t\t * query or a separator comma.\n\t\t\t */\n\t\t\tif (*p && *p != ':' && *p != '/' && *p != '?' && *p != ',')\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"unexpected character \\\"%c\\\" at position %d in URI (expected \\\":\\\" or \\\"/\\\"): \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  *p, (int) (p - buf + 1), uri);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not an IPv6 address: DNS-named or IPv4 netloc */\n\t\t\thost = p;\n\n\t\t\t/*\n\t\t\t * Look for port specifier (colon) or end of host specifier\n\t\t\t * (slash) or query (question mark) or host separator (comma).\n\t\t\t */\n\t\t\twhile (*p && *p != ':' && *p != '/' && *p != '?' && *p != ',')\n\t\t\t\t++p;\n\t\t}\n\n\t\t/* Save the hostname terminator before we null it */\n\t\tprevchar = *p;\n\t\t*p = '\\0';\n\n\t\tappendPQExpBufferStr(&hostbuf, host);\n\n\t\tif (prevchar == ':')\n\t\t{\n\t\t\tconst char *port = ++p; /* advance past host terminator */\n\n\t\t\twhile (*p && *p != '/' && *p != '?' && *p != ',')\n\t\t\t\t++p;\n\n\t\t\tprevchar = *p;\n\t\t\t*p = '\\0';\n\n\t\t\tappendPQExpBufferStr(&portbuf, port);\n\t\t}\n\n\t\tif (prevchar != ',')\n\t\t\tbreak;\n\t\t++p;\t\t\t\t\t/* advance past comma separator */\n\t\tappendPQExpBufferChar(&hostbuf, ',');\n\t\tappendPQExpBufferChar(&portbuf, ',');\n\t}\n\n\t/* Save final values for host and port. */\n\tif (PQExpBufferDataBroken(hostbuf) || PQExpBufferDataBroken(portbuf))\n\t\tgoto cleanup;\n\tif (hostbuf.data[0] &&\n\t\t!conninfo_storeval(options, \"host\", hostbuf.data,\n\t\t\t\t\t\t   errorMessage, false, true))\n\t\tgoto cleanup;\n\tif (portbuf.data[0] &&\n\t\t!conninfo_storeval(options, \"port\", portbuf.data,\n\t\t\t\t\t\t   errorMessage, false, true))\n\t\tgoto cleanup;\n\n\tif (prevchar && prevchar != '?')\n\t{\n\t\tconst char *dbname = ++p;\t/* advance past host terminator */\n\n\t\t/* Look for query parameters */\n\t\twhile (*p && *p != '?')\n\t\t\t++p;\n\n\t\tprevchar = *p;\n\t\t*p = '\\0';\n\n\t\t/*\n\t\t * Avoid setting dbname to an empty string, as it forces the default\n\t\t * value (username) and ignores $PGDATABASE, as opposed to not setting\n\t\t * it at all.\n\t\t */\n\t\tif (*dbname &&\n\t\t\t!conninfo_storeval(options, \"dbname\", dbname,\n\t\t\t\t\t\t\t   errorMessage, false, true))\n\t\t\tgoto cleanup;\n\t}\n\n\tif (prevchar)\n\t{\n\t\t++p;\t\t\t\t\t/* advance past terminator */\n\n\t\tif (!conninfo_uri_parse_params(p, options, errorMessage))\n\t\t\tgoto cleanup;\n\t}\n\n\t/* everything parsed okay */\n\tretval = true;\n\ncleanup:\n\ttermPQExpBuffer(&hostbuf);\n\ttermPQExpBuffer(&portbuf);\n\tif (buf)\n\t\tfree(buf);\n\treturn retval;\n}\n\n/*\n * Connection URI parameters parser routine\n *\n * If successful, returns true while connOptions is filled with parsed\n * parameters.  Otherwise, returns false and fills errorMessage appropriately.\n *\n * Destructively modifies 'params' buffer.\n */\nstatic bool\nconninfo_uri_parse_params(char *params,\n\t\t\t\t\t\t  PQconninfoOption *connOptions,\n\t\t\t\t\t\t  PQExpBuffer errorMessage)\n{\n\twhile (*params)\n\t{\n\t\tchar\t   *keyword = params;\n\t\tchar\t   *value = NULL;\n\t\tchar\t   *p = params;\n\t\tbool\t\tmalloced = false;\n\t\tint\t\t\toldmsglen;\n\n\t\t/*\n\t\t * Scan the params string for '=' and '&', marking the end of keyword\n\t\t * and value respectively.\n\t\t */\n\t\tfor (;;)\n\t\t{\n\t\t\tif (*p == '=')\n\t\t\t{\n\t\t\t\t/* Was there '=' already? */\n\t\t\t\tif (value != NULL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"extra key/value separator \\\"=\\\" in URI query parameter: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t  keyword);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Cut off keyword, advance to value */\n\t\t\t\t*p++ = '\\0';\n\t\t\t\tvalue = p;\n\t\t\t}\n\t\t\telse if (*p == '&' || *p == '\\0')\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If not at the end, cut off value and advance; leave p\n\t\t\t\t * pointing to start of the next parameter, if any.\n\t\t\t\t */\n\t\t\t\tif (*p != '\\0')\n\t\t\t\t\t*p++ = '\\0';\n\t\t\t\t/* Was there '=' at all? */\n\t\t\t\tif (value == NULL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"missing key/value separator \\\"=\\\" in URI query parameter: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t  keyword);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Got keyword and value, go process them. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++p;\t\t\t/* Advance over all other bytes. */\n\t\t}\n\n\t\tkeyword = conninfo_uri_decode(keyword, errorMessage);\n\t\tif (keyword == NULL)\n\t\t{\n\t\t\t/* conninfo_uri_decode already set an error message */\n\t\t\treturn false;\n\t\t}\n\t\tvalue = conninfo_uri_decode(value, errorMessage);\n\t\tif (value == NULL)\n\t\t{\n\t\t\t/* conninfo_uri_decode already set an error message */\n\t\t\tfree(keyword);\n\t\t\treturn false;\n\t\t}\n\t\tmalloced = true;\n\n\t\t/*\n\t\t * Special keyword handling for improved JDBC compatibility.\n\t\t */\n\t\tif (strcmp(keyword, \"ssl\") == 0 &&\n\t\t\tstrcmp(value, \"true\") == 0)\n\t\t{\n\t\t\tfree(keyword);\n\t\t\tfree(value);\n\t\t\tmalloced = false;\n\n\t\t\tkeyword = \"sslmode\";\n\t\t\tvalue = \"require\";\n\t\t}\n\n\t\t/*\n\t\t * Store the value if the corresponding option exists; ignore\n\t\t * otherwise.  At this point both keyword and value are not\n\t\t * URI-encoded.\n\t\t */\n\t\toldmsglen = errorMessage->len;\n\t\tif (!conninfo_storeval(connOptions, keyword, value,\n\t\t\t\t\t\t\t   errorMessage, true, false))\n\t\t{\n\t\t\t/* Insert generic message if conninfo_storeval didn't give one. */\n\t\t\tif (errorMessage->len == oldmsglen)\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid URI query parameter: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  keyword);\n\t\t\t/* And fail. */\n\t\t\tif (malloced)\n\t\t\t{\n\t\t\t\tfree(keyword);\n\t\t\t\tfree(value);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (malloced)\n\t\t{\n\t\t\tfree(keyword);\n\t\t\tfree(value);\n\t\t}\n\n\t\t/* Proceed to next key=value pair, if any */\n\t\tparams = p;\n\t}\n\n\treturn true;\n}\n\n/*\n * Connection URI decoder routine\n *\n * If successful, returns the malloc'd decoded string.\n * If not successful, returns NULL and fills errorMessage accordingly.\n *\n * The string is decoded by replacing any percent-encoded tokens with\n * corresponding characters, while preserving any non-encoded characters.  A\n * percent-encoded token is a character triplet: a percent sign, followed by a\n * pair of hexadecimal digits (0-9A-F), where lower- and upper-case letters are\n * treated identically.\n */\nstatic char *\nconninfo_uri_decode(const char *str, PQExpBuffer errorMessage)\n{\n\tchar\t   *buf;\n\tchar\t   *p;\n\tconst char *q = str;\n\n\tbuf = malloc(strlen(str) + 1);\n\tif (buf == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage, libpq_gettext(\"out of memory\\n\"));\n\t\treturn NULL;\n\t}\n\tp = buf;\n\n\tfor (;;)\n\t{\n\t\tif (*q != '%')\n\t\t{\n\t\t\t/* copy and check for NUL terminator */\n\t\t\tif (!(*(p++) = *(q++)))\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint\t\t\thi;\n\t\t\tint\t\t\tlo;\n\t\t\tint\t\t\tc;\n\n\t\t\t++q;\t\t\t\t/* skip the percent sign itself */\n\n\t\t\t/*\n\t\t\t * Possible EOL will be caught by the first call to\n\t\t\t * get_hexdigit(), so we never dereference an invalid q pointer.\n\t\t\t */\n\t\t\tif (!(get_hexdigit(*q++, &hi) && get_hexdigit(*q++, &lo)))\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid percent-encoded token: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  str);\n\t\t\t\tfree(buf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tc = (hi << 4) | lo;\n\t\t\tif (c == 0)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"forbidden value %%00 in percent-encoded value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  str);\n\t\t\t\tfree(buf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t*(p++) = c;\n\t\t}\n\t}\n\n\treturn buf;\n}\n\n/*\n * Convert hexadecimal digit character to its integer value.\n *\n * If successful, returns true and value is filled with digit's base 16 value.\n * If not successful, returns false.\n *\n * Lower- and upper-case letters in the range A-F are treated identically.\n */\nstatic bool\nget_hexdigit(char digit, int *value)\n{\n\tif ('0' <= digit && digit <= '9')\n\t\t*value = digit - '0';\n\telse if ('A' <= digit && digit <= 'F')\n\t\t*value = digit - 'A' + 10;\n\telse if ('a' <= digit && digit <= 'f')\n\t\t*value = digit - 'a' + 10;\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n\n/*\n * Find an option value corresponding to the keyword in the connOptions array.\n *\n * If successful, returns a pointer to the corresponding option's value.\n * If not successful, returns NULL.\n */\nstatic const char *\nconninfo_getval(PQconninfoOption *connOptions,\n\t\t\t\tconst char *keyword)\n{\n\tPQconninfoOption *option;\n\n\toption = conninfo_find(connOptions, keyword);\n\n\treturn option ? option->val : NULL;\n}\n\n/*\n * Store a (new) value for an option corresponding to the keyword in\n * connOptions array.\n *\n * If uri_decode is true, the value is URI-decoded.  The keyword is always\n * assumed to be non URI-encoded.\n *\n * If successful, returns a pointer to the corresponding PQconninfoOption,\n * which value is replaced with a strdup'd copy of the passed value string.\n * The existing value for the option is free'd before replacing, if any.\n *\n * If not successful, returns NULL and fills errorMessage accordingly.\n * However, if the reason of failure is an invalid keyword being passed and\n * ignoreMissing is true, errorMessage will be left untouched.\n */\nstatic PQconninfoOption *\nconninfo_storeval(PQconninfoOption *connOptions,\n\t\t\t\t  const char *keyword, const char *value,\n\t\t\t\t  PQExpBuffer errorMessage, bool ignoreMissing,\n\t\t\t\t  bool uri_decode)\n{\n\tPQconninfoOption *option;\n\tchar\t   *value_copy;\n\n\t/*\n\t * For backwards compatibility, requiressl=1 gets translated to\n\t * sslmode=require, and requiressl=0 gets translated to sslmode=prefer\n\t * (which is the default for sslmode).\n\t */\n\tif (strcmp(keyword, \"requiressl\") == 0)\n\t{\n\t\tkeyword = \"sslmode\";\n\t\tif (value[0] == '1')\n\t\t\tvalue = \"require\";\n\t\telse\n\t\t\tvalue = \"prefer\";\n\t}\n\n\toption = conninfo_find(connOptions, keyword);\n\tif (option == NULL)\n\t{\n\t\tif (!ignoreMissing)\n\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection option \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  keyword);\n\t\treturn NULL;\n\t}\n\n\tif (uri_decode)\n\t{\n\t\tvalue_copy = conninfo_uri_decode(value, errorMessage);\n\t\tif (value_copy == NULL)\n\t\t\t/* conninfo_uri_decode already set an error message */\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\tvalue_copy = strdup(value);\n\t\tif (value_copy == NULL)\n\t\t{\n\t\t\tappendPQExpBufferStr(errorMessage, libpq_gettext(\"out of memory\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (option->val)\n\t\tfree(option->val);\n\toption->val = value_copy;\n\n\treturn option;\n}\n\n/*\n * Find a PQconninfoOption option corresponding to the keyword in the\n * connOptions array.\n *\n * If successful, returns a pointer to the corresponding PQconninfoOption\n * structure.\n * If not successful, returns NULL.\n */\nstatic PQconninfoOption *\nconninfo_find(PQconninfoOption *connOptions, const char *keyword)\n{\n\tPQconninfoOption *option;\n\n\tfor (option = connOptions; option->keyword != NULL; option++)\n\t{\n\t\tif (strcmp(option->keyword, keyword) == 0)\n\t\t\treturn option;\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n * Return the connection options used for the connection\n */\nPQconninfoOption *\nPQconninfo(PGconn *conn)\n{\n\tPQExpBufferData errorBuf;\n\tPQconninfoOption *connOptions;\n\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * We don't actually report any errors here, but callees want a buffer,\n\t * and we prefer not to trash the conn's errorMessage.\n\t */\n\tinitPQExpBuffer(&errorBuf);\n\tif (PQExpBufferDataBroken(errorBuf))\n\t\treturn NULL;\t\t\t/* out of memory already :-( */\n\n\tconnOptions = conninfo_init(&errorBuf);\n\n\tif (connOptions != NULL)\n\t{\n\t\tconst internalPQconninfoOption *option;\n\n\t\tfor (option = PQconninfoOptions; option->keyword; option++)\n\t\t{\n\t\t\tchar\t  **connmember;\n\n\t\t\tif (option->connofs < 0)\n\t\t\t\tcontinue;\n\n\t\t\tconnmember = (char **) ((char *) conn + option->connofs);\n\n\t\t\tif (*connmember)\n\t\t\t\tconninfo_storeval(connOptions, option->keyword, *connmember,\n\t\t\t\t\t\t\t\t  &errorBuf, true, false);\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&errorBuf);\n\n\treturn connOptions;\n}\n\n\nvoid\nPQconninfoFree(PQconninfoOption *connOptions)\n{\n\tPQconninfoOption *option;\n\n\tif (connOptions == NULL)\n\t\treturn;\n\n\tfor (option = connOptions; option->keyword != NULL; option++)\n\t{\n\t\tif (option->val != NULL)\n\t\t\tfree(option->val);\n\t}\n\tfree(connOptions);\n}\n\n\n/* =========== accessor functions for PGconn ========= */\nchar *\nPQdb(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\treturn conn->dbName;\n}\n\nchar *\nPQuser(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\treturn conn->pguser;\n}\n\nchar *\nPQpass(const PGconn *conn)\n{\n\tchar\t   *password = NULL;\n\n\tif (!conn)\n\t\treturn NULL;\n\tif (conn->connhost != NULL)\n\t\tpassword = conn->connhost[conn->whichhost].password;\n\tif (password == NULL)\n\t\tpassword = conn->pgpass;\n\t/* Historically we've returned \"\" not NULL for no password specified */\n\tif (password == NULL)\n\t\tpassword = \"\";\n\treturn password;\n}\n\nchar *\nPQhost(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\n\tif (conn->connhost != NULL)\n\t{\n\t\t/*\n\t\t * Return the verbatim host value provided by user, or hostaddr in its\n\t\t * lack.\n\t\t */\n\t\tif (conn->connhost[conn->whichhost].host != NULL &&\n\t\t\tconn->connhost[conn->whichhost].host[0] != '\\0')\n\t\t\treturn conn->connhost[conn->whichhost].host;\n\t\telse if (conn->connhost[conn->whichhost].hostaddr != NULL &&\n\t\t\t\t conn->connhost[conn->whichhost].hostaddr[0] != '\\0')\n\t\t\treturn conn->connhost[conn->whichhost].hostaddr;\n\t}\n\n\treturn \"\";\n}\n\nchar *\nPQhostaddr(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\n\t/* Return the parsed IP address */\n\tif (conn->connhost != NULL && conn->connip != NULL)\n\t\treturn conn->connip;\n\n\treturn \"\";\n}\n\nchar *\nPQport(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\n\tif (conn->connhost != NULL)\n\t\treturn conn->connhost[conn->whichhost].port;\n\n\treturn \"\";\n}\n\n/*\n * No longer does anything, but the function remains for API backwards\n * compatibility.\n */\nchar *\nPQtty(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\treturn \"\";\n}\n\nchar *\nPQoptions(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\treturn conn->pgoptions;\n}\n\nConnStatusType\nPQstatus(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn CONNECTION_BAD;\n\treturn conn->status;\n}\n\nPGTransactionStatusType\nPQtransactionStatus(const PGconn *conn)\n{\n\tif (!conn || conn->status != CONNECTION_OK)\n\t\treturn PQTRANS_UNKNOWN;\n\tif (conn->asyncStatus != PGASYNC_IDLE)\n\t\treturn PQTRANS_ACTIVE;\n\treturn conn->xactStatus;\n}\n\nconst char *\nPQparameterStatus(const PGconn *conn, const char *paramName)\n{\n\tconst pgParameterStatus *pstatus;\n\n\tif (!conn || !paramName)\n\t\treturn NULL;\n\tfor (pstatus = conn->pstatus; pstatus != NULL; pstatus = pstatus->next)\n\t{\n\t\tif (strcmp(pstatus->name, paramName) == 0)\n\t\t\treturn pstatus->value;\n\t}\n\treturn NULL;\n}\n\nint\nPQprotocolVersion(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn 0;\n\tif (conn->status == CONNECTION_BAD)\n\t\treturn 0;\n\treturn PG_PROTOCOL_MAJOR(conn->pversion);\n}\n\nint\nPQserverVersion(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn 0;\n\tif (conn->status == CONNECTION_BAD)\n\t\treturn 0;\n\treturn conn->sversion;\n}\n\nchar *\nPQerrorMessage(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn libpq_gettext(\"connection pointer is NULL\\n\");\n\n\t/*\n\t * The errorMessage buffer might be marked \"broken\" due to having\n\t * previously failed to allocate enough memory for the message.  In that\n\t * case, tell the application we ran out of memory.\n\t */\n\tif (PQExpBufferBroken(&conn->errorMessage))\n\t\treturn libpq_gettext(\"out of memory\\n\");\n\n\treturn conn->errorMessage.data;\n}\n\n/*\n * In Windows, socket values are unsigned, and an invalid socket value\n * (INVALID_SOCKET) is ~0, which equals -1 in comparisons (with no compiler\n * warning). Ideally we would return an unsigned value for PQsocket() on\n * Windows, but that would cause the function's return value to differ from\n * Unix, so we just return -1 for invalid sockets.\n * http://msdn.microsoft.com/en-us/library/windows/desktop/cc507522%28v=vs.85%29.aspx\n * http://stackoverflow.com/questions/10817252/why-is-invalid-socket-defined-as-0-in-winsock2-h-c\n */\nint\nPQsocket(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn -1;\n\treturn (conn->sock != PGINVALID_SOCKET) ? conn->sock : -1;\n}\n\nint\nPQbackendPID(const PGconn *conn)\n{\n\tif (!conn || conn->status != CONNECTION_OK)\n\t\treturn 0;\n\treturn conn->be_pid;\n}\n\nPGpipelineStatus\nPQpipelineStatus(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn PQ_PIPELINE_OFF;\n\n\treturn conn->pipelineStatus;\n}\n\nint\nPQconnectionNeedsPassword(const PGconn *conn)\n{\n\tchar\t   *password;\n\n\tif (!conn)\n\t\treturn false;\n\tpassword = PQpass(conn);\n\tif (conn->password_needed &&\n\t\t(password == NULL || password[0] == '\\0'))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint\nPQconnectionUsedPassword(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn false;\n\tif (conn->password_needed)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint\nPQclientEncoding(const PGconn *conn)\n{\n\tif (!conn || conn->status != CONNECTION_OK)\n\t\treturn -1;\n\treturn conn->client_encoding;\n}\n\nint\nPQsetClientEncoding(PGconn *conn, const char *encoding)\n{\n\tchar\t\tqbuf[128];\n\tstatic const char query[] = \"set client_encoding to '%s'\";\n\tPGresult   *res;\n\tint\t\t\tstatus;\n\n\tif (!conn || conn->status != CONNECTION_OK)\n\t\treturn -1;\n\n\tif (!encoding)\n\t\treturn -1;\n\n\t/* Resolve special \"auto\" value from the locale */\n\tif (strcmp(encoding, \"auto\") == 0)\n\t\tencoding = pg_encoding_to_char(pg_get_encoding_from_locale(NULL, true));\n\n\t/* check query buffer overflow */\n\tif (sizeof(qbuf) < (sizeof(query) + strlen(encoding)))\n\t\treturn -1;\n\n\t/* ok, now send a query */\n\tsprintf(qbuf, query, encoding);\n\tres = PQexec(conn, qbuf);\n\n\tif (res == NULL)\n\t\treturn -1;\n\tif (res->resultStatus != PGRES_COMMAND_OK)\n\t\tstatus = -1;\n\telse\n\t{\n\t\t/*\n\t\t * We rely on the backend to report the parameter value, and we'll\n\t\t * change state at that time.\n\t\t */\n\t\tstatus = 0;\t\t\t\t/* everything is ok */\n\t}\n\tPQclear(res);\n\treturn status;\n}\n\nPGVerbosity\nPQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity)\n{\n\tPGVerbosity old;\n\n\tif (!conn)\n\t\treturn PQERRORS_DEFAULT;\n\told = conn->verbosity;\n\tconn->verbosity = verbosity;\n\treturn old;\n}\n\nPGContextVisibility\nPQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context)\n{\n\tPGContextVisibility old;\n\n\tif (!conn)\n\t\treturn PQSHOW_CONTEXT_ERRORS;\n\told = conn->show_context;\n\tconn->show_context = show_context;\n\treturn old;\n}\n\nPQnoticeReceiver\nPQsetNoticeReceiver(PGconn *conn, PQnoticeReceiver proc, void *arg)\n{\n\tPQnoticeReceiver old;\n\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\told = conn->noticeHooks.noticeRec;\n\tif (proc)\n\t{\n\t\tconn->noticeHooks.noticeRec = proc;\n\t\tconn->noticeHooks.noticeRecArg = arg;\n\t}\n\treturn old;\n}\n\nPQnoticeProcessor\nPQsetNoticeProcessor(PGconn *conn, PQnoticeProcessor proc, void *arg)\n{\n\tPQnoticeProcessor old;\n\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\told = conn->noticeHooks.noticeProc;\n\tif (proc)\n\t{\n\t\tconn->noticeHooks.noticeProc = proc;\n\t\tconn->noticeHooks.noticeProcArg = arg;\n\t}\n\treturn old;\n}\n\n/*\n * The default notice message receiver just gets the standard notice text\n * and sends it to the notice processor.  This two-level setup exists\n * mostly for backwards compatibility; perhaps we should deprecate use of\n * PQsetNoticeProcessor?\n */\nstatic void\ndefaultNoticeReceiver(void *arg, const PGresult *res)\n{\n\t(void) arg;\t\t\t\t\t/* not used */\n\tif (res->noticeHooks.noticeProc != NULL)\n\t\tres->noticeHooks.noticeProc(res->noticeHooks.noticeProcArg,\n\t\t\t\t\t\t\t\t\tPQresultErrorMessage(res));\n}\n\n/*\n * The default notice message processor just prints the\n * message on stderr.  Applications can override this if they\n * want the messages to go elsewhere (a window, for example).\n * Note that simply discarding notices is probably a bad idea.\n */\nstatic void\ndefaultNoticeProcessor(void *arg, const char *message)\n{\n\t(void) arg;\t\t\t\t\t/* not used */\n\t/* Note: we expect the supplied string to end with a newline already. */\n\tfprintf(stderr, \"%s\", message);\n}\n\n/*\n * returns a pointer to the next token or NULL if the current\n * token doesn't match\n */\nstatic char *\npwdfMatchesString(char *buf, const char *token)\n{\n\tchar\t   *tbuf;\n\tconst char *ttok;\n\tbool\t\tbslash = false;\n\n\tif (buf == NULL || token == NULL)\n\t\treturn NULL;\n\ttbuf = buf;\n\tttok = token;\n\tif (tbuf[0] == '*' && tbuf[1] == ':')\n\t\treturn tbuf + 2;\n\twhile (*tbuf != 0)\n\t{\n\t\tif (*tbuf == '\\\\' && !bslash)\n\t\t{\n\t\t\ttbuf++;\n\t\t\tbslash = true;\n\t\t}\n\t\tif (*tbuf == ':' && *ttok == 0 && !bslash)\n\t\t\treturn tbuf + 1;\n\t\tbslash = false;\n\t\tif (*ttok == 0)\n\t\t\treturn NULL;\n\t\tif (*tbuf == *ttok)\n\t\t{\n\t\t\ttbuf++;\n\t\t\tttok++;\n\t\t}\n\t\telse\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\n/* Get a password from the password file. Return value is malloc'd. */\nstatic char *\npasswordFromFile(const char *hostname, const char *port, const char *dbname,\n\t\t\t\t const char *username, const char *pgpassfile)\n{\n\tFILE\t   *fp;\n\tstruct stat stat_buf;\n\tPQExpBufferData buf;\n\n\tif (dbname == NULL || dbname[0] == '\\0')\n\t\treturn NULL;\n\n\tif (username == NULL || username[0] == '\\0')\n\t\treturn NULL;\n\n\t/* 'localhost' matches pghost of '' or the default socket directory */\n\tif (hostname == NULL || hostname[0] == '\\0')\n\t\thostname = DefaultHost;\n\telse if (is_unixsock_path(hostname))\n\n\t\t/*\n\t\t * We should probably use canonicalize_path(), but then we have to\n\t\t * bring path.c into libpq, and it doesn't seem worth it.\n\t\t */\n\t\tif (strcmp(hostname, DEFAULT_PGSOCKET_DIR) == 0)\n\t\t\thostname = DefaultHost;\n\n\tif (port == NULL || port[0] == '\\0')\n\t\tport = DEF_PGPORT_STR;\n\n\t/* If password file cannot be opened, ignore it. */\n\tif (stat(pgpassfile, &stat_buf) != 0)\n\t\treturn NULL;\n\n#ifndef WIN32\n\tif (!S_ISREG(stat_buf.st_mode))\n\t{\n\t\tfprintf(stderr,\n\t\t\t\tlibpq_gettext(\"WARNING: password file \\\"%s\\\" is not a plain file\\n\"),\n\t\t\t\tpgpassfile);\n\t\treturn NULL;\n\t}\n\n\t/* If password file is insecure, alert the user and ignore it. */\n\tif (stat_buf.st_mode & (S_IRWXG | S_IRWXO))\n\t{\n\t\tfprintf(stderr,\n\t\t\t\tlibpq_gettext(\"WARNING: password file \\\"%s\\\" has group or world access; permissions should be u=rw (0600) or less\\n\"),\n\t\t\t\tpgpassfile);\n\t\treturn NULL;\n\t}\n#else\n\n\t/*\n\t * On Win32, the directory is protected, so we don't have to check the\n\t * file.\n\t */\n#endif\n\n\tfp = fopen(pgpassfile, \"r\");\n\tif (fp == NULL)\n\t\treturn NULL;\n\n\t/* Use an expansible buffer to accommodate any reasonable line length */\n\tinitPQExpBuffer(&buf);\n\n\twhile (!feof(fp) && !ferror(fp))\n\t{\n\t\t/* Make sure there's a reasonable amount of room in the buffer */\n\t\tif (!enlargePQExpBuffer(&buf, 128))\n\t\t\tbreak;\n\n\t\t/* Read some data, appending it to what we already have */\n\t\tif (fgets(buf.data + buf.len, buf.maxlen - buf.len, fp) == NULL)\n\t\t\tbreak;\n\t\tbuf.len += strlen(buf.data + buf.len);\n\n\t\t/* If we don't yet have a whole line, loop around to read more */\n\t\tif (!(buf.len > 0 && buf.data[buf.len - 1] == '\\n') && !feof(fp))\n\t\t\tcontinue;\n\n\t\t/* ignore comments */\n\t\tif (buf.data[0] != '#')\n\t\t{\n\t\t\tchar\t   *t = buf.data;\n\t\t\tint\t\t\tlen;\n\n\t\t\t/* strip trailing newline and carriage return */\n\t\t\tlen = pg_strip_crlf(t);\n\n\t\t\tif (len > 0 &&\n\t\t\t\t(t = pwdfMatchesString(t, hostname)) != NULL &&\n\t\t\t\t(t = pwdfMatchesString(t, port)) != NULL &&\n\t\t\t\t(t = pwdfMatchesString(t, dbname)) != NULL &&\n\t\t\t\t(t = pwdfMatchesString(t, username)) != NULL)\n\t\t\t{\n\t\t\t\t/* Found a match. */\n\t\t\t\tchar\t   *ret,\n\t\t\t\t\t\t   *p1,\n\t\t\t\t\t\t   *p2;\n\n\t\t\t\tret = strdup(t);\n\n\t\t\t\tfclose(fp);\n\t\t\t\texplicit_bzero(buf.data, buf.maxlen);\n\t\t\t\ttermPQExpBuffer(&buf);\n\n\t\t\t\tif (!ret)\n\t\t\t\t{\n\t\t\t\t\t/* Out of memory. XXX: an error message would be nice. */\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\t/* De-escape password. */\n\t\t\t\tfor (p1 = p2 = ret; *p1 != ':' && *p1 != '\\0'; ++p1, ++p2)\n\t\t\t\t{\n\t\t\t\t\tif (*p1 == '\\\\' && p1[1] != '\\0')\n\t\t\t\t\t\t++p1;\n\t\t\t\t\t*p2 = *p1;\n\t\t\t\t}\n\t\t\t\t*p2 = '\\0';\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/* No match, reset buffer to prepare for next line. */\n\t\tbuf.len = 0;\n\t}\n\n\tfclose(fp);\n\texplicit_bzero(buf.data, buf.maxlen);\n\ttermPQExpBuffer(&buf);\n\treturn NULL;\n}\n\n\n/*\n *\tIf the connection failed due to bad password, we should mention\n *\tif we got the password from the pgpassfile.\n */\nstatic void\npgpassfileWarning(PGconn *conn)\n{\n\t/* If it was 'invalid authorization', add pgpassfile mention */\n\t/* only works with >= 9.0 servers */\n\tif (conn->password_needed &&\n\t\tconn->connhost[conn->whichhost].password != NULL &&\n\t\tconn->result)\n\t{\n\t\tconst char *sqlstate = PQresultErrorField(conn->result,\n\t\t\t\t\t\t\t\t\t\t\t\t  PG_DIAG_SQLSTATE);\n\n\t\tif (sqlstate && strcmp(sqlstate, ERRCODE_INVALID_PASSWORD) == 0)\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"password retrieved from file \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  conn->pgpassfile);\n\t}\n}\n\n/*\n * Check if the SSL protocol value given in input is valid or not.\n * This is used as a sanity check routine for the connection parameters\n * ssl_min_protocol_version and ssl_max_protocol_version.\n */\nstatic bool\nsslVerifyProtocolVersion(const char *version)\n{\n\t/*\n\t * An empty string and a NULL value are considered valid as it is\n\t * equivalent to ignoring the parameter.\n\t */\n\tif (!version || strlen(version) == 0)\n\t\treturn true;\n\n\tif (pg_strcasecmp(version, \"TLSv1\") == 0 ||\n\t\tpg_strcasecmp(version, \"TLSv1.1\") == 0 ||\n\t\tpg_strcasecmp(version, \"TLSv1.2\") == 0 ||\n\t\tpg_strcasecmp(version, \"TLSv1.3\") == 0)\n\t\treturn true;\n\n\t/* anything else is wrong */\n\treturn false;\n}\n\n\n/*\n * Ensure that the SSL protocol range given in input is correct.  The check\n * is performed on the input string to keep it TLS backend agnostic.  Input\n * to this function is expected verified with sslVerifyProtocolVersion().\n */\nstatic bool\nsslVerifyProtocolRange(const char *min, const char *max)\n{\n\tAssert(sslVerifyProtocolVersion(min) &&\n\t\t   sslVerifyProtocolVersion(max));\n\n\t/* If at least one of the bounds is not set, the range is valid */\n\tif (min == NULL || max == NULL || strlen(min) == 0 || strlen(max) == 0)\n\t\treturn true;\n\n\t/*\n\t * If the minimum version is the lowest one we accept, then all options\n\t * for the maximum are valid.\n\t */\n\tif (pg_strcasecmp(min, \"TLSv1\") == 0)\n\t\treturn true;\n\n\t/*\n\t * The minimum bound is valid, and cannot be TLSv1, so using TLSv1 for the\n\t * maximum is incorrect.\n\t */\n\tif (pg_strcasecmp(max, \"TLSv1\") == 0)\n\t\treturn false;\n\n\t/*\n\t * At this point we know that we have a mix of TLSv1.1 through 1.3\n\t * versions.\n\t */\n\tif (pg_strcasecmp(min, max) > 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n\n/*\n * Obtain user's home directory, return in given buffer\n *\n * On Unix, this actually returns the user's home directory.  On Windows\n * it returns the PostgreSQL-specific application data folder.\n *\n * This is essentially the same as get_home_path(), but we don't use that\n * because we don't want to pull path.c into libpq (it pollutes application\n * namespace).\n *\n * Returns true on success, false on failure to obtain the directory name.\n *\n * CAUTION: although in most situations failure is unexpected, there are users\n * who like to run applications in a home-directory-less environment.  On\n * failure, you almost certainly DO NOT want to report an error.  Just act as\n * though whatever file you were hoping to find in the home directory isn't\n * there (which it isn't).\n */\nbool\npqGetHomeDirectory(char *buf, int bufsize)\n{\n#ifndef WIN32\n\tchar\t\tpwdbuf[BUFSIZ];\n\tstruct passwd pwdstr;\n\tstruct passwd *pwd = NULL;\n\n\t(void) pqGetpwuid(geteuid(), &pwdstr, pwdbuf, sizeof(pwdbuf), &pwd);\n\tif (pwd == NULL)\n\t\treturn false;\n\tstrlcpy(buf, pwd->pw_dir, bufsize);\n\treturn true;\n#else\n\tchar\t\ttmppath[MAX_PATH];\n\n\tZeroMemory(tmppath, sizeof(tmppath));\n\tif (SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, tmppath) != S_OK)\n\t\treturn false;\n\tsnprintf(buf, bufsize, \"%s/postgresql\", tmppath);\n\treturn true;\n#endif\n}\n\n/*\n * To keep the API consistent, the locking stubs are always provided, even\n * if they are not required.\n *\n * Since we neglected to provide any error-return convention in the\n * pgthreadlock_t API, we can't do much except Assert upon failure of any\n * mutex primitive.  Fortunately, such failures appear to be nonexistent in\n * the field.\n */\n\nstatic void\ndefault_threadlock(int acquire)\n{\n#ifdef ENABLE_THREAD_SAFETY\n#ifndef WIN32\n\tstatic pthread_mutex_t singlethread_lock = PTHREAD_MUTEX_INITIALIZER;\n#else\n\tstatic pthread_mutex_t singlethread_lock = NULL;\n\tstatic long mutex_initlock = 0;\n\n\tif (singlethread_lock == NULL)\n\t{\n\t\twhile (InterlockedExchange(&mutex_initlock, 1) == 1)\n\t\t\t /* loop, another thread own the lock */ ;\n\t\tif (singlethread_lock == NULL)\n\t\t{\n\t\t\tif (pthread_mutex_init(&singlethread_lock, NULL))\n\t\t\t\tAssert(false);\n\t\t}\n\t\tInterlockedExchange(&mutex_initlock, 0);\n\t}\n#endif\n\tif (acquire)\n\t{\n\t\tif (pthread_mutex_lock(&singlethread_lock))\n\t\t\tAssert(false);\n\t}\n\telse\n\t{\n\t\tif (pthread_mutex_unlock(&singlethread_lock))\n\t\t\tAssert(false);\n\t}\n#endif\n}\n\npgthreadlock_t\nPQregisterThreadLock(pgthreadlock_t newhandler)\n{\n\tpgthreadlock_t prev = pg_g_threadlock;\n\n\tif (newhandler)\n\t\tpg_g_threadlock = newhandler;\n\telse\n\t\tpg_g_threadlock = default_threadlock;\n\n\treturn prev;\n}\n"], "fixing_code": ["<!-- doc/src/sgml/protocol.sgml -->\n\n<chapter id=\"protocol\">\n <title>Frontend/Backend Protocol</title>\n\n <indexterm zone=\"protocol\">\n  <primary>protocol</primary>\n  <secondary>frontend-backend</secondary>\n </indexterm>\n\n <para>\n  <productname>PostgreSQL</productname> uses a message-based protocol\n  for communication between frontends and backends (clients and servers).\n  The protocol is supported over <acronym>TCP/IP</acronym> and also over\n  Unix-domain sockets.  Port number 5432 has been registered with IANA as\n  the customary TCP port number for servers supporting this protocol, but\n  in practice any non-privileged port number can be used.\n </para>\n\n <para>\n  This document describes version 3.0 of the protocol, implemented in\n  <productname>PostgreSQL</productname> 7.4 and later.  For descriptions\n  of the earlier protocol versions, see previous releases of the\n  <productname>PostgreSQL</productname> documentation.  A single server\n  can support multiple protocol versions.  The initial startup-request\n  message tells the server which protocol version the client is attempting to\n  use.  If the major version requested by the client is not supported by\n  the server, the connection will be rejected (for example, this would occur\n  if the client requested protocol version 4.0, which does not exist as of\n  this writing).  If the minor version requested by the client is not\n  supported by the server (e.g., the client requests version 3.1, but the\n  server supports only 3.0), the server may either reject the connection or\n  may respond with a NegotiateProtocolVersion message containing the highest\n  minor protocol version which it supports.  The client may then choose either\n  to continue with the connection using the specified protocol version or\n  to abort the connection.\n </para>\n\n  <para>\n   In order to serve multiple clients efficiently, the server launches\n   a new <quote>backend</quote> process for each client.\n   In the current implementation, a new child\n   process is created immediately after an incoming connection is detected.\n   This is transparent to the protocol, however.  For purposes of the\n   protocol, the terms <quote>backend</quote> and <quote>server</quote> are\n   interchangeable; likewise <quote>frontend</quote> and <quote>client</quote>\n   are interchangeable.\n  </para>\n\n <sect1 id=\"protocol-overview\">\n  <title>Overview</title>\n\n  <para>\n   The protocol has separate phases for startup and normal operation.\n   In the startup phase, the frontend opens a connection to the server\n   and authenticates itself to the satisfaction of the server.  (This might\n   involve a single message, or multiple messages depending on the\n   authentication method being used.)  If all goes well, the server then sends\n   status information to the frontend, and finally enters normal operation.\n   Except for the initial startup-request message, this part of the\n   protocol is driven by the server.\n  </para>\n\n  <para>\n   During normal operation, the frontend sends queries and\n   other commands to the backend, and the backend sends back query results\n   and other responses.  There are a few cases (such as <command>NOTIFY</command>)\n   wherein the\n   backend will send unsolicited messages, but for the most part this portion\n   of a session is driven by frontend requests.\n  </para>\n\n  <para>\n   Termination of the session is normally by frontend choice, but can be\n   forced by the backend in certain cases.  In any case, when the backend\n   closes the connection, it will roll back any open (incomplete) transaction\n   before exiting.\n  </para>\n\n  <para>\n   Within normal operation, SQL commands can be executed through either of\n   two sub-protocols.  In the <quote>simple query</quote> protocol, the frontend\n   just sends a textual query string, which is parsed and immediately\n   executed by the backend.  In the <quote>extended query</quote> protocol,\n   processing of queries is separated into multiple steps: parsing,\n   binding of parameter values, and execution.  This offers flexibility\n   and performance benefits, at the cost of extra complexity.\n  </para>\n\n  <para>\n   Normal operation has additional sub-protocols for special operations\n   such as <command>COPY</command>.\n  </para>\n\n <sect2 id=\"protocol-message-concepts\">\n  <title>Messaging Overview</title>\n\n  <para>\n   All communication is through a stream of messages.  The first byte of a\n   message identifies the message type, and the next four bytes specify the\n   length of the rest of the message (this length count includes itself, but\n   not the message-type byte).  The remaining contents of the message are\n   determined by the message type.  For historical reasons, the very first\n   message sent by the client (the startup message) has no initial\n   message-type byte.\n  </para>\n\n  <para>\n   To avoid losing synchronization with the message stream, both servers and\n   clients typically read an entire message into a buffer (using the byte\n   count) before attempting to process its contents.  This allows easy\n   recovery if an error is detected while processing the contents.  In\n   extreme situations (such as not having enough memory to buffer the\n   message), the receiver can use the byte count to determine how much\n   input to skip before it resumes reading messages.\n  </para>\n\n  <para>\n   Conversely, both servers and clients must take care never to send an\n   incomplete message.  This is commonly done by marshaling the entire message\n   in a buffer before beginning to send it.  If a communications failure\n   occurs partway through sending or receiving a message, the only sensible\n   response is to abandon the connection, since there is little hope of\n   recovering message-boundary synchronization.\n  </para>\n </sect2>\n\n  <sect2 id=\"protocol-query-concepts\">\n   <title>Extended Query Overview</title>\n\n   <para>\n    In the extended-query protocol, execution of SQL commands is divided\n    into multiple steps.  The state retained between steps is represented\n    by two types of objects: <firstterm>prepared statements</firstterm> and\n    <firstterm>portals</firstterm>.  A prepared statement represents the result of\n    parsing and semantic analysis of a textual query string.\n    A prepared statement is not in itself ready to execute, because it might\n    lack specific values for <firstterm>parameters</firstterm>.  A portal represents\n    a ready-to-execute or already-partially-executed statement, with any\n    missing parameter values filled in.  (For <command>SELECT</command> statements,\n    a portal is equivalent to an open cursor, but we choose to use a different\n    term since cursors don't handle non-<command>SELECT</command> statements.)\n   </para>\n\n   <para>\n    The overall execution cycle consists of a <firstterm>parse</firstterm> step,\n    which creates a prepared statement from a textual query string; a\n    <firstterm>bind</firstterm> step, which creates a portal given a prepared\n    statement and values for any needed parameters; and an\n    <firstterm>execute</firstterm> step that runs a portal's query.  In the case of\n    a query that returns rows (<command>SELECT</command>, <command>SHOW</command>, etc),\n    the execute step can be told to fetch only\n    a limited number of rows, so that multiple execute steps might be needed\n    to complete the operation.\n   </para>\n\n   <para>\n    The backend can keep track of multiple prepared statements and portals\n    (but note that these exist only within a session, and are never shared\n    across sessions).  Existing prepared statements and portals are\n    referenced by names assigned when they were created.  In addition,\n    an <quote>unnamed</quote> prepared statement and portal exist.  Although these\n    behave largely the same as named objects, operations on them are optimized\n    for the case of executing a query only once and then discarding it,\n    whereas operations on named objects are optimized on the expectation\n    of multiple uses.\n   </para>\n  </sect2>\n\n  <sect2 id=\"protocol-format-codes\">\n   <title>Formats and Format Codes</title>\n\n   <para>\n    Data of a particular data type might be transmitted in any of several\n    different <firstterm>formats</firstterm>.  As of <productname>PostgreSQL</productname> 7.4\n    the only supported formats are <quote>text</quote> and <quote>binary</quote>,\n    but the protocol makes provision for future extensions.  The desired\n    format for any value is specified by a <firstterm>format code</firstterm>.\n    Clients can specify a format code for each transmitted parameter value\n    and for each column of a query result.  Text has format code zero,\n    binary has format code one, and all other format codes are reserved\n    for future definition.\n   </para>\n\n   <para>\n    The text representation of values is whatever strings are produced\n    and accepted by the input/output conversion functions for the\n    particular data type.  In the transmitted representation, there is\n    no trailing null character; the frontend must add one to received\n    values if it wants to process them as C strings.\n    (The text format does not allow embedded nulls, by the way.)\n   </para>\n\n   <para>\n    Binary representations for integers use network byte order (most\n    significant byte first).  For other data types consult the documentation\n    or source code to learn about the binary representation.  Keep in mind\n    that binary representations for complex data types might change across\n    server versions; the text format is usually the more portable choice.\n   </para>\n  </sect2>\n </sect1>\n\n <sect1 id=\"protocol-flow\">\n  <title>Message Flow</title>\n\n  <para>\n   This section describes the message flow and the semantics of each\n   message type.  (Details of the exact representation of each message\n   appear in <xref linkend=\"protocol-message-formats\"/>.)  There are\n   several different sub-protocols depending on the state of the\n   connection: start-up, query, function call,\n   <command>COPY</command>, and termination.  There are also special\n   provisions for asynchronous operations (including notification\n   responses and command cancellation), which can occur at any time\n   after the start-up phase.\n  </para>\n\n  <sect2>\n   <title>Start-up</title>\n\n   <para>\n    To begin a session, a frontend opens a connection to the server and sends\n    a startup message.  This message includes the names of the user and of the\n    database the user wants to connect to; it also identifies the particular\n    protocol version to be used.  (Optionally, the startup message can include\n    additional settings for run-time parameters.)\n    The server then uses this information and\n    the contents of its configuration files (such as\n    <filename>pg_hba.conf</filename>) to determine\n    whether the connection is provisionally acceptable, and what additional\n    authentication is required (if any).\n   </para>\n\n   <para>\n    The server then sends an appropriate authentication request message,\n    to which the frontend must reply with an appropriate authentication\n    response message (such as a password).\n    For all authentication methods except GSSAPI, SSPI and SASL, there is at\n    most one request and one response. In some methods, no response\n    at all is needed from the frontend, and so no authentication request\n    occurs. For GSSAPI, SSPI and SASL, multiple exchanges of packets may be\n    needed to complete the authentication.\n   </para>\n\n   <para>\n    The authentication cycle ends with the server either rejecting the\n    connection attempt (ErrorResponse), or sending AuthenticationOk.\n   </para>\n\n   <para>\n    The possible messages from the server in this phase are:\n\n    <variablelist>\n     <varlistentry>\n      <term>ErrorResponse</term>\n      <listitem>\n       <para>\n        The connection attempt has been rejected.\n        The server then immediately closes the connection.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationOk</term>\n      <listitem>\n       <para>\n        The authentication exchange is successfully completed.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationKerberosV5</term>\n      <listitem>\n       <para>\n        The frontend must now take part in a Kerberos V5\n        authentication dialog (not described here, part of the\n        Kerberos specification) with the server.  If this is\n        successful, the server responds with an AuthenticationOk,\n        otherwise it responds with an ErrorResponse. This is no\n        longer supported.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationCleartextPassword</term>\n      <listitem>\n       <para>\n        The frontend must now send a PasswordMessage containing the\n        password in clear-text form.  If\n        this is the correct password, the server responds with an\n        AuthenticationOk, otherwise it responds with an ErrorResponse.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationMD5Password</term>\n      <listitem>\n       <para>\n        The frontend must now send a PasswordMessage containing the\n        password (with user name) encrypted via MD5, then encrypted\n        again using the 4-byte random salt specified in the\n        AuthenticationMD5Password message.  If this is the correct\n        password, the server responds with an AuthenticationOk,\n        otherwise it responds with an ErrorResponse.  The actual\n        PasswordMessage can be computed in SQL as <literal>concat('md5',\n        md5(concat(md5(concat(password, username)), random-salt)))</literal>.\n        (Keep in mind the <function>md5()</function> function returns its\n        result as a hex string.)\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSCMCredential</term>\n      <listitem>\n       <para>\n        This response is only possible for local Unix-domain connections\n        on platforms that support SCM credential messages.  The frontend\n        must issue an SCM credential message and then send a single data\n        byte.  (The contents of the data byte are uninteresting; it's\n        only used to ensure that the server waits long enough to receive\n        the credential message.)  If the credential is acceptable,\n        the server responds with an\n        AuthenticationOk, otherwise it responds with an ErrorResponse.\n        (This message type is only issued by pre-9.1 servers.  It may\n        eventually be removed from the protocol specification.)\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationGSS</term>\n      <listitem>\n       <para>\n        The frontend must now initiate a GSSAPI negotiation. The frontend\n        will send a GSSResponse message with the first part of the GSSAPI\n        data stream in response to this. If further messages are needed,\n        the server will respond with AuthenticationGSSContinue.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSSPI</term>\n      <listitem>\n       <para>\n        The frontend must now initiate an SSPI negotiation. The frontend\n        will send a GSSResponse with the first part of the SSPI\n        data stream in response to this. If further messages are needed,\n        the server will respond with AuthenticationGSSContinue.\n       </para>\n      </listitem>\n\n     </varlistentry>\n     <varlistentry>\n      <term>AuthenticationGSSContinue</term>\n      <listitem>\n       <para>\n        This message contains the response data from the previous step\n        of GSSAPI or SSPI negotiation (AuthenticationGSS, AuthenticationSSPI\n        or a previous AuthenticationGSSContinue). If the GSSAPI\n        or SSPI data in this message\n        indicates more data is needed to complete the authentication,\n        the frontend must send that data as another GSSResponse message. If\n        GSSAPI or SSPI authentication is completed by this message, the server\n        will next send AuthenticationOk to indicate successful authentication\n        or ErrorResponse to indicate failure.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSASL</term>\n      <listitem>\n       <para>\n        The frontend must now initiate a SASL negotiation, using one of the\n        SASL mechanisms listed in the message. The frontend will send a\n        SASLInitialResponse with the name of the selected mechanism, and the\n        first part of the SASL data stream in response to this. If further\n        messages are needed, the server will respond with\n        AuthenticationSASLContinue. See <xref linkend=\"sasl-authentication\"/>\n        for details.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSASLContinue</term>\n      <listitem>\n       <para>\n        This message contains challenge data from the previous step of SASL\n        negotiation (AuthenticationSASL, or a previous\n        AuthenticationSASLContinue). The frontend must respond with a\n        SASLResponse message.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>AuthenticationSASLFinal</term>\n      <listitem>\n       <para>\n        SASL authentication has completed with additional mechanism-specific\n        data for the client. The server will next send AuthenticationOk to\n        indicate successful authentication, or an ErrorResponse to indicate\n        failure. This message is sent only if the SASL mechanism specifies\n        additional data to be sent from server to client at completion.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>NegotiateProtocolVersion</term>\n      <listitem>\n       <para>\n        The server does not support the minor protocol version requested\n        by the client, but does support an earlier version of the protocol;\n        this message indicates the highest supported minor version.  This\n        message will also be sent if the client requested unsupported protocol\n        options (i.e., beginning with <literal>_pq_.</literal>) in the\n        startup packet.  This message will be followed by an ErrorResponse or\n        a message indicating the success or failure of authentication.\n       </para>\n      </listitem>\n     </varlistentry>\n\n    </variablelist>\n   </para>\n\n   <para>\n    If the frontend does not support the authentication method\n    requested by the server, then it should immediately close the\n    connection.\n   </para>\n\n   <para>\n    After having received AuthenticationOk, the frontend must wait\n    for further messages from the server.  In this phase a backend process\n    is being started, and the frontend is just an interested bystander.\n    It is still possible for the startup attempt\n    to fail (ErrorResponse) or the server to decline support for the requested\n    minor protocol version (NegotiateProtocolVersion), but in the normal case\n    the backend will send some ParameterStatus messages, BackendKeyData, and\n    finally ReadyForQuery.\n   </para>\n\n   <para>\n    During this phase the backend will attempt to apply any additional\n    run-time parameter settings that were given in the startup message.\n    If successful, these values become session defaults.  An error causes\n    ErrorResponse and exit.\n   </para>\n\n   <para>\n    The possible messages from the backend in this phase are:\n\n    <variablelist>\n     <varlistentry>\n      <term>BackendKeyData</term>\n      <listitem>\n       <para>\n        This message provides secret-key data that the frontend must\n        save if it wants to be able to issue cancel requests later.\n        The frontend should not respond to this message, but should\n        continue listening for a ReadyForQuery message.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ParameterStatus</term>\n      <listitem>\n       <para>\n        This message informs the frontend about the current (initial)\n         setting of backend parameters, such as <xref\n         linkend=\"guc-client-encoding\"/> or <xref linkend=\"guc-datestyle\"/>.\n         The frontend can ignore this message, or record the settings\n         for its future use; see <xref linkend=\"protocol-async\"/> for\n         more details.  The frontend should not respond to this\n         message, but should continue listening for a ReadyForQuery\n         message.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ReadyForQuery</term>\n      <listitem>\n       <para>\n        Start-up is completed.  The frontend can now issue commands.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ErrorResponse</term>\n      <listitem>\n       <para>\n        Start-up failed.  The connection is closed after sending this\n        message.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>NoticeResponse</term>\n      <listitem>\n       <para>\n        A warning message has been issued.  The frontend should\n        display the message but continue listening for ReadyForQuery\n        or ErrorResponse.\n       </para>\n      </listitem>\n     </varlistentry>\n    </variablelist>\n   </para>\n\n   <para>\n    The ReadyForQuery message is the same one that the backend will\n    issue after each command cycle.  Depending on the coding needs of\n    the frontend, it is reasonable to consider ReadyForQuery as\n    starting a command cycle, or to consider ReadyForQuery as ending the\n    start-up phase and each subsequent command cycle.\n   </para>\n  </sect2>\n\n  <sect2>\n   <title>Simple Query</title>\n\n   <para>\n    A simple query cycle is initiated by the frontend sending a Query message\n    to the backend.  The message includes an SQL command (or commands)\n    expressed as a text string.\n    The backend then sends one or more response\n    messages depending on the contents of the query command string,\n    and finally a ReadyForQuery response message.  ReadyForQuery\n    informs the frontend that it can safely send a new command.\n    (It is not actually necessary for the frontend to wait for\n    ReadyForQuery before issuing another command, but the frontend must\n    then take responsibility for figuring out what happens if the earlier\n    command fails and already-issued later commands succeed.)\n   </para>\n\n   <para>\n    The possible response messages from the backend are:\n\n    <variablelist>\n     <varlistentry>\n      <term>CommandComplete</term>\n      <listitem>\n       <para>\n        An SQL command completed normally.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>CopyInResponse</term>\n      <listitem>\n       <para>\n        The backend is ready to copy data from the frontend to a\n        table; see <xref linkend=\"protocol-copy\"/>.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>CopyOutResponse</term>\n      <listitem>\n       <para>\n        The backend is ready to copy data from a table to the\n        frontend; see <xref linkend=\"protocol-copy\"/>.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>RowDescription</term>\n      <listitem>\n       <para>\n        Indicates that rows are about to be returned in response to\n        a <command>SELECT</command>, <command>FETCH</command>, etc query.\n        The contents of this message describe the column layout of the rows.\n        This will be followed by a DataRow message for each row being returned\n        to the frontend.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>DataRow</term>\n      <listitem>\n       <para>\n        One of the set of rows returned by\n        a <command>SELECT</command>, <command>FETCH</command>, etc query.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>EmptyQueryResponse</term>\n      <listitem>\n       <para>\n        An empty query string was recognized.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ErrorResponse</term>\n      <listitem>\n       <para>\n        An error has occurred.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ReadyForQuery</term>\n      <listitem>\n       <para>\n        Processing of the query string is complete.  A separate\n        message is sent to indicate this because the query string might\n        contain multiple SQL commands.  (CommandComplete marks the\n        end of processing one SQL command, not the whole string.)\n        ReadyForQuery will always be sent, whether processing\n        terminates successfully or with an error.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>NoticeResponse</term>\n      <listitem>\n       <para>\n        A warning message has been issued in relation to the query.\n        Notices are in addition to other responses, i.e., the backend\n        will continue processing the command.\n       </para>\n      </listitem>\n     </varlistentry>\n\n    </variablelist>\n   </para>\n\n   <para>\n    The response to a <command>SELECT</command> query (or other queries that\n    return row sets, such as <command>EXPLAIN</command> or <command>SHOW</command>)\n    normally consists of RowDescription, zero or more\n    DataRow messages, and then CommandComplete.\n    <command>COPY</command> to or from the frontend invokes special protocol\n    as described in <xref linkend=\"protocol-copy\"/>.\n    All other query types normally produce only\n    a CommandComplete message.\n   </para>\n\n   <para>\n    Since a query string could contain several queries (separated by\n    semicolons), there might be several such response sequences before the\n    backend finishes processing the query string.  ReadyForQuery is issued\n    when the entire string has been processed and the backend is ready to\n    accept a new query string.\n   </para>\n\n   <para>\n    If a completely empty (no contents other than whitespace) query string\n    is received, the response is EmptyQueryResponse followed by ReadyForQuery.\n   </para>\n\n   <para>\n    In the event of an error, ErrorResponse is issued followed by\n    ReadyForQuery.  All further processing of the query string is aborted by\n    ErrorResponse (even if more queries remained in it).  Note that this\n    might occur partway through the sequence of messages generated by an\n    individual query.\n   </para>\n\n   <para>\n    In simple Query mode, the format of retrieved values is always text,\n    except when the given command is a <command>FETCH</command> from a cursor\n    declared with the <literal>BINARY</literal> option.  In that case, the\n    retrieved values are in binary format.  The format codes given in\n    the RowDescription message tell which format is being used.\n   </para>\n\n   <para>\n    A frontend must be prepared to accept ErrorResponse and\n    NoticeResponse messages whenever it is expecting any other type of\n    message.  See also <xref linkend=\"protocol-async\"/> concerning messages\n    that the backend might generate due to outside events.\n   </para>\n\n   <para>\n    Recommended practice is to code frontends in a state-machine style\n    that will accept any message type at any time that it could make sense,\n    rather than wiring in assumptions about the exact sequence of messages.\n   </para>\n\n   <sect3 id=\"protocol-flow-multi-statement\">\n    <title>Multiple Statements in a Simple Query</title>\n\n    <para>\n     When a simple Query message contains more than one SQL statement\n     (separated by semicolons), those statements are executed as a single\n     transaction, unless explicit transaction control commands are included\n     to force a different behavior.  For example, if the message contains\n<programlisting>\nINSERT INTO mytable VALUES(1);\nSELECT 1/0;\nINSERT INTO mytable VALUES(2);\n</programlisting>\n     then the divide-by-zero failure in the <command>SELECT</command> will force\n     rollback of the first <command>INSERT</command>.  Furthermore, because\n     execution of the message is abandoned at the first error, the second\n     <command>INSERT</command> is never attempted at all.\n    </para>\n\n    <para>\n     If instead the message contains\n<programlisting>\nBEGIN;\nINSERT INTO mytable VALUES(1);\nCOMMIT;\nINSERT INTO mytable VALUES(2);\nSELECT 1/0;\n</programlisting>\n     then the first <command>INSERT</command> is committed by the\n     explicit <command>COMMIT</command> command.  The second <command>INSERT</command>\n     and the <command>SELECT</command> are still treated as a single transaction,\n     so that the divide-by-zero failure will roll back the\n     second <command>INSERT</command>, but not the first one.\n    </para>\n\n    <para>\n     This behavior is implemented by running the statements in a\n     multi-statement Query message in an <firstterm>implicit transaction\n     block</firstterm> unless there is some explicit transaction block for them to\n     run in.  The main difference between an implicit transaction block and\n     a regular one is that an implicit block is closed automatically at the\n     end of the Query message, either by an implicit commit if there was no\n     error, or an implicit rollback if there was an error.  This is similar\n     to the implicit commit or rollback that happens for a statement\n     executed by itself (when not in a transaction block).\n    </para>\n\n    <para>\n     If the session is already in a transaction block, as a result of\n     a <command>BEGIN</command> in some previous message, then the Query message\n     simply continues that transaction block, whether the message contains\n     one statement or several.  However, if the Query message contains\n     a <command>COMMIT</command> or <command>ROLLBACK</command> closing the existing\n     transaction block, then any following statements are executed in an\n     implicit transaction block.\n     Conversely, if a <command>BEGIN</command> appears in a multi-statement Query\n     message, then it starts a regular transaction block that will only be\n     terminated by an explicit <command>COMMIT</command> or <command>ROLLBACK</command>,\n     whether that appears in this Query message or a later one.\n     If the <command>BEGIN</command> follows some statements that were executed as\n     an implicit transaction block, those statements are not immediately\n     committed; in effect, they are retroactively included into the new\n     regular transaction block.\n    </para>\n\n    <para>\n     A <command>COMMIT</command> or <command>ROLLBACK</command> appearing in an implicit\n     transaction block is executed as normal, closing the implicit block;\n     however, a warning will be issued since a <command>COMMIT</command>\n     or <command>ROLLBACK</command> without a previous <command>BEGIN</command> might\n     represent a mistake.  If more statements follow, a new implicit\n     transaction block will be started for them.\n    </para>\n\n    <para>\n     Savepoints are not allowed in an implicit transaction block, since\n     they would conflict with the behavior of automatically closing the\n     block upon any error.\n    </para>\n\n    <para>\n     Remember that, regardless of any transaction control commands that may\n     be present, execution of the Query message stops at the first error.\n     Thus for example given\n<programlisting>\nBEGIN;\nSELECT 1/0;\nROLLBACK;\n</programlisting>\n     in a single Query message, the session will be left inside a failed\n     regular transaction block, since the <command>ROLLBACK</command> is not\n     reached after the divide-by-zero error.  Another <command>ROLLBACK</command>\n     will be needed to restore the session to a usable state.\n    </para>\n\n    <para>\n     Another behavior of note is that initial lexical and syntactic\n     analysis is done on the entire query string before any of it is\n     executed.  Thus simple errors (such as a misspelled keyword) in later\n     statements can prevent execution of any of the statements.  This\n     is normally invisible to users since the statements would all roll\n     back anyway when done as an implicit transaction block.  However,\n     it can be visible when attempting to do multiple transactions within a\n     multi-statement Query.  For instance, if a typo turned our previous\n     example into\n<programlisting>\nBEGIN;\nINSERT INTO mytable VALUES(1);\nCOMMIT;\nINSERT INTO mytable VALUES(2);\nSELCT 1/0;<!-- this typo is intentional -->\n</programlisting>\n     then none of the statements would get run, resulting in the visible\n     difference that the first <command>INSERT</command> is not committed.\n     Errors detected at semantic analysis or later, such as a misspelled\n     table or column name, do not have this effect.\n    </para>\n   </sect3>\n  </sect2>\n\n  <sect2 id=\"protocol-flow-ext-query\">\n   <title>Extended Query</title>\n\n   <para>\n    The extended query protocol breaks down the above-described simple\n    query protocol into multiple steps.  The results of preparatory\n    steps can be re-used multiple times for improved efficiency.\n    Furthermore, additional features are available, such as the possibility\n    of supplying data values as separate parameters instead of having to\n    insert them directly into a query string.\n   </para>\n\n   <para>\n    In the extended protocol, the frontend first sends a Parse message,\n    which contains a textual query string, optionally some information\n    about data types of parameter placeholders, and the\n    name of a destination prepared-statement object (an empty string\n    selects the unnamed prepared statement).  The response is\n    either ParseComplete or ErrorResponse.  Parameter data types can be\n    specified by OID; if not given, the parser attempts to infer the\n    data types in the same way as it would do for untyped literal string\n    constants.\n   </para>\n\n   <note>\n    <para>\n     A parameter data type can be left unspecified by setting it to zero,\n     or by making the array of parameter type OIDs shorter than the\n     number of parameter symbols (<literal>$</literal><replaceable>n</replaceable>)\n     used in the query string.  Another special case is that a parameter's\n     type can be specified as <type>void</type> (that is, the OID of the\n     <type>void</type> pseudo-type).  This is meant to allow parameter symbols\n     to be used for function parameters that are actually OUT parameters.\n     Ordinarily there is no context in which a <type>void</type> parameter\n     could be used, but if such a parameter symbol appears in a function's\n     parameter list, it is effectively ignored.  For example, a function\n     call such as <literal>foo($1,$2,$3,$4)</literal> could match a function with\n     two IN and two OUT arguments, if <literal>$3</literal> and <literal>$4</literal>\n     are specified as having type <type>void</type>.\n    </para>\n   </note>\n\n   <note>\n    <para>\n     The query string contained in a Parse message cannot include more\n     than one SQL statement; else a syntax error is reported.  This\n     restriction does not exist in the simple-query protocol, but it\n     does exist in the extended protocol, because allowing prepared\n     statements or portals to contain multiple commands would complicate\n     the protocol unduly.\n    </para>\n   </note>\n\n   <para>\n    If successfully created, a named prepared-statement object lasts till\n    the end of the current session, unless explicitly destroyed.  An unnamed\n    prepared statement lasts only until the next Parse statement specifying\n    the unnamed statement as destination is issued.  (Note that a simple\n    Query message also destroys the unnamed statement.)  Named prepared\n    statements must be explicitly closed before they can be redefined by\n    another Parse message, but this is not required for the unnamed statement.\n    Named prepared statements can also be created and accessed at the SQL\n    command level, using <command>PREPARE</command> and <command>EXECUTE</command>.\n   </para>\n\n   <para>\n    Once a prepared statement exists, it can be readied for execution using a\n    Bind message.  The Bind message gives the name of the source prepared\n    statement (empty string denotes the unnamed prepared statement), the name\n    of the destination portal (empty string denotes the unnamed portal), and\n    the values to use for any parameter placeholders present in the prepared\n    statement.  The\n    supplied parameter set must match those needed by the prepared statement.\n    (If you declared any <type>void</type> parameters in the Parse message,\n    pass NULL values for them in the Bind message.)\n    Bind also specifies the format to use for any data returned\n    by the query; the format can be specified overall, or per-column.\n    The response is either BindComplete or ErrorResponse.\n   </para>\n\n   <note>\n    <para>\n     The choice between text and binary output is determined by the format\n     codes given in Bind, regardless of the SQL command involved.  The\n     <literal>BINARY</literal> attribute in cursor declarations is irrelevant when\n     using extended query protocol.\n    </para>\n   </note>\n\n   <para>\n    Query planning typically occurs when the Bind message is processed.\n    If the prepared statement has no parameters, or is executed repeatedly,\n    the server might save the created plan and re-use it during subsequent\n    Bind messages for the same prepared statement.  However, it will do so\n    only if it finds that a generic plan can be created that is not much\n    less efficient than a plan that depends on the specific parameter values\n    supplied.  This happens transparently so far as the protocol is concerned.\n   </para>\n\n   <para>\n    If successfully created, a named portal object lasts till the end of the\n    current transaction, unless explicitly destroyed.  An unnamed portal is\n    destroyed at the end of the transaction, or as soon as the next Bind\n    statement specifying the unnamed portal as destination is issued.  (Note\n    that a simple Query message also destroys the unnamed portal.)  Named\n    portals must be explicitly closed before they can be redefined by another\n    Bind message, but this is not required for the unnamed portal.\n    Named portals can also be created and accessed at the SQL\n    command level, using <command>DECLARE CURSOR</command> and <command>FETCH</command>.\n   </para>\n\n   <para>\n    Once a portal exists, it can be executed using an Execute message.\n    The Execute message specifies the portal name (empty string denotes the\n    unnamed portal) and\n    a maximum result-row count (zero meaning <quote>fetch all rows</quote>).\n    The result-row count is only meaningful for portals\n    containing commands that return row sets; in other cases the command is\n    always executed to completion, and the row count is ignored.\n    The possible\n    responses to Execute are the same as those described above for queries\n    issued via simple query protocol, except that Execute doesn't cause\n    ReadyForQuery or RowDescription to be issued.\n   </para>\n\n   <para>\n    If Execute terminates before completing the execution of a portal\n    (due to reaching a nonzero result-row count), it will send a\n    PortalSuspended message; the appearance of this message tells the frontend\n    that another Execute should be issued against the same portal to\n    complete the operation.  The CommandComplete message indicating\n    completion of the source SQL command is not sent until\n    the portal's execution is completed.  Therefore, an Execute phase is\n    always terminated by the appearance of exactly one of these messages:\n    CommandComplete, EmptyQueryResponse (if the portal was created from\n    an empty query string), ErrorResponse, or PortalSuspended.\n   </para>\n\n   <para>\n    At completion of each series of extended-query messages, the frontend\n    should issue a Sync message.  This parameterless message causes the\n    backend to close the current transaction if it's not inside a\n    <command>BEGIN</command>/<command>COMMIT</command> transaction block (<quote>close</quote>\n    meaning to commit if no error, or roll back if error).  Then a\n    ReadyForQuery response is issued.  The purpose of Sync is to provide\n    a resynchronization point for error recovery.  When an error is detected\n    while processing any extended-query message, the backend issues\n    ErrorResponse, then reads and discards messages until a Sync is reached,\n    then issues ReadyForQuery and returns to normal message processing.\n    (But note that no skipping occurs if an error is detected\n    <emphasis>while</emphasis> processing Sync &mdash; this ensures that there is one\n    and only one ReadyForQuery sent for each Sync.)\n   </para>\n\n   <note>\n    <para>\n     Sync does not cause a transaction block opened with <command>BEGIN</command>\n     to be closed.  It is possible to detect this situation since the\n     ReadyForQuery message includes transaction status information.\n    </para>\n   </note>\n\n   <para>\n    In addition to these fundamental, required operations, there are several\n    optional operations that can be used with extended-query protocol.\n   </para>\n\n   <para>\n    The Describe message (portal variant) specifies the name of an existing\n    portal (or an empty string for the unnamed portal).  The response is a\n    RowDescription message describing the rows that will be returned by\n    executing the portal; or a NoData message if the portal does not contain a\n    query that will return rows; or ErrorResponse if there is no such portal.\n   </para>\n\n   <para>\n    The Describe message (statement variant) specifies the name of an existing\n    prepared statement (or an empty string for the unnamed prepared\n    statement).  The response is a ParameterDescription message describing the\n    parameters needed by the statement, followed by a RowDescription message\n    describing the rows that will be returned when the statement is eventually\n    executed (or a NoData message if the statement will not return rows).\n    ErrorResponse is issued if there is no such prepared statement.  Note that\n    since Bind has not yet been issued, the formats to be used for returned\n    columns are not yet known to the backend; the format code fields in the\n    RowDescription message will be zeroes in this case.\n   </para>\n\n   <tip>\n    <para>\n     In most scenarios the frontend should issue one or the other variant\n     of Describe before issuing Execute, to ensure that it knows how to\n     interpret the results it will get back.\n    </para>\n   </tip>\n\n   <para>\n    The Close message closes an existing prepared statement or portal\n    and releases resources.  It is not an error to issue Close against\n    a nonexistent statement or portal name.  The response is normally\n    CloseComplete, but could be ErrorResponse if some difficulty is\n    encountered while releasing resources.  Note that closing a prepared\n    statement implicitly closes any open portals that were constructed\n    from that statement.\n   </para>\n\n   <para>\n    The Flush message does not cause any specific output to be generated,\n    but forces the backend to deliver any data pending in its output\n    buffers.  A Flush must be sent after any extended-query command except\n    Sync, if the frontend wishes to examine the results of that command before\n    issuing more commands.  Without Flush, messages returned by the backend\n    will be combined into the minimum possible number of packets to minimize\n    network overhead.\n   </para>\n\n   <note>\n    <para>\n     The simple Query message is approximately equivalent to the series Parse,\n     Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared\n     statement and portal objects and no parameters.  One difference is that\n     it will accept multiple SQL statements in the query string, automatically\n     performing the bind/describe/execute sequence for each one in succession.\n     Another difference is that it will not return ParseComplete, BindComplete,\n     CloseComplete, or NoData messages.\n    </para>\n   </note>\n  </sect2>\n\n  <sect2>\n   <title>Function Call</title>\n\n   <para>\n    The Function Call sub-protocol allows the client to request a direct\n    call of any function that exists in the database's\n    <structname>pg_proc</structname> system catalog.  The client must have\n    execute permission for the function.\n   </para>\n\n   <note>\n    <para>\n     The Function Call sub-protocol is a legacy feature that is probably best\n     avoided in new code.  Similar results can be accomplished by setting up\n     a prepared statement that does <literal>SELECT function($1, ...)</literal>.\n     The Function Call cycle can then be replaced with Bind/Execute.\n    </para>\n   </note>\n\n   <para>\n    A Function Call cycle is initiated by the frontend sending a\n    FunctionCall message to the backend.  The backend then sends one\n    or more response messages depending on the results of the function\n    call, and finally a ReadyForQuery response message.  ReadyForQuery\n    informs the frontend that it can safely send a new query or\n    function call.\n   </para>\n\n   <para>\n    The possible response messages from the backend are:\n\n    <variablelist>\n     <varlistentry>\n      <term>ErrorResponse</term>\n      <listitem>\n       <para>\n        An error has occurred.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>FunctionCallResponse</term>\n      <listitem>\n       <para>\n        The function call was completed and returned the result given\n        in the message.\n        (Note that the Function Call protocol can only handle a single\n        scalar result, not a row type or set of results.)\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>ReadyForQuery</term>\n      <listitem>\n       <para>\n        Processing of the function call is complete.  ReadyForQuery\n        will always be sent, whether processing terminates\n        successfully or with an error.\n       </para>\n      </listitem>\n     </varlistentry>\n\n     <varlistentry>\n      <term>NoticeResponse</term>\n      <listitem>\n       <para>\n        A warning message has been issued in relation to the function\n        call.  Notices are in addition to other responses, i.e., the\n        backend will continue processing the command.\n       </para>\n      </listitem>\n     </varlistentry>\n    </variablelist>\n   </para>\n  </sect2>\n\n  <sect2 id=\"protocol-copy\">\n   <title>COPY Operations</title>\n\n   <para>\n    The <command>COPY</command> command allows high-speed bulk data transfer\n    to or from the server.  Copy-in and copy-out operations each switch\n    the connection into a distinct sub-protocol, which lasts until the\n    operation is completed.\n   </para>\n\n   <para>\n    Copy-in mode (data transfer to the server) is initiated when the\n    backend executes a <command>COPY FROM STDIN</command> SQL statement.  The backend\n    sends a CopyInResponse message to the frontend.  The frontend should\n    then send zero or more CopyData messages, forming a stream of input\n    data.  (The message boundaries are not required to have anything to do\n    with row boundaries, although that is often a reasonable choice.)\n    The frontend can terminate the copy-in mode by sending either a CopyDone\n    message (allowing successful termination) or a CopyFail message (which\n    will cause the <command>COPY</command> SQL statement to fail with an\n    error).  The backend then reverts to the command-processing mode it was\n    in before the <command>COPY</command> started, which will be either simple or\n    extended query protocol.  It will next send either CommandComplete\n    (if successful) or ErrorResponse (if not).\n   </para>\n\n   <para>\n    In the event of a backend-detected error during copy-in mode (including\n    receipt of a CopyFail message), the backend will issue an ErrorResponse\n    message.  If the <command>COPY</command> command was issued via an extended-query\n    message, the backend will now discard frontend messages until a Sync\n    message is received, then it will issue ReadyForQuery and return to normal\n    processing.  If the <command>COPY</command> command was issued in a simple\n    Query message, the rest of that message is discarded and ReadyForQuery\n    is issued.  In either case, any subsequent CopyData, CopyDone, or CopyFail\n    messages issued by the frontend will simply be dropped.\n   </para>\n\n   <para>\n    The backend will ignore Flush and Sync messages received during copy-in\n    mode.  Receipt of any other non-copy message type constitutes an error\n    that will abort the copy-in state as described above.  (The exception for\n    Flush and Sync is for the convenience of client libraries that always\n    send Flush or Sync after an Execute message, without checking whether\n    the command to be executed is a <command>COPY FROM STDIN</command>.)\n   </para>\n\n   <para>\n    Copy-out mode (data transfer from the server) is initiated when the\n    backend executes a <command>COPY TO STDOUT</command> SQL statement.  The backend\n    sends a CopyOutResponse message to the frontend, followed by\n    zero or more CopyData messages (always one per row), followed by CopyDone.\n    The backend then reverts to the command-processing mode it was\n    in before the <command>COPY</command> started, and sends CommandComplete.\n    The frontend cannot abort the transfer (except by closing the connection\n    or issuing a Cancel request),\n    but it can discard unwanted CopyData and CopyDone messages.\n   </para>\n\n   <para>\n    In the event of a backend-detected error during copy-out mode,\n    the backend will issue an ErrorResponse message and revert to normal\n    processing.  The frontend should treat receipt of ErrorResponse as\n    terminating the copy-out mode.\n   </para>\n\n   <para>\n    It is possible for NoticeResponse and ParameterStatus messages to be\n    interspersed between CopyData messages; frontends must handle these cases,\n    and should be prepared for other asynchronous message types as well (see\n    <xref linkend=\"protocol-async\"/>).  Otherwise, any message type other than\n    CopyData or CopyDone may be treated as terminating copy-out mode.\n   </para>\n\n   <para>\n    There is another Copy-related mode called copy-both, which allows\n    high-speed bulk data transfer to <emphasis>and</emphasis> from the server.\n    Copy-both mode is initiated when a backend in walsender mode\n    executes a <command>START_REPLICATION</command> statement.  The\n    backend sends a CopyBothResponse message to the frontend.  Both\n    the backend and the frontend may then send CopyData messages\n    until either end sends a CopyDone message. After the client\n    sends a CopyDone message, the connection goes from copy-both mode to\n    copy-out mode, and the client may not send any more CopyData messages.\n    Similarly, when the server sends a CopyDone message, the connection\n    goes into copy-in mode, and the server may not send any more CopyData\n    messages. After both sides have sent a CopyDone message, the copy mode\n    is terminated, and the backend reverts to the command-processing mode.\n    In the event of a backend-detected error during copy-both mode,\n    the backend will issue an ErrorResponse message, discard frontend messages\n    until a Sync message is received, and then issue ReadyForQuery and return\n    to normal processing.  The frontend should treat receipt of ErrorResponse\n    as terminating the copy in both directions; no CopyDone should be sent\n    in this case.  See <xref linkend=\"protocol-replication\"/> for more\n    information on the subprotocol transmitted over copy-both mode.\n   </para>\n\n   <para>\n    The CopyInResponse, CopyOutResponse and CopyBothResponse messages\n    include fields that inform the frontend of the number of columns\n    per row and the format codes being used for each column.  (As of\n    the present implementation, all columns in a given <command>COPY</command>\n    operation will use the same format, but the message design does not\n    assume this.)\n   </para>\n\n  </sect2>\n\n  <sect2 id=\"protocol-async\">\n   <title>Asynchronous Operations</title>\n\n   <para>\n    There are several cases in which the backend will send messages that\n    are not specifically prompted by the frontend's command stream.\n    Frontends must be prepared to deal with these messages at any time,\n    even when not engaged in a query.\n    At minimum, one should check for these cases before beginning to\n    read a query response.\n   </para>\n\n   <para>\n    It is possible for NoticeResponse messages to be generated due to\n    outside activity; for example, if the database administrator commands\n    a <quote>fast</quote> database shutdown, the backend will send a NoticeResponse\n    indicating this fact before closing the connection.  Accordingly,\n    frontends should always be prepared to accept and display NoticeResponse\n    messages, even when the connection is nominally idle.\n   </para>\n\n   <para>\n    ParameterStatus messages will be generated whenever the active\n    value changes for any of the parameters the backend believes the\n    frontend should know about.  Most commonly this occurs in response\n    to a <command>SET</command> SQL command executed by the frontend, and\n    this case is effectively synchronous &mdash; but it is also possible\n    for parameter status changes to occur because the administrator\n    changed a configuration file and then sent the\n    <systemitem>SIGHUP</systemitem> signal to the server.  Also,\n    if a <command>SET</command> command is rolled back, an appropriate\n    ParameterStatus message will be generated to report the current\n    effective value.\n   </para>\n\n   <para>\n    At present there is a hard-wired set of parameters for which\n    ParameterStatus will be generated: they are\n    <varname>server_version</varname>,\n    <varname>server_encoding</varname>,\n    <varname>client_encoding</varname>,\n    <varname>application_name</varname>,\n    <varname>default_transaction_read_only</varname>,\n    <varname>in_hot_standby</varname>,\n    <varname>is_superuser</varname>,\n    <varname>session_authorization</varname>,\n    <varname>DateStyle</varname>,\n    <varname>IntervalStyle</varname>,\n    <varname>TimeZone</varname>,\n    <varname>integer_datetimes</varname>, and\n    <varname>standard_conforming_strings</varname>.\n    (<varname>server_encoding</varname>, <varname>TimeZone</varname>, and\n    <varname>integer_datetimes</varname> were not reported by releases before 8.0;\n    <varname>standard_conforming_strings</varname> was not reported by releases\n    before 8.1;\n    <varname>IntervalStyle</varname> was not reported by releases before 8.4;\n    <varname>application_name</varname> was not reported by releases before\n    9.0;\n    <varname>default_transaction_read_only</varname> and\n    <varname>in_hot_standby</varname> were not reported by releases before\n    14.)\n    Note that\n    <varname>server_version</varname>,\n    <varname>server_encoding</varname> and\n    <varname>integer_datetimes</varname>\n    are pseudo-parameters that cannot change after startup.\n    This set might change in the future, or even become configurable.\n    Accordingly, a frontend should simply ignore ParameterStatus for\n    parameters that it does not understand or care about.\n   </para>\n\n   <para>\n    If a frontend issues a <command>LISTEN</command> command, then the\n    backend will send a NotificationResponse message (not to be\n    confused with NoticeResponse!)  whenever a\n    <command>NOTIFY</command> command is executed for the same\n    channel name.\n   </para>\n\n   <note>\n    <para>\n     At present, NotificationResponse can only be sent outside a\n     transaction, and thus it will not occur in the middle of a\n     command-response series, though it might occur just before ReadyForQuery.\n     It is unwise to design frontend logic that assumes that, however.\n     Good practice is to be able to accept NotificationResponse at any\n     point in the protocol.\n    </para>\n   </note>\n  </sect2>\n\n  <sect2>\n   <title>Canceling Requests in Progress</title>\n\n   <para>\n    During the processing of a query, the frontend might request\n    cancellation of the query.  The cancel request is not sent\n    directly on the open connection to the backend for reasons of\n    implementation efficiency: we don't want to have the backend\n    constantly checking for new input from the frontend during query\n    processing.  Cancel requests should be relatively infrequent, so\n    we make them slightly cumbersome in order to avoid a penalty in\n    the normal case.\n   </para>\n\n   <para>\n    To issue a cancel request, the frontend opens a new connection to\n    the server and sends a CancelRequest message, rather than the\n    StartupMessage message that would ordinarily be sent across a new\n    connection.  The server will process this request and then close\n    the connection.  For security reasons, no direct reply is made to\n    the cancel request message.\n   </para>\n\n   <para>\n    A CancelRequest message will be ignored unless it contains the\n    same key data (PID and secret key) passed to the frontend during\n    connection start-up.  If the request matches the PID and secret\n    key for a currently executing backend, the processing of the\n    current query is aborted.  (In the existing implementation, this is\n    done by sending a special signal to the backend process that is\n    processing the query.)\n   </para>\n\n   <para>\n    The cancellation signal might or might not have any effect &mdash; for\n    example, if it arrives after the backend has finished processing\n    the query, then it will have no effect.  If the cancellation is\n    effective, it results in the current command being terminated\n    early with an error message.\n   </para>\n\n   <para>\n    The upshot of all this is that for reasons of both security and\n    efficiency, the frontend has no direct way to tell whether a\n    cancel request has succeeded.  It must continue to wait for the\n    backend to respond to the query.  Issuing a cancel simply improves\n    the odds that the current query will finish soon, and improves the\n    odds that it will fail with an error message instead of\n    succeeding.\n   </para>\n\n   <para>\n    Since the cancel request is sent across a new connection to the\n    server and not across the regular frontend/backend communication\n    link, it is possible for the cancel request to be issued by any\n    process, not just the frontend whose query is to be canceled.\n    This might provide additional flexibility when building\n    multiple-process applications.  It also introduces a security\n    risk, in that unauthorized persons might try to cancel queries.\n    The security risk is addressed by requiring a dynamically\n    generated secret key to be supplied in cancel requests.\n   </para>\n  </sect2>\n\n  <sect2>\n   <title>Termination</title>\n\n   <para>\n    The normal, graceful termination procedure is that the frontend\n    sends a Terminate message and immediately closes the connection.\n    On receipt of this message, the backend closes the connection and\n    terminates.\n   </para>\n\n   <para>\n    In rare cases (such as an administrator-commanded database shutdown)\n    the backend might disconnect without any frontend request to do so.\n    In such cases the backend will attempt to send an error or notice message\n    giving the reason for the disconnection before it closes the connection.\n   </para>\n\n   <para>\n    Other termination scenarios arise from various failure cases, such as core\n    dump at one end or the other, loss of the communications link, loss of\n    message-boundary synchronization, etc.  If either frontend or backend sees\n    an unexpected closure of the connection, it should clean\n    up and terminate.  The frontend has the option of launching a new backend\n    by recontacting the server if it doesn't want to terminate itself.\n    Closing the connection is also advisable if an unrecognizable message type\n    is received, since this probably indicates loss of message-boundary sync.\n   </para>\n\n   <para>\n    For either normal or abnormal termination, any open transaction is\n    rolled back, not committed.  One should note however that if a\n    frontend disconnects while a non-<command>SELECT</command> query\n    is being processed, the backend will probably finish the query\n    before noticing the disconnection.  If the query is outside any\n    transaction block (<command>BEGIN</command> ... <command>COMMIT</command>\n    sequence) then its results might be committed before the\n    disconnection is recognized.\n   </para>\n  </sect2>\n\n  <sect2>\n   <title><acronym>SSL</acronym> Session Encryption</title>\n\n   <para>\n    If <productname>PostgreSQL</productname> was built with\n    <acronym>SSL</acronym> support, frontend/backend communications\n    can be encrypted using <acronym>SSL</acronym>.  This provides\n    communication security in environments where attackers might be\n    able to capture the session traffic. For more information on\n    encrypting <productname>PostgreSQL</productname> sessions with\n    <acronym>SSL</acronym>, see <xref linkend=\"ssl-tcp\"/>.\n   </para>\n\n   <para>\n    To initiate an <acronym>SSL</acronym>-encrypted connection, the\n    frontend initially sends an SSLRequest message rather than a\n    StartupMessage.  The server then responds with a single byte\n    containing <literal>S</literal> or <literal>N</literal>, indicating that it is\n    willing or unwilling to perform <acronym>SSL</acronym>,\n    respectively.  The frontend might close the connection at this point\n    if it is dissatisfied with the response.  To continue after\n    <literal>S</literal>, perform an <acronym>SSL</acronym> startup handshake\n    (not described here, part of the <acronym>SSL</acronym>\n    specification) with the server.  If this is successful, continue\n    with sending the usual StartupMessage.  In this case the\n    StartupMessage and all subsequent data will be\n    <acronym>SSL</acronym>-encrypted.  To continue after\n    <literal>N</literal>, send the usual StartupMessage and proceed without\n    encryption.\n    (Alternatively, it is permissible to issue a GSSENCRequest message\n    after an <literal>N</literal> response to try to\n    use <acronym>GSSAPI</acronym> encryption instead\n    of <acronym>SSL</acronym>.)\n   </para>\n\n   <para>\n    The frontend should also be prepared to handle an ErrorMessage\n    response to SSLRequest from the server.  This would only occur if\n    the server predates the addition of <acronym>SSL</acronym> support\n    to <productname>PostgreSQL</productname>.  (Such servers are now very ancient,\n    and likely do not exist in the wild anymore.)\n    In this case the connection must\n    be closed, but the frontend might choose to open a fresh connection\n    and proceed without requesting <acronym>SSL</acronym>.\n   </para>\n\n   <para>\n    When <acronym>SSL</acronym> encryption can be performed, the server\n    is expected to send only the single <literal>S</literal> byte and then\n    wait for the frontend to initiate an <acronym>SSL</acronym> handshake.\n    If additional bytes are available to read at this point, it likely\n    means that a man-in-the-middle is attempting to perform a\n    buffer-stuffing attack\n    (<ulink url=\"https://www.postgresql.org/support/security/CVE-2021-23222/\">CVE-2021-23222</ulink>).\n    Frontends should be coded either to read exactly one byte from the\n    socket before turning the socket over to their SSL library, or to\n    treat it as a protocol violation if they find they have read additional\n    bytes.\n   </para>\n\n   <para>\n    An initial SSLRequest can also be used in a connection that is being\n    opened to send a CancelRequest message.\n   </para>\n\n   <para>\n    While the protocol itself does not provide a way for the server to\n    force <acronym>SSL</acronym> encryption, the administrator can\n    configure the server to reject unencrypted sessions as a byproduct\n    of authentication checking.\n   </para>\n  </sect2>\n\n  <sect2>\n   <title><acronym>GSSAPI</acronym> Session Encryption</title>\n\n   <para>\n    If <productname>PostgreSQL</productname> was built with\n    <acronym>GSSAPI</acronym> support, frontend/backend communications\n    can be encrypted using <acronym>GSSAPI</acronym>.  This provides\n    communication security in environments where attackers might be\n    able to capture the session traffic. For more information on\n    encrypting <productname>PostgreSQL</productname> sessions with\n    <acronym>GSSAPI</acronym>, see <xref linkend=\"gssapi-enc\"/>.\n   </para>\n\n   <para>\n    To initiate a <acronym>GSSAPI</acronym>-encrypted connection, the\n    frontend initially sends a GSSENCRequest message rather than a\n    StartupMessage.  The server then responds with a single byte\n    containing <literal>G</literal> or <literal>N</literal>, indicating that it\n    is willing or unwilling to perform <acronym>GSSAPI</acronym> encryption,\n    respectively.  The frontend might close the connection at this point\n    if it is dissatisfied with the response.  To continue after\n    <literal>G</literal>, using the GSSAPI C bindings as discussed in\n    <ulink url=\"https://tools.ietf.org/html/rfc2744\">RFC 2744</ulink>\n    or equivalent, perform a <acronym>GSSAPI</acronym> initialization by\n    calling <function>gss_init_sec_context()</function> in a loop and sending\n    the result to the server, starting with an empty input and then with each\n    result from the server, until it returns no output.  When sending the\n    results of <function>gss_init_sec_context()</function> to the server,\n    prepend the length of the message as a four byte integer in network byte\n    order.\n    To continue after\n    <literal>N</literal>, send the usual StartupMessage and proceed without\n    encryption.\n    (Alternatively, it is permissible to issue an SSLRequest message\n    after an <literal>N</literal> response to try to\n    use <acronym>SSL</acronym> encryption instead\n    of <acronym>GSSAPI</acronym>.)\n   </para>\n\n   <para>\n    The frontend should also be prepared to handle an ErrorMessage\n    response to GSSENCRequest from the server.  This would only occur if\n    the server predates the addition of <acronym>GSSAPI</acronym> encryption\n    support to <productname>PostgreSQL</productname>.  In this case the\n    connection must be closed, but the frontend might choose to open a fresh\n    connection and proceed without requesting <acronym>GSSAPI</acronym>\n    encryption.\n   </para>\n\n   <para>\n    When <acronym>GSSAPI</acronym> encryption can be performed, the server\n    is expected to send only the single <literal>G</literal> byte and then\n    wait for the frontend to initiate a <acronym>GSSAPI</acronym> handshake.\n    If additional bytes are available to read at this point, it likely\n    means that a man-in-the-middle is attempting to perform a\n    buffer-stuffing attack\n    (<ulink url=\"https://www.postgresql.org/support/security/CVE-2021-23222/\">CVE-2021-23222</ulink>).\n    Frontends should be coded either to read exactly one byte from the\n    socket before turning the socket over to their GSSAPI library, or to\n    treat it as a protocol violation if they find they have read additional\n    bytes.\n   </para>\n\n   <para>\n    An initial GSSENCRequest can also be used in a connection that is being\n    opened to send a CancelRequest message.\n   </para>\n\n   <para>\n    Once <acronym>GSSAPI</acronym> encryption has been successfully\n    established, use <function>gss_wrap()</function> to\n    encrypt the usual StartupMessage and all subsequent data, prepending the\n    length of the result from <function>gss_wrap()</function> as a four byte\n    integer in network byte order to the actual encrypted payload.  Note that\n    the server will only accept encrypted packets from the client which are less\n    than 16kB; <function>gss_wrap_size_limit()</function> should be used by the\n    client to determine the size of the unencrypted message which will fit\n    within this limit and larger messages should be broken up into multiple\n    <function>gss_wrap()</function> calls.  Typical segments are 8kB of\n    unencrypted data, resulting in encrypted packets of slightly larger than 8kB\n    but well within the 16kB maximum.  The server can be expected to not send\n    encrypted packets of larger than 16kB to the client.\n   </para>\n\n   <para>\n    While the protocol itself does not provide a way for the server to\n    force <acronym>GSSAPI</acronym> encryption, the administrator can\n    configure the server to reject unencrypted sessions as a byproduct\n    of authentication checking.\n   </para>\n  </sect2>\n </sect1>\n\n<sect1 id=\"sasl-authentication\">\n<title>SASL Authentication</title>\n\n<para>\n<firstterm>SASL</firstterm> is a framework for authentication in connection-oriented\nprotocols. At the moment, <productname>PostgreSQL</productname> implements two SASL\nauthentication mechanisms, SCRAM-SHA-256 and SCRAM-SHA-256-PLUS. More\nmight be added in the future. The below steps illustrate how SASL\nauthentication is performed in general, while the next subsection gives\nmore details on SCRAM-SHA-256 and SCRAM-SHA-256-PLUS.\n</para>\n\n<procedure>\n<title>SASL Authentication Message Flow</title>\n\n<step id=\"sasl-auth-begin\">\n<para>\n  To begin a SASL authentication exchange, the server sends an\n  AuthenticationSASL message. It includes a list of SASL authentication\n  mechanisms that the server can accept, in the server's preferred order.\n</para>\n</step>\n\n<step id=\"sasl-auth-initial-response\">\n<para>\n  The client selects one of the supported mechanisms from the list, and sends\n  a SASLInitialResponse message to the server. The message includes the name\n  of the selected mechanism, and an optional Initial Client Response, if the\n  selected mechanism uses that.\n</para>\n</step>\n\n<step id=\"sasl-auth-continue\">\n<para>\n  One or more server-challenge and client-response message will follow. Each\n  server-challenge is sent in an AuthenticationSASLContinue message, followed\n  by a response from client in a SASLResponse message. The particulars of\n  the messages are mechanism specific.\n</para>\n</step>\n\n<step id=\"sasl-auth-end\">\n<para>\n  Finally, when the authentication exchange is completed successfully, the\n  server sends an AuthenticationSASLFinal message, followed\n  immediately by an AuthenticationOk message. The AuthenticationSASLFinal\n  contains additional server-to-client data, whose content is particular to the\n  selected authentication mechanism. If the authentication mechanism doesn't\n  use additional data that's sent at completion, the AuthenticationSASLFinal\n  message is not sent.\n</para>\n</step>\n</procedure>\n\n<para>\nOn error, the server can abort the authentication at any stage, and send an\nErrorMessage.\n</para>\n\n <sect2 id=\"sasl-scram-sha-256\">\n  <title>SCRAM-SHA-256 Authentication</title>\n\n  <para>\n   The implemented SASL mechanisms at the moment\n   are <literal>SCRAM-SHA-256</literal> and its variant with channel\n   binding <literal>SCRAM-SHA-256-PLUS</literal>. They are described in\n   detail in <ulink url=\"https://tools.ietf.org/html/rfc7677\">RFC 7677</ulink>\n   and <ulink url=\"https://tools.ietf.org/html/rfc5802\">RFC 5802</ulink>.\n  </para>\n\n  <para>\nWhen SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name\nthat the client sends in the <structname>client-first-message</structname>. The user name\nthat was already sent in the startup message is used instead.\n<productname>PostgreSQL</productname> supports multiple character encodings, while SCRAM\ndictates UTF-8 to be used for the user name, so it might be impossible to\nrepresent the PostgreSQL user name in UTF-8.\n  </para>\n\n  <para>\nThe SCRAM specification dictates that the password is also in UTF-8, and is\nprocessed with the <firstterm>SASLprep</firstterm> algorithm.\n<productname>PostgreSQL</productname>, however, does not require UTF-8 to be used for\nthe password. When a user's password is set, it is processed with SASLprep\nas if it was in UTF-8, regardless of the actual encoding used. However, if\nit is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences\nthat are prohibited by the SASLprep algorithm, the raw password will be used\nwithout SASLprep processing, instead of throwing an error. This allows the\npassword to be normalized when it is in UTF-8, but still allows a non-UTF-8\npassword to be used, and doesn't require the system to know which encoding\nthe password is in.\n  </para>\n\n  <para>\n<firstterm>Channel binding</firstterm> is supported in PostgreSQL builds with\nSSL support. The SASL mechanism name for SCRAM with channel binding is\n<literal>SCRAM-SHA-256-PLUS</literal>.  The channel binding type used by\nPostgreSQL is <literal>tls-server-end-point</literal>.\n  </para>\n\n  <para>\n   In <acronym>SCRAM</acronym> without channel binding, the server chooses\n   a random number that is transmitted to the client to be mixed with the\n   user-supplied password in the transmitted password hash.  While this\n   prevents the password hash from being successfully retransmitted in\n   a later session, it does not prevent a fake server between the real\n   server and client from passing through the server's random value\n   and successfully authenticating.\n  </para>\n\n  <para>\n   <acronym>SCRAM</acronym> with channel binding prevents such\n   man-in-the-middle attacks by mixing the signature of the server's\n   certificate into the transmitted password hash. While a fake server can\n   retransmit the real server's certificate, it doesn't have access to the\n   private key matching that certificate, and therefore cannot prove it is\n   the owner, causing SSL connection failure.\n  </para>\n\n<procedure>\n<title>Example</title>\n  <step id=\"scram-begin\">\n<para>\n  The server sends an AuthenticationSASL message. It includes a list of\n  SASL authentication mechanisms that the server can accept.\n  This will be <literal>SCRAM-SHA-256-PLUS</literal>\n  and <literal>SCRAM-SHA-256</literal> if the server is built with SSL\n  support, or else just the latter.\n</para>\n</step>\n<step id=\"scram-client-first\">\n<para>\n  The client responds by sending a SASLInitialResponse message, which\n  indicates the chosen mechanism, <literal>SCRAM-SHA-256</literal> or\n  <literal>SCRAM-SHA-256-PLUS</literal>. (A client is free to choose either\n  mechanism, but for better security it should choose the channel-binding\n  variant if it can support it.) In the Initial Client response field, the\n  message contains the SCRAM <structname>client-first-message</structname>.\n  The <structname>client-first-message</structname> also contains the channel\n  binding type chosen by the client.\n</para>\n</step>\n<step id=\"scram-server-first\">\n<para>\n  Server sends an AuthenticationSASLContinue message, with a SCRAM\n  <structname>server-first-message</structname> as the content.\n</para>\n</step>\n<step id=\"scram-client-final\">\n<para>\n  Client sends a SASLResponse message, with SCRAM\n  <structname>client-final-message</structname> as the content.\n</para>\n</step>\n<step id=\"scram-server-final\">\n<para>\n  Server sends an AuthenticationSASLFinal message, with the SCRAM\n  <structname>server-final-message</structname>, followed immediately by\n  an AuthenticationOk message.\n</para>\n</step>\n</procedure>\n</sect2>\n</sect1>\n\n<sect1 id=\"protocol-replication\">\n<title>Streaming Replication Protocol</title>\n\n<para>\nTo initiate streaming replication, the frontend sends the\n<literal>replication</literal> parameter in the startup message. A Boolean\nvalue of <literal>true</literal> (or <literal>on</literal>,\n<literal>yes</literal>, <literal>1</literal>) tells the backend to go into\nphysical replication walsender mode, wherein a small set of replication\ncommands, shown below, can be issued instead of SQL statements.\n</para>\n\n<para>\nPassing <literal>database</literal> as the value for the\n<literal>replication</literal> parameter instructs the backend to go into\nlogical replication walsender mode, connecting to the database specified in\nthe <literal>dbname</literal> parameter.  In logical replication walsender\nmode, the replication commands shown below as well as normal SQL commands can\nbe issued.\n</para>\n\n<para>\nIn either physical replication or logical replication walsender mode, only the\nsimple query protocol can be used.\n</para>\n\n<para>\n For the purpose of testing replication commands, you can make a replication\n connection via <application>psql</application> or any other\n <application>libpq</application>-using tool with a connection string including\n the <literal>replication</literal> option,\n e.g.:\n<programlisting>\npsql \"dbname=postgres replication=database\" -c \"IDENTIFY_SYSTEM;\"\n</programlisting>\n However, it is often more useful to use\n <xref linkend=\"app-pgreceivewal\"/> (for physical replication) or\n <xref linkend=\"app-pgrecvlogical\"/> (for logical replication).\n</para>\n\n<para>\nReplication commands are logged in the server log when\n<xref linkend=\"guc-log-replication-commands\"/> is enabled.\n</para>\n\n<para>\nThe commands accepted in replication mode are:\n<variablelist>\n  <varlistentry>\n    <term><literal>IDENTIFY_SYSTEM</literal>\n     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Requests the server to identify itself. Server replies with a result\n      set of a single row, containing four fields:\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n       <literal>systemid</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       The unique system identifier identifying the cluster. This\n       can be used to check that the base backup used to initialize the\n       standby came from the same cluster.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      <varlistentry>\n      <term>\n       <literal>timeline</literal> (<type>int4</type>)\n      </term>\n      <listitem>\n      <para>\n       Current timeline ID. Also useful to check that the standby is\n       consistent with the primary.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      <varlistentry>\n      <term>\n       <literal>xlogpos</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       Current WAL flush location. Useful to get a known location in the\n       write-ahead log where streaming can start.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      <varlistentry>\n      <term>\n       <literal>dbname</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       Database connected to or null.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>SHOW</literal> <replaceable class=\"parameter\">name</replaceable>\n     <indexterm><primary>SHOW</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Requests the server to send the current setting of a run-time parameter.\n      This is similar to the SQL command <xref linkend=\"sql-show\"/>.\n     </para>\n\n     <variablelist>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">name</replaceable></term>\n       <listitem>\n         <para>\n          The name of a run-time parameter. Available parameters are documented\n          in <xref linkend=\"runtime-config\"/>.\n         </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>TIMELINE_HISTORY</literal> <replaceable class=\"parameter\">tli</replaceable>\n     <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Requests the server to send over the timeline history file for timeline\n      <replaceable class=\"parameter\">tli</replaceable>.  Server replies with a\n      result set of a single row, containing two fields.  While the fields\n      are labeled as <type>text</type>, they effectively return raw bytes,\n      with no encoding conversion:\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n       <literal>filename</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       File name of the timeline history file, e.g., <filename>00000002.history</filename>.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      <varlistentry>\n      <term>\n       <literal>content</literal> (<type>text</type>)\n      </term>\n      <listitem>\n      <para>\n       Contents of the timeline history file.\n      </para>\n      </listitem>\n      </varlistentry>\n\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry id=\"protocol-replication-create-slot\" xreflabel=\"CREATE_REPLICATION_SLOT\">\n   <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> | <literal>LOGICAL</literal> } [ ( <replaceable class=\"parameter\">option</replaceable> [, ...] ) ]\n     <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Create a physical or logical replication\n      slot. See <xref linkend=\"streaming-replication-slots\"/> for more about\n      replication slots.\n     </para>\n     <variablelist>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">slot_name</replaceable></term>\n       <listitem>\n         <para>\n          The name of the slot to create. Must be a valid replication slot\n          name (see <xref linkend=\"streaming-replication-slots-manipulation\"/>).\n         </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><replaceable class=\"parameter\">output_plugin</replaceable></term>\n       <listitem>\n         <para>\n          The name of the output plugin used for logical decoding\n          (see <xref linkend=\"logicaldecoding-output-plugin\"/>).\n         </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><literal>TEMPORARY</literal></term>\n       <listitem>\n        <para>\n         Specify that this replication slot is a temporary one. Temporary\n         slots are not saved to disk and are automatically dropped on error\n         or when the session has finished.\n        </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n\n     <para>The following options are supported:</para>\n\n     <variablelist>\n      <varlistentry>\n       <term><literal>TWO_PHASE [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n       <listitem>\n        <para>\n         If true, this logical replication slot supports decoding of two-phase\n         transactions. With this option, two-phase commands like\n         <literal>PREPARE TRANSACTION</literal>, <literal>COMMIT PREPARED</literal>\n         and <literal>ROLLBACK PREPARED</literal> are decoded and transmitted.\n         The transaction will be decoded and transmitted at\n         <literal>PREPARE TRANSACTION</literal> time.\n         The default is false.\n        </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><literal>RESERVE_WAL [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n       <listitem>\n        <para>\n         If true, this physical replication slot reserves <acronym>WAL</acronym>\n         immediately.  Otherwise, <acronym>WAL</acronym> is only reserved upon\n         connection from a streaming replication client.\n         The default is false.\n        </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><literal>SNAPSHOT { 'export' | 'use' | 'nothing' }</literal></term>\n       <listitem>\n        <para>\n         Decides what to do with the snapshot created during logical slot\n         initialization. <literal>'export'</literal>, which is the default,\n         will export the snapshot for use in other sessions. This option can't\n         be used inside a transaction.  <literal>'use'</literal> will use the\n         snapshot for the current transaction executing the command. This\n         option must be used in a transaction, and\n         <literal>CREATE_REPLICATION_SLOT</literal> must be the first command\n         run in that transaction.  Finally, <literal>'nothing'</literal> will\n         just use the snapshot for logical decoding as normal but won't do\n         anything else with it.\n        </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n\n     <para>\n      In response to this command, the server will send a one-row result set\n      containing the following fields:\n\n      <variablelist>\n       <varlistentry>\n        <term><literal>slot_name</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The name of the newly-created replication slot.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>consistent_point</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The WAL location at which the slot became consistent.  This is the\n          earliest location from which streaming can start on this replication\n          slot.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>snapshot_name</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The identifier of the snapshot exported by the command.  The\n          snapshot is valid until a new command is executed on this connection\n          or the replication connection is closed.  Null if the created slot\n          is physical.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>output_plugin</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The name of the output plugin used by the newly-created replication\n          slot.  Null if the created slot is physical.\n         </para>\n        </listitem>\n       </varlistentry>\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable class=\"parameter\">output_plugin</replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | <literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> | <literal>TWO_PHASE</literal> ] }\n    </term>\n    <listitem>\n     <para>\n      For compatibility with older releases, this alternative syntax for\n      the <literal>CREATE_REPLICATION_SLOT</literal> command is still supported.\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>READ_REPLICATION_SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable>\n      <indexterm><primary>READ_REPLICATION_SLOT</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Read some information associated to a replication slot. Returns a tuple\n      with <literal>NULL</literal> values if the replication slot does not\n      exist. This command is currently only supported for physical replication\n      slots.\n     </para>\n     <para>\n      In response to this command, the server will return a one-row result set,\n      containing the following fields:\n      <variablelist>\n       <varlistentry>\n        <term><literal>slot_type</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The replication slot's type, either <literal>physical</literal> or\n          <literal>NULL</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>restart_lsn</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The replication slot's <literal>restart_lsn</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>restart_tli</literal> (<type>int8</type>)</term>\n        <listitem>\n         <para>\n          The timeline ID associated to <literal>restart_lsn</literal>,\n          following the current timeline history.\n         </para>\n        </listitem>\n       </varlistentry>\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class=\"parameter\">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class=\"parameter\">tli</replaceable> ]\n     <indexterm><primary>START_REPLICATION</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Instructs server to start streaming WAL, starting at\n      WAL location <replaceable class=\"parameter\">XXX/XXX</replaceable>.\n      If <literal>TIMELINE</literal> option is specified,\n      streaming starts on timeline <replaceable class=\"parameter\">tli</replaceable>;\n      otherwise, the server's current timeline is selected. The server can\n      reply with an error, for example if the requested section of WAL has already\n      been recycled. On success, server responds with a CopyBothResponse\n      message, and then starts to stream WAL to the frontend.\n     </para>\n\n     <para>\n      If a slot's name is provided\n      via <replaceable class=\"parameter\">slot_name</replaceable>, it will be updated\n      as replication progresses so that the server knows which WAL segments,\n      and if <varname>hot_standby_feedback</varname> is on which transactions,\n      are still needed by the standby.\n     </para>\n\n     <para>\n      If the client requests a timeline that's not the latest but is part of\n      the history of the server, the server will stream all the WAL on that\n      timeline starting from the requested start point up to the point where\n      the server switched to another timeline. If the client requests\n      streaming at exactly the end of an old timeline, the server skips COPY\n      mode entirely.\n     </para>\n\n     <para>\n      After streaming all the WAL on a timeline that is not the latest one,\n      the server will end streaming by exiting the COPY mode. When the client\n      acknowledges this by also exiting COPY mode, the server sends a result\n      set with one row and two columns, indicating the next timeline in this\n      server's history. The first column is the next timeline's ID (type <type>int8</type>), and the\n      second column is the WAL location where the switch happened (type <type>text</type>). Usually,\n      the switch position is the end of the WAL that was streamed, but there\n      are corner cases where the server can send some WAL from the old\n      timeline that it has not itself replayed before promoting. Finally, the\n      server sends two CommandComplete messages (one that ends the CopyData\n      and the other ends the <literal>START_REPLICATION</literal> itself), and\n      is ready to accept a new command.\n     </para>\n\n     <para>\n      WAL data is sent as a series of CopyData messages.  (This allows\n      other information to be intermixed; in particular the server can send\n      an ErrorResponse message if it encounters a failure after beginning\n      to stream.)  The payload of each CopyData message from server to the\n      client contains a message of one of the following formats:\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          XLogData (B)\n      </term>\n      <listitem>\n      <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Byte1('w')\n      </term>\n      <listitem>\n      <para>\n          Identifies the message as WAL data.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The starting point of the WAL data in this message.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The current end of WAL on the server.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The server's system clock at the time of transmission, as\n          microseconds since midnight on 2000-01-01.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Byte<replaceable>n</replaceable>\n      </term>\n      <listitem>\n      <para>\n          A section of the WAL data stream.\n      </para>\n      <para>\n          A single WAL record is never split across two XLogData messages.\n          When a WAL record crosses a WAL page boundary, and is therefore\n          already split using continuation records, it can be split at the page\n          boundary. In other words, the first main WAL record and its\n          continuation records can be sent in different XLogData messages.\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Primary keepalive message (B)\n      </term>\n      <listitem>\n      <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Byte1('k')\n      </term>\n      <listitem>\n      <para>\n          Identifies the message as a sender keepalive.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The current end of WAL on the server.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The server's system clock at the time of transmission, as\n          microseconds since midnight on 2000-01-01.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Byte1\n      </term>\n      <listitem>\n      <para>\n          1 means that the client should reply to this message as soon as\n          possible, to avoid a timeout disconnect. 0 otherwise.\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n     </para>\n\n     <para>\n       The receiving process can send replies back to the sender at any time,\n       using one of the following message formats (also in the payload of a\n       CopyData message):\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Standby status update (F)\n      </term>\n      <listitem>\n      <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Byte1('r')\n      </term>\n      <listitem>\n      <para>\n          Identifies the message as a receiver status update.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The location of the last WAL byte + 1 received and written to disk\n          in the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The location of the last WAL byte + 1 flushed to disk in\n          the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The location of the last WAL byte + 1 applied in the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The client's system clock at the time of transmission, as\n          microseconds since midnight on 2000-01-01.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Byte1\n      </term>\n      <listitem>\n      <para>\n          If 1, the client requests the server to reply to this message\n          immediately. This can be used to ping the server, to test if\n          the connection is still healthy.\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n     </para>\n\n     <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Hot Standby feedback message (F)\n      </term>\n      <listitem>\n      <para>\n      <variablelist>\n      <varlistentry>\n      <term>\n          Byte1('h')\n      </term>\n      <listitem>\n      <para>\n          Identifies the message as a Hot Standby feedback message.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int64\n      </term>\n      <listitem>\n      <para>\n          The client's system clock at the time of transmission, as\n          microseconds since midnight on 2000-01-01.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int32\n      </term>\n      <listitem>\n      <para>\n          The standby's current global xmin, excluding the catalog_xmin from any\n          replication slots. If both this value and the following\n          catalog_xmin are 0 this is treated as a notification that Hot Standby\n          feedback will no longer be sent on this connection. Later non-zero\n          messages may reinitiate the feedback mechanism.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int32\n      </term>\n      <listitem>\n      <para>\n          The epoch of the global xmin xid on the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int32\n      </term>\n      <listitem>\n      <para>\n          The lowest catalog_xmin of any replication slots on the standby. Set to 0\n          if no catalog_xmin exists on the standby or if hot standby feedback is being\n          disabled.\n      </para>\n      </listitem>\n      </varlistentry>\n      <varlistentry>\n      <term>\n          Int32\n      </term>\n      <listitem>\n      <para>\n          The epoch of the catalog_xmin xid on the standby.\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n      </para>\n      </listitem>\n      </varlistentry>\n      </variablelist>\n     </para>\n    </listitem>\n  </varlistentry>\n  <varlistentry>\n    <term><literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> <literal>LOGICAL</literal> <replaceable class=\"parameter\">XXX/XXX</replaceable> [ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</replaceable> ] [, ...] ) ]</term>\n    <listitem>\n     <para>\n      Instructs server to start streaming WAL for logical replication,\n      starting at either WAL location <replaceable\n      class=\"parameter\">XXX/XXX</replaceable> or the slot's\n      <literal>confirmed_flush_lsn</literal> (see <xref\n      linkend=\"view-pg-replication-slots\"/>), whichever is greater. This\n      behavior makes it easier for clients to avoid updating their local LSN\n      status when there is no data to process. However, starting at a\n      different LSN than requested might not catch certain kinds of client\n      errors; so the client may wish to check that\n      <literal>confirmed_flush_lsn</literal> matches its expectations before\n      issuing <literal>START_REPLICATION</literal>.\n     </para>\n\n     <para>\n      The server can reply with an error, for example if the\n      slot does not exist. On success, server responds with a CopyBothResponse\n      message, and then starts to stream WAL to the frontend.\n     </para>\n\n     <para>\n      The messages inside the CopyBothResponse messages are of the same format\n      documented for <literal>START_REPLICATION ... PHYSICAL</literal>, including\n      two CommandComplete messages.\n     </para>\n\n     <para>\n      The output plugin associated with the selected slot is used\n      to process the output for streaming.\n     </para>\n\n     <variablelist>\n      <varlistentry>\n       <term><literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable></term>\n       <listitem>\n         <para>\n          The name of the slot to stream changes from. This parameter is required,\n          and must correspond to an existing logical replication slot created\n          with <literal>CREATE_REPLICATION_SLOT</literal> in\n          <literal>LOGICAL</literal> mode.\n         </para>\n       </listitem>\n      </varlistentry>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">XXX/XXX</replaceable></term>\n       <listitem>\n        <para>\n         The WAL location to begin streaming at.\n        </para>\n       </listitem>\n      </varlistentry>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">option_name</replaceable></term>\n       <listitem>\n        <para>\n         The name of an option passed to the slot's logical decoding plugin.\n        </para>\n       </listitem>\n      </varlistentry>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">option_value</replaceable></term>\n       <listitem>\n        <para>\n         Optional value, in the form of a string constant, associated with the\n         specified option.\n        </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term>\n     <literal>DROP_REPLICATION_SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable> <optional> <literal>WAIT</literal> </optional>\n     <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Drops a replication slot, freeing any reserved server-side resources.\n      If the slot is a logical slot that was created in a database other than\n      the database the walsender is connected to, this command fails.\n     </para>\n     <variablelist>\n      <varlistentry>\n       <term><replaceable class=\"parameter\">slot_name</replaceable></term>\n       <listitem>\n         <para>\n          The name of the slot to drop.\n         </para>\n       </listitem>\n      </varlistentry>\n\n      <varlistentry>\n       <term><literal>WAIT</literal></term>\n       <listitem>\n        <para>\n         This option causes the command to wait if the slot is active until\n         it becomes inactive, instead of the default behavior of raising an\n         error.\n        </para>\n       </listitem>\n      </varlistentry>\n     </variablelist>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry id=\"protocol-replication-base-backup\" xreflabel=\"BASE_BACKUP\">\n    <term><literal>BASE_BACKUP</literal> [ ( <replaceable class=\"parameter\">option</replaceable> [, ...] ) ]\n     <indexterm><primary>BASE_BACKUP</primary></indexterm>\n    </term>\n    <listitem>\n     <para>\n      Instructs the server to start streaming a base backup.\n      The system will automatically be put in backup mode before the backup\n      is started, and taken out of it when the backup is complete. The\n      following options are accepted:\n      <variablelist>\n       <varlistentry>\n        <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>\n        <listitem>\n         <para>\n          Sets the label of the backup. If none is specified, a backup label\n          of <literal>base backup</literal> will be used. The quoting rules\n          for the label are the same as a standard SQL string with\n          <xref linkend=\"guc-standard-conforming-strings\"/> turned on.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>PROGRESS [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If set to true, request information required to generate a progress\n          report. This will send back an approximate size in the header of each\n          tablespace, which can be used to calculate how far along the stream\n          is done. This is calculated by enumerating all the file sizes once\n          before the transfer is even started, and might as such have a\n          negative impact on the performance.  In particular, it might take\n          longer before the first data\n          is streamed. Since the database files can change during the backup,\n          the size is only approximate and might both grow and shrink between\n          the time of approximation and the sending of the actual files.\n          The default is false.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>CHECKPOINT { 'fast' | 'spread' }</literal></term>\n        <listitem>\n         <para>\n          Sets the type of checkpoint to be performed at the beginning of the\n          base backup. The default is <literal>spread</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>WAL [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If set to true, include the necessary WAL segments in the backup.\n          This will include all the files between start and stop backup in the\n          <filename>pg_wal</filename> directory of the base directory tar\n          file. The default is false.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>WAIT [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If set to true, the backup will wait until the last required WAL\n          segment has been archived, or emit a warning if log archiving is\n          not enabled. If false, the backup will neither wait nor warn,\n          leaving the client responsible for ensuring the required log is\n          available. The default is true.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>MAX_RATE</literal> <replaceable>rate</replaceable></term>\n        <listitem>\n         <para>\n          Limit (throttle) the maximum amount of data transferred from server\n          to client per unit of time.  The expected unit is kilobytes per second.\n          If this option is specified, the value must either be equal to zero\n          or it must fall within the range from 32 kB through 1 GB (inclusive).\n          If zero is passed or the option is not specified, no restriction is\n          imposed on the transfer.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>TABLESPACE_MAP [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If true, include information about symbolic links present in the\n          directory <filename>pg_tblspc</filename> in a file named\n          <filename>tablespace_map</filename>. The tablespace map file includes\n          each symbolic link name as it exists in the directory\n          <filename>pg_tblspc/</filename> and the full path of that symbolic link.\n          The default is false.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>VERIFY_CHECKSUMS [ <replaceable class=\"parameter\">boolean</replaceable> ]</literal></term>\n        <listitem>\n         <para>\n          If true, checksums are verified during a base backup if they are\n          enabled. If false, this is skipped. The default is true.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>MANIFEST</literal> <replaceable>manifest_option</replaceable></term>\n        <listitem>\n         <para>\n          When this option is specified with a value of <literal>yes</literal>\n          or <literal>force-encode</literal>, a backup manifest is created\n          and sent along with the backup.  The manifest is a list of every\n          file present in the backup with the exception of any WAL files that\n          may be included. It also stores the size, last modification time, and\n          optionally a checksum for each file.\n          A value of <literal>force-encode</literal> forces all filenames\n          to be hex-encoded; otherwise, this type of encoding is performed only\n          for files whose names are non-UTF8 octet sequences.\n          <literal>force-encode</literal> is intended primarily for testing\n          purposes, to be sure that clients which read the backup manifest\n          can handle this case. For compatibility with previous releases,\n          the default is <literal>MANIFEST 'no'</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n\n       <varlistentry>\n        <term><literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable></term>\n        <listitem>\n         <para>\n          Specifies the checksum algorithm that should be applied to each file included\n          in the backup manifest. Currently, the available\n          algorithms are <literal>NONE</literal>, <literal>CRC32C</literal>,\n          <literal>SHA224</literal>, <literal>SHA256</literal>,\n          <literal>SHA384</literal>, and <literal>SHA512</literal>.\n          The default is <literal>CRC32C</literal>.\n         </para>\n        </listitem>\n       </varlistentry>\n      </variablelist>\n     </para>\n     <para>\n      When the backup is started, the server will first send two\n      ordinary result sets, followed by one or more CopyOutResponse\n      results.\n     </para>\n     <para>\n      The first ordinary result set contains the starting position of the\n      backup, in a single row with two columns. The first column contains\n      the start position given in XLogRecPtr format, and the second column\n      contains the corresponding timeline ID.\n     </para>\n     <para>\n      The second ordinary result set has one row for each tablespace.\n      The fields in this row are:\n      <variablelist>\n       <varlistentry>\n        <term><literal>spcoid</literal> (<type>oid</type>)</term>\n        <listitem>\n         <para>\n          The OID of the tablespace, or null if it's the base\n          directory.\n         </para>\n        </listitem>\n       </varlistentry>\n       <varlistentry>\n        <term><literal>spclocation</literal> (<type>text</type>)</term>\n        <listitem>\n         <para>\n          The full path of the tablespace directory, or null\n          if it's the base directory.\n         </para>\n        </listitem>\n       </varlistentry>\n       <varlistentry>\n        <term><literal>size</literal> (<type>int8</type>)</term>\n        <listitem>\n         <para>\n          The approximate size of the tablespace, in kilobytes (1024 bytes),\n          if progress report has been requested; otherwise it's null.\n         </para>\n        </listitem>\n       </varlistentry>\n      </variablelist>\n     </para>\n\n     <para>\n      After the second regular result set, one or more CopyOutResponse results\n      will be sent, one for the main data directory and one for each additional tablespace other\n      than <literal>pg_default</literal> and <literal>pg_global</literal>. The data in\n      the CopyOutResponse results will be a tar format (following the\n      <quote>ustar interchange format</quote> specified in the POSIX 1003.1-2008\n      standard) dump of the tablespace contents, except that the two trailing\n      blocks of zeroes specified in the standard are omitted.\n      After the tar data is complete, and if a backup manifest was requested,\n      another CopyOutResponse result is sent, containing the manifest data for the\n      current base backup. In any case, a final ordinary result set will be\n      sent, containing the WAL end position of the backup, in the same format as\n      the start position.\n     </para>\n\n     <para>\n      The tar archive for the data directory and each tablespace will contain\n      all files in the directories, regardless of whether they are\n      <productname>PostgreSQL</productname> files or other files added to the same\n      directory. The only excluded files are:\n      <itemizedlist spacing=\"compact\" mark=\"bullet\">\n       <listitem>\n        <para>\n         <filename>postmaster.pid</filename>\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         <filename>postmaster.opts</filename>\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         <filename>pg_internal.init</filename> (found in multiple directories)\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         Various temporary files and directories created during the operation\n         of the PostgreSQL server, such as any file or directory beginning\n         with <filename>pgsql_tmp</filename> and temporary relations.\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         Unlogged relations, except for the init fork which is required to\n         recreate the (empty) unlogged relation on recovery.\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         <filename>pg_wal</filename>, including subdirectories. If the backup is run\n         with WAL files included, a synthesized version of <filename>pg_wal</filename> will be\n         included, but it will only contain the files necessary for the\n         backup to work, not the rest of the contents.\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         <filename>pg_dynshmem</filename>, <filename>pg_notify</filename>,\n         <filename>pg_replslot</filename>, <filename>pg_serial</filename>,\n         <filename>pg_snapshots</filename>, <filename>pg_stat_tmp</filename>, and\n         <filename>pg_subtrans</filename> are copied as empty directories (even if\n         they are symbolic links).\n        </para>\n       </listitem>\n       <listitem>\n        <para>\n         Files other than regular files and directories, such as symbolic\n         links (other than for the directories listed above) and special\n         device files, are skipped.  (Symbolic links\n         in <filename>pg_tblspc</filename> are maintained.)\n        </para>\n       </listitem>\n      </itemizedlist>\n      Owner, group, and file mode are set if the underlying file system on\n      the server supports it.\n     </para>\n    </listitem>\n  </varlistentry>\n\n  <varlistentry>\n    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ] [ <literal>MANIFEST</literal> <replaceable>manifest_option</replaceable> ] [ <literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable> ]\n    </term>\n    <listitem>\n     <para>\n      For compatibility with older releases, this alternative syntax for\n      the <literal>BASE_BACKUP</literal> command is still supported.\n     </para>\n    </listitem>\n  </varlistentry>\n</variablelist>\n\n</para>\n\n</sect1>\n\n<sect1 id=\"protocol-logical-replication\">\n <title>Logical Streaming Replication Protocol</title>\n\n <para>\n  This section describes the logical replication protocol, which is the message\n  flow started by the <literal>START_REPLICATION</literal>\n  <literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</replaceable>\n  <literal>LOGICAL</literal> replication command.\n </para>\n\n <para>\n  The logical streaming replication protocol builds on the primitives of\n  the physical streaming replication protocol.\n </para>\n\n <sect2 id=\"protocol-logical-replication-params\">\n  <title>Logical Streaming Replication Parameters</title>\n\n  <para>\n   The logical replication <literal>START_REPLICATION</literal> command\n   accepts following parameters:\n\n   <variablelist>\n    <varlistentry>\n     <term>\n      proto_version\n     </term>\n     <listitem>\n      <para>\n       Protocol version. Currently versions <literal>1</literal>, <literal>2</literal>,\n       and <literal>3</literal> are supported.\n      </para>\n      <para>\n       Version <literal>2</literal> is supported only for server version 14\n       and above, and it allows streaming of large in-progress transactions.\n      </para>\n      <para>\n       Version <literal>3</literal> is supported only for server version 15\n       and above, and it allows streaming of two-phase transactions.\n      </para>\n     </listitem>\n    </varlistentry>\n\n    <varlistentry>\n     <term>\n      publication_names\n     </term>\n     <listitem>\n      <para>\n       Comma separated list of publication names for which to subscribe\n       (receive changes). The individual publication names are treated\n       as standard objects names and can be quoted the same as needed.\n      </para>\n     </listitem>\n    </varlistentry>\n   </variablelist>\n\n  </para>\n </sect2>\n\n <sect2 id=\"protocol-logical-messages\">\n  <title>Logical Replication Protocol Messages</title>\n\n  <para>\n   The individual protocol messages are discussed in the following\n   subsections. Individual messages are described in\n   <xref linkend=\"protocol-logicalrep-message-formats\"/>.\n  </para>\n\n  <para>\n   All top-level protocol messages begin with a message type byte.\n   While represented in code as a character, this is a signed byte with no\n   associated encoding.\n  </para>\n\n  <para>\n   Since the streaming replication protocol supplies a message length there\n   is no need for top-level protocol messages to embed a length in their\n   header.\n  </para>\n\n </sect2>\n\n <sect2 id=\"protocol-logical-messages-flow\">\n  <title>Logical Replication Protocol Message Flow</title>\n\n  <para>\n   With the exception of the <literal>START_REPLICATION</literal> command and\n   the replay progress messages, all information flows only from the backend\n   to the frontend.\n  </para>\n\n  <para>\n   The logical replication protocol sends individual transactions one by one.\n   This means that all messages between a pair of Begin and Commit messages\n   belong to the same transaction. Similarly, all messages between a pair of\n   Begin Prepare and Prepare messages belong to the same transaction.\n   It also sends changes of large in-progress transactions between a pair of\n   Stream Start and Stream Stop messages. The last stream of such a transaction\n   contains a Stream Commit or Stream Abort message.\n  </para>\n\n  <para>\n   Every sent transaction contains zero or more DML messages (Insert,\n   Update, Delete). In case of a cascaded setup it can also contain Origin\n   messages. The origin message indicates that the transaction originated on\n   different replication node. Since a replication node in the scope of logical\n   replication protocol can be pretty much anything, the only identifier\n   is the origin name. It's downstream's responsibility to handle this as\n   needed (if needed). The Origin message is always sent before any DML\n   messages in the transaction.\n  </para>\n\n  <para>\n   Every DML message contains an arbitrary relation ID, which can be mapped to\n   an ID in the Relation messages. The Relation messages describe the schema of the\n   given relation. The Relation message is sent for a given relation either\n   because it is the first time we send a DML message for given relation in the\n   current session or because the relation definition has changed since the\n   last Relation message was sent for it. The protocol assumes that the client\n   is capable of caching the metadata for as many relations as needed.\n  </para>\n </sect2>\n</sect1>\n\n<sect1 id=\"protocol-message-types\">\n<title>Message Data Types</title>\n\n<para>\nThis section describes the base data types used in messages.\n\n<variablelist>\n\n<varlistentry>\n<term>\n        Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)\n</term>\n<listitem>\n<para>\n                An <replaceable>n</replaceable>-bit integer in network byte\n                order (most significant byte first).\n                If <replaceable>i</replaceable> is specified it\n                is the exact value that will appear, otherwise the value\n                is variable.  Eg. Int16, Int32(42).\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]\n</term>\n<listitem>\n<para>\n                An array of <replaceable>k</replaceable>\n                <replaceable>n</replaceable>-bit integers, each in network\n                byte order.  The array length <replaceable>k</replaceable>\n                is always determined by an earlier field in the message.\n                Eg. Int16[M].\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        String(<replaceable>s</replaceable>)\n</term>\n<listitem>\n<para>\n                A null-terminated string (C-style string).  There is no\n                specific length limitation on strings.\n                If <replaceable>s</replaceable> is specified it is the exact\n                value that will appear, otherwise the value is variable.\n                Eg. String, String(\"user\").\n</para>\n\n<note>\n<para>\n<emphasis>There is no predefined limit</emphasis> on the length of a string\nthat can be returned by the backend.  Good coding strategy for a frontend\nis to use an expandable buffer so that anything that fits in memory can be\naccepted.  If that's not feasible, read the full string and discard trailing\ncharacters that don't fit into your fixed-size buffer.\n</para>\n</note>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)\n</term>\n<listitem>\n<para>\n                Exactly <replaceable>n</replaceable> bytes.  If the field\n                width <replaceable>n</replaceable> is not a constant, it is\n                always determinable from an earlier field in the message.\n                If <replaceable>c</replaceable> is specified it is the exact\n                value.  Eg. Byte2, Byte1('\\n').\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</sect1>\n\n<sect1 id=\"protocol-message-formats\">\n<title>Message Formats</title>\n\n<para>\nThis section describes the detailed format of each message.  Each is marked to\nindicate that it can be sent by a frontend (F), a backend (B), or both\n(F &amp; B).\nNotice that although each message includes a byte count at the beginning,\nthe message format is defined so that the message end can be found without\nreference to the byte count.  This aids validity checking.  (The CopyData\nmessage is an exception, because it forms part of a data stream; the contents\nof any individual CopyData message cannot be interpretable on their own.)\n</para>\n\n<variablelist>\n\n\n<varlistentry>\n<term>\nAuthenticationOk (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(0)\n</term>\n<listitem>\n<para>\n                Specifies that the authentication was successful.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationKerberosV5 (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(2)\n</term>\n<listitem>\n<para>\n                Specifies that Kerberos V5 authentication is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationCleartextPassword (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(3)\n</term>\n<listitem>\n<para>\n                Specifies that a clear-text password is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationMD5Password (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(12)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(5)\n</term>\n<listitem>\n<para>\n                Specifies that an MD5-encrypted password is required.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte4\n</term>\n<listitem>\n<para>\n                The salt to use when encrypting the password.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSCMCredential (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(6)\n</term>\n<listitem>\n<para>\n                Specifies that an SCM credentials message is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationGSS (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(7)\n</term>\n<listitem>\n<para>\n                Specifies that GSSAPI authentication is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationGSSContinue (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Specifies that this message contains GSSAPI or SSPI data.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                GSSAPI or SSPI authentication data.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSSPI (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(9)\n</term>\n<listitem>\n<para>\n                Specifies that SSPI authentication is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSASL (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(10)\n</term>\n<listitem>\n<para>\n                Specifies that SASL authentication is required.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\nThe message body is a list of SASL authentication mechanisms, in the\nserver's order of preference. A zero byte is required as terminator after\nthe last authentication mechanism name. For each mechanism, there is the\nfollowing:\n<variablelist>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of a SASL authentication mechanism.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSASLContinue (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(11)\n</term>\n<listitem>\n<para>\n                Specifies that this message contains a SASL challenge.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                SASL data, specific to the SASL mechanism being used.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nAuthenticationSASLFinal (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as an authentication request.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(12)\n</term>\n<listitem>\n<para>\n                Specifies that SASL authentication has completed.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                SASL outcome \"additional data\", specific to the SASL mechanism\n                being used.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nBackendKeyData (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('K')\n</term>\n<listitem>\n<para>\n                Identifies the message as cancellation key data.\n                The frontend must save these values if it wishes to be\n                able to issue CancelRequest messages later.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(12)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The process ID of this backend.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The secret key of this backend.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nBind (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('B')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Bind command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the destination portal\n                (an empty string selects the unnamed portal).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the source prepared statement\n                (an empty string selects the unnamed prepared statement).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of parameter format codes that follow\n                (denoted <replaceable>C</replaceable> below).\n                This can be zero to indicate that there are no parameters\n                or that the parameters all use the default format (text);\n                or one, in which case the specified format code is applied\n                to all parameters; or it can equal the actual number of\n                parameters.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>C</replaceable>]\n</term>\n<listitem>\n<para>\n                The parameter format codes.  Each must presently be\n                zero (text) or one (binary).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of parameter values that follow (possibly zero).\n                This must match the number of parameters needed by the query.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, the following pair of fields appear for each parameter:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The length of the parameter value, in bytes (this count\n                does not include itself).  Can be zero.\n                As a special case, -1 indicates a NULL parameter value.\n                No value bytes follow in the NULL case.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the parameter, in the format indicated by the\n                associated format code.\n                <replaceable>n</replaceable> is the above length.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        After the last parameter, the following fields appear:\n<variablelist>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of result-column format codes that follow\n                (denoted <replaceable>R</replaceable> below).\n                This can be zero to indicate that there are no result columns\n                or that the result columns should all use the default format\n                (text);\n                or one, in which case the specified format code is applied\n                to all result columns (if any); or it can equal the actual\n                number of result columns of the query.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>R</replaceable>]\n</term>\n<listitem>\n<para>\n                The result-column format codes.  Each must presently be\n                zero (text) or one (binary).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nBindComplete (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('2')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Bind-complete indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCancelRequest (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int32(16)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(80877102)\n</term>\n<listitem>\n<para>\n                The cancel request code.  The value is chosen to contain\n                <literal>1234</literal> in the most significant 16 bits, and <literal>5678</literal> in the\n                least significant 16 bits.  (To avoid confusion, this code\n                must not be the same as any protocol version number.)\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The process ID of the target backend.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The secret key for the target backend.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nClose (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('C')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Close command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                '<literal>S</literal>' to close a prepared statement; or\n                '<literal>P</literal>' to close a portal.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the prepared statement or portal to close\n                (an empty string selects the unnamed prepared statement\n                or portal).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCloseComplete (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('3')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Close-complete indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCommandComplete (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('C')\n</term>\n<listitem>\n<para>\n                Identifies the message as a command-completed response.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n       <para>\n        The command tag.  This is usually a single\n        word that identifies which SQL command was completed.\n       </para>\n\n       <para>\n        For an <command>INSERT</command> command, the tag is\n        <literal>INSERT <replaceable>oid</replaceable>\n        <replaceable>rows</replaceable></literal>, where\n        <replaceable>rows</replaceable> is the number of rows\n        inserted. <replaceable>oid</replaceable> used to be the object ID\n        of the inserted row if <replaceable>rows</replaceable> was 1\n        and the target table had OIDs, but OIDs system columns are\n        not supported anymore; therefore <replaceable>oid</replaceable>\n        is always 0.\n       </para>\n\n       <para>\n        For a <command>DELETE</command> command, the tag is\n        <literal>DELETE <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows deleted.\n       </para>\n\n       <para>\n        For an <command>UPDATE</command> command, the tag is\n        <literal>UPDATE <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows updated.\n       </para>\n\n       <para>\n        For a <command>SELECT</command> or <command>CREATE TABLE AS</command>\n        command, the tag is <literal>SELECT <replaceable>rows</replaceable></literal>\n        where <replaceable>rows</replaceable> is the number of rows retrieved.\n       </para>\n\n       <para>\n        For a <command>MOVE</command> command, the tag is\n        <literal>MOVE <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows the\n        cursor's position has been changed by.\n       </para>\n\n       <para>\n        For a <command>FETCH</command> command, the tag is\n        <literal>FETCH <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows that\n        have been retrieved from the cursor.\n       </para>\n\n       <para>\n        For a <command>COPY</command> command, the tag is\n        <literal>COPY <replaceable>rows</replaceable></literal> where\n        <replaceable>rows</replaceable> is the number of rows copied.\n        (Note: the row count appears only in\n        <productname>PostgreSQL</productname> 8.2 and later.)\n       </para>\n\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyData (F &amp; B)\n</term>\n<listitem>\n<para>\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('d')\n</term>\n<listitem>\n<para>\n                Identifies the message as <command>COPY</command> data.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                Data that forms part of a <command>COPY</command> data stream.  Messages sent\n                from the backend will always correspond to single data rows,\n                but messages sent by frontends might divide the data stream\n                arbitrarily.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyDone (F &amp; B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('c')\n</term>\n<listitem>\n<para>\n                Identifies the message as a <command>COPY</command>-complete indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyFail (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('f')\n</term>\n<listitem>\n<para>\n                Identifies the message as a <command>COPY</command>-failure indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                An error message to report as the cause of failure.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyInResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('G')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Start Copy In response.\n                The frontend must now send copy-in data (if not\n                prepared to do so, send a CopyFail message).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                0 indicates the overall <command>COPY</command> format is textual (rows\n                separated by newlines, columns separated by separator\n                characters, etc).\n                1 indicates the overall copy format is binary (similar\n                to DataRow format).\n                See <xref linkend=\"sql-copy\"/>\n                for more information.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of columns in the data to be copied\n                (denoted <replaceable>N</replaceable> below).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>N</replaceable>]\n</term>\n<listitem>\n<para>\n                The format codes to be used for each column.\n                Each must presently be zero (text) or one (binary).\n                All must be zero if the overall copy format is textual.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyOutResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('H')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Start Copy Out response.\n                This message will be followed by copy-out data.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                0 indicates the overall <command>COPY</command> format\n                is textual (rows separated by newlines, columns\n                separated by separator characters, etc). 1 indicates\n                the overall copy format is binary (similar to DataRow\n                format). See <xref linkend=\"sql-copy\"/> for more information.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of columns in the data to be copied\n                (denoted <replaceable>N</replaceable> below).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>N</replaceable>]\n</term>\n<listitem>\n<para>\n                The format codes to be used for each column.\n                Each must presently be zero (text) or one (binary).\n                All must be zero if the overall copy format is textual.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nCopyBothResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('W')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Start Copy Both response.\n                This message is used only for Streaming Replication.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                0 indicates the overall <command>COPY</command> format\n                is textual (rows separated by newlines, columns\n                separated by separator characters, etc). 1 indicates\n                the overall copy format is binary (similar to DataRow\n                format). See <xref linkend=\"sql-copy\"/> for more information.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of columns in the data to be copied\n                (denoted <replaceable>N</replaceable> below).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>N</replaceable>]\n</term>\n<listitem>\n<para>\n                The format codes to be used for each column.\n                Each must presently be zero (text) or one (binary).\n                All must be zero if the overall copy format is textual.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nDataRow (B)\n</term>\n<listitem>\n<para>\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('D')\n</term>\n<listitem>\n<para>\n                Identifies the message as a data row.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of column values that follow (possibly zero).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, the following pair of fields appear for each column:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The length of the column value, in bytes (this count\n                does not include itself).  Can be zero.\n                As a special case, -1 indicates a NULL column value.\n                No value bytes follow in the NULL case.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the column, in the format indicated by the\n                associated format code.\n                <replaceable>n</replaceable> is the above length.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nDescribe (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('D')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Describe command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                '<literal>S</literal>' to describe a prepared statement; or\n                '<literal>P</literal>' to describe a portal.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the prepared statement or portal to describe\n                (an empty string selects the unnamed prepared statement\n                or portal).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nEmptyQueryResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('I')\n</term>\n<listitem>\n<para>\n                Identifies the message as a response to an empty query string.\n                (This substitutes for CommandComplete.)\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nErrorResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('E')\n</term>\n<listitem>\n<para>\n                Identifies the message as an error.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        The message body consists of one or more identified fields,\n        followed by a zero byte as a terminator.  Fields can appear in\n        any order.  For each field there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                A code identifying the field type; if zero, this is\n                the message terminator and no string follows.\n                The presently defined field types are listed in\n                <xref linkend=\"protocol-error-fields\"/>.\n                Since more field types might be added in future,\n                frontends should silently ignore fields of unrecognized\n                type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The field value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nExecute (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('E')\n</term>\n<listitem>\n<para>\n                Identifies the message as an Execute command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the portal to execute\n                (an empty string selects the unnamed portal).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Maximum number of rows to return, if portal contains\n                a query that returns rows (ignored otherwise).  Zero\n                denotes <quote>no limit</quote>.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nFlush (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('H')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Flush command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nFunctionCall (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('F')\n</term>\n<listitem>\n<para>\n                Identifies the message as a function call.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Specifies the object ID of the function to call.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of argument format codes that follow\n                (denoted <replaceable>C</replaceable> below).\n                This can be zero to indicate that there are no arguments\n                or that the arguments all use the default format (text);\n                or one, in which case the specified format code is applied\n                to all arguments; or it can equal the actual number of\n                arguments.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16[<replaceable>C</replaceable>]\n</term>\n<listitem>\n<para>\n                The argument format codes.  Each must presently be\n                zero (text) or one (binary).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                Specifies the number of arguments being supplied to the\n                function.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, the following pair of fields appear for each argument:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The length of the argument value, in bytes (this count\n                does not include itself).  Can be zero.\n                As a special case, -1 indicates a NULL argument value.\n                No value bytes follow in the NULL case.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the argument, in the format indicated by the\n                associated format code.\n                <replaceable>n</replaceable> is the above length.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        After the last argument, the following field appears:\n<variablelist>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The format code for the function result. Must presently be\n                zero (text) or one (binary).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nFunctionCallResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('V')\n</term>\n<listitem>\n<para>\n                Identifies the message as a function call result.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The length of the function result value, in bytes (this count\n                does not include itself).  Can be zero.\n                As a special case, -1 indicates a NULL function result.\n                No value bytes follow in the NULL case.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the function result, in the format indicated by\n                the associated format code.\n                <replaceable>n</replaceable> is the above length.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nGSSENCRequest (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(80877104)\n</term>\n<listitem>\n<para>\n                The <acronym>GSSAPI</acronym> Encryption request code.  The value is chosen to contain\n                <literal>1234</literal> in the most significant 16 bits, and <literal>5680</literal> in the\n                least significant 16 bits.  (To avoid confusion, this code\n                must not be the same as any protocol version number.)\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nGSSResponse (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('p')\n</term>\n<listitem>\n<para>\n                Identifies the message as a GSSAPI or SSPI response. Note that\n                this is also used for SASL and password response messages.\n                The exact message type can be deduced from the context.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                GSSAPI/SSPI specific message data.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nNegotiateProtocolVersion (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('v')\n</term>\n<listitem>\n<para>\n                Identifies the message as a protocol version negotiation\n                message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Newest minor protocol version supported by the server\n                for the major protocol version requested by the client.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Number of protocol options not recognized by the server.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Then, for protocol option not recognized by the server, there\n        is the following:\n<variablelist>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The option name.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nNoData (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('n')\n</term>\n<listitem>\n<para>\n                Identifies the message as a no-data indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nNoticeResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('N')\n</term>\n<listitem>\n<para>\n                Identifies the message as a notice.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        The message body consists of one or more identified fields,\n        followed by a zero byte as a terminator.  Fields can appear in\n        any order.  For each field there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                A code identifying the field type; if zero, this is\n                the message terminator and no string follows.\n                The presently defined field types are listed in\n                <xref linkend=\"protocol-error-fields\"/>.\n                Since more field types might be added in future,\n                frontends should silently ignore fields of unrecognized\n                type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The field value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nNotificationResponse (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('A')\n</term>\n<listitem>\n<para>\n                Identifies the message as a notification response.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The process ID of the notifying backend process.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the channel that the notify has been raised on.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The <quote>payload</quote> string passed from the notifying process.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nParameterDescription (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('t')\n</term>\n<listitem>\n<para>\n                Identifies the message as a parameter description.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of parameters used by the statement\n                (can be zero).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Then, for each parameter, there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Specifies the object ID of the parameter data type.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nParameterStatus (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('S')\n</term>\n<listitem>\n<para>\n                Identifies the message as a run-time parameter status report.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the run-time parameter being reported.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The current value of the parameter.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nParse (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('P')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Parse command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The name of the destination prepared statement\n                (an empty string selects the unnamed prepared statement).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The query string to be parsed.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The number of parameter data types specified\n                (can be zero).  Note that this is not an indication of\n                the number of parameters that might appear in the\n                query string, only the number that the frontend wants to\n                prespecify types for.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Then, for each parameter, there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Specifies the object ID of the parameter data type.\n                Placing a zero here is equivalent to leaving the type\n                unspecified.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nParseComplete (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('1')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Parse-complete indicator.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nPasswordMessage (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('p')\n</term>\n<listitem>\n<para>\n                Identifies the message as a password response. Note that\n                this is also used for GSSAPI, SSPI and SASL response messages.\n                The exact message type can be deduced from the context.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The password (encrypted, if requested).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nPortalSuspended (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('s')\n</term>\n<listitem>\n<para>\n                Identifies the message as a portal-suspended indicator.\n                Note this only appears if an Execute message's row-count limit\n                was reached.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nQuery (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('Q')\n</term>\n<listitem>\n<para>\n                Identifies the message as a simple query.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The query string itself.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nReadyForQuery (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('Z')\n</term>\n<listitem>\n<para>\n                Identifies the message type.  ReadyForQuery is sent\n                whenever the backend is ready for a new query cycle.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(5)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte1\n</term>\n<listitem>\n<para>\n                Current backend transaction status indicator.\n                Possible values are '<literal>I</literal>' if idle (not in\n                a transaction block); '<literal>T</literal>' if in a transaction\n                block; or '<literal>E</literal>' if in a failed transaction\n                block (queries will be rejected until block is ended).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nRowDescription (B)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('T')\n</term>\n<listitem>\n<para>\n                Identifies the message as a row description.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                Specifies the number of fields in a row (can be zero).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Then, for each field, there is the following:\n<variablelist>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The field name.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                If the field can be identified as a column of a specific\n                table, the object ID of the table; otherwise zero.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                If the field can be identified as a column of a specific\n                table, the attribute number of the column; otherwise zero.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The object ID of the field's data type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The data type size (see <varname>pg_type.typlen</varname>).\n                Note that negative values denote variable-width types.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                The type modifier (see <varname>pg_attribute.atttypmod</varname>).\n                The meaning of the modifier is type-specific.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                The format code being used for the field.  Currently will\n                be zero (text) or one (binary).  In a RowDescription\n                returned from the statement variant of Describe, the\n                format code is not yet known and will always be zero.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nSASLInitialResponse (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('p')\n</term>\n<listitem>\n<para>\n                Identifies the message as an initial SASL response. Note that\n                this is also used for GSSAPI, SSPI and password response messages.\n                The exact message type is deduced from the context.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of the SASL authentication mechanism that the client\n                selected.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of SASL mechanism specific \"Initial Client Response\" that\n                follows, or -1 if there is no Initial Response.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                SASL mechanism specific \"Initial Response\".\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nSASLResponse (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('p')\n</term>\n<listitem>\n<para>\n                Identifies the message as a SASL response. Note that\n                this is also used for GSSAPI, SSPI and password response messages.\n                The exact message type can be deduced from the context.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                SASL mechanism specific message data.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nSSLRequest (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int32(8)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(80877103)\n</term>\n<listitem>\n<para>\n                The <acronym>SSL</acronym> request code.  The value is chosen to contain\n                <literal>1234</literal> in the most significant 16 bits, and <literal>5679</literal> in the\n                least significant 16 bits.  (To avoid confusion, this code\n                must not be the same as any protocol version number.)\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nStartupMessage (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(196608)\n</term>\n<listitem>\n<para>\n                The protocol version number.  The most significant 16 bits are\n                the major version number (3 for the protocol described here).\n                The least significant 16 bits are the minor version number\n                (0 for the protocol described here).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        The protocol version number is followed by one or more pairs of\n        parameter name and value strings.  A zero byte is required as a\n        terminator after the last name/value pair.\n        Parameters can appear in any\n        order.  <literal>user</literal> is required, others are optional.\n        Each parameter is specified as:\n<variablelist>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The parameter name.  Currently recognized names are:\n\n<variablelist>\n<varlistentry>\n<term>\n                <literal>user</literal>\n</term>\n<listitem>\n<para>\n                        The database user name to connect as.  Required;\n                        there is no default.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n                <literal>database</literal>\n</term>\n<listitem>\n<para>\n                        The database to connect to.  Defaults to the user name.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n                <literal>options</literal>\n</term>\n<listitem>\n<para>\n                        Command-line arguments for the backend.  (This is\n                        deprecated in favor of setting individual run-time\n                        parameters.)  Spaces within this string are\n                        considered to separate arguments, unless escaped with\n                        a backslash (<literal>\\</literal>); write <literal>\\\\</literal> to\n                        represent a literal backslash.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n                <literal>replication</literal>\n</term>\n<listitem>\n<para>\n                        Used to connect in streaming replication mode, where\n                        a small set of replication commands can be issued\n                        instead of SQL statements. Value can be\n                        <literal>true</literal>, <literal>false</literal>, or\n                        <literal>database</literal>, and the default is\n                        <literal>false</literal>. See\n                        <xref linkend=\"protocol-replication\"/> for details.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n                In addition to the above, other parameters may be listed.\n                Parameter names beginning with <literal>_pq_.</literal> are\n                reserved for use as protocol extensions, while others are\n                treated as run-time parameters to be set at backend start\n                time.  Such settings will be applied during backend start\n                (after parsing the command-line arguments if any) and will\n                act as session defaults.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The parameter value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nSync (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('S')\n</term>\n<listitem>\n<para>\n                Identifies the message as a Sync command.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n<varlistentry>\n<term>\nTerminate (F)\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('X')\n</term>\n<listitem>\n<para>\n                Identifies the message as a termination.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32(4)\n</term>\n<listitem>\n<para>\n                Length of message contents in bytes, including self.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n\n</variablelist>\n\n</sect1>\n\n\n<sect1 id=\"protocol-error-fields\">\n<title>Error and Notice Message Fields</title>\n\n<para>\nThis section describes the fields that can appear in ErrorResponse and\nNoticeResponse messages.  Each field type has a single-byte identification\ntoken.  Note that any given field type should appear at most once per\nmessage.\n</para>\n\n<variablelist>\n\n<varlistentry>\n<term>\n<literal>S</literal>\n</term>\n<listitem>\n<para>\n        Severity: the field contents are\n        <literal>ERROR</literal>, <literal>FATAL</literal>, or\n        <literal>PANIC</literal> (in an error message), or\n        <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,\n        <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message),\n        or a localized translation of one of these.  Always present.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>V</literal>\n</term>\n<listitem>\n<para>\n        Severity: the field contents are\n        <literal>ERROR</literal>, <literal>FATAL</literal>, or\n        <literal>PANIC</literal> (in an error message), or\n        <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,\n        <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message).\n        This is identical to the <literal>S</literal> field except\n        that the contents are never localized.  This is present only in\n        messages generated by <productname>PostgreSQL</productname> versions 9.6\n        and later.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>C</literal>\n</term>\n<listitem>\n<para>\n        Code: the SQLSTATE code for the error (see <xref\n        linkend=\"errcodes-appendix\"/>).  Not localizable.  Always present.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>M</literal>\n</term>\n<listitem>\n<para>\n        Message: the primary human-readable error message.\n        This should be accurate but terse (typically one line).\n        Always present.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>D</literal>\n</term>\n<listitem>\n<para>\n        Detail: an optional secondary error message carrying more\n        detail about the problem.  Might run to multiple lines.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>H</literal>\n</term>\n<listitem>\n<para>\n        Hint: an optional suggestion what to do about the problem.\n        This is intended to differ from Detail in that it offers advice\n        (potentially inappropriate) rather than hard facts.\n        Might run to multiple lines.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>P</literal>\n</term>\n<listitem>\n<para>\n        Position: the field value is a decimal ASCII integer, indicating\n        an error cursor position as an index into the original query string.\n        The first character has index 1, and positions are measured in\n        characters not bytes.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>p</literal>\n</term>\n<listitem>\n<para>\n        Internal position: this is defined the same as the <literal>P</literal>\n        field, but it is used when the cursor position refers to an internally\n        generated command rather than the one submitted by the client.\n        The <literal>q</literal> field will always appear when this field appears.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>q</literal>\n</term>\n<listitem>\n<para>\n        Internal query: the text of a failed internally-generated command.\n        This could be, for example, an SQL query issued by a PL/pgSQL function.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>W</literal>\n</term>\n<listitem>\n<para>\n        Where: an indication of the context in which the error occurred.\n        Presently this includes a call stack traceback of active\n        procedural language functions and internally-generated queries.\n        The trace is one entry per line, most recent first.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>s</literal>\n</term>\n<listitem>\n<para>\n        Schema name: if the error was associated with a specific database\n        object, the name of the schema containing that object, if any.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>t</literal>\n</term>\n<listitem>\n<para>\n        Table name: if the error was associated with a specific table, the\n        name of the table.  (Refer to the schema name field for the name of\n        the table's schema.)\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>c</literal>\n</term>\n<listitem>\n<para>\n        Column name: if the error was associated with a specific table column,\n        the name of the column.  (Refer to the schema and table name fields to\n        identify the table.)\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>d</literal>\n</term>\n<listitem>\n<para>\n        Data type name: if the error was associated with a specific data type,\n        the name of the data type.  (Refer to the schema name field for the\n        name of the data type's schema.)\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>n</literal>\n</term>\n<listitem>\n<para>\n        Constraint name: if the error was associated with a specific\n        constraint, the name of the constraint.  Refer to fields listed above\n        for the associated table or domain.  (For this purpose, indexes are\n        treated as constraints, even if they weren't created with constraint\n        syntax.)\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>F</literal>\n</term>\n<listitem>\n<para>\n        File: the file name of the source-code location where the error\n        was reported.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>L</literal>\n</term>\n<listitem>\n<para>\n        Line: the line number of the source-code location where the error\n        was reported.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n<literal>R</literal>\n</term>\n<listitem>\n<para>\n        Routine: the name of the source-code routine reporting the error.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n<note>\n <para>\n  The fields for schema name, table name, column name, data type name, and\n  constraint name are supplied only for a limited number of error types;\n  see <xref linkend=\"errcodes-appendix\"/>.  Frontends should not assume that\n  the presence of any of these fields guarantees the presence of another\n  field.  Core error sources observe the interrelationships noted above, but\n  user-defined functions may use these fields in other ways.  In the same\n  vein, clients should not assume that these fields denote contemporary\n  objects in the current database.\n </para>\n</note>\n\n<para>\nThe client is responsible for formatting displayed information to meet its\nneeds; in particular it should break long lines as needed.  Newline characters\nappearing in the error message fields should be treated as paragraph breaks,\nnot line breaks.\n</para>\n\n</sect1>\n\n<sect1 id=\"protocol-logicalrep-message-formats\">\n<title>Logical Replication Message Formats</title>\n\n<para>\nThis section describes the detailed format of each logical replication\nmessage.  These messages are either returned by the replication slot SQL\ninterface or are sent by a walsender.  In the case of a walsender they are\nencapsulated inside replication protocol WAL messages as described in\n<xref linkend=\"protocol-replication\"/>, and generally obey the same message\nflow as physical replication.\n</para>\n\n<variablelist>\n\n<varlistentry>\n<term>\nBegin\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('B')\n</term>\n<listitem>\n<para>\n                Identifies the message as a begin message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The final LSN of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem>\n<para>\n                Commit timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nMessage\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('M')\n</term>\n<listitem>\n<para>\n                Identifies the message as a logical decoding message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction (only present for streamed transactions).\n                This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                Flags; Either 0 for no flags or 1 if the logical decoding\n                message is transactional.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The LSN of the logical decoding message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                The prefix of the logical decoding message.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of the content.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The content of the logical decoding message.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nCommit\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('C')\n</term>\n<listitem>\n<para>\n                Identifies the message as a commit message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem>\n<para>\n                Flags; currently unused.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The LSN of the commit.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The end LSN of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem>\n<para>\n                Commit timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nOrigin\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('O')\n</term>\n<listitem>\n<para>\n                Identifies the message as an origin message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The LSN of the commit on the origin server.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of the origin.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n\n<para>\n  Note that there can be multiple Origin messages inside a single transaction.\n</para>\n\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nRelation\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('R')\n</term>\n<listitem>\n<para>\n                Identifies the message as a relation message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Namespace (empty string for <literal>pg_catalog</literal>).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Relation name.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                Replica identity setting for the relation (same as\n                <structfield>relreplident</structfield> in <structname>pg_class</structname>).\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                Number of columns.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, the following message part appears for each column (except generated columns):\n<variablelist>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                Flags for the column. Currently can be either 0 for no flags\n                or 1 which marks the column as part of the key.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of the column.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the column's data type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Type modifier of the column (<structfield>atttypmod</structfield>).\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nType\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('Y')\n</term>\n<listitem>\n<para>\n                Identifies the message as a type message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the data type.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Namespace (empty string for <literal>pg_catalog</literal>).\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        String\n</term>\n<listitem>\n<para>\n                Name of the data type.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nInsert\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('I')\n</term>\n<listitem>\n<para>\n                Identifies the message as an insert message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction (only present for streamed transactions).\n                This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation corresponding to the ID in the relation\n                message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte1('N')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData message as a new tuple.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        TupleData\n</term>\n<listitem>\n<para>\n                TupleData message part representing the contents of new tuple.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nUpdate\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('U')\n</term>\n<listitem>\n<para>\n                Identifies the message as an update message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation corresponding to the ID in the relation\n                message.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('K')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData submessage as a key.\n                This field is optional and is only present if\n                the update changed data in any of the column(s) that are\n                part of the REPLICA IDENTITY index.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('O')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData submessage as an old tuple.\n                This field is optional and is only present if table in which\n                the update happened has REPLICA IDENTITY set to FULL.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        TupleData\n</term>\n<listitem>\n<para>\n                TupleData message part representing the contents of the old tuple\n                or primary key. Only present if the previous 'O' or 'K' part\n                is present.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('N')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData message as a new tuple.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        TupleData\n</term>\n<listitem>\n<para>\n                TupleData message part representing the contents of a new tuple.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n\n<para>\n    The Update message may contain either a 'K' message part or an 'O' message part\n    or neither of them, but never both of them.\n</para>\n\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nDelete\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('D')\n</term>\n<listitem>\n<para>\n                Identifies the message as a delete message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation corresponding to the ID in the relation\n                message.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('K')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData submessage as a key.\n                This field is present if the table in which the delete has\n                happened uses an index as REPLICA IDENTITY.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Byte1('O')\n</term>\n<listitem>\n<para>\n                Identifies the following TupleData message as an old tuple.\n                This field is present if the table in which the delete\n                happened has REPLICA IDENTITY set to FULL.\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        TupleData\n</term>\n<listitem>\n<para>\n                TupleData message part representing the contents of the old tuple\n                or primary key, depending on the previous field.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n</para>\n\n<para>\n    The Delete message may contain either a 'K' message part or an 'O' message part,\n    but never both of them.\n</para>\n\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nTruncate\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('T')\n</term>\n<listitem>\n<para>\n                Identifies the message as a truncate message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n               Xid of the transaction (only present for streamed transactions).\n               This field is available since protocol version 2.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Number of relations\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                Option bits for <command>TRUNCATE</command>:\n                1 for <literal>CASCADE</literal>, 2 for <literal>RESTART IDENTITY</literal>\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (Oid)\n</term>\n<listitem>\n<para>\n                OID of the relation corresponding to the ID in the relation\n                message.  This field is repeated for each relation.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n<para>\n\nThe following messages (Stream Start, Stream Stop, Stream Commit, and\nStream Abort) are available since protocol version 2.\n\n</para>\n\n<variablelist>\n\n<varlistentry>\n<term>\nStream Start\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('S')\n</term>\n<listitem>\n<para>\n                Identifies the message as a stream start message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8\n</term>\n<listitem>\n<para>\n                A value of 1 indicates this is the first stream segment for\n                this XID, 0 for any other stream segment.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nStream Stop\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('E')\n</term>\n<listitem>\n<para>\n                Identifies the message as a stream stop message.\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nStream Commit\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('c')\n</term>\n<listitem>\n<para>\n                Identifies the message as a stream commit message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem>\n<para>\n                Flags; currently unused.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The LSN of the commit.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem>\n<para>\n                The end LSN of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem>\n<para>\n                Commit timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\nStream Abort\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('A')\n</term>\n<listitem>\n<para>\n                Identifies the message as a stream abort message.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the transaction.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem>\n<para>\n                Xid of the subtransaction (will be same as xid of the transaction for top-level\n                transactions).\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n<para>\nThe following messages (Begin Prepare, Prepare, Commit Prepared, Rollback Prepared, Stream Prepare)\nare available since protocol version 3.\n</para>\n\n<variablelist>\n\n<varlistentry>\n\n<term>Begin Prepare</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('b')</term>\n<listitem><para>\n                Identifies the message as the beginning of a two-phase transaction message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The LSN of the prepare.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Prepare timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n\n<term>Prepare</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('P')</term>\n<listitem><para>\n                Identifies the message as a two-phase prepared transaction message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem><para>\n                Flags; currently unused.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The LSN of the prepare.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Prepare timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n\n<term>Commit Prepared</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('K')</term>\n<listitem><para>\n                Identifies the message as the commit of a two-phase transaction message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem><para>\n                Flags; currently unused.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The LSN of the commit prepared.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the commit prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Commit timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n\n<term>Rollback Prepared</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('r')</term>\n<listitem><para>\n                Identifies the message as the rollback of a two-phase transaction message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem><para>\n                Flags; currently unused.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the rollback prepared transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Prepare timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Rollback timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n<varlistentry>\n\n<term>Stream Prepare</term>\n<listitem>\n<para>\n\n<variablelist>\n\n<varlistentry>\n<term>Byte1('p')</term>\n<listitem><para>\n                Identifies the message as a two-phase stream prepare message.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int8(0)\n</term>\n<listitem><para>\n                Flags; currently unused.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The LSN of the prepare.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (XLogRecPtr)\n</term>\n<listitem><para>\n                The end LSN of the prepare transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int64 (TimestampTz)\n</term>\n<listitem><para>\n                Prepare timestamp of the transaction. The value is in number\n                of microseconds since PostgreSQL epoch (2000-01-01).\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>\n        Int32 (TransactionId)\n</term>\n<listitem><para>\n                Xid of the transaction.\n</para></listitem>\n</varlistentry>\n\n<varlistentry>\n<term>String</term>\n<listitem><para>\n                The user defined GID of the two-phase transaction.\n</para></listitem>\n</varlistentry>\n\n</variablelist>\n\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n<para>\n\nThe following message parts are shared by the above messages.\n\n</para>\n\n<variablelist>\n\n<varlistentry>\n<term>\nTupleData\n</term>\n<listitem>\n<para>\n\n<variablelist>\n<varlistentry>\n<term>\n        Int16\n</term>\n<listitem>\n<para>\n                Number of columns.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Next, one of the following submessages appears for each column (except generated columns):\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('n')\n</term>\n<listitem>\n<para>\n                Identifies the data as NULL value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Or\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('u')\n</term>\n<listitem>\n<para>\n                Identifies unchanged TOASTed value (the actual value is not\n                sent).\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Or\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('t')\n</term>\n<listitem>\n<para>\n                Identifies the data as text formatted value.\n</para>\n</listitem>\n</varlistentry>\n</variablelist>\n        Or\n<variablelist>\n<varlistentry>\n<term>\n        Byte1('b')\n</term>\n<listitem>\n<para>\n                Identifies the data as binary formatted value.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Int32\n</term>\n<listitem>\n<para>\n                Length of the column value.\n</para>\n</listitem>\n</varlistentry>\n<varlistentry>\n<term>\n        Byte<replaceable>n</replaceable>\n</term>\n<listitem>\n<para>\n                The value of the column, either in binary or in text format.\n                (As specified in the preceding format byte).\n                <replaceable>n</replaceable> is the above length.\n\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n</para>\n</listitem>\n</varlistentry>\n\n</variablelist>\n\n</sect1>\n\n<sect1 id=\"protocol-changes\">\n<title>Summary of Changes since Protocol 2.0</title>\n\n<para>\nThis section provides a quick checklist of changes, for the benefit of\ndevelopers trying to update existing client libraries to protocol 3.0.\n</para>\n\n<para>\nThe initial startup packet uses a flexible list-of-strings format\ninstead of a fixed format.  Notice that session default values for run-time\nparameters can now be specified directly in the startup packet.  (Actually,\nyou could do that before using the <literal>options</literal> field, but given the\nlimited width of <literal>options</literal> and the lack of any way to quote\nwhitespace in the values, it wasn't a very safe technique.)\n</para>\n\n<para>\nAll messages now have a length count immediately following the message type\nbyte (except for startup packets, which have no type byte).  Also note that\nPasswordMessage now has a type byte.\n</para>\n\n<para>\nErrorResponse and NoticeResponse ('<literal>E</literal>' and '<literal>N</literal>')\nmessages now contain multiple fields, from which the client code can\nassemble an error message of the desired level of verbosity.  Note that\nindividual fields will typically not end with a newline, whereas the single\nstring sent in the older protocol always did.\n</para>\n\n<para>\nThe ReadyForQuery ('<literal>Z</literal>') message includes a transaction status\nindicator.\n</para>\n\n<para>\nThe distinction between BinaryRow and DataRow message types is gone; the\nsingle DataRow message type serves for returning data in all formats.\nNote that the layout of DataRow has changed to make it easier to parse.\nAlso, the representation of binary values has changed: it is no longer\ndirectly tied to the server's internal representation.\n</para>\n\n<para>\nThere is a new <quote>extended query</quote> sub-protocol, which adds the frontend\nmessage types Parse, Bind, Execute, Describe, Close, Flush, and Sync, and the\nbackend message types ParseComplete, BindComplete, PortalSuspended,\nParameterDescription, NoData, and CloseComplete.  Existing clients do not\nhave to concern themselves with this sub-protocol, but making use of it\nmight allow improvements in performance or functionality.\n</para>\n\n<para>\n<command>COPY</command> data is now encapsulated into CopyData and CopyDone messages.  There\nis a well-defined way to recover from errors during <command>COPY</command>.  The special\n<quote><literal>\\.</literal></quote> last line is not needed anymore, and is not sent\nduring <command>COPY OUT</command>.\n(It is still recognized as a terminator during <command>COPY IN</command>, but its use is\ndeprecated and will eventually be removed.)  Binary <command>COPY</command> is supported.\nThe CopyInResponse and CopyOutResponse messages include fields indicating\nthe number of columns and the format of each column.\n</para>\n\n<para>\nThe layout of FunctionCall and FunctionCallResponse messages has changed.\nFunctionCall can now support passing NULL arguments to functions.  It also\ncan handle passing parameters and retrieving results in either text or\nbinary format.  There is no longer any reason to consider FunctionCall a\npotential security hole, since it does not offer direct access to internal\nserver data representations.\n</para>\n\n<para>\nThe backend sends ParameterStatus ('<literal>S</literal>') messages during connection\nstartup for all parameters it considers interesting to the client library.\nSubsequently, a ParameterStatus message is sent whenever the active value\nchanges for any of these parameters.\n</para>\n\n<para>\nThe RowDescription ('<literal>T</literal>') message carries new table OID and column\nnumber fields for each column of the described row.  It also shows the format\ncode for each column.\n</para>\n\n<para>\nThe CursorResponse ('<literal>P</literal>') message is no longer generated by\nthe backend.\n</para>\n\n<para>\nThe NotificationResponse ('<literal>A</literal>') message has an additional string\nfield, which can carry a <quote>payload</quote> string passed\nfrom the <command>NOTIFY</command> event sender.\n</para>\n\n<para>\nThe EmptyQueryResponse ('<literal>I</literal>') message used to include an empty\nstring parameter; this has been removed.\n</para>\n\n</sect1>\n\n</chapter>\n", "/*-------------------------------------------------------------------------\n *\n * fe-connect.c\n *\t  functions related to setting up a connection to the backend\n *\n * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/interfaces/libpq/fe-connect.c\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"postgres_fe.h\"\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"common/ip.h\"\n#include \"common/link-canary.h\"\n#include \"common/scram-common.h\"\n#include \"common/string.h\"\n#include \"fe-auth.h\"\n#include \"libpq-fe.h\"\n#include \"libpq-int.h\"\n#include \"mb/pg_wchar.h\"\n#include \"pg_config_paths.h\"\n#include \"port/pg_bswap.h\"\n\n#ifdef WIN32\n#include \"win32.h\"\n#ifdef _WIN32_IE\n#undef _WIN32_IE\n#endif\n#define _WIN32_IE 0x0500\n#ifdef near\n#undef near\n#endif\n#define near\n#include <shlobj.h>\n#ifdef _MSC_VER\t\t\t\t\t/* mstcpip.h is missing on mingw */\n#include <mstcpip.h>\n#endif\n#else\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#ifdef HAVE_NETINET_TCP_H\n#include <netinet/tcp.h>\n#endif\n#endif\n\n#ifdef ENABLE_THREAD_SAFETY\n#ifdef WIN32\n#include \"pthread-win32.h\"\n#else\n#include <pthread.h>\n#endif\n#endif\n\n#ifdef USE_LDAP\n#ifdef WIN32\n#include <winldap.h>\n#else\n/* OpenLDAP deprecates RFC 1823, but we want standard conformance */\n#define LDAP_DEPRECATED 1\n#include <ldap.h>\ntypedef struct timeval LDAP_TIMEVAL;\n#endif\nstatic int\tldapServiceLookup(const char *purl, PQconninfoOption *options,\n\t\t\t\t\t\t\t  PQExpBuffer errorMessage);\n#endif\n\n#ifndef WIN32\n#define PGPASSFILE \".pgpass\"\n#else\n#define PGPASSFILE \"pgpass.conf\"\n#endif\n\n/*\n * Pre-9.0 servers will return this SQLSTATE if asked to set\n * application_name in a startup packet.  We hard-wire the value rather\n * than looking into errcodes.h since it reflects historical behavior\n * rather than that of the current code.\n */\n#define ERRCODE_APPNAME_UNKNOWN \"42704\"\n\n/* This is part of the protocol so just define it */\n#define ERRCODE_INVALID_PASSWORD \"28P01\"\n/* This too */\n#define ERRCODE_CANNOT_CONNECT_NOW \"57P03\"\n\n/*\n * Cope with the various platform-specific ways to spell TCP keepalive socket\n * options.  This doesn't cover Windows, which as usual does its own thing.\n */\n#if defined(TCP_KEEPIDLE)\n/* TCP_KEEPIDLE is the name of this option on Linux and *BSD */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPIDLE\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPIDLE\"\n#elif defined(TCP_KEEPALIVE_THRESHOLD)\n/* TCP_KEEPALIVE_THRESHOLD is the name of this option on Solaris >= 11 */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPALIVE_THRESHOLD\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPALIVE_THRESHOLD\"\n#elif defined(TCP_KEEPALIVE) && defined(__darwin__)\n/* TCP_KEEPALIVE is the name of this option on macOS */\n/* Caution: Solaris has this symbol but it means something different */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPALIVE\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPALIVE\"\n#endif\n\n/*\n * fall back options if they are not specified by arguments or defined\n * by environment variables\n */\n#define DefaultHost\t\t\"localhost\"\n#define DefaultOption\t\"\"\n#ifdef USE_SSL\n#define DefaultChannelBinding\t\"prefer\"\n#else\n#define DefaultChannelBinding\t\"disable\"\n#endif\n#define DefaultTargetSessionAttrs\t\"any\"\n#ifdef USE_SSL\n#define DefaultSSLMode \"prefer\"\n#else\n#define DefaultSSLMode\t\"disable\"\n#endif\n#ifdef ENABLE_GSS\n#include \"fe-gssapi-common.h\"\n#define DefaultGSSMode \"prefer\"\n#else\n#define DefaultGSSMode \"disable\"\n#endif\n\n/* ----------\n * Definition of the conninfo parameters and their fallback resources.\n *\n * If Environment-Var and Compiled-in are specified as NULL, no\n * fallback is available. If after all no value can be determined\n * for an option, an error is returned.\n *\n * The value for the username is treated specially in conninfo_add_defaults.\n * If the value is not obtained any other way, the username is determined\n * by pg_fe_getauthname().\n *\n * The Label and Disp-Char entries are provided for applications that\n * want to use PQconndefaults() to create a generic database connection\n * dialog. Disp-Char is defined as follows:\n *\t\t\"\"\t\tNormal input field\n *\t\t\"*\"\t\tPassword field - hide value\n *\t\t\"D\"\t\tDebug option - don't show by default\n *\n * PQconninfoOptions[] is a constant static array that we use to initialize\n * a dynamically allocated working copy.  All the \"val\" fields in\n * PQconninfoOptions[] *must* be NULL.  In a working copy, non-null \"val\"\n * fields point to malloc'd strings that should be freed when the working\n * array is freed (see PQconninfoFree).\n *\n * The first part of each struct is identical to the one in libpq-fe.h,\n * which is required since we memcpy() data between the two!\n * ----------\n */\ntypedef struct _internalPQconninfoOption\n{\n\tchar\t   *keyword;\t\t/* The keyword of the option\t\t\t*/\n\tchar\t   *envvar;\t\t\t/* Fallback environment variable name\t*/\n\tchar\t   *compiled;\t\t/* Fallback compiled in default value\t*/\n\tchar\t   *val;\t\t\t/* Option's current value, or NULL\t\t*/\n\tchar\t   *label;\t\t\t/* Label for field in connect dialog\t*/\n\tchar\t   *dispchar;\t\t/* Indicates how to display this field in a\n\t\t\t\t\t\t\t\t * connect dialog. Values are: \"\" Display\n\t\t\t\t\t\t\t\t * entered value as is \"*\" Password field -\n\t\t\t\t\t\t\t\t * hide value \"D\"  Debug option - don't show\n\t\t\t\t\t\t\t\t * by default */\n\tint\t\t\tdispsize;\t\t/* Field size in characters for dialog\t*/\n\t/* ---\n\t * Anything above this comment must be synchronized with\n\t * PQconninfoOption in libpq-fe.h, since we memcpy() data\n\t * between them!\n\t * ---\n\t */\n\toff_t\t\tconnofs;\t\t/* Offset into PGconn struct, -1 if not there */\n} internalPQconninfoOption;\n\nstatic const internalPQconninfoOption PQconninfoOptions[] = {\n\t{\"service\", \"PGSERVICE\", NULL, NULL,\n\t\"Database-Service\", \"\", 20, -1},\n\n\t{\"user\", \"PGUSER\", NULL, NULL,\n\t\t\"Database-User\", \"\", 20,\n\toffsetof(struct pg_conn, pguser)},\n\n\t{\"password\", \"PGPASSWORD\", NULL, NULL,\n\t\t\"Database-Password\", \"*\", 20,\n\toffsetof(struct pg_conn, pgpass)},\n\n\t{\"passfile\", \"PGPASSFILE\", NULL, NULL,\n\t\t\"Database-Password-File\", \"\", 64,\n\toffsetof(struct pg_conn, pgpassfile)},\n\n\t{\"channel_binding\", \"PGCHANNELBINDING\", DefaultChannelBinding, NULL,\n\t\t\"Channel-Binding\", \"\", 8,\t/* sizeof(\"require\") == 8 */\n\toffsetof(struct pg_conn, channel_binding)},\n\n\t{\"connect_timeout\", \"PGCONNECT_TIMEOUT\", NULL, NULL,\n\t\t\"Connect-timeout\", \"\", 10,\t/* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, connect_timeout)},\n\n\t{\"dbname\", \"PGDATABASE\", NULL, NULL,\n\t\t\"Database-Name\", \"\", 20,\n\toffsetof(struct pg_conn, dbName)},\n\n\t{\"host\", \"PGHOST\", NULL, NULL,\n\t\t\"Database-Host\", \"\", 40,\n\toffsetof(struct pg_conn, pghost)},\n\n\t{\"hostaddr\", \"PGHOSTADDR\", NULL, NULL,\n\t\t\"Database-Host-IP-Address\", \"\", 45,\n\toffsetof(struct pg_conn, pghostaddr)},\n\n\t{\"port\", \"PGPORT\", DEF_PGPORT_STR, NULL,\n\t\t\"Database-Port\", \"\", 6,\n\toffsetof(struct pg_conn, pgport)},\n\n\t{\"client_encoding\", \"PGCLIENTENCODING\", NULL, NULL,\n\t\t\"Client-Encoding\", \"\", 10,\n\toffsetof(struct pg_conn, client_encoding_initial)},\n\n\t{\"options\", \"PGOPTIONS\", DefaultOption, NULL,\n\t\t\"Backend-Options\", \"\", 40,\n\toffsetof(struct pg_conn, pgoptions)},\n\n\t{\"application_name\", \"PGAPPNAME\", NULL, NULL,\n\t\t\"Application-Name\", \"\", 64,\n\toffsetof(struct pg_conn, appname)},\n\n\t{\"fallback_application_name\", NULL, NULL, NULL,\n\t\t\"Fallback-Application-Name\", \"\", 64,\n\toffsetof(struct pg_conn, fbappname)},\n\n\t{\"keepalives\", NULL, NULL, NULL,\n\t\t\"TCP-Keepalives\", \"\", 1,\t/* should be just '0' or '1' */\n\toffsetof(struct pg_conn, keepalives)},\n\n\t{\"keepalives_idle\", NULL, NULL, NULL,\n\t\t\"TCP-Keepalives-Idle\", \"\", 10,\t/* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, keepalives_idle)},\n\n\t{\"keepalives_interval\", NULL, NULL, NULL,\n\t\t\"TCP-Keepalives-Interval\", \"\", 10,\t/* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, keepalives_interval)},\n\n\t{\"keepalives_count\", NULL, NULL, NULL,\n\t\t\"TCP-Keepalives-Count\", \"\", 10, /* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, keepalives_count)},\n\n\t{\"tcp_user_timeout\", NULL, NULL, NULL,\n\t\t\"TCP-User-Timeout\", \"\", 10, /* strlen(INT32_MAX) == 10 */\n\toffsetof(struct pg_conn, pgtcp_user_timeout)},\n\n\t/*\n\t * ssl options are allowed even without client SSL support because the\n\t * client can still handle SSL modes \"disable\" and \"allow\". Other\n\t * parameters have no effect on non-SSL connections, so there is no reason\n\t * to exclude them since none of them are mandatory.\n\t */\n\t{\"sslmode\", \"PGSSLMODE\", DefaultSSLMode, NULL,\n\t\t\"SSL-Mode\", \"\", 12,\t\t/* sizeof(\"verify-full\") == 12 */\n\toffsetof(struct pg_conn, sslmode)},\n\n\t{\"sslcompression\", \"PGSSLCOMPRESSION\", \"0\", NULL,\n\t\t\"SSL-Compression\", \"\", 1,\n\toffsetof(struct pg_conn, sslcompression)},\n\n\t{\"sslcert\", \"PGSSLCERT\", NULL, NULL,\n\t\t\"SSL-Client-Cert\", \"\", 64,\n\toffsetof(struct pg_conn, sslcert)},\n\n\t{\"sslkey\", \"PGSSLKEY\", NULL, NULL,\n\t\t\"SSL-Client-Key\", \"\", 64,\n\toffsetof(struct pg_conn, sslkey)},\n\n\t{\"sslpassword\", NULL, NULL, NULL,\n\t\t\"SSL-Client-Key-Password\", \"*\", 20,\n\toffsetof(struct pg_conn, sslpassword)},\n\n\t{\"sslrootcert\", \"PGSSLROOTCERT\", NULL, NULL,\n\t\t\"SSL-Root-Certificate\", \"\", 64,\n\toffsetof(struct pg_conn, sslrootcert)},\n\n\t{\"sslcrl\", \"PGSSLCRL\", NULL, NULL,\n\t\t\"SSL-Revocation-List\", \"\", 64,\n\toffsetof(struct pg_conn, sslcrl)},\n\n\t{\"sslcrldir\", \"PGSSLCRLDIR\", NULL, NULL,\n\t\t\"SSL-Revocation-List-Dir\", \"\", 64,\n\toffsetof(struct pg_conn, sslcrldir)},\n\n\t{\"sslsni\", \"PGSSLSNI\", \"1\", NULL,\n\t\t\"SSL-SNI\", \"\", 1,\n\toffsetof(struct pg_conn, sslsni)},\n\n\t{\"requirepeer\", \"PGREQUIREPEER\", NULL, NULL,\n\t\t\"Require-Peer\", \"\", 10,\n\toffsetof(struct pg_conn, requirepeer)},\n\n\t{\"ssl_min_protocol_version\", \"PGSSLMINPROTOCOLVERSION\", \"TLSv1.2\", NULL,\n\t\t\"SSL-Minimum-Protocol-Version\", \"\", 8,\t/* sizeof(\"TLSv1.x\") == 8 */\n\toffsetof(struct pg_conn, ssl_min_protocol_version)},\n\n\t{\"ssl_max_protocol_version\", \"PGSSLMAXPROTOCOLVERSION\", NULL, NULL,\n\t\t\"SSL-Maximum-Protocol-Version\", \"\", 8,\t/* sizeof(\"TLSv1.x\") == 8 */\n\toffsetof(struct pg_conn, ssl_max_protocol_version)},\n\n\t/*\n\t * As with SSL, all GSS options are exposed even in builds that don't have\n\t * support.\n\t */\n\t{\"gssencmode\", \"PGGSSENCMODE\", DefaultGSSMode, NULL,\n\t\t\"GSSENC-Mode\", \"\", 8,\t/* sizeof(\"disable\") == 8 */\n\toffsetof(struct pg_conn, gssencmode)},\n\n\t/* Kerberos and GSSAPI authentication support specifying the service name */\n\t{\"krbsrvname\", \"PGKRBSRVNAME\", PG_KRB_SRVNAM, NULL,\n\t\t\"Kerberos-service-name\", \"\", 20,\n\toffsetof(struct pg_conn, krbsrvname)},\n\n\t{\"gsslib\", \"PGGSSLIB\", NULL, NULL,\n\t\t\"GSS-library\", \"\", 7,\t/* sizeof(\"gssapi\") == 7 */\n\toffsetof(struct pg_conn, gsslib)},\n\n\t{\"replication\", NULL, NULL, NULL,\n\t\t\"Replication\", \"D\", 5,\n\toffsetof(struct pg_conn, replication)},\n\n\t{\"target_session_attrs\", \"PGTARGETSESSIONATTRS\",\n\t\tDefaultTargetSessionAttrs, NULL,\n\t\t\"Target-Session-Attrs\", \"\", 15, /* sizeof(\"prefer-standby\") = 15 */\n\toffsetof(struct pg_conn, target_session_attrs)},\n\n\t/* Terminating entry --- MUST BE LAST */\n\t{NULL, NULL, NULL, NULL,\n\tNULL, NULL, 0}\n};\n\nstatic const PQEnvironmentOption EnvironmentOptions[] =\n{\n\t/* common user-interface settings */\n\t{\n\t\t\"PGDATESTYLE\", \"datestyle\"\n\t},\n\t{\n\t\t\"PGTZ\", \"timezone\"\n\t},\n\t/* internal performance-related settings */\n\t{\n\t\t\"PGGEQO\", \"geqo\"\n\t},\n\t{\n\t\tNULL, NULL\n\t}\n};\n\n/* The connection URI must start with either of the following designators: */\nstatic const char uri_designator[] = \"postgresql://\";\nstatic const char short_uri_designator[] = \"postgres://\";\n\nstatic bool connectOptions1(PGconn *conn, const char *conninfo);\nstatic bool connectOptions2(PGconn *conn);\nstatic int\tconnectDBStart(PGconn *conn);\nstatic int\tconnectDBComplete(PGconn *conn);\nstatic PGPing internal_ping(PGconn *conn);\nstatic PGconn *makeEmptyPGconn(void);\nstatic bool fillPGconn(PGconn *conn, PQconninfoOption *connOptions);\nstatic void freePGconn(PGconn *conn);\nstatic void closePGconn(PGconn *conn);\nstatic void release_conn_addrinfo(PGconn *conn);\nstatic void sendTerminateConn(PGconn *conn);\nstatic PQconninfoOption *conninfo_init(PQExpBuffer errorMessage);\nstatic PQconninfoOption *parse_connection_string(const char *conninfo,\n\t\t\t\t\t\t\t\t\t\t\t\t PQExpBuffer errorMessage, bool use_defaults);\nstatic int\turi_prefix_length(const char *connstr);\nstatic bool recognized_connection_string(const char *connstr);\nstatic PQconninfoOption *conninfo_parse(const char *conninfo,\n\t\t\t\t\t\t\t\t\t\tPQExpBuffer errorMessage, bool use_defaults);\nstatic PQconninfoOption *conninfo_array_parse(const char *const *keywords,\n\t\t\t\t\t\t\t\t\t\t\t  const char *const *values, PQExpBuffer errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  bool use_defaults, int expand_dbname);\nstatic bool conninfo_add_defaults(PQconninfoOption *options,\n\t\t\t\t\t\t\t\t  PQExpBuffer errorMessage);\nstatic PQconninfoOption *conninfo_uri_parse(const char *uri,\n\t\t\t\t\t\t\t\t\t\t\tPQExpBuffer errorMessage, bool use_defaults);\nstatic bool conninfo_uri_parse_options(PQconninfoOption *options,\n\t\t\t\t\t\t\t\t\t   const char *uri, PQExpBuffer errorMessage);\nstatic bool conninfo_uri_parse_params(char *params,\n\t\t\t\t\t\t\t\t\t  PQconninfoOption *connOptions,\n\t\t\t\t\t\t\t\t\t  PQExpBuffer errorMessage);\nstatic char *conninfo_uri_decode(const char *str, PQExpBuffer errorMessage);\nstatic bool get_hexdigit(char digit, int *value);\nstatic const char *conninfo_getval(PQconninfoOption *connOptions,\n\t\t\t\t\t\t\t\t   const char *keyword);\nstatic PQconninfoOption *conninfo_storeval(PQconninfoOption *connOptions,\n\t\t\t\t\t\t\t\t\t\t   const char *keyword, const char *value,\n\t\t\t\t\t\t\t\t\t\t   PQExpBuffer errorMessage, bool ignoreMissing, bool uri_decode);\nstatic PQconninfoOption *conninfo_find(PQconninfoOption *connOptions,\n\t\t\t\t\t\t\t\t\t   const char *keyword);\nstatic void defaultNoticeReceiver(void *arg, const PGresult *res);\nstatic void defaultNoticeProcessor(void *arg, const char *message);\nstatic int\tparseServiceInfo(PQconninfoOption *options,\n\t\t\t\t\t\t\t PQExpBuffer errorMessage);\nstatic int\tparseServiceFile(const char *serviceFile,\n\t\t\t\t\t\t\t const char *service,\n\t\t\t\t\t\t\t PQconninfoOption *options,\n\t\t\t\t\t\t\t PQExpBuffer errorMessage,\n\t\t\t\t\t\t\t bool *group_found);\nstatic char *pwdfMatchesString(char *buf, const char *token);\nstatic char *passwordFromFile(const char *hostname, const char *port, const char *dbname,\n\t\t\t\t\t\t\t  const char *username, const char *pgpassfile);\nstatic void pgpassfileWarning(PGconn *conn);\nstatic void default_threadlock(int acquire);\nstatic bool sslVerifyProtocolVersion(const char *version);\nstatic bool sslVerifyProtocolRange(const char *min, const char *max);\n\n\n/* global variable because fe-auth.c needs to access it */\npgthreadlock_t pg_g_threadlock = default_threadlock;\n\n\n/*\n *\t\tpqDropConnection\n *\n * Close any physical connection to the server, and reset associated\n * state inside the connection object.  We don't release state that\n * would be needed to reconnect, though, nor local state that might still\n * be useful later.\n *\n * We can always flush the output buffer, since there's no longer any hope\n * of sending that data.  However, unprocessed input data might still be\n * valuable, so the caller must tell us whether to flush that or not.\n */\nvoid\npqDropConnection(PGconn *conn, bool flushInput)\n{\n\t/* Drop any SSL state */\n\tpqsecure_close(conn);\n\n\t/* Close the socket itself */\n\tif (conn->sock != PGINVALID_SOCKET)\n\t\tclosesocket(conn->sock);\n\tconn->sock = PGINVALID_SOCKET;\n\n\t/* Optionally discard any unread data */\n\tif (flushInput)\n\t\tconn->inStart = conn->inCursor = conn->inEnd = 0;\n\n\t/* Always discard any unsent data */\n\tconn->outCount = 0;\n\n\t/* Free authentication/encryption state */\n#ifdef ENABLE_GSS\n\t{\n\t\tOM_uint32\tmin_s;\n\n\t\tif (conn->gcred != GSS_C_NO_CREDENTIAL)\n\t\t{\n\t\t\tgss_release_cred(&min_s, &conn->gcred);\n\t\t\tconn->gcred = GSS_C_NO_CREDENTIAL;\n\t\t}\n\t\tif (conn->gctx)\n\t\t\tgss_delete_sec_context(&min_s, &conn->gctx, GSS_C_NO_BUFFER);\n\t\tif (conn->gtarg_nam)\n\t\t\tgss_release_name(&min_s, &conn->gtarg_nam);\n\t\tif (conn->gss_SendBuffer)\n\t\t{\n\t\t\tfree(conn->gss_SendBuffer);\n\t\t\tconn->gss_SendBuffer = NULL;\n\t\t}\n\t\tif (conn->gss_RecvBuffer)\n\t\t{\n\t\t\tfree(conn->gss_RecvBuffer);\n\t\t\tconn->gss_RecvBuffer = NULL;\n\t\t}\n\t\tif (conn->gss_ResultBuffer)\n\t\t{\n\t\t\tfree(conn->gss_ResultBuffer);\n\t\t\tconn->gss_ResultBuffer = NULL;\n\t\t}\n\t\tconn->gssenc = false;\n\t}\n#endif\n#ifdef ENABLE_SSPI\n\tif (conn->sspitarget)\n\t{\n\t\tfree(conn->sspitarget);\n\t\tconn->sspitarget = NULL;\n\t}\n\tif (conn->sspicred)\n\t{\n\t\tFreeCredentialsHandle(conn->sspicred);\n\t\tfree(conn->sspicred);\n\t\tconn->sspicred = NULL;\n\t}\n\tif (conn->sspictx)\n\t{\n\t\tDeleteSecurityContext(conn->sspictx);\n\t\tfree(conn->sspictx);\n\t\tconn->sspictx = NULL;\n\t}\n\tconn->usesspi = 0;\n#endif\n\tif (conn->sasl_state)\n\t{\n\t\tconn->sasl->free(conn->sasl_state);\n\t\tconn->sasl_state = NULL;\n\t}\n}\n\n/*\n * pqFreeCommandQueue\n * Free all the entries of PGcmdQueueEntry queue passed.\n */\nstatic void\npqFreeCommandQueue(PGcmdQueueEntry *queue)\n{\n\twhile (queue != NULL)\n\t{\n\t\tPGcmdQueueEntry *cur = queue;\n\n\t\tqueue = cur->next;\n\t\tif (cur->query)\n\t\t\tfree(cur->query);\n\t\tfree(cur);\n\t}\n}\n\n/*\n *\t\tpqDropServerData\n *\n * Clear all connection state data that was received from (or deduced about)\n * the server.  This is essential to do between connection attempts to\n * different servers, else we may incorrectly hold over some data from the\n * old server.\n *\n * It would be better to merge this into pqDropConnection, perhaps, but\n * right now we cannot because that function is called immediately on\n * detection of connection loss (cf. pqReadData, for instance).  This data\n * should be kept until we are actually starting a new connection.\n */\nstatic void\npqDropServerData(PGconn *conn)\n{\n\tPGnotify   *notify;\n\tpgParameterStatus *pstatus;\n\n\t/* Forget pending notifies */\n\tnotify = conn->notifyHead;\n\twhile (notify != NULL)\n\t{\n\t\tPGnotify   *prev = notify;\n\n\t\tnotify = notify->next;\n\t\tfree(prev);\n\t}\n\tconn->notifyHead = conn->notifyTail = NULL;\n\n\tpqFreeCommandQueue(conn->cmd_queue_head);\n\tconn->cmd_queue_head = conn->cmd_queue_tail = NULL;\n\n\tpqFreeCommandQueue(conn->cmd_queue_recycle);\n\tconn->cmd_queue_recycle = NULL;\n\n\t/* Reset ParameterStatus data, as well as variables deduced from it */\n\tpstatus = conn->pstatus;\n\twhile (pstatus != NULL)\n\t{\n\t\tpgParameterStatus *prev = pstatus;\n\n\t\tpstatus = pstatus->next;\n\t\tfree(prev);\n\t}\n\tconn->pstatus = NULL;\n\tconn->client_encoding = PG_SQL_ASCII;\n\tconn->std_strings = false;\n\tconn->default_transaction_read_only = PG_BOOL_UNKNOWN;\n\tconn->in_hot_standby = PG_BOOL_UNKNOWN;\n\tconn->sversion = 0;\n\n\t/* Drop large-object lookup data */\n\tif (conn->lobjfuncs)\n\t\tfree(conn->lobjfuncs);\n\tconn->lobjfuncs = NULL;\n\n\t/* Reset assorted other per-connection state */\n\tconn->last_sqlstate[0] = '\\0';\n\tconn->auth_req_received = false;\n\tconn->password_needed = false;\n\tconn->write_failed = false;\n\tif (conn->write_err_msg)\n\t\tfree(conn->write_err_msg);\n\tconn->write_err_msg = NULL;\n\tconn->be_pid = 0;\n\tconn->be_key = 0;\n}\n\n\n/*\n *\t\tConnecting to a Database\n *\n * There are now six different ways a user of this API can connect to the\n * database.  Two are not recommended for use in new code, because of their\n * lack of extensibility with respect to the passing of options to the\n * backend.  These are PQsetdb and PQsetdbLogin (the former now being a macro\n * to the latter).\n *\n * If it is desired to connect in a synchronous (blocking) manner, use the\n * function PQconnectdb or PQconnectdbParams. The former accepts a string of\n * option = value pairs (or a URI) which must be parsed; the latter takes two\n * NULL terminated arrays instead.\n *\n * To connect in an asynchronous (non-blocking) manner, use the functions\n * PQconnectStart or PQconnectStartParams (which differ in the same way as\n * PQconnectdb and PQconnectdbParams) and PQconnectPoll.\n *\n * Internally, the static functions connectDBStart, connectDBComplete\n * are part of the connection procedure.\n */\n\n/*\n *\t\tPQconnectdbParams\n *\n * establishes a connection to a postgres backend through the postmaster\n * using connection information in two arrays.\n *\n * The keywords array is defined as\n *\n *\t   const char *params[] = {\"option1\", \"option2\", NULL}\n *\n * The values array is defined as\n *\n *\t   const char *values[] = {\"value1\", \"value2\", NULL}\n *\n * Returns a PGconn* which is needed for all subsequent libpq calls, or NULL\n * if a memory allocation failed.\n * If the status field of the connection returned is CONNECTION_BAD,\n * then some fields may be null'ed out instead of having valid values.\n *\n * You should call PQfinish (if conn is not NULL) regardless of whether this\n * call succeeded.\n */\nPGconn *\nPQconnectdbParams(const char *const *keywords,\n\t\t\t\t  const char *const *values,\n\t\t\t\t  int expand_dbname)\n{\n\tPGconn\t   *conn = PQconnectStartParams(keywords, values, expand_dbname);\n\n\tif (conn && conn->status != CONNECTION_BAD)\n\t\t(void) connectDBComplete(conn);\n\n\treturn conn;\n\n}\n\n/*\n *\t\tPQpingParams\n *\n * check server status, accepting parameters identical to PQconnectdbParams\n */\nPGPing\nPQpingParams(const char *const *keywords,\n\t\t\t const char *const *values,\n\t\t\t int expand_dbname)\n{\n\tPGconn\t   *conn = PQconnectStartParams(keywords, values, expand_dbname);\n\tPGPing\t\tret;\n\n\tret = internal_ping(conn);\n\tPQfinish(conn);\n\n\treturn ret;\n}\n\n/*\n *\t\tPQconnectdb\n *\n * establishes a connection to a postgres backend through the postmaster\n * using connection information in a string.\n *\n * The conninfo string is either a whitespace-separated list of\n *\n *\t   option = value\n *\n * definitions or a URI (refer to the documentation for details.) Value\n * might be a single value containing no whitespaces or a single quoted\n * string. If a single quote should appear anywhere in the value, it must be\n * escaped with a backslash like \\'\n *\n * Returns a PGconn* which is needed for all subsequent libpq calls, or NULL\n * if a memory allocation failed.\n * If the status field of the connection returned is CONNECTION_BAD,\n * then some fields may be null'ed out instead of having valid values.\n *\n * You should call PQfinish (if conn is not NULL) regardless of whether this\n * call succeeded.\n */\nPGconn *\nPQconnectdb(const char *conninfo)\n{\n\tPGconn\t   *conn = PQconnectStart(conninfo);\n\n\tif (conn && conn->status != CONNECTION_BAD)\n\t\t(void) connectDBComplete(conn);\n\n\treturn conn;\n}\n\n/*\n *\t\tPQping\n *\n * check server status, accepting parameters identical to PQconnectdb\n */\nPGPing\nPQping(const char *conninfo)\n{\n\tPGconn\t   *conn = PQconnectStart(conninfo);\n\tPGPing\t\tret;\n\n\tret = internal_ping(conn);\n\tPQfinish(conn);\n\n\treturn ret;\n}\n\n/*\n *\t\tPQconnectStartParams\n *\n * Begins the establishment of a connection to a postgres backend through the\n * postmaster using connection information in a struct.\n *\n * See comment for PQconnectdbParams for the definition of the string format.\n *\n * Returns a PGconn*.  If NULL is returned, a malloc error has occurred, and\n * you should not attempt to proceed with this connection.  If the status\n * field of the connection returned is CONNECTION_BAD, an error has\n * occurred. In this case you should call PQfinish on the result, (perhaps\n * inspecting the error message first).  Other fields of the structure may not\n * be valid if that occurs.  If the status field is not CONNECTION_BAD, then\n * this stage has succeeded - call PQconnectPoll, using select(2) to see when\n * this is necessary.\n *\n * See PQconnectPoll for more info.\n */\nPGconn *\nPQconnectStartParams(const char *const *keywords,\n\t\t\t\t\t const char *const *values,\n\t\t\t\t\t int expand_dbname)\n{\n\tPGconn\t   *conn;\n\tPQconninfoOption *connOptions;\n\n\t/*\n\t * Allocate memory for the conn structure.  Note that we also expect this\n\t * to initialize conn->errorMessage to empty.  All subsequent steps during\n\t * connection initialization will only append to that buffer.\n\t */\n\tconn = makeEmptyPGconn();\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Parse the conninfo arrays\n\t */\n\tconnOptions = conninfo_array_parse(keywords, values,\n\t\t\t\t\t\t\t\t\t   &conn->errorMessage,\n\t\t\t\t\t\t\t\t\t   true, expand_dbname);\n\tif (connOptions == NULL)\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\t/* errorMessage is already set */\n\t\treturn conn;\n\t}\n\n\t/*\n\t * Move option values into conn structure\n\t */\n\tif (!fillPGconn(conn, connOptions))\n\t{\n\t\tPQconninfoFree(connOptions);\n\t\treturn conn;\n\t}\n\n\t/*\n\t * Free the option info - all is in conn now\n\t */\n\tPQconninfoFree(connOptions);\n\n\t/*\n\t * Compute derived options\n\t */\n\tif (!connectOptions2(conn))\n\t\treturn conn;\n\n\t/*\n\t * Connect to the database\n\t */\n\tif (!connectDBStart(conn))\n\t{\n\t\t/* Just in case we failed to set it in connectDBStart */\n\t\tconn->status = CONNECTION_BAD;\n\t}\n\n\treturn conn;\n}\n\n/*\n *\t\tPQconnectStart\n *\n * Begins the establishment of a connection to a postgres backend through the\n * postmaster using connection information in a string.\n *\n * See comment for PQconnectdb for the definition of the string format.\n *\n * Returns a PGconn*.  If NULL is returned, a malloc error has occurred, and\n * you should not attempt to proceed with this connection.  If the status\n * field of the connection returned is CONNECTION_BAD, an error has\n * occurred. In this case you should call PQfinish on the result, (perhaps\n * inspecting the error message first).  Other fields of the structure may not\n * be valid if that occurs.  If the status field is not CONNECTION_BAD, then\n * this stage has succeeded - call PQconnectPoll, using select(2) to see when\n * this is necessary.\n *\n * See PQconnectPoll for more info.\n */\nPGconn *\nPQconnectStart(const char *conninfo)\n{\n\tPGconn\t   *conn;\n\n\t/*\n\t * Allocate memory for the conn structure.  Note that we also expect this\n\t * to initialize conn->errorMessage to empty.  All subsequent steps during\n\t * connection initialization will only append to that buffer.\n\t */\n\tconn = makeEmptyPGconn();\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Parse the conninfo string\n\t */\n\tif (!connectOptions1(conn, conninfo))\n\t\treturn conn;\n\n\t/*\n\t * Compute derived options\n\t */\n\tif (!connectOptions2(conn))\n\t\treturn conn;\n\n\t/*\n\t * Connect to the database\n\t */\n\tif (!connectDBStart(conn))\n\t{\n\t\t/* Just in case we failed to set it in connectDBStart */\n\t\tconn->status = CONNECTION_BAD;\n\t}\n\n\treturn conn;\n}\n\n/*\n * Move option values into conn structure\n *\n * Don't put anything cute here --- intelligence should be in\n * connectOptions2 ...\n *\n * Returns true on success. On failure, returns false and sets error message.\n */\nstatic bool\nfillPGconn(PGconn *conn, PQconninfoOption *connOptions)\n{\n\tconst internalPQconninfoOption *option;\n\n\tfor (option = PQconninfoOptions; option->keyword; option++)\n\t{\n\t\tif (option->connofs >= 0)\n\t\t{\n\t\t\tconst char *tmp = conninfo_getval(connOptions, option->keyword);\n\n\t\t\tif (tmp)\n\t\t\t{\n\t\t\t\tchar\t  **connmember = (char **) ((char *) conn + option->connofs);\n\n\t\t\t\tif (*connmember)\n\t\t\t\t\tfree(*connmember);\n\t\t\t\t*connmember = strdup(tmp);\n\t\t\t\tif (*connmember == NULL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/*\n *\t\tconnectOptions1\n *\n * Internal subroutine to set up connection parameters given an already-\n * created PGconn and a conninfo string.  Derived settings should be\n * processed by calling connectOptions2 next.  (We split them because\n * PQsetdbLogin overrides defaults in between.)\n *\n * Returns true if OK, false if trouble (in which case errorMessage is set\n * and so is conn->status).\n */\nstatic bool\nconnectOptions1(PGconn *conn, const char *conninfo)\n{\n\tPQconninfoOption *connOptions;\n\n\t/*\n\t * Parse the conninfo string\n\t */\n\tconnOptions = parse_connection_string(conninfo, &conn->errorMessage, true);\n\tif (connOptions == NULL)\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\t/* errorMessage is already set */\n\t\treturn false;\n\t}\n\n\t/*\n\t * Move option values into conn structure\n\t */\n\tif (!fillPGconn(conn, connOptions))\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\tPQconninfoFree(connOptions);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Free the option info - all is in conn now\n\t */\n\tPQconninfoFree(connOptions);\n\n\treturn true;\n}\n\n/*\n * Count the number of elements in a simple comma-separated list.\n */\nstatic int\ncount_comma_separated_elems(const char *input)\n{\n\tint\t\t\tn;\n\n\tn = 1;\n\tfor (; *input != '\\0'; input++)\n\t{\n\t\tif (*input == ',')\n\t\t\tn++;\n\t}\n\n\treturn n;\n}\n\n/*\n * Parse a simple comma-separated list.\n *\n * On each call, returns a malloc'd copy of the next element, and sets *more\n * to indicate whether there are any more elements in the list after this,\n * and updates *startptr to point to the next element, if any.\n *\n * On out of memory, returns NULL.\n */\nstatic char *\nparse_comma_separated_list(char **startptr, bool *more)\n{\n\tchar\t   *p;\n\tchar\t   *s = *startptr;\n\tchar\t   *e;\n\tint\t\t\tlen;\n\n\t/*\n\t * Search for the end of the current element; a comma or end-of-string\n\t * acts as a terminator.\n\t */\n\te = s;\n\twhile (*e != '\\0' && *e != ',')\n\t\t++e;\n\t*more = (*e == ',');\n\n\tlen = e - s;\n\tp = (char *) malloc(sizeof(char) * (len + 1));\n\tif (p)\n\t{\n\t\tmemcpy(p, s, len);\n\t\tp[len] = '\\0';\n\t}\n\t*startptr = e + 1;\n\n\treturn p;\n}\n\n/*\n *\t\tconnectOptions2\n *\n * Compute derived connection options after absorbing all user-supplied info.\n *\n * Returns true if OK, false if trouble (in which case errorMessage is set\n * and so is conn->status).\n */\nstatic bool\nconnectOptions2(PGconn *conn)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Allocate memory for details about each host to which we might possibly\n\t * try to connect.  For that, count the number of elements in the hostaddr\n\t * or host options.  If neither is given, assume one host.\n\t */\n\tconn->whichhost = 0;\n\tif (conn->pghostaddr && conn->pghostaddr[0] != '\\0')\n\t\tconn->nconnhost = count_comma_separated_elems(conn->pghostaddr);\n\telse if (conn->pghost && conn->pghost[0] != '\\0')\n\t\tconn->nconnhost = count_comma_separated_elems(conn->pghost);\n\telse\n\t\tconn->nconnhost = 1;\n\tconn->connhost = (pg_conn_host *)\n\t\tcalloc(conn->nconnhost, sizeof(pg_conn_host));\n\tif (conn->connhost == NULL)\n\t\tgoto oom_error;\n\n\t/*\n\t * We now have one pg_conn_host structure per possible host.  Fill in the\n\t * host and hostaddr fields for each, by splitting the parameter strings.\n\t */\n\tif (conn->pghostaddr != NULL && conn->pghostaddr[0] != '\\0')\n\t{\n\t\tchar\t   *s = conn->pghostaddr;\n\t\tbool\t\tmore = true;\n\n\t\tfor (i = 0; i < conn->nconnhost && more; i++)\n\t\t{\n\t\t\tconn->connhost[i].hostaddr = parse_comma_separated_list(&s, &more);\n\t\t\tif (conn->connhost[i].hostaddr == NULL)\n\t\t\t\tgoto oom_error;\n\t\t}\n\n\t\t/*\n\t\t * If hostaddr was given, the array was allocated according to the\n\t\t * number of elements in the hostaddr list, so it really should be the\n\t\t * right size.\n\t\t */\n\t\tAssert(!more);\n\t\tAssert(i == conn->nconnhost);\n\t}\n\n\tif (conn->pghost != NULL && conn->pghost[0] != '\\0')\n\t{\n\t\tchar\t   *s = conn->pghost;\n\t\tbool\t\tmore = true;\n\n\t\tfor (i = 0; i < conn->nconnhost && more; i++)\n\t\t{\n\t\t\tconn->connhost[i].host = parse_comma_separated_list(&s, &more);\n\t\t\tif (conn->connhost[i].host == NULL)\n\t\t\t\tgoto oom_error;\n\t\t}\n\n\t\t/* Check for wrong number of host items. */\n\t\tif (more || i != conn->nconnhost)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"could not match %d host names to %d hostaddr values\\n\"),\n\t\t\t\t\t\t\t  count_comma_separated_elems(conn->pghost), conn->nconnhost);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Now, for each host slot, identify the type of address spec, and fill in\n\t * the default address if nothing was given.\n\t */\n\tfor (i = 0; i < conn->nconnhost; i++)\n\t{\n\t\tpg_conn_host *ch = &conn->connhost[i];\n\n\t\tif (ch->hostaddr != NULL && ch->hostaddr[0] != '\\0')\n\t\t\tch->type = CHT_HOST_ADDRESS;\n\t\telse if (ch->host != NULL && ch->host[0] != '\\0')\n\t\t{\n\t\t\tch->type = CHT_HOST_NAME;\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\tif (is_unixsock_path(ch->host))\n\t\t\t\tch->type = CHT_UNIX_SOCKET;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (ch->host)\n\t\t\t\tfree(ch->host);\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\tif (DEFAULT_PGSOCKET_DIR[0])\n\t\t\t{\n\t\t\t\tch->host = strdup(DEFAULT_PGSOCKET_DIR);\n\t\t\t\tch->type = CHT_UNIX_SOCKET;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tch->host = strdup(DefaultHost);\n\t\t\t\tch->type = CHT_HOST_NAME;\n\t\t\t}\n\t\t\tif (ch->host == NULL)\n\t\t\t\tgoto oom_error;\n\t\t}\n\t}\n\n\t/*\n\t * Next, work out the port number corresponding to each host name.\n\t *\n\t * Note: unlike the above for host names, this could leave the port fields\n\t * as null or empty strings.  We will substitute DEF_PGPORT whenever we\n\t * read such a port field.\n\t */\n\tif (conn->pgport != NULL && conn->pgport[0] != '\\0')\n\t{\n\t\tchar\t   *s = conn->pgport;\n\t\tbool\t\tmore = true;\n\n\t\tfor (i = 0; i < conn->nconnhost && more; i++)\n\t\t{\n\t\t\tconn->connhost[i].port = parse_comma_separated_list(&s, &more);\n\t\t\tif (conn->connhost[i].port == NULL)\n\t\t\t\tgoto oom_error;\n\t\t}\n\n\t\t/*\n\t\t * If exactly one port was given, use it for every host.  Otherwise,\n\t\t * there must be exactly as many ports as there were hosts.\n\t\t */\n\t\tif (i == 1 && !more)\n\t\t{\n\t\t\tfor (i = 1; i < conn->nconnhost; i++)\n\t\t\t{\n\t\t\t\tconn->connhost[i].port = strdup(conn->connhost[0].port);\n\t\t\t\tif (conn->connhost[i].port == NULL)\n\t\t\t\t\tgoto oom_error;\n\t\t\t}\n\t\t}\n\t\telse if (more || i != conn->nconnhost)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"could not match %d port numbers to %d hosts\\n\"),\n\t\t\t\t\t\t\t  count_comma_separated_elems(conn->pgport), conn->nconnhost);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If user name was not given, fetch it.  (Most likely, the fetch will\n\t * fail, since the only way we get here is if pg_fe_getauthname() failed\n\t * during conninfo_add_defaults().  But now we want an error message.)\n\t */\n\tif (conn->pguser == NULL || conn->pguser[0] == '\\0')\n\t{\n\t\tif (conn->pguser)\n\t\t\tfree(conn->pguser);\n\t\tconn->pguser = pg_fe_getauthname(&conn->errorMessage);\n\t\tif (!conn->pguser)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * If database name was not given, default it to equal user name\n\t */\n\tif (conn->dbName == NULL || conn->dbName[0] == '\\0')\n\t{\n\t\tif (conn->dbName)\n\t\t\tfree(conn->dbName);\n\t\tconn->dbName = strdup(conn->pguser);\n\t\tif (!conn->dbName)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * If password was not given, try to look it up in password file.  Note\n\t * that the result might be different for each host/port pair.\n\t */\n\tif (conn->pgpass == NULL || conn->pgpass[0] == '\\0')\n\t{\n\t\t/* If password file wasn't specified, use ~/PGPASSFILE */\n\t\tif (conn->pgpassfile == NULL || conn->pgpassfile[0] == '\\0')\n\t\t{\n\t\t\tchar\t\thomedir[MAXPGPATH];\n\n\t\t\tif (pqGetHomeDirectory(homedir, sizeof(homedir)))\n\t\t\t{\n\t\t\t\tif (conn->pgpassfile)\n\t\t\t\t\tfree(conn->pgpassfile);\n\t\t\t\tconn->pgpassfile = malloc(MAXPGPATH);\n\t\t\t\tif (!conn->pgpassfile)\n\t\t\t\t\tgoto oom_error;\n\t\t\t\tsnprintf(conn->pgpassfile, MAXPGPATH, \"%s/%s\",\n\t\t\t\t\t\t homedir, PGPASSFILE);\n\t\t\t}\n\t\t}\n\n\t\tif (conn->pgpassfile != NULL && conn->pgpassfile[0] != '\\0')\n\t\t{\n\t\t\tfor (i = 0; i < conn->nconnhost; i++)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Try to get a password for this host from file.  We use host\n\t\t\t\t * for the hostname search key if given, else hostaddr (at\n\t\t\t\t * least one of them is guaranteed nonempty by now).\n\t\t\t\t */\n\t\t\t\tconst char *pwhost = conn->connhost[i].host;\n\n\t\t\t\tif (pwhost == NULL || pwhost[0] == '\\0')\n\t\t\t\t\tpwhost = conn->connhost[i].hostaddr;\n\n\t\t\t\tconn->connhost[i].password =\n\t\t\t\t\tpasswordFromFile(pwhost,\n\t\t\t\t\t\t\t\t\t conn->connhost[i].port,\n\t\t\t\t\t\t\t\t\t conn->dbName,\n\t\t\t\t\t\t\t\t\t conn->pguser,\n\t\t\t\t\t\t\t\t\t conn->pgpassfile);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * validate channel_binding option\n\t */\n\tif (conn->channel_binding)\n\t{\n\t\tif (strcmp(conn->channel_binding, \"disable\") != 0\n\t\t\t&& strcmp(conn->channel_binding, \"prefer\") != 0\n\t\t\t&& strcmp(conn->channel_binding, \"require\") != 0)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  \"channel_binding\", conn->channel_binding);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconn->channel_binding = strdup(DefaultChannelBinding);\n\t\tif (!conn->channel_binding)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * validate sslmode option\n\t */\n\tif (conn->sslmode)\n\t{\n\t\tif (strcmp(conn->sslmode, \"disable\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"allow\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"prefer\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"require\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"verify-ca\") != 0\n\t\t\t&& strcmp(conn->sslmode, \"verify-full\") != 0)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  \"sslmode\", conn->sslmode);\n\t\t\treturn false;\n\t\t}\n\n#ifndef USE_SSL\n\t\tswitch (conn->sslmode[0])\n\t\t{\n\t\t\tcase 'a':\t\t\t/* \"allow\" */\n\t\t\tcase 'p':\t\t\t/* \"prefer\" */\n\n\t\t\t\t/*\n\t\t\t\t * warn user that an SSL connection will never be negotiated\n\t\t\t\t * since SSL was not compiled in?\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\t\t\t/* \"require\" */\n\t\t\tcase 'v':\t\t\t/* \"verify-ca\" or \"verify-full\" */\n\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"sslmode value \\\"%s\\\" invalid when SSL support is not compiled in\\n\"),\n\t\t\t\t\t\t\t\t  conn->sslmode);\n\t\t\t\treturn false;\n\t\t}\n#endif\n\t}\n\telse\n\t{\n\t\tconn->sslmode = strdup(DefaultSSLMode);\n\t\tif (!conn->sslmode)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * Validate TLS protocol versions for ssl_min_protocol_version and\n\t * ssl_max_protocol_version.\n\t */\n\tif (!sslVerifyProtocolVersion(conn->ssl_min_protocol_version))\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t  \"ssl_min_protocol_version\",\n\t\t\t\t\t\t  conn->ssl_min_protocol_version);\n\t\treturn false;\n\t}\n\tif (!sslVerifyProtocolVersion(conn->ssl_max_protocol_version))\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t  \"ssl_max_protocol_version\",\n\t\t\t\t\t\t  conn->ssl_max_protocol_version);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check if the range of SSL protocols defined is correct.  This is done\n\t * at this early step because this is independent of the SSL\n\t * implementation used, and this avoids unnecessary cycles with an\n\t * already-built SSL context when the connection is being established, as\n\t * it would be doomed anyway.\n\t */\n\tif (!sslVerifyProtocolRange(conn->ssl_min_protocol_version,\n\t\t\t\t\t\t\t\tconn->ssl_max_protocol_version))\n\t{\n\t\tconn->status = CONNECTION_BAD;\n\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"invalid SSL protocol version range\\n\"));\n\t\treturn false;\n\t}\n\n\t/*\n\t * validate gssencmode option\n\t */\n\tif (conn->gssencmode)\n\t{\n\t\tif (strcmp(conn->gssencmode, \"disable\") != 0 &&\n\t\t\tstrcmp(conn->gssencmode, \"prefer\") != 0 &&\n\t\t\tstrcmp(conn->gssencmode, \"require\") != 0)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  \"gssencmode\",\n\t\t\t\t\t\t\t  conn->gssencmode);\n\t\t\treturn false;\n\t\t}\n#ifndef ENABLE_GSS\n\t\tif (strcmp(conn->gssencmode, \"require\") == 0)\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"gssencmode value \\\"%s\\\" invalid when GSSAPI support is not compiled in\\n\"),\n\t\t\t\t\t\t\t  conn->gssencmode);\n\t\t\treturn false;\n\t\t}\n#endif\n\t}\n\telse\n\t{\n\t\tconn->gssencmode = strdup(DefaultGSSMode);\n\t\tif (!conn->gssencmode)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * validate target_session_attrs option, and set target_server_type\n\t */\n\tif (conn->target_session_attrs)\n\t{\n\t\tif (strcmp(conn->target_session_attrs, \"any\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_ANY;\n\t\telse if (strcmp(conn->target_session_attrs, \"read-write\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_READ_WRITE;\n\t\telse if (strcmp(conn->target_session_attrs, \"read-only\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_READ_ONLY;\n\t\telse if (strcmp(conn->target_session_attrs, \"primary\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_PRIMARY;\n\t\telse if (strcmp(conn->target_session_attrs, \"standby\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_STANDBY;\n\t\telse if (strcmp(conn->target_session_attrs, \"prefer-standby\") == 0)\n\t\t\tconn->target_server_type = SERVER_TYPE_PREFER_STANDBY;\n\t\telse\n\t\t{\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid %s value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  \"target_session_attrs\",\n\t\t\t\t\t\t\t  conn->target_session_attrs);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t\tconn->target_server_type = SERVER_TYPE_ANY;\n\n\t/*\n\t * Resolve special \"auto\" client_encoding from the locale\n\t */\n\tif (conn->client_encoding_initial &&\n\t\tstrcmp(conn->client_encoding_initial, \"auto\") == 0)\n\t{\n\t\tfree(conn->client_encoding_initial);\n\t\tconn->client_encoding_initial = strdup(pg_encoding_to_char(pg_get_encoding_from_locale(NULL, true)));\n\t\tif (!conn->client_encoding_initial)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * Only if we get this far is it appropriate to try to connect. (We need a\n\t * state flag, rather than just the boolean result of this function, in\n\t * case someone tries to PQreset() the PGconn.)\n\t */\n\tconn->options_valid = true;\n\n\treturn true;\n\noom_error:\n\tconn->status = CONNECTION_BAD;\n\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\treturn false;\n}\n\n/*\n *\t\tPQconndefaults\n *\n * Construct a default connection options array, which identifies all the\n * available options and shows any default values that are available from the\n * environment etc.  On error (eg out of memory), NULL is returned.\n *\n * Using this function, an application may determine all possible options\n * and their current default values.\n *\n * NOTE: as of PostgreSQL 7.0, the returned array is dynamically allocated\n * and should be freed when no longer needed via PQconninfoFree().  (In prior\n * versions, the returned array was static, but that's not thread-safe.)\n * Pre-7.0 applications that use this function will see a small memory leak\n * until they are updated to call PQconninfoFree.\n */\nPQconninfoOption *\nPQconndefaults(void)\n{\n\tPQExpBufferData errorBuf;\n\tPQconninfoOption *connOptions;\n\n\t/* We don't actually report any errors here, but callees want a buffer */\n\tinitPQExpBuffer(&errorBuf);\n\tif (PQExpBufferDataBroken(errorBuf))\n\t\treturn NULL;\t\t\t/* out of memory already :-( */\n\n\tconnOptions = conninfo_init(&errorBuf);\n\tif (connOptions != NULL)\n\t{\n\t\t/* pass NULL errorBuf to ignore errors */\n\t\tif (!conninfo_add_defaults(connOptions, NULL))\n\t\t{\n\t\t\tPQconninfoFree(connOptions);\n\t\t\tconnOptions = NULL;\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&errorBuf);\n\treturn connOptions;\n}\n\n/* ----------------\n *\t\tPQsetdbLogin\n *\n * establishes a connection to a postgres backend through the postmaster\n * at the specified host and port.\n *\n * returns a PGconn* which is needed for all subsequent libpq calls\n *\n * if the status field of the connection returned is CONNECTION_BAD,\n * then only the errorMessage is likely to be useful.\n * ----------------\n */\nPGconn *\nPQsetdbLogin(const char *pghost, const char *pgport, const char *pgoptions,\n\t\t\t const char *pgtty, const char *dbName, const char *login,\n\t\t\t const char *pwd)\n{\n\tPGconn\t   *conn;\n\n\t/*\n\t * Allocate memory for the conn structure.  Note that we also expect this\n\t * to initialize conn->errorMessage to empty.  All subsequent steps during\n\t * connection initialization will only append to that buffer.\n\t */\n\tconn = makeEmptyPGconn();\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * If the dbName parameter contains what looks like a connection string,\n\t * parse it into conn struct using connectOptions1.\n\t */\n\tif (dbName && recognized_connection_string(dbName))\n\t{\n\t\tif (!connectOptions1(conn, dbName))\n\t\t\treturn conn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Old-style path: first, parse an empty conninfo string in order to\n\t\t * set up the same defaults that PQconnectdb() would use.\n\t\t */\n\t\tif (!connectOptions1(conn, \"\"))\n\t\t\treturn conn;\n\n\t\t/* Insert dbName parameter value into struct */\n\t\tif (dbName && dbName[0] != '\\0')\n\t\t{\n\t\t\tif (conn->dbName)\n\t\t\t\tfree(conn->dbName);\n\t\t\tconn->dbName = strdup(dbName);\n\t\t\tif (!conn->dbName)\n\t\t\t\tgoto oom_error;\n\t\t}\n\t}\n\n\t/*\n\t * Insert remaining parameters into struct, overriding defaults (as well\n\t * as any conflicting data from dbName taken as a conninfo).\n\t */\n\tif (pghost && pghost[0] != '\\0')\n\t{\n\t\tif (conn->pghost)\n\t\t\tfree(conn->pghost);\n\t\tconn->pghost = strdup(pghost);\n\t\tif (!conn->pghost)\n\t\t\tgoto oom_error;\n\t}\n\n\tif (pgport && pgport[0] != '\\0')\n\t{\n\t\tif (conn->pgport)\n\t\t\tfree(conn->pgport);\n\t\tconn->pgport = strdup(pgport);\n\t\tif (!conn->pgport)\n\t\t\tgoto oom_error;\n\t}\n\n\tif (pgoptions && pgoptions[0] != '\\0')\n\t{\n\t\tif (conn->pgoptions)\n\t\t\tfree(conn->pgoptions);\n\t\tconn->pgoptions = strdup(pgoptions);\n\t\tif (!conn->pgoptions)\n\t\t\tgoto oom_error;\n\t}\n\n\tif (login && login[0] != '\\0')\n\t{\n\t\tif (conn->pguser)\n\t\t\tfree(conn->pguser);\n\t\tconn->pguser = strdup(login);\n\t\tif (!conn->pguser)\n\t\t\tgoto oom_error;\n\t}\n\n\tif (pwd && pwd[0] != '\\0')\n\t{\n\t\tif (conn->pgpass)\n\t\t\tfree(conn->pgpass);\n\t\tconn->pgpass = strdup(pwd);\n\t\tif (!conn->pgpass)\n\t\t\tgoto oom_error;\n\t}\n\n\t/*\n\t * Compute derived options\n\t */\n\tif (!connectOptions2(conn))\n\t\treturn conn;\n\n\t/*\n\t * Connect to the database\n\t */\n\tif (connectDBStart(conn))\n\t\t(void) connectDBComplete(conn);\n\n\treturn conn;\n\noom_error:\n\tconn->status = CONNECTION_BAD;\n\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\treturn conn;\n}\n\n\n/* ----------\n * connectNoDelay -\n * Sets the TCP_NODELAY socket option.\n * Returns 1 if successful, 0 if not.\n * ----------\n */\nstatic int\nconnectNoDelay(PGconn *conn)\n{\n#ifdef\tTCP_NODELAY\n\tint\t\t\ton = 1;\n\n\tif (setsockopt(conn->sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t\t\t   (char *) &on,\n\t\t\t\t   sizeof(on)) < 0)\n\t{\n\t\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"could not set socket to TCP no delay mode: %s\\n\"),\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\n/* ----------\n * Write currently connected IP address into host_addr (of len host_addr_len).\n * If unable to, set it to the empty string.\n * ----------\n */\nstatic void\ngetHostaddr(PGconn *conn, char *host_addr, int host_addr_len)\n{\n\tstruct sockaddr_storage *addr = &conn->raddr.addr;\n\n\tif (addr->ss_family == AF_INET)\n\t{\n\t\tif (pg_inet_net_ntop(AF_INET,\n\t\t\t\t\t\t\t &((struct sockaddr_in *) addr)->sin_addr.s_addr,\n\t\t\t\t\t\t\t 32,\n\t\t\t\t\t\t\t host_addr, host_addr_len) == NULL)\n\t\t\thost_addr[0] = '\\0';\n\t}\n#ifdef HAVE_IPV6\n\telse if (addr->ss_family == AF_INET6)\n\t{\n\t\tif (pg_inet_net_ntop(AF_INET6,\n\t\t\t\t\t\t\t &((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr,\n\t\t\t\t\t\t\t 128,\n\t\t\t\t\t\t\t host_addr, host_addr_len) == NULL)\n\t\t\thost_addr[0] = '\\0';\n\t}\n#endif\n\telse\n\t\thost_addr[0] = '\\0';\n}\n\n/*\n * emitHostIdentityInfo -\n * Speculatively append \"connection to server so-and-so failed: \" to\n * conn->errorMessage once we've identified the current connection target\n * address.  This ensures that any subsequent error message will be properly\n * attributed to the server we couldn't connect to.  conn->raddr must be\n * valid, and the result of getHostaddr() must be supplied.\n */\nstatic void\nemitHostIdentityInfo(PGconn *conn, const char *host_addr)\n{\n#ifdef HAVE_UNIX_SOCKETS\n\tif (IS_AF_UNIX(conn->raddr.addr.ss_family))\n\t{\n\t\tchar\t\tservice[NI_MAXHOST];\n\n\t\tpg_getnameinfo_all(&conn->raddr.addr, conn->raddr.salen,\n\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t   service, sizeof(service),\n\t\t\t\t\t\t   NI_NUMERICSERV);\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"connection to server on socket \\\"%s\\\" failed: \"),\n\t\t\t\t\t\t  service);\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* HAVE_UNIX_SOCKETS */\n\t{\n\t\tconst char *displayed_host;\n\t\tconst char *displayed_port;\n\n\t\t/* To which host and port were we actually connecting? */\n\t\tif (conn->connhost[conn->whichhost].type == CHT_HOST_ADDRESS)\n\t\t\tdisplayed_host = conn->connhost[conn->whichhost].hostaddr;\n\t\telse\n\t\t\tdisplayed_host = conn->connhost[conn->whichhost].host;\n\t\tdisplayed_port = conn->connhost[conn->whichhost].port;\n\t\tif (displayed_port == NULL || displayed_port[0] == '\\0')\n\t\t\tdisplayed_port = DEF_PGPORT_STR;\n\n\t\t/*\n\t\t * If the user did not supply an IP address using 'hostaddr', and\n\t\t * 'host' was missing or does not match our lookup, display the\n\t\t * looked-up IP address.\n\t\t */\n\t\tif (conn->connhost[conn->whichhost].type != CHT_HOST_ADDRESS &&\n\t\t\thost_addr[0] &&\n\t\t\tstrcmp(displayed_host, host_addr) != 0)\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"connection to server at \\\"%s\\\" (%s), port %s failed: \"),\n\t\t\t\t\t\t\t  displayed_host, host_addr,\n\t\t\t\t\t\t\t  displayed_port);\n\t\telse\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"connection to server at \\\"%s\\\", port %s failed: \"),\n\t\t\t\t\t\t\t  displayed_host,\n\t\t\t\t\t\t\t  displayed_port);\n\t}\n}\n\n/* ----------\n * connectFailureMessage -\n * create a friendly error message on connection failure,\n * using the given errno value.  Use this for error cases that\n * imply that there's no server there.\n * ----------\n */\nstatic void\nconnectFailureMessage(PGconn *conn, int errorno)\n{\n\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t  \"%s\\n\",\n\t\t\t\t\t  SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));\n\n#ifdef HAVE_UNIX_SOCKETS\n\tif (IS_AF_UNIX(conn->raddr.addr.ss_family))\n\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"\\tIs the server running locally and accepting connections on that socket?\\n\"));\n\telse\n#endif\n\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"\\tIs the server running on that host and accepting TCP/IP connections?\\n\"));\n}\n\n/*\n * Should we use keepalives?  Returns 1 if yes, 0 if no, and -1 if\n * conn->keepalives is set to a value which is not parseable as an\n * integer.\n */\nstatic int\nuseKeepalives(PGconn *conn)\n{\n\tchar\t   *ep;\n\tint\t\t\tval;\n\n\tif (conn->keepalives == NULL)\n\t\treturn 1;\n\tval = strtol(conn->keepalives, &ep, 10);\n\tif (*ep)\n\t\treturn -1;\n\treturn val != 0 ? 1 : 0;\n}\n\n/*\n * Parse and try to interpret \"value\" as an integer value, and if successful,\n * store it in *result, complaining if there is any trailing garbage or an\n * overflow.  This allows any number of leading and trailing whitespaces.\n */\nstatic bool\nparse_int_param(const char *value, int *result, PGconn *conn,\n\t\t\t\tconst char *context)\n{\n\tchar\t   *end;\n\tlong\t\tnumval;\n\n\tAssert(value != NULL);\n\n\t*result = 0;\n\n\t/* strtol(3) skips leading whitespaces */\n\terrno = 0;\n\tnumval = strtol(value, &end, 10);\n\n\t/*\n\t * If no progress was done during the parsing or an error happened, fail.\n\t * This tests properly for overflows of the result.\n\t */\n\tif (value == end || errno != 0 || numval != (int) numval)\n\t\tgoto error;\n\n\t/*\n\t * Skip any trailing whitespace; if anything but whitespace remains before\n\t * the terminating character, fail\n\t */\n\twhile (*end != '\\0' && isspace((unsigned char) *end))\n\t\tend++;\n\n\tif (*end != '\\0')\n\t\tgoto error;\n\n\t*result = numval;\n\treturn true;\n\nerror:\n\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t  libpq_gettext(\"invalid integer value \\\"%s\\\" for connection option \\\"%s\\\"\\n\"),\n\t\t\t\t\t  value, context);\n\treturn false;\n}\n\n#ifndef WIN32\n/*\n * Set the keepalive idle timer.\n */\nstatic int\nsetKeepalivesIdle(PGconn *conn)\n{\n\tint\t\t\tidle;\n\n\tif (conn->keepalives_idle == NULL)\n\t\treturn 1;\n\n\tif (!parse_int_param(conn->keepalives_idle, &idle, conn,\n\t\t\t\t\t\t \"keepalives_idle\"))\n\t\treturn 0;\n\tif (idle < 0)\n\t\tidle = 0;\n\n#ifdef PG_TCP_KEEPALIVE_IDLE\n\tif (setsockopt(conn->sock, IPPROTO_TCP, PG_TCP_KEEPALIVE_IDLE,\n\t\t\t\t   (char *) &idle, sizeof(idle)) < 0)\n\t{\n\t\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t  PG_TCP_KEEPALIVE_IDLE_STR,\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\n/*\n * Set the keepalive interval.\n */\nstatic int\nsetKeepalivesInterval(PGconn *conn)\n{\n\tint\t\t\tinterval;\n\n\tif (conn->keepalives_interval == NULL)\n\t\treturn 1;\n\n\tif (!parse_int_param(conn->keepalives_interval, &interval, conn,\n\t\t\t\t\t\t \"keepalives_interval\"))\n\t\treturn 0;\n\tif (interval < 0)\n\t\tinterval = 0;\n\n#ifdef TCP_KEEPINTVL\n\tif (setsockopt(conn->sock, IPPROTO_TCP, TCP_KEEPINTVL,\n\t\t\t\t   (char *) &interval, sizeof(interval)) < 0)\n\t{\n\t\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t  \"TCP_KEEPINTVL\",\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\n/*\n * Set the count of lost keepalive packets that will trigger a connection\n * break.\n */\nstatic int\nsetKeepalivesCount(PGconn *conn)\n{\n\tint\t\t\tcount;\n\n\tif (conn->keepalives_count == NULL)\n\t\treturn 1;\n\n\tif (!parse_int_param(conn->keepalives_count, &count, conn,\n\t\t\t\t\t\t \"keepalives_count\"))\n\t\treturn 0;\n\tif (count < 0)\n\t\tcount = 0;\n\n#ifdef TCP_KEEPCNT\n\tif (setsockopt(conn->sock, IPPROTO_TCP, TCP_KEEPCNT,\n\t\t\t\t   (char *) &count, sizeof(count)) < 0)\n\t{\n\t\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t  \"TCP_KEEPCNT\",\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n#else\t\t\t\t\t\t\t/* WIN32 */\n#ifdef SIO_KEEPALIVE_VALS\n/*\n * Enable keepalives and set the keepalive values on Win32,\n * where they are always set in one batch.\n */\nstatic int\nsetKeepalivesWin32(PGconn *conn)\n{\n\tstruct tcp_keepalive ka;\n\tDWORD\t\tretsize;\n\tint\t\t\tidle = 0;\n\tint\t\t\tinterval = 0;\n\n\tif (conn->keepalives_idle &&\n\t\t!parse_int_param(conn->keepalives_idle, &idle, conn,\n\t\t\t\t\t\t \"keepalives_idle\"))\n\t\treturn 0;\n\tif (idle <= 0)\n\t\tidle = 2 * 60 * 60;\t\t/* 2 hours = default */\n\n\tif (conn->keepalives_interval &&\n\t\t!parse_int_param(conn->keepalives_interval, &interval, conn,\n\t\t\t\t\t\t \"keepalives_interval\"))\n\t\treturn 0;\n\tif (interval <= 0)\n\t\tinterval = 1;\t\t\t/* 1 second = default */\n\n\tka.onoff = 1;\n\tka.keepalivetime = idle * 1000;\n\tka.keepaliveinterval = interval * 1000;\n\n\tif (WSAIoctl(conn->sock,\n\t\t\t\t SIO_KEEPALIVE_VALS,\n\t\t\t\t (LPVOID) &ka,\n\t\t\t\t sizeof(ka),\n\t\t\t\t NULL,\n\t\t\t\t 0,\n\t\t\t\t &retsize,\n\t\t\t\t NULL,\n\t\t\t\t NULL)\n\t\t!= 0)\n\t{\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: error code %d\\n\"),\n\t\t\t\t\t\t  \"WSAIoctl\", \"SIO_KEEPALIVE_VALS\",\n\t\t\t\t\t\t  WSAGetLastError());\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n#endif\t\t\t\t\t\t\t/* SIO_KEEPALIVE_VALS */\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n/*\n * Set the TCP user timeout.\n */\nstatic int\nsetTCPUserTimeout(PGconn *conn)\n{\n\tint\t\t\ttimeout;\n\n\tif (conn->pgtcp_user_timeout == NULL)\n\t\treturn 1;\n\n\tif (!parse_int_param(conn->pgtcp_user_timeout, &timeout, conn,\n\t\t\t\t\t\t \"tcp_user_timeout\"))\n\t\treturn 0;\n\n\tif (timeout < 0)\n\t\ttimeout = 0;\n\n#ifdef TCP_USER_TIMEOUT\n\tif (setsockopt(conn->sock, IPPROTO_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t   (char *) &timeout, sizeof(timeout)) < 0)\n\t{\n\t\tchar\t\tsebuf[256];\n\n\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t  \"TCP_USER_TIMEOUT\",\n\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn 1;\n}\n\n/* ----------\n * connectDBStart -\n *\t\tBegin the process of making a connection to the backend.\n *\n * Returns 1 if successful, 0 if not.\n * ----------\n */\nstatic int\nconnectDBStart(PGconn *conn)\n{\n\tif (!conn)\n\t\treturn 0;\n\n\tif (!conn->options_valid)\n\t\tgoto connect_errReturn;\n\n\t/*\n\t * Check for bad linking to backend-internal versions of src/common\n\t * functions (see comments in link-canary.c for the reason we need this).\n\t * Nobody but developers should see this message, so we don't bother\n\t * translating it.\n\t */\n\tif (!pg_link_canary_is_frontend())\n\t{\n\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t \"libpq is incorrectly linked to backend functions\\n\");\n\t\tgoto connect_errReturn;\n\t}\n\n\t/* Ensure our buffers are empty */\n\tconn->inStart = conn->inCursor = conn->inEnd = 0;\n\tconn->outCount = 0;\n\n\t/*\n\t * Set up to try to connect to the first host.  (Setting whichhost = -1 is\n\t * a bit of a cheat, but PQconnectPoll will advance it to 0 before\n\t * anything else looks at it.)\n\t */\n\tconn->whichhost = -1;\n\tconn->try_next_addr = false;\n\tconn->try_next_host = true;\n\tconn->status = CONNECTION_NEEDED;\n\n\t/* Also reset the target_server_type state if needed */\n\tif (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY_PASS2)\n\t\tconn->target_server_type = SERVER_TYPE_PREFER_STANDBY;\n\n\t/*\n\t * The code for processing CONNECTION_NEEDED state is in PQconnectPoll(),\n\t * so that it can easily be re-executed if needed again during the\n\t * asynchronous startup process.  However, we must run it once here,\n\t * because callers expect a success return from this routine to mean that\n\t * we are in PGRES_POLLING_WRITING connection state.\n\t */\n\tif (PQconnectPoll(conn) == PGRES_POLLING_WRITING)\n\t\treturn 1;\n\nconnect_errReturn:\n\n\t/*\n\t * If we managed to open a socket, close it immediately rather than\n\t * waiting till PQfinish.  (The application cannot have gotten the socket\n\t * from PQsocket yet, so this doesn't risk breaking anything.)\n\t */\n\tpqDropConnection(conn, true);\n\tconn->status = CONNECTION_BAD;\n\treturn 0;\n}\n\n\n/*\n *\t\tconnectDBComplete\n *\n * Block and complete a connection.\n *\n * Returns 1 on success, 0 on failure.\n */\nstatic int\nconnectDBComplete(PGconn *conn)\n{\n\tPostgresPollingStatusType flag = PGRES_POLLING_WRITING;\n\ttime_t\t\tfinish_time = ((time_t) -1);\n\tint\t\t\ttimeout = 0;\n\tint\t\t\tlast_whichhost = -2;\t/* certainly different from whichhost */\n\tstruct addrinfo *last_addr_cur = NULL;\n\n\tif (conn == NULL || conn->status == CONNECTION_BAD)\n\t\treturn 0;\n\n\t/*\n\t * Set up a time limit, if connect_timeout isn't zero.\n\t */\n\tif (conn->connect_timeout != NULL)\n\t{\n\t\tif (!parse_int_param(conn->connect_timeout, &timeout, conn,\n\t\t\t\t\t\t\t \"connect_timeout\"))\n\t\t{\n\t\t\t/* mark the connection as bad to report the parsing failure */\n\t\t\tconn->status = CONNECTION_BAD;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (timeout > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Rounding could cause connection to fail unexpectedly quickly;\n\t\t\t * to prevent possibly waiting hardly-at-all, insist on at least\n\t\t\t * two seconds.\n\t\t\t */\n\t\t\tif (timeout < 2)\n\t\t\t\ttimeout = 2;\n\t\t}\n\t\telse\t\t\t\t\t/* negative means 0 */\n\t\t\ttimeout = 0;\n\t}\n\n\tfor (;;)\n\t{\n\t\tint\t\t\tret = 0;\n\n\t\t/*\n\t\t * (Re)start the connect_timeout timer if it's active and we are\n\t\t * considering a different host than we were last time through.  If\n\t\t * we've already succeeded, though, needn't recalculate.\n\t\t */\n\t\tif (flag != PGRES_POLLING_OK &&\n\t\t\ttimeout > 0 &&\n\t\t\t(conn->whichhost != last_whichhost ||\n\t\t\t conn->addr_cur != last_addr_cur))\n\t\t{\n\t\t\tfinish_time = time(NULL) + timeout;\n\t\t\tlast_whichhost = conn->whichhost;\n\t\t\tlast_addr_cur = conn->addr_cur;\n\t\t}\n\n\t\t/*\n\t\t * Wait, if necessary.  Note that the initial state (just after\n\t\t * PQconnectStart) is to wait for the socket to select for writing.\n\t\t */\n\t\tswitch (flag)\n\t\t{\n\t\t\tcase PGRES_POLLING_OK:\n\t\t\t\treturn 1;\t\t/* success! */\n\n\t\t\tcase PGRES_POLLING_READING:\n\t\t\t\tret = pqWaitTimed(1, 0, conn, finish_time);\n\t\t\t\tif (ret == -1)\n\t\t\t\t{\n\t\t\t\t\t/* hard failure, eg select() problem, aborts everything */\n\t\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PGRES_POLLING_WRITING:\n\t\t\t\tret = pqWaitTimed(0, 1, conn, finish_time);\n\t\t\t\tif (ret == -1)\n\t\t\t\t{\n\t\t\t\t\t/* hard failure, eg select() problem, aborts everything */\n\t\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* Just in case we failed to set it in PQconnectPoll */\n\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (ret == 1)\t\t\t/* connect_timeout elapsed */\n\t\t{\n\t\t\t/*\n\t\t\t * Give up on current server/address, try the next one.\n\t\t\t */\n\t\t\tconn->try_next_addr = true;\n\t\t\tconn->status = CONNECTION_NEEDED;\n\t\t}\n\n\t\t/*\n\t\t * Now try to advance the state machine.\n\t\t */\n\t\tflag = PQconnectPoll(conn);\n\t}\n}\n\n/* ----------------\n *\t\tPQconnectPoll\n *\n * Poll an asynchronous connection.\n *\n * Returns a PostgresPollingStatusType.\n * Before calling this function, use select(2) to determine when data\n * has arrived..\n *\n * You must call PQfinish whether or not this fails.\n *\n * This function and PQconnectStart are intended to allow connections to be\n * made without blocking the execution of your program on remote I/O. However,\n * there are a number of caveats:\n *\n *\t o\tIf you call PQtrace, ensure that the stream object into which you trace\n *\t\twill not block.\n *\t o\tIf you do not supply an IP address for the remote host (i.e. you\n *\t\tsupply a host name instead) then PQconnectStart will block on\n *\t\tgethostbyname.  You will be fine if using Unix sockets (i.e. by\n *\t\tsupplying neither a host name nor a host address).\n *\t o\tIf your backend wants to use Kerberos authentication then you must\n *\t\tsupply both a host name and a host address, otherwise this function\n *\t\tmay block on gethostname.\n *\n * ----------------\n */\nPostgresPollingStatusType\nPQconnectPoll(PGconn *conn)\n{\n\tbool\t\treset_connection_state_machine = false;\n\tbool\t\tneed_new_connection = false;\n\tPGresult   *res;\n\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\tint\t\t\toptval;\n\n\tif (conn == NULL)\n\t\treturn PGRES_POLLING_FAILED;\n\n\t/* Get the new data */\n\tswitch (conn->status)\n\t{\n\t\t\t/*\n\t\t\t * We really shouldn't have been polled in these two cases, but we\n\t\t\t * can handle it.\n\t\t\t */\n\t\tcase CONNECTION_BAD:\n\t\t\treturn PGRES_POLLING_FAILED;\n\t\tcase CONNECTION_OK:\n\t\t\treturn PGRES_POLLING_OK;\n\n\t\t\t/* These are reading states */\n\t\tcase CONNECTION_AWAITING_RESPONSE:\n\t\tcase CONNECTION_AUTH_OK:\n\t\tcase CONNECTION_CHECK_WRITABLE:\n\t\tcase CONNECTION_CONSUME:\n\t\tcase CONNECTION_CHECK_STANDBY:\n\t\t\t{\n\t\t\t\t/* Load waiting data */\n\t\t\t\tint\t\t\tn = pqReadData(conn);\n\n\t\t\t\tif (n < 0)\n\t\t\t\t\tgoto error_return;\n\t\t\t\tif (n == 0)\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* These are writing states, so we just proceed. */\n\t\tcase CONNECTION_STARTED:\n\t\tcase CONNECTION_MADE:\n\t\t\tbreak;\n\n\t\t\t/* Special cases: proceed without waiting. */\n\t\tcase CONNECTION_SSL_STARTUP:\n\t\tcase CONNECTION_NEEDED:\n\t\tcase CONNECTION_GSS_STARTUP:\n\t\tcase CONNECTION_CHECK_TARGET:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t libpq_gettext(\"invalid connection state, probably indicative of memory corruption\\n\"));\n\t\t\tgoto error_return;\n\t}\n\n\nkeep_going:\t\t\t\t\t\t/* We will come back to here until there is\n\t\t\t\t\t\t\t\t * nothing left to do. */\n\n\t/* Time to advance to next address, or next host if no more addresses? */\n\tif (conn->try_next_addr)\n\t{\n\t\tif (conn->addr_cur && conn->addr_cur->ai_next)\n\t\t{\n\t\t\tconn->addr_cur = conn->addr_cur->ai_next;\n\t\t\treset_connection_state_machine = true;\n\t\t}\n\t\telse\n\t\t\tconn->try_next_host = true;\n\t\tconn->try_next_addr = false;\n\t}\n\n\t/* Time to advance to next connhost[] entry? */\n\tif (conn->try_next_host)\n\t{\n\t\tpg_conn_host *ch;\n\t\tstruct addrinfo hint;\n\t\tint\t\t\tthisport;\n\t\tint\t\t\tret;\n\t\tchar\t\tportstr[MAXPGPATH];\n\n\t\tif (conn->whichhost + 1 < conn->nconnhost)\n\t\t\tconn->whichhost++;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Oops, no more hosts.\n\t\t\t *\n\t\t\t * If we are trying to connect in \"prefer-standby\" mode, then drop\n\t\t\t * the standby requirement and start over.\n\t\t\t *\n\t\t\t * Otherwise, an appropriate error message is already set up, so\n\t\t\t * we just need to set the right status.\n\t\t\t */\n\t\t\tif (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY &&\n\t\t\t\tconn->nconnhost > 0)\n\t\t\t{\n\t\t\t\tconn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2;\n\t\t\t\tconn->whichhost = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto error_return;\n\t\t}\n\n\t\t/* Drop any address info for previous host */\n\t\trelease_conn_addrinfo(conn);\n\n\t\t/*\n\t\t * Look up info for the new host.  On failure, log the problem in\n\t\t * conn->errorMessage, then loop around to try the next host.  (Note\n\t\t * we don't clear try_next_host until we've succeeded.)\n\t\t */\n\t\tch = &conn->connhost[conn->whichhost];\n\n\t\t/* Initialize hint structure */\n\t\tMemSet(&hint, 0, sizeof(hint));\n\t\thint.ai_socktype = SOCK_STREAM;\n\t\tconn->addrlist_family = hint.ai_family = AF_UNSPEC;\n\n\t\t/* Figure out the port number we're going to use. */\n\t\tif (ch->port == NULL || ch->port[0] == '\\0')\n\t\t\tthisport = DEF_PGPORT;\n\t\telse\n\t\t{\n\t\t\tif (!parse_int_param(ch->port, &thisport, conn, \"port\"))\n\t\t\t\tgoto error_return;\n\n\t\t\tif (thisport < 1 || thisport > 65535)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid port number: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  ch->port);\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\t\t}\n\t\tsnprintf(portstr, sizeof(portstr), \"%d\", thisport);\n\n\t\t/* Use pg_getaddrinfo_all() to resolve the address */\n\t\tswitch (ch->type)\n\t\t{\n\t\t\tcase CHT_HOST_NAME:\n\t\t\t\tret = pg_getaddrinfo_all(ch->host, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not translate host name \\\"%s\\\" to address: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  ch->host, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CHT_HOST_ADDRESS:\n\t\t\t\thint.ai_flags = AI_NUMERICHOST;\n\t\t\t\tret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not parse network address \\\"%s\\\": %s\\n\"),\n\t\t\t\t\t\t\t\t\t  ch->hostaddr, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CHT_UNIX_SOCKET:\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\t\tconn->addrlist_family = hint.ai_family = AF_UNIX;\n\t\t\t\tUNIXSOCK_PATH(portstr, thisport, ch->host);\n\t\t\t\tif (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"Unix-domain socket path \\\"%s\\\" is too long (maximum %d bytes)\\n\"),\n\t\t\t\t\t\t\t\t\t  portstr,\n\t\t\t\t\t\t\t\t\t  (int) (UNIXSOCK_PATH_BUFLEN - 1));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * NULL hostname tells pg_getaddrinfo_all to parse the service\n\t\t\t\t * name as a Unix-domain socket path.\n\t\t\t\t */\n\t\t\t\tret = pg_getaddrinfo_all(NULL, portstr, &hint,\n\t\t\t\t\t\t\t\t\t\t &conn->addrlist);\n\t\t\t\tif (ret || !conn->addrlist)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not translate Unix-domain socket path \\\"%s\\\" to address: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  portstr, gai_strerror(ret));\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n#else\n\t\t\t\tAssert(false);\n#endif\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, scan this addrlist for a working server address */\n\t\tconn->addr_cur = conn->addrlist;\n\t\treset_connection_state_machine = true;\n\t\tconn->try_next_host = false;\n\t}\n\n\t/* Reset connection state machine? */\n\tif (reset_connection_state_machine)\n\t{\n\t\t/*\n\t\t * (Re) initialize our connection control variables for a set of\n\t\t * connection attempts to a single server address.  These variables\n\t\t * must persist across individual connection attempts, but we must\n\t\t * reset them when we start to consider a new server.\n\t\t */\n\t\tconn->pversion = PG_PROTOCOL(3, 0);\n\t\tconn->send_appname = true;\n#ifdef USE_SSL\n\t\t/* initialize these values based on SSL mode */\n\t\tconn->allow_ssl_try = (conn->sslmode[0] != 'd');\t/* \"disable\" */\n\t\tconn->wait_ssl_try = (conn->sslmode[0] == 'a'); /* \"allow\" */\n#endif\n#ifdef ENABLE_GSS\n\t\tconn->try_gss = (conn->gssencmode[0] != 'd');\t/* \"disable\" */\n#endif\n\n\t\treset_connection_state_machine = false;\n\t\tneed_new_connection = true;\n\t}\n\n\t/* Force a new connection (perhaps to the same server as before)? */\n\tif (need_new_connection)\n\t{\n\t\t/* Drop any existing connection */\n\t\tpqDropConnection(conn, true);\n\n\t\t/* Reset all state obtained from old server */\n\t\tpqDropServerData(conn);\n\n\t\t/* Drop any PGresult we might have, too */\n\t\tconn->asyncStatus = PGASYNC_IDLE;\n\t\tconn->xactStatus = PQTRANS_IDLE;\n\t\tconn->pipelineStatus = PQ_PIPELINE_OFF;\n\t\tpqClearAsyncResult(conn);\n\n\t\t/* Reset conn->status to put the state machine in the right state */\n\t\tconn->status = CONNECTION_NEEDED;\n\n\t\tneed_new_connection = false;\n\t}\n\n\t/* Now try to advance the state machine for this connection */\n\tswitch (conn->status)\n\t{\n\t\tcase CONNECTION_NEEDED:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Try to initiate a connection to one of the addresses\n\t\t\t\t * returned by pg_getaddrinfo_all().  conn->addr_cur is the\n\t\t\t\t * next one to try.\n\t\t\t\t *\n\t\t\t\t * The extra level of braces here is historical.  It's not\n\t\t\t\t * worth reindenting this whole switch case to remove 'em.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tstruct addrinfo *addr_cur = conn->addr_cur;\n\t\t\t\t\tchar\t\thost_addr[NI_MAXHOST];\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Advance to next possible host, if we've tried all of\n\t\t\t\t\t * the addresses for the current host.\n\t\t\t\t\t */\n\t\t\t\t\tif (addr_cur == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Remember current address for possible use later */\n\t\t\t\t\tmemcpy(&conn->raddr.addr, addr_cur->ai_addr,\n\t\t\t\t\t\t   addr_cur->ai_addrlen);\n\t\t\t\t\tconn->raddr.salen = addr_cur->ai_addrlen;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set connip, too.  Note we purposely ignore strdup\n\t\t\t\t\t * failure; not a big problem if it fails.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->connip != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(conn->connip);\n\t\t\t\t\t\tconn->connip = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgetHostaddr(conn, host_addr, NI_MAXHOST);\n\t\t\t\t\tif (host_addr[0])\n\t\t\t\t\t\tconn->connip = strdup(host_addr);\n\n\t\t\t\t\t/* Try to create the socket */\n\t\t\t\t\tconn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);\n\t\t\t\t\tif (conn->sock == PGINVALID_SOCKET)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\terrorno = SOCK_ERRNO;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Silently ignore socket() failure if we have more\n\t\t\t\t\t\t * addresses to try; this reduces useless chatter in\n\t\t\t\t\t\t * cases where the address list includes both IPv4 and\n\t\t\t\t\t\t * IPv6 but kernel only accepts one family.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (addr_cur->ai_next != NULL ||\n\t\t\t\t\t\t\tconn->whichhost + 1 < conn->nconnhost)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t\temitHostIdentityInfo(conn, host_addr);\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not create socket: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Once we've identified a target address, all errors\n\t\t\t\t\t * except the preceding socket()-failure case should be\n\t\t\t\t\t * prefixed with host-identity information.  (If the\n\t\t\t\t\t * connection succeeds, the contents of conn->errorMessage\n\t\t\t\t\t * won't matter, so this is harmless.)\n\t\t\t\t\t */\n\t\t\t\t\temitHostIdentityInfo(conn, host_addr);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Select socket options: no delay of outgoing data for\n\t\t\t\t\t * TCP sockets, nonblock mode, close-on-exec.  Try the\n\t\t\t\t\t * next address if any of this fails.\n\t\t\t\t\t */\n\t\t\t\t\tif (!IS_AF_UNIX(addr_cur->ai_family))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!connectNoDelay(conn))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* error message already created */\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!pg_set_noblock(conn->sock))\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not set socket to nonblocking mode: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n#ifdef F_SETFD\n\t\t\t\t\tif (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not set socket to close-on-exec mode: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* F_SETFD */\n\n\t\t\t\t\tif (!IS_AF_UNIX(addr_cur->ai_family))\n\t\t\t\t\t{\n#ifndef WIN32\n\t\t\t\t\t\tint\t\t\ton = 1;\n#endif\n\t\t\t\t\t\tint\t\t\tusekeepalives = useKeepalives(conn);\n\t\t\t\t\t\tint\t\t\terr = 0;\n\n\t\t\t\t\t\tif (usekeepalives < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"keepalives parameter must be an integer\\n\"));\n\t\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (usekeepalives == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Do nothing */\n\t\t\t\t\t\t}\n#ifndef WIN32\n\t\t\t\t\t\telse if (setsockopt(conn->sock,\n\t\t\t\t\t\t\t\t\t\t\tSOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t\t\t\t\t\t\t\t(char *) &on, sizeof(on)) < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"%s(%s) failed: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  \"setsockopt\",\n\t\t\t\t\t\t\t\t\t\t\t  \"SO_KEEPALIVE\",\n\t\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\t\terr = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!setKeepalivesIdle(conn)\n\t\t\t\t\t\t\t\t || !setKeepalivesInterval(conn)\n\t\t\t\t\t\t\t\t || !setKeepalivesCount(conn))\n\t\t\t\t\t\t\terr = 1;\n#else\t\t\t\t\t\t\t/* WIN32 */\n#ifdef SIO_KEEPALIVE_VALS\n\t\t\t\t\t\telse if (!setKeepalivesWin32(conn))\n\t\t\t\t\t\t\terr = 1;\n#endif\t\t\t\t\t\t\t/* SIO_KEEPALIVE_VALS */\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t\t\telse if (!setTCPUserTimeout(conn))\n\t\t\t\t\t\t\terr = 1;\n\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*----------\n\t\t\t\t\t * We have three methods of blocking SIGPIPE during\n\t\t\t\t\t * send() calls to this socket:\n\t\t\t\t\t *\n\t\t\t\t\t *\t- setsockopt(sock, SO_NOSIGPIPE)\n\t\t\t\t\t *\t- send(sock, ..., MSG_NOSIGNAL)\n\t\t\t\t\t *\t- setting the signal mask to SIG_IGN during send()\n\t\t\t\t\t *\n\t\t\t\t\t * The third method requires three syscalls per send,\n\t\t\t\t\t * so we prefer either of the first two, but they are\n\t\t\t\t\t * less portable.  The state is tracked in the following\n\t\t\t\t\t * members of PGconn:\n\t\t\t\t\t *\n\t\t\t\t\t * conn->sigpipe_so\t\t- we have set up SO_NOSIGPIPE\n\t\t\t\t\t * conn->sigpipe_flag\t- we're specifying MSG_NOSIGNAL\n\t\t\t\t\t *\n\t\t\t\t\t * If we can use SO_NOSIGPIPE, then set sigpipe_so here\n\t\t\t\t\t * and we're done.  Otherwise, set sigpipe_flag so that\n\t\t\t\t\t * we will try MSG_NOSIGNAL on sends.  If we get an error\n\t\t\t\t\t * with MSG_NOSIGNAL, we'll clear that flag and revert to\n\t\t\t\t\t * signal masking.\n\t\t\t\t\t *----------\n\t\t\t\t\t */\n\t\t\t\t\tconn->sigpipe_so = false;\n#ifdef MSG_NOSIGNAL\n\t\t\t\t\tconn->sigpipe_flag = true;\n#else\n\t\t\t\t\tconn->sigpipe_flag = false;\n#endif\t\t\t\t\t\t\t/* MSG_NOSIGNAL */\n\n#ifdef SO_NOSIGPIPE\n\t\t\t\t\toptval = 1;\n\t\t\t\t\tif (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE,\n\t\t\t\t\t\t\t\t   (char *) &optval, sizeof(optval)) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->sigpipe_so = true;\n\t\t\t\t\t\tconn->sigpipe_flag = false;\n\t\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* SO_NOSIGPIPE */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Start/make connection.  This should not block, since we\n\t\t\t\t\t * are in nonblock mode.  If it does, well, too bad.\n\t\t\t\t\t */\n\t\t\t\t\tif (connect(conn->sock, addr_cur->ai_addr,\n\t\t\t\t\t\t\t\taddr_cur->ai_addrlen) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (SOCK_ERRNO == EINPROGRESS ||\n#ifdef WIN32\n\t\t\t\t\t\t\tSOCK_ERRNO == EWOULDBLOCK ||\n#endif\n\t\t\t\t\t\t\tSOCK_ERRNO == EINTR)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * This is fine - we're in non-blocking mode, and\n\t\t\t\t\t\t\t * the connection is in progress.  Tell caller to\n\t\t\t\t\t\t\t * wait for write-ready on socket.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconn->status = CONNECTION_STARTED;\n\t\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* otherwise, trouble */\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Hm, we're connected already --- seems the \"nonblock\n\t\t\t\t\t\t * connection\" wasn't.  Advance the state machine and\n\t\t\t\t\t\t * go do the next stuff.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_STARTED;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * This connection failed.  Add the error report to\n\t\t\t\t\t * conn->errorMessage, then try the next address if any.\n\t\t\t\t\t */\n\t\t\t\t\tconnectFailureMessage(conn, SOCK_ERRNO);\n\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase CONNECTION_STARTED:\n\t\t\t{\n\t\t\t\tACCEPT_TYPE_ARG3 optlen = sizeof(optval);\n\n\t\t\t\t/*\n\t\t\t\t * Write ready, since we've made it here, so the connection\n\t\t\t\t * has been made ... or has failed.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Now check (using getsockopt) that there is not an error\n\t\t\t\t * state waiting for us on the socket.\n\t\t\t\t */\n\n\t\t\t\tif (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,\n\t\t\t\t\t\t\t   (char *) &optval, &optlen) == -1)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get socket error status: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\telse if (optval != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * When using a nonblocking connect, we will typically see\n\t\t\t\t\t * connect failures at this point, so provide a friendly\n\t\t\t\t\t * error message.\n\t\t\t\t\t */\n\t\t\t\t\tconnectFailureMessage(conn, optval);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Try the next address if any, just as in the case where\n\t\t\t\t\t * connect() returned failure immediately.\n\t\t\t\t\t */\n\t\t\t\t\tconn->try_next_addr = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Fill in the client address */\n\t\t\t\tconn->laddr.salen = sizeof(conn->laddr.addr);\n\t\t\t\tif (getsockname(conn->sock,\n\t\t\t\t\t\t\t\t(struct sockaddr *) &conn->laddr.addr,\n\t\t\t\t\t\t\t\t&conn->laddr.salen) < 0)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get client address from socket: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make sure we can write before advancing to next step.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t}\n\n\t\tcase CONNECTION_MADE:\n\t\t\t{\n\t\t\t\tchar\t   *startpacket;\n\t\t\t\tint\t\t\tpacketlen;\n\n\t\t\t\t/*\n\t\t\t\t * Implement requirepeer check, if requested and it's a\n\t\t\t\t * Unix-domain socket.\n\t\t\t\t */\n\t\t\t\tif (conn->requirepeer && conn->requirepeer[0] &&\n\t\t\t\t\tIS_AF_UNIX(conn->raddr.addr.ss_family))\n\t\t\t\t{\n#ifndef WIN32\n\t\t\t\t\tchar\t\tpwdbuf[BUFSIZ];\n\t\t\t\t\tstruct passwd pass_buf;\n\t\t\t\t\tstruct passwd *pass;\n\t\t\t\t\tint\t\t\tpasserr;\n#endif\n\t\t\t\t\tuid_t\t\tuid;\n\t\t\t\t\tgid_t\t\tgid;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tif (getpeereid(conn->sock, &uid, &gid) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Provide special error message if getpeereid is a\n\t\t\t\t\t\t * stub\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (errno == ENOSYS)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"requirepeer parameter is not supported on this platform\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not get peer credentials: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  strerror_r(errno, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n#ifndef WIN32\n\t\t\t\t\tpasserr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass);\n\t\t\t\t\tif (pass == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (passerr != 0)\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not look up local user ID %d: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  (int) uid,\n\t\t\t\t\t\t\t\t\t\t\t  strerror_r(passerr, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"local user with ID %d does not exist\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t  (int) uid);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (strcmp(pass->pw_name, conn->requirepeer) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"requirepeer specifies \\\"%s\\\", but actual peer user name is \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t\t  conn->requirepeer, pass->pw_name);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n#else\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t\t/* should have failed with ENOSYS above */\n\t\t\t\t\tAssert(false);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\t\t}\n\n\t\t\t\tif (IS_AF_UNIX(conn->raddr.addr.ss_family))\n\t\t\t\t{\n\t\t\t\t\t/* Don't request SSL or GSSAPI over Unix sockets */\n#ifdef USE_SSL\n\t\t\t\t\tconn->allow_ssl_try = false;\n#endif\n#ifdef ENABLE_GSS\n\t\t\t\t\tconn->try_gss = false;\n#endif\n\t\t\t\t}\n\n#ifdef ENABLE_GSS\n\n\t\t\t\t/*\n\t\t\t\t * If GSSAPI encryption is enabled, then call\n\t\t\t\t * pg_GSS_have_cred_cache() which will return true if we can\n\t\t\t\t * acquire credentials (and give us a handle to use in\n\t\t\t\t * conn->gcred), and then send a packet to the server asking\n\t\t\t\t * for GSSAPI Encryption (and skip past SSL negotiation and\n\t\t\t\t * regular startup below).\n\t\t\t\t */\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t\tconn->try_gss = pg_GSS_have_cred_cache(&conn->gcred);\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t{\n\t\t\t\t\tProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);\n\n\t\t\t\t\tif (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send GSSAPI negotiation packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Ok, wait for response */\n\t\t\t\t\tconn->status = CONNECTION_GSS_STARTUP;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\t\t\t\telse if (!conn->gctx && conn->gssencmode[0] == 'r')\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\\n\"));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n#endif\n\n#ifdef USE_SSL\n\n\t\t\t\t/*\n\t\t\t\t * Enable the libcrypto callbacks before checking if SSL needs\n\t\t\t\t * to be done.  This is done before sending the startup packet\n\t\t\t\t * as depending on the type of authentication done, like MD5\n\t\t\t\t * or SCRAM that use cryptohashes, the callbacks would be\n\t\t\t\t * required even without a SSL connection\n\t\t\t\t */\n\t\t\t\tif (pqsecure_initialize(conn, false, true) < 0)\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\t/*\n\t\t\t\t * If SSL is enabled and we haven't already got encryption of\n\t\t\t\t * some sort running, request SSL instead of sending the\n\t\t\t\t * startup message.\n\t\t\t\t */\n\t\t\t\tif (conn->allow_ssl_try && !conn->wait_ssl_try &&\n\t\t\t\t\t!conn->ssl_in_use\n#ifdef ENABLE_GSS\n\t\t\t\t\t&& !conn->gssenc\n#endif\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tProtocolVersion pv;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Send the SSL request packet.\n\t\t\t\t\t *\n\t\t\t\t\t * Theoretically, this could block, but it really\n\t\t\t\t\t * shouldn't since we only got here if the socket is\n\t\t\t\t\t * write-ready.\n\t\t\t\t\t */\n\t\t\t\t\tpv = pg_hton32(NEGOTIATE_SSL_CODE);\n\t\t\t\t\tif (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send SSL negotiation packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\t/* Ok, wait for response */\n\t\t\t\t\tconn->status = CONNECTION_SSL_STARTUP;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_SSL */\n\n\t\t\t\t/*\n\t\t\t\t * Build the startup packet.\n\t\t\t\t */\n\t\t\t\tstartpacket = pqBuildStartupPacket3(conn, &packetlen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEnvironmentOptions);\n\t\t\t\tif (!startpacket)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Send the startup packet.\n\t\t\t\t *\n\t\t\t\t * Theoretically, this could block, but it really shouldn't\n\t\t\t\t * since we only got here if the socket is write-ready.\n\t\t\t\t */\n\t\t\t\tif (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"could not send startup packet: %s\\n\"),\n\t\t\t\t\t\t\t\t\t  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));\n\t\t\t\t\tfree(startpacket);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\tfree(startpacket);\n\n\t\t\t\tconn->status = CONNECTION_AWAITING_RESPONSE;\n\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Handle SSL negotiation: wait for postmaster messages and\n\t\t\t * respond as necessary.\n\t\t\t */\n\t\tcase CONNECTION_SSL_STARTUP:\n\t\t\t{\n#ifdef USE_SSL\n\t\t\t\tPostgresPollingStatusType pollres;\n\n\t\t\t\t/*\n\t\t\t\t * On first time through, get the postmaster's response to our\n\t\t\t\t * SSL negotiation packet.\n\t\t\t\t */\n\t\t\t\tif (!conn->ssl_in_use)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We use pqReadData here since it has the logic to\n\t\t\t\t\t * distinguish no-data-yet from connection closure. Since\n\t\t\t\t\t * conn->ssl isn't set, a plain recv() will occur.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tSSLok;\n\t\t\t\t\tint\t\t\trdresult;\n\n\t\t\t\t\trdresult = pqReadData(conn);\n\t\t\t\t\tif (rdresult < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* errorMessage is already filled in */\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\tif (rdresult == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* caller failed to wait for data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\tif (pqGetc(&SSLok, conn) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* should not happen really */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\tif (SSLok == 'S')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Set up global SSL state if required.  The crypto\n\t\t\t\t\t\t * state has already been set if libpq took care of\n\t\t\t\t\t\t * doing that, so there is no need to make that happen\n\t\t\t\t\t\t * again.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (pqsecure_initialize(conn, true, false) != 0)\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t\telse if (SSLok == 'N')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\t\tconn->inStart = conn->inCursor;\n\t\t\t\t\t\t/* OK to do without SSL? */\n\t\t\t\t\t\tif (conn->sslmode[0] == 'r' ||\t/* \"require\" */\n\t\t\t\t\t\t\tconn->sslmode[0] == 'v')\t/* \"verify-ca\" or\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * \"verify-full\" */\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Require SSL, but server does not want it */\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server does not support SSL, but SSL was required\\n\"));\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Otherwise, proceed with normal startup */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\t/* We can proceed using this connection */\n\t\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t}\n\t\t\t\t\telse if (SSLok == 'E')\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Server failure of some sort, such as failure to\n\t\t\t\t\t\t * fork a backend process.  We need to process and\n\t\t\t\t\t\t * report the error message, which might be formatted\n\t\t\t\t\t\t * according to either protocol 2 or protocol 3.\n\t\t\t\t\t\t * Rather than duplicate the code for that, we flip\n\t\t\t\t\t\t * into AWAITING_RESPONSE state and let the code there\n\t\t\t\t\t\t * deal with it.  Note we have *not* consumed the \"E\"\n\t\t\t\t\t\t * byte here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_AWAITING_RESPONSE;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"received invalid response to SSL negotiation: %c\\n\"),\n\t\t\t\t\t\t\t\t\t\t  SSLok);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Begin or continue the SSL negotiation process.\n\t\t\t\t */\n\t\t\t\tpollres = pqsecure_open_client(conn);\n\t\t\t\tif (pollres == PGRES_POLLING_OK)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * At this point we should have no data already buffered.\n\t\t\t\t\t * If we do, it was received before we performed the SSL\n\t\t\t\t\t * handshake, so it wasn't encrypted and indeed may have\n\t\t\t\t\t * been injected by a man-in-the-middle.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->inCursor != conn->inEnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"received unencrypted data after SSL response\\n\"));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* SSL handshake done, ready to send startup packet */\n\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t}\n\t\t\t\tif (pollres == PGRES_POLLING_FAILED)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Failed ... if sslmode is \"prefer\" then do a non-SSL\n\t\t\t\t\t * retry\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'p' /* \"prefer\" */\n\t\t\t\t\t\t&& conn->allow_ssl_try\t/* redundant? */\n\t\t\t\t\t\t&& !conn->wait_ssl_try) /* redundant? */\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else it's a hard failure */\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\t/* Else, return POLLING_READING or POLLING_WRITING status */\n\t\t\t\treturn pollres;\n#else\t\t\t\t\t\t\t/* !USE_SSL */\n\t\t\t\t/* can't get here */\n\t\t\t\tgoto error_return;\n#endif\t\t\t\t\t\t\t/* USE_SSL */\n\t\t\t}\n\n\t\tcase CONNECTION_GSS_STARTUP:\n\t\t\t{\n#ifdef ENABLE_GSS\n\t\t\t\tPostgresPollingStatusType pollres;\n\n\t\t\t\t/*\n\t\t\t\t * If we haven't yet, get the postmaster's response to our\n\t\t\t\t * negotiation packet\n\t\t\t\t */\n\t\t\t\tif (conn->try_gss && !conn->gctx)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tgss_ok;\n\t\t\t\t\tint\t\t\trdresult = pqReadData(conn);\n\n\t\t\t\t\tif (rdresult < 0)\n\t\t\t\t\t\t/* pqReadData fills in error message */\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\telse if (rdresult == 0)\n\t\t\t\t\t\t/* caller failed to wait for data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\tif (pqGetc(&gss_ok, conn) < 0)\n\t\t\t\t\t\t/* shouldn't happen... */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\t\tif (gss_ok == 'E')\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Server failure of some sort.  Assume it's a\n\t\t\t\t\t\t * protocol version support failure, and let's see if\n\t\t\t\t\t\t * we can't recover (if it's not, we'll get a better\n\t\t\t\t\t\t * error message on retry).  Server gets fussy if we\n\t\t\t\t\t\t * don't hang up the socket, though.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* mark byte consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\tif (gss_ok == 'N')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Server doesn't want GSSAPI; fall back if we can */\n\t\t\t\t\t\tif (conn->gssencmode[0] == 'r')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server doesn't support GSSAPI encryption, but it was required\\n\"));\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\t/* We can proceed using this connection */\n\t\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t\t}\n\t\t\t\t\telse if (gss_ok != 'G')\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t  libpq_gettext(\"received invalid response to GSSAPI negotiation: %c\\n\"),\n\t\t\t\t\t\t\t\t\t\t  gss_ok);\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Begin or continue GSSAPI negotiation */\n\t\t\t\tpollres = pqsecure_open_gss(conn);\n\t\t\t\tif (pollres == PGRES_POLLING_OK)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * At this point we should have no data already buffered.\n\t\t\t\t\t * If we do, it was received before we performed the GSS\n\t\t\t\t\t * handshake, so it wasn't encrypted and indeed may have\n\t\t\t\t\t * been injected by a man-in-the-middle.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->inCursor != conn->inEnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"received unencrypted data after GSSAPI encryption response\\n\"));\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* All set for startup packet */\n\t\t\t\t\tconn->status = CONNECTION_MADE;\n\t\t\t\t\treturn PGRES_POLLING_WRITING;\n\t\t\t\t}\n\t\t\t\telse if (pollres == PGRES_POLLING_FAILED &&\n\t\t\t\t\t\t conn->gssencmode[0] == 'p')\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We failed, but we can retry on \"prefer\".  Have to drop\n\t\t\t\t\t * the current connection to do so, though.\n\t\t\t\t\t */\n\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\t\t\t\treturn pollres;\n#else\t\t\t\t\t\t\t/* !ENABLE_GSS */\n\t\t\t\t/* unreachable */\n\t\t\t\tgoto error_return;\n#endif\t\t\t\t\t\t\t/* ENABLE_GSS */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Handle authentication exchange: wait for postmaster messages\n\t\t\t * and respond as necessary.\n\t\t\t */\n\t\tcase CONNECTION_AWAITING_RESPONSE:\n\t\t\t{\n\t\t\t\tchar\t\tberesp;\n\t\t\t\tint\t\t\tmsgLength;\n\t\t\t\tint\t\t\tavail;\n\t\t\t\tAuthRequest areq;\n\t\t\t\tint\t\t\tres;\n\n\t\t\t\t/*\n\t\t\t\t * Scan the message from current point (note that if we find\n\t\t\t\t * the message is incomplete, we will return without advancing\n\t\t\t\t * inStart, and resume here next time).\n\t\t\t\t */\n\t\t\t\tconn->inCursor = conn->inStart;\n\n\t\t\t\t/* Read type byte */\n\t\t\t\tif (pqGetc(&beresp, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Validate message type: we expect only an authentication\n\t\t\t\t * request or an error here.  Anything else probably means\n\t\t\t\t * it's not Postgres on the other end at all.\n\t\t\t\t */\n\t\t\t\tif (!(beresp == 'R' || beresp == 'E'))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"expected authentication request from server, but received %c\\n\"),\n\t\t\t\t\t\t\t\t\t  beresp);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* Read message length word */\n\t\t\t\tif (pqGetInt(&msgLength, 4, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Try to validate message length before using it.\n\t\t\t\t * Authentication requests can't be very large, although GSS\n\t\t\t\t * auth requests may not be that small.  Errors can be a\n\t\t\t\t * little larger, but not huge.  If we see a large apparent\n\t\t\t\t * length in an error, it means we're really talking to a\n\t\t\t\t * pre-3.0-protocol server; cope.  (Before version 14, the\n\t\t\t\t * server also used the old protocol for errors that happened\n\t\t\t\t * before processing the startup packet.)\n\t\t\t\t */\n\t\t\t\tif (beresp == 'R' && (msgLength < 8 || msgLength > 2000))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"expected authentication request from server, but received %c\\n\"),\n\t\t\t\t\t\t\t\t\t  beresp);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\tif (beresp == 'E' && (msgLength < 8 || msgLength > 30000))\n\t\t\t\t{\n\t\t\t\t\t/* Handle error from a pre-3.0 server */\n\t\t\t\t\tconn->inCursor = conn->inStart + 1; /* reread data */\n\t\t\t\t\tif (pqGets_append(&conn->errorMessage, conn))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\t/* OK, we read the message; mark data consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Before 7.2, the postmaster didn't always end its\n\t\t\t\t\t * messages with a newline, so add one if needed to\n\t\t\t\t\t * conform to libpq conventions.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->errorMessage.len == 0 ||\n\t\t\t\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferChar(&conn->errorMessage, '\\n');\n\t\t\t\t\t}\n\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Can't process if message body isn't all here yet.\n\t\t\t\t */\n\t\t\t\tmsgLength -= 4;\n\t\t\t\tavail = conn->inEnd - conn->inCursor;\n\t\t\t\tif (avail < msgLength)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Before returning, try to enlarge the input buffer if\n\t\t\t\t\t * needed to hold the whole message; see notes in\n\t\t\t\t\t * pqParseInput3.\n\t\t\t\t\t */\n\t\t\t\t\tif (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength,\n\t\t\t\t\t\t\t\t\t\t\t conn))\n\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/* Handle errors. */\n\t\t\t\tif (beresp == 'E')\n\t\t\t\t{\n\t\t\t\t\tif (pqGetErrorNotice3(conn, true))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We'll come back when there is more data */\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\t\t\t\t\t/* OK, we read the message; mark data consumed */\n\t\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If error is \"cannot connect now\", try the next host if\n\t\t\t\t\t * any (but we don't want to consider additional addresses\n\t\t\t\t\t * for this host, nor is there much point in changing SSL\n\t\t\t\t\t * or GSS mode).  This is helpful when dealing with\n\t\t\t\t\t * standby servers that might not be in hot-standby state.\n\t\t\t\t\t */\n\t\t\t\t\tif (strcmp(conn->last_sqlstate,\n\t\t\t\t\t\t\t   ERRCODE_CANNOT_CONNECT_NOW) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check to see if we should mention pgpassfile */\n\t\t\t\t\tpgpassfileWarning(conn);\n\n#ifdef ENABLE_GSS\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If gssencmode is \"prefer\" and we're using GSSAPI, retry\n\t\t\t\t\t * without it.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->gssenc && conn->gssencmode[0] == 'p')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->try_gss = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\n\n#ifdef USE_SSL\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if sslmode is \"allow\" and we haven't tried an SSL\n\t\t\t\t\t * connection already, then retry with an SSL connection\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'a' /* \"allow\" */\n\t\t\t\t\t\t&& !conn->ssl_in_use\n\t\t\t\t\t\t&& conn->allow_ssl_try\n\t\t\t\t\t\t&& conn->wait_ssl_try)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->wait_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if sslmode is \"prefer\" and we're in an SSL connection,\n\t\t\t\t\t * then do a non-SSL retry\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sslmode[0] == 'p' /* \"prefer\" */\n\t\t\t\t\t\t&& conn->ssl_in_use\n\t\t\t\t\t\t&& conn->allow_ssl_try\t/* redundant? */\n\t\t\t\t\t\t&& !conn->wait_ssl_try) /* redundant? */\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only retry once */\n\t\t\t\t\t\tconn->allow_ssl_try = false;\n\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n#endif\n\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* It is an authentication request. */\n\t\t\t\tconn->auth_req_received = true;\n\n\t\t\t\t/* Get the type of request. */\n\t\t\t\tif (pqGetInt((int *) &areq, 4, conn))\n\t\t\t\t{\n\t\t\t\t\t/* We'll come back when there are more data */\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\t\t\t\tmsgLength -= 4;\n\n\t\t\t\t/*\n\t\t\t\t * Process the rest of the authentication request message, and\n\t\t\t\t * respond to it if necessary.\n\t\t\t\t *\n\t\t\t\t * Note that conn->pghost must be non-NULL if we are going to\n\t\t\t\t * avoid the Kerberos code doing a hostname look-up.\n\t\t\t\t */\n\t\t\t\tres = pg_fe_sendauth(areq, msgLength, conn);\n\n\t\t\t\t/* OK, we have processed the message; mark data consumed */\n\t\t\t\tconn->inStart = conn->inCursor;\n\n\t\t\t\tif (res != STATUS_OK)\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\t/*\n\t\t\t\t * Just make sure that any data sent by pg_fe_sendauth is\n\t\t\t\t * flushed out.  Although this theoretically could block, it\n\t\t\t\t * really shouldn't since we don't send large auth responses.\n\t\t\t\t */\n\t\t\t\tif (pqFlush(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (areq == AUTH_REQ_OK)\n\t\t\t\t{\n\t\t\t\t\t/* We are done with authentication exchange */\n\t\t\t\t\tconn->status = CONNECTION_AUTH_OK;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set asyncStatus so that PQgetResult will think that\n\t\t\t\t\t * what comes back next is the result of a query.  See\n\t\t\t\t\t * below.\n\t\t\t\t\t */\n\t\t\t\t\tconn->asyncStatus = PGASYNC_BUSY;\n\t\t\t\t}\n\n\t\t\t\t/* Look to see if we have more data yet. */\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_AUTH_OK:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Now we expect to hear from the backend. A ReadyForQuery\n\t\t\t\t * message indicates that startup is successful, but we might\n\t\t\t\t * also get an Error message indicating failure. (Notice\n\t\t\t\t * messages indicating nonfatal warnings are also allowed by\n\t\t\t\t * the protocol, as are ParameterStatus and BackendKeyData\n\t\t\t\t * messages.) Easiest way to handle this is to let\n\t\t\t\t * PQgetResult() read the messages. We just have to fake it\n\t\t\t\t * out about the state of the connection, by setting\n\t\t\t\t * asyncStatus = PGASYNC_BUSY (done above).\n\t\t\t\t */\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\n\t\t\t\tres = PQgetResult(conn);\n\n\t\t\t\t/*\n\t\t\t\t * NULL return indicating we have gone to IDLE state is\n\t\t\t\t * expected\n\t\t\t\t */\n\t\t\t\tif (res)\n\t\t\t\t{\n\t\t\t\t\tif (res->resultStatus != PGRES_FATAL_ERROR)\n\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"unexpected message from server during startup\\n\"));\n\t\t\t\t\telse if (conn->send_appname &&\n\t\t\t\t\t\t\t (conn->appname || conn->fbappname))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If we tried to send application_name, check to see\n\t\t\t\t\t\t * if the error is about that --- pre-9.0 servers will\n\t\t\t\t\t\t * reject it at this stage of the process.  If so,\n\t\t\t\t\t\t * close the connection and retry without sending\n\t\t\t\t\t\t * application_name.  We could possibly get a false\n\t\t\t\t\t\t * SQLSTATE match here and retry uselessly, but there\n\t\t\t\t\t\t * seems no great harm in that; we'll just get the\n\t\t\t\t\t\t * same error again if it's unrelated.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst char *sqlstate;\n\n\t\t\t\t\t\tsqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);\n\t\t\t\t\t\tif (sqlstate &&\n\t\t\t\t\t\t\tstrcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPQclear(res);\n\t\t\t\t\t\t\tconn->send_appname = false;\n\t\t\t\t\t\t\tneed_new_connection = true;\n\t\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * if the resultStatus is FATAL, then conn->errorMessage\n\t\t\t\t\t * already has a copy of the error; needn't copy it back.\n\t\t\t\t\t * But add a newline if it's not there already, since\n\t\t\t\t\t * postmaster error messages may not have one.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->errorMessage.len <= 0 ||\n\t\t\t\t\t\tconn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')\n\t\t\t\t\t\tappendPQExpBufferChar(&conn->errorMessage, '\\n');\n\t\t\t\t\tPQclear(res);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\t/* Almost there now ... */\n\t\t\t\tconn->status = CONNECTION_CHECK_TARGET;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_TARGET:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If a read-write, read-only, primary, or standby connection\n\t\t\t\t * is required, see if we have one.\n\t\t\t\t */\n\t\t\t\tif (conn->target_server_type == SERVER_TYPE_READ_WRITE ||\n\t\t\t\t\tconn->target_server_type == SERVER_TYPE_READ_ONLY)\n\t\t\t\t{\n\t\t\t\t\tbool\t\tread_only_server;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the server didn't report\n\t\t\t\t\t * \"default_transaction_read_only\" or \"in_hot_standby\" at\n\t\t\t\t\t * startup, we must determine its state by sending the\n\t\t\t\t\t * query \"SHOW transaction_read_only\".  This GUC exists in\n\t\t\t\t\t * all server versions that support 3.0 protocol.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->default_transaction_read_only == PG_BOOL_UNKNOWN ||\n\t\t\t\t\t\tconn->in_hot_standby == PG_BOOL_UNKNOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We use PQsendQueryContinue so that\n\t\t\t\t\t\t * conn->errorMessage does not get cleared.  We need\n\t\t\t\t\t\t * to preserve any error messages related to previous\n\t\t\t\t\t\t * hosts we have tried and failed to connect to.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tif (!PQsendQueryContinue(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t \"SHOW transaction_read_only\"))\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t/* We'll return to this state when we have the answer */\n\t\t\t\t\t\tconn->status = CONNECTION_CHECK_WRITABLE;\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* OK, we can make the test */\n\t\t\t\t\tread_only_server =\n\t\t\t\t\t\t(conn->default_transaction_read_only == PG_BOOL_YES ||\n\t\t\t\t\t\t conn->in_hot_standby == PG_BOOL_YES);\n\n\t\t\t\t\tif ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ?\n\t\t\t\t\t\tread_only_server : !read_only_server)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Wrong server state, reject and try the next host */\n\t\t\t\t\t\tif (conn->target_server_type == SERVER_TYPE_READ_WRITE)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"session is read-only\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"session is not read-only\\n\"));\n\n\t\t\t\t\t\t/* Close connection politely. */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Try next host if any, but we don't want to consider\n\t\t\t\t\t\t * additional addresses for this host.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (conn->target_server_type == SERVER_TYPE_PRIMARY ||\n\t\t\t\t\t\t conn->target_server_type == SERVER_TYPE_STANDBY ||\n\t\t\t\t\t\t conn->target_server_type == SERVER_TYPE_PREFER_STANDBY)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If the server didn't report \"in_hot_standby\" at\n\t\t\t\t\t * startup, we must determine its state by sending the\n\t\t\t\t\t * query \"SELECT pg_catalog.pg_is_in_recovery()\".  Servers\n\t\t\t\t\t * before 9.0 don't have that function, but by the same\n\t\t\t\t\t * token they don't have any standby mode, so we may just\n\t\t\t\t\t * assume the result.\n\t\t\t\t\t */\n\t\t\t\t\tif (conn->sversion < 90000)\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\n\t\t\t\t\tif (conn->in_hot_standby == PG_BOOL_UNKNOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We use PQsendQueryContinue so that\n\t\t\t\t\t\t * conn->errorMessage does not get cleared.  We need\n\t\t\t\t\t\t * to preserve any error messages related to previous\n\t\t\t\t\t\t * hosts we have tried and failed to connect to.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tif (!PQsendQueryContinue(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t \"SELECT pg_catalog.pg_is_in_recovery()\"))\n\t\t\t\t\t\t\tgoto error_return;\n\t\t\t\t\t\t/* We'll return to this state when we have the answer */\n\t\t\t\t\t\tconn->status = CONNECTION_CHECK_STANDBY;\n\t\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* OK, we can make the test */\n\t\t\t\t\tif ((conn->target_server_type == SERVER_TYPE_PRIMARY) ?\n\t\t\t\t\t\t(conn->in_hot_standby == PG_BOOL_YES) :\n\t\t\t\t\t\t(conn->in_hot_standby == PG_BOOL_NO))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Wrong server state, reject and try the next host */\n\t\t\t\t\t\tif (conn->target_server_type == SERVER_TYPE_PRIMARY)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server is in hot standby mode\\n\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"server is not in hot standby mode\\n\"));\n\n\t\t\t\t\t\t/* Close connection politely. */\n\t\t\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Try next host if any, but we don't want to consider\n\t\t\t\t\t\t * additional addresses for this host.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->try_next_host = true;\n\t\t\t\t\t\tgoto keep_going;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* We can release the address list now. */\n\t\t\t\trelease_conn_addrinfo(conn);\n\n\t\t\t\t/*\n\t\t\t\t * Contents of conn->errorMessage are no longer interesting\n\t\t\t\t * (and it seems some clients expect it to be empty after a\n\t\t\t\t * successful connection).\n\t\t\t\t */\n\t\t\t\tresetPQExpBuffer(&conn->errorMessage);\n\n\t\t\t\t/* We are open for business! */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\treturn PGRES_POLLING_OK;\n\t\t\t}\n\n\t\tcase CONNECTION_CONSUME:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This state just makes sure the connection is idle after\n\t\t\t\t * we've obtained the result of a SHOW or SELECT query.  Once\n\t\t\t\t * we're clear, return to CONNECTION_CHECK_TARGET state to\n\t\t\t\t * decide what to do next.  We must transiently set status =\n\t\t\t\t * CONNECTION_OK in order to use the result-consuming\n\t\t\t\t * subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\t/* Call PQgetResult() again until we get a NULL result */\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res != NULL)\n\t\t\t\t{\n\t\t\t\t\tPQclear(res);\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tconn->status = CONNECTION_CHECK_TARGET;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_WRITABLE:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Waiting for result of \"SHOW transaction_read_only\".  We\n\t\t\t\t * must transiently set status = CONNECTION_OK in order to use\n\t\t\t\t * the result-consuming subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CHECK_WRITABLE;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res && PQresultStatus(res) == PGRES_TUPLES_OK &&\n\t\t\t\t\tPQntuples(res) == 1)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *val = PQgetvalue(res, 0, 0);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * \"transaction_read_only = on\" proves that at least one\n\t\t\t\t\t * of default_transaction_read_only and in_hot_standby is\n\t\t\t\t\t * on, but we don't actually know which.  We don't care\n\t\t\t\t\t * though for the purpose of identifying a read-only\n\t\t\t\t\t * session, so satisfy the CONNECTION_CHECK_TARGET code by\n\t\t\t\t\t * claiming they are both on.  On the other hand, if it's\n\t\t\t\t\t * a read-write session, they are certainly both off.\n\t\t\t\t\t */\n\t\t\t\t\tif (strncmp(val, \"on\", 2) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->default_transaction_read_only = PG_BOOL_YES;\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_YES;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->default_transaction_read_only = PG_BOOL_NO;\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\t\t\t\t\t}\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t\t/* Finish reading messages before continuing */\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Something went wrong with \"SHOW transaction_read_only\". */\n\t\t\t\tif (res)\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t/* Append error report to conn->errorMessage. */\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"\\\"%s\\\" failed\\n\"),\n\t\t\t\t\t\t\t\t  \"SHOW transaction_read_only\");\n\n\t\t\t\t/* Close connection politely. */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t/* Try next host. */\n\t\t\t\tconn->try_next_host = true;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tcase CONNECTION_CHECK_STANDBY:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Waiting for result of \"SELECT pg_is_in_recovery()\".  We\n\t\t\t\t * must transiently set status = CONNECTION_OK in order to use\n\t\t\t\t * the result-consuming subroutines.\n\t\t\t\t */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tif (!PQconsumeInput(conn))\n\t\t\t\t\tgoto error_return;\n\n\t\t\t\tif (PQisBusy(conn))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_CHECK_STANDBY;\n\t\t\t\t\treturn PGRES_POLLING_READING;\n\t\t\t\t}\n\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tif (res && PQresultStatus(res) == PGRES_TUPLES_OK &&\n\t\t\t\t\tPQntuples(res) == 1)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *val = PQgetvalue(res, 0, 0);\n\n\t\t\t\t\tif (strncmp(val, \"t\", 1) == 0)\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_YES;\n\t\t\t\t\telse\n\t\t\t\t\t\tconn->in_hot_standby = PG_BOOL_NO;\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t\t/* Finish reading messages before continuing */\n\t\t\t\t\tconn->status = CONNECTION_CONSUME;\n\t\t\t\t\tgoto keep_going;\n\t\t\t\t}\n\n\t\t\t\t/* Something went wrong with \"SELECT pg_is_in_recovery()\". */\n\t\t\t\tif (res)\n\t\t\t\t\tPQclear(res);\n\n\t\t\t\t/* Append error report to conn->errorMessage. */\n\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"\\\"%s\\\" failed\\n\"),\n\t\t\t\t\t\t\t\t  \"SELECT pg_is_in_recovery()\");\n\n\t\t\t\t/* Close connection politely. */\n\t\t\t\tconn->status = CONNECTION_OK;\n\t\t\t\tsendTerminateConn(conn);\n\n\t\t\t\t/* Try next host. */\n\t\t\t\tconn->try_next_host = true;\n\t\t\t\tgoto keep_going;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection state %d, \"\n\t\t\t\t\t\t\t\t\t\t\t\"probably indicative of memory corruption\\n\"),\n\t\t\t\t\t\t\t  conn->status);\n\t\t\tgoto error_return;\n\t}\n\n\t/* Unreachable */\n\nerror_return:\n\n\t/*\n\t * We used to close the socket at this point, but that makes it awkward\n\t * for those above us if they wish to remove this socket from their own\n\t * records (an fd_set for example).  We'll just have this socket closed\n\t * when PQfinish is called (which is compulsory even after an error, since\n\t * the connection structure must be freed).\n\t */\n\tconn->status = CONNECTION_BAD;\n\treturn PGRES_POLLING_FAILED;\n}\n\n\n/*\n * internal_ping\n *\t\tDetermine if a server is running and if we can connect to it.\n *\n * The argument is a connection that's been started, but not completed.\n */\nstatic PGPing\ninternal_ping(PGconn *conn)\n{\n\t/* Say \"no attempt\" if we never got to PQconnectPoll */\n\tif (!conn || !conn->options_valid)\n\t\treturn PQPING_NO_ATTEMPT;\n\n\t/* Attempt to complete the connection */\n\tif (conn->status != CONNECTION_BAD)\n\t\t(void) connectDBComplete(conn);\n\n\t/* Definitely OK if we succeeded */\n\tif (conn->status != CONNECTION_BAD)\n\t\treturn PQPING_OK;\n\n\t/*\n\t * Here begins the interesting part of \"ping\": determine the cause of the\n\t * failure in sufficient detail to decide what to return.  We do not want\n\t * to report that the server is not up just because we didn't have a valid\n\t * password, for example.  In fact, any sort of authentication request\n\t * implies the server is up.  (We need this check since the libpq side of\n\t * things might have pulled the plug on the connection before getting an\n\t * error as such from the postmaster.)\n\t */\n\tif (conn->auth_req_received)\n\t\treturn PQPING_OK;\n\n\t/*\n\t * If we failed to get any ERROR response from the postmaster, report\n\t * PQPING_NO_RESPONSE.  This result could be somewhat misleading for a\n\t * pre-7.4 server, since it won't send back a SQLSTATE, but those are long\n\t * out of support.  Another corner case where the server could return a\n\t * failure without a SQLSTATE is fork failure, but PQPING_NO_RESPONSE\n\t * isn't totally unreasonable for that anyway.  We expect that every other\n\t * failure case in a modern server will produce a report with a SQLSTATE.\n\t *\n\t * NOTE: whenever we get around to making libpq generate SQLSTATEs for\n\t * client-side errors, we should either not store those into\n\t * last_sqlstate, or add an extra flag so we can tell client-side errors\n\t * apart from server-side ones.\n\t */\n\tif (strlen(conn->last_sqlstate) != 5)\n\t\treturn PQPING_NO_RESPONSE;\n\n\t/*\n\t * Report PQPING_REJECT if server says it's not accepting connections. (We\n\t * distinguish this case mainly for the convenience of pg_ctl.)\n\t */\n\tif (strcmp(conn->last_sqlstate, ERRCODE_CANNOT_CONNECT_NOW) == 0)\n\t\treturn PQPING_REJECT;\n\n\t/*\n\t * Any other SQLSTATE can be taken to indicate that the server is up.\n\t * Presumably it didn't like our username, password, or database name; or\n\t * perhaps it had some transient failure, but that should not be taken as\n\t * meaning \"it's down\".\n\t */\n\treturn PQPING_OK;\n}\n\n\n/*\n * makeEmptyPGconn\n *\t - create a PGconn data structure with (as yet) no interesting data\n */\nstatic PGconn *\nmakeEmptyPGconn(void)\n{\n\tPGconn\t   *conn;\n\n#ifdef WIN32\n\n\t/*\n\t * Make sure socket support is up and running in this process.\n\t *\n\t * Note: the Windows documentation says that we should eventually do a\n\t * matching WSACleanup() call, but experience suggests that that is at\n\t * least as likely to cause problems as fix them.  So we don't.\n\t */\n\tstatic bool wsastartup_done = false;\n\n\tif (!wsastartup_done)\n\t{\n\t\tWSADATA\t\twsaData;\n\n\t\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\t\treturn NULL;\n\t\twsastartup_done = true;\n\t}\n\n\t/* Forget any earlier error */\n\tWSASetLastError(0);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tconn = (PGconn *) malloc(sizeof(PGconn));\n\tif (conn == NULL)\n\t\treturn conn;\n\n\t/* Zero all pointers and booleans */\n\tMemSet(conn, 0, sizeof(PGconn));\n\n\t/* install default notice hooks */\n\tconn->noticeHooks.noticeRec = defaultNoticeReceiver;\n\tconn->noticeHooks.noticeProc = defaultNoticeProcessor;\n\n\tconn->status = CONNECTION_BAD;\n\tconn->asyncStatus = PGASYNC_IDLE;\n\tconn->pipelineStatus = PQ_PIPELINE_OFF;\n\tconn->xactStatus = PQTRANS_IDLE;\n\tconn->options_valid = false;\n\tconn->nonblocking = false;\n\tconn->client_encoding = PG_SQL_ASCII;\n\tconn->std_strings = false;\t/* unless server says differently */\n\tconn->default_transaction_read_only = PG_BOOL_UNKNOWN;\n\tconn->in_hot_standby = PG_BOOL_UNKNOWN;\n\tconn->verbosity = PQERRORS_DEFAULT;\n\tconn->show_context = PQSHOW_CONTEXT_ERRORS;\n\tconn->sock = PGINVALID_SOCKET;\n\tconn->Pfdebug = NULL;\n\n\t/*\n\t * We try to send at least 8K at a time, which is the usual size of pipe\n\t * buffers on Unix systems.  That way, when we are sending a large amount\n\t * of data, we avoid incurring extra kernel context swaps for partial\n\t * bufferloads.  The output buffer is initially made 16K in size, and we\n\t * try to dump it after accumulating 8K.\n\t *\n\t * With the same goal of minimizing context swaps, the input buffer will\n\t * be enlarged anytime it has less than 8K free, so we initially allocate\n\t * twice that.\n\t */\n\tconn->inBufSize = 16 * 1024;\n\tconn->inBuffer = (char *) malloc(conn->inBufSize);\n\tconn->outBufSize = 16 * 1024;\n\tconn->outBuffer = (char *) malloc(conn->outBufSize);\n\tconn->rowBufLen = 32;\n\tconn->rowBuf = (PGdataValue *) malloc(conn->rowBufLen * sizeof(PGdataValue));\n\tinitPQExpBuffer(&conn->errorMessage);\n\tinitPQExpBuffer(&conn->workBuffer);\n\n\tif (conn->inBuffer == NULL ||\n\t\tconn->outBuffer == NULL ||\n\t\tconn->rowBuf == NULL ||\n\t\tPQExpBufferBroken(&conn->errorMessage) ||\n\t\tPQExpBufferBroken(&conn->workBuffer))\n\t{\n\t\t/* out of memory already :-( */\n\t\tfreePGconn(conn);\n\t\tconn = NULL;\n\t}\n\n\treturn conn;\n}\n\n/*\n * freePGconn\n *\t - free an idle (closed) PGconn data structure\n *\n * NOTE: this should not overlap any functionality with closePGconn().\n * Clearing/resetting of transient state belongs there; what we do here is\n * release data that is to be held for the life of the PGconn structure.\n * If a value ought to be cleared/freed during PQreset(), do it there not here.\n */\nstatic void\nfreePGconn(PGconn *conn)\n{\n\tint\t\t\ti;\n\n\t/* let any event procs clean up their state data */\n\tfor (i = 0; i < conn->nEvents; i++)\n\t{\n\t\tPGEventConnDestroy evt;\n\n\t\tevt.conn = conn;\n\t\t(void) conn->events[i].proc(PGEVT_CONNDESTROY, &evt,\n\t\t\t\t\t\t\t\t\tconn->events[i].passThrough);\n\t\tfree(conn->events[i].name);\n\t}\n\n\t/* clean up pg_conn_host structures */\n\tif (conn->connhost != NULL)\n\t{\n\t\tfor (i = 0; i < conn->nconnhost; ++i)\n\t\t{\n\t\t\tif (conn->connhost[i].host != NULL)\n\t\t\t\tfree(conn->connhost[i].host);\n\t\t\tif (conn->connhost[i].hostaddr != NULL)\n\t\t\t\tfree(conn->connhost[i].hostaddr);\n\t\t\tif (conn->connhost[i].port != NULL)\n\t\t\t\tfree(conn->connhost[i].port);\n\t\t\tif (conn->connhost[i].password != NULL)\n\t\t\t{\n\t\t\t\texplicit_bzero(conn->connhost[i].password, strlen(conn->connhost[i].password));\n\t\t\t\tfree(conn->connhost[i].password);\n\t\t\t}\n\t\t}\n\t\tfree(conn->connhost);\n\t}\n\n\tif (conn->client_encoding_initial)\n\t\tfree(conn->client_encoding_initial);\n\tif (conn->events)\n\t\tfree(conn->events);\n\tif (conn->pghost)\n\t\tfree(conn->pghost);\n\tif (conn->pghostaddr)\n\t\tfree(conn->pghostaddr);\n\tif (conn->pgport)\n\t\tfree(conn->pgport);\n\tif (conn->connect_timeout)\n\t\tfree(conn->connect_timeout);\n\tif (conn->pgtcp_user_timeout)\n\t\tfree(conn->pgtcp_user_timeout);\n\tif (conn->pgoptions)\n\t\tfree(conn->pgoptions);\n\tif (conn->appname)\n\t\tfree(conn->appname);\n\tif (conn->fbappname)\n\t\tfree(conn->fbappname);\n\tif (conn->dbName)\n\t\tfree(conn->dbName);\n\tif (conn->replication)\n\t\tfree(conn->replication);\n\tif (conn->pguser)\n\t\tfree(conn->pguser);\n\tif (conn->pgpass)\n\t{\n\t\texplicit_bzero(conn->pgpass, strlen(conn->pgpass));\n\t\tfree(conn->pgpass);\n\t}\n\tif (conn->pgpassfile)\n\t\tfree(conn->pgpassfile);\n\tif (conn->channel_binding)\n\t\tfree(conn->channel_binding);\n\tif (conn->keepalives)\n\t\tfree(conn->keepalives);\n\tif (conn->keepalives_idle)\n\t\tfree(conn->keepalives_idle);\n\tif (conn->keepalives_interval)\n\t\tfree(conn->keepalives_interval);\n\tif (conn->keepalives_count)\n\t\tfree(conn->keepalives_count);\n\tif (conn->sslmode)\n\t\tfree(conn->sslmode);\n\tif (conn->sslcert)\n\t\tfree(conn->sslcert);\n\tif (conn->sslkey)\n\t\tfree(conn->sslkey);\n\tif (conn->sslpassword)\n\t{\n\t\texplicit_bzero(conn->sslpassword, strlen(conn->sslpassword));\n\t\tfree(conn->sslpassword);\n\t}\n\tif (conn->sslrootcert)\n\t\tfree(conn->sslrootcert);\n\tif (conn->sslcrl)\n\t\tfree(conn->sslcrl);\n\tif (conn->sslcrldir)\n\t\tfree(conn->sslcrldir);\n\tif (conn->sslcompression)\n\t\tfree(conn->sslcompression);\n\tif (conn->sslsni)\n\t\tfree(conn->sslsni);\n\tif (conn->requirepeer)\n\t\tfree(conn->requirepeer);\n\tif (conn->ssl_min_protocol_version)\n\t\tfree(conn->ssl_min_protocol_version);\n\tif (conn->ssl_max_protocol_version)\n\t\tfree(conn->ssl_max_protocol_version);\n\tif (conn->gssencmode)\n\t\tfree(conn->gssencmode);\n\tif (conn->krbsrvname)\n\t\tfree(conn->krbsrvname);\n\tif (conn->gsslib)\n\t\tfree(conn->gsslib);\n\tif (conn->connip)\n\t\tfree(conn->connip);\n\t/* Note that conn->Pfdebug is not ours to close or free */\n\tif (conn->write_err_msg)\n\t\tfree(conn->write_err_msg);\n\tif (conn->inBuffer)\n\t\tfree(conn->inBuffer);\n\tif (conn->outBuffer)\n\t\tfree(conn->outBuffer);\n\tif (conn->rowBuf)\n\t\tfree(conn->rowBuf);\n\tif (conn->target_session_attrs)\n\t\tfree(conn->target_session_attrs);\n\ttermPQExpBuffer(&conn->errorMessage);\n\ttermPQExpBuffer(&conn->workBuffer);\n\n\tfree(conn);\n}\n\n/*\n * release_conn_addrinfo\n *\t - Free any addrinfo list in the PGconn.\n */\nstatic void\nrelease_conn_addrinfo(PGconn *conn)\n{\n\tif (conn->addrlist)\n\t{\n\t\tpg_freeaddrinfo_all(conn->addrlist_family, conn->addrlist);\n\t\tconn->addrlist = NULL;\n\t\tconn->addr_cur = NULL;\t/* for safety */\n\t}\n}\n\n/*\n * sendTerminateConn\n *\t - Send a terminate message to backend.\n */\nstatic void\nsendTerminateConn(PGconn *conn)\n{\n\t/*\n\t * Note that the protocol doesn't allow us to send Terminate messages\n\t * during the startup phase.\n\t */\n\tif (conn->sock != PGINVALID_SOCKET && conn->status == CONNECTION_OK)\n\t{\n\t\t/*\n\t\t * Try to send \"close connection\" message to backend. Ignore any\n\t\t * error.\n\t\t */\n\t\tpqPutMsgStart('X', conn);\n\t\tpqPutMsgEnd(conn);\n\t\t(void) pqFlush(conn);\n\t}\n}\n\n/*\n * closePGconn\n *\t - properly close a connection to the backend\n *\n * This should reset or release all transient state, but NOT the connection\n * parameters.  On exit, the PGconn should be in condition to start a fresh\n * connection with the same parameters (see PQreset()).\n */\nstatic void\nclosePGconn(PGconn *conn)\n{\n\t/*\n\t * If possible, send Terminate message to close the connection politely.\n\t */\n\tsendTerminateConn(conn);\n\n\t/*\n\t * Must reset the blocking status so a possible reconnect will work.\n\t *\n\t * Don't call PQsetnonblocking() because it will fail if it's unable to\n\t * flush the connection.\n\t */\n\tconn->nonblocking = false;\n\n\t/*\n\t * Close the connection, reset all transient state, flush I/O buffers.\n\t * Note that this includes clearing conn->errorMessage; we're no longer\n\t * interested in any failures associated with the old connection, and we\n\t * want a clean slate for any new connection attempt.\n\t */\n\tpqDropConnection(conn, true);\n\tconn->status = CONNECTION_BAD;\t/* Well, not really _bad_ - just absent */\n\tconn->asyncStatus = PGASYNC_IDLE;\n\tconn->xactStatus = PQTRANS_IDLE;\n\tconn->pipelineStatus = PQ_PIPELINE_OFF;\n\tpqClearAsyncResult(conn);\t/* deallocate result */\n\tresetPQExpBuffer(&conn->errorMessage);\n\trelease_conn_addrinfo(conn);\n\n\t/* Reset all state obtained from server, too */\n\tpqDropServerData(conn);\n}\n\n/*\n * PQfinish: properly close a connection to the backend. Also frees\n * the PGconn data structure so it shouldn't be re-used after this.\n */\nvoid\nPQfinish(PGconn *conn)\n{\n\tif (conn)\n\t{\n\t\tclosePGconn(conn);\n\t\tfreePGconn(conn);\n\t}\n}\n\n/*\n * PQreset: resets the connection to the backend by closing the\n * existing connection and creating a new one.\n */\nvoid\nPQreset(PGconn *conn)\n{\n\tif (conn)\n\t{\n\t\tclosePGconn(conn);\n\n\t\tif (connectDBStart(conn) && connectDBComplete(conn))\n\t\t{\n\t\t\t/*\n\t\t\t * Notify event procs of successful reset.  We treat an event proc\n\t\t\t * failure as disabling the connection ... good idea?\n\t\t\t */\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < conn->nEvents; i++)\n\t\t\t{\n\t\t\t\tPGEventConnReset evt;\n\n\t\t\t\tevt.conn = conn;\n\t\t\t\tif (!conn->events[i].proc(PGEVT_CONNRESET, &evt,\n\t\t\t\t\t\t\t\t\t\t  conn->events[i].passThrough))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"PGEventProc \\\"%s\\\" failed during PGEVT_CONNRESET event\\n\"),\n\t\t\t\t\t\t\t\t\t  conn->events[i].name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/*\n * PQresetStart:\n * resets the connection to the backend\n * closes the existing connection and makes a new one\n * Returns 1 on success, 0 on failure.\n */\nint\nPQresetStart(PGconn *conn)\n{\n\tif (conn)\n\t{\n\t\tclosePGconn(conn);\n\n\t\treturn connectDBStart(conn);\n\t}\n\n\treturn 0;\n}\n\n\n/*\n * PQresetPoll:\n * resets the connection to the backend\n * closes the existing connection and makes a new one\n */\nPostgresPollingStatusType\nPQresetPoll(PGconn *conn)\n{\n\tif (conn)\n\t{\n\t\tPostgresPollingStatusType status = PQconnectPoll(conn);\n\n\t\tif (status == PGRES_POLLING_OK)\n\t\t{\n\t\t\t/*\n\t\t\t * Notify event procs of successful reset.  We treat an event proc\n\t\t\t * failure as disabling the connection ... good idea?\n\t\t\t */\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < conn->nEvents; i++)\n\t\t\t{\n\t\t\t\tPGEventConnReset evt;\n\n\t\t\t\tevt.conn = conn;\n\t\t\t\tif (!conn->events[i].proc(PGEVT_CONNRESET, &evt,\n\t\t\t\t\t\t\t\t\t\t  conn->events[i].passThrough))\n\t\t\t\t{\n\t\t\t\t\tconn->status = CONNECTION_BAD;\n\t\t\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"PGEventProc \\\"%s\\\" failed during PGEVT_CONNRESET event\\n\"),\n\t\t\t\t\t\t\t\t\t  conn->events[i].name);\n\t\t\t\t\treturn PGRES_POLLING_FAILED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn status;\n\t}\n\n\treturn PGRES_POLLING_FAILED;\n}\n\n/*\n * PQgetCancel: get a PGcancel structure corresponding to a connection.\n *\n * A copy is needed to be able to cancel a running query from a different\n * thread. If the same structure is used all structure members would have\n * to be individually locked (if the entire structure was locked, it would\n * be impossible to cancel a synchronous query because the structure would\n * have to stay locked for the duration of the query).\n */\nPGcancel *\nPQgetCancel(PGconn *conn)\n{\n\tPGcancel   *cancel;\n\n\tif (!conn)\n\t\treturn NULL;\n\n\tif (conn->sock == PGINVALID_SOCKET)\n\t\treturn NULL;\n\n\tcancel = malloc(sizeof(PGcancel));\n\tif (cancel == NULL)\n\t\treturn NULL;\n\n\tmemcpy(&cancel->raddr, &conn->raddr, sizeof(SockAddr));\n\tcancel->be_pid = conn->be_pid;\n\tcancel->be_key = conn->be_key;\n\n\treturn cancel;\n}\n\n/* PQfreeCancel: free a cancel structure */\nvoid\nPQfreeCancel(PGcancel *cancel)\n{\n\tif (cancel)\n\t\tfree(cancel);\n}\n\n\n/*\n * PQcancel and PQrequestCancel: attempt to request cancellation of the\n * current operation.\n *\n * The return value is true if the cancel request was successfully\n * dispatched, false if not (in which case an error message is available).\n * Note: successful dispatch is no guarantee that there will be any effect at\n * the backend.  The application must read the operation result as usual.\n *\n * CAUTION: we want this routine to be safely callable from a signal handler\n * (for example, an application might want to call it in a SIGINT handler).\n * This means we cannot use any C library routine that might be non-reentrant.\n * malloc/free are often non-reentrant, and anything that might call them is\n * just as dangerous.  We avoid sprintf here for that reason.  Building up\n * error messages with strcpy/strcat is tedious but should be quite safe.\n * We also save/restore errno in case the signal handler support doesn't.\n *\n * internal_cancel() is an internal helper function to make code-sharing\n * between the two versions of the cancel function possible.\n */\nstatic int\ninternal_cancel(SockAddr *raddr, int be_pid, int be_key,\n\t\t\t\tchar *errbuf, int errbufsize)\n{\n\tint\t\t\tsave_errno = SOCK_ERRNO;\n\tpgsocket\ttmpsock = PGINVALID_SOCKET;\n\tchar\t\tsebuf[PG_STRERROR_R_BUFLEN];\n\tint\t\t\tmaxlen;\n\tstruct\n\t{\n\t\tuint32\t\tpacketlen;\n\t\tCancelRequestPacket cp;\n\t}\t\t\tcrp;\n\n\t/*\n\t * We need to open a temporary connection to the postmaster. Do this with\n\t * only kernel calls.\n\t */\n\tif ((tmpsock = socket(raddr->addr.ss_family, SOCK_STREAM, 0)) == PGINVALID_SOCKET)\n\t{\n\t\tstrlcpy(errbuf, \"PQcancel() -- socket() failed: \", errbufsize);\n\t\tgoto cancel_errReturn;\n\t}\nretry3:\n\tif (connect(tmpsock, (struct sockaddr *) &raddr->addr,\n\t\t\t\traddr->salen) < 0)\n\t{\n\t\tif (SOCK_ERRNO == EINTR)\n\t\t\t/* Interrupted system call - we'll just try again */\n\t\t\tgoto retry3;\n\t\tstrlcpy(errbuf, \"PQcancel() -- connect() failed: \", errbufsize);\n\t\tgoto cancel_errReturn;\n\t}\n\n\t/*\n\t * We needn't set nonblocking I/O or NODELAY options here.\n\t */\n\n\t/* Create and send the cancel request packet. */\n\n\tcrp.packetlen = pg_hton32((uint32) sizeof(crp));\n\tcrp.cp.cancelRequestCode = (MsgType) pg_hton32(CANCEL_REQUEST_CODE);\n\tcrp.cp.backendPID = pg_hton32(be_pid);\n\tcrp.cp.cancelAuthCode = pg_hton32(be_key);\n\nretry4:\n\tif (send(tmpsock, (char *) &crp, sizeof(crp), 0) != (int) sizeof(crp))\n\t{\n\t\tif (SOCK_ERRNO == EINTR)\n\t\t\t/* Interrupted system call - we'll just try again */\n\t\t\tgoto retry4;\n\t\tstrlcpy(errbuf, \"PQcancel() -- send() failed: \", errbufsize);\n\t\tgoto cancel_errReturn;\n\t}\n\n\t/*\n\t * Wait for the postmaster to close the connection, which indicates that\n\t * it's processed the request.  Without this delay, we might issue another\n\t * command only to find that our cancel zaps that command instead of the\n\t * one we thought we were canceling.  Note we don't actually expect this\n\t * read to obtain any data, we are just waiting for EOF to be signaled.\n\t */\nretry5:\n\tif (recv(tmpsock, (char *) &crp, 1, 0) < 0)\n\t{\n\t\tif (SOCK_ERRNO == EINTR)\n\t\t\t/* Interrupted system call - we'll just try again */\n\t\t\tgoto retry5;\n\t\t/* we ignore other error conditions */\n\t}\n\n\t/* All done */\n\tclosesocket(tmpsock);\n\tSOCK_ERRNO_SET(save_errno);\n\treturn true;\n\ncancel_errReturn:\n\n\t/*\n\t * Make sure we don't overflow the error buffer. Leave space for the \\n at\n\t * the end, and for the terminating zero.\n\t */\n\tmaxlen = errbufsize - strlen(errbuf) - 2;\n\tif (maxlen >= 0)\n\t{\n\t\tstrncat(errbuf, SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)),\n\t\t\t\tmaxlen);\n\t\tstrcat(errbuf, \"\\n\");\n\t}\n\tif (tmpsock != PGINVALID_SOCKET)\n\t\tclosesocket(tmpsock);\n\tSOCK_ERRNO_SET(save_errno);\n\treturn false;\n}\n\n/*\n * PQcancel: request query cancel\n *\n * Returns true if able to send the cancel request, false if not.\n *\n * On failure, an error message is stored in *errbuf, which must be of size\n * errbufsize (recommended size is 256 bytes).  *errbuf is not changed on\n * success return.\n */\nint\nPQcancel(PGcancel *cancel, char *errbuf, int errbufsize)\n{\n\tif (!cancel)\n\t{\n\t\tstrlcpy(errbuf, \"PQcancel() -- no cancel object supplied\", errbufsize);\n\t\treturn false;\n\t}\n\n\treturn internal_cancel(&cancel->raddr, cancel->be_pid, cancel->be_key,\n\t\t\t\t\t\t   errbuf, errbufsize);\n}\n\n/*\n * PQrequestCancel: old, not thread-safe function for requesting query cancel\n *\n * Returns true if able to send the cancel request, false if not.\n *\n * On failure, the error message is saved in conn->errorMessage; this means\n * that this can't be used when there might be other active operations on\n * the connection object.\n *\n * NOTE: error messages will be cut off at the current size of the\n * error message buffer, since we dare not try to expand conn->errorMessage!\n */\nint\nPQrequestCancel(PGconn *conn)\n{\n\tint\t\t\tr;\n\n\t/* Check we have an open connection */\n\tif (!conn)\n\t\treturn false;\n\n\tif (conn->sock == PGINVALID_SOCKET)\n\t{\n\t\tstrlcpy(conn->errorMessage.data,\n\t\t\t\t\"PQrequestCancel() -- connection is not open\\n\",\n\t\t\t\tconn->errorMessage.maxlen);\n\t\tconn->errorMessage.len = strlen(conn->errorMessage.data);\n\n\t\treturn false;\n\t}\n\n\tr = internal_cancel(&conn->raddr, conn->be_pid, conn->be_key,\n\t\t\t\t\t\tconn->errorMessage.data, conn->errorMessage.maxlen);\n\n\tif (!r)\n\t\tconn->errorMessage.len = strlen(conn->errorMessage.data);\n\n\treturn r;\n}\n\n\n/*\n * pqPacketSend() -- convenience routine to send a message to server.\n *\n * pack_type: the single-byte message type code.  (Pass zero for startup\n * packets, which have no message type code.)\n *\n * buf, buf_len: contents of message.  The given length includes only what\n * is in buf; the message type and message length fields are added here.\n *\n * RETURNS: STATUS_ERROR if the write fails, STATUS_OK otherwise.\n * SIDE_EFFECTS: may block.\n */\nint\npqPacketSend(PGconn *conn, char pack_type,\n\t\t\t const void *buf, size_t buf_len)\n{\n\t/* Start the message. */\n\tif (pqPutMsgStart(pack_type, conn))\n\t\treturn STATUS_ERROR;\n\n\t/* Send the message body. */\n\tif (pqPutnchar(buf, buf_len, conn))\n\t\treturn STATUS_ERROR;\n\n\t/* Finish the message. */\n\tif (pqPutMsgEnd(conn))\n\t\treturn STATUS_ERROR;\n\n\t/* Flush to ensure backend gets it. */\n\tif (pqFlush(conn))\n\t\treturn STATUS_ERROR;\n\n\treturn STATUS_OK;\n}\n\n#ifdef USE_LDAP\n\n#define LDAP_URL\t\"ldap://\"\n#define LDAP_DEF_PORT\t389\n#define PGLDAP_TIMEOUT 2\n\n#define ld_is_sp_tab(x) ((x) == ' ' || (x) == '\\t')\n#define ld_is_nl_cr(x) ((x) == '\\r' || (x) == '\\n')\n\n\n/*\n *\t\tldapServiceLookup\n *\n * Search the LDAP URL passed as first argument, treat the result as a\n * string of connection options that are parsed and added to the array of\n * options passed as second argument.\n *\n * LDAP URLs must conform to RFC 1959 without escape sequences.\n *\tldap://host:port/dn?attributes?scope?filter?extensions\n *\n * Returns\n *\t0 if the lookup was successful,\n *\t1 if the connection to the LDAP server could be established but\n *\t  the search was unsuccessful,\n *\t2 if a connection could not be established, and\n *\t3 if a fatal error occurred.\n *\n * An error message is appended to *errorMessage for return codes 1 and 3.\n */\nstatic int\nldapServiceLookup(const char *purl, PQconninfoOption *options,\n\t\t\t\t  PQExpBuffer errorMessage)\n{\n\tint\t\t\tport = LDAP_DEF_PORT,\n\t\t\t\tscope,\n\t\t\t\trc,\n\t\t\t\tsize,\n\t\t\t\tstate,\n\t\t\t\toldstate,\n\t\t\t\ti;\n#ifndef WIN32\n\tint\t\t\tmsgid;\n#endif\n\tbool\t\tfound_keyword;\n\tchar\t   *url,\n\t\t\t   *hostname,\n\t\t\t   *portstr,\n\t\t\t   *endptr,\n\t\t\t   *dn,\n\t\t\t   *scopestr,\n\t\t\t   *filter,\n\t\t\t   *result,\n\t\t\t   *p,\n\t\t\t   *p1 = NULL,\n\t\t\t   *optname = NULL,\n\t\t\t   *optval = NULL;\n\tchar\t   *attrs[2] = {NULL, NULL};\n\tLDAP\t   *ld = NULL;\n\tLDAPMessage *res,\n\t\t\t   *entry;\n\tstruct berval **values;\n\tLDAP_TIMEVAL time = {PGLDAP_TIMEOUT, 0};\n\n\tif ((url = strdup(purl)) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage, libpq_gettext(\"out of memory\\n\"));\n\t\treturn 3;\n\t}\n\n\t/*\n\t * Parse URL components, check for correctness.  Basically, url has '\\0'\n\t * placed at component boundaries and variables are pointed at each\n\t * component.\n\t */\n\n\tif (pg_strncasecmp(url, LDAP_URL, strlen(LDAP_URL)) != 0)\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": scheme must be ldap://\\n\"), purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\n\t/* hostname */\n\thostname = url + strlen(LDAP_URL);\n\tif (*hostname == '/')\t\t/* no hostname? */\n\t\thostname = DefaultHost; /* the default */\n\n\t/* dn, \"distinguished name\" */\n\tp = strchr(url + strlen(LDAP_URL), '/');\n\tif (p == NULL || *(p + 1) == '\\0' || *(p + 1) == '?')\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": missing distinguished name\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\t*p = '\\0';\t\t\t\t\t/* terminate hostname */\n\tdn = p + 1;\n\n\t/* attribute */\n\tif ((p = strchr(dn, '?')) == NULL || *(p + 1) == '\\0' || *(p + 1) == '?')\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": must have exactly one attribute\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\t*p = '\\0';\n\tattrs[0] = p + 1;\n\n\t/* scope */\n\tif ((p = strchr(attrs[0], '?')) == NULL || *(p + 1) == '\\0' || *(p + 1) == '?')\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": must have search scope (base/one/sub)\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\t*p = '\\0';\n\tscopestr = p + 1;\n\n\t/* filter */\n\tif ((p = strchr(scopestr, '?')) == NULL || *(p + 1) == '\\0' || *(p + 1) == '?')\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": no filter\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\t*p = '\\0';\n\tfilter = p + 1;\n\tif ((p = strchr(filter, '?')) != NULL)\n\t\t*p = '\\0';\n\n\t/* port number? */\n\tif ((p1 = strchr(hostname, ':')) != NULL)\n\t{\n\t\tlong\t\tlport;\n\n\t\t*p1 = '\\0';\n\t\tportstr = p1 + 1;\n\t\terrno = 0;\n\t\tlport = strtol(portstr, &endptr, 10);\n\t\tif (*portstr == '\\0' || *endptr != '\\0' || errno || lport < 0 || lport > 65535)\n\t\t{\n\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": invalid port number\\n\"),\n\t\t\t\t\t\t\t  purl);\n\t\t\tfree(url);\n\t\t\treturn 3;\n\t\t}\n\t\tport = (int) lport;\n\t}\n\n\t/* Allow only one attribute */\n\tif (strchr(attrs[0], ',') != NULL)\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": must have exactly one attribute\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\n\t/* set scope */\n\tif (pg_strcasecmp(scopestr, \"base\") == 0)\n\t\tscope = LDAP_SCOPE_BASE;\n\telse if (pg_strcasecmp(scopestr, \"one\") == 0)\n\t\tscope = LDAP_SCOPE_ONELEVEL;\n\telse if (pg_strcasecmp(scopestr, \"sub\") == 0)\n\t\tscope = LDAP_SCOPE_SUBTREE;\n\telse\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid LDAP URL \\\"%s\\\": must have search scope (base/one/sub)\\n\"),\n\t\t\t\t\t\t  purl);\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\n\t/* initialize LDAP structure */\n\tif ((ld = ldap_init(hostname, port)) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"could not create LDAP structure\\n\"));\n\t\tfree(url);\n\t\treturn 3;\n\t}\n\n\t/*\n\t * Perform an explicit anonymous bind.\n\t *\n\t * LDAP does not require that an anonymous bind is performed explicitly,\n\t * but we want to distinguish between the case where LDAP bind does not\n\t * succeed within PGLDAP_TIMEOUT seconds (return 2 to continue parsing the\n\t * service control file) and the case where querying the LDAP server fails\n\t * (return 1 to end parsing).\n\t *\n\t * Unfortunately there is no way of setting a timeout that works for both\n\t * Windows and OpenLDAP.\n\t */\n#ifdef WIN32\n\t/* the nonstandard ldap_connect function performs an anonymous bind */\n\tif (ldap_connect(ld, &time) != LDAP_SUCCESS)\n\t{\n\t\t/* error or timeout in ldap_connect */\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 2;\n\t}\n#else\t\t\t\t\t\t\t/* !WIN32 */\n\t/* in OpenLDAP, use the LDAP_OPT_NETWORK_TIMEOUT option */\n\tif (ldap_set_option(ld, LDAP_OPT_NETWORK_TIMEOUT, &time) != LDAP_SUCCESS)\n\t{\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 3;\n\t}\n\n\t/* anonymous bind */\n\tif ((msgid = ldap_simple_bind(ld, NULL, NULL)) == -1)\n\t{\n\t\t/* error or network timeout */\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 2;\n\t}\n\n\t/* wait some time for the connection to succeed */\n\tres = NULL;\n\tif ((rc = ldap_result(ld, msgid, LDAP_MSG_ALL, &time, &res)) == -1 ||\n\t\tres == NULL)\n\t{\n\t\t/* error or timeout */\n\t\tif (res != NULL)\n\t\t\tldap_msgfree(res);\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 2;\n\t}\n\tldap_msgfree(res);\n\n\t/* reset timeout */\n\ttime.tv_sec = -1;\n\tif (ldap_set_option(ld, LDAP_OPT_NETWORK_TIMEOUT, &time) != LDAP_SUCCESS)\n\t{\n\t\tfree(url);\n\t\tldap_unbind(ld);\n\t\treturn 3;\n\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t/* search */\n\tres = NULL;\n\tif ((rc = ldap_search_st(ld, dn, scope, filter, attrs, 0, &time, &res))\n\t\t!= LDAP_SUCCESS)\n\t{\n\t\tif (res != NULL)\n\t\t\tldap_msgfree(res);\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"lookup on LDAP server failed: %s\\n\"),\n\t\t\t\t\t\t  ldap_err2string(rc));\n\t\tldap_unbind(ld);\n\t\tfree(url);\n\t\treturn 1;\n\t}\n\n\t/* complain if there was not exactly one result */\n\tif ((rc = ldap_count_entries(ld, res)) != 1)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t rc ? libpq_gettext(\"more than one entry found on LDAP lookup\\n\")\n\t\t\t\t\t\t\t : libpq_gettext(\"no entry found on LDAP lookup\\n\"));\n\t\tldap_msgfree(res);\n\t\tldap_unbind(ld);\n\t\tfree(url);\n\t\treturn 1;\n\t}\n\n\t/* get entry */\n\tif ((entry = ldap_first_entry(ld, res)) == NULL)\n\t{\n\t\t/* should never happen */\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"no entry found on LDAP lookup\\n\"));\n\t\tldap_msgfree(res);\n\t\tldap_unbind(ld);\n\t\tfree(url);\n\t\treturn 1;\n\t}\n\n\t/* get values */\n\tif ((values = ldap_get_values_len(ld, entry, attrs[0])) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"attribute has no values on LDAP lookup\\n\"));\n\t\tldap_msgfree(res);\n\t\tldap_unbind(ld);\n\t\tfree(url);\n\t\treturn 1;\n\t}\n\n\tldap_msgfree(res);\n\tfree(url);\n\n\tif (values[0] == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"attribute has no values on LDAP lookup\\n\"));\n\t\tldap_value_free_len(values);\n\t\tldap_unbind(ld);\n\t\treturn 1;\n\t}\n\n\t/* concatenate values into a single string with newline terminators */\n\tsize = 1;\t\t\t\t\t/* for the trailing null */\n\tfor (i = 0; values[i] != NULL; i++)\n\t\tsize += values[i]->bv_len + 1;\n\tif ((result = malloc(size)) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\tldap_value_free_len(values);\n\t\tldap_unbind(ld);\n\t\treturn 3;\n\t}\n\tp = result;\n\tfor (i = 0; values[i] != NULL; i++)\n\t{\n\t\tmemcpy(p, values[i]->bv_val, values[i]->bv_len);\n\t\tp += values[i]->bv_len;\n\t\t*(p++) = '\\n';\n\t}\n\t*p = '\\0';\n\n\tldap_value_free_len(values);\n\tldap_unbind(ld);\n\n\t/* parse result string */\n\toldstate = state = 0;\n\tfor (p = result; *p != '\\0'; ++p)\n\t{\n\t\tswitch (state)\n\t\t{\n\t\t\tcase 0:\t\t\t\t/* between entries */\n\t\t\t\tif (!ld_is_sp_tab(*p) && !ld_is_nl_cr(*p))\n\t\t\t\t{\n\t\t\t\t\toptname = p;\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\t\t\t\t/* in option name */\n\t\t\t\tif (ld_is_sp_tab(*p))\n\t\t\t\t{\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse if (ld_is_nl_cr(*p))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"missing \\\"=\\\" after \\\"%s\\\" in connection info string\\n\"),\n\t\t\t\t\t\t\t\t\t  optname);\n\t\t\t\t\tfree(result);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\telse if (*p == '=')\n\t\t\t\t{\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\t\t\t\t/* after option name */\n\t\t\t\tif (*p == '=')\n\t\t\t\t{\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t\telse if (!ld_is_sp_tab(*p))\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"missing \\\"=\\\" after \\\"%s\\\" in connection info string\\n\"),\n\t\t\t\t\t\t\t\t\t  optname);\n\t\t\t\t\tfree(result);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\t\t\t\t/* before option value */\n\t\t\t\tif (*p == '\\'')\n\t\t\t\t{\n\t\t\t\t\toptval = p + 1;\n\t\t\t\t\tp1 = p + 1;\n\t\t\t\t\tstate = 5;\n\t\t\t\t}\n\t\t\t\telse if (ld_is_nl_cr(*p))\n\t\t\t\t{\n\t\t\t\t\toptval = optname + strlen(optname); /* empty */\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse if (!ld_is_sp_tab(*p))\n\t\t\t\t{\n\t\t\t\t\toptval = p;\n\t\t\t\t\tstate = 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\t\t\t\t/* in unquoted option value */\n\t\t\t\tif (ld_is_sp_tab(*p) || ld_is_nl_cr(*p))\n\t\t\t\t{\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\t\t\t\t/* in quoted option value */\n\t\t\t\tif (*p == '\\'')\n\t\t\t\t{\n\t\t\t\t\t*p1 = '\\0';\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse if (*p == '\\\\')\n\t\t\t\t\tstate = 6;\n\t\t\t\telse\n\t\t\t\t\t*(p1++) = *p;\n\t\t\t\tbreak;\n\t\t\tcase 6:\t\t\t\t/* in quoted option value after escape */\n\t\t\t\t*(p1++) = *p;\n\t\t\t\tstate = 5;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (state == 0 && oldstate != 0)\n\t\t{\n\t\t\tfound_keyword = false;\n\t\t\tfor (i = 0; options[i].keyword; i++)\n\t\t\t{\n\t\t\t\tif (strcmp(options[i].keyword, optname) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (options[i].val == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions[i].val = strdup(optval);\n\t\t\t\t\t\tif (!options[i].val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\t\t\tfree(result);\n\t\t\t\t\t\t\treturn 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfound_keyword = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found_keyword)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection option \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  optname);\n\t\t\t\tfree(result);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\toptname = NULL;\n\t\t\toptval = NULL;\n\t\t}\n\t\toldstate = state;\n\t}\n\n\tfree(result);\n\n\tif (state == 5 || state == 6)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"unterminated quoted string in connection info string\\n\"));\n\t\treturn 3;\n\t}\n\n\treturn 0;\n}\n\n#endif\t\t\t\t\t\t\t/* USE_LDAP */\n\n/*\n * parseServiceInfo: if a service name has been given, look it up and absorb\n * connection options from it into *options.\n *\n * Returns 0 on success, nonzero on failure.  On failure, if errorMessage\n * isn't null, also store an error message there.  (Note: the only reason\n * this function and related ones don't dump core on errorMessage == NULL\n * is the undocumented fact that printfPQExpBuffer does nothing when passed\n * a null PQExpBuffer pointer.)\n */\nstatic int\nparseServiceInfo(PQconninfoOption *options, PQExpBuffer errorMessage)\n{\n\tconst char *service = conninfo_getval(options, \"service\");\n\tchar\t\tserviceFile[MAXPGPATH];\n\tchar\t   *env;\n\tbool\t\tgroup_found = false;\n\tint\t\t\tstatus;\n\tstruct stat stat_buf;\n\n\t/*\n\t * We have to special-case the environment variable PGSERVICE here, since\n\t * this is and should be called before inserting environment defaults for\n\t * other connection options.\n\t */\n\tif (service == NULL)\n\t\tservice = getenv(\"PGSERVICE\");\n\n\t/* If no service name given, nothing to do */\n\tif (service == NULL)\n\t\treturn 0;\n\n\t/*\n\t * Try PGSERVICEFILE if specified, else try ~/.pg_service.conf (if that\n\t * exists).\n\t */\n\tif ((env = getenv(\"PGSERVICEFILE\")) != NULL)\n\t\tstrlcpy(serviceFile, env, sizeof(serviceFile));\n\telse\n\t{\n\t\tchar\t\thomedir[MAXPGPATH];\n\n\t\tif (!pqGetHomeDirectory(homedir, sizeof(homedir)))\n\t\t\tgoto next_file;\n\t\tsnprintf(serviceFile, MAXPGPATH, \"%s/%s\", homedir, \".pg_service.conf\");\n\t\tif (stat(serviceFile, &stat_buf) != 0)\n\t\t\tgoto next_file;\n\t}\n\n\tstatus = parseServiceFile(serviceFile, service, options, errorMessage, &group_found);\n\tif (group_found || status != 0)\n\t\treturn status;\n\nnext_file:\n\n\t/*\n\t * This could be used by any application so we can't use the binary\n\t * location to find our config files.\n\t */\n\tsnprintf(serviceFile, MAXPGPATH, \"%s/pg_service.conf\",\n\t\t\t getenv(\"PGSYSCONFDIR\") ? getenv(\"PGSYSCONFDIR\") : SYSCONFDIR);\n\tif (stat(serviceFile, &stat_buf) != 0)\n\t\tgoto last_file;\n\n\tstatus = parseServiceFile(serviceFile, service, options, errorMessage, &group_found);\n\tif (status != 0)\n\t\treturn status;\n\nlast_file:\n\tif (!group_found)\n\t{\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"definition of service \\\"%s\\\" not found\\n\"), service);\n\t\treturn 3;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nparseServiceFile(const char *serviceFile,\n\t\t\t\t const char *service,\n\t\t\t\t PQconninfoOption *options,\n\t\t\t\t PQExpBuffer errorMessage,\n\t\t\t\t bool *group_found)\n{\n\tint\t\t\tresult = 0,\n\t\t\t\tlinenr = 0,\n\t\t\t\ti;\n\tFILE\t   *f;\n\tchar\t   *line;\n\tchar\t\tbuf[1024];\n\n\t*group_found = false;\n\n\tf = fopen(serviceFile, \"r\");\n\tif (f == NULL)\n\t{\n\t\tappendPQExpBuffer(errorMessage, libpq_gettext(\"service file \\\"%s\\\" not found\\n\"),\n\t\t\t\t\t\t  serviceFile);\n\t\treturn 1;\n\t}\n\n\twhile ((line = fgets(buf, sizeof(buf), f)) != NULL)\n\t{\n\t\tint\t\t\tlen;\n\n\t\tlinenr++;\n\n\t\tif (strlen(line) >= sizeof(buf) - 1)\n\t\t{\n\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"line %d too long in service file \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  linenr,\n\t\t\t\t\t\t\t  serviceFile);\n\t\t\tresult = 2;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* ignore whitespace at end of line, especially the newline */\n\t\tlen = strlen(line);\n\t\twhile (len > 0 && isspace((unsigned char) line[len - 1]))\n\t\t\tline[--len] = '\\0';\n\n\t\t/* ignore leading whitespace too */\n\t\twhile (*line && isspace((unsigned char) line[0]))\n\t\t\tline++;\n\n\t\t/* ignore comments and empty lines */\n\t\tif (line[0] == '\\0' || line[0] == '#')\n\t\t\tcontinue;\n\n\t\t/* Check for right groupname */\n\t\tif (line[0] == '[')\n\t\t{\n\t\t\tif (*group_found)\n\t\t\t{\n\t\t\t\t/* end of desired group reached; return success */\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (strncmp(line + 1, service, strlen(service)) == 0 &&\n\t\t\t\tline[strlen(service) + 1] == ']')\n\t\t\t\t*group_found = true;\n\t\t\telse\n\t\t\t\t*group_found = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (*group_found)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Finally, we are in the right group and can parse the line\n\t\t\t\t */\n\t\t\t\tchar\t   *key,\n\t\t\t\t\t\t   *val;\n\t\t\t\tbool\t\tfound_keyword;\n\n#ifdef USE_LDAP\n\t\t\t\tif (strncmp(line, \"ldap\", 4) == 0)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\trc = ldapServiceLookup(line, options, errorMessage);\n\n\t\t\t\t\t/* if rc = 2, go on reading for fallback */\n\t\t\t\t\tswitch (rc)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tresult = 3;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n\t\t\t\tkey = line;\n\t\t\t\tval = strchr(line, '=');\n\t\t\t\tif (val == NULL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"syntax error in service file \\\"%s\\\", line %d\\n\"),\n\t\t\t\t\t\t\t\t\t  serviceFile,\n\t\t\t\t\t\t\t\t\t  linenr);\n\t\t\t\t\tresult = 3;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\t*val++ = '\\0';\n\n\t\t\t\tif (strcmp(key, \"service\") == 0)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"nested service specifications not supported in service file \\\"%s\\\", line %d\\n\"),\n\t\t\t\t\t\t\t\t\t  serviceFile,\n\t\t\t\t\t\t\t\t\t  linenr);\n\t\t\t\t\tresult = 3;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Set the parameter --- but don't override any previous\n\t\t\t\t * explicit setting.\n\t\t\t\t */\n\t\t\t\tfound_keyword = false;\n\t\t\t\tfor (i = 0; options[i].keyword; i++)\n\t\t\t\t{\n\t\t\t\t\tif (strcmp(options[i].keyword, key) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (options[i].val == NULL)\n\t\t\t\t\t\t\toptions[i].val = strdup(val);\n\t\t\t\t\t\tif (!options[i].val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\t\t\tresult = 3;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfound_keyword = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!found_keyword)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"syntax error in service file \\\"%s\\\", line %d\\n\"),\n\t\t\t\t\t\t\t\t\t  serviceFile,\n\t\t\t\t\t\t\t\t\t  linenr);\n\t\t\t\t\tresult = 3;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tfclose(f);\n\n\treturn result;\n}\n\n\n/*\n *\t\tPQconninfoParse\n *\n * Parse a string like PQconnectdb() would do and return the\n * resulting connection options array.  NULL is returned on failure.\n * The result contains only options specified directly in the string,\n * not any possible default values.\n *\n * If errmsg isn't NULL, *errmsg is set to NULL on success, or a malloc'd\n * string on failure (use PQfreemem to free it).  In out-of-memory conditions\n * both *errmsg and the result could be NULL.\n *\n * NOTE: the returned array is dynamically allocated and should\n * be freed when no longer needed via PQconninfoFree().\n */\nPQconninfoOption *\nPQconninfoParse(const char *conninfo, char **errmsg)\n{\n\tPQExpBufferData errorBuf;\n\tPQconninfoOption *connOptions;\n\n\tif (errmsg)\n\t\t*errmsg = NULL;\t\t\t/* default */\n\tinitPQExpBuffer(&errorBuf);\n\tif (PQExpBufferDataBroken(errorBuf))\n\t\treturn NULL;\t\t\t/* out of memory already :-( */\n\tconnOptions = parse_connection_string(conninfo, &errorBuf, false);\n\tif (connOptions == NULL && errmsg)\n\t\t*errmsg = errorBuf.data;\n\telse\n\t\ttermPQExpBuffer(&errorBuf);\n\treturn connOptions;\n}\n\n/*\n * Build a working copy of the constant PQconninfoOptions array.\n */\nstatic PQconninfoOption *\nconninfo_init(PQExpBuffer errorMessage)\n{\n\tPQconninfoOption *options;\n\tPQconninfoOption *opt_dest;\n\tconst internalPQconninfoOption *cur_opt;\n\n\t/*\n\t * Get enough memory for all options in PQconninfoOptions, even if some\n\t * end up being filtered out.\n\t */\n\toptions = (PQconninfoOption *) malloc(sizeof(PQconninfoOption) * sizeof(PQconninfoOptions) / sizeof(PQconninfoOptions[0]));\n\tif (options == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\treturn NULL;\n\t}\n\topt_dest = options;\n\n\tfor (cur_opt = PQconninfoOptions; cur_opt->keyword; cur_opt++)\n\t{\n\t\t/* Only copy the public part of the struct, not the full internal */\n\t\tmemcpy(opt_dest, cur_opt, sizeof(PQconninfoOption));\n\t\topt_dest++;\n\t}\n\tMemSet(opt_dest, 0, sizeof(PQconninfoOption));\n\n\treturn options;\n}\n\n/*\n * Connection string parser\n *\n * Returns a malloc'd PQconninfoOption array, if parsing is successful.\n * Otherwise, NULL is returned and an error message is added to errorMessage.\n *\n * If use_defaults is true, default values are filled in (from a service file,\n * environment variables, etc).\n */\nstatic PQconninfoOption *\nparse_connection_string(const char *connstr, PQExpBuffer errorMessage,\n\t\t\t\t\t\tbool use_defaults)\n{\n\t/* Parse as URI if connection string matches URI prefix */\n\tif (uri_prefix_length(connstr) != 0)\n\t\treturn conninfo_uri_parse(connstr, errorMessage, use_defaults);\n\n\t/* Parse as default otherwise */\n\treturn conninfo_parse(connstr, errorMessage, use_defaults);\n}\n\n/*\n * Checks if connection string starts with either of the valid URI prefix\n * designators.\n *\n * Returns the URI prefix length, 0 if the string doesn't contain a URI prefix.\n *\n * XXX this is duplicated in psql/common.c.\n */\nstatic int\nuri_prefix_length(const char *connstr)\n{\n\tif (strncmp(connstr, uri_designator,\n\t\t\t\tsizeof(uri_designator) - 1) == 0)\n\t\treturn sizeof(uri_designator) - 1;\n\n\tif (strncmp(connstr, short_uri_designator,\n\t\t\t\tsizeof(short_uri_designator) - 1) == 0)\n\t\treturn sizeof(short_uri_designator) - 1;\n\n\treturn 0;\n}\n\n/*\n * Recognized connection string either starts with a valid URI prefix or\n * contains a \"=\" in it.\n *\n * Must be consistent with parse_connection_string: anything for which this\n * returns true should at least look like it's parseable by that routine.\n *\n * XXX this is duplicated in psql/common.c\n */\nstatic bool\nrecognized_connection_string(const char *connstr)\n{\n\treturn uri_prefix_length(connstr) != 0 || strchr(connstr, '=') != NULL;\n}\n\n/*\n * Subroutine for parse_connection_string\n *\n * Deal with a string containing key=value pairs.\n */\nstatic PQconninfoOption *\nconninfo_parse(const char *conninfo, PQExpBuffer errorMessage,\n\t\t\t   bool use_defaults)\n{\n\tchar\t   *pname;\n\tchar\t   *pval;\n\tchar\t   *buf;\n\tchar\t   *cp;\n\tchar\t   *cp2;\n\tPQconninfoOption *options;\n\n\t/* Make a working copy of PQconninfoOptions */\n\toptions = conninfo_init(errorMessage);\n\tif (options == NULL)\n\t\treturn NULL;\n\n\t/* Need a modifiable copy of the input string */\n\tif ((buf = strdup(conninfo)) == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\tPQconninfoFree(options);\n\t\treturn NULL;\n\t}\n\tcp = buf;\n\n\twhile (*cp)\n\t{\n\t\t/* Skip blanks before the parameter name */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the parameter name */\n\t\tpname = cp;\n\t\twhile (*cp)\n\t\t{\n\t\t\tif (*cp == '=')\n\t\t\t\tbreak;\n\t\t\tif (isspace((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\twhile (*cp)\n\t\t\t\t{\n\t\t\t\t\tif (!isspace((unsigned char) *cp))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcp++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcp++;\n\t\t}\n\n\t\t/* Check that there is a following '=' */\n\t\tif (*cp != '=')\n\t\t{\n\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"missing \\\"=\\\" after \\\"%s\\\" in connection info string\\n\"),\n\t\t\t\t\t\t\t  pname);\n\t\t\tPQconninfoFree(options);\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t*cp++ = '\\0';\n\n\t\t/* Skip blanks after the '=' */\n\t\twhile (*cp)\n\t\t{\n\t\t\tif (!isspace((unsigned char) *cp))\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t}\n\n\t\t/* Get the parameter value */\n\t\tpval = cp;\n\n\t\tif (*cp != '\\'')\n\t\t{\n\t\t\tcp2 = pval;\n\t\t\twhile (*cp)\n\t\t\t{\n\t\t\t\tif (isspace((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tcp++;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\t*cp2++ = *cp++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t*cp2++ = *cp++;\n\t\t\t}\n\t\t\t*cp2 = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcp2 = pval;\n\t\t\tcp++;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tif (*cp == '\\0')\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"unterminated quoted string in connection info string\\n\"));\n\t\t\t\t\tPQconninfoFree(options);\n\t\t\t\t\tfree(buf);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tcp++;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\t*cp2++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\'')\n\t\t\t\t{\n\t\t\t\t\t*cp2 = '\\0';\n\t\t\t\t\tcp++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*cp2++ = *cp++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now that we have the name and the value, store the record.\n\t\t */\n\t\tif (!conninfo_storeval(options, pname, pval, errorMessage, false, false))\n\t\t{\n\t\t\tPQconninfoFree(options);\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Done with the modifiable input string */\n\tfree(buf);\n\n\t/*\n\t * Add in defaults if the caller wants that.\n\t */\n\tif (use_defaults)\n\t{\n\t\tif (!conninfo_add_defaults(options, errorMessage))\n\t\t{\n\t\t\tPQconninfoFree(options);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn options;\n}\n\n/*\n * Conninfo array parser routine\n *\n * If successful, a malloc'd PQconninfoOption array is returned.\n * If not successful, NULL is returned and an error message is\n * appended to errorMessage.\n * Defaults are supplied (from a service file, environment variables, etc)\n * for unspecified options, but only if use_defaults is true.\n *\n * If expand_dbname is non-zero, and the value passed for the first occurrence\n * of \"dbname\" keyword is a connection string (as indicated by\n * recognized_connection_string) then parse and process it, overriding any\n * previously processed conflicting keywords. Subsequent keywords will take\n * precedence, however. In-tree programs generally specify expand_dbname=true,\n * so command-line arguments naming a database can use a connection string.\n * Some code acquires arbitrary database names from known-literal sources like\n * PQdb(), PQconninfoParse() and pg_database.datname.  When connecting to such\n * a database, in-tree code first wraps the name in a connection string.\n */\nstatic PQconninfoOption *\nconninfo_array_parse(const char *const *keywords, const char *const *values,\n\t\t\t\t\t PQExpBuffer errorMessage, bool use_defaults,\n\t\t\t\t\t int expand_dbname)\n{\n\tPQconninfoOption *options;\n\tPQconninfoOption *dbname_options = NULL;\n\tPQconninfoOption *option;\n\tint\t\t\ti = 0;\n\n\t/*\n\t * If expand_dbname is non-zero, check keyword \"dbname\" to see if val is\n\t * actually a recognized connection string.\n\t */\n\twhile (expand_dbname && keywords[i])\n\t{\n\t\tconst char *pname = keywords[i];\n\t\tconst char *pvalue = values[i];\n\n\t\t/* first find \"dbname\" if any */\n\t\tif (strcmp(pname, \"dbname\") == 0 && pvalue)\n\t\t{\n\t\t\t/*\n\t\t\t * If value is a connection string, parse it, but do not use\n\t\t\t * defaults here -- those get picked up later. We only want to\n\t\t\t * override for those parameters actually passed.\n\t\t\t */\n\t\t\tif (recognized_connection_string(pvalue))\n\t\t\t{\n\t\t\t\tdbname_options = parse_connection_string(pvalue, errorMessage, false);\n\t\t\t\tif (dbname_options == NULL)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t++i;\n\t}\n\n\t/* Make a working copy of PQconninfoOptions */\n\toptions = conninfo_init(errorMessage);\n\tif (options == NULL)\n\t{\n\t\tPQconninfoFree(dbname_options);\n\t\treturn NULL;\n\t}\n\n\t/* Parse the keywords/values arrays */\n\ti = 0;\n\twhile (keywords[i])\n\t{\n\t\tconst char *pname = keywords[i];\n\t\tconst char *pvalue = values[i];\n\n\t\tif (pvalue != NULL && pvalue[0] != '\\0')\n\t\t{\n\t\t\t/* Search for the param record */\n\t\t\tfor (option = options; option->keyword != NULL; option++)\n\t\t\t{\n\t\t\t\tif (strcmp(option->keyword, pname) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check for invalid connection option */\n\t\t\tif (option->keyword == NULL)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection option \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  pname);\n\t\t\t\tPQconninfoFree(options);\n\t\t\t\tPQconninfoFree(dbname_options);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we are on the first dbname parameter, and we have a parsed\n\t\t\t * connection string, copy those parameters across, overriding any\n\t\t\t * existing previous settings.\n\t\t\t */\n\t\t\tif (strcmp(pname, \"dbname\") == 0 && dbname_options)\n\t\t\t{\n\t\t\t\tPQconninfoOption *str_option;\n\n\t\t\t\tfor (str_option = dbname_options; str_option->keyword != NULL; str_option++)\n\t\t\t\t{\n\t\t\t\t\tif (str_option->val != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tk;\n\n\t\t\t\t\t\tfor (k = 0; options[k].keyword; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (strcmp(options[k].keyword, str_option->keyword) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (options[k].val)\n\t\t\t\t\t\t\t\t\tfree(options[k].val);\n\t\t\t\t\t\t\t\toptions[k].val = strdup(str_option->val);\n\t\t\t\t\t\t\t\tif (!options[k].val)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\t\t\t\t\tPQconninfoFree(options);\n\t\t\t\t\t\t\t\t\tPQconninfoFree(dbname_options);\n\t\t\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Forget the parsed connection string, so that any subsequent\n\t\t\t\t * dbname parameters will not be expanded.\n\t\t\t\t */\n\t\t\t\tPQconninfoFree(dbname_options);\n\t\t\t\tdbname_options = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Store the value, overriding previous settings\n\t\t\t\t */\n\t\t\t\tif (option->val)\n\t\t\t\t\tfree(option->val);\n\t\t\t\toption->val = strdup(pvalue);\n\t\t\t\tif (!option->val)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\tPQconninfoFree(options);\n\t\t\t\t\tPQconninfoFree(dbname_options);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++i;\n\t}\n\tPQconninfoFree(dbname_options);\n\n\t/*\n\t * Add in defaults if the caller wants that.\n\t */\n\tif (use_defaults)\n\t{\n\t\tif (!conninfo_add_defaults(options, errorMessage))\n\t\t{\n\t\t\tPQconninfoFree(options);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn options;\n}\n\n/*\n * Add the default values for any unspecified options to the connection\n * options array.\n *\n * Defaults are obtained from a service file, environment variables, etc.\n *\n * Returns true if successful, otherwise false; errorMessage, if supplied,\n * is filled in upon failure.  Note that failure to locate a default value\n * is not an error condition here --- we just leave the option's value as\n * NULL.\n */\nstatic bool\nconninfo_add_defaults(PQconninfoOption *options, PQExpBuffer errorMessage)\n{\n\tPQconninfoOption *option;\n\tchar\t   *tmp;\n\n\t/*\n\t * If there's a service spec, use it to obtain any not-explicitly-given\n\t * parameters.  Ignore error if no error message buffer is passed because\n\t * there is no way to pass back the failure message.\n\t */\n\tif (parseServiceInfo(options, errorMessage) != 0 && errorMessage)\n\t\treturn false;\n\n\t/*\n\t * Get the fallback resources for parameters not specified in the conninfo\n\t * string nor the service.\n\t */\n\tfor (option = options; option->keyword != NULL; option++)\n\t{\n\t\tif (option->val != NULL)\n\t\t\tcontinue;\t\t\t/* Value was in conninfo or service */\n\n\t\t/*\n\t\t * Try to get the environment variable fallback\n\t\t */\n\t\tif (option->envvar != NULL)\n\t\t{\n\t\t\tif ((tmp = getenv(option->envvar)) != NULL)\n\t\t\t{\n\t\t\t\toption->val = strdup(tmp);\n\t\t\t\tif (!option->val)\n\t\t\t\t{\n\t\t\t\t\tif (errorMessage)\n\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Interpret the deprecated PGREQUIRESSL environment variable.  Per\n\t\t * tradition, translate values starting with \"1\" to sslmode=require,\n\t\t * and ignore other values.  Given both PGREQUIRESSL=1 and PGSSLMODE,\n\t\t * PGSSLMODE takes precedence; the opposite was true before v9.3.\n\t\t */\n\t\tif (strcmp(option->keyword, \"sslmode\") == 0)\n\t\t{\n\t\t\tconst char *requiresslenv = getenv(\"PGREQUIRESSL\");\n\n\t\t\tif (requiresslenv != NULL && requiresslenv[0] == '1')\n\t\t\t{\n\t\t\t\toption->val = strdup(\"require\");\n\t\t\t\tif (!option->val)\n\t\t\t\t{\n\t\t\t\t\tif (errorMessage)\n\t\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * No environment variable specified or the variable isn't set - try\n\t\t * compiled-in default\n\t\t */\n\t\tif (option->compiled != NULL)\n\t\t{\n\t\t\toption->val = strdup(option->compiled);\n\t\t\tif (!option->val)\n\t\t\t{\n\t\t\t\tif (errorMessage)\n\t\t\t\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Special handling for \"user\" option.  Note that if pg_fe_getauthname\n\t\t * fails, we just leave the value as NULL; there's no need for this to\n\t\t * be an error condition if the caller provides a user name.  The only\n\t\t * reason we do this now at all is so that callers of PQconndefaults\n\t\t * will see a correct default (barring error, of course).\n\t\t */\n\t\tif (strcmp(option->keyword, \"user\") == 0)\n\t\t{\n\t\t\toption->val = pg_fe_getauthname(NULL);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/*\n * Subroutine for parse_connection_string\n *\n * Deal with a URI connection string.\n */\nstatic PQconninfoOption *\nconninfo_uri_parse(const char *uri, PQExpBuffer errorMessage,\n\t\t\t\t   bool use_defaults)\n{\n\tPQconninfoOption *options;\n\n\t/* Make a working copy of PQconninfoOptions */\n\toptions = conninfo_init(errorMessage);\n\tif (options == NULL)\n\t\treturn NULL;\n\n\tif (!conninfo_uri_parse_options(options, uri, errorMessage))\n\t{\n\t\tPQconninfoFree(options);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Add in defaults if the caller wants that.\n\t */\n\tif (use_defaults)\n\t{\n\t\tif (!conninfo_add_defaults(options, errorMessage))\n\t\t{\n\t\t\tPQconninfoFree(options);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn options;\n}\n\n/*\n * conninfo_uri_parse_options\n *\t\tActual URI parser.\n *\n * If successful, returns true while the options array is filled with parsed\n * options from the URI.\n * If not successful, returns false and fills errorMessage accordingly.\n *\n * Parses the connection URI string in 'uri' according to the URI syntax (RFC\n * 3986):\n *\n * postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&...]\n *\n * where \"netloc\" is a hostname, an IPv4 address, or an IPv6 address surrounded\n * by literal square brackets.  As an extension, we also allow multiple\n * netloc[:port] specifications, separated by commas:\n *\n * postgresql://[user[:password]@][netloc][:port][,...][/dbname][?param1=value1&...]\n *\n * Any of the URI parts might use percent-encoding (%xy).\n */\nstatic bool\nconninfo_uri_parse_options(PQconninfoOption *options, const char *uri,\n\t\t\t\t\t\t   PQExpBuffer errorMessage)\n{\n\tint\t\t\tprefix_len;\n\tchar\t   *p;\n\tchar\t   *buf = NULL;\n\tchar\t   *start;\n\tchar\t\tprevchar = '\\0';\n\tchar\t   *user = NULL;\n\tchar\t   *host = NULL;\n\tbool\t\tretval = false;\n\tPQExpBufferData hostbuf;\n\tPQExpBufferData portbuf;\n\n\tinitPQExpBuffer(&hostbuf);\n\tinitPQExpBuffer(&portbuf);\n\tif (PQExpBufferDataBroken(hostbuf) || PQExpBufferDataBroken(portbuf))\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\tgoto cleanup;\n\t}\n\n\t/* need a modifiable copy of the input URI */\n\tbuf = strdup(uri);\n\tif (buf == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage,\n\t\t\t\t\t\t\t libpq_gettext(\"out of memory\\n\"));\n\t\tgoto cleanup;\n\t}\n\tstart = buf;\n\n\t/* Skip the URI prefix */\n\tprefix_len = uri_prefix_length(uri);\n\tif (prefix_len == 0)\n\t{\n\t\t/* Should never happen */\n\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"invalid URI propagated to internal parser routine: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t  uri);\n\t\tgoto cleanup;\n\t}\n\tstart += prefix_len;\n\tp = start;\n\n\t/* Look ahead for possible user credentials designator */\n\twhile (*p && *p != '@' && *p != '/')\n\t\t++p;\n\tif (*p == '@')\n\t{\n\t\t/*\n\t\t * Found username/password designator, so URI should be of the form\n\t\t * \"scheme://user[:password]@[netloc]\".\n\t\t */\n\t\tuser = start;\n\n\t\tp = user;\n\t\twhile (*p != ':' && *p != '@')\n\t\t\t++p;\n\n\t\t/* Save last char and cut off at end of user name */\n\t\tprevchar = *p;\n\t\t*p = '\\0';\n\n\t\tif (*user &&\n\t\t\t!conninfo_storeval(options, \"user\", user,\n\t\t\t\t\t\t\t   errorMessage, false, true))\n\t\t\tgoto cleanup;\n\n\t\tif (prevchar == ':')\n\t\t{\n\t\t\tconst char *password = p + 1;\n\n\t\t\twhile (*p != '@')\n\t\t\t\t++p;\n\t\t\t*p = '\\0';\n\n\t\t\tif (*password &&\n\t\t\t\t!conninfo_storeval(options, \"password\", password,\n\t\t\t\t\t\t\t\t   errorMessage, false, true))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Advance past end of parsed user name or password token */\n\t\t++p;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No username/password designator found.  Reset to start of URI.\n\t\t */\n\t\tp = start;\n\t}\n\n\t/*\n\t * There may be multiple netloc[:port] pairs, each separated from the next\n\t * by a comma.  When we initially enter this loop, \"p\" has been\n\t * incremented past optional URI credential information at this point and\n\t * now points at the \"netloc\" part of the URI.  On subsequent loop\n\t * iterations, \"p\" has been incremented past the comma separator and now\n\t * points at the start of the next \"netloc\".\n\t */\n\tfor (;;)\n\t{\n\t\t/*\n\t\t * Look for IPv6 address.\n\t\t */\n\t\tif (*p == '[')\n\t\t{\n\t\t\thost = ++p;\n\t\t\twhile (*p && *p != ']')\n\t\t\t\t++p;\n\t\t\tif (!*p)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"end of string reached when looking for matching \\\"]\\\" in IPv6 host address in URI: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  uri);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (p == host)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"IPv6 host address may not be empty in URI: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  uri);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/* Cut off the bracket and advance */\n\t\t\t*(p++) = '\\0';\n\n\t\t\t/*\n\t\t\t * The address may be followed by a port specifier or a slash or a\n\t\t\t * query or a separator comma.\n\t\t\t */\n\t\t\tif (*p && *p != ':' && *p != '/' && *p != '?' && *p != ',')\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"unexpected character \\\"%c\\\" at position %d in URI (expected \\\":\\\" or \\\"/\\\"): \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  *p, (int) (p - buf + 1), uri);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not an IPv6 address: DNS-named or IPv4 netloc */\n\t\t\thost = p;\n\n\t\t\t/*\n\t\t\t * Look for port specifier (colon) or end of host specifier\n\t\t\t * (slash) or query (question mark) or host separator (comma).\n\t\t\t */\n\t\t\twhile (*p && *p != ':' && *p != '/' && *p != '?' && *p != ',')\n\t\t\t\t++p;\n\t\t}\n\n\t\t/* Save the hostname terminator before we null it */\n\t\tprevchar = *p;\n\t\t*p = '\\0';\n\n\t\tappendPQExpBufferStr(&hostbuf, host);\n\n\t\tif (prevchar == ':')\n\t\t{\n\t\t\tconst char *port = ++p; /* advance past host terminator */\n\n\t\t\twhile (*p && *p != '/' && *p != '?' && *p != ',')\n\t\t\t\t++p;\n\n\t\t\tprevchar = *p;\n\t\t\t*p = '\\0';\n\n\t\t\tappendPQExpBufferStr(&portbuf, port);\n\t\t}\n\n\t\tif (prevchar != ',')\n\t\t\tbreak;\n\t\t++p;\t\t\t\t\t/* advance past comma separator */\n\t\tappendPQExpBufferChar(&hostbuf, ',');\n\t\tappendPQExpBufferChar(&portbuf, ',');\n\t}\n\n\t/* Save final values for host and port. */\n\tif (PQExpBufferDataBroken(hostbuf) || PQExpBufferDataBroken(portbuf))\n\t\tgoto cleanup;\n\tif (hostbuf.data[0] &&\n\t\t!conninfo_storeval(options, \"host\", hostbuf.data,\n\t\t\t\t\t\t   errorMessage, false, true))\n\t\tgoto cleanup;\n\tif (portbuf.data[0] &&\n\t\t!conninfo_storeval(options, \"port\", portbuf.data,\n\t\t\t\t\t\t   errorMessage, false, true))\n\t\tgoto cleanup;\n\n\tif (prevchar && prevchar != '?')\n\t{\n\t\tconst char *dbname = ++p;\t/* advance past host terminator */\n\n\t\t/* Look for query parameters */\n\t\twhile (*p && *p != '?')\n\t\t\t++p;\n\n\t\tprevchar = *p;\n\t\t*p = '\\0';\n\n\t\t/*\n\t\t * Avoid setting dbname to an empty string, as it forces the default\n\t\t * value (username) and ignores $PGDATABASE, as opposed to not setting\n\t\t * it at all.\n\t\t */\n\t\tif (*dbname &&\n\t\t\t!conninfo_storeval(options, \"dbname\", dbname,\n\t\t\t\t\t\t\t   errorMessage, false, true))\n\t\t\tgoto cleanup;\n\t}\n\n\tif (prevchar)\n\t{\n\t\t++p;\t\t\t\t\t/* advance past terminator */\n\n\t\tif (!conninfo_uri_parse_params(p, options, errorMessage))\n\t\t\tgoto cleanup;\n\t}\n\n\t/* everything parsed okay */\n\tretval = true;\n\ncleanup:\n\ttermPQExpBuffer(&hostbuf);\n\ttermPQExpBuffer(&portbuf);\n\tif (buf)\n\t\tfree(buf);\n\treturn retval;\n}\n\n/*\n * Connection URI parameters parser routine\n *\n * If successful, returns true while connOptions is filled with parsed\n * parameters.  Otherwise, returns false and fills errorMessage appropriately.\n *\n * Destructively modifies 'params' buffer.\n */\nstatic bool\nconninfo_uri_parse_params(char *params,\n\t\t\t\t\t\t  PQconninfoOption *connOptions,\n\t\t\t\t\t\t  PQExpBuffer errorMessage)\n{\n\twhile (*params)\n\t{\n\t\tchar\t   *keyword = params;\n\t\tchar\t   *value = NULL;\n\t\tchar\t   *p = params;\n\t\tbool\t\tmalloced = false;\n\t\tint\t\t\toldmsglen;\n\n\t\t/*\n\t\t * Scan the params string for '=' and '&', marking the end of keyword\n\t\t * and value respectively.\n\t\t */\n\t\tfor (;;)\n\t\t{\n\t\t\tif (*p == '=')\n\t\t\t{\n\t\t\t\t/* Was there '=' already? */\n\t\t\t\tif (value != NULL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"extra key/value separator \\\"=\\\" in URI query parameter: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t  keyword);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Cut off keyword, advance to value */\n\t\t\t\t*p++ = '\\0';\n\t\t\t\tvalue = p;\n\t\t\t}\n\t\t\telse if (*p == '&' || *p == '\\0')\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If not at the end, cut off value and advance; leave p\n\t\t\t\t * pointing to start of the next parameter, if any.\n\t\t\t\t */\n\t\t\t\tif (*p != '\\0')\n\t\t\t\t\t*p++ = '\\0';\n\t\t\t\t/* Was there '=' at all? */\n\t\t\t\tif (value == NULL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\"missing key/value separator \\\"=\\\" in URI query parameter: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t  keyword);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Got keyword and value, go process them. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++p;\t\t\t/* Advance over all other bytes. */\n\t\t}\n\n\t\tkeyword = conninfo_uri_decode(keyword, errorMessage);\n\t\tif (keyword == NULL)\n\t\t{\n\t\t\t/* conninfo_uri_decode already set an error message */\n\t\t\treturn false;\n\t\t}\n\t\tvalue = conninfo_uri_decode(value, errorMessage);\n\t\tif (value == NULL)\n\t\t{\n\t\t\t/* conninfo_uri_decode already set an error message */\n\t\t\tfree(keyword);\n\t\t\treturn false;\n\t\t}\n\t\tmalloced = true;\n\n\t\t/*\n\t\t * Special keyword handling for improved JDBC compatibility.\n\t\t */\n\t\tif (strcmp(keyword, \"ssl\") == 0 &&\n\t\t\tstrcmp(value, \"true\") == 0)\n\t\t{\n\t\t\tfree(keyword);\n\t\t\tfree(value);\n\t\t\tmalloced = false;\n\n\t\t\tkeyword = \"sslmode\";\n\t\t\tvalue = \"require\";\n\t\t}\n\n\t\t/*\n\t\t * Store the value if the corresponding option exists; ignore\n\t\t * otherwise.  At this point both keyword and value are not\n\t\t * URI-encoded.\n\t\t */\n\t\toldmsglen = errorMessage->len;\n\t\tif (!conninfo_storeval(connOptions, keyword, value,\n\t\t\t\t\t\t\t   errorMessage, true, false))\n\t\t{\n\t\t\t/* Insert generic message if conninfo_storeval didn't give one. */\n\t\t\tif (errorMessage->len == oldmsglen)\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid URI query parameter: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  keyword);\n\t\t\t/* And fail. */\n\t\t\tif (malloced)\n\t\t\t{\n\t\t\t\tfree(keyword);\n\t\t\t\tfree(value);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (malloced)\n\t\t{\n\t\t\tfree(keyword);\n\t\t\tfree(value);\n\t\t}\n\n\t\t/* Proceed to next key=value pair, if any */\n\t\tparams = p;\n\t}\n\n\treturn true;\n}\n\n/*\n * Connection URI decoder routine\n *\n * If successful, returns the malloc'd decoded string.\n * If not successful, returns NULL and fills errorMessage accordingly.\n *\n * The string is decoded by replacing any percent-encoded tokens with\n * corresponding characters, while preserving any non-encoded characters.  A\n * percent-encoded token is a character triplet: a percent sign, followed by a\n * pair of hexadecimal digits (0-9A-F), where lower- and upper-case letters are\n * treated identically.\n */\nstatic char *\nconninfo_uri_decode(const char *str, PQExpBuffer errorMessage)\n{\n\tchar\t   *buf;\n\tchar\t   *p;\n\tconst char *q = str;\n\n\tbuf = malloc(strlen(str) + 1);\n\tif (buf == NULL)\n\t{\n\t\tappendPQExpBufferStr(errorMessage, libpq_gettext(\"out of memory\\n\"));\n\t\treturn NULL;\n\t}\n\tp = buf;\n\n\tfor (;;)\n\t{\n\t\tif (*q != '%')\n\t\t{\n\t\t\t/* copy and check for NUL terminator */\n\t\t\tif (!(*(p++) = *(q++)))\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint\t\t\thi;\n\t\t\tint\t\t\tlo;\n\t\t\tint\t\t\tc;\n\n\t\t\t++q;\t\t\t\t/* skip the percent sign itself */\n\n\t\t\t/*\n\t\t\t * Possible EOL will be caught by the first call to\n\t\t\t * get_hexdigit(), so we never dereference an invalid q pointer.\n\t\t\t */\n\t\t\tif (!(get_hexdigit(*q++, &hi) && get_hexdigit(*q++, &lo)))\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"invalid percent-encoded token: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  str);\n\t\t\t\tfree(buf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tc = (hi << 4) | lo;\n\t\t\tif (c == 0)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t\t  libpq_gettext(\"forbidden value %%00 in percent-encoded value: \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t\t  str);\n\t\t\t\tfree(buf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t*(p++) = c;\n\t\t}\n\t}\n\n\treturn buf;\n}\n\n/*\n * Convert hexadecimal digit character to its integer value.\n *\n * If successful, returns true and value is filled with digit's base 16 value.\n * If not successful, returns false.\n *\n * Lower- and upper-case letters in the range A-F are treated identically.\n */\nstatic bool\nget_hexdigit(char digit, int *value)\n{\n\tif ('0' <= digit && digit <= '9')\n\t\t*value = digit - '0';\n\telse if ('A' <= digit && digit <= 'F')\n\t\t*value = digit - 'A' + 10;\n\telse if ('a' <= digit && digit <= 'f')\n\t\t*value = digit - 'a' + 10;\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n\n/*\n * Find an option value corresponding to the keyword in the connOptions array.\n *\n * If successful, returns a pointer to the corresponding option's value.\n * If not successful, returns NULL.\n */\nstatic const char *\nconninfo_getval(PQconninfoOption *connOptions,\n\t\t\t\tconst char *keyword)\n{\n\tPQconninfoOption *option;\n\n\toption = conninfo_find(connOptions, keyword);\n\n\treturn option ? option->val : NULL;\n}\n\n/*\n * Store a (new) value for an option corresponding to the keyword in\n * connOptions array.\n *\n * If uri_decode is true, the value is URI-decoded.  The keyword is always\n * assumed to be non URI-encoded.\n *\n * If successful, returns a pointer to the corresponding PQconninfoOption,\n * which value is replaced with a strdup'd copy of the passed value string.\n * The existing value for the option is free'd before replacing, if any.\n *\n * If not successful, returns NULL and fills errorMessage accordingly.\n * However, if the reason of failure is an invalid keyword being passed and\n * ignoreMissing is true, errorMessage will be left untouched.\n */\nstatic PQconninfoOption *\nconninfo_storeval(PQconninfoOption *connOptions,\n\t\t\t\t  const char *keyword, const char *value,\n\t\t\t\t  PQExpBuffer errorMessage, bool ignoreMissing,\n\t\t\t\t  bool uri_decode)\n{\n\tPQconninfoOption *option;\n\tchar\t   *value_copy;\n\n\t/*\n\t * For backwards compatibility, requiressl=1 gets translated to\n\t * sslmode=require, and requiressl=0 gets translated to sslmode=prefer\n\t * (which is the default for sslmode).\n\t */\n\tif (strcmp(keyword, \"requiressl\") == 0)\n\t{\n\t\tkeyword = \"sslmode\";\n\t\tif (value[0] == '1')\n\t\t\tvalue = \"require\";\n\t\telse\n\t\t\tvalue = \"prefer\";\n\t}\n\n\toption = conninfo_find(connOptions, keyword);\n\tif (option == NULL)\n\t{\n\t\tif (!ignoreMissing)\n\t\t\tappendPQExpBuffer(errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"invalid connection option \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  keyword);\n\t\treturn NULL;\n\t}\n\n\tif (uri_decode)\n\t{\n\t\tvalue_copy = conninfo_uri_decode(value, errorMessage);\n\t\tif (value_copy == NULL)\n\t\t\t/* conninfo_uri_decode already set an error message */\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\tvalue_copy = strdup(value);\n\t\tif (value_copy == NULL)\n\t\t{\n\t\t\tappendPQExpBufferStr(errorMessage, libpq_gettext(\"out of memory\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (option->val)\n\t\tfree(option->val);\n\toption->val = value_copy;\n\n\treturn option;\n}\n\n/*\n * Find a PQconninfoOption option corresponding to the keyword in the\n * connOptions array.\n *\n * If successful, returns a pointer to the corresponding PQconninfoOption\n * structure.\n * If not successful, returns NULL.\n */\nstatic PQconninfoOption *\nconninfo_find(PQconninfoOption *connOptions, const char *keyword)\n{\n\tPQconninfoOption *option;\n\n\tfor (option = connOptions; option->keyword != NULL; option++)\n\t{\n\t\tif (strcmp(option->keyword, keyword) == 0)\n\t\t\treturn option;\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n * Return the connection options used for the connection\n */\nPQconninfoOption *\nPQconninfo(PGconn *conn)\n{\n\tPQExpBufferData errorBuf;\n\tPQconninfoOption *connOptions;\n\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * We don't actually report any errors here, but callees want a buffer,\n\t * and we prefer not to trash the conn's errorMessage.\n\t */\n\tinitPQExpBuffer(&errorBuf);\n\tif (PQExpBufferDataBroken(errorBuf))\n\t\treturn NULL;\t\t\t/* out of memory already :-( */\n\n\tconnOptions = conninfo_init(&errorBuf);\n\n\tif (connOptions != NULL)\n\t{\n\t\tconst internalPQconninfoOption *option;\n\n\t\tfor (option = PQconninfoOptions; option->keyword; option++)\n\t\t{\n\t\t\tchar\t  **connmember;\n\n\t\t\tif (option->connofs < 0)\n\t\t\t\tcontinue;\n\n\t\t\tconnmember = (char **) ((char *) conn + option->connofs);\n\n\t\t\tif (*connmember)\n\t\t\t\tconninfo_storeval(connOptions, option->keyword, *connmember,\n\t\t\t\t\t\t\t\t  &errorBuf, true, false);\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&errorBuf);\n\n\treturn connOptions;\n}\n\n\nvoid\nPQconninfoFree(PQconninfoOption *connOptions)\n{\n\tPQconninfoOption *option;\n\n\tif (connOptions == NULL)\n\t\treturn;\n\n\tfor (option = connOptions; option->keyword != NULL; option++)\n\t{\n\t\tif (option->val != NULL)\n\t\t\tfree(option->val);\n\t}\n\tfree(connOptions);\n}\n\n\n/* =========== accessor functions for PGconn ========= */\nchar *\nPQdb(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\treturn conn->dbName;\n}\n\nchar *\nPQuser(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\treturn conn->pguser;\n}\n\nchar *\nPQpass(const PGconn *conn)\n{\n\tchar\t   *password = NULL;\n\n\tif (!conn)\n\t\treturn NULL;\n\tif (conn->connhost != NULL)\n\t\tpassword = conn->connhost[conn->whichhost].password;\n\tif (password == NULL)\n\t\tpassword = conn->pgpass;\n\t/* Historically we've returned \"\" not NULL for no password specified */\n\tif (password == NULL)\n\t\tpassword = \"\";\n\treturn password;\n}\n\nchar *\nPQhost(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\n\tif (conn->connhost != NULL)\n\t{\n\t\t/*\n\t\t * Return the verbatim host value provided by user, or hostaddr in its\n\t\t * lack.\n\t\t */\n\t\tif (conn->connhost[conn->whichhost].host != NULL &&\n\t\t\tconn->connhost[conn->whichhost].host[0] != '\\0')\n\t\t\treturn conn->connhost[conn->whichhost].host;\n\t\telse if (conn->connhost[conn->whichhost].hostaddr != NULL &&\n\t\t\t\t conn->connhost[conn->whichhost].hostaddr[0] != '\\0')\n\t\t\treturn conn->connhost[conn->whichhost].hostaddr;\n\t}\n\n\treturn \"\";\n}\n\nchar *\nPQhostaddr(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\n\t/* Return the parsed IP address */\n\tif (conn->connhost != NULL && conn->connip != NULL)\n\t\treturn conn->connip;\n\n\treturn \"\";\n}\n\nchar *\nPQport(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\n\tif (conn->connhost != NULL)\n\t\treturn conn->connhost[conn->whichhost].port;\n\n\treturn \"\";\n}\n\n/*\n * No longer does anything, but the function remains for API backwards\n * compatibility.\n */\nchar *\nPQtty(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\treturn \"\";\n}\n\nchar *\nPQoptions(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn NULL;\n\treturn conn->pgoptions;\n}\n\nConnStatusType\nPQstatus(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn CONNECTION_BAD;\n\treturn conn->status;\n}\n\nPGTransactionStatusType\nPQtransactionStatus(const PGconn *conn)\n{\n\tif (!conn || conn->status != CONNECTION_OK)\n\t\treturn PQTRANS_UNKNOWN;\n\tif (conn->asyncStatus != PGASYNC_IDLE)\n\t\treturn PQTRANS_ACTIVE;\n\treturn conn->xactStatus;\n}\n\nconst char *\nPQparameterStatus(const PGconn *conn, const char *paramName)\n{\n\tconst pgParameterStatus *pstatus;\n\n\tif (!conn || !paramName)\n\t\treturn NULL;\n\tfor (pstatus = conn->pstatus; pstatus != NULL; pstatus = pstatus->next)\n\t{\n\t\tif (strcmp(pstatus->name, paramName) == 0)\n\t\t\treturn pstatus->value;\n\t}\n\treturn NULL;\n}\n\nint\nPQprotocolVersion(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn 0;\n\tif (conn->status == CONNECTION_BAD)\n\t\treturn 0;\n\treturn PG_PROTOCOL_MAJOR(conn->pversion);\n}\n\nint\nPQserverVersion(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn 0;\n\tif (conn->status == CONNECTION_BAD)\n\t\treturn 0;\n\treturn conn->sversion;\n}\n\nchar *\nPQerrorMessage(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn libpq_gettext(\"connection pointer is NULL\\n\");\n\n\t/*\n\t * The errorMessage buffer might be marked \"broken\" due to having\n\t * previously failed to allocate enough memory for the message.  In that\n\t * case, tell the application we ran out of memory.\n\t */\n\tif (PQExpBufferBroken(&conn->errorMessage))\n\t\treturn libpq_gettext(\"out of memory\\n\");\n\n\treturn conn->errorMessage.data;\n}\n\n/*\n * In Windows, socket values are unsigned, and an invalid socket value\n * (INVALID_SOCKET) is ~0, which equals -1 in comparisons (with no compiler\n * warning). Ideally we would return an unsigned value for PQsocket() on\n * Windows, but that would cause the function's return value to differ from\n * Unix, so we just return -1 for invalid sockets.\n * http://msdn.microsoft.com/en-us/library/windows/desktop/cc507522%28v=vs.85%29.aspx\n * http://stackoverflow.com/questions/10817252/why-is-invalid-socket-defined-as-0-in-winsock2-h-c\n */\nint\nPQsocket(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn -1;\n\treturn (conn->sock != PGINVALID_SOCKET) ? conn->sock : -1;\n}\n\nint\nPQbackendPID(const PGconn *conn)\n{\n\tif (!conn || conn->status != CONNECTION_OK)\n\t\treturn 0;\n\treturn conn->be_pid;\n}\n\nPGpipelineStatus\nPQpipelineStatus(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn PQ_PIPELINE_OFF;\n\n\treturn conn->pipelineStatus;\n}\n\nint\nPQconnectionNeedsPassword(const PGconn *conn)\n{\n\tchar\t   *password;\n\n\tif (!conn)\n\t\treturn false;\n\tpassword = PQpass(conn);\n\tif (conn->password_needed &&\n\t\t(password == NULL || password[0] == '\\0'))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint\nPQconnectionUsedPassword(const PGconn *conn)\n{\n\tif (!conn)\n\t\treturn false;\n\tif (conn->password_needed)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint\nPQclientEncoding(const PGconn *conn)\n{\n\tif (!conn || conn->status != CONNECTION_OK)\n\t\treturn -1;\n\treturn conn->client_encoding;\n}\n\nint\nPQsetClientEncoding(PGconn *conn, const char *encoding)\n{\n\tchar\t\tqbuf[128];\n\tstatic const char query[] = \"set client_encoding to '%s'\";\n\tPGresult   *res;\n\tint\t\t\tstatus;\n\n\tif (!conn || conn->status != CONNECTION_OK)\n\t\treturn -1;\n\n\tif (!encoding)\n\t\treturn -1;\n\n\t/* Resolve special \"auto\" value from the locale */\n\tif (strcmp(encoding, \"auto\") == 0)\n\t\tencoding = pg_encoding_to_char(pg_get_encoding_from_locale(NULL, true));\n\n\t/* check query buffer overflow */\n\tif (sizeof(qbuf) < (sizeof(query) + strlen(encoding)))\n\t\treturn -1;\n\n\t/* ok, now send a query */\n\tsprintf(qbuf, query, encoding);\n\tres = PQexec(conn, qbuf);\n\n\tif (res == NULL)\n\t\treturn -1;\n\tif (res->resultStatus != PGRES_COMMAND_OK)\n\t\tstatus = -1;\n\telse\n\t{\n\t\t/*\n\t\t * We rely on the backend to report the parameter value, and we'll\n\t\t * change state at that time.\n\t\t */\n\t\tstatus = 0;\t\t\t\t/* everything is ok */\n\t}\n\tPQclear(res);\n\treturn status;\n}\n\nPGVerbosity\nPQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity)\n{\n\tPGVerbosity old;\n\n\tif (!conn)\n\t\treturn PQERRORS_DEFAULT;\n\told = conn->verbosity;\n\tconn->verbosity = verbosity;\n\treturn old;\n}\n\nPGContextVisibility\nPQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context)\n{\n\tPGContextVisibility old;\n\n\tif (!conn)\n\t\treturn PQSHOW_CONTEXT_ERRORS;\n\told = conn->show_context;\n\tconn->show_context = show_context;\n\treturn old;\n}\n\nPQnoticeReceiver\nPQsetNoticeReceiver(PGconn *conn, PQnoticeReceiver proc, void *arg)\n{\n\tPQnoticeReceiver old;\n\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\told = conn->noticeHooks.noticeRec;\n\tif (proc)\n\t{\n\t\tconn->noticeHooks.noticeRec = proc;\n\t\tconn->noticeHooks.noticeRecArg = arg;\n\t}\n\treturn old;\n}\n\nPQnoticeProcessor\nPQsetNoticeProcessor(PGconn *conn, PQnoticeProcessor proc, void *arg)\n{\n\tPQnoticeProcessor old;\n\n\tif (conn == NULL)\n\t\treturn NULL;\n\n\told = conn->noticeHooks.noticeProc;\n\tif (proc)\n\t{\n\t\tconn->noticeHooks.noticeProc = proc;\n\t\tconn->noticeHooks.noticeProcArg = arg;\n\t}\n\treturn old;\n}\n\n/*\n * The default notice message receiver just gets the standard notice text\n * and sends it to the notice processor.  This two-level setup exists\n * mostly for backwards compatibility; perhaps we should deprecate use of\n * PQsetNoticeProcessor?\n */\nstatic void\ndefaultNoticeReceiver(void *arg, const PGresult *res)\n{\n\t(void) arg;\t\t\t\t\t/* not used */\n\tif (res->noticeHooks.noticeProc != NULL)\n\t\tres->noticeHooks.noticeProc(res->noticeHooks.noticeProcArg,\n\t\t\t\t\t\t\t\t\tPQresultErrorMessage(res));\n}\n\n/*\n * The default notice message processor just prints the\n * message on stderr.  Applications can override this if they\n * want the messages to go elsewhere (a window, for example).\n * Note that simply discarding notices is probably a bad idea.\n */\nstatic void\ndefaultNoticeProcessor(void *arg, const char *message)\n{\n\t(void) arg;\t\t\t\t\t/* not used */\n\t/* Note: we expect the supplied string to end with a newline already. */\n\tfprintf(stderr, \"%s\", message);\n}\n\n/*\n * returns a pointer to the next token or NULL if the current\n * token doesn't match\n */\nstatic char *\npwdfMatchesString(char *buf, const char *token)\n{\n\tchar\t   *tbuf;\n\tconst char *ttok;\n\tbool\t\tbslash = false;\n\n\tif (buf == NULL || token == NULL)\n\t\treturn NULL;\n\ttbuf = buf;\n\tttok = token;\n\tif (tbuf[0] == '*' && tbuf[1] == ':')\n\t\treturn tbuf + 2;\n\twhile (*tbuf != 0)\n\t{\n\t\tif (*tbuf == '\\\\' && !bslash)\n\t\t{\n\t\t\ttbuf++;\n\t\t\tbslash = true;\n\t\t}\n\t\tif (*tbuf == ':' && *ttok == 0 && !bslash)\n\t\t\treturn tbuf + 1;\n\t\tbslash = false;\n\t\tif (*ttok == 0)\n\t\t\treturn NULL;\n\t\tif (*tbuf == *ttok)\n\t\t{\n\t\t\ttbuf++;\n\t\t\tttok++;\n\t\t}\n\t\telse\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\n/* Get a password from the password file. Return value is malloc'd. */\nstatic char *\npasswordFromFile(const char *hostname, const char *port, const char *dbname,\n\t\t\t\t const char *username, const char *pgpassfile)\n{\n\tFILE\t   *fp;\n\tstruct stat stat_buf;\n\tPQExpBufferData buf;\n\n\tif (dbname == NULL || dbname[0] == '\\0')\n\t\treturn NULL;\n\n\tif (username == NULL || username[0] == '\\0')\n\t\treturn NULL;\n\n\t/* 'localhost' matches pghost of '' or the default socket directory */\n\tif (hostname == NULL || hostname[0] == '\\0')\n\t\thostname = DefaultHost;\n\telse if (is_unixsock_path(hostname))\n\n\t\t/*\n\t\t * We should probably use canonicalize_path(), but then we have to\n\t\t * bring path.c into libpq, and it doesn't seem worth it.\n\t\t */\n\t\tif (strcmp(hostname, DEFAULT_PGSOCKET_DIR) == 0)\n\t\t\thostname = DefaultHost;\n\n\tif (port == NULL || port[0] == '\\0')\n\t\tport = DEF_PGPORT_STR;\n\n\t/* If password file cannot be opened, ignore it. */\n\tif (stat(pgpassfile, &stat_buf) != 0)\n\t\treturn NULL;\n\n#ifndef WIN32\n\tif (!S_ISREG(stat_buf.st_mode))\n\t{\n\t\tfprintf(stderr,\n\t\t\t\tlibpq_gettext(\"WARNING: password file \\\"%s\\\" is not a plain file\\n\"),\n\t\t\t\tpgpassfile);\n\t\treturn NULL;\n\t}\n\n\t/* If password file is insecure, alert the user and ignore it. */\n\tif (stat_buf.st_mode & (S_IRWXG | S_IRWXO))\n\t{\n\t\tfprintf(stderr,\n\t\t\t\tlibpq_gettext(\"WARNING: password file \\\"%s\\\" has group or world access; permissions should be u=rw (0600) or less\\n\"),\n\t\t\t\tpgpassfile);\n\t\treturn NULL;\n\t}\n#else\n\n\t/*\n\t * On Win32, the directory is protected, so we don't have to check the\n\t * file.\n\t */\n#endif\n\n\tfp = fopen(pgpassfile, \"r\");\n\tif (fp == NULL)\n\t\treturn NULL;\n\n\t/* Use an expansible buffer to accommodate any reasonable line length */\n\tinitPQExpBuffer(&buf);\n\n\twhile (!feof(fp) && !ferror(fp))\n\t{\n\t\t/* Make sure there's a reasonable amount of room in the buffer */\n\t\tif (!enlargePQExpBuffer(&buf, 128))\n\t\t\tbreak;\n\n\t\t/* Read some data, appending it to what we already have */\n\t\tif (fgets(buf.data + buf.len, buf.maxlen - buf.len, fp) == NULL)\n\t\t\tbreak;\n\t\tbuf.len += strlen(buf.data + buf.len);\n\n\t\t/* If we don't yet have a whole line, loop around to read more */\n\t\tif (!(buf.len > 0 && buf.data[buf.len - 1] == '\\n') && !feof(fp))\n\t\t\tcontinue;\n\n\t\t/* ignore comments */\n\t\tif (buf.data[0] != '#')\n\t\t{\n\t\t\tchar\t   *t = buf.data;\n\t\t\tint\t\t\tlen;\n\n\t\t\t/* strip trailing newline and carriage return */\n\t\t\tlen = pg_strip_crlf(t);\n\n\t\t\tif (len > 0 &&\n\t\t\t\t(t = pwdfMatchesString(t, hostname)) != NULL &&\n\t\t\t\t(t = pwdfMatchesString(t, port)) != NULL &&\n\t\t\t\t(t = pwdfMatchesString(t, dbname)) != NULL &&\n\t\t\t\t(t = pwdfMatchesString(t, username)) != NULL)\n\t\t\t{\n\t\t\t\t/* Found a match. */\n\t\t\t\tchar\t   *ret,\n\t\t\t\t\t\t   *p1,\n\t\t\t\t\t\t   *p2;\n\n\t\t\t\tret = strdup(t);\n\n\t\t\t\tfclose(fp);\n\t\t\t\texplicit_bzero(buf.data, buf.maxlen);\n\t\t\t\ttermPQExpBuffer(&buf);\n\n\t\t\t\tif (!ret)\n\t\t\t\t{\n\t\t\t\t\t/* Out of memory. XXX: an error message would be nice. */\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\t/* De-escape password. */\n\t\t\t\tfor (p1 = p2 = ret; *p1 != ':' && *p1 != '\\0'; ++p1, ++p2)\n\t\t\t\t{\n\t\t\t\t\tif (*p1 == '\\\\' && p1[1] != '\\0')\n\t\t\t\t\t\t++p1;\n\t\t\t\t\t*p2 = *p1;\n\t\t\t\t}\n\t\t\t\t*p2 = '\\0';\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/* No match, reset buffer to prepare for next line. */\n\t\tbuf.len = 0;\n\t}\n\n\tfclose(fp);\n\texplicit_bzero(buf.data, buf.maxlen);\n\ttermPQExpBuffer(&buf);\n\treturn NULL;\n}\n\n\n/*\n *\tIf the connection failed due to bad password, we should mention\n *\tif we got the password from the pgpassfile.\n */\nstatic void\npgpassfileWarning(PGconn *conn)\n{\n\t/* If it was 'invalid authorization', add pgpassfile mention */\n\t/* only works with >= 9.0 servers */\n\tif (conn->password_needed &&\n\t\tconn->connhost[conn->whichhost].password != NULL &&\n\t\tconn->result)\n\t{\n\t\tconst char *sqlstate = PQresultErrorField(conn->result,\n\t\t\t\t\t\t\t\t\t\t\t\t  PG_DIAG_SQLSTATE);\n\n\t\tif (sqlstate && strcmp(sqlstate, ERRCODE_INVALID_PASSWORD) == 0)\n\t\t\tappendPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"password retrieved from file \\\"%s\\\"\\n\"),\n\t\t\t\t\t\t\t  conn->pgpassfile);\n\t}\n}\n\n/*\n * Check if the SSL protocol value given in input is valid or not.\n * This is used as a sanity check routine for the connection parameters\n * ssl_min_protocol_version and ssl_max_protocol_version.\n */\nstatic bool\nsslVerifyProtocolVersion(const char *version)\n{\n\t/*\n\t * An empty string and a NULL value are considered valid as it is\n\t * equivalent to ignoring the parameter.\n\t */\n\tif (!version || strlen(version) == 0)\n\t\treturn true;\n\n\tif (pg_strcasecmp(version, \"TLSv1\") == 0 ||\n\t\tpg_strcasecmp(version, \"TLSv1.1\") == 0 ||\n\t\tpg_strcasecmp(version, \"TLSv1.2\") == 0 ||\n\t\tpg_strcasecmp(version, \"TLSv1.3\") == 0)\n\t\treturn true;\n\n\t/* anything else is wrong */\n\treturn false;\n}\n\n\n/*\n * Ensure that the SSL protocol range given in input is correct.  The check\n * is performed on the input string to keep it TLS backend agnostic.  Input\n * to this function is expected verified with sslVerifyProtocolVersion().\n */\nstatic bool\nsslVerifyProtocolRange(const char *min, const char *max)\n{\n\tAssert(sslVerifyProtocolVersion(min) &&\n\t\t   sslVerifyProtocolVersion(max));\n\n\t/* If at least one of the bounds is not set, the range is valid */\n\tif (min == NULL || max == NULL || strlen(min) == 0 || strlen(max) == 0)\n\t\treturn true;\n\n\t/*\n\t * If the minimum version is the lowest one we accept, then all options\n\t * for the maximum are valid.\n\t */\n\tif (pg_strcasecmp(min, \"TLSv1\") == 0)\n\t\treturn true;\n\n\t/*\n\t * The minimum bound is valid, and cannot be TLSv1, so using TLSv1 for the\n\t * maximum is incorrect.\n\t */\n\tif (pg_strcasecmp(max, \"TLSv1\") == 0)\n\t\treturn false;\n\n\t/*\n\t * At this point we know that we have a mix of TLSv1.1 through 1.3\n\t * versions.\n\t */\n\tif (pg_strcasecmp(min, max) > 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n\n/*\n * Obtain user's home directory, return in given buffer\n *\n * On Unix, this actually returns the user's home directory.  On Windows\n * it returns the PostgreSQL-specific application data folder.\n *\n * This is essentially the same as get_home_path(), but we don't use that\n * because we don't want to pull path.c into libpq (it pollutes application\n * namespace).\n *\n * Returns true on success, false on failure to obtain the directory name.\n *\n * CAUTION: although in most situations failure is unexpected, there are users\n * who like to run applications in a home-directory-less environment.  On\n * failure, you almost certainly DO NOT want to report an error.  Just act as\n * though whatever file you were hoping to find in the home directory isn't\n * there (which it isn't).\n */\nbool\npqGetHomeDirectory(char *buf, int bufsize)\n{\n#ifndef WIN32\n\tchar\t\tpwdbuf[BUFSIZ];\n\tstruct passwd pwdstr;\n\tstruct passwd *pwd = NULL;\n\n\t(void) pqGetpwuid(geteuid(), &pwdstr, pwdbuf, sizeof(pwdbuf), &pwd);\n\tif (pwd == NULL)\n\t\treturn false;\n\tstrlcpy(buf, pwd->pw_dir, bufsize);\n\treturn true;\n#else\n\tchar\t\ttmppath[MAX_PATH];\n\n\tZeroMemory(tmppath, sizeof(tmppath));\n\tif (SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, tmppath) != S_OK)\n\t\treturn false;\n\tsnprintf(buf, bufsize, \"%s/postgresql\", tmppath);\n\treturn true;\n#endif\n}\n\n/*\n * To keep the API consistent, the locking stubs are always provided, even\n * if they are not required.\n *\n * Since we neglected to provide any error-return convention in the\n * pgthreadlock_t API, we can't do much except Assert upon failure of any\n * mutex primitive.  Fortunately, such failures appear to be nonexistent in\n * the field.\n */\n\nstatic void\ndefault_threadlock(int acquire)\n{\n#ifdef ENABLE_THREAD_SAFETY\n#ifndef WIN32\n\tstatic pthread_mutex_t singlethread_lock = PTHREAD_MUTEX_INITIALIZER;\n#else\n\tstatic pthread_mutex_t singlethread_lock = NULL;\n\tstatic long mutex_initlock = 0;\n\n\tif (singlethread_lock == NULL)\n\t{\n\t\twhile (InterlockedExchange(&mutex_initlock, 1) == 1)\n\t\t\t /* loop, another thread own the lock */ ;\n\t\tif (singlethread_lock == NULL)\n\t\t{\n\t\t\tif (pthread_mutex_init(&singlethread_lock, NULL))\n\t\t\t\tAssert(false);\n\t\t}\n\t\tInterlockedExchange(&mutex_initlock, 0);\n\t}\n#endif\n\tif (acquire)\n\t{\n\t\tif (pthread_mutex_lock(&singlethread_lock))\n\t\t\tAssert(false);\n\t}\n\telse\n\t{\n\t\tif (pthread_mutex_unlock(&singlethread_lock))\n\t\t\tAssert(false);\n\t}\n#endif\n}\n\npgthreadlock_t\nPQregisterThreadLock(pgthreadlock_t newhandler)\n{\n\tpgthreadlock_t prev = pg_g_threadlock;\n\n\tif (newhandler)\n\t\tpg_g_threadlock = newhandler;\n\telse\n\t\tpg_g_threadlock = default_threadlock;\n\n\treturn prev;\n}\n"], "filenames": ["doc/src/sgml/protocol.sgml", "src/interfaces/libpq/fe-connect.c"], "buggy_code_start_loc": [1480, 3099], "buggy_code_end_loc": [1539, 3198], "fixing_code_start_loc": [1481, 3100], "fixing_code_end_loc": [1568, 3225], "type": "CWE-522", "message": "A man-in-the-middle attacker can inject false responses to the client's first few queries, despite the use of SSL certificate verification and encryption.", "other": {"cve": {"id": "CVE-2021-23222", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-02T23:15:08.517", "lastModified": "2023-01-31T17:29:26.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A man-in-the-middle attacker can inject false responses to the client's first few queries, despite the use of SSL certificate verification and encryption."}, {"lang": "es", "value": "Un atacante de tipo man-in-the-middle puede inyectar respuestas falsas a las primeras consultas del cliente, a pesar de haber usado la verificaci\u00f3n y el cifrado de certificados SSL"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-522"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.6", "versionEndExcluding": "9.6.24", "matchCriteriaId": "05169DD0-8704-497F-A7C8-826A2EBE1736"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0", "versionEndExcluding": "10.19", "matchCriteriaId": "C495B1CF-63CD-4E10-A9B2-6FD773AD5243"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.14", "matchCriteriaId": "121A1F97-8480-4C15-AAA6-256CB1C0DD47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.0", "versionEndExcluding": "12.9", "matchCriteriaId": "1E585815-7CA4-4B66-B222-28064F4600C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0", "versionEndExcluding": "13.5", "matchCriteriaId": "D4F8E475-7A26-4157-8E42-91D37845436C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:14.0:*:*:*:*:*:*:*", "matchCriteriaId": "B7DAB70A-574C-45E0-BC26-0C980E58907B"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2022675", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=d83cdfdca9d918bbbd6bb209139b94c954da7228", "source": "secalert@redhat.com", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/postgres/postgres/commit/160c0258802d10b0600d7671b1bbea55d8e17d45", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202211-04", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.postgresql.org/support/security/CVE-2021-23222/", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/postgres/postgres/commit/160c0258802d10b0600d7671b1bbea55d8e17d45"}}