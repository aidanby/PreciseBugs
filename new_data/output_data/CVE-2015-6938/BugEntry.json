{"buggy_code": ["# coding: utf-8\n\"\"\"A tornado based IPython notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom __future__ import absolute_import, print_function\n\nimport base64\nimport datetime\nimport errno\nimport importlib\nimport io\nimport json\nimport logging\nimport os\nimport random\nimport re\nimport select\nimport signal\nimport socket\nimport ssl\nimport sys\nimport threading\nimport webbrowser\n\n\nfrom jinja2 import Environment, FileSystemLoader\n\n# Install the pyzmq ioloop. This has to be done before anything else from\n# tornado is imported.\nfrom zmq.eventloop import ioloop\nioloop.install()\n\n# check for tornado 3.1.0\nmsg = \"The IPython Notebook requires tornado >= 4.0\"\ntry:\n    import tornado\nexcept ImportError:\n    raise ImportError(msg)\ntry:\n    version_info = tornado.version_info\nexcept AttributeError:\n    raise ImportError(msg + \", but you have < 1.1.0\")\nif version_info < (4,0):\n    raise ImportError(msg + \", but you have %s\" % tornado.version)\n\nfrom tornado import httpserver\nfrom tornado import web\nfrom tornado.log import LogFormatter, app_log, access_log, gen_log\n\nfrom notebook import (\n    DEFAULT_STATIC_FILES_PATH,\n    DEFAULT_TEMPLATE_PATH_LIST,\n    __version__,\n)\nfrom .base.handlers import Template404\nfrom .log import log_request\nfrom .services.kernels.kernelmanager import MappingKernelManager\nfrom .services.config import ConfigManager\nfrom .services.contents.manager import ContentsManager\nfrom .services.contents.filemanager import FileContentsManager\nfrom .services.sessions.sessionmanager import SessionManager\n\nfrom .auth.login import LoginHandler\nfrom .auth.logout import LogoutHandler\nfrom .base.handlers import FileFindHandler, IPythonHandler\n\nfrom traitlets.config import Config\nfrom traitlets.config.application import catch_config_error, boolean_flag\nfrom jupyter_core.application import (\n    JupyterApp, base_flags, base_aliases,\n)\nfrom jupyter_client import KernelManager\nfrom jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME\nfrom jupyter_client.session import Session\nfrom nbformat.sign import NotebookNotary\nfrom traitlets import (\n    Dict, Unicode, Integer, List, Bool, Bytes, Instance,\n    TraitError, Type,\n)\nfrom ipython_genutils import py3compat\nfrom IPython.paths import get_ipython_dir\nfrom jupyter_core.paths import jupyter_runtime_dir, jupyter_path\nfrom notebook._sysinfo import get_sys_info\n\nfrom .utils import url_path_join, check_pid\n\n#-----------------------------------------------------------------------------\n# Module globals\n#-----------------------------------------------------------------------------\n\n_examples = \"\"\"\nipython notebook                       # start the notebook\nipython notebook --profile=sympy       # use the sympy profile\nipython notebook --certfile=mycert.pem # use SSL/TLS certificate\n\"\"\"\n\n#-----------------------------------------------------------------------------\n# Helper functions\n#-----------------------------------------------------------------------------\n\ndef random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))\n\ndef load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers\n\n\nclass DeprecationHandler(IPythonHandler):\n    def get(self, url_path):\n        self.set_header(\"Content-Type\", 'text/javascript')\n        self.finish(\"\"\"\n            console.warn('`/static/widgets/js` is deprecated.  Use `/nbextensions/widgets/widgets/js` instead.');\n            define(['%s'], function(x) { return x; });\n        \"\"\" % url_path_join('nbextensions', 'widgets', 'widgets', url_path.rstrip('.js')))\n        self.log.warn('Deprecated widget Javascript path /static/widgets/js/*.js was used')\n\n#-----------------------------------------------------------------------------\n# The Tornado web application\n#-----------------------------------------------------------------------------\n\nclass NotebookWebApplication(web.Application):\n\n    def __init__(self, ipython_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        settings = self.init_settings(\n            ipython_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, ipython_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            ipython_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = jinja_env_options if jinja_env_options else {}\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=ipython_app.static_file_path,\n            static_custom_path=ipython_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            \n            # authentication\n            cookie_secret=ipython_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=ipython_app.login_handler_class,\n            logout_handler_class=ipython_app.logout_handler_class,\n            password=ipython_app.password,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=ipython_app.jinja_template_vars,\n            nbextensions_path=ipython_app.nbextensions_path,\n            websocket_url=ipython_app.websocket_url,\n            mathjax_url=ipython_app.mathjax_url,\n            config=ipython_app.config,\n            config_dir=ipython_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.append((r'/deprecatedwidgets/(.*)', DeprecationHandler))\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        try:\n            import ipywidgets\n            handlers.append(\n                (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                    'path': ipywidgets.find_static_assets(),\n                    'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                }),\n            )\n        except:\n            app_log.warn('ipywidgets package not installed.  Widgets are unavailable.')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', web.RedirectHandler, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers\n\n\nclass NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers in this profile.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                print(serverinfo['url'], \"::\", serverinfo['notebook_dir'])\n\n#-----------------------------------------------------------------------------\n# Aliases and Flags\n#-----------------------------------------------------------------------------\n\nflags = dict(base_flags)\nflags['no-browser']=(\n    {'NotebookApp' : {'open_browser' : False}},\n    \"Don't open the notebook in a browser after startup.\"\n)\nflags['pylab']=(\n    {'NotebookApp' : {'pylab' : 'warn'}},\n    \"DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\"\n)\nflags['no-mathjax']=(\n    {'NotebookApp' : {'enable_mathjax' : False}},\n    \"\"\"Disable MathJax\n    \n    MathJax is the javascript library IPython uses to render math/LaTeX. It is\n    very large, so you may want to disable it if you have a slow internet\n    connection, or for offline use of the notebook.\n    \n    When disabled, equations etc. will appear as their untransformed TeX source.\n    \"\"\"\n)\n\n# Add notebook manager flags\nflags.update(boolean_flag('script', 'FileContentsManager.save_script',\n               'DEPRECATED, IGNORED',\n               'DEPRECATED, IGNORED'))\n\naliases = dict(base_aliases)\n\naliases.update({\n    'ip': 'NotebookApp.ip',\n    'port': 'NotebookApp.port',\n    'port-retries': 'NotebookApp.port_retries',\n    'transport': 'KernelManager.transport',\n    'keyfile': 'NotebookApp.keyfile',\n    'certfile': 'NotebookApp.certfile',\n    'notebook-dir': 'NotebookApp.notebook_dir',\n    'browser': 'NotebookApp.browser',\n    'pylab': 'NotebookApp.pylab',\n})\n\n#-----------------------------------------------------------------------------\n# NotebookApp\n#-----------------------------------------------------------------------------\n\nclass NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    def _log_level_default(self):\n        return logging.INFO\n\n    def _log_datefmt_default(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    def _log_format_default(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    # create requested profiles by default, if they don't exist:\n    auto_create = Bool(True)\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n    def _ip_default(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warn(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    def _ip_changed(self, name, old, new):\n        if new == u'*': self.ip = u''\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n    def _cookie_secret_file_default(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    def _cookie_secret_default(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = base64.encodestring(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warn(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n    def _webapp_settings_changed(self, name, old, new):\n        self.log.warn(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = new\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"IPython notebook uses.\")\n    \n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library IPython uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n    def _enable_mathjax_changed(self, name, old, new):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not new:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n    def _base_url_changed(self, name, old, new):\n        if not new.startswith('/'):\n            self.base_url = '/'+new\n        elif not new.endswith('/'):\n            self.base_url = new+'/'\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n    def _base_project_url_changed(self, name, old, new):\n        self.log.warn(\"base_project_url is deprecated, use base_url\")\n        self.base_url = new\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n    def _static_custom_path_default(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                # FIXME: serve IPython profile while we don't have `jupyter migrate`\n                os.path.join(get_ipython_dir(), 'profile_default', 'static'),\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path once migration is setup\n        path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"The url for MathJax.js.\"\"\"\n    )\n    def _mathjax_url_default(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\",\n                         url_path_join(self.base_url, \"static\")\n        )\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    def _mathjax_url_changed(self, name, old, new):\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of IPython and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    def _info_file_default(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n    def _pylab_changed(self, name, old, new):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if new != 'warn':\n            backend = ' %s' % new\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    def _notebook_dir_default(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    def _notebook_dir_changed(self, name, old, new):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        if not os.path.isabs(new):\n            # If we receive a non-absolute path, make it absolute.\n            self.notebook_dir = os.path.abspath(new)\n            return\n        if not os.path.isdir(new):\n            raise TraitError(\"No such notebook dir: %r\" % new)\n        \n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    server_extensions = List(Unicode(), config=True,\n        help=(\"Python modules to load as notebook server extensions. \"\n              \"This is an experimental API, and may change in future releases.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n        \n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the profile.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n        \n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # Disable SSLv3, since its use is discouraged.\n            ssl_options['ssl_version']=ssl.PROTOCOL_TLSv1\n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another random port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warn(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        return self._url(ip)\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warn\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        for modulename in self.server_extensions:\n            try:\n                mod = importlib.import_module(modulename)\n                func = getattr(mod, 'load_jupyter_server_extension', None)\n                if func is not None:\n                    func(self)\n            except Exception:\n                if self.reraise_server_extension_failures:\n                    raise\n                self.log.warn(\"Error loading server extension %s\", modulename,\n                              exc_info=True)\n    \n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The IPython Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'pid': os.getpid()\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the IPython Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warn('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_path_join('notebooks', *relpath.split(os.sep))\n            else:\n                uri = 'tree'\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n        \n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.cleanup_kernels()\n            self.remove_server_info_file()\n    \n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)\n\n\ndef list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a profile name, find nbserver-* files in the security directory of\n    that profile, and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(file)\n                except OSError:\n                    pass  # TODO: This should warn or log or something\n#-----------------------------------------------------------------------------\n# Main entry point\n#-----------------------------------------------------------------------------\n\nmain = launch_new_instance = NotebookApp.launch_instance\n\n"], "fixing_code": ["# coding: utf-8\n\"\"\"A tornado based IPython notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom __future__ import absolute_import, print_function\n\nimport base64\nimport datetime\nimport errno\nimport importlib\nimport io\nimport json\nimport logging\nimport os\nimport random\nimport re\nimport select\nimport signal\nimport socket\nimport ssl\nimport sys\nimport threading\nimport webbrowser\n\n\nfrom jinja2 import Environment, FileSystemLoader\n\n# Install the pyzmq ioloop. This has to be done before anything else from\n# tornado is imported.\nfrom zmq.eventloop import ioloop\nioloop.install()\n\n# check for tornado 3.1.0\nmsg = \"The IPython Notebook requires tornado >= 4.0\"\ntry:\n    import tornado\nexcept ImportError:\n    raise ImportError(msg)\ntry:\n    version_info = tornado.version_info\nexcept AttributeError:\n    raise ImportError(msg + \", but you have < 1.1.0\")\nif version_info < (4,0):\n    raise ImportError(msg + \", but you have %s\" % tornado.version)\n\nfrom tornado import httpserver\nfrom tornado import web\nfrom tornado.log import LogFormatter, app_log, access_log, gen_log\n\nfrom notebook import (\n    DEFAULT_STATIC_FILES_PATH,\n    DEFAULT_TEMPLATE_PATH_LIST,\n    __version__,\n)\nfrom .base.handlers import Template404\nfrom .log import log_request\nfrom .services.kernels.kernelmanager import MappingKernelManager\nfrom .services.config import ConfigManager\nfrom .services.contents.manager import ContentsManager\nfrom .services.contents.filemanager import FileContentsManager\nfrom .services.sessions.sessionmanager import SessionManager\n\nfrom .auth.login import LoginHandler\nfrom .auth.logout import LogoutHandler\nfrom .base.handlers import FileFindHandler, IPythonHandler\n\nfrom traitlets.config import Config\nfrom traitlets.config.application import catch_config_error, boolean_flag\nfrom jupyter_core.application import (\n    JupyterApp, base_flags, base_aliases,\n)\nfrom jupyter_client import KernelManager\nfrom jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME\nfrom jupyter_client.session import Session\nfrom nbformat.sign import NotebookNotary\nfrom traitlets import (\n    Dict, Unicode, Integer, List, Bool, Bytes, Instance,\n    TraitError, Type,\n)\nfrom ipython_genutils import py3compat\nfrom IPython.paths import get_ipython_dir\nfrom jupyter_core.paths import jupyter_runtime_dir, jupyter_path\nfrom notebook._sysinfo import get_sys_info\n\nfrom .utils import url_path_join, check_pid\n\n#-----------------------------------------------------------------------------\n# Module globals\n#-----------------------------------------------------------------------------\n\n_examples = \"\"\"\nipython notebook                       # start the notebook\nipython notebook --profile=sympy       # use the sympy profile\nipython notebook --certfile=mycert.pem # use SSL/TLS certificate\n\"\"\"\n\n#-----------------------------------------------------------------------------\n# Helper functions\n#-----------------------------------------------------------------------------\n\ndef random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))\n\ndef load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers\n\n\nclass DeprecationHandler(IPythonHandler):\n    def get(self, url_path):\n        self.set_header(\"Content-Type\", 'text/javascript')\n        self.finish(\"\"\"\n            console.warn('`/static/widgets/js` is deprecated.  Use `/nbextensions/widgets/widgets/js` instead.');\n            define(['%s'], function(x) { return x; });\n        \"\"\" % url_path_join('nbextensions', 'widgets', 'widgets', url_path.rstrip('.js')))\n        self.log.warn('Deprecated widget Javascript path /static/widgets/js/*.js was used')\n\n#-----------------------------------------------------------------------------\n# The Tornado web application\n#-----------------------------------------------------------------------------\n\nclass NotebookWebApplication(web.Application):\n\n    def __init__(self, ipython_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        settings = self.init_settings(\n            ipython_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, ipython_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            ipython_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = {\"autoescape\": True}\n        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=ipython_app.static_file_path,\n            static_custom_path=ipython_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            \n            # authentication\n            cookie_secret=ipython_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=ipython_app.login_handler_class,\n            logout_handler_class=ipython_app.logout_handler_class,\n            password=ipython_app.password,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=ipython_app.jinja_template_vars,\n            nbextensions_path=ipython_app.nbextensions_path,\n            websocket_url=ipython_app.websocket_url,\n            mathjax_url=ipython_app.mathjax_url,\n            config=ipython_app.config,\n            config_dir=ipython_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.append((r'/deprecatedwidgets/(.*)', DeprecationHandler))\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        try:\n            import ipywidgets\n            handlers.append(\n                (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                    'path': ipywidgets.find_static_assets(),\n                    'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                }),\n            )\n        except:\n            app_log.warn('ipywidgets package not installed.  Widgets are unavailable.')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', web.RedirectHandler, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers\n\n\nclass NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers in this profile.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                print(serverinfo['url'], \"::\", serverinfo['notebook_dir'])\n\n#-----------------------------------------------------------------------------\n# Aliases and Flags\n#-----------------------------------------------------------------------------\n\nflags = dict(base_flags)\nflags['no-browser']=(\n    {'NotebookApp' : {'open_browser' : False}},\n    \"Don't open the notebook in a browser after startup.\"\n)\nflags['pylab']=(\n    {'NotebookApp' : {'pylab' : 'warn'}},\n    \"DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\"\n)\nflags['no-mathjax']=(\n    {'NotebookApp' : {'enable_mathjax' : False}},\n    \"\"\"Disable MathJax\n    \n    MathJax is the javascript library IPython uses to render math/LaTeX. It is\n    very large, so you may want to disable it if you have a slow internet\n    connection, or for offline use of the notebook.\n    \n    When disabled, equations etc. will appear as their untransformed TeX source.\n    \"\"\"\n)\n\n# Add notebook manager flags\nflags.update(boolean_flag('script', 'FileContentsManager.save_script',\n               'DEPRECATED, IGNORED',\n               'DEPRECATED, IGNORED'))\n\naliases = dict(base_aliases)\n\naliases.update({\n    'ip': 'NotebookApp.ip',\n    'port': 'NotebookApp.port',\n    'port-retries': 'NotebookApp.port_retries',\n    'transport': 'KernelManager.transport',\n    'keyfile': 'NotebookApp.keyfile',\n    'certfile': 'NotebookApp.certfile',\n    'notebook-dir': 'NotebookApp.notebook_dir',\n    'browser': 'NotebookApp.browser',\n    'pylab': 'NotebookApp.pylab',\n})\n\n#-----------------------------------------------------------------------------\n# NotebookApp\n#-----------------------------------------------------------------------------\n\nclass NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    def _log_level_default(self):\n        return logging.INFO\n\n    def _log_datefmt_default(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    def _log_format_default(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    # create requested profiles by default, if they don't exist:\n    auto_create = Bool(True)\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n    def _ip_default(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warn(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    def _ip_changed(self, name, old, new):\n        if new == u'*': self.ip = u''\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n    def _cookie_secret_file_default(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    def _cookie_secret_default(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = base64.encodestring(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warn(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n    def _webapp_settings_changed(self, name, old, new):\n        self.log.warn(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = new\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"IPython notebook uses.\")\n    \n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library IPython uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n    def _enable_mathjax_changed(self, name, old, new):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not new:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n    def _base_url_changed(self, name, old, new):\n        if not new.startswith('/'):\n            self.base_url = '/'+new\n        elif not new.endswith('/'):\n            self.base_url = new+'/'\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n    def _base_project_url_changed(self, name, old, new):\n        self.log.warn(\"base_project_url is deprecated, use base_url\")\n        self.base_url = new\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n    def _static_custom_path_default(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                # FIXME: serve IPython profile while we don't have `jupyter migrate`\n                os.path.join(get_ipython_dir(), 'profile_default', 'static'),\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path once migration is setup\n        path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"The url for MathJax.js.\"\"\"\n    )\n    def _mathjax_url_default(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\",\n                         url_path_join(self.base_url, \"static\")\n        )\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    def _mathjax_url_changed(self, name, old, new):\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of IPython and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    def _info_file_default(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n    def _pylab_changed(self, name, old, new):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if new != 'warn':\n            backend = ' %s' % new\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    def _notebook_dir_default(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    def _notebook_dir_changed(self, name, old, new):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        if not os.path.isabs(new):\n            # If we receive a non-absolute path, make it absolute.\n            self.notebook_dir = os.path.abspath(new)\n            return\n        if not os.path.isdir(new):\n            raise TraitError(\"No such notebook dir: %r\" % new)\n        \n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    server_extensions = List(Unicode(), config=True,\n        help=(\"Python modules to load as notebook server extensions. \"\n              \"This is an experimental API, and may change in future releases.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n        \n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the profile.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n        \n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # Disable SSLv3, since its use is discouraged.\n            ssl_options['ssl_version']=ssl.PROTOCOL_TLSv1\n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another random port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warn(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        return self._url(ip)\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warn\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        for modulename in self.server_extensions:\n            try:\n                mod = importlib.import_module(modulename)\n                func = getattr(mod, 'load_jupyter_server_extension', None)\n                if func is not None:\n                    func(self)\n            except Exception:\n                if self.reraise_server_extension_failures:\n                    raise\n                self.log.warn(\"Error loading server extension %s\", modulename,\n                              exc_info=True)\n    \n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The IPython Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'pid': os.getpid()\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the IPython Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warn('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_path_join('notebooks', *relpath.split(os.sep))\n            else:\n                uri = 'tree'\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n        \n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.cleanup_kernels()\n            self.remove_server_info_file()\n    \n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)\n\n\ndef list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a profile name, find nbserver-* files in the security directory of\n    that profile, and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(file)\n                except OSError:\n                    pass  # TODO: This should warn or log or something\n#-----------------------------------------------------------------------------\n# Main entry point\n#-----------------------------------------------------------------------------\n\nmain = launch_new_instance = NotebookApp.launch_instance\n\n"], "filenames": ["notebook/notebookapp.py"], "buggy_code_start_loc": [163], "buggy_code_end_loc": [164], "fixing_code_start_loc": [163], "fixing_code_end_loc": [166], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in the file browser in notebook/notebookapp.py in IPython Notebook before 3.2.2 and Jupyter Notebook 4.0.x before 4.0.5 allows remote attackers to inject arbitrary web script or HTML via a folder name.  NOTE: this was originally reported as a cross-site request forgery (CSRF) vulnerability, but this may be inaccurate.", "other": {"cve": {"id": "CVE-2015-6938", "sourceIdentifier": "cve@mitre.org", "published": "2015-09-21T19:59:05.353", "lastModified": "2018-10-30T16:27:37.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in the file browser in notebook/notebookapp.py in IPython Notebook before 3.2.2 and Jupyter Notebook 4.0.x before 4.0.5 allows remote attackers to inject arbitrary web script or HTML via a folder name.  NOTE: this was originally reported as a cross-site request forgery (CSRF) vulnerability, but this may be inaccurate."}, {"lang": "es", "value": "Vulnerabilidad de XSS en el buscador de archivos en notebook/notebookapp.py en IPython Notebook en versiones anteriores a 3.2.2 y Jupyter Notebook 4.0.x en versiones anteriores a 4.0.5, permite a atacantes remotos inyectar secuencias de comandos web o HTML arbitrarios a trav\u00e9s del nombre de una carpeta. NOTA: esta vulnerabilidad fue inicialmente reportada como (CSRF), pero esto puede ser incorrecto."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:notebook:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "320F3B3D-9D14-4CD2-87F7-FE9096E1B85A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:notebook:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "D41485D7-0A64-40CC-A784-3A2182CE830D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:notebook:4.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "FF025212-0295-4746-8506-7F287DE65D11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:notebook:4.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "16AA87BF-6CC1-48D3-AB8E-A73E8EFD1D1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:notebook:4.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "6ADC5C96-5B64-47C8-A5B2-879F9E9BE2DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ipython:notebook:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.1", "matchCriteriaId": "FD264874-41FF-4357-82DF-0BB77DD3E1C1"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-September/166460.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-September/166471.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-September/167670.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2015-10/msg00016.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2015/q3/474", "source": "cve@mitre.org"}, {"url": "http://seclists.org/oss-sec/2015/q3/544", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1259405", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/ipython/ipython/commit/3ab41641cf6fce3860c73d5cf4645aa12e1e5892", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/jupyter/notebook/commit/35f32dd2da804d108a3a3585b69ec3295b2677ed", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/jupyter/notebook/commit/dd9876381f0ef09873d8c5f6f2063269172331e3", "source": "cve@mitre.org", "tags": ["Patch", "Issue Tracking"]}]}, "github_commit_url": "https://github.com/jupyter/notebook/commit/dd9876381f0ef09873d8c5f6f2063269172331e3"}}