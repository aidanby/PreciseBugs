{"buggy_code": ["# fastbots\nA simple library for fast bot and scraper development using selenium and the POM (Page Object Model) design.\nIncrease your productivity, focusing only one the scraping, less boilerplate code and don't require directly driver managment related code, with browser independent settings.\nIf the site locators changes, this don't require changes in the code, only in the configuration.\n\n## Installation:\nThe installation is a simple process with pip on the\nPyPy repository.\n```bash\npip install fastbots\n```\n\n## Showcase:\nCheck out the full example at the repo: [cookiecutter-fastbots](https://github.com/ubertidavide/cookiecutter-fastbots).\n\n### Main Code\nAll the main code example:\n```python\n-- main.py\nimport logging\n\nfrom fastbots import Task, Bot, Page, EC, WebElement, Keys\n\n\nclass ProductPage(Page):\n\n    # page name it's the page_name used in the locators file, see below\n    def __init__(self, bot: Bot, page_name: str = 'product_page'): \n        super().__init__(bot, page_name)\n\n    def forward(self) -> None:\n        logging.info('DO THINGS')\n\n        # using the locators specified in the file give more flexibility and less code changes\n        name_element: WebElement = self.bot.wait.until(EC.element_to_be_clickable(self.__locator__('name_locator')))\n        # store data in the payload section, useful when i need to retrieve data on success\n        self.bot.payload['result'] = name_element.text\n\n        # end the chain of pages interactins\n        return None\n\nclass SearchPage(Page):\n\n    # page name it's the page_name used in the locators file, see below\n    def __init__(self, bot: Bot, page_name: str = 'search_page'):\n        super().__init__(bot, page_name)\n\n    def forward(self) -> ProductPage:\n        logging.info('DO THINGS')\n\n        # using the locators specified in the file give more flexibility and less code changes\n        search_element: WebElement = self.bot.wait.until(EC.element_to_be_clickable(self.__locator__('search_locator')))\n        search_element.send_keys('Selenium with Python Simplified For Beginners')\n        search_element.send_keys(Keys.ENTER)\n\n        # product_element: WebElement = self.bot.driver.find_element(*self.__locator__('product_locator'))\n        product_element: WebElement = self.bot.wait.until(EC.element_to_be_clickable(self.__locator__('product_locator')))\n        product_element.click()\n\n        # continue the chain interaction in the next page\n        return ProductPage(bot=self.bot)\n\nclass TestTask(Task):\n\n    # main task code\n    def run(self, bot: Bot) -> bool:\n        logging.info('DO THINGS')\n\n        # open the search page do things and go forward\n        page: Page = SearchPage(bot=bot).forward()\n\n        # for every page founded do things and go forward\n        while page:\n            page = page.forward()\n\n        # for default it will succeed\n        return True\n\n    # method executed on bot success, with it's payload\n    def on_success(self, payload):\n        logging.info(f'SUCCESS {payload}')\n    \n    # method executed on bot failure\n    def on_failure(self, payload):\n        logging.info(f'FAILED {payload}')\n        \nif __name__ == '__main__':\n    # start the above task\n    TestTask()()\n```\n\n### Locators File\nIn the locators configuration file there is all the required locators config.\nThis could be changed easily without rebuild or make modifications at the code.\n```ini\n-- locators.ini\n[pages_url] # pages_url required url settings\nstart_url=https://www.amazon.com/ #start_url it's the first page driver.get()\nsearch_page=https://www.amazon.com/ #*_page it's the first page url used for the page_name parameter with it's url that need to match\nproduct_page=https://www.amazon.com/s?k=Selenium+with+Python#*_page it's the second page url used for the page_name parameter with it's url that need to match\n\n[search_page] #*_page first page_name parameter, with it's related locators\nsearch_locator=(By.ID, \"twotabsearchtextbox\")\nproduct_locator=(By.XPATH, '//*[@id=\"search\"]/div[1]/div[1]/div/span[1]/div[1]/div[2]')\n\n[product_page]#*_page second page_name parameter, with it's related locators\nname_locator=(By.ID, \"title\")\n```\n\n### Browser and Drivers (Optional)\nFor default config, the selected browser is Firefox, but it could be changed from the config file:\n```ini\n-- settings.ini\n[settings]\n#BOT_DRIVER_TYPE=FIREFOX\nBOT_DRIVER_TYPE=CHROME\n```\n**The correct browser installed for the driver selected it's required.**\nThe browser installation path is autodetected by system env variables, the driver download process and it's related installation path settings are managed automatically.\n\n### Retry and Debug (Optional)\nFor default every task will be retryed 2 times waiting 10 seconds, when all the two try fail, the task execute the on_error method else it will execute the on_success method.\nThis behaviour could be modified in the settings file:\n```ini\n-- settings.ini\n[settings]\nBOT_MAX_RETRIES=2 #sec default\nBOT_RETRY_DELAY=10 #sec default\n```\nWhen the task is failed the library store the screenshot and the html of the page in the debug folder, useful for debug.\nIt will store also all the logs in the log.log file.\n\n### Download Folder and other Folders (Optional)\n```ini\n-- settings.ini\n[settings]\nBOT_DOWNLOAD_FOLDER_PATH='/usr/...' #override the default download path used for the browser\nBOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH='/debug' # default\nBOT_HTML_DOWNLOAD_FOLDER_PATH='/debug'\n```\n\n### Global Wait (Optional)\nThe default configured wait are showed below:\n- The implicit wait used for inital page loading.\n- The wait for the url check that matches the specified in the locators file\n- The default wait used by the self.bot.wait function\n```ini\n-- settings.ini\n[settings]\nSELENIUM_GLOBAL_IMPLICIT_WAIT=5 #sec default\nSELENIUM_EXPECTED_URL_TIMEOUT=5 #sec default\nSELENIUM_DEFAULT_WAIT=5 #sec default\n\nSELENIUM_EXPECTED_URL_CHECK=False #disable the automatic page url check, the default value it's True\n```\n\n### Proxy (Optional)\nConfigure the proxy settings.\n```ini\n-- settings.ini\n[settings]\nBOT_PROXY_ENABLED=True\nBOT_HTTP_PROXY=127.0.0.1:8080\nBOT_HTTPS_PROXY=127.0.0.1:8080\n```\n\n### User Agent (Optional)\nConfigure the user agent used for the requests.\n```ini\n-- settings.ini\n[settings]\nBOT_USER_AGENT=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36\"\n```\n\n### Arguments (Optional)\nConfigure Firefox Arguments, store them in the config file, the format it's the same for all the supported drivers, check carefully that the exact arg it's implemented for the selected driver.\n\n#### Firefox args:\n```ini\n-- settings.ini\n[settings]\nBOT_ARGUMENTS=[\"--headless\", \"--disable-gpu\"]\n```\n\n#### Chrome args\n```ini\n-- settings.ini\n[settings]\nBOT_ARGUMENTS=[\"--no-sandbox\"]\n```\n\n### Store Preferences (Optional)\nStore preferences in a json file, the format it's the same for all the supported drivers, check carefully that the exact string and value it's implemented for the selected driver.\n\n#### Firefox prefs:\n```json\n-- preferences.json \n{\n    \"browser.download.manager.showWhenStarting\": false, # Don't show download\n    \"browser.helperApps.neverAsk.saveToDisk\": \"application/pdf\" # Automatic save pdf files\n}\n```\n\n#### Chrome prefs:\n```json\n-- preferences.json \n{\n    \"profile.default_content_setting_values.notifications\": 2,  # Disable notifications\n    \"profile.default_content_settings.popups\": 0  # Allow popups\n}\n```", "import tempfile\nimport shutil\nimport pickle\nfrom typing import List, Union\nfrom pathlib import Path\nfrom datetime import datetime\nfrom configparser import ConfigParser\nimport logging\nfrom typing import Type\nfrom abc import ABC, abstractmethod\n\nfrom selenium.webdriver.firefox.options import Options as FirefoxOptions\nfrom selenium.webdriver.chrome.options import Options as ChromeOptions\nfrom selenium.webdriver.firefox.firefox_profile import FirefoxProfile\nfrom selenium.webdriver.support.wait import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import TimeoutException\nfrom selenium.webdriver.remote.webdriver import WebDriver\n\nfrom fastbots import config\nfrom fastbots.exceptions import ExpectedUrlError\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Bot(ABC):\n    \"\"\"\n    Bot\n\n    Class used to specify a bot blueprint.\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Bot\n\n        Initialize all the attributes of the Bot instance\n        \"\"\"\n        super().__init__()\n\n        # use a temporary directory as default download folder\n        if config.BOT_DOWNLOAD_FOLDER_PATH != 'None':\n            self._temp_dir: str = tempfile.mkdtemp(dir=config.BOT_DOWNLOAD_FOLDER_PATH)\n        else:\n            self._temp_dir: str = tempfile.mkdtemp()\n\n        # load all the locators\n        self._locators: ConfigParser = self.__load_locators__()\n        # data store\n        self._payload: dict = {}\n\n    @property\n    def driver(self) -> WebDriver:\n        \"\"\"\n        Driver Getter\n        \"\"\"\n        return self._driver\n    \n    @property\n    def wait(self) -> WebDriverWait:\n        \"\"\"\n        Wait Getter\n        \"\"\"\n        return self._wait\n    \n    @property\n    def payload(self) -> dict:\n        \"\"\"\n        Payload Getter\n        \"\"\"\n        return self._payload\n\n    def __enter__(self) -> Type['Bot']:\n        \"\"\"\n        Enter\n\n        Load and configure all the needed resources.\n        \"\"\"\n        # default global driver settings\n        self._driver.implicitly_wait(config.SELENIUM_GLOBAL_IMPLICIT_WAIT)\n\n        # load the start page\n        self._driver.get(self.locator('pages_url', 'start_url'))\n\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        \"\"\"\n        Exit\n        \n        Clean all the used resources.\n        \"\"\"\n        shutil.rmtree(self._temp_dir)\n        self._driver.close()\n\n    def check_page_url(self, expected_page_url: str):\n        \"\"\"\n        Check Page Url\n\n        Check that the browser it't at the expected page.\n        \"\"\"\n        try:\n            # polling that the page url is the expected\n            WebDriverWait(driver=self._driver, timeout=config.SELENIUM_EXPECTED_URL_TIMEOUT, poll_frequency=1).until(\n                EC.url_to_be(expected_page_url)\n            )\n\n        except TimeoutException as te:\n            # if not the expected url raises an exception\n            raise ExpectedUrlError(current_url=self._driver.current_url, expected_url=expected_page_url)\n\n    def locator(self, page_name: str, locator_name: str) -> str:\n        \"\"\"\n        Locator\n\n        Getter that get the locator used for a page locator\n        \"\"\"\n        if not self._locators.has_section(page_name):\n            raise ValueError(f'The specified page_name: {page_name} is not declared in locators config.')\n        if not self._locators.has_option(page_name, locator_name):\n            raise ValueError(f'The specified locator_name: {locator_name} is not declared in locators config.')\n        return self._locators.get(page_name, locator_name)\n        \n    def save_screenshot(self):\n        \"\"\"\n        Save Screenshot\n\n        Save the browser's screenshot to a png file, the path could be specified in the settings.\n        \"\"\"\n        if not Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH).exists():\n            Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH).mkdir(exist_ok=True, parents=True)\n\n        file_path: Path = Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH) / f'{datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")}.png'\n        self._driver.save_screenshot(str(file_path.absolute()))\n\n    def save_html(self):\n        \"\"\"\n        Save Html\n\n        Save the browser's html page to a file, the path could be specified in the settings.\n        \"\"\"\n        if not Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH).exists():\n            Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH).mkdir(exist_ok=True, parents=True)\n\n        file_path: Path = Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH) / f'{datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")}.html'\n        with open(str(file_path.absolute()), \"w\", encoding=\"utf-8\") as file:\n            file.write(self._driver.page_source)\n\n    def save_cookies(self):\n        \"\"\"\n        Save Cookies\n\n        Save all the cookies founded in the file.\n        \"\"\"\n        cookies: List[dict] = self._driver.get_cookies()\n\n        with open(config.BOT_COOKIES_FILE_PATH, 'wb') as file:\n            pickle.dump(cookies, file)\n    \n    def load_cookies(self):\n        \"\"\"\n        Load Cookies\n\n        Add all the cookies founded in the file.\n        \"\"\"\n        if Path(config.BOT_COOKIES_FILE_PATH).is_file():\n            with open(config.BOT_COOKIES_FILE_PATH, 'rb') as file:\n                cookies = pickle.load(file)\n\n                for cookie in cookies:\n                    self._driver.add_cookie(cookie)\n\n    def __load_locators__(self) -> ConfigParser:\n        \"\"\"\n        Load Locators\n\n        Load a file that contains all the locators\n        \"\"\"\n        if not Path(config.SELENIUM_LOCATORS_FILE).is_file():\n            return ValueError(f'Erorr, locators file not founded at path: {config.SELENIUM_LOCATORS_FILE}')\n        \n        config_parser: ConfigParser = ConfigParser()\n        config_parser.read(config.SELENIUM_LOCATORS_FILE)\n        return config_parser\n\n    @abstractmethod\n    def __load_preferences__(self) -> Union[FirefoxProfile, dict]:\n        \"\"\"\n        Load Preferences\n\n        Load all the preferences stored in a json file,\n        specified in the config.\n        \"\"\"\n        return NotImplementedError('Bot must define this method.')\n\n    @abstractmethod\n    def __load_options__(self) -> Union[FirefoxOptions, ChromeOptions]:\n        \"\"\"\n        Load Options\n\n        Load all the default options\n        \"\"\"\n        return NotImplementedError('Bot must define this method.')\n    \n    @abstractmethod\n    def __load_driver__(self) -> WebDriver:\n        \"\"\"\n        Load Driver\n\n        Load and configure all the options for the driver.\n        \"\"\"\n        return NotImplementedError('Bot must define this method.')", "import logging\nfrom typing import List\nfrom enum import Enum\n\nfrom decouple import config\n\n\nclass DriverType(Enum):\n    FIREFOX = 1\n    CHROME = 2\n\n# static config\nENV_DEVELOPMENT: str = 'development'\nENV_RELEASE: str = 'release'\n\n# dynamic config\n\n# project settings\nLOG_LEVEL: int = config('LOGLEVEL', default=logging.DEBUG, cast=int)\nENV: str = config('ENV', default=ENV_DEVELOPMENT, cast=str)\n\nPROJECT_NAME: str = config('PROJECT_NAME', default='fastbot', cast=str)\nAPP_VERSION: str = config('APP_VERSION', default='0.1.0', cast=str)\n\n# firefox settings\nBOT_DRIVER_TYPE: DriverType = config('BOT_DRIVER_TYPE', default=DriverType.FIREFOX, cast=DriverType)\nBOT_DOWNLOAD_FOLDER_PATH: str = config('BOT_DOWNLOAD_FOLDER_PATH', default=None, cast=str)\n\n# comma separated list of arguments (ex: --headless, --disable-gui)\nBOT_ARGUMENTS: List[str] = config('BOT_ARGUMENTS', default=[])\n\nBOT_USER_AGENT: str = config('BOT_USER_AGENT', default=f'{PROJECT_NAME} {APP_VERSION}', cast=str)\n\nBOT_PROXY_ENABLED: bool = config('BOT_PROXY_ENABLED', default=False, cast=bool)\nBOT_HTTP_PROXY: str = config('BOT_HTTP_PROXY', default=None, cast=str)\nBOT_HTTPS_PROXY: str = config('BOT_HTTPS_PROXY', default=BOT_HTTP_PROXY, cast=str)\n\nBOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH: str = config('BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH', default='debug/', cast=str)\nBOT_HTML_DOWNLOAD_FOLDER_PATH: str = config('BOT_HTML_DOWNLOAD_FOLDER_PATH', default='debug/', cast=str)\nBOT_COOKIES_FILE_PATH: str = config('BOT_COOKIES_FILE_PATH', default='cookies.pkl', cast=str)\n\nBOT_PREFERENCES_FILE_PATH: str = config('BOT_PREFERENCES_FILE_PATH', default='preferences.json', cast=str)\n\nBOT_MAX_RETRIES: int = config('BOT_MAX_RETRIES', default=2, cast=int)\nBOT_RETRY_DELAY: int = config('BOT_RETRY_DELAY', default=10, cast=int)\n\n# selenium\nSELENIUM_GLOBAL_IMPLICIT_WAIT: int = config('SELENIUM_GLOBAL_IMPLICIT_WAIT', default=5, cast=int)\nSELENIUM_EXPECTED_URL_CHECK: bool = config('SELENIUM_EXPECTED_URL_CHECK', default=True, cast=bool)\nSELENIUM_EXPECTED_URL_TIMEOUT: int = config('SELENIUM_EXPECTED_URL_TIMEOUT', default=5, cast=int)\nSELENIUM_DEFAULT_WAIT: int = config('SELENIUM_DEFAULT_WAIT', default=5, cast=int)\nSELENIUM_LOCATORS_FILE: str = config('SELENIUM_LOCATORS_FILE', default='locators.ini', cast=str)", "class GenericError(Exception):\n    \"\"\" Generic Error \"\"\"\n    \n    def __init__(self, message: str = 'Generic Error') -> None:\n        self.message: str = message\n        super().__init__(self.message)\n\n    def __str__(self) -> str:\n        return self.message\n\nclass ExpectedUrlError(GenericError):\n    \"\"\" \n    Expected Url Error\n\n    Happen when the current url is not the expected. \n    \"\"\"\n    \n    def __init__(self, current_url: str, expected_url: str) -> None:\n        self.current_url: str = current_url\n        self.expected_url: str = expected_url\n        self.message: str = f'The current url: {self.current_url} of the browser is not the expected: {self.expected_url}'\n        super().__init__(self.message)\n\n    def __str__(self) -> str:\n        return self.message\n", "import logging\nfrom abc import ABC, abstractmethod\nfrom typing import Type, Union\n\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.remote.webelement import WebElement\n\nfrom fastbots.bot import Bot\nfrom fastbots import config\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Page(ABC):\n    \"\"\"\n    Page\n\n    A web page blueprint used to forward pages and\n    make a series of actions on it.\n    \"\"\"\n\n    def __init__(self, bot: Bot, page_name: str = 'page_name'):\n        \"\"\"\n        Initialize the page class.\n\n        In the locators file must be declared the page in the below format:\n\n        [pages_url]\n        page_name=https://example.com/page\n        \"\"\"\n        super().__init__()\n\n        self._bot: Bot = bot\n        self._page_name: str = page_name\n        \n        # load the pages url from the locators file\n        self._page_url: str = self._bot.locator('pages_url', self._page_name)\n\n        # check that the current page is the expected\n        if config.SELENIUM_EXPECTED_URL_CHECK and self._page_url != 'None':\n            self._bot.check_page_url(expected_page_url=self._page_url)\n\n    @property\n    def bot(self):\n        return self._bot\n\n    def __locator__(self, locator_name: str) -> tuple:\n        \"\"\"\n        Locator\n\n        Utility used to load the locator.\n\n        The locators in the file must be in the below format:\n\n        [page_name]\n        locator_name=(By.XPATH, \"//html//input\")\n\n        \"\"\"\n        # load the locators from file and interprete that as code\n        return eval(self._bot.locator(self._page_name, locator_name))\n\n    @abstractmethod\n    def forward(self) -> Union[Type['Page'], None]:\n        \"\"\"\n        Forward\n\n        This method represents a series of action in one page,\n        in order to pass on another page or when the task it's done\n        it will return None, in order to finish.\n        \"\"\"\n        raise NotImplementedError('Tasks must define this method.')", "[tool.poetry]\nname = \"fastbots\"\nversion = \"0.1.3\"\ndescription = \"A simple library for bot development using selenium and the POM (Page Object Model) design.\"\nauthors = [\"Uberti Davide <24529587+ubertidavide@users.noreply.github.com>\"]\nlicense = \"LICENSE\"\nreadme = \"README.md\"\n\n[tool.poetry.dependencies]\npython = \"^3.11\"\nselenium = \"^4.15.2\"\npython-decouple = \"^3.8\"\ntenacity = \"^8.2.3\"\nselenium-wire = \"^5.1.0\"\n\n[tool.poetry.group.dev.dependencies]\nsetuptools = \"^68.2.2\"\npytest = \"^7.4.3\"\npytest-mock = \"^3.12.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n"], "fixing_code": ["# fastbots\nA simple library for fast bot and scraper development using selenium and the POM (Page Object Model) design.\nIncrease your productivity, focusing only one the scraping, less boilerplate code and don't require directly driver managment related code, with browser independent settings.\nIf the site locators changes, this don't require changes in the code, only in the configuration.\n\n## Installation:\nThe installation is a simple process with pip on the\nPyPy repository.\n```bash\npip install fastbots\n```\n\n## Showcase:\nCheck out the full example at the repo: [cookiecutter-fastbots](https://github.com/ubertidavide/cookiecutter-fastbots).\n\n### Main Code\nAll the main code example:\n```python\n-- main.py\nimport logging\n\nfrom fastbots import Task, Bot, Page, EC, WebElement, Keys\n\n\nclass ProductPage(Page):\n\n    # page name it's the page_name used in the locators file, see below\n    def __init__(self, bot: Bot, page_name: str = 'product_page'): \n        super().__init__(bot, page_name)\n\n    def forward(self) -> None:\n        logging.info('DO THINGS')\n\n        # using the locators specified in the file give more flexibility and less code changes\n        name_element: WebElement = self.bot.wait.until(EC.element_to_be_clickable(self.__locator__('name_locator')))\n        # store data in the payload section, useful when i need to retrieve data on success\n        self.bot.payload['result'] = name_element.text\n\n        # end the chain of pages interactins\n        return None\n\nclass SearchPage(Page):\n\n    # page name it's the page_name used in the locators file, see below\n    def __init__(self, bot: Bot, page_name: str = 'search_page'):\n        super().__init__(bot, page_name)\n\n    def forward(self) -> ProductPage:\n        logging.info('DO THINGS')\n\n        # using the locators specified in the file give more flexibility and less code changes\n        search_element: WebElement = self.bot.wait.until(EC.element_to_be_clickable(self.__locator__('search_locator')))\n        search_element.send_keys('Selenium with Python Simplified For Beginners')\n        search_element.send_keys(Keys.ENTER)\n\n        # product_element: WebElement = self.bot.driver.find_element(*self.__locator__('product_locator'))\n        product_element: WebElement = self.bot.wait.until(EC.element_to_be_clickable(self.__locator__('product_locator')))\n        product_element.click()\n\n        # continue the chain interaction in the next page\n        return ProductPage(bot=self.bot)\n\nclass TestTask(Task):\n\n    # main task code\n    def run(self, bot: Bot) -> bool:\n        logging.info('DO THINGS')\n\n        # open the search page do things and go forward\n        page: Page = SearchPage(bot=bot).forward()\n\n        # for every page founded do things and go forward\n        while page:\n            page = page.forward()\n\n        # for default it will succeed\n        return True\n\n    # method executed on bot success, with it's payload\n    def on_success(self, payload):\n        logging.info(f'SUCCESS {payload}')\n    \n    # method executed on bot failure\n    def on_failure(self, payload):\n        logging.info(f'FAILED {payload}')\n        \nif __name__ == '__main__':\n    # start the above task\n    TestTask()()\n```\n\n### Locators File\nIn the locators configuration file there is all the required locators config.\nThis could be changed easily without rebuild or make modifications at the code.\n```ini\n-- locators.ini\n[pages_url] # pages_url required url settings\nstart_url=https://www.amazon.com/ #start_url it's the first page driver.get()\nsearch_page=https://www.amazon.com/ #*_page it's the first page url used for the page_name parameter with it's url that need to match\nproduct_page=https://www.amazon.com/s?k=Selenium+with+Python#*_page it's the second page url used for the page_name parameter with it's url that need to match\n\n[search_page] #*_page first page_name parameter, with it's related locators\nsearch_locator=(By.ID, \"twotabsearchtextbox\")\nproduct_locator=(By.XPATH, '//*[@id=\"search\"]/div[1]/div[1]/div/span[1]/div[1]/div[2]')\n\n[product_page]#*_page second page_name parameter, with it's related locators\nname_locator=(By.ID, \"title\")\n```\n\n### Browser and Drivers (Optional)\nFor default config, the selected browser is Firefox, but it could be changed from the config file:\n```ini\n-- settings.ini\n[settings]\n#BOT_DRIVER_TYPE=FIREFOX\nBOT_DRIVER_TYPE=CHROME\n```\n**The correct browser installed for the driver selected it's required.**\nThe browser installation path is autodetected by system env variables, the driver download process and it's related installation path settings are managed automatically.\n\n### Retry and Debug (Optional)\nFor default every task will be retryed 2 times waiting 10 seconds, when all the two try fail, the task execute the on_error method else it will execute the on_success method.\nThis behaviour could be modified in the settings file:\n```ini\n-- settings.ini\n[settings]\nBOT_MAX_RETRIES=2 #sec default\nBOT_RETRY_DELAY=10 #sec default\n```\nWhen the task is failed the library store the screenshot and the html of the page in the debug folder, useful for debug.\nIt will store also all the logs in the log.log file.\n\n### Page Url Check (Automatic)\nEvery defined page must have a page url and when it's instantiate and reaced by the bot, the library check that the \nspecified url in the config are the same as the reached page during the navigation, to reduce navigation errors.  \nIf you want to disable this function see the Global Wait Section below.\n\n### File Download Wait (Functions)\nThis library have the bot.wait_downloaded_file_path(file_extension, new_name_file=None) method that could be used afer a button download click in order\nto wait and get the path of the downloaded file, it will give the ability also to rename the file.  \nThe extension is used to check that the file downloaded it's the correct and it's not corrupted.\n\n### Download Folder and other Folders (Optional)\n```ini\n-- settings.ini\n[settings]\nBOT_DOWNLOAD_FOLDER_PATH='/usr/...' #override the default download path used for the browser\nBOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH='/debug' # default\nBOT_HTML_DOWNLOAD_FOLDER_PATH='/debug'\n```\n\n### Global Wait (Optional)\nThe default configured wait are showed below:\n- The implicit wait used for inital page loading.\n- The wait for the url check that matches the specified in the locators file\n- The default wait used by the self.bot.wait function\n```ini\n-- settings.ini\n[settings]\nSELENIUM_GLOBAL_IMPLICIT_WAIT=5 #sec default\nSELENIUM_EXPECTED_URL_TIMEOUT=5 #sec default\nSELENIUM_DEFAULT_WAIT=5 #sec default\nSELENIUM_FILE_DOWNLOAD_TIMEOUT=20 #sec default\n\nSELENIUM_EXPECTED_URL_CHECK=False #disable the automatic page url check, the default value it's True\n```\n\n### Proxy (Optional)\nConfigure the proxy settings.\n```ini\n-- settings.ini\n[settings]\nBOT_PROXY_ENABLED=True\nBOT_HTTP_PROXY=127.0.0.1:8080\nBOT_HTTPS_PROXY=127.0.0.1:8080\n```\n\n### User Agent (Optional)\nConfigure the user agent used for the requests.\n```ini\n-- settings.ini\n[settings]\nBOT_USER_AGENT=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36\"\n```\n\n### Arguments (Optional)\nConfigure Firefox Arguments, store them in the config file, the format it's the same for all the supported drivers, check carefully that the exact arg it's implemented for the selected driver.\n\n#### Firefox args:\n```ini\n-- settings.ini\n[settings]\nBOT_ARGUMENTS=[\"--headless\", \"--disable-gpu\"]\n```\n\n#### Chrome args\n```ini\n-- settings.ini\n[settings]\nBOT_ARGUMENTS=[\"--no-sandbox\"]\n```\n\n### Store Preferences (Optional)\nStore preferences in a json file, the format it's the same for all the supported drivers, check carefully that the exact string and value it's implemented for the selected driver.\n\n#### Firefox prefs:\n```json\n-- preferences.json \n{\n    \"browser.download.manager.showWhenStarting\": false, # Don't show download\n    \"browser.helperApps.neverAsk.saveToDisk\": \"application/pdf\" # Automatic save pdf files\n}\n```\n\n#### Chrome prefs:\n```json\n-- preferences.json \n{\n    \"profile.default_content_setting_values.notifications\": 2,  # Disable notifications\n    \"profile.default_content_settings.popups\": 0  # Allow popups\n}\n```", "import tempfile\nimport shutil\nimport pickle\nfrom typing import List, Union\nfrom pathlib import Path\nfrom datetime import datetime\nfrom configparser import ConfigParser\nimport logging\nfrom typing import Type\nfrom abc import ABC, abstractmethod\n\nfrom selenium.webdriver.firefox.options import Options as FirefoxOptions\nfrom selenium.webdriver.chrome.options import Options as ChromeOptions\nfrom selenium.webdriver.firefox.firefox_profile import FirefoxProfile\nfrom selenium.webdriver.support.wait import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import TimeoutException\nfrom selenium.webdriver.remote.webdriver import WebDriver\n\nfrom fastbots import config, logger\nfrom fastbots.exceptions import ExpectedUrlError, DownloadFileError\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Bot(ABC):\n    \"\"\"\n    Bot\n\n    Class used to specify a bot blueprint.\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Bot\n\n        Initialize all the attributes of the Bot instance\n        \"\"\"\n        super().__init__()\n\n        # use a temporary directory as default download folder\n        self._temp_dir: str = tempfile.mkdtemp()\n\n        # official downloaded file folder\n        if config.BOT_DOWNLOAD_FOLDER_PATH != 'None':\n            self._download_dir: str = tempfile.mkdtemp(dir=config.BOT_DOWNLOAD_FOLDER_PATH)\n        else:\n            self._download_dir: str = tempfile.mkdtemp()\n\n        # load all the locators\n        self._locators: ConfigParser = self.__load_locators__()\n        # data store\n        self._payload: dict = {}\n\n    @property\n    def driver(self) -> WebDriver:\n        \"\"\"\n        Driver Getter\n        \"\"\"\n        return self._driver\n    \n    @property\n    def wait(self) -> WebDriverWait:\n        \"\"\"\n        Wait Getter\n        \"\"\"\n        return self._wait\n    \n    @property\n    def payload(self) -> dict:\n        \"\"\"\n        Payload Getter\n        \"\"\"\n        return self._payload\n\n    def __enter__(self) -> Type['Bot']:\n        \"\"\"\n        Enter\n\n        Load and configure all the needed resources.\n        \"\"\"\n        # default global driver settings\n        self._driver.implicitly_wait(config.SELENIUM_GLOBAL_IMPLICIT_WAIT)\n\n        # load the start page\n        self._driver.get(self.locator('pages_url', 'start_url'))\n\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        \"\"\"\n        Exit\n        \n        Clean all the used resources.\n        \"\"\"\n        shutil.rmtree(self._temp_dir)\n        self._driver.close()\n\n    def check_page_url(self, expected_page_url: str):\n        \"\"\"\n        Check Page Url\n\n        Check that the browser it't at the expected page.\n        \"\"\"\n        try:\n            # polling that the page url is the expected\n            WebDriverWait(driver=self._driver, timeout=config.SELENIUM_EXPECTED_URL_TIMEOUT, poll_frequency=1).until(\n                EC.url_to_be(expected_page_url)\n            )\n\n        except TimeoutException as te:\n            # if not the expected url raises an exception\n            raise ExpectedUrlError(current_url=self._driver.current_url, expected_url=expected_page_url)\n\n    def locator(self, page_name: str, locator_name: str) -> str:\n        \"\"\"\n        Locator\n\n        Getter that get the locator used for a page locator\n        \"\"\"\n        if not self._locators.has_section(page_name):\n            raise ValueError(f'The specified page_name: {page_name} is not declared in locators config.')\n        \n        if not self._locators.has_option(page_name, locator_name):\n            raise ValueError(f'The specified locator_name: {locator_name} is not declared in locators config.')\n        \n        return self._locators.get(page_name, locator_name)\n        \n    def wait_downloaded_file_path(self, file_extension: str, new_file_name: str | None = None) -> str:\n        \"\"\"\n        Wait Downloaded File Path\n\n        This method allow to wait for a specific downloaded file to be completely available in the download folder.\n        It uses the file extension in order to wait the full download finish.\n        It will also give the ability to rename the downloaded file.\n\n        The file_extension must be specified without the dot \".\" (ex .png become png)\n        \"\"\"\n        try:\n            # polling that the page url is the expected, it uses the extension because the temp part file cache by browser\n            # usally have a specific extension that isn't the usally of the files\n            WebDriverWait(driver=self._driver, timeout=config.SELENIUM_FILE_DOWNLOAD_TIMEOUT, poll_frequency=1).until(\n                lambda driver: len(list(Path(self._temp_dir).glob(f'*.{file_extension}'))) == 1\n            )\n\n            # get the latest downloaded file\n            latest_file: Path = max(list(Path(self._temp_dir).glob(f'*.{file_extension}')), key=lambda x: x.stat().st_ctime)\n\n            # build the download path based on renamed file or \n            downloaded_file_path: Path = None\n            if new_file_name is None:\n                downloaded_file_path = Path(config.BOT_DOWNLOAD_FOLDER_PATH) / latest_file.name\n            else:\n                downloaded_file_path = Path(config.BOT_DOWNLOAD_FOLDER_PATH) / f'{new_file_name}.{file_extension}'\n                \n            # move to the download folder the file name\n            shutil.move(src=str(latest_file.absolute()), dst=str(downloaded_file_path.absolute()))\n\n            # remove the temporary downloaded file\n            latest_file.unlink()\n\n            # return the path and filename as string\n            return str(downloaded_file_path.absolute())\n\n        except TimeoutException as te:\n            # if not the expected url raises an exception\n            file_count: int = len(list(Path(self._temp_dir).glob(f'*.{file_extension}')))\n\n            # error string based on the specific error\n            if file_count == 0:\n                raise DownloadFileError('File not founded in the download folder, an error with the download occurs.')\n            elif file_count > 1:\n                raise DownloadFileError(f'Too many downloaded files founded, files number : {file_count}.')\n\n            raise DownloadFileError()\n\n    def save_screenshot(self):\n        \"\"\"\n        Save Screenshot\n\n        Save the browser's screenshot to a png file, the path could be specified in the settings.\n        \"\"\"\n        if not Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH).exists():\n            Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH).mkdir(exist_ok=True, parents=True)\n\n        file_path: Path = Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH) / f'{datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")}.png'\n        self._driver.save_screenshot(str(file_path.absolute()))\n\n    def save_html(self):\n        \"\"\"\n        Save Html\n\n        Save the browser's html page to a file, the path could be specified in the settings.\n        \"\"\"\n        if not Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH).exists():\n            Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH).mkdir(exist_ok=True, parents=True)\n\n        file_path: Path = Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH) / f'{datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")}.html'\n        with open(str(file_path.absolute()), \"w\", encoding=\"utf-8\") as file:\n            file.write(self._driver.page_source)\n\n    def save_cookies(self):\n        \"\"\"\n        Save Cookies\n\n        Save all the cookies founded in the file.\n        \"\"\"\n        cookies: List[dict] = self._driver.get_cookies()\n\n        with open(config.BOT_COOKIES_FILE_PATH, 'wb') as file:\n            pickle.dump(cookies, file)\n    \n    def load_cookies(self):\n        \"\"\"\n        Load Cookies\n\n        Add all the cookies founded in the file.\n        \"\"\"\n        if Path(config.BOT_COOKIES_FILE_PATH).is_file():\n            with open(config.BOT_COOKIES_FILE_PATH, 'rb') as file:\n                cookies = pickle.load(file)\n\n                for cookie in cookies:\n                    self._driver.add_cookie(cookie)\n\n    def __load_locators__(self) -> ConfigParser:\n        \"\"\"\n        Load Locators\n\n        Load a file that contains all the locators\n        \"\"\"\n        if not Path(config.SELENIUM_LOCATORS_FILE).is_file():\n            return ValueError(f'Erorr, locators file not founded at path: {config.SELENIUM_LOCATORS_FILE}')\n        \n        config_parser: ConfigParser = ConfigParser()\n        config_parser.read(config.SELENIUM_LOCATORS_FILE)\n        return config_parser\n\n    @abstractmethod\n    def __load_preferences__(self) -> Union[FirefoxProfile, dict]:\n        \"\"\"\n        Load Preferences\n\n        Load all the preferences stored in a json file,\n        specified in the config.\n        \"\"\"\n        return NotImplementedError('Bot must define this method.')\n\n    @abstractmethod\n    def __load_options__(self) -> Union[FirefoxOptions, ChromeOptions]:\n        \"\"\"\n        Load Options\n\n        Load all the default options\n        \"\"\"\n        return NotImplementedError('Bot must define this method.')\n    \n    @abstractmethod\n    def __load_driver__(self) -> WebDriver:\n        \"\"\"\n        Load Driver\n\n        Load and configure all the options for the driver.\n        \"\"\"\n        return NotImplementedError('Bot must define this method.')", "import logging\nfrom typing import List\nfrom enum import Enum\n\nfrom decouple import config\n\n\nclass DriverType(Enum):\n    FIREFOX = 1\n    CHROME = 2\n\n# static config\nENV_DEVELOPMENT: str = 'development'\nENV_RELEASE: str = 'release'\n\n# dynamic config\n\n# project settings\nLOG_LEVEL: int = config('LOGLEVEL', default=logging.DEBUG, cast=int)\nENV: str = config('ENV', default=ENV_DEVELOPMENT, cast=str)\n\nPROJECT_NAME: str = config('PROJECT_NAME', default='fastbot', cast=str)\nAPP_VERSION: str = config('APP_VERSION', default='0.1.0', cast=str)\n\n# firefox settings\nBOT_DRIVER_TYPE: DriverType = config('BOT_DRIVER_TYPE', default=DriverType.FIREFOX, cast=DriverType)\nBOT_DOWNLOAD_FOLDER_PATH: str = config('BOT_DOWNLOAD_FOLDER_PATH', default=None, cast=str)\n\n# comma separated list of arguments (ex: --headless, --disable-gui)\nBOT_ARGUMENTS: List[str] = config('BOT_ARGUMENTS', default=[])\n\nBOT_USER_AGENT: str = config('BOT_USER_AGENT', default=f'{PROJECT_NAME} {APP_VERSION}', cast=str)\n\nBOT_PROXY_ENABLED: bool = config('BOT_PROXY_ENABLED', default=False, cast=bool)\nBOT_HTTP_PROXY: str = config('BOT_HTTP_PROXY', default=None, cast=str)\nBOT_HTTPS_PROXY: str = config('BOT_HTTPS_PROXY', default=BOT_HTTP_PROXY, cast=str)\n\nBOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH: str = config('BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH', default='debug/', cast=str)\nBOT_HTML_DOWNLOAD_FOLDER_PATH: str = config('BOT_HTML_DOWNLOAD_FOLDER_PATH', default='debug/', cast=str)\nBOT_COOKIES_FILE_PATH: str = config('BOT_COOKIES_FILE_PATH', default='cookies.pkl', cast=str)\n\nBOT_PREFERENCES_FILE_PATH: str = config('BOT_PREFERENCES_FILE_PATH', default='preferences.json', cast=str)\n\nBOT_MAX_RETRIES: int = config('BOT_MAX_RETRIES', default=2, cast=int)\nBOT_RETRY_DELAY: int = config('BOT_RETRY_DELAY', default=10, cast=int)\n\n# selenium\nSELENIUM_GLOBAL_IMPLICIT_WAIT: int = config('SELENIUM_GLOBAL_IMPLICIT_WAIT', default=5, cast=int)\nSELENIUM_EXPECTED_URL_CHECK: bool = config('SELENIUM_EXPECTED_URL_CHECK', default=True, cast=bool)\nSELENIUM_EXPECTED_URL_TIMEOUT: int = config('SELENIUM_EXPECTED_URL_TIMEOUT', default=5, cast=int)\nSELENIUM_DEFAULT_WAIT: int = config('SELENIUM_DEFAULT_WAIT', default=5, cast=int)\nSELENIUM_FILE_DOWNLOAD_TIMEOUT: int = config('SELENIUM_FILE_DOWNLOAD_TIMEOUT', default=20, cast=int)\nSELENIUM_LOCATORS_FILE: str = config('SELENIUM_LOCATORS_FILE', default='locators.ini', cast=str)", "class GenericError(Exception):\n    \"\"\" Generic Error \"\"\"\n    \n    def __init__(self, message: str = 'Generic Error') -> None:\n        self.message: str = message\n        super().__init__(self.message)\n\n    def __str__(self) -> str:\n        return self.message\n\nclass ExpectedUrlError(GenericError):\n    \"\"\" \n    Expected Url Error\n\n    Happen when the current url is not the expected. \n    \"\"\"\n    \n    def __init__(self, current_url: str, expected_url: str) -> None:\n        self.current_url: str = current_url\n        self.expected_url: str = expected_url\n        self.message: str = f'The current url: {self.current_url} of the browser is not the expected: {self.expected_url}'\n        super().__init__(self.message)\n\n    def __str__(self) -> str:\n        return self.message\n    \nclass DownloadFileError(GenericError):\n    \"\"\"\n    Download File Error\n\n    Happen when an error occurs in the downloading process.\n    \"\"\"\n\n    def __init__(self, message: str = 'Download File Error') -> None:\n        self.message: str = message\n        super().__init__(self.message)\n\n    def __str__(self) -> str:\n        return self.message\n", "import logging\nfrom abc import ABC, abstractmethod\nfrom typing import Type, Union, Dict\n\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.remote.webelement import WebElement\n\nfrom fastbots.bot import Bot\nfrom fastbots import config\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Page(ABC):\n    \"\"\"\n    Page\n\n    A web page blueprint used to forward pages and\n    make a series of actions on it.\n    \"\"\"\n\n    def __init__(self, bot: Bot, page_name: str = 'page_name'):\n        \"\"\"\n        Initialize the page class.\n\n        In the locators file must be declared the page in the below format:\n\n        [pages_url]\n        page_name=https://example.com/page\n        \"\"\"\n        super().__init__()\n\n        self._bot: Bot = bot\n        self._page_name: str = page_name\n        \n        # load the pages url from the locators file\n        self._page_url: str = self._bot.locator('pages_url', self._page_name)\n\n        # check that the current page is the expected\n        if config.SELENIUM_EXPECTED_URL_CHECK and self._page_url != 'None':\n            self._bot.check_page_url(expected_page_url=self._page_url)\n\n    @property\n    def bot(self):\n        return self._bot\n\n    def __locator__(self, locator_name: str) -> tuple:\n        \"\"\"\n        Locator\n\n        Utility used to load the locator.\n\n        The locators in the file must be in the below format:\n\n        [page_name]\n        locator_name=(By.XPATH, \"//html//input\")\n\n        \"\"\"\n        # load the locators from file and interprete that as code\n        full_locator: str = self._bot.locator(self._page_name, locator_name)\n\n        if not full_locator.startswith('(') or not full_locator.endswith(')'):\n            raise ValueError('The locator must be enclosed in round brackets.')\n\n        # declared locators\n        locator_list: Dict[str, By] = ['By.ID', 'By.XPATH', 'By.NAME', 'By.CLASS_NAME', 'By.CSS_SELECTOR', \n                                       'By.LINK_TEXT', 'By.PARTIAL_LINK_TEXT', 'By.TAG_NAME']\n\n        # check the used locator\n        parsed_locator: tuple = None\n        for locator in locator_list:\n            # check that the first characters are them of the locators and the next one of the comma \n            if full_locator[1:-1].strip().startswith(locator) and full_locator[1:-1].strip()[len(locator):].strip().startswith(','):\n                # extract the tuple required as locator\n                parsed_locator = (eval(locator), full_locator[1:-1].strip()[len(locator):].strip()[1:].strip()[1:-1])\n\n                logging.info(f'{parsed_locator}')\n\n                return parsed_locator\n            \n        else:\n            raise ValueError('The specified locator is unknown or worng, check by, brackets and commas.')\n\n    @abstractmethod\n    def forward(self) -> Union[Type['Page'], None]:\n        \"\"\"\n        Forward\n\n        This method represents a series of action in one page,\n        in order to pass on another page or when the task it's done\n        it will return None, in order to finish.\n        \"\"\"\n        raise NotImplementedError('Tasks must define this method.')", "[tool.poetry]\nname = \"fastbots\"\nversion = \"0.1.4\"\ndescription = \"A simple library for fast bot and scraper development using selenium and the POM (Page Object Model) design.\"\nauthors = [\"Uberti Davide <24529587+ubertidavide@users.noreply.github.com>\"]\nlicense = \"LICENSE\"\nreadme = \"README.md\"\n\n[tool.poetry.dependencies]\npython = \"^3.11\"\nselenium = \"^4.15.2\"\npython-decouple = \"^3.8\"\ntenacity = \"^8.2.3\"\nselenium-wire = \"^5.1.0\"\n\n[tool.poetry.group.dev.dependencies]\nsetuptools = \"^68.2.2\"\npytest = \"^7.4.3\"\npytest-mock = \"^3.12.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n"], "filenames": ["README.md", "fastbots/bot.py", "fastbots/config.py", "fastbots/exceptions.py", "fastbots/page.py", "pyproject.toml"], "buggy_code_start_loc": [132, 20, 51, 25, 3, 3], "buggy_code_end_loc": [152, 124, 51, 25, 62, 5], "fixing_code_start_loc": [133, 20, 52, 26, 3, 3], "fixing_code_end_loc": [164, 178, 53, 40, 84, 5], "type": "CWE-94", "message": "fastbots is a library for fast bot and scraper development using selenium and the Page Object Model (POM) design. Prior to version 0.1.5, an attacker could modify the locators.ini locator file with python code that without proper validation it's executed and it could lead to rce. The vulnerability is in the function `def __locator__(self, locator_name: str)` in `page.py`. In order to mitigate this issue, upgrade to fastbots version 0.1.5 or above.", "other": {"cve": {"id": "CVE-2023-48699", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-21T23:15:08.103", "lastModified": "2023-11-30T15:15:03.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fastbots is a library for fast bot and scraper development using selenium and the Page Object Model (POM) design. Prior to version 0.1.5, an attacker could modify the locators.ini locator file with python code that without proper validation it's executed and it could lead to rce. The vulnerability is in the function `def __locator__(self, locator_name: str)` in `page.py`. In order to mitigate this issue, upgrade to fastbots version 0.1.5 or above."}, {"lang": "es", "value": "fastbots es una librer\u00eda para el desarrollo r\u00e1pido de robots y raspadores utilizando selenio y el dise\u00f1o de Page Object Model (POM). Antes de la versi\u00f3n 0.1.5, un atacante pod\u00eda modificar el archivo localizador locators.ini con c\u00f3digo Python que sin la validaci\u00f3n adecuada se ejecutaba y podr\u00eda provocar rce. La vulnerabilidad est\u00e1 en la funci\u00f3n `def __locator__(self, locator_name: str)` en `page.py`. Para mitigar este problema, actualice a la versi\u00f3n 0.1.5 o superior de fastbots."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-95"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ubertidavide:fastbots:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.5", "matchCriteriaId": "F4D23CDD-ACB2-427B-BC2C-1F98D79FE70C"}]}]}], "references": [{"url": "https://github.com/ubertidavide/fastbots/commit/73eb03bd75365e112b39877e26ef52853f5e9f57", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ubertidavide/fastbots/pull/3#issue-2003080806", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ubertidavide/fastbots/security/advisories/GHSA-vccg-f4gp-45x9", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ubertidavide/fastbots/commit/73eb03bd75365e112b39877e26ef52853f5e9f57"}}