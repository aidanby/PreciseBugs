{"buggy_code": ["PATH\n  remote: .\n  specs:\n    gemirro (0.14.0)\n      builder (~> 3.2)\n      confstruct (~> 1.0)\n      erubis (~> 2.7)\n      httpclient (~> 2.8)\n      parallel (~> 1.12)\n      sinatra (~> 2.0)\n      slop (~> 3.6)\n      thin (~> 1.7)\n\nGEM\n  remote: https://rubygems.org/\n  specs:\n    ast (2.3.0)\n    builder (3.2.3)\n    confstruct (1.0.2)\n      hashie (~> 3.3)\n    daemons (1.2.5)\n    diff-lcs (1.3)\n    docile (1.1.5)\n    erubis (2.7.0)\n    eventmachine (1.2.5)\n    fakefs (0.11.3)\n    hashie (3.5.6)\n    httpclient (2.8.3)\n    json (2.1.0)\n    mustermann (1.0.1)\n    parallel (1.12.0)\n    parser (2.4.0.2)\n      ast (~> 2.3)\n    powerpack (0.1.1)\n    rack (2.0.3)\n    rack-protection (2.0.0)\n      rack\n    rack-test (0.7.0)\n      rack (>= 1.0, < 3)\n    rainbow (2.2.2)\n      rake\n    rake (12.2.1)\n    rspec (3.7.0)\n      rspec-core (~> 3.7.0)\n      rspec-expectations (~> 3.7.0)\n      rspec-mocks (~> 3.7.0)\n    rspec-core (3.7.0)\n      rspec-support (~> 3.7.0)\n    rspec-expectations (3.7.0)\n      diff-lcs (>= 1.2.0, < 2.0)\n      rspec-support (~> 3.7.0)\n    rspec-mocks (3.7.0)\n      diff-lcs (>= 1.2.0, < 2.0)\n      rspec-support (~> 3.7.0)\n    rspec-support (3.7.0)\n    rubocop (0.51.0)\n      parallel (~> 1.10)\n      parser (>= 2.3.3.1, < 3.0)\n      powerpack (~> 0.1)\n      rainbow (>= 2.2.2, < 3.0)\n      ruby-progressbar (~> 1.7)\n      unicode-display_width (~> 1.0, >= 1.0.1)\n    ruby-progressbar (1.9.0)\n    simplecov (0.15.1)\n      docile (~> 1.1.0)\n      json (>= 1.8, < 3)\n      simplecov-html (~> 0.10.0)\n    simplecov-html (0.10.2)\n    sinatra (2.0.0)\n      mustermann (~> 1.0)\n      rack (~> 2.0)\n      rack-protection (= 2.0.0)\n      tilt (~> 2.0)\n    slop (3.6.0)\n    thin (1.7.2)\n      daemons (~> 1.0, >= 1.0.9)\n      eventmachine (~> 1.0, >= 1.0.4)\n      rack (>= 1, < 3)\n    tilt (2.0.8)\n    unicode-display_width (1.3.0)\n\nPLATFORMS\n  ruby\n\nDEPENDENCIES\n  fakefs (~> 0.11)\n  gemirro!\n  rack-test (~> 0.7)\n  rake (~> 12.1)\n  rspec (~> 3.7)\n  rubocop (~> 0.51)\n  simplecov (~> 0.15)\n\nBUNDLED WITH\n   1.15.4\n", "require 'sinatra/base'\nrequire 'thin'\n\nmodule Gemirro\n  ##\n  # Launch Sinatra server to easily download gems.\n  #\n  class Server < Sinatra::Base\n    # rubocop:disable Metrics/LineLength\n    URI_REGEXP = /^(.*)-(\\d+(?:\\.\\d+){1,4}.*?)(?:-(x86-(?:(?:mswin|mingw)(?:32|64)).*?|java))?\\.(gem(?:spec\\.rz)?)$/\n    GEMSPEC_TYPE = 'gemspec.rz'.freeze\n    GEM_TYPE = 'gem'.freeze\n\n    access_logger = Logger.new(Utils.configuration.server.access_log).tap do |logger|\n      ::Logger.class_eval { alias_method :write, :'<<' }\n      logger.level = ::Logger::INFO\n    end\n    # rubocop:enable Metrics/LineLength\n\n    error_logger = File.new(Utils.configuration.server.error_log, 'a+')\n    error_logger.sync = true\n\n    before do\n      env['rack.errors'] = error_logger\n      Utils.configuration.logger = access_logger\n    end\n\n    ##\n    # Configure server\n    #\n    configure do\n      config = Utils.configuration\n      config.server.host = 'localhost' if config.server.host.nil?\n      config.server.port = '2000' if config.server.port.nil?\n\n      set :static, true\n\n      set :views, Gemirro::Configuration.views_directory\n      set :port, config.server.port\n      set :bind, config.server.host\n      set :public_folder, config.destination.gsub(%r{/$}, '')\n      set :environment, config.environment\n      set :dump_errors, true\n      set :raise_errors, true\n\n      enable :logging\n      use Rack::CommonLogger, access_logger\n    end\n\n    ##\n    # Set template for not found action\n    #\n    # @return [nil]\n    #\n    not_found do\n      content_type 'text/html'\n      erb(:not_found)\n    end\n\n    ##\n    # Display information about one gem\n    #\n    # @return [nil]\n    #\n    get('/gem/:gemname') do\n      gems = Utils.gems_collection\n      gem = gems.find_by_name(params[:gemname])\n      return not_found if gem.nil?\n\n      erb(:gem, {}, gem: gem)\n    end\n\n    ##\n    # Display home page containing the list of gems already\n    # downloaded on the server\n    #\n    # @return [nil]\n    #\n    get('/') do\n      erb(:index, {}, gems: Utils.gems_collection)\n    end\n\n    ##\n    # Return gem dependencies as binary\n    #\n    # @return [nil]\n    #\n    get '/api/v1/dependencies' do\n      content_type 'application/octet-stream'\n      query_gems.any? ? Marshal.dump(query_gems_list) : 200\n    end\n\n    ##\n    # Return gem dependencies as json\n    #\n    # @return [nil]\n    #\n    get '/api/v1/dependencies.json' do\n      content_type 'application/json'\n      query_gems.any? ? JSON.dump(query_gems_list) : {}\n    end\n\n    ##\n    # Try to get all request and download files\n    # if files aren't found.\n    #\n    # @return [nil]\n    #\n    get('*') do |path|\n      resource = \"#{settings.public_folder}#{path}\"\n\n      # Try to download gem\n      fetch_gem(resource) unless File.exist?(resource)\n      # If not found again, return a 404\n      return not_found unless File.exist?(resource)\n\n      send_file(resource)\n    end\n\n    ##\n    # Try to fetch gem and download its if it's possible, and\n    # build and install indicies.\n    #\n    # @param [String] resource\n    # @return [Indexer]\n    #\n    def fetch_gem(resource)\n      return unless Utils.configuration.fetch_gem\n      name = File.basename(resource)\n      result = name.match(URI_REGEXP)\n      return unless result\n\n      gem_name, gem_version, gem_platform, gem_type = result.captures\n      return unless gem_name && gem_version\n\n      begin\n        gem = Utils.stored_gem(gem_name, gem_version, gem_platform)\n        gem.gemspec = true if gem_type == GEMSPEC_TYPE\n\n        # rubocop:disable Metrics/LineLength\n        return if Utils.gems_fetcher.gem_exists?(gem.filename(gem_version)) && gem_type == GEM_TYPE\n        return if Utils.gems_fetcher.gemspec_exists?(gem.gemspec_filename(gem_version)) && gem_type == GEMSPEC_TYPE\n        # rubocop:enable Metrics/LineLength\n\n        Utils.logger\n             .info(\"Try to download #{gem_name} with version #{gem_version}\")\n        Utils.gems_fetcher.source.gems.clear\n        Utils.gems_fetcher.source.gems.push(gem)\n        Utils.gems_fetcher.fetch\n\n        update_indexes if Utils.configuration.update_on_fetch\n      rescue StandardError => e\n        Utils.logger.error(e)\n      end\n    end\n\n    ##\n    # Update indexes files\n    #\n    # @return [Indexer]\n    #\n    def update_indexes\n      indexer = Gemirro::Indexer.new(Utils.configuration.destination)\n      indexer.only_origin = true\n      indexer.ui = ::Gem::SilentUI.new\n\n      Utils.logger.info('Generating indexes')\n      indexer.update_index\n      indexer.updated_gems.peach do |gem|\n        Utils.cache.flush_key(File.basename(gem))\n      end\n    rescue SystemExit => e\n      Utils.logger.info(e.message)\n    end\n\n    ##\n    # Return all gems pass to query\n    #\n    # @return [Array]\n    #\n    def query_gems\n      params[:gems].to_s.split(',')\n    end\n\n    ##\n    # Return gems list from query params\n    #\n    # @return [Array]\n    #\n    def query_gems_list\n      Utils.gems_collection(false) # load collection\n      gems = Parallel.map(query_gems, in_threads: 4) do |query_gem|\n        gem_dependencies(query_gem)\n      end\n\n      gems.flatten!\n      gems.reject!(&:empty?)\n      gems\n    end\n\n    ##\n    # List of versions and dependencies of each version\n    # from a gem name.\n    #\n    # @return [Array]\n    #\n    def gem_dependencies(gem_name)\n      Utils.cache.cache(gem_name) do\n        gems = Utils.gems_collection(false)\n        gem_collection = gems.find_by_name(gem_name)\n\n        return '' if gem_collection.nil?\n\n        gem_collection = Parallel.map(gem_collection, in_threads: 4) do |gem|\n          [gem, spec_for(gem.name, gem.number, gem.platform)]\n        end\n        gem_collection.reject! do |_, spec|\n          spec.nil?\n        end\n\n        Parallel.map(gem_collection, in_threads: 4) do |gem, spec|\n          dependencies = spec.dependencies.select do |d|\n            d.type == :runtime\n          end\n\n          dependencies = Parallel.map(dependencies, in_threads: 4) do |d|\n            [d.name.is_a?(Array) ? d.name.first : d.name, d.requirement.to_s]\n          end\n\n          {\n            name: gem.name,\n            number: gem.number,\n            platform: gem.platform,\n            dependencies: dependencies\n          }\n        end\n      end\n    end\n\n    helpers do\n      ##\n      # Return gem specification from gemname and version\n      #\n      # @param [String] gemname\n      # @param [String] version\n      # @return [::Gem::Specification]\n      #\n      def spec_for(gemname, version, platform = 'ruby')\n        gem = Utils.stored_gem(gemname, version.to_s, platform)\n        gemspec_path = File.join('quick',\n                                 Gemirro::Configuration.marshal_identifier,\n                                 gem.gemspec_filename)\n        spec_file = File.join(settings.public_folder,\n                              gemspec_path)\n        fetch_gem(gemspec_path) unless File.exist?(spec_file)\n\n        return unless File.exist?(spec_file)\n\n        File.open(spec_file, 'r') do |uz_file|\n          uz_file.binmode\n          Marshal.load(::Gem.inflate(uz_file.read))\n        end\n      end\n\n      ##\n      # Escape string\n      #\n      # @param [String] string\n      # @return [String]\n      #\n      def escape(string)\n        Rack::Utils.escape_html(string)\n      end\n    end\n  end\nend\n", "<div class=\"col-lg-12\">\n  <div class=\"col-lg-3 center-block pull-none text-center\">\n    <a class=\"btn btn-default\" href=\"<%= url '/'%>\">Back to Gem Index</a>\n  </div>\n</div>\n\n<div class=\"col-lg-12\">\n  <% gem.by_name do |name, versions| %>\n    <div class=\"col-lg-6 center-block pull-none\">\n      <div class=\"panel panel-info\">\n        <div class=\"panel-heading\">\n          <a href=\"<%= url(\"gem/#{name}\") %>\">\n            <h2 class=\"panel-title\"><%= escape(name) %> <span class=\"badge pull-right\"><%= escape(versions.newest.number) %></span></h2>\n          </a>\n        </div>\n        <div class=\"panel-body\">\n          <% newest_gem = versions.newest %>\n          <% if spec = spec_for(name, newest_gem.number, newest_gem.platform) %>\n            <p><%= escape(spec.description) %></p>\n\n            <h3>Dependencies</h3>\n            <ul class=\"list-group\">\n              <% spec.dependencies.each do |dependency| %>\n                <li class=\"list-group-item\">\n                  <a href=\"<%= url(\"gem/#{dependency.name}\") %>\"><%= escape([dependency.name, dependency.requirement].join(' ')) %></a>\n                </li>\n              <% end %>\n            </ul>\n\n            <h3>Authors</h3>\n            <ul class=\"list-group\">\n              <% spec.authors.each do |author| %>\n                <li class=\"list-group-item\">\n                  <a href=\"<%= escape(spec.homepage) %>\"><%= escape(author) %></a>\n                </li>\n              <% end %>\n            </ul>\n          <% end %>\n        </div>\n\n        <ul class=\"list-group\">\n          <% versions.each.reverse_each do |version| %>\n            <li class=\"list-group-item clearfix\">\n              <p class=\"pull-left\">\n                <code>gem install <%= escape(version.name) %> -v \"<%= escape(version.number) %>\"</code>\n                <% unless version.platform =~ /^ruby/i %>\n                  <small class=\"platform\"><%= escape(version.platform) %></small>\n                <% end %>\n              </p>\n              <div class=\"pull-right\">\n                <a class=\"btn btn-primary btn-sm\" href=\"<%= url(\"/gems/#{version.gemfile_name}.gem\") %>\">Download</a>\n              </div>\n            </li>\n          <% end %>\n        </ul>\n    </div>\n  <% end %>\n</div>\n"], "fixing_code": ["PATH\n  remote: .\n  specs:\n    gemirro (0.15.0)\n      builder (~> 3.2)\n      confstruct (~> 1.0)\n      erubis (~> 2.7)\n      httpclient (~> 2.8)\n      parallel (~> 1.12)\n      sinatra (~> 2.0)\n      slop (~> 3.6)\n      thin (~> 1.7)\n\nGEM\n  remote: https://rubygems.org/\n  specs:\n    ast (2.3.0)\n    builder (3.2.3)\n    confstruct (1.0.2)\n      hashie (~> 3.3)\n    daemons (1.2.5)\n    diff-lcs (1.3)\n    docile (1.1.5)\n    erubis (2.7.0)\n    eventmachine (1.2.5)\n    fakefs (0.11.3)\n    hashie (3.5.6)\n    httpclient (2.8.3)\n    json (2.1.0)\n    mustermann (1.0.1)\n    parallel (1.12.0)\n    parser (2.4.0.2)\n      ast (~> 2.3)\n    powerpack (0.1.1)\n    rack (2.0.3)\n    rack-protection (2.0.0)\n      rack\n    rack-test (0.7.0)\n      rack (>= 1.0, < 3)\n    rainbow (2.2.2)\n      rake\n    rake (12.2.1)\n    rspec (3.7.0)\n      rspec-core (~> 3.7.0)\n      rspec-expectations (~> 3.7.0)\n      rspec-mocks (~> 3.7.0)\n    rspec-core (3.7.0)\n      rspec-support (~> 3.7.0)\n    rspec-expectations (3.7.0)\n      diff-lcs (>= 1.2.0, < 2.0)\n      rspec-support (~> 3.7.0)\n    rspec-mocks (3.7.0)\n      diff-lcs (>= 1.2.0, < 2.0)\n      rspec-support (~> 3.7.0)\n    rspec-support (3.7.0)\n    rubocop (0.51.0)\n      parallel (~> 1.10)\n      parser (>= 2.3.3.1, < 3.0)\n      powerpack (~> 0.1)\n      rainbow (>= 2.2.2, < 3.0)\n      ruby-progressbar (~> 1.7)\n      unicode-display_width (~> 1.0, >= 1.0.1)\n    ruby-progressbar (1.9.0)\n    simplecov (0.15.1)\n      docile (~> 1.1.0)\n      json (>= 1.8, < 3)\n      simplecov-html (~> 0.10.0)\n    simplecov-html (0.10.2)\n    sinatra (2.0.0)\n      mustermann (~> 1.0)\n      rack (~> 2.0)\n      rack-protection (= 2.0.0)\n      tilt (~> 2.0)\n    slop (3.6.0)\n    thin (1.7.2)\n      daemons (~> 1.0, >= 1.0.9)\n      eventmachine (~> 1.0, >= 1.0.4)\n      rack (>= 1, < 3)\n    tilt (2.0.8)\n    unicode-display_width (1.3.0)\n\nPLATFORMS\n  ruby\n\nDEPENDENCIES\n  fakefs (~> 0.11)\n  gemirro!\n  rack-test (~> 0.7)\n  rake (~> 12.1)\n  rspec (~> 3.7)\n  rubocop (~> 0.51)\n  simplecov (~> 0.15)\n\nBUNDLED WITH\n   1.15.4\n", "require 'sinatra/base'\nrequire 'thin'\nrequire 'uri'\n\nmodule Gemirro\n  ##\n  # Launch Sinatra server to easily download gems.\n  #\n  class Server < Sinatra::Base\n    # rubocop:disable Metrics/LineLength\n    URI_REGEXP = /^(.*)-(\\d+(?:\\.\\d+){1,4}.*?)(?:-(x86-(?:(?:mswin|mingw)(?:32|64)).*?|java))?\\.(gem(?:spec\\.rz)?)$/\n    GEMSPEC_TYPE = 'gemspec.rz'.freeze\n    GEM_TYPE = 'gem'.freeze\n\n    access_logger = Logger.new(Utils.configuration.server.access_log).tap do |logger|\n      ::Logger.class_eval { alias_method :write, :'<<' }\n      logger.level = ::Logger::INFO\n    end\n    # rubocop:enable Metrics/LineLength\n\n    error_logger = File.new(Utils.configuration.server.error_log, 'a+')\n    error_logger.sync = true\n\n    before do\n      env['rack.errors'] = error_logger\n      Utils.configuration.logger = access_logger\n    end\n\n    ##\n    # Configure server\n    #\n    configure do\n      config = Utils.configuration\n      config.server.host = 'localhost' if config.server.host.nil?\n      config.server.port = '2000' if config.server.port.nil?\n\n      set :static, true\n\n      set :views, Gemirro::Configuration.views_directory\n      set :port, config.server.port\n      set :bind, config.server.host\n      set :public_folder, config.destination.gsub(%r{/$}, '')\n      set :environment, config.environment\n      set :dump_errors, true\n      set :raise_errors, true\n\n      enable :logging\n      use Rack::CommonLogger, access_logger\n    end\n\n    ##\n    # Set template for not found action\n    #\n    # @return [nil]\n    #\n    not_found do\n      content_type 'text/html'\n      erb(:not_found)\n    end\n\n    ##\n    # Display information about one gem\n    #\n    # @return [nil]\n    #\n    get('/gem/:gemname') do\n      gems = Utils.gems_collection\n      gem = gems.find_by_name(params[:gemname])\n      return not_found if gem.nil?\n\n      erb(:gem, {}, gem: gem)\n    end\n\n    ##\n    # Display home page containing the list of gems already\n    # downloaded on the server\n    #\n    # @return [nil]\n    #\n    get('/') do\n      erb(:index, {}, gems: Utils.gems_collection)\n    end\n\n    ##\n    # Return gem dependencies as binary\n    #\n    # @return [nil]\n    #\n    get '/api/v1/dependencies' do\n      content_type 'application/octet-stream'\n      query_gems.any? ? Marshal.dump(query_gems_list) : 200\n    end\n\n    ##\n    # Return gem dependencies as json\n    #\n    # @return [nil]\n    #\n    get '/api/v1/dependencies.json' do\n      content_type 'application/json'\n      query_gems.any? ? JSON.dump(query_gems_list) : {}\n    end\n\n    ##\n    # Try to get all request and download files\n    # if files aren't found.\n    #\n    # @return [nil]\n    #\n    get('*') do |path|\n      resource = \"#{settings.public_folder}#{path}\"\n\n      # Try to download gem\n      fetch_gem(resource) unless File.exist?(resource)\n      # If not found again, return a 404\n      return not_found unless File.exist?(resource)\n\n      send_file(resource)\n    end\n\n    ##\n    # Try to fetch gem and download its if it's possible, and\n    # build and install indicies.\n    #\n    # @param [String] resource\n    # @return [Indexer]\n    #\n    def fetch_gem(resource)\n      return unless Utils.configuration.fetch_gem\n      name = File.basename(resource)\n      result = name.match(URI_REGEXP)\n      return unless result\n\n      gem_name, gem_version, gem_platform, gem_type = result.captures\n      return unless gem_name && gem_version\n\n      begin\n        gem = Utils.stored_gem(gem_name, gem_version, gem_platform)\n        gem.gemspec = true if gem_type == GEMSPEC_TYPE\n\n        # rubocop:disable Metrics/LineLength\n        return if Utils.gems_fetcher.gem_exists?(gem.filename(gem_version)) && gem_type == GEM_TYPE\n        return if Utils.gems_fetcher.gemspec_exists?(gem.gemspec_filename(gem_version)) && gem_type == GEMSPEC_TYPE\n        # rubocop:enable Metrics/LineLength\n\n        Utils.logger\n             .info(\"Try to download #{gem_name} with version #{gem_version}\")\n        Utils.gems_fetcher.source.gems.clear\n        Utils.gems_fetcher.source.gems.push(gem)\n        Utils.gems_fetcher.fetch\n\n        update_indexes if Utils.configuration.update_on_fetch\n      rescue StandardError => e\n        Utils.logger.error(e)\n      end\n    end\n\n    ##\n    # Update indexes files\n    #\n    # @return [Indexer]\n    #\n    def update_indexes\n      indexer = Gemirro::Indexer.new(Utils.configuration.destination)\n      indexer.only_origin = true\n      indexer.ui = ::Gem::SilentUI.new\n\n      Utils.logger.info('Generating indexes')\n      indexer.update_index\n      indexer.updated_gems.peach do |gem|\n        Utils.cache.flush_key(File.basename(gem))\n      end\n    rescue SystemExit => e\n      Utils.logger.info(e.message)\n    end\n\n    ##\n    # Return all gems pass to query\n    #\n    # @return [Array]\n    #\n    def query_gems\n      params[:gems].to_s.split(',')\n    end\n\n    ##\n    # Return gems list from query params\n    #\n    # @return [Array]\n    #\n    def query_gems_list\n      Utils.gems_collection(false) # load collection\n      gems = Parallel.map(query_gems, in_threads: 4) do |query_gem|\n        gem_dependencies(query_gem)\n      end\n\n      gems.flatten!\n      gems.reject!(&:empty?)\n      gems\n    end\n\n    ##\n    # List of versions and dependencies of each version\n    # from a gem name.\n    #\n    # @return [Array]\n    #\n    def gem_dependencies(gem_name)\n      Utils.cache.cache(gem_name) do\n        gems = Utils.gems_collection(false)\n        gem_collection = gems.find_by_name(gem_name)\n\n        return '' if gem_collection.nil?\n\n        gem_collection = Parallel.map(gem_collection, in_threads: 4) do |gem|\n          [gem, spec_for(gem.name, gem.number, gem.platform)]\n        end\n        gem_collection.reject! do |_, spec|\n          spec.nil?\n        end\n\n        Parallel.map(gem_collection, in_threads: 4) do |gem, spec|\n          dependencies = spec.dependencies.select do |d|\n            d.type == :runtime\n          end\n\n          dependencies = Parallel.map(dependencies, in_threads: 4) do |d|\n            [d.name.is_a?(Array) ? d.name.first : d.name, d.requirement.to_s]\n          end\n\n          {\n            name: gem.name,\n            number: gem.number,\n            platform: gem.platform,\n            dependencies: dependencies\n          }\n        end\n      end\n    end\n\n    helpers do\n      ##\n      # Return gem specification from gemname and version\n      #\n      # @param [String] gemname\n      # @param [String] version\n      # @return [::Gem::Specification]\n      #\n      def spec_for(gemname, version, platform = 'ruby')\n        gem = Utils.stored_gem(gemname, version.to_s, platform)\n        gemspec_path = File.join('quick',\n                                 Gemirro::Configuration.marshal_identifier,\n                                 gem.gemspec_filename)\n        spec_file = File.join(settings.public_folder,\n                              gemspec_path)\n        fetch_gem(gemspec_path) unless File.exist?(spec_file)\n\n        return unless File.exist?(spec_file)\n\n        File.open(spec_file, 'r') do |uz_file|\n          uz_file.binmode\n          Marshal.load(::Gem.inflate(uz_file.read))\n        end\n      end\n\n      ##\n      # Escape string\n      #\n      # @param [String] string\n      # @return [String]\n      #\n      def escape(string)\n        Rack::Utils.escape_html(string)\n      end\n\n      ##\n      # Homepage link\n      #\n      # @param [Gem] spec\n      # @return [String]\n      #\n      def homepage(spec)\n        URI.parse(URI.escape(spec.homepage))\n      end\n    end\n  end\nend\n", "<div class=\"col-lg-12\">\n  <div class=\"col-lg-3 center-block pull-none text-center\">\n    <a class=\"btn btn-default\" href=\"<%= url '/'%>\">Back to Gem Index</a>\n  </div>\n</div>\n\n<div class=\"col-lg-12\">\n  <% gem.by_name do |name, versions| %>\n    <div class=\"col-lg-6 center-block pull-none\">\n      <div class=\"panel panel-info\">\n        <div class=\"panel-heading\">\n          <a href=\"<%= url(\"gem/#{name}\") %>\">\n            <h2 class=\"panel-title\"><%= escape(name) %> <span class=\"badge pull-right\"><%= escape(versions.newest.number) %></span></h2>\n          </a>\n        </div>\n        <div class=\"panel-body\">\n          <% newest_gem = versions.newest %>\n          <% if spec = spec_for(name, newest_gem.number, newest_gem.platform) %>\n            <p><%= escape(spec.description) %></p>\n\n            <h3>Dependencies</h3>\n            <ul class=\"list-group\">\n              <% spec.dependencies.each do |dependency| %>\n                <li class=\"list-group-item\">\n                  <a href=\"<%= url(\"gem/#{dependency.name}\") %>\"><%= escape([dependency.name, dependency.requirement].join(' ')) %></a>\n                </li>\n              <% end %>\n            </ul>\n\n            <h3>Authors</h3>\n            <ul class=\"list-group\">\n              <% spec.authors.each do |author| %>\n                <li class=\"list-group-item\">\n                  <a href=\"<%= homepage(spec) %>\"><%= escape(author) %></a>\n                </li>\n              <% end %>\n            </ul>\n          <% end %>\n        </div>\n\n        <ul class=\"list-group\">\n          <% versions.each.reverse_each do |version| %>\n            <li class=\"list-group-item clearfix\">\n              <p class=\"pull-left\">\n                <code>gem install <%= escape(version.name) %> -v \"<%= escape(version.number) %>\"</code>\n                <% unless version.platform =~ /^ruby/i %>\n                  <small class=\"platform\"><%= escape(version.platform) %></small>\n                <% end %>\n              </p>\n              <div class=\"pull-right\">\n                <a class=\"btn btn-primary btn-sm\" href=\"<%= url(\"/gems/#{version.gemfile_name}.gem\") %>\">Download</a>\n              </div>\n            </li>\n          <% end %>\n        </ul>\n    </div>\n  <% end %>\n</div>\n"], "filenames": ["Gemfile.lock", "lib/gemirro/server.rb", "views/gem.erb"], "buggy_code_start_loc": [4, 2, 34], "buggy_code_end_loc": [5, 273, 35], "fixing_code_start_loc": [4, 3, 34], "fixing_code_end_loc": [5, 285, 35], "type": "CWE-79", "message": "Stored cross-site scripting (XSS) vulnerability in Gemirro before 0.16.0 allows attackers to inject arbitrary web script via a crafted javascript: URL in the \"homepage\" value of a \".gemspec\" file.", "other": {"cve": {"id": "CVE-2017-16833", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-15T09:29:00.210", "lastModified": "2020-03-10T13:11:16.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stored cross-site scripting (XSS) vulnerability in Gemirro before 0.16.0 allows attackers to inject arbitrary web script via a crafted javascript: URL in the \"homepage\" value of a \".gemspec\" file."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-Site Scripting (XSS) en Gemirro en versiones anteriores a la 0.16.0 permite que atacantes remotos inyecten scripts web o HTML arbitrarios mediante una URL JavaScript manipulada en el valor \"homepage\" de un archivo \".gemspec\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gemirro_project:gemirro:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "0.16.0", "matchCriteriaId": "A3E3307D-BE64-43A1-A196-1DF5247636F3"}]}]}], "references": [{"url": "https://github.com/PierreRambaud/gemirro/commit/9659f9b7ce15a723da8e361bd41b9203b19c97de", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "Patch"]}]}, "github_commit_url": "https://github.com/PierreRambaud/gemirro/commit/9659f9b7ce15a723da8e361bd41b9203b19c97de"}}