{"buggy_code": ["/*\n * Marvell Wireless LAN device driver: PCIE specific handling\n *\n * Copyright (C) 2011-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include <linux/firmware.h>\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"pcie.h\"\n\n#define PCIE_VERSION\t\"1.0\"\n#define DRV_NAME        \"Marvell mwifiex PCIe\"\n\nstatic struct mwifiex_if_ops pcie_ops;\n\nstatic const struct of_device_id mwifiex_pcie_of_match_table[] = {\n\t{ .compatible = \"pci11ab,2b42\" },\n\t{ .compatible = \"pci1b4b,2b42\" },\n\t{ }\n};\n\nstatic int mwifiex_pcie_probe_of(struct device *dev)\n{\n\tif (!of_match_node(mwifiex_pcie_of_match_table, dev->of_node)) {\n\t\tdev_err(dev, \"required compatible string missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_pcie_work(struct work_struct *work);\n\nstatic int\nmwifiex_map_pci_memory(struct mwifiex_adapter *adapter, struct sk_buff *skb,\n\t\t       size_t size, int flags)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_dma_mapping mapping;\n\n\tmapping.addr = pci_map_single(card->dev, skb->data, size, flags);\n\tif (pci_dma_mapping_error(card->dev, mapping.addr)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"failed to map pci memory!\\n\");\n\t\treturn -1;\n\t}\n\tmapping.len = size;\n\tmwifiex_store_mapping(skb, &mapping);\n\treturn 0;\n}\n\nstatic void mwifiex_unmap_pci_memory(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct sk_buff *skb, int flags)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_dma_mapping mapping;\n\n\tmwifiex_get_mapping(skb, &mapping);\n\tpci_unmap_single(card->dev, mapping.addr, mapping.len, flags);\n}\n\n/*\n * This function writes data into PCIE card register.\n */\nstatic int mwifiex_write_reg(struct mwifiex_adapter *adapter, int reg, u32 data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tiowrite32(data, card->pci_mmap1 + reg);\n\n\treturn 0;\n}\n\n/* This function reads data from PCIE card register.\n */\nstatic int mwifiex_read_reg(struct mwifiex_adapter *adapter, int reg, u32 *data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t*data = ioread32(card->pci_mmap1 + reg);\n\tif (*data == 0xffffffff)\n\t\treturn 0xffffffff;\n\n\treturn 0;\n}\n\n/* This function reads u8 data from PCIE card register. */\nstatic int mwifiex_read_reg_byte(struct mwifiex_adapter *adapter,\n\t\t\t\t int reg, u8 *data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t*data = ioread8(card->pci_mmap1 + reg);\n\n\treturn 0;\n}\n\n/*\n * This function reads sleep cookie and checks if FW is ready\n */\nstatic bool mwifiex_pcie_ok_to_access_hw(struct mwifiex_adapter *adapter)\n{\n\tu32 cookie_value;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!reg->sleep_cookie)\n\t\treturn true;\n\n\tif (card->sleep_cookie_vbase) {\n\t\tcookie_value = get_unaligned_le32(card->sleep_cookie_vbase);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ACCESS_HW: sleep cookie=0x%x\\n\",\n\t\t\t    cookie_value);\n\t\tif (cookie_value == FW_AWAKE_COOKIE)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#ifdef CONFIG_PM_SLEEP\n/*\n * Kernel needs to suspend all functions separately. Therefore all\n * registered functions must have drivers with suspend and resume\n * methods. Failing that the kernel simply removes the whole card.\n *\n * If already not suspended, this function allocates and sends a host\n * sleep activate request to the firmware and turns off the traffic.\n */\nstatic int mwifiex_pcie_suspend(struct device *dev)\n{\n\tstruct mwifiex_adapter *adapter;\n\tstruct pcie_service_card *card = dev_get_drvdata(dev);\n\n\n\t/* Might still be loading firmware */\n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter) {\n\t\tdev_err(dev, \"adapter is not valid\\n\");\n\t\treturn 0;\n\t}\n\n\tmwifiex_enable_wake(adapter);\n\n\t/* Enable the Host Sleep */\n\tif (!mwifiex_enable_hs(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cmd: failed to suspend\\n\");\n\t\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\t\tmwifiex_disable_wake(adapter);\n\t\treturn -EFAULT;\n\t}\n\n\tflush_workqueue(adapter->workqueue);\n\n\t/* Indicate device suspended */\n\tset_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\n\treturn 0;\n}\n\n/*\n * Kernel needs to suspend all functions separately. Therefore all\n * registered functions must have drivers with suspend and resume\n * methods. Failing that the kernel simply removes the whole card.\n *\n * If already not resumed, this function turns on the traffic and\n * sends a host sleep cancel request to the firmware.\n */\nstatic int mwifiex_pcie_resume(struct device *dev)\n{\n\tstruct mwifiex_adapter *adapter;\n\tstruct pcie_service_card *card = dev_get_drvdata(dev);\n\n\n\tif (!card->adapter) {\n\t\tdev_err(dev, \"adapter structure is not valid\\n\");\n\t\treturn 0;\n\t}\n\n\tadapter = card->adapter;\n\n\tif (!test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"Device already resumed\\n\");\n\t\treturn 0;\n\t}\n\n\tclear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\n\tmwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),\n\t\t\t  MWIFIEX_ASYNC_CMD);\n\tmwifiex_disable_wake(adapter);\n\n\treturn 0;\n}\n#endif\n\n/*\n * This function probes an mwifiex device and registers it. It allocates\n * the card structure, enables PCIE function number and initiates the\n * device registration and initialization procedure by adding a logical\n * interface.\n */\nstatic int mwifiex_pcie_probe(struct pci_dev *pdev,\n\t\t\t\t\tconst struct pci_device_id *ent)\n{\n\tstruct pcie_service_card *card;\n\tint ret;\n\n\tpr_debug(\"info: vendor=0x%4.04X device=0x%4.04X rev=%d\\n\",\n\t\t pdev->vendor, pdev->device, pdev->revision);\n\n\tcard = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&card->fw_done);\n\n\tcard->dev = pdev;\n\n\tif (ent->driver_data) {\n\t\tstruct mwifiex_pcie_device *data = (void *)ent->driver_data;\n\t\tcard->pcie.reg = data->reg;\n\t\tcard->pcie.blksz_fw_dl = data->blksz_fw_dl;\n\t\tcard->pcie.tx_buf_size = data->tx_buf_size;\n\t\tcard->pcie.can_dump_fw = data->can_dump_fw;\n\t\tcard->pcie.mem_type_mapping_tbl = data->mem_type_mapping_tbl;\n\t\tcard->pcie.num_mem_types = data->num_mem_types;\n\t\tcard->pcie.can_ext_scan = data->can_ext_scan;\n\t\tINIT_WORK(&card->work, mwifiex_pcie_work);\n\t}\n\n\t/* device tree node parsing and platform specific configuration*/\n\tif (pdev->dev.of_node) {\n\t\tret = mwifiex_pcie_probe_of(&pdev->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (mwifiex_add_card(card, &card->fw_done, &pcie_ops,\n\t\t\t     MWIFIEX_PCIE, &pdev->dev)) {\n\t\tpr_err(\"%s failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function removes the interface and frees up the card structure.\n */\nstatic void mwifiex_pcie_remove(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card;\n\tstruct mwifiex_adapter *adapter;\n\tstruct mwifiex_private *priv;\n\tconst struct mwifiex_pcie_card_reg *reg;\n\tu32 fw_status;\n\tint ret;\n\n\tcard = pci_get_drvdata(pdev);\n\n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter || !adapter->priv_num)\n\t\treturn;\n\n\treg = card->pcie.reg;\n\tif (reg)\n\t\tret = mwifiex_read_reg(adapter, reg->fw_status, &fw_status);\n\telse\n\t\tfw_status = -1;\n\n\tif (fw_status == FIRMWARE_READY_PCIE && !adapter->mfg_mode) {\n\t\tmwifiex_deauthenticate_all(adapter);\n\n\t\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\t\tmwifiex_disable_auto_ds(priv);\n\n\t\tmwifiex_init_shutdown_fw(priv, MWIFIEX_FUNC_SHUTDOWN);\n\t}\n\n\tmwifiex_remove_card(adapter);\n}\n\nstatic void mwifiex_pcie_shutdown(struct pci_dev *pdev)\n{\n\tmwifiex_pcie_remove(pdev);\n\n\treturn;\n}\n\nstatic void mwifiex_pcie_coredump(struct device *dev)\n{\n\tstruct pci_dev *pdev;\n\tstruct pcie_service_card *card;\n\n\tpdev = container_of(dev, struct pci_dev, dev);\n\tcard = pci_get_drvdata(pdev);\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t      &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic const struct pci_device_id mwifiex_ids[] = {\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8766P,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8766,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8897,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8897,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8997,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8997,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_V2_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8997,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8997,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(pci, mwifiex_ids);\n\n/*\n * Cleanup all software without cleaning anything related to PCIe and HW.\n */\nstatic void mwifiex_pcie_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card = pci_get_drvdata(pdev);\n\tstruct mwifiex_adapter *adapter = card->adapter;\n\n\tif (!adapter) {\n\t\tdev_err(&pdev->dev, \"%s: adapter structure is not valid\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: vendor=0x%4.04x device=0x%4.04x rev=%d Pre-FLR\\n\",\n\t\t    __func__, pdev->vendor, pdev->device, pdev->revision);\n\n\tmwifiex_shutdown_sw(adapter);\n\tclear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &card->work_flags);\n\tclear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags);\n\tmwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);\n}\n\n/*\n * Kernel stores and restores PCIe function context before and after performing\n * FLR respectively. Reconfigure the software and firmware including firmware\n * redownload.\n */\nstatic void mwifiex_pcie_reset_done(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card = pci_get_drvdata(pdev);\n\tstruct mwifiex_adapter *adapter = card->adapter;\n\tint ret;\n\n\tif (!adapter) {\n\t\tdev_err(&pdev->dev, \"%s: adapter structure is not valid\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: vendor=0x%4.04x device=0x%4.04x rev=%d Post-FLR\\n\",\n\t\t    __func__, pdev->vendor, pdev->device, pdev->revision);\n\n\tret = mwifiex_reinit_sw(adapter);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"reinit failed: %d\\n\", ret);\n\telse\n\t\tmwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);\n}\n\nstatic const struct pci_error_handlers mwifiex_pcie_err_handler = {\n\t.reset_prepare\t\t= mwifiex_pcie_reset_prepare,\n\t.reset_done\t\t= mwifiex_pcie_reset_done,\n};\n\n#ifdef CONFIG_PM_SLEEP\n/* Power Management Hooks */\nstatic SIMPLE_DEV_PM_OPS(mwifiex_pcie_pm_ops, mwifiex_pcie_suspend,\n\t\t\t\tmwifiex_pcie_resume);\n#endif\n\n/* PCI Device Driver */\nstatic struct pci_driver __refdata mwifiex_pcie = {\n\t.name     = \"mwifiex_pcie\",\n\t.id_table = mwifiex_ids,\n\t.probe    = mwifiex_pcie_probe,\n\t.remove   = mwifiex_pcie_remove,\n\t.driver   = {\n\t\t.coredump = mwifiex_pcie_coredump,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm = &mwifiex_pcie_pm_ops,\n#endif\n\t},\n\t.shutdown = mwifiex_pcie_shutdown,\n\t.err_handler = &mwifiex_pcie_err_handler,\n};\n\n/*\n * This function adds delay loop to ensure FW is awake before proceeding.\n */\nstatic void mwifiex_pcie_dev_wakeup_delay(struct mwifiex_adapter *adapter)\n{\n\tint i = 0;\n\n\twhile (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\ti++;\n\t\tusleep_range(10, 20);\n\t\t/* 50ms max wait */\n\t\tif (i == 5000)\n\t\t\tbreak;\n\t}\n\n\treturn;\n}\n\nstatic void mwifiex_delay_for_sleep_cookie(struct mwifiex_adapter *adapter,\n\t\t\t\t\t   u32 max_delay_loop_cnt)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tu8 *buffer;\n\tu32 sleep_cookie, count;\n\tstruct sk_buff *cmdrsp = card->cmdrsp_buf;\n\n\tfor (count = 0; count < max_delay_loop_cnt; count++) {\n\t\tpci_dma_sync_single_for_cpu(card->dev,\n\t\t\t\t\t    MWIFIEX_SKB_DMA_ADDR(cmdrsp),\n\t\t\t\t\t    sizeof(sleep_cookie),\n\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\t\tbuffer = cmdrsp->data;\n\t\tsleep_cookie = get_unaligned_le32(buffer);\n\n\t\tif (sleep_cookie == MWIFIEX_DEF_SLEEP_COOKIE) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"sleep cookie found at count %d\\n\", count);\n\t\t\tbreak;\n\t\t}\n\t\tpci_dma_sync_single_for_device(card->dev,\n\t\t\t\t\t       MWIFIEX_SKB_DMA_ADDR(cmdrsp),\n\t\t\t\t\t       sizeof(sleep_cookie),\n\t\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t\tusleep_range(20, 30);\n\t}\n\n\tif (count >= max_delay_loop_cnt)\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"max count reached while accessing sleep cookie\\n\");\n}\n\n/* This function wakes up the card by reading fw_status register. */\nstatic int mwifiex_pm_wakeup_card(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"event: Wakeup device...\\n\");\n\n\tif (reg->sleep_cookie)\n\t\tmwifiex_pcie_dev_wakeup_delay(adapter);\n\n\t/* Accessing fw_status register will wakeup device */\n\tif (mwifiex_write_reg(adapter, reg->fw_status, FIRMWARE_READY_PCIE)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Writing fw_status register failed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (reg->sleep_cookie) {\n\t\tmwifiex_pcie_dev_wakeup_delay(adapter);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"PCIE wakeup: Setting PS_STATE_AWAKE\\n\");\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function is called after the card has woken up.\n *\n * The card configuration register is reset.\n */\nstatic int mwifiex_pm_wakeup_card_complete(struct mwifiex_adapter *adapter)\n{\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: Wakeup device completed\\n\");\n\n\treturn 0;\n}\n\n/*\n * This function disables the host interrupt.\n *\n * The host interrupt mask is read, the disable bit is reset and\n * written back to the card host interrupt mask register.\n */\nstatic int mwifiex_pcie_disable_host_int(struct mwifiex_adapter *adapter)\n{\n\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_MASK,\n\t\t\t\t      0x00000000)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Disable host interrupt failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tatomic_set(&adapter->tx_hw_pending, 0);\n\treturn 0;\n}\n\nstatic void mwifiex_pcie_disable_host_int_noerr(struct mwifiex_adapter *adapter)\n{\n\tWARN_ON(mwifiex_pcie_disable_host_int(adapter));\n}\n\n/*\n * This function enables the host interrupt.\n *\n * The host interrupt enable mask is written to the card\n * host interrupt mask register.\n */\nstatic int mwifiex_pcie_enable_host_int(struct mwifiex_adapter *adapter)\n{\n\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t/* Simply write the mask to the register */\n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_MASK,\n\t\t\t\t      HOST_INTR_MASK)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Enable host interrupt failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function initializes TX buffer ring descriptors\n */\nstatic int mwifiex_init_txq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tcard->tx_buf_list[i] = NULL;\n\t\tif (reg->pfu_enabled) {\n\t\t\tcard->txbd_ring[i] = (void *)card->txbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc2) * i);\n\t\t\tdesc2 = card->txbd_ring[i];\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tcard->txbd_ring[i] = (void *)card->txbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc) * i);\n\t\t\tdesc = card->txbd_ring[i];\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* This function initializes RX buffer ring descriptors. Each SKB is allocated\n * here and after mapping PCI memory, its physical address is assigned to\n * PCIE Rx buffer descriptor's physical address.\n */\nstatic int mwifiex_init_rxq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = mwifiex_alloc_dma_align_buf(MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for RX ring.\\n\");\n\t\t\tkfree(card->rxbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb,\n\t\t\t\t\t   MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: RX ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->rx_buf_list[i] = skb;\n\t\tif (reg->pfu_enabled) {\n\t\t\tcard->rxbd_ring[i] = (void *)card->rxbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc2) * i);\n\t\t\tdesc2 = card->rxbd_ring[i];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = (u16)skb->len;\n\t\t\tdesc2->frag_len = (u16)skb->len;\n\t\t\tdesc2->flags = reg->ring_flag_eop | reg->ring_flag_sop;\n\t\t\tdesc2->offset = 0;\n\t\t} else {\n\t\t\tcard->rxbd_ring[i] = (void *)(card->rxbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc) * i));\n\t\t\tdesc = card->rxbd_ring[i];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = (u16)skb->len;\n\t\t\tdesc->flags = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* This function initializes event buffer ring descriptors. Each SKB is\n * allocated here and after mapping PCI memory, its physical address is assigned\n * to PCIE Rx buffer descriptor's physical address\n */\nstatic int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}\n\n/* This function cleans up TX buffer rings. If any of the buffer list has valid\n * SKB address, associated SKB is freed.\n */\nstatic void mwifiex_cleanup_txq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[i];\n\t\t\tif (card->tx_buf_list[i]) {\n\t\t\t\tskb = card->tx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[i];\n\t\t\tif (card->tx_buf_list[i]) {\n\t\t\t\tskb = card->tx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tcard->tx_buf_list[i] = NULL;\n\t}\n\n\tatomic_set(&adapter->tx_hw_pending, 0);\n\treturn;\n}\n\n/* This function cleans up RX buffer rings. If any of the buffer list has valid\n * SKB address, associated SKB is freed.\n */\nstatic void mwifiex_cleanup_rxq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->rxbd_ring[i];\n\t\t\tif (card->rx_buf_list[i]) {\n\t\t\t\tskb = card->rx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->rxbd_ring[i];\n\t\t\tif (card->rx_buf_list[i]) {\n\t\t\t\tskb = card->rx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tcard->rx_buf_list[i] = NULL;\n\t}\n\n\treturn;\n}\n\n/* This function cleans up event buffer rings. If any of the buffer list has\n * valid SKB address, associated SKB is freed.\n */\nstatic void mwifiex_cleanup_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tdesc = card->evtbd_ring[i];\n\t\tif (card->evt_buf_list[i]) {\n\t\t\tskb = card->evt_buf_list[i];\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t\tcard->evt_buf_list[i] = NULL;\n\t\tmemset(desc, 0, sizeof(*desc));\n\t}\n\n\treturn;\n}\n\n/* This function creates buffer descriptor ring for TX\n */\nstatic int mwifiex_pcie_create_txbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t/*\n\t * driver maintaines the write pointer and firmware maintaines the read\n\t * pointer. The write pointer starts at 0 (zero) while the read pointer\n\t * starts at zero with rollover bit set\n\t */\n\tcard->txbd_wrptr = 0;\n\n\tif (reg->pfu_enabled)\n\t\tcard->txbd_rdptr = 0;\n\telse\n\t\tcard->txbd_rdptr |= reg->tx_rollover_ind;\n\n\t/* allocate shared memory for the BD ring and divide the same in to\n\t   several descriptors */\n\tif (reg->pfu_enabled)\n\t\tcard->txbd_ring_size = sizeof(struct mwifiex_pfu_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\telse\n\t\tcard->txbd_ring_size = sizeof(struct mwifiex_pcie_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: txbd_ring: Allocating %d bytes\\n\",\n\t\t    card->txbd_ring_size);\n\tcard->txbd_ring_vbase = pci_alloc_consistent(card->dev,\n\t\t\t\t\t\t     card->txbd_ring_size,\n\t\t\t\t\t\t     &card->txbd_ring_pbase);\n\tif (!card->txbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate consistent memory (%d bytes) failed!\\n\",\n\t\t\t    card->txbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: txbd_ring - base: %p, pbase: %#x:%x, len: %x\\n\",\n\t\t    card->txbd_ring_vbase, (unsigned int)card->txbd_ring_pbase,\n\t\t    (u32)((u64)card->txbd_ring_pbase >> 32),\n\t\t    card->txbd_ring_size);\n\n\treturn mwifiex_init_txq_ring(adapter);\n}\n\nstatic int mwifiex_pcie_delete_txbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_txq_ring(adapter);\n\n\tif (card->txbd_ring_vbase)\n\t\tpci_free_consistent(card->dev, card->txbd_ring_size,\n\t\t\t\t    card->txbd_ring_vbase,\n\t\t\t\t    card->txbd_ring_pbase);\n\tcard->txbd_ring_size = 0;\n\tcard->txbd_wrptr = 0;\n\tcard->txbd_rdptr = 0 | reg->tx_rollover_ind;\n\tcard->txbd_ring_vbase = NULL;\n\tcard->txbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n/*\n * This function creates buffer descriptor ring for RX\n */\nstatic int mwifiex_pcie_create_rxbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t/*\n\t * driver maintaines the read pointer and firmware maintaines the write\n\t * pointer. The write pointer starts at 0 (zero) while the read pointer\n\t * starts at zero with rollover bit set\n\t */\n\tcard->rxbd_wrptr = 0;\n\tcard->rxbd_rdptr = reg->rx_rollover_ind;\n\n\tif (reg->pfu_enabled)\n\t\tcard->rxbd_ring_size = sizeof(struct mwifiex_pfu_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\telse\n\t\tcard->rxbd_ring_size = sizeof(struct mwifiex_pcie_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: rxbd_ring: Allocating %d bytes\\n\",\n\t\t    card->rxbd_ring_size);\n\tcard->rxbd_ring_vbase = pci_alloc_consistent(card->dev,\n\t\t\t\t\t\t     card->rxbd_ring_size,\n\t\t\t\t\t\t     &card->rxbd_ring_pbase);\n\tif (!card->rxbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate consistent memory (%d bytes) failed!\\n\",\n\t\t\t    card->rxbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: rxbd_ring - base: %p, pbase: %#x:%x, len: %#x\\n\",\n\t\t    card->rxbd_ring_vbase, (u32)card->rxbd_ring_pbase,\n\t\t    (u32)((u64)card->rxbd_ring_pbase >> 32),\n\t\t    card->rxbd_ring_size);\n\n\treturn mwifiex_init_rxq_ring(adapter);\n}\n\n/*\n * This function deletes Buffer descriptor ring for RX\n */\nstatic int mwifiex_pcie_delete_rxbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_rxq_ring(adapter);\n\n\tif (card->rxbd_ring_vbase)\n\t\tpci_free_consistent(card->dev, card->rxbd_ring_size,\n\t\t\t\t    card->rxbd_ring_vbase,\n\t\t\t\t    card->rxbd_ring_pbase);\n\tcard->rxbd_ring_size = 0;\n\tcard->rxbd_wrptr = 0;\n\tcard->rxbd_rdptr = 0 | reg->rx_rollover_ind;\n\tcard->rxbd_ring_vbase = NULL;\n\tcard->rxbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n/*\n * This function creates buffer descriptor ring for Events\n */\nstatic int mwifiex_pcie_create_evtbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t/*\n\t * driver maintaines the read pointer and firmware maintaines the write\n\t * pointer. The write pointer starts at 0 (zero) while the read pointer\n\t * starts at zero with rollover bit set\n\t */\n\tcard->evtbd_wrptr = 0;\n\tcard->evtbd_rdptr = reg->evt_rollover_ind;\n\n\tcard->evtbd_ring_size = sizeof(struct mwifiex_evt_buf_desc) *\n\t\t\t\tMWIFIEX_MAX_EVT_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: evtbd_ring: Allocating %d bytes\\n\",\n\t\tcard->evtbd_ring_size);\n\tcard->evtbd_ring_vbase = pci_alloc_consistent(card->dev,\n\t\t\t\t\t\t      card->evtbd_ring_size,\n\t\t\t\t\t\t      &card->evtbd_ring_pbase);\n\tif (!card->evtbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate consistent memory (%d bytes) failed!\\n\",\n\t\t\t    card->evtbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: CMDRSP/EVT bd_ring - base: %p pbase: %#x:%x len: %#x\\n\",\n\t\t    card->evtbd_ring_vbase, (u32)card->evtbd_ring_pbase,\n\t\t    (u32)((u64)card->evtbd_ring_pbase >> 32),\n\t\t    card->evtbd_ring_size);\n\n\treturn mwifiex_pcie_init_evt_ring(adapter);\n}\n\n/*\n * This function deletes Buffer descriptor ring for Events\n */\nstatic int mwifiex_pcie_delete_evtbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_evt_ring(adapter);\n\n\tif (card->evtbd_ring_vbase)\n\t\tpci_free_consistent(card->dev, card->evtbd_ring_size,\n\t\t\t\t    card->evtbd_ring_vbase,\n\t\t\t\t    card->evtbd_ring_pbase);\n\tcard->evtbd_wrptr = 0;\n\tcard->evtbd_rdptr = 0 | reg->evt_rollover_ind;\n\tcard->evtbd_ring_size = 0;\n\tcard->evtbd_ring_vbase = NULL;\n\tcard->evtbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n/*\n * This function allocates a buffer for CMDRSP\n */\nstatic int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\n\t/* Allocate memory for receiving command response data */\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\n\tcard->cmdrsp_buf = skb;\n\n\treturn 0;\n}\n\n/*\n * This function deletes a buffer for CMDRSP\n */\nstatic int mwifiex_pcie_delete_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card;\n\n\tif (!adapter)\n\t\treturn 0;\n\n\tcard = adapter->card;\n\n\tif (card && card->cmdrsp_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmdrsp_buf,\n\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\tdev_kfree_skb_any(card->cmdrsp_buf);\n\t\tcard->cmdrsp_buf = NULL;\n\t}\n\n\tif (card && card->cmd_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmd_buf,\n\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\tdev_kfree_skb_any(card->cmd_buf);\n\t\tcard->cmd_buf = NULL;\n\t}\n\treturn 0;\n}\n\n/*\n * This function allocates a buffer for sleep cookie\n */\nstatic int mwifiex_pcie_alloc_sleep_cookie_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tu32 tmp;\n\n\tcard->sleep_cookie_vbase = pci_alloc_consistent(card->dev, sizeof(u32),\n\t\t\t\t\t\t     &card->sleep_cookie_pbase);\n\tif (!card->sleep_cookie_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"pci_alloc_consistent failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t/* Init val of Sleep Cookie */\n\ttmp = FW_AWAKE_COOKIE;\n\tput_unaligned(tmp, card->sleep_cookie_vbase);\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"alloc_scook: sleep cookie=0x%x\\n\",\n\t\t    get_unaligned(card->sleep_cookie_vbase));\n\n\treturn 0;\n}\n\n/*\n * This function deletes buffer for sleep cookie\n */\nstatic int mwifiex_pcie_delete_sleep_cookie_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card;\n\n\tif (!adapter)\n\t\treturn 0;\n\n\tcard = adapter->card;\n\n\tif (card && card->sleep_cookie_vbase) {\n\t\tpci_free_consistent(card->dev, sizeof(u32),\n\t\t\t\t    card->sleep_cookie_vbase,\n\t\t\t\t    card->sleep_cookie_pbase);\n\t\tcard->sleep_cookie_vbase = NULL;\n\t}\n\n\treturn 0;\n}\n\n/* This function flushes the TX buffer descriptor ring\n * This function defined as handler is also called while cleaning TXRX\n * during disconnect/ bss stop.\n */\nstatic int mwifiex_clean_pcie_ring_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!mwifiex_pcie_txbd_empty(card, card->txbd_rdptr)) {\n\t\tcard->txbd_flush = 1;\n\t\t/* write pointer already set at last send\n\t\t * send dnld-rdy intr again, wait for completion.\n\t\t */\n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_DNLD_RDY)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"failed to assert dnld-rdy interrupt.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * This function unmaps and frees downloaded data buffer\n */\nstatic int mwifiex_pcie_send_data_complete(struct mwifiex_adapter *adapter)\n{\n\tstruct sk_buff *skb;\n\tu32 wrdoneidx, rdptr, num_tx_buffs, unmap_count = 0;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\t/* Read the TX ring read pointer set by firmware */\n\tif (mwifiex_read_reg(adapter, reg->tx_rdptr, &rdptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"SEND COMP: failed to read reg->tx_rdptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"SEND COMP: rdptr_prev=0x%x, rdptr=0x%x\\n\",\n\t\t    card->txbd_rdptr, rdptr);\n\n\tnum_tx_buffs = MWIFIEX_MAX_TXRX_BD << reg->tx_start_ptr;\n\t/* free from previous txbd_rdptr to current txbd_rdptr */\n\twhile (((card->txbd_rdptr & reg->tx_mask) !=\n\t\t(rdptr & reg->tx_mask)) ||\n\t       ((card->txbd_rdptr & reg->tx_rollover_ind) !=\n\t\t(rdptr & reg->tx_rollover_ind))) {\n\t\twrdoneidx = (card->txbd_rdptr & reg->tx_mask) >>\n\t\t\t    reg->tx_start_ptr;\n\n\t\tskb = card->tx_buf_list[wrdoneidx];\n\n\t\tif (skb) {\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"SEND COMP: Detach skb %p at txbd_rdidx=%d\\n\",\n\t\t\t\t    skb, wrdoneidx);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\n\t\t\tunmap_count++;\n\n\t\t\tif (card->txbd_flush)\n\t\t\t\tmwifiex_write_data_complete(adapter, skb, 0,\n\t\t\t\t\t\t\t    -1);\n\t\t\telse\n\t\t\t\tmwifiex_write_data_complete(adapter, skb, 0, 0);\n\t\t\tatomic_dec(&adapter->tx_hw_pending);\n\t\t}\n\n\t\tcard->tx_buf_list[wrdoneidx] = NULL;\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[wrdoneidx];\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[wrdoneidx];\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tswitch (card->dev->device) {\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\t\tcard->txbd_rdptr++;\n\t\t\tbreak;\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\t\tcard->txbd_rdptr += reg->ring_tx_start_ptr;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tif ((card->txbd_rdptr & reg->tx_mask) == num_tx_buffs)\n\t\t\tcard->txbd_rdptr = ((card->txbd_rdptr &\n\t\t\t\t\t     reg->tx_rollover_ind) ^\n\t\t\t\t\t     reg->tx_rollover_ind);\n\t}\n\n\tif (unmap_count)\n\t\tadapter->data_sent = false;\n\n\tif (card->txbd_flush) {\n\t\tif (mwifiex_pcie_txbd_empty(card, card->txbd_rdptr))\n\t\t\tcard->txbd_flush = 0;\n\t\telse\n\t\t\tmwifiex_clean_pcie_ring_buf(adapter);\n\t}\n\n\treturn 0;\n}\n\n/* This function sends data buffer to device. First 4 bytes of payload\n * are filled with payload length and payload type. Then this payload\n * is mapped to PCI device memory. Tx ring pointers are advanced accordingly.\n * Download ready interrupt to FW is deffered if Tx ring is not full and\n * additional payload can be accomodated.\n * Caller must ensure tx_param parameter to this function is not NULL.\n */\nstatic int\nmwifiex_pcie_send_data(struct mwifiex_adapter *adapter, struct sk_buff *skb,\n\t\t       struct mwifiex_tx_param *tx_param)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 wrindx, num_tx_buffs, rx_val;\n\tint ret;\n\tdma_addr_t buf_pa;\n\tstruct mwifiex_pcie_buf_desc *desc = NULL;\n\tstruct mwifiex_pfu_buf_desc *desc2 = NULL;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s(): invalid parameter <%p, %#x>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tnum_tx_buffs = MWIFIEX_MAX_TXRX_BD << reg->tx_start_ptr;\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: SEND DATA: <Rd: %#x, Wr: %#x>\\n\",\n\t\tcard->txbd_rdptr, card->txbd_wrptr);\n\tif (mwifiex_pcie_txbd_not_full(card)) {\n\t\tu8 *payload;\n\n\t\tadapter->data_sent = true;\n\t\tpayload = skb->data;\n\t\tput_unaligned_le16((u16)skb->len, payload + 0);\n\t\tput_unaligned_le16(MWIFIEX_TYPE_DATA, payload + 2);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, skb->len,\n\t\t\t\t\t   PCI_DMA_TODEVICE))\n\t\t\treturn -1;\n\n\t\twrindx = (card->txbd_wrptr & reg->tx_mask) >> reg->tx_start_ptr;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tcard->tx_buf_list[wrindx] = skb;\n\t\tatomic_inc(&adapter->tx_hw_pending);\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[wrindx];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = (u16)skb->len;\n\t\t\tdesc2->frag_len = (u16)skb->len;\n\t\t\tdesc2->offset = 0;\n\t\t\tdesc2->flags = MWIFIEX_BD_FLAG_FIRST_DESC |\n\t\t\t\t\t MWIFIEX_BD_FLAG_LAST_DESC;\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[wrindx];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = (u16)skb->len;\n\t\t\tdesc->flags = MWIFIEX_BD_FLAG_FIRST_DESC |\n\t\t\t\t      MWIFIEX_BD_FLAG_LAST_DESC;\n\t\t}\n\n\t\tswitch (card->dev->device) {\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\t\tcard->txbd_wrptr++;\n\t\t\tbreak;\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\t\tcard->txbd_wrptr += reg->ring_tx_start_ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((card->txbd_wrptr & reg->tx_mask) == num_tx_buffs)\n\t\t\tcard->txbd_wrptr = ((card->txbd_wrptr &\n\t\t\t\t\t\treg->tx_rollover_ind) ^\n\t\t\t\t\t\treg->tx_rollover_ind);\n\n\t\trx_val = card->rxbd_rdptr & reg->rx_wrap_mask;\n\t\t/* Write the TX ring write pointer in to reg->tx_wrptr */\n\t\tif (mwifiex_write_reg(adapter, reg->tx_wrptr,\n\t\t\t\t      card->txbd_wrptr | rx_val)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SEND DATA: failed to write reg->tx_wrptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done_unmap;\n\t\t}\n\t\tif ((mwifiex_pcie_txbd_not_full(card)) &&\n\t\t    tx_param->next_pkt_len) {\n\t\t\t/* have more packets and TxBD still can hold more */\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"SEND DATA: delay dnld-rdy interrupt.\\n\");\n\t\t\tadapter->data_sent = false;\n\t\t} else {\n\t\t\t/* Send the TX ready interrupt */\n\t\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t\t      CPU_INTR_DNLD_RDY)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"SEND DATA: failed to assert dnld-rdy interrupt.\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done_unmap;\n\t\t\t}\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: SEND DATA: Updated <Rd: %#x, Wr:\\t\"\n\t\t\t    \"%#x> and sent packet to firmware successfully\\n\",\n\t\t\t    card->txbd_rdptr, card->txbd_wrptr);\n\t} else {\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: TX Ring full, can't send packets to fw\\n\");\n\t\tadapter->data_sent = true;\n\t\t/* Send the TX ready interrupt */\n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_DNLD_RDY))\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SEND DATA: failed to assert door-bell intr\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn -EINPROGRESS;\ndone_unmap:\n\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\tcard->tx_buf_list[wrindx] = NULL;\n\tatomic_dec(&adapter->tx_hw_pending);\n\tif (reg->pfu_enabled)\n\t\tmemset(desc2, 0, sizeof(*desc2));\n\telse\n\t\tmemset(desc, 0, sizeof(*desc));\n\n\treturn ret;\n}\n\n/*\n * This function handles received buffer ring and\n * dispatches packets to upper\n */\nstatic int mwifiex_pcie_process_recv_data(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 wrptr, rd_index, tx_val;\n\tdma_addr_t buf_pa;\n\tint ret = 0;\n\tstruct sk_buff *skb_tmp = NULL;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\t/* Read the RX ring Write pointer set by firmware */\n\tif (mwifiex_read_reg(adapter, reg->rx_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"RECV DATA: failed to read reg->rx_wrptr\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tcard->rxbd_wrptr = wrptr;\n\n\twhile (((wrptr & reg->rx_mask) !=\n\t\t(card->rxbd_rdptr & reg->rx_mask)) ||\n\t       ((wrptr & reg->rx_rollover_ind) ==\n\t\t(card->rxbd_rdptr & reg->rx_rollover_ind))) {\n\t\tstruct sk_buff *skb_data;\n\t\tu16 rx_len;\n\n\t\trd_index = card->rxbd_rdptr & reg->rx_mask;\n\t\tskb_data = card->rx_buf_list[rd_index];\n\n\t\t/* If skb allocation was failed earlier for Rx packet,\n\t\t * rx_buf_list[rd_index] would have been left with a NULL.\n\t\t */\n\t\tif (!skb_data)\n\t\t\treturn -ENOMEM;\n\n\t\tmwifiex_unmap_pci_memory(adapter, skb_data, PCI_DMA_FROMDEVICE);\n\t\tcard->rx_buf_list[rd_index] = NULL;\n\n\t\t/* Get data length from interface header -\n\t\t * first 2 bytes for len, next 2 bytes is for type\n\t\t */\n\t\trx_len = get_unaligned_le16(skb_data->data);\n\t\tif (WARN_ON(rx_len <= adapter->intf_hdr_len ||\n\t\t\t    rx_len > MWIFIEX_RX_DATA_BUF_SIZE)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Invalid RX len %d, Rd=%#x, Wr=%#x\\n\",\n\t\t\t\t    rx_len, card->rxbd_rdptr, wrptr);\n\t\t\tdev_kfree_skb_any(skb_data);\n\t\t} else {\n\t\t\tskb_put(skb_data, rx_len);\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"info: RECV DATA: Rd=%#x, Wr=%#x, Len=%d\\n\",\n\t\t\t\t    card->rxbd_rdptr, wrptr, rx_len);\n\t\t\tskb_pull(skb_data, adapter->intf_hdr_len);\n\t\t\tif (adapter->rx_work_enabled) {\n\t\t\t\tskb_queue_tail(&adapter->rx_data_q, skb_data);\n\t\t\t\tadapter->data_received = true;\n\t\t\t\tatomic_inc(&adapter->rx_pending);\n\t\t\t} else {\n\t\t\t\tmwifiex_handle_rx_packet(adapter, skb_data);\n\t\t\t}\n\t\t}\n\n\t\tskb_tmp = mwifiex_alloc_dma_align_buf(MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!skb_tmp) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb_tmp,\n\t\t\t\t\t   MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb_tmp);\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"RECV DATA: Attach new sk_buff %p at rxbd_rdidx=%d\\n\",\n\t\t\t    skb_tmp, rd_index);\n\t\tcard->rx_buf_list[rd_index] = skb_tmp;\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->rxbd_ring[rd_index];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = skb_tmp->len;\n\t\t\tdesc2->frag_len = skb_tmp->len;\n\t\t\tdesc2->offset = 0;\n\t\t\tdesc2->flags = reg->ring_flag_sop | reg->ring_flag_eop;\n\t\t} else {\n\t\t\tdesc = card->rxbd_ring[rd_index];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = skb_tmp->len;\n\t\t\tdesc->flags = 0;\n\t\t}\n\n\t\tif ((++card->rxbd_rdptr & reg->rx_mask) ==\n\t\t\t\t\t\t\tMWIFIEX_MAX_TXRX_BD) {\n\t\t\tcard->rxbd_rdptr = ((card->rxbd_rdptr &\n\t\t\t\t\t     reg->rx_rollover_ind) ^\n\t\t\t\t\t     reg->rx_rollover_ind);\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: RECV DATA: <Rd: %#x, Wr: %#x>\\n\",\n\t\t\t    card->rxbd_rdptr, wrptr);\n\n\t\ttx_val = card->txbd_wrptr & reg->tx_wrap_mask;\n\t\t/* Write the RX ring read pointer in to reg->rx_rdptr */\n\t\tif (mwifiex_write_reg(adapter, reg->rx_rdptr,\n\t\t\t\t      card->rxbd_rdptr | tx_val)) {\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"RECV DATA: failed to write reg->rx_rdptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Read the RX ring Write pointer set by firmware */\n\t\tif (mwifiex_read_reg(adapter, reg->rx_wrptr, &wrptr)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"RECV DATA: failed to read reg->rx_wrptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: RECV DATA: Rcvd packet from fw successfully\\n\");\n\t\tcard->rxbd_wrptr = wrptr;\n\t}\n\ndone:\n\treturn ret;\n}\n\n/*\n * This function downloads the boot command to device\n */\nstatic int\nmwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)\n{\n\tdma_addr_t buf_pa;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Invalid parameter in %s <%p. len %d>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_map_pci_memory(adapter, skb, skb->len, PCI_DMA_TODEVICE))\n\t\treturn -1;\n\n\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t/* Write the lower 32bits of the physical address to low command\n\t * address scratch register\n\t */\n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_lo, (u32)buf_pa)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write download command to boot code.\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\t\treturn -1;\n\t}\n\n\t/* Write the upper 32bits of the physical address to high command\n\t * address scratch register\n\t */\n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_hi,\n\t\t\t      (u32)((u64)buf_pa >> 32))) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write download command to boot code.\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\t\treturn -1;\n\t}\n\n\t/* Write the command length to cmd_size scratch register */\n\tif (mwifiex_write_reg(adapter, reg->cmd_size, skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write command len to cmd_size scratch reg\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\t\treturn -1;\n\t}\n\n\t/* Ring the door bell */\n\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t      CPU_INTR_DOOR_BELL)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to assert door-bell intr\\n\", __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* This function init rx port in firmware which in turn enables to receive data\n * from device before transmitting any packet.\n */\nstatic int mwifiex_pcie_init_fw_port(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint tx_wrap = card->txbd_wrptr & reg->tx_wrap_mask;\n\n\t/* Write the RX ring read pointer in to reg->rx_rdptr */\n\tif (mwifiex_write_reg(adapter, reg->rx_rdptr, card->rxbd_rdptr |\n\t\t\t      tx_wrap)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"RECV DATA: failed to write reg->rx_rdptr\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* This function downloads commands to the device\n */\nstatic int\nmwifiex_pcie_send_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret = 0;\n\tdma_addr_t cmd_buf_pa, cmdrsp_buf_pa;\n\tu8 *payload = (u8 *)skb->data;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Invalid parameter in %s <%p, %#x>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\t/* Make sure a command response buffer is available */\n\tif (!card->cmdrsp_buf) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"No response buffer available, send command failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tadapter->cmd_sent = true;\n\n\tput_unaligned_le16((u16)skb->len, &payload[0]);\n\tput_unaligned_le16(MWIFIEX_TYPE_CMD, &payload[2]);\n\n\tif (mwifiex_map_pci_memory(adapter, skb, skb->len, PCI_DMA_TODEVICE))\n\t\treturn -1;\n\n\tcard->cmd_buf = skb;\n\t/*\n\t * Need to keep a reference, since core driver might free up this\n\t * buffer before we've unmapped it.\n\t */\n\tskb_get(skb);\n\n\t/* To send a command, the driver will:\n\t\t1. Write the 64bit physical address of the data buffer to\n\t\t   cmd response address low  + cmd response address high\n\t\t2. Ring the door bell (i.e. set the door bell interrupt)\n\n\t\tIn response to door bell interrupt, the firmware will perform\n\t\tthe DMA of the command packet (first header to obtain the total\n\t\tlength and then rest of the command).\n\t*/\n\n\tif (card->cmdrsp_buf) {\n\t\tcmdrsp_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmdrsp_buf);\n\t\t/* Write the lower 32bits of the cmdrsp buffer physical\n\t\t   address */\n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_lo,\n\t\t\t\t      (u32)cmdrsp_buf_pa)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t\t/* Write the upper 32bits of the cmdrsp buffer physical\n\t\t   address */\n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_hi,\n\t\t\t\t      (u32)((u64)cmdrsp_buf_pa >> 32))) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tcmd_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmd_buf);\n\t/* Write the lower 32bits of the physical address to reg->cmd_addr_lo */\n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_lo,\n\t\t\t      (u32)cmd_buf_pa)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\t/* Write the upper 32bits of the physical address to reg->cmd_addr_hi */\n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_hi,\n\t\t\t      (u32)((u64)cmd_buf_pa >> 32))) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/* Write the command length to reg->cmd_size */\n\tif (mwifiex_write_reg(adapter, reg->cmd_size,\n\t\t\t      card->cmd_buf->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write cmd len to reg->cmd_size\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/* Ring the door bell */\n\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t      CPU_INTR_DOOR_BELL)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to assert door-bell intr\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\ndone:\n\tif (ret)\n\t\tadapter->cmd_sent = false;\n\n\treturn 0;\n}\n\n/*\n * This function handles command complete interrupt\n */\nstatic int mwifiex_pcie_process_cmd_complete(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb = card->cmdrsp_buf;\n\tint count = 0;\n\tu16 rx_len;\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"info: Rx CMD Response\\n\");\n\n\tif (adapter->curr_cmd)\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_FROMDEVICE);\n\telse\n\t\tpci_dma_sync_single_for_cpu(card->dev,\n\t\t\t\t\t    MWIFIEX_SKB_DMA_ADDR(skb),\n\t\t\t\t\t    MWIFIEX_UPLD_SIZE,\n\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\n\t/* Unmap the command as a response has been received. */\n\tif (card->cmd_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmd_buf,\n\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\tdev_kfree_skb_any(card->cmd_buf);\n\t\tcard->cmd_buf = NULL;\n\t}\n\n\trx_len = get_unaligned_le16(skb->data);\n\tskb_put(skb, MWIFIEX_UPLD_SIZE - skb->len);\n\tskb_trim(skb, rx_len);\n\n\tif (!adapter->curr_cmd) {\n\t\tif (adapter->ps_state == PS_STATE_SLEEP_CFM) {\n\t\t\tpci_dma_sync_single_for_device(card->dev,\n\t\t\t\t\t\tMWIFIEX_SKB_DMA_ADDR(skb),\n\t\t\t\t\t\tMWIFIEX_SLEEP_COOKIE_SIZE,\n\t\t\t\t\t\tPCI_DMA_FROMDEVICE);\n\t\t\tif (mwifiex_write_reg(adapter,\n\t\t\t\t\t      PCIE_CPU_INT_EVENT,\n\t\t\t\t\t      CPU_INTR_SLEEP_CFM_DONE)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"Write register failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmwifiex_delay_for_sleep_cookie(adapter,\n\t\t\t\t\t\t       MWIFIEX_MAX_DELAY_COUNT);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\tskb_pull(skb, adapter->intf_hdr_len);\n\t\t\twhile (reg->sleep_cookie && (count++ < 10) &&\n\t\t\t       mwifiex_pcie_ok_to_access_hw(adapter))\n\t\t\t\tusleep_range(50, 60);\n\t\t\tmwifiex_pcie_enable_host_int(adapter);\n\t\t\tmwifiex_process_sleep_confirm_resp(adapter, skb->data,\n\t\t\t\t\t\t\t   skb->len);\n\t\t} else {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"There is no command but got cmdrsp\\n\");\n\t\t}\n\t\tmemcpy(adapter->upld_buf, skb->data,\n\t\t       min_t(u32, MWIFIEX_SIZE_OF_CMD_BUFFER, skb->len));\n\t\tskb_push(skb, adapter->intf_hdr_len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t} else if (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\tskb_pull(skb, adapter->intf_hdr_len);\n\t\tadapter->curr_cmd->resp_skb = skb;\n\t\tadapter->cmd_resp_received = true;\n\t\t/* Take the pointer and set it to CMD node and will\n\t\t   return in the response complete callback */\n\t\tcard->cmdrsp_buf = NULL;\n\n\t\t/* Clear the cmd-rsp buffer address in scratch registers. This\n\t\t   will prevent firmware from writing to the same response\n\t\t   buffer again. */\n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_lo, 0)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cmd_done: failed to clear cmd_rsp_addr_lo\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* Write the upper 32bits of the cmdrsp buffer physical\n\t\t   address */\n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_hi, 0)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cmd_done: failed to clear cmd_rsp_addr_hi\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Command Response processing complete handler\n */\nstatic int mwifiex_pcie_cmdrsp_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (skb) {\n\t\tcard->cmdrsp_buf = skb;\n\t\tskb_push(card->cmdrsp_buf, adapter->intf_hdr_len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function handles firmware event ready interrupt\n */\nstatic int mwifiex_pcie_process_event_ready(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;\n\tu32 wrptr, event;\n\tstruct mwifiex_evt_buf_desc *desc;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tif (adapter->event_received) {\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: Event being processed,\\t\"\n\t\t\t    \"do not process this interrupt just yet\\n\");\n\t\treturn 0;\n\t}\n\n\tif (rdptr >= MWIFIEX_MAX_EVT_BD) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"info: Invalid read pointer...\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Read the event ring write pointer set by firmware */\n\tif (mwifiex_read_reg(adapter, reg->evt_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"EventReady: failed to read reg->evt_wrptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: EventReady: Initial <Rd: 0x%x, Wr: 0x%x>\",\n\t\t    card->evtbd_rdptr, wrptr);\n\tif (((wrptr & MWIFIEX_EVTBD_MASK) != (card->evtbd_rdptr\n\t\t\t\t\t      & MWIFIEX_EVTBD_MASK)) ||\n\t    ((wrptr & reg->evt_rollover_ind) ==\n\t     (card->evtbd_rdptr & reg->evt_rollover_ind))) {\n\t\tstruct sk_buff *skb_cmd;\n\t\t__le16 data_len = 0;\n\t\tu16 evt_len;\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Read Index: %d\\n\", rdptr);\n\t\tskb_cmd = card->evt_buf_list[rdptr];\n\t\tmwifiex_unmap_pci_memory(adapter, skb_cmd, PCI_DMA_FROMDEVICE);\n\n\t\t/* Take the pointer and set it to event pointer in adapter\n\t\t   and will return back after event handling callback */\n\t\tcard->evt_buf_list[rdptr] = NULL;\n\t\tdesc = card->evtbd_ring[rdptr];\n\t\tmemset(desc, 0, sizeof(*desc));\n\n\t\tevent = get_unaligned_le32(\n\t\t\t&skb_cmd->data[adapter->intf_hdr_len]);\n\t\tadapter->event_cause = event;\n\t\t/* The first 4bytes will be the event transfer header\n\t\t   len is 2 bytes followed by type which is 2 bytes */\n\t\tmemcpy(&data_len, skb_cmd->data, sizeof(__le16));\n\t\tevt_len = le16_to_cpu(data_len);\n\t\tskb_trim(skb_cmd, evt_len);\n\t\tskb_pull(skb_cmd, adapter->intf_hdr_len);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: Event length: %d\\n\", evt_len);\n\n\t\tif (evt_len > MWIFIEX_EVENT_HEADER_LEN &&\n\t\t    evt_len < MAX_EVENT_SIZE)\n\t\t\tmemcpy(adapter->event_body, skb_cmd->data +\n\t\t\t       MWIFIEX_EVENT_HEADER_LEN, evt_len -\n\t\t\t       MWIFIEX_EVENT_HEADER_LEN);\n\n\t\tadapter->event_received = true;\n\t\tadapter->event_skb = skb_cmd;\n\n\t\t/* Do not update the event read pointer here, wait till the\n\t\t   buffer is released. This is just to make things simpler,\n\t\t   we need to find a better method of managing these buffers.\n\t\t*/\n\t} else {\n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_EVENT_DONE)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Write register failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Event processing complete handler\n */\nstatic int mwifiex_pcie_event_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret = 0;\n\tu32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;\n\tu32 wrptr;\n\tstruct mwifiex_evt_buf_desc *desc;\n\n\tif (!skb)\n\t\treturn 0;\n\n\tif (rdptr >= MWIFIEX_MAX_EVT_BD) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: Invalid rdptr 0x%x\\n\",\n\t\t\t    rdptr);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read the event ring write pointer set by firmware */\n\tif (mwifiex_read_reg(adapter, reg->evt_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: failed to read reg->evt_wrptr\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!card->evt_buf_list[rdptr]) {\n\t\tskb_push(skb, adapter->intf_hdr_len);\n\t\tskb_put(skb, MAX_EVENT_SIZE - skb->len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb,\n\t\t\t\t\t   MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tcard->evt_buf_list[rdptr] = skb;\n\t\tdesc = card->evtbd_ring[rdptr];\n\t\tdesc->paddr = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t\tskb = NULL;\n\t} else {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"info: ERROR: buf still valid at index %d, <%p, %p>\\n\",\n\t\t\t    rdptr, card->evt_buf_list[rdptr], skb);\n\t}\n\n\tif ((++card->evtbd_rdptr & MWIFIEX_EVTBD_MASK) == MWIFIEX_MAX_EVT_BD) {\n\t\tcard->evtbd_rdptr = ((card->evtbd_rdptr &\n\t\t\t\t\treg->evt_rollover_ind) ^\n\t\t\t\t\treg->evt_rollover_ind);\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: Updated <Rd: 0x%x, Wr: 0x%x>\",\n\t\t    card->evtbd_rdptr, wrptr);\n\n\t/* Write the event ring read pointer in to reg->evt_rdptr */\n\tif (mwifiex_write_reg(adapter, reg->evt_rdptr,\n\t\t\t      card->evtbd_rdptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: failed to read reg->evt_rdptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: Check Events Again\\n\");\n\tret = mwifiex_pcie_process_event_ready(adapter);\n\n\treturn ret;\n}\n\n/* Combo firmware image is a combination of\n * (1) combo crc heaer, start with CMD5\n * (2) bluetooth image, start with CMD7, end with CMD6, data wrapped in CMD1.\n * (3) wifi image.\n *\n * This function bypass the header and bluetooth part, return\n * the offset of tail wifi-only part. If the image is already wifi-only,\n * that is start with CMD1, return 0.\n */\n\nstatic int mwifiex_extract_wifi_fw(struct mwifiex_adapter *adapter,\n\t\t\t\t   const void *firmware, u32 firmware_len) {\n\tconst struct mwifiex_fw_data *fwdata;\n\tu32 offset = 0, data_len, dnld_cmd;\n\tint ret = 0;\n\tbool cmd7_before = false, first_cmd = false;\n\n\twhile (1) {\n\t\t/* Check for integer and buffer overflow */\n\t\tif (offset + sizeof(fwdata->header) < sizeof(fwdata->header) ||\n\t\t    offset + sizeof(fwdata->header) >= firmware_len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"extract wifi-only fw failure!\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfwdata = firmware + offset;\n\t\tdnld_cmd = le32_to_cpu(fwdata->header.dnld_cmd);\n\t\tdata_len = le32_to_cpu(fwdata->header.data_length);\n\n\t\t/* Skip past header */\n\t\toffset += sizeof(fwdata->header);\n\n\t\tswitch (dnld_cmd) {\n\t\tcase MWIFIEX_FW_DNLD_CMD_1:\n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* Image start with cmd1, already wifi-only firmware */\n\t\t\tif (!first_cmd) {\n\t\t\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t\t\t    \"input wifi-only firmware\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!cmd7_before) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"no cmd7 before cmd1!\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tbreak;\n\t\tcase MWIFIEX_FW_DNLD_CMD_5:\n\t\t\tfirst_cmd = true;\n\t\t\t/* Check for integer overflow */\n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tbreak;\n\t\tcase MWIFIEX_FW_DNLD_CMD_6:\n\t\t\tfirst_cmd = true;\n\t\t\t/* Check for integer overflow */\n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tif (offset >= firmware_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"extract wifi-only fw failure!\\n\");\n\t\t\t\tret = -1;\n\t\t\t} else {\n\t\t\t\tret = offset;\n\t\t\t}\n\t\t\tgoto done;\n\t\tcase MWIFIEX_FW_DNLD_CMD_7:\n\t\t\tfirst_cmd = true;\n\t\t\tcmd7_before = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmwifiex_dbg(adapter, ERROR, \"unknown dnld_cmd %d\\n\",\n\t\t\t\t    dnld_cmd);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\treturn ret;\n}\n\n/*\n * This function downloads the firmware to the card.\n *\n * Firmware is downloaded to the card in blocks. Every block download\n * is tested for CRC errors, and retried a number of times before\n * returning failure.\n */\nstatic int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct mwifiex_fw_image *fw)\n{\n\tint ret;\n\tu8 *firmware = fw->fw_buf;\n\tu32 firmware_len = fw->fw_len;\n\tu32 offset = 0;\n\tstruct sk_buff *skb;\n\tu32 txlen, tx_blocks = 0, tries, len, val;\n\tu32 block_retry_cnt = 0;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!firmware || !firmware_len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"No firmware image found! Terminating download\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: Downloading FW image (%d bytes)\\n\",\n\t\t    firmware_len);\n\n\tif (mwifiex_pcie_disable_host_int(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: Disabling interrupts failed.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tret = mwifiex_read_reg(adapter, PCIE_SCRATCH_13_REG, &val);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, FATAL, \"Failed to read scratch register 13\\n\");\n\t\tgoto done;\n\t}\n\n\t/* PCIE FLR case: extract wifi part from combo firmware*/\n\tif (val == MWIFIEX_PCIE_FLR_HAPPENS) {\n\t\tret = mwifiex_extract_wifi_fw(adapter, firmware, firmware_len);\n\t\tif (ret < 0) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Failed to extract wifi fw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\toffset = ret;\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"info: dnld wifi firmware from %d bytes\\n\", offset);\n\t}\n\n\t/* Perform firmware data transfer */\n\tdo {\n\t\tu32 ireg_intr = 0;\n\n\t\t/* More data? */\n\t\tif (offset >= firmware_len)\n\t\t\tbreak;\n\n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tret = mwifiex_read_reg(adapter, reg->cmd_size,\n\t\t\t\t\t       &len);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, FATAL,\n\t\t\t\t\t    \"Failed reading len from boot code\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (len)\n\t\t\t\tbreak;\n\t\t\tusleep_range(10, 20);\n\t\t}\n\n\t\tif (!len) {\n\t\t\tbreak;\n\t\t} else if (len > MWIFIEX_UPLD_SIZE) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW download failure @ %d, invalid length %d\\n\",\n\t\t\t\t    offset, len);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttxlen = len;\n\n\t\tif (len & BIT(0)) {\n\t\t\tblock_retry_cnt++;\n\t\t\tif (block_retry_cnt > MAX_WRITE_IOMEM_RETRY) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"FW download failure @ %d, over max\\t\"\n\t\t\t\t\t    \"retry count\\n\", offset);\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW CRC error indicated by the\\t\"\n\t\t\t\t    \"helper: len = 0x%04X, txlen = %d\\n\",\n\t\t\t\t    len, txlen);\n\t\t\tlen &= ~BIT(0);\n\t\t\t/* Setting this to 0 to resend from same offset */\n\t\t\ttxlen = 0;\n\t\t} else {\n\t\t\tblock_retry_cnt = 0;\n\t\t\t/* Set blocksize to transfer - checking for\n\t\t\t   last block */\n\t\t\tif (firmware_len - offset < txlen)\n\t\t\t\ttxlen = firmware_len - offset;\n\n\t\t\ttx_blocks = (txlen + card->pcie.blksz_fw_dl - 1) /\n\t\t\t\t    card->pcie.blksz_fw_dl;\n\n\t\t\t/* Copy payload to buffer */\n\t\t\tmemmove(skb->data, &firmware[offset], txlen);\n\t\t}\n\n\t\tskb_put(skb, MWIFIEX_UPLD_SIZE - skb->len);\n\t\tskb_trim(skb, tx_blocks * card->pcie.blksz_fw_dl);\n\n\t\t/* Send the boot command to device */\n\t\tif (mwifiex_pcie_send_boot_cmd(adapter, skb)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to send firmware download command\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Wait for the command done interrupt */\n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tif (mwifiex_read_reg(adapter, PCIE_CPU_INT_STATUS,\n\t\t\t\t\t     &ireg_intr)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"%s: Failed to read\\t\"\n\t\t\t\t\t    \"interrupt status during fw dnld.\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (!(ireg_intr & CPU_INTR_DOOR_BELL))\n\t\t\t\tbreak;\n\t\t\tusleep_range(10, 20);\n\t\t}\n\t\tif (ireg_intr & CPU_INTR_DOOR_BELL) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"%s: Card failed to ACK download\\n\",\n\t\t\t\t    __func__);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\n\t\toffset += txlen;\n\t} while (true);\n\n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"info: FW download over, size %d bytes\\n\", offset);\n\n\tret = 0;\n\ndone:\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\n/*\n * This function checks the firmware status in card.\n */\nstatic int\nmwifiex_check_fw_status(struct mwifiex_adapter *adapter, u32 poll_num)\n{\n\tint ret = 0;\n\tu32 firmware_stat;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 tries;\n\n\t/* Mask spurios interrupts */\n\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_STATUS_MASK,\n\t\t\t      HOST_INTR_MASK)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Write register failed\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"Setting driver ready signature\\n\");\n\tif (mwifiex_write_reg(adapter, reg->drv_rdy,\n\t\t\t      FIRMWARE_READY_PCIE)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write driver ready signature\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Wait for firmware initialization event */\n\tfor (tries = 0; tries < poll_num; tries++) {\n\t\tif (mwifiex_read_reg(adapter, reg->fw_status,\n\t\t\t\t     &firmware_stat))\n\t\t\tret = -1;\n\t\telse\n\t\t\tret = 0;\n\n\t\tmwifiex_dbg(adapter, INFO, \"Try %d if FW is ready <%d,%#x>\",\n\t\t\t    tries, ret, firmware_stat);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tif (firmware_stat == FIRMWARE_READY_PCIE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tmsleep(100);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* This function checks if WLAN is the winner.\n */\nstatic int\nmwifiex_check_winner_status(struct mwifiex_adapter *adapter)\n{\n\tu32 winner = 0;\n\tint ret = 0;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &winner)) {\n\t\tret = -1;\n\t} else if (!winner) {\n\t\tmwifiex_dbg(adapter, INFO, \"PCI-E is the winner\\n\");\n\t\tadapter->winner = 1;\n\t} else {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PCI-E is not the winner <%#x>\", winner);\n\t}\n\n\treturn ret;\n}\n\n/*\n * This function reads the interrupt status from card.\n */\nstatic void mwifiex_interrupt_status(struct mwifiex_adapter *adapter,\n\t\t\t\t     int msg_id)\n{\n\tu32 pcie_ireg;\n\tunsigned long flags;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (card->msi_enable) {\n\t\tspin_lock_irqsave(&adapter->int_lock, flags);\n\t\tadapter->int_status = 1;\n\t\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\t\treturn;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\treturn;\n\n\tif (card->msix_enable && msg_id >= 0) {\n\t\tpcie_ireg = BIT(msg_id);\n\t} else {\n\t\tif (mwifiex_read_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t     &pcie_ireg)) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Read register failed\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pcie_ireg == 0xFFFFFFFF) || !pcie_ireg)\n\t\t\treturn;\n\n\n\t\tmwifiex_pcie_disable_host_int(adapter);\n\n\t\t/* Clear the pending interrupts */\n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t      ~pcie_ireg)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Write register failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!adapter->pps_uapsd_mode &&\n\t    adapter->ps_state == PS_STATE_SLEEP &&\n\t    mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t/* Potentially for PCIe we could get other\n\t\t * interrupts like shared. Don't change power\n\t\t * state until cookie is set\n\t\t */\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\tadapter->pm_wakeup_fw_try = false;\n\t\tdel_timer(&adapter->wakeup_timer);\n\t}\n\n\tspin_lock_irqsave(&adapter->int_lock, flags);\n\tadapter->int_status |= pcie_ireg;\n\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\tmwifiex_dbg(adapter, INTR, \"ireg: 0x%08x\\n\", pcie_ireg);\n}\n\n/*\n * Interrupt handler for PCIe root port\n *\n * This function reads the interrupt status from firmware and assigns\n * the main process in workqueue which will handle the interrupt.\n */\nstatic irqreturn_t mwifiex_pcie_interrupt(int irq, void *context)\n{\n\tstruct mwifiex_msix_context *ctx = context;\n\tstruct pci_dev *pdev = ctx->dev;\n\tstruct pcie_service_card *card;\n\tstruct mwifiex_adapter *adapter;\n\n\tcard = pci_get_drvdata(pdev);\n\n\tif (!card->adapter) {\n\t\tpr_err(\"info: %s: card=%p adapter=%p\\n\", __func__, card,\n\t\t       card ? card->adapter : NULL);\n\t\tgoto exit;\n\t}\n\tadapter = card->adapter;\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags))\n\t\tgoto exit;\n\n\tif (card->msix_enable)\n\t\tmwifiex_interrupt_status(adapter, ctx->msg_id);\n\telse\n\t\tmwifiex_interrupt_status(adapter, -1);\n\n\tmwifiex_queue_main_work(adapter);\n\nexit:\n\treturn IRQ_HANDLED;\n}\n\n/*\n * This function checks the current interrupt status.\n *\n * The following interrupts are checked and handled by this function -\n *      - Data sent\n *      - Command sent\n *      - Command received\n *      - Packets received\n *      - Events received\n *\n * In case of Rx packets received, the packets are uploaded from card to\n * host and processed accordingly.\n */\nstatic int mwifiex_process_int_status(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tu32 pcie_ireg = 0;\n\tunsigned long flags;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tspin_lock_irqsave(&adapter->int_lock, flags);\n\tif (!card->msi_enable) {\n\t\t/* Clear out unused interrupts */\n\t\tpcie_ireg = adapter->int_status;\n\t}\n\tadapter->int_status = 0;\n\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\n\tif (card->msi_enable) {\n\t\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t\tif (mwifiex_read_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t\t     &pcie_ireg)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"Read register failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((pcie_ireg != 0xFFFFFFFF) && (pcie_ireg)) {\n\t\t\t\tif (mwifiex_write_reg(adapter,\n\t\t\t\t\t\t      PCIE_HOST_INT_STATUS,\n\t\t\t\t\t\t      ~pcie_ireg)) {\n\t\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t\t    \"Write register failed\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (!adapter->pps_uapsd_mode &&\n\t\t\t\t    adapter->ps_state == PS_STATE_SLEEP) {\n\t\t\t\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\t\t\t\tadapter->pm_wakeup_fw_try = false;\n\t\t\t\t\tdel_timer(&adapter->wakeup_timer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pcie_ireg & HOST_INTR_DNLD_DONE) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: TX DNLD Done\\n\");\n\t\tret = mwifiex_pcie_send_data_complete(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_UPLD_RDY) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: Rx DATA\\n\");\n\t\tret = mwifiex_pcie_process_recv_data(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_EVENT_RDY) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: Rx EVENT\\n\");\n\t\tret = mwifiex_pcie_process_event_ready(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_CMD_DONE) {\n\t\tif (adapter->cmd_sent) {\n\t\t\tmwifiex_dbg(adapter, INTR,\n\t\t\t\t    \"info: CMD sent Interrupt\\n\");\n\t\t\tadapter->cmd_sent = false;\n\t\t}\n\t\t/* Handle command response */\n\t\tret = mwifiex_pcie_process_cmd_complete(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmwifiex_dbg(adapter, INTR,\n\t\t    \"info: cmd_sent=%d data_sent=%d\\n\",\n\t\t    adapter->cmd_sent, adapter->data_sent);\n\tif (!card->msi_enable && !card->msix_enable &&\n\t\t\t\t adapter->ps_state != PS_STATE_SLEEP)\n\t\tmwifiex_pcie_enable_host_int(adapter);\n\n\treturn 0;\n}\n\n/*\n * This function downloads data from driver to card.\n *\n * Both commands and data packets are transferred to the card by this\n * function.\n *\n * This function adds the PCIE specific header to the front of the buffer\n * before transferring. The header contains the length of the packet and\n * the type. The firmware handles the packets based upon this set type.\n */\nstatic int mwifiex_pcie_host_to_card(struct mwifiex_adapter *adapter, u8 type,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     struct mwifiex_tx_param *tx_param)\n{\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Passed NULL skb to %s\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (type == MWIFIEX_TYPE_DATA)\n\t\treturn mwifiex_pcie_send_data(adapter, skb, tx_param);\n\telse if (type == MWIFIEX_TYPE_CMD)\n\t\treturn mwifiex_pcie_send_cmd(adapter, skb);\n\n\treturn 0;\n}\n\n/* Function to dump PCIE scratch registers in case of FW crash\n */\nstatic int\nmwifiex_pcie_reg_dump(struct mwifiex_adapter *adapter, char *drv_buf)\n{\n\tchar *p = drv_buf;\n\tchar buf[256], *ptr;\n\tint i;\n\tu32 value;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint pcie_scratch_reg[] = {PCIE_SCRATCH_12_REG,\n\t\t\t\t  PCIE_SCRATCH_14_REG,\n\t\t\t\t  PCIE_SCRATCH_15_REG};\n\n\tif (!p)\n\t\treturn 0;\n\n\tmwifiex_dbg(adapter, MSG, \"PCIE register dump start\\n\");\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &value)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"failed to read firmware status\");\n\t\treturn 0;\n\t}\n\n\tptr = buf;\n\tmwifiex_dbg(adapter, MSG, \"pcie scratch register:\");\n\tfor (i = 0; i < ARRAY_SIZE(pcie_scratch_reg); i++) {\n\t\tmwifiex_read_reg(adapter, pcie_scratch_reg[i], &value);\n\t\tptr += sprintf(ptr, \"reg:0x%x, value=0x%x\\n\",\n\t\t\t       pcie_scratch_reg[i], value);\n\t}\n\n\tmwifiex_dbg(adapter, MSG, \"%s\\n\", buf);\n\tp += sprintf(p, \"%s\\n\", buf);\n\n\tmwifiex_dbg(adapter, MSG, \"PCIE register dump end\\n\");\n\n\treturn p - drv_buf;\n}\n\n/* This function read/write firmware */\nstatic enum rdwr_status\nmwifiex_pcie_rdwr_firmware(struct mwifiex_adapter *adapter, u8 doneflag)\n{\n\tint ret, tries;\n\tu8 ctrl_data;\n\tu32 fw_status;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &fw_status))\n\t\treturn RDWR_STATUS_FAILURE;\n\n\tret = mwifiex_write_reg(adapter, reg->fw_dump_ctrl,\n\t\t\t\treg->fw_dump_host_ready);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PCIE write err\\n\");\n\t\treturn RDWR_STATUS_FAILURE;\n\t}\n\n\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\tmwifiex_read_reg_byte(adapter, reg->fw_dump_ctrl, &ctrl_data);\n\t\tif (ctrl_data == FW_DUMP_DONE)\n\t\t\treturn RDWR_STATUS_SUCCESS;\n\t\tif (doneflag && ctrl_data == doneflag)\n\t\t\treturn RDWR_STATUS_DONE;\n\t\tif (ctrl_data != reg->fw_dump_host_ready) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"The ctrl reg was changed, re-try again!\\n\");\n\t\t\tret = mwifiex_write_reg(adapter, reg->fw_dump_ctrl,\n\t\t\t\t\t\treg->fw_dump_host_ready);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"PCIE write err\\n\");\n\t\t\t\treturn RDWR_STATUS_FAILURE;\n\t\t\t}\n\t\t}\n\t\tusleep_range(100, 200);\n\t}\n\n\tmwifiex_dbg(adapter, ERROR, \"Fail to pull ctrl_data\\n\");\n\treturn RDWR_STATUS_FAILURE;\n}\n\n/* This function dump firmware memory to file */\nstatic void mwifiex_pcie_fw_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *creg = card->pcie.reg;\n\tunsigned int reg, reg_start, reg_end;\n\tu8 *dbg_ptr, *end_ptr, *tmp_ptr, fw_dump_num, dump_num;\n\tu8 idx, i, read_reg, doneflag = 0;\n\tenum rdwr_status stat;\n\tu32 memory_size;\n\tint ret;\n\n\tif (!card->pcie.can_dump_fw)\n\t\treturn;\n\n\tfor (idx = 0; idx < adapter->num_mem_types; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\n\t\tif (entry->mem_ptr) {\n\t\t\tvfree(entry->mem_ptr);\n\t\t\tentry->mem_ptr = NULL;\n\t\t}\n\t\tentry->mem_size = 0;\n\t}\n\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump start ==\\n\");\n\n\t/* Read the number of the memories which will dump */\n\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\tif (stat == RDWR_STATUS_FAILURE)\n\t\treturn;\n\n\treg = creg->fw_dump_start;\n\tmwifiex_read_reg_byte(adapter, reg, &fw_dump_num);\n\n\t/* W8997 chipset firmware dump will be restore in single region*/\n\tif (fw_dump_num == 0)\n\t\tdump_num = 1;\n\telse\n\t\tdump_num = fw_dump_num;\n\n\t/* Read the length of every memory which will dump */\n\tfor (idx = 0; idx < dump_num; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\t\tmemory_size = 0;\n\t\tif (fw_dump_num != 0) {\n\t\t\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\t\t\tif (stat == RDWR_STATUS_FAILURE)\n\t\t\t\treturn;\n\n\t\t\treg = creg->fw_dump_start;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tmwifiex_read_reg_byte(adapter, reg, &read_reg);\n\t\t\t\tmemory_size |= (read_reg << (i * 8));\n\t\t\t\treg++;\n\t\t\t}\n\t\t} else {\n\t\t\tmemory_size = MWIFIEX_FW_DUMP_MAX_MEMSIZE;\n\t\t}\n\n\t\tif (memory_size == 0) {\n\t\t\tmwifiex_dbg(adapter, MSG, \"Firmware dump Finished!\\n\");\n\t\t\tret = mwifiex_write_reg(adapter, creg->fw_dump_ctrl,\n\t\t\t\t\t\tcreg->fw_dump_read_done);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"PCIE write err\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmwifiex_dbg(adapter, DUMP,\n\t\t\t    \"%s_SIZE=0x%x\\n\", entry->mem_name, memory_size);\n\t\tentry->mem_ptr = vmalloc(memory_size + 1);\n\t\tentry->mem_size = memory_size;\n\t\tif (!entry->mem_ptr) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Vmalloc %s failed\\n\", entry->mem_name);\n\t\t\treturn;\n\t\t}\n\t\tdbg_ptr = entry->mem_ptr;\n\t\tend_ptr = dbg_ptr + memory_size;\n\n\t\tdoneflag = entry->done_flag;\n\t\tmwifiex_dbg(adapter, DUMP, \"Start %s output, please wait...\\n\",\n\t\t\t    entry->mem_name);\n\n\t\tdo {\n\t\t\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\t\t\tif (RDWR_STATUS_FAILURE == stat)\n\t\t\t\treturn;\n\n\t\t\treg_start = creg->fw_dump_start;\n\t\t\treg_end = creg->fw_dump_end;\n\t\t\tfor (reg = reg_start; reg <= reg_end; reg++) {\n\t\t\t\tmwifiex_read_reg_byte(adapter, reg, dbg_ptr);\n\t\t\t\tif (dbg_ptr < end_ptr) {\n\t\t\t\t\tdbg_ptr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"pre-allocated buf not enough\\n\");\n\t\t\t\ttmp_ptr =\n\t\t\t\t\tvzalloc(memory_size + MWIFIEX_SIZE_4K);\n\t\t\t\tif (!tmp_ptr)\n\t\t\t\t\treturn;\n\t\t\t\tmemcpy(tmp_ptr, entry->mem_ptr, memory_size);\n\t\t\t\tvfree(entry->mem_ptr);\n\t\t\t\tentry->mem_ptr = tmp_ptr;\n\t\t\t\ttmp_ptr = NULL;\n\t\t\t\tdbg_ptr = entry->mem_ptr + memory_size;\n\t\t\t\tmemory_size += MWIFIEX_SIZE_4K;\n\t\t\t\tend_ptr = entry->mem_ptr + memory_size;\n\t\t\t}\n\n\t\t\tif (stat != RDWR_STATUS_DONE)\n\t\t\t\tcontinue;\n\n\t\t\tmwifiex_dbg(adapter, DUMP,\n\t\t\t\t    \"%s done: size=0x%tx\\n\",\n\t\t\t\t    entry->mem_name, dbg_ptr - entry->mem_ptr);\n\t\t\tbreak;\n\t\t} while (true);\n\t}\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump end ==\\n\");\n}\n\nstatic void mwifiex_pcie_device_dump_work(struct mwifiex_adapter *adapter)\n{\n\tadapter->devdump_data = vzalloc(MWIFIEX_FW_DUMP_SIZE);\n\tif (!adapter->devdump_data) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"vzalloc devdump data failure!\\n\");\n\t\treturn;\n\t}\n\n\tmwifiex_drv_info_dump(adapter);\n\tmwifiex_pcie_fw_dump(adapter);\n\tmwifiex_prepare_fw_dump_info(adapter);\n\tmwifiex_upload_device_dump(adapter);\n}\n\nstatic void mwifiex_pcie_card_reset_work(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t/* We can't afford to wait here; remove() might be waiting on us. If we\n\t * can't grab the device lock, maybe we'll get another chance later.\n\t */\n\tpci_try_reset_function(card->dev);\n}\n\nstatic void mwifiex_pcie_work(struct work_struct *work)\n{\n\tstruct pcie_service_card *card =\n\t\tcontainer_of(work, struct pcie_service_card, work);\n\n\tif (test_and_clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t       &card->work_flags))\n\t\tmwifiex_pcie_device_dump_work(card->adapter);\n\tif (test_and_clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET,\n\t\t\t       &card->work_flags))\n\t\tmwifiex_pcie_card_reset_work(card->adapter);\n}\n\n/* This function dumps FW information */\nstatic void mwifiex_pcie_device_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t      &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic void mwifiex_pcie_card_reset(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic int mwifiex_pcie_alloc_buffers(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret;\n\n\tcard->cmdrsp_buf = NULL;\n\tret = mwifiex_pcie_create_txbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create txbd ring\\n\");\n\t\tgoto err_cre_txbd;\n\t}\n\n\tret = mwifiex_pcie_create_rxbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create rxbd ring\\n\");\n\t\tgoto err_cre_rxbd;\n\t}\n\n\tret = mwifiex_pcie_create_evtbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create evtbd ring\\n\");\n\t\tgoto err_cre_evtbd;\n\t}\n\n\tret = mwifiex_pcie_alloc_cmdrsp_buf(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to allocate cmdbuf buffer\\n\");\n\t\tgoto err_alloc_cmdbuf;\n\t}\n\n\tif (reg->sleep_cookie) {\n\t\tret = mwifiex_pcie_alloc_sleep_cookie_buf(adapter);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Failed to allocate sleep_cookie buffer\\n\");\n\t\t\tgoto err_alloc_cookie;\n\t\t}\n\t} else {\n\t\tcard->sleep_cookie_vbase = NULL;\n\t}\n\n\treturn 0;\n\nerr_alloc_cookie:\n\tmwifiex_pcie_delete_cmdrsp_buf(adapter);\nerr_alloc_cmdbuf:\n\tmwifiex_pcie_delete_evtbd_ring(adapter);\nerr_cre_evtbd:\n\tmwifiex_pcie_delete_rxbd_ring(adapter);\nerr_cre_rxbd:\n\tmwifiex_pcie_delete_txbd_ring(adapter);\nerr_cre_txbd:\n\treturn ret;\n}\n\nstatic void mwifiex_pcie_free_buffers(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (reg->sleep_cookie)\n\t\tmwifiex_pcie_delete_sleep_cookie_buf(adapter);\n\n\tmwifiex_pcie_delete_cmdrsp_buf(adapter);\n\tmwifiex_pcie_delete_evtbd_ring(adapter);\n\tmwifiex_pcie_delete_rxbd_ring(adapter);\n\tmwifiex_pcie_delete_txbd_ring(adapter);\n}\n\n/*\n * This function initializes the PCI-E host memory space, WCB rings, etc.\n */\nstatic int mwifiex_init_pcie(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tint ret;\n\tstruct pci_dev *pdev = card->dev;\n\n\tpci_set_drvdata(pdev, card);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto err_enable_dev;\n\n\tpci_set_master(pdev);\n\n\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tpr_err(\"set_dma_mask(32) failed: %d\\n\", ret);\n\t\tgoto err_set_dma_mask;\n\t}\n\n\tret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tpr_err(\"set_consistent_dma_mask(64) failed\\n\");\n\t\tgoto err_set_dma_mask;\n\t}\n\n\tret = pci_request_region(pdev, 0, DRV_NAME);\n\tif (ret) {\n\t\tpr_err(\"req_reg(0) error\\n\");\n\t\tgoto err_req_region0;\n\t}\n\tcard->pci_mmap = pci_iomap(pdev, 0, 0);\n\tif (!card->pci_mmap) {\n\t\tpr_err(\"iomap(0) error\\n\");\n\t\tret = -EIO;\n\t\tgoto err_iomap0;\n\t}\n\tret = pci_request_region(pdev, 2, DRV_NAME);\n\tif (ret) {\n\t\tpr_err(\"req_reg(2) error\\n\");\n\t\tgoto err_req_region2;\n\t}\n\tcard->pci_mmap1 = pci_iomap(pdev, 2, 0);\n\tif (!card->pci_mmap1) {\n\t\tpr_err(\"iomap(2) error\\n\");\n\t\tret = -EIO;\n\t\tgoto err_iomap2;\n\t}\n\n\tpr_notice(\"PCI memory map Virt0: %pK PCI memory map Virt2: %pK\\n\",\n\t\t  card->pci_mmap, card->pci_mmap1);\n\n\tret = mwifiex_pcie_alloc_buffers(adapter);\n\tif (ret)\n\t\tgoto err_alloc_buffers;\n\n\treturn 0;\n\nerr_alloc_buffers:\n\tpci_iounmap(pdev, card->pci_mmap1);\nerr_iomap2:\n\tpci_release_region(pdev, 2);\nerr_req_region2:\n\tpci_iounmap(pdev, card->pci_mmap);\nerr_iomap0:\n\tpci_release_region(pdev, 0);\nerr_req_region0:\nerr_set_dma_mask:\n\tpci_disable_device(pdev);\nerr_enable_dev:\n\treturn ret;\n}\n\n/*\n * This function cleans up the allocated card buffers.\n */\nstatic void mwifiex_cleanup_pcie(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret;\n\tu32 fw_status;\n\n\tcancel_work_sync(&card->work);\n\n\tret = mwifiex_read_reg(adapter, reg->fw_status, &fw_status);\n\tif (fw_status == FIRMWARE_READY_PCIE) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"Clearing driver ready signature\\n\");\n\t\tif (mwifiex_write_reg(adapter, reg->drv_rdy, 0x00000000))\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write driver not-ready signature\\n\");\n\t}\n\n\tpci_disable_device(pdev);\n\n\tpci_iounmap(pdev, card->pci_mmap);\n\tpci_iounmap(pdev, card->pci_mmap1);\n\tpci_release_region(pdev, 2);\n\tpci_release_region(pdev, 0);\n\n\tmwifiex_pcie_free_buffers(adapter);\n}\n\nstatic int mwifiex_pcie_request_irq(struct mwifiex_adapter *adapter)\n{\n\tint ret, i, j;\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\n\tif (card->pcie.reg->msix_support) {\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tcard->msix_entries[i].entry = i;\n\t\tret = pci_enable_msix_exact(pdev, card->msix_entries,\n\t\t\t\t\t    MWIFIEX_NUM_MSIX_VECTORS);\n\t\tif (!ret) {\n\t\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++) {\n\t\t\t\tcard->msix_ctx[i].dev = pdev;\n\t\t\t\tcard->msix_ctx[i].msg_id = i;\n\n\t\t\t\tret = request_irq(card->msix_entries[i].vector,\n\t\t\t\t\t\t  mwifiex_pcie_interrupt, 0,\n\t\t\t\t\t\t  \"MWIFIEX_PCIE_MSIX\",\n\t\t\t\t\t\t  &card->msix_ctx[i]);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, INFO, \"request_irq fail: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tfree_irq(card->msix_entries[j].vector,\n\t\t\t\t\t\t &card->msix_ctx[i]);\n\t\t\t\tpci_disable_msix(pdev);\n\t\t\t} else {\n\t\t\t\tmwifiex_dbg(adapter, MSG, \"MSIx enabled!\");\n\t\t\t\tcard->msix_enable = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pci_enable_msi(pdev) != 0)\n\t\tpci_disable_msi(pdev);\n\telse\n\t\tcard->msi_enable = 1;\n\n\tmwifiex_dbg(adapter, INFO, \"msi_enable = %d\\n\", card->msi_enable);\n\n\tcard->share_irq_ctx.dev = pdev;\n\tcard->share_irq_ctx.msg_id = -1;\n\tret = request_irq(pdev->irq, mwifiex_pcie_interrupt, IRQF_SHARED,\n\t\t\t  \"MRVL_PCIE\", &card->share_irq_ctx);\n\tif (ret) {\n\t\tpr_err(\"request_irq failed: ret=%d\\n\", ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function gets the firmware name for downloading by revision id\n *\n * Read revision id register to get revision id\n */\nstatic void mwifiex_pcie_get_fw_name(struct mwifiex_adapter *adapter)\n{\n\tint revision_id = 0;\n\tint version, magic;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tswitch (card->dev->device) {\n\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\tstrcpy(adapter->fw_name, PCIE8766_DEFAULT_FW_NAME);\n\t\tbreak;\n\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tmwifiex_write_reg(adapter, 0x0c58, 0x80c00000);\n\t\tmwifiex_read_reg(adapter, 0x0c58, &revision_id);\n\t\trevision_id &= 0xff00;\n\t\tswitch (revision_id) {\n\t\tcase PCIE8897_A0:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_A0_FW_NAME);\n\t\t\tbreak;\n\t\tcase PCIE8897_B0:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_B0_FW_NAME);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_DEFAULT_FW_NAME);\n\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\tmwifiex_read_reg(adapter, 0x8, &revision_id);\n\t\tmwifiex_read_reg(adapter, 0x0cd0, &version);\n\t\tmwifiex_read_reg(adapter, 0x0cd4, &magic);\n\t\trevision_id &= 0xff;\n\t\tversion &= 0x7;\n\t\tmagic &= 0xff;\n\t\tif (revision_id == PCIE8997_A1 &&\n\t\t    magic == CHIP_MAGIC_VALUE &&\n\t\t    version == CHIP_VER_PCIEUART)\n\t\t\tstrcpy(adapter->fw_name, PCIEUART8997_FW_NAME_V4);\n\t\telse\n\t\t\tstrcpy(adapter->fw_name, PCIEUSB8997_FW_NAME_V4);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n * This function registers the PCIE device.\n *\n * PCIE IRQ is claimed, block size is set and driver data is initialized.\n */\nstatic int mwifiex_register_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t/* save adapter pointer in card */\n\tcard->adapter = adapter;\n\n\tif (mwifiex_pcie_request_irq(adapter))\n\t\treturn -1;\n\n\tadapter->tx_buf_size = card->pcie.tx_buf_size;\n\tadapter->mem_type_mapping_tbl = card->pcie.mem_type_mapping_tbl;\n\tadapter->num_mem_types = card->pcie.num_mem_types;\n\tadapter->ext_scan = card->pcie.can_ext_scan;\n\tmwifiex_pcie_get_fw_name(adapter);\n\n\treturn 0;\n}\n\n/*\n * This function unregisters the PCIE device.\n *\n * The PCIE IRQ is released, the function is disabled and driver\n * data is set to null.\n */\nstatic void mwifiex_unregister_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\tint i;\n\n\tif (card->msix_enable) {\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tsynchronize_irq(card->msix_entries[i].vector);\n\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tfree_irq(card->msix_entries[i].vector,\n\t\t\t\t &card->msix_ctx[i]);\n\n\t\tcard->msix_enable = 0;\n\t\tpci_disable_msix(pdev);\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s(): calling free_irq()\\n\", __func__);\n\t       free_irq(card->dev->irq, &card->share_irq_ctx);\n\n\t\tif (card->msi_enable)\n\t\t\tpci_disable_msi(pdev);\n\t}\n\tcard->adapter = NULL;\n}\n\n/*\n * This function initializes the PCI-E host memory space, WCB rings, etc.,\n * similar to mwifiex_init_pcie(), but without resetting PCI-E state.\n */\nstatic void mwifiex_pcie_up_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\n\t/* tx_buf_size might be changed to 3584 by firmware during\n\t * data transfer, we should reset it to default size.\n\t */\n\tadapter->tx_buf_size = card->pcie.tx_buf_size;\n\n\tmwifiex_pcie_alloc_buffers(adapter);\n\n\tpci_set_master(pdev);\n}\n\n/* This function cleans up the PCI-E host memory space. */\nstatic void mwifiex_pcie_down_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct pci_dev *pdev = card->dev;\n\n\tif (mwifiex_write_reg(adapter, reg->drv_rdy, 0x00000000))\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to write driver not-ready signature\\n\");\n\n\tpci_clear_master(pdev);\n\n\tadapter->seq_num = 0;\n\n\tmwifiex_pcie_free_buffers(adapter);\n}\n\nstatic struct mwifiex_if_ops pcie_ops = {\n\t.init_if =\t\t\tmwifiex_init_pcie,\n\t.cleanup_if =\t\t\tmwifiex_cleanup_pcie,\n\t.check_fw_status =\t\tmwifiex_check_fw_status,\n\t.check_winner_status =          mwifiex_check_winner_status,\n\t.prog_fw =\t\t\tmwifiex_prog_fw_w_helper,\n\t.register_dev =\t\t\tmwifiex_register_dev,\n\t.unregister_dev =\t\tmwifiex_unregister_dev,\n\t.enable_int =\t\t\tmwifiex_pcie_enable_host_int,\n\t.disable_int =\t\t\tmwifiex_pcie_disable_host_int_noerr,\n\t.process_int_status =\t\tmwifiex_process_int_status,\n\t.host_to_card =\t\t\tmwifiex_pcie_host_to_card,\n\t.wakeup =\t\t\tmwifiex_pm_wakeup_card,\n\t.wakeup_complete =\t\tmwifiex_pm_wakeup_card_complete,\n\n\t/* PCIE specific */\n\t.cmdrsp_complete =\t\tmwifiex_pcie_cmdrsp_complete,\n\t.event_complete =\t\tmwifiex_pcie_event_complete,\n\t.update_mp_end_port =\t\tNULL,\n\t.cleanup_mpa_buf =\t\tNULL,\n\t.init_fw_port =\t\t\tmwifiex_pcie_init_fw_port,\n\t.clean_pcie_ring =\t\tmwifiex_clean_pcie_ring_buf,\n\t.card_reset =\t\t\tmwifiex_pcie_card_reset,\n\t.reg_dump =\t\t\tmwifiex_pcie_reg_dump,\n\t.device_dump =\t\t\tmwifiex_pcie_device_dump,\n\t.down_dev =\t\t\tmwifiex_pcie_down_dev,\n\t.up_dev =\t\t\tmwifiex_pcie_up_dev,\n};\n\nmodule_pci_driver(mwifiex_pcie);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell WiFi-Ex PCI-Express Driver version \" PCIE_VERSION);\nMODULE_VERSION(PCIE_VERSION);\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["/*\n * Marvell Wireless LAN device driver: PCIE specific handling\n *\n * Copyright (C) 2011-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include <linux/firmware.h>\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"pcie.h\"\n\n#define PCIE_VERSION\t\"1.0\"\n#define DRV_NAME        \"Marvell mwifiex PCIe\"\n\nstatic struct mwifiex_if_ops pcie_ops;\n\nstatic const struct of_device_id mwifiex_pcie_of_match_table[] = {\n\t{ .compatible = \"pci11ab,2b42\" },\n\t{ .compatible = \"pci1b4b,2b42\" },\n\t{ }\n};\n\nstatic int mwifiex_pcie_probe_of(struct device *dev)\n{\n\tif (!of_match_node(mwifiex_pcie_of_match_table, dev->of_node)) {\n\t\tdev_err(dev, \"required compatible string missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_pcie_work(struct work_struct *work);\n\nstatic int\nmwifiex_map_pci_memory(struct mwifiex_adapter *adapter, struct sk_buff *skb,\n\t\t       size_t size, int flags)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_dma_mapping mapping;\n\n\tmapping.addr = pci_map_single(card->dev, skb->data, size, flags);\n\tif (pci_dma_mapping_error(card->dev, mapping.addr)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"failed to map pci memory!\\n\");\n\t\treturn -1;\n\t}\n\tmapping.len = size;\n\tmwifiex_store_mapping(skb, &mapping);\n\treturn 0;\n}\n\nstatic void mwifiex_unmap_pci_memory(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct sk_buff *skb, int flags)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_dma_mapping mapping;\n\n\tmwifiex_get_mapping(skb, &mapping);\n\tpci_unmap_single(card->dev, mapping.addr, mapping.len, flags);\n}\n\n/*\n * This function writes data into PCIE card register.\n */\nstatic int mwifiex_write_reg(struct mwifiex_adapter *adapter, int reg, u32 data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tiowrite32(data, card->pci_mmap1 + reg);\n\n\treturn 0;\n}\n\n/* This function reads data from PCIE card register.\n */\nstatic int mwifiex_read_reg(struct mwifiex_adapter *adapter, int reg, u32 *data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t*data = ioread32(card->pci_mmap1 + reg);\n\tif (*data == 0xffffffff)\n\t\treturn 0xffffffff;\n\n\treturn 0;\n}\n\n/* This function reads u8 data from PCIE card register. */\nstatic int mwifiex_read_reg_byte(struct mwifiex_adapter *adapter,\n\t\t\t\t int reg, u8 *data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t*data = ioread8(card->pci_mmap1 + reg);\n\n\treturn 0;\n}\n\n/*\n * This function reads sleep cookie and checks if FW is ready\n */\nstatic bool mwifiex_pcie_ok_to_access_hw(struct mwifiex_adapter *adapter)\n{\n\tu32 cookie_value;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!reg->sleep_cookie)\n\t\treturn true;\n\n\tif (card->sleep_cookie_vbase) {\n\t\tcookie_value = get_unaligned_le32(card->sleep_cookie_vbase);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ACCESS_HW: sleep cookie=0x%x\\n\",\n\t\t\t    cookie_value);\n\t\tif (cookie_value == FW_AWAKE_COOKIE)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#ifdef CONFIG_PM_SLEEP\n/*\n * Kernel needs to suspend all functions separately. Therefore all\n * registered functions must have drivers with suspend and resume\n * methods. Failing that the kernel simply removes the whole card.\n *\n * If already not suspended, this function allocates and sends a host\n * sleep activate request to the firmware and turns off the traffic.\n */\nstatic int mwifiex_pcie_suspend(struct device *dev)\n{\n\tstruct mwifiex_adapter *adapter;\n\tstruct pcie_service_card *card = dev_get_drvdata(dev);\n\n\n\t/* Might still be loading firmware */\n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter) {\n\t\tdev_err(dev, \"adapter is not valid\\n\");\n\t\treturn 0;\n\t}\n\n\tmwifiex_enable_wake(adapter);\n\n\t/* Enable the Host Sleep */\n\tif (!mwifiex_enable_hs(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cmd: failed to suspend\\n\");\n\t\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\t\tmwifiex_disable_wake(adapter);\n\t\treturn -EFAULT;\n\t}\n\n\tflush_workqueue(adapter->workqueue);\n\n\t/* Indicate device suspended */\n\tset_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\n\treturn 0;\n}\n\n/*\n * Kernel needs to suspend all functions separately. Therefore all\n * registered functions must have drivers with suspend and resume\n * methods. Failing that the kernel simply removes the whole card.\n *\n * If already not resumed, this function turns on the traffic and\n * sends a host sleep cancel request to the firmware.\n */\nstatic int mwifiex_pcie_resume(struct device *dev)\n{\n\tstruct mwifiex_adapter *adapter;\n\tstruct pcie_service_card *card = dev_get_drvdata(dev);\n\n\n\tif (!card->adapter) {\n\t\tdev_err(dev, \"adapter structure is not valid\\n\");\n\t\treturn 0;\n\t}\n\n\tadapter = card->adapter;\n\n\tif (!test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"Device already resumed\\n\");\n\t\treturn 0;\n\t}\n\n\tclear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\n\tmwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),\n\t\t\t  MWIFIEX_ASYNC_CMD);\n\tmwifiex_disable_wake(adapter);\n\n\treturn 0;\n}\n#endif\n\n/*\n * This function probes an mwifiex device and registers it. It allocates\n * the card structure, enables PCIE function number and initiates the\n * device registration and initialization procedure by adding a logical\n * interface.\n */\nstatic int mwifiex_pcie_probe(struct pci_dev *pdev,\n\t\t\t\t\tconst struct pci_device_id *ent)\n{\n\tstruct pcie_service_card *card;\n\tint ret;\n\n\tpr_debug(\"info: vendor=0x%4.04X device=0x%4.04X rev=%d\\n\",\n\t\t pdev->vendor, pdev->device, pdev->revision);\n\n\tcard = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&card->fw_done);\n\n\tcard->dev = pdev;\n\n\tif (ent->driver_data) {\n\t\tstruct mwifiex_pcie_device *data = (void *)ent->driver_data;\n\t\tcard->pcie.reg = data->reg;\n\t\tcard->pcie.blksz_fw_dl = data->blksz_fw_dl;\n\t\tcard->pcie.tx_buf_size = data->tx_buf_size;\n\t\tcard->pcie.can_dump_fw = data->can_dump_fw;\n\t\tcard->pcie.mem_type_mapping_tbl = data->mem_type_mapping_tbl;\n\t\tcard->pcie.num_mem_types = data->num_mem_types;\n\t\tcard->pcie.can_ext_scan = data->can_ext_scan;\n\t\tINIT_WORK(&card->work, mwifiex_pcie_work);\n\t}\n\n\t/* device tree node parsing and platform specific configuration*/\n\tif (pdev->dev.of_node) {\n\t\tret = mwifiex_pcie_probe_of(&pdev->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (mwifiex_add_card(card, &card->fw_done, &pcie_ops,\n\t\t\t     MWIFIEX_PCIE, &pdev->dev)) {\n\t\tpr_err(\"%s failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function removes the interface and frees up the card structure.\n */\nstatic void mwifiex_pcie_remove(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card;\n\tstruct mwifiex_adapter *adapter;\n\tstruct mwifiex_private *priv;\n\tconst struct mwifiex_pcie_card_reg *reg;\n\tu32 fw_status;\n\tint ret;\n\n\tcard = pci_get_drvdata(pdev);\n\n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter || !adapter->priv_num)\n\t\treturn;\n\n\treg = card->pcie.reg;\n\tif (reg)\n\t\tret = mwifiex_read_reg(adapter, reg->fw_status, &fw_status);\n\telse\n\t\tfw_status = -1;\n\n\tif (fw_status == FIRMWARE_READY_PCIE && !adapter->mfg_mode) {\n\t\tmwifiex_deauthenticate_all(adapter);\n\n\t\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\t\tmwifiex_disable_auto_ds(priv);\n\n\t\tmwifiex_init_shutdown_fw(priv, MWIFIEX_FUNC_SHUTDOWN);\n\t}\n\n\tmwifiex_remove_card(adapter);\n}\n\nstatic void mwifiex_pcie_shutdown(struct pci_dev *pdev)\n{\n\tmwifiex_pcie_remove(pdev);\n\n\treturn;\n}\n\nstatic void mwifiex_pcie_coredump(struct device *dev)\n{\n\tstruct pci_dev *pdev;\n\tstruct pcie_service_card *card;\n\n\tpdev = container_of(dev, struct pci_dev, dev);\n\tcard = pci_get_drvdata(pdev);\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t      &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic const struct pci_device_id mwifiex_ids[] = {\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8766P,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8766,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8897,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8897,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8997,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8997,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_V2_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8997,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8997,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(pci, mwifiex_ids);\n\n/*\n * Cleanup all software without cleaning anything related to PCIe and HW.\n */\nstatic void mwifiex_pcie_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card = pci_get_drvdata(pdev);\n\tstruct mwifiex_adapter *adapter = card->adapter;\n\n\tif (!adapter) {\n\t\tdev_err(&pdev->dev, \"%s: adapter structure is not valid\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: vendor=0x%4.04x device=0x%4.04x rev=%d Pre-FLR\\n\",\n\t\t    __func__, pdev->vendor, pdev->device, pdev->revision);\n\n\tmwifiex_shutdown_sw(adapter);\n\tclear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &card->work_flags);\n\tclear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags);\n\tmwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);\n}\n\n/*\n * Kernel stores and restores PCIe function context before and after performing\n * FLR respectively. Reconfigure the software and firmware including firmware\n * redownload.\n */\nstatic void mwifiex_pcie_reset_done(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card = pci_get_drvdata(pdev);\n\tstruct mwifiex_adapter *adapter = card->adapter;\n\tint ret;\n\n\tif (!adapter) {\n\t\tdev_err(&pdev->dev, \"%s: adapter structure is not valid\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: vendor=0x%4.04x device=0x%4.04x rev=%d Post-FLR\\n\",\n\t\t    __func__, pdev->vendor, pdev->device, pdev->revision);\n\n\tret = mwifiex_reinit_sw(adapter);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"reinit failed: %d\\n\", ret);\n\telse\n\t\tmwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);\n}\n\nstatic const struct pci_error_handlers mwifiex_pcie_err_handler = {\n\t.reset_prepare\t\t= mwifiex_pcie_reset_prepare,\n\t.reset_done\t\t= mwifiex_pcie_reset_done,\n};\n\n#ifdef CONFIG_PM_SLEEP\n/* Power Management Hooks */\nstatic SIMPLE_DEV_PM_OPS(mwifiex_pcie_pm_ops, mwifiex_pcie_suspend,\n\t\t\t\tmwifiex_pcie_resume);\n#endif\n\n/* PCI Device Driver */\nstatic struct pci_driver __refdata mwifiex_pcie = {\n\t.name     = \"mwifiex_pcie\",\n\t.id_table = mwifiex_ids,\n\t.probe    = mwifiex_pcie_probe,\n\t.remove   = mwifiex_pcie_remove,\n\t.driver   = {\n\t\t.coredump = mwifiex_pcie_coredump,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm = &mwifiex_pcie_pm_ops,\n#endif\n\t},\n\t.shutdown = mwifiex_pcie_shutdown,\n\t.err_handler = &mwifiex_pcie_err_handler,\n};\n\n/*\n * This function adds delay loop to ensure FW is awake before proceeding.\n */\nstatic void mwifiex_pcie_dev_wakeup_delay(struct mwifiex_adapter *adapter)\n{\n\tint i = 0;\n\n\twhile (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\ti++;\n\t\tusleep_range(10, 20);\n\t\t/* 50ms max wait */\n\t\tif (i == 5000)\n\t\t\tbreak;\n\t}\n\n\treturn;\n}\n\nstatic void mwifiex_delay_for_sleep_cookie(struct mwifiex_adapter *adapter,\n\t\t\t\t\t   u32 max_delay_loop_cnt)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tu8 *buffer;\n\tu32 sleep_cookie, count;\n\tstruct sk_buff *cmdrsp = card->cmdrsp_buf;\n\n\tfor (count = 0; count < max_delay_loop_cnt; count++) {\n\t\tpci_dma_sync_single_for_cpu(card->dev,\n\t\t\t\t\t    MWIFIEX_SKB_DMA_ADDR(cmdrsp),\n\t\t\t\t\t    sizeof(sleep_cookie),\n\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\t\tbuffer = cmdrsp->data;\n\t\tsleep_cookie = get_unaligned_le32(buffer);\n\n\t\tif (sleep_cookie == MWIFIEX_DEF_SLEEP_COOKIE) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"sleep cookie found at count %d\\n\", count);\n\t\t\tbreak;\n\t\t}\n\t\tpci_dma_sync_single_for_device(card->dev,\n\t\t\t\t\t       MWIFIEX_SKB_DMA_ADDR(cmdrsp),\n\t\t\t\t\t       sizeof(sleep_cookie),\n\t\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t\tusleep_range(20, 30);\n\t}\n\n\tif (count >= max_delay_loop_cnt)\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"max count reached while accessing sleep cookie\\n\");\n}\n\n/* This function wakes up the card by reading fw_status register. */\nstatic int mwifiex_pm_wakeup_card(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"event: Wakeup device...\\n\");\n\n\tif (reg->sleep_cookie)\n\t\tmwifiex_pcie_dev_wakeup_delay(adapter);\n\n\t/* Accessing fw_status register will wakeup device */\n\tif (mwifiex_write_reg(adapter, reg->fw_status, FIRMWARE_READY_PCIE)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Writing fw_status register failed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (reg->sleep_cookie) {\n\t\tmwifiex_pcie_dev_wakeup_delay(adapter);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"PCIE wakeup: Setting PS_STATE_AWAKE\\n\");\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function is called after the card has woken up.\n *\n * The card configuration register is reset.\n */\nstatic int mwifiex_pm_wakeup_card_complete(struct mwifiex_adapter *adapter)\n{\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: Wakeup device completed\\n\");\n\n\treturn 0;\n}\n\n/*\n * This function disables the host interrupt.\n *\n * The host interrupt mask is read, the disable bit is reset and\n * written back to the card host interrupt mask register.\n */\nstatic int mwifiex_pcie_disable_host_int(struct mwifiex_adapter *adapter)\n{\n\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_MASK,\n\t\t\t\t      0x00000000)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Disable host interrupt failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tatomic_set(&adapter->tx_hw_pending, 0);\n\treturn 0;\n}\n\nstatic void mwifiex_pcie_disable_host_int_noerr(struct mwifiex_adapter *adapter)\n{\n\tWARN_ON(mwifiex_pcie_disable_host_int(adapter));\n}\n\n/*\n * This function enables the host interrupt.\n *\n * The host interrupt enable mask is written to the card\n * host interrupt mask register.\n */\nstatic int mwifiex_pcie_enable_host_int(struct mwifiex_adapter *adapter)\n{\n\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t/* Simply write the mask to the register */\n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_MASK,\n\t\t\t\t      HOST_INTR_MASK)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Enable host interrupt failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function initializes TX buffer ring descriptors\n */\nstatic int mwifiex_init_txq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tcard->tx_buf_list[i] = NULL;\n\t\tif (reg->pfu_enabled) {\n\t\t\tcard->txbd_ring[i] = (void *)card->txbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc2) * i);\n\t\t\tdesc2 = card->txbd_ring[i];\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tcard->txbd_ring[i] = (void *)card->txbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc) * i);\n\t\t\tdesc = card->txbd_ring[i];\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* This function initializes RX buffer ring descriptors. Each SKB is allocated\n * here and after mapping PCI memory, its physical address is assigned to\n * PCIE Rx buffer descriptor's physical address.\n */\nstatic int mwifiex_init_rxq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = mwifiex_alloc_dma_align_buf(MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for RX ring.\\n\");\n\t\t\tkfree(card->rxbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb,\n\t\t\t\t\t   MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: RX ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->rx_buf_list[i] = skb;\n\t\tif (reg->pfu_enabled) {\n\t\t\tcard->rxbd_ring[i] = (void *)card->rxbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc2) * i);\n\t\t\tdesc2 = card->rxbd_ring[i];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = (u16)skb->len;\n\t\t\tdesc2->frag_len = (u16)skb->len;\n\t\t\tdesc2->flags = reg->ring_flag_eop | reg->ring_flag_sop;\n\t\t\tdesc2->offset = 0;\n\t\t} else {\n\t\t\tcard->rxbd_ring[i] = (void *)(card->rxbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc) * i));\n\t\t\tdesc = card->rxbd_ring[i];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = (u16)skb->len;\n\t\t\tdesc->flags = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* This function initializes event buffer ring descriptors. Each SKB is\n * allocated here and after mapping PCI memory, its physical address is assigned\n * to PCIE Rx buffer descriptor's physical address\n */\nstatic int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}\n\n/* This function cleans up TX buffer rings. If any of the buffer list has valid\n * SKB address, associated SKB is freed.\n */\nstatic void mwifiex_cleanup_txq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[i];\n\t\t\tif (card->tx_buf_list[i]) {\n\t\t\t\tskb = card->tx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[i];\n\t\t\tif (card->tx_buf_list[i]) {\n\t\t\t\tskb = card->tx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tcard->tx_buf_list[i] = NULL;\n\t}\n\n\tatomic_set(&adapter->tx_hw_pending, 0);\n\treturn;\n}\n\n/* This function cleans up RX buffer rings. If any of the buffer list has valid\n * SKB address, associated SKB is freed.\n */\nstatic void mwifiex_cleanup_rxq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->rxbd_ring[i];\n\t\t\tif (card->rx_buf_list[i]) {\n\t\t\t\tskb = card->rx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->rxbd_ring[i];\n\t\t\tif (card->rx_buf_list[i]) {\n\t\t\t\tskb = card->rx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tcard->rx_buf_list[i] = NULL;\n\t}\n\n\treturn;\n}\n\n/* This function cleans up event buffer rings. If any of the buffer list has\n * valid SKB address, associated SKB is freed.\n */\nstatic void mwifiex_cleanup_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tdesc = card->evtbd_ring[i];\n\t\tif (card->evt_buf_list[i]) {\n\t\t\tskb = card->evt_buf_list[i];\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t\tcard->evt_buf_list[i] = NULL;\n\t\tmemset(desc, 0, sizeof(*desc));\n\t}\n\n\treturn;\n}\n\n/* This function creates buffer descriptor ring for TX\n */\nstatic int mwifiex_pcie_create_txbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t/*\n\t * driver maintaines the write pointer and firmware maintaines the read\n\t * pointer. The write pointer starts at 0 (zero) while the read pointer\n\t * starts at zero with rollover bit set\n\t */\n\tcard->txbd_wrptr = 0;\n\n\tif (reg->pfu_enabled)\n\t\tcard->txbd_rdptr = 0;\n\telse\n\t\tcard->txbd_rdptr |= reg->tx_rollover_ind;\n\n\t/* allocate shared memory for the BD ring and divide the same in to\n\t   several descriptors */\n\tif (reg->pfu_enabled)\n\t\tcard->txbd_ring_size = sizeof(struct mwifiex_pfu_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\telse\n\t\tcard->txbd_ring_size = sizeof(struct mwifiex_pcie_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: txbd_ring: Allocating %d bytes\\n\",\n\t\t    card->txbd_ring_size);\n\tcard->txbd_ring_vbase = pci_alloc_consistent(card->dev,\n\t\t\t\t\t\t     card->txbd_ring_size,\n\t\t\t\t\t\t     &card->txbd_ring_pbase);\n\tif (!card->txbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate consistent memory (%d bytes) failed!\\n\",\n\t\t\t    card->txbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: txbd_ring - base: %p, pbase: %#x:%x, len: %x\\n\",\n\t\t    card->txbd_ring_vbase, (unsigned int)card->txbd_ring_pbase,\n\t\t    (u32)((u64)card->txbd_ring_pbase >> 32),\n\t\t    card->txbd_ring_size);\n\n\treturn mwifiex_init_txq_ring(adapter);\n}\n\nstatic int mwifiex_pcie_delete_txbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_txq_ring(adapter);\n\n\tif (card->txbd_ring_vbase)\n\t\tpci_free_consistent(card->dev, card->txbd_ring_size,\n\t\t\t\t    card->txbd_ring_vbase,\n\t\t\t\t    card->txbd_ring_pbase);\n\tcard->txbd_ring_size = 0;\n\tcard->txbd_wrptr = 0;\n\tcard->txbd_rdptr = 0 | reg->tx_rollover_ind;\n\tcard->txbd_ring_vbase = NULL;\n\tcard->txbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n/*\n * This function creates buffer descriptor ring for RX\n */\nstatic int mwifiex_pcie_create_rxbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t/*\n\t * driver maintaines the read pointer and firmware maintaines the write\n\t * pointer. The write pointer starts at 0 (zero) while the read pointer\n\t * starts at zero with rollover bit set\n\t */\n\tcard->rxbd_wrptr = 0;\n\tcard->rxbd_rdptr = reg->rx_rollover_ind;\n\n\tif (reg->pfu_enabled)\n\t\tcard->rxbd_ring_size = sizeof(struct mwifiex_pfu_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\telse\n\t\tcard->rxbd_ring_size = sizeof(struct mwifiex_pcie_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: rxbd_ring: Allocating %d bytes\\n\",\n\t\t    card->rxbd_ring_size);\n\tcard->rxbd_ring_vbase = pci_alloc_consistent(card->dev,\n\t\t\t\t\t\t     card->rxbd_ring_size,\n\t\t\t\t\t\t     &card->rxbd_ring_pbase);\n\tif (!card->rxbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate consistent memory (%d bytes) failed!\\n\",\n\t\t\t    card->rxbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: rxbd_ring - base: %p, pbase: %#x:%x, len: %#x\\n\",\n\t\t    card->rxbd_ring_vbase, (u32)card->rxbd_ring_pbase,\n\t\t    (u32)((u64)card->rxbd_ring_pbase >> 32),\n\t\t    card->rxbd_ring_size);\n\n\treturn mwifiex_init_rxq_ring(adapter);\n}\n\n/*\n * This function deletes Buffer descriptor ring for RX\n */\nstatic int mwifiex_pcie_delete_rxbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_rxq_ring(adapter);\n\n\tif (card->rxbd_ring_vbase)\n\t\tpci_free_consistent(card->dev, card->rxbd_ring_size,\n\t\t\t\t    card->rxbd_ring_vbase,\n\t\t\t\t    card->rxbd_ring_pbase);\n\tcard->rxbd_ring_size = 0;\n\tcard->rxbd_wrptr = 0;\n\tcard->rxbd_rdptr = 0 | reg->rx_rollover_ind;\n\tcard->rxbd_ring_vbase = NULL;\n\tcard->rxbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n/*\n * This function creates buffer descriptor ring for Events\n */\nstatic int mwifiex_pcie_create_evtbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t/*\n\t * driver maintaines the read pointer and firmware maintaines the write\n\t * pointer. The write pointer starts at 0 (zero) while the read pointer\n\t * starts at zero with rollover bit set\n\t */\n\tcard->evtbd_wrptr = 0;\n\tcard->evtbd_rdptr = reg->evt_rollover_ind;\n\n\tcard->evtbd_ring_size = sizeof(struct mwifiex_evt_buf_desc) *\n\t\t\t\tMWIFIEX_MAX_EVT_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: evtbd_ring: Allocating %d bytes\\n\",\n\t\tcard->evtbd_ring_size);\n\tcard->evtbd_ring_vbase = pci_alloc_consistent(card->dev,\n\t\t\t\t\t\t      card->evtbd_ring_size,\n\t\t\t\t\t\t      &card->evtbd_ring_pbase);\n\tif (!card->evtbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate consistent memory (%d bytes) failed!\\n\",\n\t\t\t    card->evtbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: CMDRSP/EVT bd_ring - base: %p pbase: %#x:%x len: %#x\\n\",\n\t\t    card->evtbd_ring_vbase, (u32)card->evtbd_ring_pbase,\n\t\t    (u32)((u64)card->evtbd_ring_pbase >> 32),\n\t\t    card->evtbd_ring_size);\n\n\treturn mwifiex_pcie_init_evt_ring(adapter);\n}\n\n/*\n * This function deletes Buffer descriptor ring for Events\n */\nstatic int mwifiex_pcie_delete_evtbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_evt_ring(adapter);\n\n\tif (card->evtbd_ring_vbase)\n\t\tpci_free_consistent(card->dev, card->evtbd_ring_size,\n\t\t\t\t    card->evtbd_ring_vbase,\n\t\t\t\t    card->evtbd_ring_pbase);\n\tcard->evtbd_wrptr = 0;\n\tcard->evtbd_rdptr = 0 | reg->evt_rollover_ind;\n\tcard->evtbd_ring_size = 0;\n\tcard->evtbd_ring_vbase = NULL;\n\tcard->evtbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n/*\n * This function allocates a buffer for CMDRSP\n */\nstatic int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\n\t/* Allocate memory for receiving command response data */\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE)) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tcard->cmdrsp_buf = skb;\n\n\treturn 0;\n}\n\n/*\n * This function deletes a buffer for CMDRSP\n */\nstatic int mwifiex_pcie_delete_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card;\n\n\tif (!adapter)\n\t\treturn 0;\n\n\tcard = adapter->card;\n\n\tif (card && card->cmdrsp_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmdrsp_buf,\n\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\tdev_kfree_skb_any(card->cmdrsp_buf);\n\t\tcard->cmdrsp_buf = NULL;\n\t}\n\n\tif (card && card->cmd_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmd_buf,\n\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\tdev_kfree_skb_any(card->cmd_buf);\n\t\tcard->cmd_buf = NULL;\n\t}\n\treturn 0;\n}\n\n/*\n * This function allocates a buffer for sleep cookie\n */\nstatic int mwifiex_pcie_alloc_sleep_cookie_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tu32 tmp;\n\n\tcard->sleep_cookie_vbase = pci_alloc_consistent(card->dev, sizeof(u32),\n\t\t\t\t\t\t     &card->sleep_cookie_pbase);\n\tif (!card->sleep_cookie_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"pci_alloc_consistent failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t/* Init val of Sleep Cookie */\n\ttmp = FW_AWAKE_COOKIE;\n\tput_unaligned(tmp, card->sleep_cookie_vbase);\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"alloc_scook: sleep cookie=0x%x\\n\",\n\t\t    get_unaligned(card->sleep_cookie_vbase));\n\n\treturn 0;\n}\n\n/*\n * This function deletes buffer for sleep cookie\n */\nstatic int mwifiex_pcie_delete_sleep_cookie_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card;\n\n\tif (!adapter)\n\t\treturn 0;\n\n\tcard = adapter->card;\n\n\tif (card && card->sleep_cookie_vbase) {\n\t\tpci_free_consistent(card->dev, sizeof(u32),\n\t\t\t\t    card->sleep_cookie_vbase,\n\t\t\t\t    card->sleep_cookie_pbase);\n\t\tcard->sleep_cookie_vbase = NULL;\n\t}\n\n\treturn 0;\n}\n\n/* This function flushes the TX buffer descriptor ring\n * This function defined as handler is also called while cleaning TXRX\n * during disconnect/ bss stop.\n */\nstatic int mwifiex_clean_pcie_ring_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!mwifiex_pcie_txbd_empty(card, card->txbd_rdptr)) {\n\t\tcard->txbd_flush = 1;\n\t\t/* write pointer already set at last send\n\t\t * send dnld-rdy intr again, wait for completion.\n\t\t */\n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_DNLD_RDY)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"failed to assert dnld-rdy interrupt.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * This function unmaps and frees downloaded data buffer\n */\nstatic int mwifiex_pcie_send_data_complete(struct mwifiex_adapter *adapter)\n{\n\tstruct sk_buff *skb;\n\tu32 wrdoneidx, rdptr, num_tx_buffs, unmap_count = 0;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\t/* Read the TX ring read pointer set by firmware */\n\tif (mwifiex_read_reg(adapter, reg->tx_rdptr, &rdptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"SEND COMP: failed to read reg->tx_rdptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"SEND COMP: rdptr_prev=0x%x, rdptr=0x%x\\n\",\n\t\t    card->txbd_rdptr, rdptr);\n\n\tnum_tx_buffs = MWIFIEX_MAX_TXRX_BD << reg->tx_start_ptr;\n\t/* free from previous txbd_rdptr to current txbd_rdptr */\n\twhile (((card->txbd_rdptr & reg->tx_mask) !=\n\t\t(rdptr & reg->tx_mask)) ||\n\t       ((card->txbd_rdptr & reg->tx_rollover_ind) !=\n\t\t(rdptr & reg->tx_rollover_ind))) {\n\t\twrdoneidx = (card->txbd_rdptr & reg->tx_mask) >>\n\t\t\t    reg->tx_start_ptr;\n\n\t\tskb = card->tx_buf_list[wrdoneidx];\n\n\t\tif (skb) {\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"SEND COMP: Detach skb %p at txbd_rdidx=%d\\n\",\n\t\t\t\t    skb, wrdoneidx);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\n\t\t\tunmap_count++;\n\n\t\t\tif (card->txbd_flush)\n\t\t\t\tmwifiex_write_data_complete(adapter, skb, 0,\n\t\t\t\t\t\t\t    -1);\n\t\t\telse\n\t\t\t\tmwifiex_write_data_complete(adapter, skb, 0, 0);\n\t\t\tatomic_dec(&adapter->tx_hw_pending);\n\t\t}\n\n\t\tcard->tx_buf_list[wrdoneidx] = NULL;\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[wrdoneidx];\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[wrdoneidx];\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tswitch (card->dev->device) {\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\t\tcard->txbd_rdptr++;\n\t\t\tbreak;\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\t\tcard->txbd_rdptr += reg->ring_tx_start_ptr;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tif ((card->txbd_rdptr & reg->tx_mask) == num_tx_buffs)\n\t\t\tcard->txbd_rdptr = ((card->txbd_rdptr &\n\t\t\t\t\t     reg->tx_rollover_ind) ^\n\t\t\t\t\t     reg->tx_rollover_ind);\n\t}\n\n\tif (unmap_count)\n\t\tadapter->data_sent = false;\n\n\tif (card->txbd_flush) {\n\t\tif (mwifiex_pcie_txbd_empty(card, card->txbd_rdptr))\n\t\t\tcard->txbd_flush = 0;\n\t\telse\n\t\t\tmwifiex_clean_pcie_ring_buf(adapter);\n\t}\n\n\treturn 0;\n}\n\n/* This function sends data buffer to device. First 4 bytes of payload\n * are filled with payload length and payload type. Then this payload\n * is mapped to PCI device memory. Tx ring pointers are advanced accordingly.\n * Download ready interrupt to FW is deffered if Tx ring is not full and\n * additional payload can be accomodated.\n * Caller must ensure tx_param parameter to this function is not NULL.\n */\nstatic int\nmwifiex_pcie_send_data(struct mwifiex_adapter *adapter, struct sk_buff *skb,\n\t\t       struct mwifiex_tx_param *tx_param)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 wrindx, num_tx_buffs, rx_val;\n\tint ret;\n\tdma_addr_t buf_pa;\n\tstruct mwifiex_pcie_buf_desc *desc = NULL;\n\tstruct mwifiex_pfu_buf_desc *desc2 = NULL;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s(): invalid parameter <%p, %#x>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tnum_tx_buffs = MWIFIEX_MAX_TXRX_BD << reg->tx_start_ptr;\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: SEND DATA: <Rd: %#x, Wr: %#x>\\n\",\n\t\tcard->txbd_rdptr, card->txbd_wrptr);\n\tif (mwifiex_pcie_txbd_not_full(card)) {\n\t\tu8 *payload;\n\n\t\tadapter->data_sent = true;\n\t\tpayload = skb->data;\n\t\tput_unaligned_le16((u16)skb->len, payload + 0);\n\t\tput_unaligned_le16(MWIFIEX_TYPE_DATA, payload + 2);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, skb->len,\n\t\t\t\t\t   PCI_DMA_TODEVICE))\n\t\t\treturn -1;\n\n\t\twrindx = (card->txbd_wrptr & reg->tx_mask) >> reg->tx_start_ptr;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tcard->tx_buf_list[wrindx] = skb;\n\t\tatomic_inc(&adapter->tx_hw_pending);\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[wrindx];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = (u16)skb->len;\n\t\t\tdesc2->frag_len = (u16)skb->len;\n\t\t\tdesc2->offset = 0;\n\t\t\tdesc2->flags = MWIFIEX_BD_FLAG_FIRST_DESC |\n\t\t\t\t\t MWIFIEX_BD_FLAG_LAST_DESC;\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[wrindx];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = (u16)skb->len;\n\t\t\tdesc->flags = MWIFIEX_BD_FLAG_FIRST_DESC |\n\t\t\t\t      MWIFIEX_BD_FLAG_LAST_DESC;\n\t\t}\n\n\t\tswitch (card->dev->device) {\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\t\tcard->txbd_wrptr++;\n\t\t\tbreak;\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\t\tcard->txbd_wrptr += reg->ring_tx_start_ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((card->txbd_wrptr & reg->tx_mask) == num_tx_buffs)\n\t\t\tcard->txbd_wrptr = ((card->txbd_wrptr &\n\t\t\t\t\t\treg->tx_rollover_ind) ^\n\t\t\t\t\t\treg->tx_rollover_ind);\n\n\t\trx_val = card->rxbd_rdptr & reg->rx_wrap_mask;\n\t\t/* Write the TX ring write pointer in to reg->tx_wrptr */\n\t\tif (mwifiex_write_reg(adapter, reg->tx_wrptr,\n\t\t\t\t      card->txbd_wrptr | rx_val)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SEND DATA: failed to write reg->tx_wrptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done_unmap;\n\t\t}\n\t\tif ((mwifiex_pcie_txbd_not_full(card)) &&\n\t\t    tx_param->next_pkt_len) {\n\t\t\t/* have more packets and TxBD still can hold more */\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"SEND DATA: delay dnld-rdy interrupt.\\n\");\n\t\t\tadapter->data_sent = false;\n\t\t} else {\n\t\t\t/* Send the TX ready interrupt */\n\t\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t\t      CPU_INTR_DNLD_RDY)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"SEND DATA: failed to assert dnld-rdy interrupt.\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done_unmap;\n\t\t\t}\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: SEND DATA: Updated <Rd: %#x, Wr:\\t\"\n\t\t\t    \"%#x> and sent packet to firmware successfully\\n\",\n\t\t\t    card->txbd_rdptr, card->txbd_wrptr);\n\t} else {\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: TX Ring full, can't send packets to fw\\n\");\n\t\tadapter->data_sent = true;\n\t\t/* Send the TX ready interrupt */\n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_DNLD_RDY))\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SEND DATA: failed to assert door-bell intr\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn -EINPROGRESS;\ndone_unmap:\n\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\tcard->tx_buf_list[wrindx] = NULL;\n\tatomic_dec(&adapter->tx_hw_pending);\n\tif (reg->pfu_enabled)\n\t\tmemset(desc2, 0, sizeof(*desc2));\n\telse\n\t\tmemset(desc, 0, sizeof(*desc));\n\n\treturn ret;\n}\n\n/*\n * This function handles received buffer ring and\n * dispatches packets to upper\n */\nstatic int mwifiex_pcie_process_recv_data(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 wrptr, rd_index, tx_val;\n\tdma_addr_t buf_pa;\n\tint ret = 0;\n\tstruct sk_buff *skb_tmp = NULL;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\t/* Read the RX ring Write pointer set by firmware */\n\tif (mwifiex_read_reg(adapter, reg->rx_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"RECV DATA: failed to read reg->rx_wrptr\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tcard->rxbd_wrptr = wrptr;\n\n\twhile (((wrptr & reg->rx_mask) !=\n\t\t(card->rxbd_rdptr & reg->rx_mask)) ||\n\t       ((wrptr & reg->rx_rollover_ind) ==\n\t\t(card->rxbd_rdptr & reg->rx_rollover_ind))) {\n\t\tstruct sk_buff *skb_data;\n\t\tu16 rx_len;\n\n\t\trd_index = card->rxbd_rdptr & reg->rx_mask;\n\t\tskb_data = card->rx_buf_list[rd_index];\n\n\t\t/* If skb allocation was failed earlier for Rx packet,\n\t\t * rx_buf_list[rd_index] would have been left with a NULL.\n\t\t */\n\t\tif (!skb_data)\n\t\t\treturn -ENOMEM;\n\n\t\tmwifiex_unmap_pci_memory(adapter, skb_data, PCI_DMA_FROMDEVICE);\n\t\tcard->rx_buf_list[rd_index] = NULL;\n\n\t\t/* Get data length from interface header -\n\t\t * first 2 bytes for len, next 2 bytes is for type\n\t\t */\n\t\trx_len = get_unaligned_le16(skb_data->data);\n\t\tif (WARN_ON(rx_len <= adapter->intf_hdr_len ||\n\t\t\t    rx_len > MWIFIEX_RX_DATA_BUF_SIZE)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Invalid RX len %d, Rd=%#x, Wr=%#x\\n\",\n\t\t\t\t    rx_len, card->rxbd_rdptr, wrptr);\n\t\t\tdev_kfree_skb_any(skb_data);\n\t\t} else {\n\t\t\tskb_put(skb_data, rx_len);\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"info: RECV DATA: Rd=%#x, Wr=%#x, Len=%d\\n\",\n\t\t\t\t    card->rxbd_rdptr, wrptr, rx_len);\n\t\t\tskb_pull(skb_data, adapter->intf_hdr_len);\n\t\t\tif (adapter->rx_work_enabled) {\n\t\t\t\tskb_queue_tail(&adapter->rx_data_q, skb_data);\n\t\t\t\tadapter->data_received = true;\n\t\t\t\tatomic_inc(&adapter->rx_pending);\n\t\t\t} else {\n\t\t\t\tmwifiex_handle_rx_packet(adapter, skb_data);\n\t\t\t}\n\t\t}\n\n\t\tskb_tmp = mwifiex_alloc_dma_align_buf(MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!skb_tmp) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb_tmp,\n\t\t\t\t\t   MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb_tmp);\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"RECV DATA: Attach new sk_buff %p at rxbd_rdidx=%d\\n\",\n\t\t\t    skb_tmp, rd_index);\n\t\tcard->rx_buf_list[rd_index] = skb_tmp;\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->rxbd_ring[rd_index];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = skb_tmp->len;\n\t\t\tdesc2->frag_len = skb_tmp->len;\n\t\t\tdesc2->offset = 0;\n\t\t\tdesc2->flags = reg->ring_flag_sop | reg->ring_flag_eop;\n\t\t} else {\n\t\t\tdesc = card->rxbd_ring[rd_index];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = skb_tmp->len;\n\t\t\tdesc->flags = 0;\n\t\t}\n\n\t\tif ((++card->rxbd_rdptr & reg->rx_mask) ==\n\t\t\t\t\t\t\tMWIFIEX_MAX_TXRX_BD) {\n\t\t\tcard->rxbd_rdptr = ((card->rxbd_rdptr &\n\t\t\t\t\t     reg->rx_rollover_ind) ^\n\t\t\t\t\t     reg->rx_rollover_ind);\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: RECV DATA: <Rd: %#x, Wr: %#x>\\n\",\n\t\t\t    card->rxbd_rdptr, wrptr);\n\n\t\ttx_val = card->txbd_wrptr & reg->tx_wrap_mask;\n\t\t/* Write the RX ring read pointer in to reg->rx_rdptr */\n\t\tif (mwifiex_write_reg(adapter, reg->rx_rdptr,\n\t\t\t\t      card->rxbd_rdptr | tx_val)) {\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"RECV DATA: failed to write reg->rx_rdptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Read the RX ring Write pointer set by firmware */\n\t\tif (mwifiex_read_reg(adapter, reg->rx_wrptr, &wrptr)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"RECV DATA: failed to read reg->rx_wrptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: RECV DATA: Rcvd packet from fw successfully\\n\");\n\t\tcard->rxbd_wrptr = wrptr;\n\t}\n\ndone:\n\treturn ret;\n}\n\n/*\n * This function downloads the boot command to device\n */\nstatic int\nmwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)\n{\n\tdma_addr_t buf_pa;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Invalid parameter in %s <%p. len %d>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_map_pci_memory(adapter, skb, skb->len, PCI_DMA_TODEVICE))\n\t\treturn -1;\n\n\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t/* Write the lower 32bits of the physical address to low command\n\t * address scratch register\n\t */\n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_lo, (u32)buf_pa)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write download command to boot code.\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\t\treturn -1;\n\t}\n\n\t/* Write the upper 32bits of the physical address to high command\n\t * address scratch register\n\t */\n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_hi,\n\t\t\t      (u32)((u64)buf_pa >> 32))) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write download command to boot code.\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\t\treturn -1;\n\t}\n\n\t/* Write the command length to cmd_size scratch register */\n\tif (mwifiex_write_reg(adapter, reg->cmd_size, skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write command len to cmd_size scratch reg\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\t\treturn -1;\n\t}\n\n\t/* Ring the door bell */\n\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t      CPU_INTR_DOOR_BELL)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to assert door-bell intr\\n\", __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* This function init rx port in firmware which in turn enables to receive data\n * from device before transmitting any packet.\n */\nstatic int mwifiex_pcie_init_fw_port(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint tx_wrap = card->txbd_wrptr & reg->tx_wrap_mask;\n\n\t/* Write the RX ring read pointer in to reg->rx_rdptr */\n\tif (mwifiex_write_reg(adapter, reg->rx_rdptr, card->rxbd_rdptr |\n\t\t\t      tx_wrap)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"RECV DATA: failed to write reg->rx_rdptr\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* This function downloads commands to the device\n */\nstatic int\nmwifiex_pcie_send_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret = 0;\n\tdma_addr_t cmd_buf_pa, cmdrsp_buf_pa;\n\tu8 *payload = (u8 *)skb->data;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Invalid parameter in %s <%p, %#x>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\t/* Make sure a command response buffer is available */\n\tif (!card->cmdrsp_buf) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"No response buffer available, send command failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tadapter->cmd_sent = true;\n\n\tput_unaligned_le16((u16)skb->len, &payload[0]);\n\tput_unaligned_le16(MWIFIEX_TYPE_CMD, &payload[2]);\n\n\tif (mwifiex_map_pci_memory(adapter, skb, skb->len, PCI_DMA_TODEVICE))\n\t\treturn -1;\n\n\tcard->cmd_buf = skb;\n\t/*\n\t * Need to keep a reference, since core driver might free up this\n\t * buffer before we've unmapped it.\n\t */\n\tskb_get(skb);\n\n\t/* To send a command, the driver will:\n\t\t1. Write the 64bit physical address of the data buffer to\n\t\t   cmd response address low  + cmd response address high\n\t\t2. Ring the door bell (i.e. set the door bell interrupt)\n\n\t\tIn response to door bell interrupt, the firmware will perform\n\t\tthe DMA of the command packet (first header to obtain the total\n\t\tlength and then rest of the command).\n\t*/\n\n\tif (card->cmdrsp_buf) {\n\t\tcmdrsp_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmdrsp_buf);\n\t\t/* Write the lower 32bits of the cmdrsp buffer physical\n\t\t   address */\n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_lo,\n\t\t\t\t      (u32)cmdrsp_buf_pa)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t\t/* Write the upper 32bits of the cmdrsp buffer physical\n\t\t   address */\n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_hi,\n\t\t\t\t      (u32)((u64)cmdrsp_buf_pa >> 32))) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tcmd_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmd_buf);\n\t/* Write the lower 32bits of the physical address to reg->cmd_addr_lo */\n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_lo,\n\t\t\t      (u32)cmd_buf_pa)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\t/* Write the upper 32bits of the physical address to reg->cmd_addr_hi */\n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_hi,\n\t\t\t      (u32)((u64)cmd_buf_pa >> 32))) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/* Write the command length to reg->cmd_size */\n\tif (mwifiex_write_reg(adapter, reg->cmd_size,\n\t\t\t      card->cmd_buf->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write cmd len to reg->cmd_size\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/* Ring the door bell */\n\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t      CPU_INTR_DOOR_BELL)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to assert door-bell intr\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\ndone:\n\tif (ret)\n\t\tadapter->cmd_sent = false;\n\n\treturn 0;\n}\n\n/*\n * This function handles command complete interrupt\n */\nstatic int mwifiex_pcie_process_cmd_complete(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb = card->cmdrsp_buf;\n\tint count = 0;\n\tu16 rx_len;\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"info: Rx CMD Response\\n\");\n\n\tif (adapter->curr_cmd)\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_FROMDEVICE);\n\telse\n\t\tpci_dma_sync_single_for_cpu(card->dev,\n\t\t\t\t\t    MWIFIEX_SKB_DMA_ADDR(skb),\n\t\t\t\t\t    MWIFIEX_UPLD_SIZE,\n\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\n\t/* Unmap the command as a response has been received. */\n\tif (card->cmd_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmd_buf,\n\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\tdev_kfree_skb_any(card->cmd_buf);\n\t\tcard->cmd_buf = NULL;\n\t}\n\n\trx_len = get_unaligned_le16(skb->data);\n\tskb_put(skb, MWIFIEX_UPLD_SIZE - skb->len);\n\tskb_trim(skb, rx_len);\n\n\tif (!adapter->curr_cmd) {\n\t\tif (adapter->ps_state == PS_STATE_SLEEP_CFM) {\n\t\t\tpci_dma_sync_single_for_device(card->dev,\n\t\t\t\t\t\tMWIFIEX_SKB_DMA_ADDR(skb),\n\t\t\t\t\t\tMWIFIEX_SLEEP_COOKIE_SIZE,\n\t\t\t\t\t\tPCI_DMA_FROMDEVICE);\n\t\t\tif (mwifiex_write_reg(adapter,\n\t\t\t\t\t      PCIE_CPU_INT_EVENT,\n\t\t\t\t\t      CPU_INTR_SLEEP_CFM_DONE)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"Write register failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmwifiex_delay_for_sleep_cookie(adapter,\n\t\t\t\t\t\t       MWIFIEX_MAX_DELAY_COUNT);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\tskb_pull(skb, adapter->intf_hdr_len);\n\t\t\twhile (reg->sleep_cookie && (count++ < 10) &&\n\t\t\t       mwifiex_pcie_ok_to_access_hw(adapter))\n\t\t\t\tusleep_range(50, 60);\n\t\t\tmwifiex_pcie_enable_host_int(adapter);\n\t\t\tmwifiex_process_sleep_confirm_resp(adapter, skb->data,\n\t\t\t\t\t\t\t   skb->len);\n\t\t} else {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"There is no command but got cmdrsp\\n\");\n\t\t}\n\t\tmemcpy(adapter->upld_buf, skb->data,\n\t\t       min_t(u32, MWIFIEX_SIZE_OF_CMD_BUFFER, skb->len));\n\t\tskb_push(skb, adapter->intf_hdr_len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t} else if (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\tskb_pull(skb, adapter->intf_hdr_len);\n\t\tadapter->curr_cmd->resp_skb = skb;\n\t\tadapter->cmd_resp_received = true;\n\t\t/* Take the pointer and set it to CMD node and will\n\t\t   return in the response complete callback */\n\t\tcard->cmdrsp_buf = NULL;\n\n\t\t/* Clear the cmd-rsp buffer address in scratch registers. This\n\t\t   will prevent firmware from writing to the same response\n\t\t   buffer again. */\n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_lo, 0)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cmd_done: failed to clear cmd_rsp_addr_lo\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* Write the upper 32bits of the cmdrsp buffer physical\n\t\t   address */\n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_hi, 0)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cmd_done: failed to clear cmd_rsp_addr_hi\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Command Response processing complete handler\n */\nstatic int mwifiex_pcie_cmdrsp_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (skb) {\n\t\tcard->cmdrsp_buf = skb;\n\t\tskb_push(card->cmdrsp_buf, adapter->intf_hdr_len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function handles firmware event ready interrupt\n */\nstatic int mwifiex_pcie_process_event_ready(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;\n\tu32 wrptr, event;\n\tstruct mwifiex_evt_buf_desc *desc;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tif (adapter->event_received) {\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: Event being processed,\\t\"\n\t\t\t    \"do not process this interrupt just yet\\n\");\n\t\treturn 0;\n\t}\n\n\tif (rdptr >= MWIFIEX_MAX_EVT_BD) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"info: Invalid read pointer...\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Read the event ring write pointer set by firmware */\n\tif (mwifiex_read_reg(adapter, reg->evt_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"EventReady: failed to read reg->evt_wrptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: EventReady: Initial <Rd: 0x%x, Wr: 0x%x>\",\n\t\t    card->evtbd_rdptr, wrptr);\n\tif (((wrptr & MWIFIEX_EVTBD_MASK) != (card->evtbd_rdptr\n\t\t\t\t\t      & MWIFIEX_EVTBD_MASK)) ||\n\t    ((wrptr & reg->evt_rollover_ind) ==\n\t     (card->evtbd_rdptr & reg->evt_rollover_ind))) {\n\t\tstruct sk_buff *skb_cmd;\n\t\t__le16 data_len = 0;\n\t\tu16 evt_len;\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Read Index: %d\\n\", rdptr);\n\t\tskb_cmd = card->evt_buf_list[rdptr];\n\t\tmwifiex_unmap_pci_memory(adapter, skb_cmd, PCI_DMA_FROMDEVICE);\n\n\t\t/* Take the pointer and set it to event pointer in adapter\n\t\t   and will return back after event handling callback */\n\t\tcard->evt_buf_list[rdptr] = NULL;\n\t\tdesc = card->evtbd_ring[rdptr];\n\t\tmemset(desc, 0, sizeof(*desc));\n\n\t\tevent = get_unaligned_le32(\n\t\t\t&skb_cmd->data[adapter->intf_hdr_len]);\n\t\tadapter->event_cause = event;\n\t\t/* The first 4bytes will be the event transfer header\n\t\t   len is 2 bytes followed by type which is 2 bytes */\n\t\tmemcpy(&data_len, skb_cmd->data, sizeof(__le16));\n\t\tevt_len = le16_to_cpu(data_len);\n\t\tskb_trim(skb_cmd, evt_len);\n\t\tskb_pull(skb_cmd, adapter->intf_hdr_len);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: Event length: %d\\n\", evt_len);\n\n\t\tif (evt_len > MWIFIEX_EVENT_HEADER_LEN &&\n\t\t    evt_len < MAX_EVENT_SIZE)\n\t\t\tmemcpy(adapter->event_body, skb_cmd->data +\n\t\t\t       MWIFIEX_EVENT_HEADER_LEN, evt_len -\n\t\t\t       MWIFIEX_EVENT_HEADER_LEN);\n\n\t\tadapter->event_received = true;\n\t\tadapter->event_skb = skb_cmd;\n\n\t\t/* Do not update the event read pointer here, wait till the\n\t\t   buffer is released. This is just to make things simpler,\n\t\t   we need to find a better method of managing these buffers.\n\t\t*/\n\t} else {\n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_EVENT_DONE)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Write register failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Event processing complete handler\n */\nstatic int mwifiex_pcie_event_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret = 0;\n\tu32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;\n\tu32 wrptr;\n\tstruct mwifiex_evt_buf_desc *desc;\n\n\tif (!skb)\n\t\treturn 0;\n\n\tif (rdptr >= MWIFIEX_MAX_EVT_BD) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: Invalid rdptr 0x%x\\n\",\n\t\t\t    rdptr);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Read the event ring write pointer set by firmware */\n\tif (mwifiex_read_reg(adapter, reg->evt_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: failed to read reg->evt_wrptr\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!card->evt_buf_list[rdptr]) {\n\t\tskb_push(skb, adapter->intf_hdr_len);\n\t\tskb_put(skb, MAX_EVENT_SIZE - skb->len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb,\n\t\t\t\t\t   MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tcard->evt_buf_list[rdptr] = skb;\n\t\tdesc = card->evtbd_ring[rdptr];\n\t\tdesc->paddr = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t\tskb = NULL;\n\t} else {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"info: ERROR: buf still valid at index %d, <%p, %p>\\n\",\n\t\t\t    rdptr, card->evt_buf_list[rdptr], skb);\n\t}\n\n\tif ((++card->evtbd_rdptr & MWIFIEX_EVTBD_MASK) == MWIFIEX_MAX_EVT_BD) {\n\t\tcard->evtbd_rdptr = ((card->evtbd_rdptr &\n\t\t\t\t\treg->evt_rollover_ind) ^\n\t\t\t\t\treg->evt_rollover_ind);\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: Updated <Rd: 0x%x, Wr: 0x%x>\",\n\t\t    card->evtbd_rdptr, wrptr);\n\n\t/* Write the event ring read pointer in to reg->evt_rdptr */\n\tif (mwifiex_write_reg(adapter, reg->evt_rdptr,\n\t\t\t      card->evtbd_rdptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: failed to read reg->evt_rdptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: Check Events Again\\n\");\n\tret = mwifiex_pcie_process_event_ready(adapter);\n\n\treturn ret;\n}\n\n/* Combo firmware image is a combination of\n * (1) combo crc heaer, start with CMD5\n * (2) bluetooth image, start with CMD7, end with CMD6, data wrapped in CMD1.\n * (3) wifi image.\n *\n * This function bypass the header and bluetooth part, return\n * the offset of tail wifi-only part. If the image is already wifi-only,\n * that is start with CMD1, return 0.\n */\n\nstatic int mwifiex_extract_wifi_fw(struct mwifiex_adapter *adapter,\n\t\t\t\t   const void *firmware, u32 firmware_len) {\n\tconst struct mwifiex_fw_data *fwdata;\n\tu32 offset = 0, data_len, dnld_cmd;\n\tint ret = 0;\n\tbool cmd7_before = false, first_cmd = false;\n\n\twhile (1) {\n\t\t/* Check for integer and buffer overflow */\n\t\tif (offset + sizeof(fwdata->header) < sizeof(fwdata->header) ||\n\t\t    offset + sizeof(fwdata->header) >= firmware_len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"extract wifi-only fw failure!\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfwdata = firmware + offset;\n\t\tdnld_cmd = le32_to_cpu(fwdata->header.dnld_cmd);\n\t\tdata_len = le32_to_cpu(fwdata->header.data_length);\n\n\t\t/* Skip past header */\n\t\toffset += sizeof(fwdata->header);\n\n\t\tswitch (dnld_cmd) {\n\t\tcase MWIFIEX_FW_DNLD_CMD_1:\n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* Image start with cmd1, already wifi-only firmware */\n\t\t\tif (!first_cmd) {\n\t\t\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t\t\t    \"input wifi-only firmware\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!cmd7_before) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"no cmd7 before cmd1!\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tbreak;\n\t\tcase MWIFIEX_FW_DNLD_CMD_5:\n\t\t\tfirst_cmd = true;\n\t\t\t/* Check for integer overflow */\n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tbreak;\n\t\tcase MWIFIEX_FW_DNLD_CMD_6:\n\t\t\tfirst_cmd = true;\n\t\t\t/* Check for integer overflow */\n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tif (offset >= firmware_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"extract wifi-only fw failure!\\n\");\n\t\t\t\tret = -1;\n\t\t\t} else {\n\t\t\t\tret = offset;\n\t\t\t}\n\t\t\tgoto done;\n\t\tcase MWIFIEX_FW_DNLD_CMD_7:\n\t\t\tfirst_cmd = true;\n\t\t\tcmd7_before = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmwifiex_dbg(adapter, ERROR, \"unknown dnld_cmd %d\\n\",\n\t\t\t\t    dnld_cmd);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\treturn ret;\n}\n\n/*\n * This function downloads the firmware to the card.\n *\n * Firmware is downloaded to the card in blocks. Every block download\n * is tested for CRC errors, and retried a number of times before\n * returning failure.\n */\nstatic int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct mwifiex_fw_image *fw)\n{\n\tint ret;\n\tu8 *firmware = fw->fw_buf;\n\tu32 firmware_len = fw->fw_len;\n\tu32 offset = 0;\n\tstruct sk_buff *skb;\n\tu32 txlen, tx_blocks = 0, tries, len, val;\n\tu32 block_retry_cnt = 0;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!firmware || !firmware_len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"No firmware image found! Terminating download\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: Downloading FW image (%d bytes)\\n\",\n\t\t    firmware_len);\n\n\tif (mwifiex_pcie_disable_host_int(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: Disabling interrupts failed.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tret = mwifiex_read_reg(adapter, PCIE_SCRATCH_13_REG, &val);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, FATAL, \"Failed to read scratch register 13\\n\");\n\t\tgoto done;\n\t}\n\n\t/* PCIE FLR case: extract wifi part from combo firmware*/\n\tif (val == MWIFIEX_PCIE_FLR_HAPPENS) {\n\t\tret = mwifiex_extract_wifi_fw(adapter, firmware, firmware_len);\n\t\tif (ret < 0) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Failed to extract wifi fw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\toffset = ret;\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"info: dnld wifi firmware from %d bytes\\n\", offset);\n\t}\n\n\t/* Perform firmware data transfer */\n\tdo {\n\t\tu32 ireg_intr = 0;\n\n\t\t/* More data? */\n\t\tif (offset >= firmware_len)\n\t\t\tbreak;\n\n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tret = mwifiex_read_reg(adapter, reg->cmd_size,\n\t\t\t\t\t       &len);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, FATAL,\n\t\t\t\t\t    \"Failed reading len from boot code\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (len)\n\t\t\t\tbreak;\n\t\t\tusleep_range(10, 20);\n\t\t}\n\n\t\tif (!len) {\n\t\t\tbreak;\n\t\t} else if (len > MWIFIEX_UPLD_SIZE) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW download failure @ %d, invalid length %d\\n\",\n\t\t\t\t    offset, len);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttxlen = len;\n\n\t\tif (len & BIT(0)) {\n\t\t\tblock_retry_cnt++;\n\t\t\tif (block_retry_cnt > MAX_WRITE_IOMEM_RETRY) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"FW download failure @ %d, over max\\t\"\n\t\t\t\t\t    \"retry count\\n\", offset);\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW CRC error indicated by the\\t\"\n\t\t\t\t    \"helper: len = 0x%04X, txlen = %d\\n\",\n\t\t\t\t    len, txlen);\n\t\t\tlen &= ~BIT(0);\n\t\t\t/* Setting this to 0 to resend from same offset */\n\t\t\ttxlen = 0;\n\t\t} else {\n\t\t\tblock_retry_cnt = 0;\n\t\t\t/* Set blocksize to transfer - checking for\n\t\t\t   last block */\n\t\t\tif (firmware_len - offset < txlen)\n\t\t\t\ttxlen = firmware_len - offset;\n\n\t\t\ttx_blocks = (txlen + card->pcie.blksz_fw_dl - 1) /\n\t\t\t\t    card->pcie.blksz_fw_dl;\n\n\t\t\t/* Copy payload to buffer */\n\t\t\tmemmove(skb->data, &firmware[offset], txlen);\n\t\t}\n\n\t\tskb_put(skb, MWIFIEX_UPLD_SIZE - skb->len);\n\t\tskb_trim(skb, tx_blocks * card->pcie.blksz_fw_dl);\n\n\t\t/* Send the boot command to device */\n\t\tif (mwifiex_pcie_send_boot_cmd(adapter, skb)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to send firmware download command\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Wait for the command done interrupt */\n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tif (mwifiex_read_reg(adapter, PCIE_CPU_INT_STATUS,\n\t\t\t\t\t     &ireg_intr)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"%s: Failed to read\\t\"\n\t\t\t\t\t    \"interrupt status during fw dnld.\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (!(ireg_intr & CPU_INTR_DOOR_BELL))\n\t\t\t\tbreak;\n\t\t\tusleep_range(10, 20);\n\t\t}\n\t\tif (ireg_intr & CPU_INTR_DOOR_BELL) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"%s: Card failed to ACK download\\n\",\n\t\t\t\t    __func__);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tmwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);\n\n\t\toffset += txlen;\n\t} while (true);\n\n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"info: FW download over, size %d bytes\\n\", offset);\n\n\tret = 0;\n\ndone:\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\n/*\n * This function checks the firmware status in card.\n */\nstatic int\nmwifiex_check_fw_status(struct mwifiex_adapter *adapter, u32 poll_num)\n{\n\tint ret = 0;\n\tu32 firmware_stat;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 tries;\n\n\t/* Mask spurios interrupts */\n\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_STATUS_MASK,\n\t\t\t      HOST_INTR_MASK)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Write register failed\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"Setting driver ready signature\\n\");\n\tif (mwifiex_write_reg(adapter, reg->drv_rdy,\n\t\t\t      FIRMWARE_READY_PCIE)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write driver ready signature\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Wait for firmware initialization event */\n\tfor (tries = 0; tries < poll_num; tries++) {\n\t\tif (mwifiex_read_reg(adapter, reg->fw_status,\n\t\t\t\t     &firmware_stat))\n\t\t\tret = -1;\n\t\telse\n\t\t\tret = 0;\n\n\t\tmwifiex_dbg(adapter, INFO, \"Try %d if FW is ready <%d,%#x>\",\n\t\t\t    tries, ret, firmware_stat);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tif (firmware_stat == FIRMWARE_READY_PCIE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tmsleep(100);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* This function checks if WLAN is the winner.\n */\nstatic int\nmwifiex_check_winner_status(struct mwifiex_adapter *adapter)\n{\n\tu32 winner = 0;\n\tint ret = 0;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &winner)) {\n\t\tret = -1;\n\t} else if (!winner) {\n\t\tmwifiex_dbg(adapter, INFO, \"PCI-E is the winner\\n\");\n\t\tadapter->winner = 1;\n\t} else {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PCI-E is not the winner <%#x>\", winner);\n\t}\n\n\treturn ret;\n}\n\n/*\n * This function reads the interrupt status from card.\n */\nstatic void mwifiex_interrupt_status(struct mwifiex_adapter *adapter,\n\t\t\t\t     int msg_id)\n{\n\tu32 pcie_ireg;\n\tunsigned long flags;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (card->msi_enable) {\n\t\tspin_lock_irqsave(&adapter->int_lock, flags);\n\t\tadapter->int_status = 1;\n\t\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\t\treturn;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\treturn;\n\n\tif (card->msix_enable && msg_id >= 0) {\n\t\tpcie_ireg = BIT(msg_id);\n\t} else {\n\t\tif (mwifiex_read_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t     &pcie_ireg)) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Read register failed\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pcie_ireg == 0xFFFFFFFF) || !pcie_ireg)\n\t\t\treturn;\n\n\n\t\tmwifiex_pcie_disable_host_int(adapter);\n\n\t\t/* Clear the pending interrupts */\n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t      ~pcie_ireg)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Write register failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!adapter->pps_uapsd_mode &&\n\t    adapter->ps_state == PS_STATE_SLEEP &&\n\t    mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t/* Potentially for PCIe we could get other\n\t\t * interrupts like shared. Don't change power\n\t\t * state until cookie is set\n\t\t */\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\tadapter->pm_wakeup_fw_try = false;\n\t\tdel_timer(&adapter->wakeup_timer);\n\t}\n\n\tspin_lock_irqsave(&adapter->int_lock, flags);\n\tadapter->int_status |= pcie_ireg;\n\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\tmwifiex_dbg(adapter, INTR, \"ireg: 0x%08x\\n\", pcie_ireg);\n}\n\n/*\n * Interrupt handler for PCIe root port\n *\n * This function reads the interrupt status from firmware and assigns\n * the main process in workqueue which will handle the interrupt.\n */\nstatic irqreturn_t mwifiex_pcie_interrupt(int irq, void *context)\n{\n\tstruct mwifiex_msix_context *ctx = context;\n\tstruct pci_dev *pdev = ctx->dev;\n\tstruct pcie_service_card *card;\n\tstruct mwifiex_adapter *adapter;\n\n\tcard = pci_get_drvdata(pdev);\n\n\tif (!card->adapter) {\n\t\tpr_err(\"info: %s: card=%p adapter=%p\\n\", __func__, card,\n\t\t       card ? card->adapter : NULL);\n\t\tgoto exit;\n\t}\n\tadapter = card->adapter;\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags))\n\t\tgoto exit;\n\n\tif (card->msix_enable)\n\t\tmwifiex_interrupt_status(adapter, ctx->msg_id);\n\telse\n\t\tmwifiex_interrupt_status(adapter, -1);\n\n\tmwifiex_queue_main_work(adapter);\n\nexit:\n\treturn IRQ_HANDLED;\n}\n\n/*\n * This function checks the current interrupt status.\n *\n * The following interrupts are checked and handled by this function -\n *      - Data sent\n *      - Command sent\n *      - Command received\n *      - Packets received\n *      - Events received\n *\n * In case of Rx packets received, the packets are uploaded from card to\n * host and processed accordingly.\n */\nstatic int mwifiex_process_int_status(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tu32 pcie_ireg = 0;\n\tunsigned long flags;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tspin_lock_irqsave(&adapter->int_lock, flags);\n\tif (!card->msi_enable) {\n\t\t/* Clear out unused interrupts */\n\t\tpcie_ireg = adapter->int_status;\n\t}\n\tadapter->int_status = 0;\n\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\n\tif (card->msi_enable) {\n\t\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t\tif (mwifiex_read_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t\t     &pcie_ireg)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"Read register failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((pcie_ireg != 0xFFFFFFFF) && (pcie_ireg)) {\n\t\t\t\tif (mwifiex_write_reg(adapter,\n\t\t\t\t\t\t      PCIE_HOST_INT_STATUS,\n\t\t\t\t\t\t      ~pcie_ireg)) {\n\t\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t\t    \"Write register failed\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (!adapter->pps_uapsd_mode &&\n\t\t\t\t    adapter->ps_state == PS_STATE_SLEEP) {\n\t\t\t\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\t\t\t\tadapter->pm_wakeup_fw_try = false;\n\t\t\t\t\tdel_timer(&adapter->wakeup_timer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pcie_ireg & HOST_INTR_DNLD_DONE) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: TX DNLD Done\\n\");\n\t\tret = mwifiex_pcie_send_data_complete(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_UPLD_RDY) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: Rx DATA\\n\");\n\t\tret = mwifiex_pcie_process_recv_data(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_EVENT_RDY) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: Rx EVENT\\n\");\n\t\tret = mwifiex_pcie_process_event_ready(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_CMD_DONE) {\n\t\tif (adapter->cmd_sent) {\n\t\t\tmwifiex_dbg(adapter, INTR,\n\t\t\t\t    \"info: CMD sent Interrupt\\n\");\n\t\t\tadapter->cmd_sent = false;\n\t\t}\n\t\t/* Handle command response */\n\t\tret = mwifiex_pcie_process_cmd_complete(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmwifiex_dbg(adapter, INTR,\n\t\t    \"info: cmd_sent=%d data_sent=%d\\n\",\n\t\t    adapter->cmd_sent, adapter->data_sent);\n\tif (!card->msi_enable && !card->msix_enable &&\n\t\t\t\t adapter->ps_state != PS_STATE_SLEEP)\n\t\tmwifiex_pcie_enable_host_int(adapter);\n\n\treturn 0;\n}\n\n/*\n * This function downloads data from driver to card.\n *\n * Both commands and data packets are transferred to the card by this\n * function.\n *\n * This function adds the PCIE specific header to the front of the buffer\n * before transferring. The header contains the length of the packet and\n * the type. The firmware handles the packets based upon this set type.\n */\nstatic int mwifiex_pcie_host_to_card(struct mwifiex_adapter *adapter, u8 type,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     struct mwifiex_tx_param *tx_param)\n{\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Passed NULL skb to %s\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (type == MWIFIEX_TYPE_DATA)\n\t\treturn mwifiex_pcie_send_data(adapter, skb, tx_param);\n\telse if (type == MWIFIEX_TYPE_CMD)\n\t\treturn mwifiex_pcie_send_cmd(adapter, skb);\n\n\treturn 0;\n}\n\n/* Function to dump PCIE scratch registers in case of FW crash\n */\nstatic int\nmwifiex_pcie_reg_dump(struct mwifiex_adapter *adapter, char *drv_buf)\n{\n\tchar *p = drv_buf;\n\tchar buf[256], *ptr;\n\tint i;\n\tu32 value;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint pcie_scratch_reg[] = {PCIE_SCRATCH_12_REG,\n\t\t\t\t  PCIE_SCRATCH_14_REG,\n\t\t\t\t  PCIE_SCRATCH_15_REG};\n\n\tif (!p)\n\t\treturn 0;\n\n\tmwifiex_dbg(adapter, MSG, \"PCIE register dump start\\n\");\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &value)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"failed to read firmware status\");\n\t\treturn 0;\n\t}\n\n\tptr = buf;\n\tmwifiex_dbg(adapter, MSG, \"pcie scratch register:\");\n\tfor (i = 0; i < ARRAY_SIZE(pcie_scratch_reg); i++) {\n\t\tmwifiex_read_reg(adapter, pcie_scratch_reg[i], &value);\n\t\tptr += sprintf(ptr, \"reg:0x%x, value=0x%x\\n\",\n\t\t\t       pcie_scratch_reg[i], value);\n\t}\n\n\tmwifiex_dbg(adapter, MSG, \"%s\\n\", buf);\n\tp += sprintf(p, \"%s\\n\", buf);\n\n\tmwifiex_dbg(adapter, MSG, \"PCIE register dump end\\n\");\n\n\treturn p - drv_buf;\n}\n\n/* This function read/write firmware */\nstatic enum rdwr_status\nmwifiex_pcie_rdwr_firmware(struct mwifiex_adapter *adapter, u8 doneflag)\n{\n\tint ret, tries;\n\tu8 ctrl_data;\n\tu32 fw_status;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &fw_status))\n\t\treturn RDWR_STATUS_FAILURE;\n\n\tret = mwifiex_write_reg(adapter, reg->fw_dump_ctrl,\n\t\t\t\treg->fw_dump_host_ready);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PCIE write err\\n\");\n\t\treturn RDWR_STATUS_FAILURE;\n\t}\n\n\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\tmwifiex_read_reg_byte(adapter, reg->fw_dump_ctrl, &ctrl_data);\n\t\tif (ctrl_data == FW_DUMP_DONE)\n\t\t\treturn RDWR_STATUS_SUCCESS;\n\t\tif (doneflag && ctrl_data == doneflag)\n\t\t\treturn RDWR_STATUS_DONE;\n\t\tif (ctrl_data != reg->fw_dump_host_ready) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"The ctrl reg was changed, re-try again!\\n\");\n\t\t\tret = mwifiex_write_reg(adapter, reg->fw_dump_ctrl,\n\t\t\t\t\t\treg->fw_dump_host_ready);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"PCIE write err\\n\");\n\t\t\t\treturn RDWR_STATUS_FAILURE;\n\t\t\t}\n\t\t}\n\t\tusleep_range(100, 200);\n\t}\n\n\tmwifiex_dbg(adapter, ERROR, \"Fail to pull ctrl_data\\n\");\n\treturn RDWR_STATUS_FAILURE;\n}\n\n/* This function dump firmware memory to file */\nstatic void mwifiex_pcie_fw_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *creg = card->pcie.reg;\n\tunsigned int reg, reg_start, reg_end;\n\tu8 *dbg_ptr, *end_ptr, *tmp_ptr, fw_dump_num, dump_num;\n\tu8 idx, i, read_reg, doneflag = 0;\n\tenum rdwr_status stat;\n\tu32 memory_size;\n\tint ret;\n\n\tif (!card->pcie.can_dump_fw)\n\t\treturn;\n\n\tfor (idx = 0; idx < adapter->num_mem_types; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\n\t\tif (entry->mem_ptr) {\n\t\t\tvfree(entry->mem_ptr);\n\t\t\tentry->mem_ptr = NULL;\n\t\t}\n\t\tentry->mem_size = 0;\n\t}\n\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump start ==\\n\");\n\n\t/* Read the number of the memories which will dump */\n\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\tif (stat == RDWR_STATUS_FAILURE)\n\t\treturn;\n\n\treg = creg->fw_dump_start;\n\tmwifiex_read_reg_byte(adapter, reg, &fw_dump_num);\n\n\t/* W8997 chipset firmware dump will be restore in single region*/\n\tif (fw_dump_num == 0)\n\t\tdump_num = 1;\n\telse\n\t\tdump_num = fw_dump_num;\n\n\t/* Read the length of every memory which will dump */\n\tfor (idx = 0; idx < dump_num; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\t\tmemory_size = 0;\n\t\tif (fw_dump_num != 0) {\n\t\t\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\t\t\tif (stat == RDWR_STATUS_FAILURE)\n\t\t\t\treturn;\n\n\t\t\treg = creg->fw_dump_start;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tmwifiex_read_reg_byte(adapter, reg, &read_reg);\n\t\t\t\tmemory_size |= (read_reg << (i * 8));\n\t\t\t\treg++;\n\t\t\t}\n\t\t} else {\n\t\t\tmemory_size = MWIFIEX_FW_DUMP_MAX_MEMSIZE;\n\t\t}\n\n\t\tif (memory_size == 0) {\n\t\t\tmwifiex_dbg(adapter, MSG, \"Firmware dump Finished!\\n\");\n\t\t\tret = mwifiex_write_reg(adapter, creg->fw_dump_ctrl,\n\t\t\t\t\t\tcreg->fw_dump_read_done);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"PCIE write err\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmwifiex_dbg(adapter, DUMP,\n\t\t\t    \"%s_SIZE=0x%x\\n\", entry->mem_name, memory_size);\n\t\tentry->mem_ptr = vmalloc(memory_size + 1);\n\t\tentry->mem_size = memory_size;\n\t\tif (!entry->mem_ptr) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Vmalloc %s failed\\n\", entry->mem_name);\n\t\t\treturn;\n\t\t}\n\t\tdbg_ptr = entry->mem_ptr;\n\t\tend_ptr = dbg_ptr + memory_size;\n\n\t\tdoneflag = entry->done_flag;\n\t\tmwifiex_dbg(adapter, DUMP, \"Start %s output, please wait...\\n\",\n\t\t\t    entry->mem_name);\n\n\t\tdo {\n\t\t\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\t\t\tif (RDWR_STATUS_FAILURE == stat)\n\t\t\t\treturn;\n\n\t\t\treg_start = creg->fw_dump_start;\n\t\t\treg_end = creg->fw_dump_end;\n\t\t\tfor (reg = reg_start; reg <= reg_end; reg++) {\n\t\t\t\tmwifiex_read_reg_byte(adapter, reg, dbg_ptr);\n\t\t\t\tif (dbg_ptr < end_ptr) {\n\t\t\t\t\tdbg_ptr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"pre-allocated buf not enough\\n\");\n\t\t\t\ttmp_ptr =\n\t\t\t\t\tvzalloc(memory_size + MWIFIEX_SIZE_4K);\n\t\t\t\tif (!tmp_ptr)\n\t\t\t\t\treturn;\n\t\t\t\tmemcpy(tmp_ptr, entry->mem_ptr, memory_size);\n\t\t\t\tvfree(entry->mem_ptr);\n\t\t\t\tentry->mem_ptr = tmp_ptr;\n\t\t\t\ttmp_ptr = NULL;\n\t\t\t\tdbg_ptr = entry->mem_ptr + memory_size;\n\t\t\t\tmemory_size += MWIFIEX_SIZE_4K;\n\t\t\t\tend_ptr = entry->mem_ptr + memory_size;\n\t\t\t}\n\n\t\t\tif (stat != RDWR_STATUS_DONE)\n\t\t\t\tcontinue;\n\n\t\t\tmwifiex_dbg(adapter, DUMP,\n\t\t\t\t    \"%s done: size=0x%tx\\n\",\n\t\t\t\t    entry->mem_name, dbg_ptr - entry->mem_ptr);\n\t\t\tbreak;\n\t\t} while (true);\n\t}\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump end ==\\n\");\n}\n\nstatic void mwifiex_pcie_device_dump_work(struct mwifiex_adapter *adapter)\n{\n\tadapter->devdump_data = vzalloc(MWIFIEX_FW_DUMP_SIZE);\n\tif (!adapter->devdump_data) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"vzalloc devdump data failure!\\n\");\n\t\treturn;\n\t}\n\n\tmwifiex_drv_info_dump(adapter);\n\tmwifiex_pcie_fw_dump(adapter);\n\tmwifiex_prepare_fw_dump_info(adapter);\n\tmwifiex_upload_device_dump(adapter);\n}\n\nstatic void mwifiex_pcie_card_reset_work(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t/* We can't afford to wait here; remove() might be waiting on us. If we\n\t * can't grab the device lock, maybe we'll get another chance later.\n\t */\n\tpci_try_reset_function(card->dev);\n}\n\nstatic void mwifiex_pcie_work(struct work_struct *work)\n{\n\tstruct pcie_service_card *card =\n\t\tcontainer_of(work, struct pcie_service_card, work);\n\n\tif (test_and_clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t       &card->work_flags))\n\t\tmwifiex_pcie_device_dump_work(card->adapter);\n\tif (test_and_clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET,\n\t\t\t       &card->work_flags))\n\t\tmwifiex_pcie_card_reset_work(card->adapter);\n}\n\n/* This function dumps FW information */\nstatic void mwifiex_pcie_device_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t      &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic void mwifiex_pcie_card_reset(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic int mwifiex_pcie_alloc_buffers(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret;\n\n\tcard->cmdrsp_buf = NULL;\n\tret = mwifiex_pcie_create_txbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create txbd ring\\n\");\n\t\tgoto err_cre_txbd;\n\t}\n\n\tret = mwifiex_pcie_create_rxbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create rxbd ring\\n\");\n\t\tgoto err_cre_rxbd;\n\t}\n\n\tret = mwifiex_pcie_create_evtbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create evtbd ring\\n\");\n\t\tgoto err_cre_evtbd;\n\t}\n\n\tret = mwifiex_pcie_alloc_cmdrsp_buf(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to allocate cmdbuf buffer\\n\");\n\t\tgoto err_alloc_cmdbuf;\n\t}\n\n\tif (reg->sleep_cookie) {\n\t\tret = mwifiex_pcie_alloc_sleep_cookie_buf(adapter);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Failed to allocate sleep_cookie buffer\\n\");\n\t\t\tgoto err_alloc_cookie;\n\t\t}\n\t} else {\n\t\tcard->sleep_cookie_vbase = NULL;\n\t}\n\n\treturn 0;\n\nerr_alloc_cookie:\n\tmwifiex_pcie_delete_cmdrsp_buf(adapter);\nerr_alloc_cmdbuf:\n\tmwifiex_pcie_delete_evtbd_ring(adapter);\nerr_cre_evtbd:\n\tmwifiex_pcie_delete_rxbd_ring(adapter);\nerr_cre_rxbd:\n\tmwifiex_pcie_delete_txbd_ring(adapter);\nerr_cre_txbd:\n\treturn ret;\n}\n\nstatic void mwifiex_pcie_free_buffers(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (reg->sleep_cookie)\n\t\tmwifiex_pcie_delete_sleep_cookie_buf(adapter);\n\n\tmwifiex_pcie_delete_cmdrsp_buf(adapter);\n\tmwifiex_pcie_delete_evtbd_ring(adapter);\n\tmwifiex_pcie_delete_rxbd_ring(adapter);\n\tmwifiex_pcie_delete_txbd_ring(adapter);\n}\n\n/*\n * This function initializes the PCI-E host memory space, WCB rings, etc.\n */\nstatic int mwifiex_init_pcie(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tint ret;\n\tstruct pci_dev *pdev = card->dev;\n\n\tpci_set_drvdata(pdev, card);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto err_enable_dev;\n\n\tpci_set_master(pdev);\n\n\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tpr_err(\"set_dma_mask(32) failed: %d\\n\", ret);\n\t\tgoto err_set_dma_mask;\n\t}\n\n\tret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tpr_err(\"set_consistent_dma_mask(64) failed\\n\");\n\t\tgoto err_set_dma_mask;\n\t}\n\n\tret = pci_request_region(pdev, 0, DRV_NAME);\n\tif (ret) {\n\t\tpr_err(\"req_reg(0) error\\n\");\n\t\tgoto err_req_region0;\n\t}\n\tcard->pci_mmap = pci_iomap(pdev, 0, 0);\n\tif (!card->pci_mmap) {\n\t\tpr_err(\"iomap(0) error\\n\");\n\t\tret = -EIO;\n\t\tgoto err_iomap0;\n\t}\n\tret = pci_request_region(pdev, 2, DRV_NAME);\n\tif (ret) {\n\t\tpr_err(\"req_reg(2) error\\n\");\n\t\tgoto err_req_region2;\n\t}\n\tcard->pci_mmap1 = pci_iomap(pdev, 2, 0);\n\tif (!card->pci_mmap1) {\n\t\tpr_err(\"iomap(2) error\\n\");\n\t\tret = -EIO;\n\t\tgoto err_iomap2;\n\t}\n\n\tpr_notice(\"PCI memory map Virt0: %pK PCI memory map Virt2: %pK\\n\",\n\t\t  card->pci_mmap, card->pci_mmap1);\n\n\tret = mwifiex_pcie_alloc_buffers(adapter);\n\tif (ret)\n\t\tgoto err_alloc_buffers;\n\n\treturn 0;\n\nerr_alloc_buffers:\n\tpci_iounmap(pdev, card->pci_mmap1);\nerr_iomap2:\n\tpci_release_region(pdev, 2);\nerr_req_region2:\n\tpci_iounmap(pdev, card->pci_mmap);\nerr_iomap0:\n\tpci_release_region(pdev, 0);\nerr_req_region0:\nerr_set_dma_mask:\n\tpci_disable_device(pdev);\nerr_enable_dev:\n\treturn ret;\n}\n\n/*\n * This function cleans up the allocated card buffers.\n */\nstatic void mwifiex_cleanup_pcie(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret;\n\tu32 fw_status;\n\n\tcancel_work_sync(&card->work);\n\n\tret = mwifiex_read_reg(adapter, reg->fw_status, &fw_status);\n\tif (fw_status == FIRMWARE_READY_PCIE) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"Clearing driver ready signature\\n\");\n\t\tif (mwifiex_write_reg(adapter, reg->drv_rdy, 0x00000000))\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write driver not-ready signature\\n\");\n\t}\n\n\tpci_disable_device(pdev);\n\n\tpci_iounmap(pdev, card->pci_mmap);\n\tpci_iounmap(pdev, card->pci_mmap1);\n\tpci_release_region(pdev, 2);\n\tpci_release_region(pdev, 0);\n\n\tmwifiex_pcie_free_buffers(adapter);\n}\n\nstatic int mwifiex_pcie_request_irq(struct mwifiex_adapter *adapter)\n{\n\tint ret, i, j;\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\n\tif (card->pcie.reg->msix_support) {\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tcard->msix_entries[i].entry = i;\n\t\tret = pci_enable_msix_exact(pdev, card->msix_entries,\n\t\t\t\t\t    MWIFIEX_NUM_MSIX_VECTORS);\n\t\tif (!ret) {\n\t\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++) {\n\t\t\t\tcard->msix_ctx[i].dev = pdev;\n\t\t\t\tcard->msix_ctx[i].msg_id = i;\n\n\t\t\t\tret = request_irq(card->msix_entries[i].vector,\n\t\t\t\t\t\t  mwifiex_pcie_interrupt, 0,\n\t\t\t\t\t\t  \"MWIFIEX_PCIE_MSIX\",\n\t\t\t\t\t\t  &card->msix_ctx[i]);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, INFO, \"request_irq fail: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tfree_irq(card->msix_entries[j].vector,\n\t\t\t\t\t\t &card->msix_ctx[i]);\n\t\t\t\tpci_disable_msix(pdev);\n\t\t\t} else {\n\t\t\t\tmwifiex_dbg(adapter, MSG, \"MSIx enabled!\");\n\t\t\t\tcard->msix_enable = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pci_enable_msi(pdev) != 0)\n\t\tpci_disable_msi(pdev);\n\telse\n\t\tcard->msi_enable = 1;\n\n\tmwifiex_dbg(adapter, INFO, \"msi_enable = %d\\n\", card->msi_enable);\n\n\tcard->share_irq_ctx.dev = pdev;\n\tcard->share_irq_ctx.msg_id = -1;\n\tret = request_irq(pdev->irq, mwifiex_pcie_interrupt, IRQF_SHARED,\n\t\t\t  \"MRVL_PCIE\", &card->share_irq_ctx);\n\tif (ret) {\n\t\tpr_err(\"request_irq failed: ret=%d\\n\", ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * This function gets the firmware name for downloading by revision id\n *\n * Read revision id register to get revision id\n */\nstatic void mwifiex_pcie_get_fw_name(struct mwifiex_adapter *adapter)\n{\n\tint revision_id = 0;\n\tint version, magic;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tswitch (card->dev->device) {\n\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\tstrcpy(adapter->fw_name, PCIE8766_DEFAULT_FW_NAME);\n\t\tbreak;\n\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tmwifiex_write_reg(adapter, 0x0c58, 0x80c00000);\n\t\tmwifiex_read_reg(adapter, 0x0c58, &revision_id);\n\t\trevision_id &= 0xff00;\n\t\tswitch (revision_id) {\n\t\tcase PCIE8897_A0:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_A0_FW_NAME);\n\t\t\tbreak;\n\t\tcase PCIE8897_B0:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_B0_FW_NAME);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_DEFAULT_FW_NAME);\n\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\tmwifiex_read_reg(adapter, 0x8, &revision_id);\n\t\tmwifiex_read_reg(adapter, 0x0cd0, &version);\n\t\tmwifiex_read_reg(adapter, 0x0cd4, &magic);\n\t\trevision_id &= 0xff;\n\t\tversion &= 0x7;\n\t\tmagic &= 0xff;\n\t\tif (revision_id == PCIE8997_A1 &&\n\t\t    magic == CHIP_MAGIC_VALUE &&\n\t\t    version == CHIP_VER_PCIEUART)\n\t\t\tstrcpy(adapter->fw_name, PCIEUART8997_FW_NAME_V4);\n\t\telse\n\t\t\tstrcpy(adapter->fw_name, PCIEUSB8997_FW_NAME_V4);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n * This function registers the PCIE device.\n *\n * PCIE IRQ is claimed, block size is set and driver data is initialized.\n */\nstatic int mwifiex_register_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t/* save adapter pointer in card */\n\tcard->adapter = adapter;\n\n\tif (mwifiex_pcie_request_irq(adapter))\n\t\treturn -1;\n\n\tadapter->tx_buf_size = card->pcie.tx_buf_size;\n\tadapter->mem_type_mapping_tbl = card->pcie.mem_type_mapping_tbl;\n\tadapter->num_mem_types = card->pcie.num_mem_types;\n\tadapter->ext_scan = card->pcie.can_ext_scan;\n\tmwifiex_pcie_get_fw_name(adapter);\n\n\treturn 0;\n}\n\n/*\n * This function unregisters the PCIE device.\n *\n * The PCIE IRQ is released, the function is disabled and driver\n * data is set to null.\n */\nstatic void mwifiex_unregister_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\tint i;\n\n\tif (card->msix_enable) {\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tsynchronize_irq(card->msix_entries[i].vector);\n\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tfree_irq(card->msix_entries[i].vector,\n\t\t\t\t &card->msix_ctx[i]);\n\n\t\tcard->msix_enable = 0;\n\t\tpci_disable_msix(pdev);\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s(): calling free_irq()\\n\", __func__);\n\t       free_irq(card->dev->irq, &card->share_irq_ctx);\n\n\t\tif (card->msi_enable)\n\t\t\tpci_disable_msi(pdev);\n\t}\n\tcard->adapter = NULL;\n}\n\n/*\n * This function initializes the PCI-E host memory space, WCB rings, etc.,\n * similar to mwifiex_init_pcie(), but without resetting PCI-E state.\n */\nstatic void mwifiex_pcie_up_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\n\t/* tx_buf_size might be changed to 3584 by firmware during\n\t * data transfer, we should reset it to default size.\n\t */\n\tadapter->tx_buf_size = card->pcie.tx_buf_size;\n\n\tmwifiex_pcie_alloc_buffers(adapter);\n\n\tpci_set_master(pdev);\n}\n\n/* This function cleans up the PCI-E host memory space. */\nstatic void mwifiex_pcie_down_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct pci_dev *pdev = card->dev;\n\n\tif (mwifiex_write_reg(adapter, reg->drv_rdy, 0x00000000))\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to write driver not-ready signature\\n\");\n\n\tpci_clear_master(pdev);\n\n\tadapter->seq_num = 0;\n\n\tmwifiex_pcie_free_buffers(adapter);\n}\n\nstatic struct mwifiex_if_ops pcie_ops = {\n\t.init_if =\t\t\tmwifiex_init_pcie,\n\t.cleanup_if =\t\t\tmwifiex_cleanup_pcie,\n\t.check_fw_status =\t\tmwifiex_check_fw_status,\n\t.check_winner_status =          mwifiex_check_winner_status,\n\t.prog_fw =\t\t\tmwifiex_prog_fw_w_helper,\n\t.register_dev =\t\t\tmwifiex_register_dev,\n\t.unregister_dev =\t\tmwifiex_unregister_dev,\n\t.enable_int =\t\t\tmwifiex_pcie_enable_host_int,\n\t.disable_int =\t\t\tmwifiex_pcie_disable_host_int_noerr,\n\t.process_int_status =\t\tmwifiex_process_int_status,\n\t.host_to_card =\t\t\tmwifiex_pcie_host_to_card,\n\t.wakeup =\t\t\tmwifiex_pm_wakeup_card,\n\t.wakeup_complete =\t\tmwifiex_pm_wakeup_card_complete,\n\n\t/* PCIE specific */\n\t.cmdrsp_complete =\t\tmwifiex_pcie_cmdrsp_complete,\n\t.event_complete =\t\tmwifiex_pcie_event_complete,\n\t.update_mp_end_port =\t\tNULL,\n\t.cleanup_mpa_buf =\t\tNULL,\n\t.init_fw_port =\t\t\tmwifiex_pcie_init_fw_port,\n\t.clean_pcie_ring =\t\tmwifiex_clean_pcie_ring_buf,\n\t.card_reset =\t\t\tmwifiex_pcie_card_reset,\n\t.reg_dump =\t\t\tmwifiex_pcie_reg_dump,\n\t.device_dump =\t\t\tmwifiex_pcie_device_dump,\n\t.down_dev =\t\t\tmwifiex_pcie_down_dev,\n\t.up_dev =\t\t\tmwifiex_pcie_up_dev,\n};\n\nmodule_pci_driver(mwifiex_pcie);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell WiFi-Ex PCI-Express Driver version \" PCIE_VERSION);\nMODULE_VERSION(PCIE_VERSION);\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/net/wireless/marvell/mwifiex/pcie.c"], "buggy_code_start_loc": [1032], "buggy_code_end_loc": [1033], "fixing_code_start_loc": [1032], "fixing_code_end_loc": [1036], "type": "CWE-401", "message": "A memory leak in the mwifiex_pcie_alloc_cmdrsp_buf() function in drivers/net/wireless/marvell/mwifiex/pcie.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mwifiex_map_pci_memory() failures, aka CID-db8fd2cde932.", "other": {"cve": {"id": "CVE-2019-19056", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.077", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the mwifiex_pcie_alloc_cmdrsp_buf() function in drivers/net/wireless/marvell/mwifiex/pcie.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mwifiex_map_pci_memory() failures, aka CID-db8fd2cde932."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n mwifiex_pcie_alloc_cmdrsp_buf() en el archivo drivers/net/wireless/marvell/mwifiex/pcie.c en el kernel de Linux versiones hasta la versi\u00f3n  5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n mwifiex_map_pci_memory(), tambi\u00e9n se conoce como CID-db8fd2cde932."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/db8fd2cde93227e566a412cf53173ffa227998bc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00013.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4286-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4286-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4300-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4301-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4302-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/db8fd2cde93227e566a412cf53173ffa227998bc"}}