{"buggy_code": ["/* FriBidi\n * fribidi-bidi.c - bidirectional algorithm\n *\n * Authors:\n *   Behdad Esfahbod, 2001, 2002, 2004\n *   Dov Grobgeld, 1999, 2000, 2017\n *\n * Copyright (C) 2004 Sharif FarsiWeb, Inc\n * Copyright (C) 2001,2002 Behdad Esfahbod\n * Copyright (C) 1999,2000,2017 Dov Grobgeld\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library, in a file named COPYING; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA\n *\n * For licensing issues, contact <fribidi.license@gmail.com>.\n */\n\n#include \"common.h\"\n\n#include <fribidi-bidi.h>\n#include <fribidi-mirroring.h>\n#include <fribidi-brackets.h>\n#include <fribidi-unicode.h>\n\n#include \"bidi-types.h\"\n#include \"run.h\"\n\n/*\n * This file implements most of Unicode Standard Annex #9, Tracking Number 13.\n */\n\n#ifndef MAX\n# define MAX(a,b) ((a) > (b) ? (a) : (b))\n#endif /* !MAX */\n\n/* Some convenience macros */\n#define RL_TYPE(list) ((list)->type)\n#define RL_LEN(list) ((list)->len)\n#define RL_LEVEL(list) ((list)->level)\n\n/* \"Within this scope, bidirectional types EN and AN are treated as R\" */\n#define RL_TYPE_AN_EN_AS_RTL(list) ( \\\n (((list)->type == FRIBIDI_TYPE_AN) || ((list)->type == FRIBIDI_TYPE_EN) | ((list)->type == FRIBIDI_TYPE_RTL)) ? FRIBIDI_TYPE_RTL : (list)->type)\n#define RL_BRACKET_TYPE(list) ((list)->bracket_type)\n#define RL_ISOLATE_LEVEL(list) ((list)->isolate_level)\n\n#define LOCAL_BRACKET_SIZE 16\n\n/* Pairing nodes are used for holding a pair of open/close brackets as\n   described in BD16. */\nstruct _FriBidiPairingNodeStruct {\n  FriBidiRun *open;\n  FriBidiRun *close;\n  struct _FriBidiPairingNodeStruct *next;\n};\ntypedef struct _FriBidiPairingNodeStruct FriBidiPairingNode;\n\nstatic FriBidiRun *\nmerge_with_prev (\n  FriBidiRun *second\n)\n{\n  FriBidiRun *first;\n\n  fribidi_assert (second);\n  fribidi_assert (second->next);\n  first = second->prev;\n  fribidi_assert (first);\n\n  first->next = second->next;\n  first->next->prev = first;\n  RL_LEN (first) += RL_LEN (second);\n  if (second->next_isolate)\n    second->next_isolate->prev_isolate = first;\n  first->next_isolate = second->next_isolate;\n\n  fribidi_free (second);\n  return first;\n}\n\nstatic void\ncompact_list (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    for_run_list (list, list)\n      if (RL_TYPE (list->prev) == RL_TYPE (list)\n\t  && RL_LEVEL (list->prev) == RL_LEVEL (list)\n          && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n          && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n          )\n      list = merge_with_prev (list);\n}\n\nstatic void\ncompact_neutrals (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    {\n      for_run_list (list, list)\n      {\n\tif (RL_LEVEL (list->prev) == RL_LEVEL (list)\n\t    &&\n\t    ((RL_TYPE (list->prev) == RL_TYPE (list)\n\t      || (FRIBIDI_IS_NEUTRAL (RL_TYPE (list->prev))\n\t\t  && FRIBIDI_IS_NEUTRAL (RL_TYPE (list)))))\n            && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n            && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n            )\n\t  list = merge_with_prev (list);\n      }\n    }\n}\n\n/* Search for an adjacent run in the forward or backward direction.\n   It uses the next_isolate and prev_isolate run for short circuited searching.\n */\n\n/* The static sentinel is used to signal the end of an isolating\n   sequence */\nstatic FriBidiRun sentinel = { NULL, NULL, 0,0, FRIBIDI_TYPE_SENTINEL, -1,-1,FRIBIDI_NO_BRACKET, NULL, NULL };\n\nstatic FriBidiRun *get_adjacent_run(FriBidiRun *list, fribidi_boolean forward, fribidi_boolean skip_neutral)\n{\n  FriBidiRun *ppp = forward ? list->next_isolate : list->prev_isolate;\n  if (!ppp)\n    return &sentinel;\n\n  while (ppp)\n    {\n      FriBidiCharType ppp_type = RL_TYPE (ppp);\n\n      if (ppp_type == FRIBIDI_TYPE_SENTINEL)\n        break;\n\n      /* Note that when sweeping forward we continue one run\n         beyond the PDI to see what lies behind. When looking\n         backwards, this is not necessary as the leading isolate\n         run has already been assigned the resolved level. */\n      if (ppp->isolate_level > list->isolate_level   /* <- How can this be true? */\n          || (forward && ppp_type == FRIBIDI_TYPE_PDI)\n          || (skip_neutral && !FRIBIDI_IS_STRONG(ppp_type)))\n        {\n          ppp = forward ? ppp->next_isolate : ppp->prev_isolate;\n          if (!ppp)\n            ppp = &sentinel;\n\n          continue;\n        }\n      break;\n    }\n\n  return ppp;\n}\n\n#ifdef DEBUG\n/*======================================================================\n *  For debugging, define some functions for printing the types and the\n *  levels.\n *----------------------------------------------------------------------*/\n\nstatic char char_from_level_array[] = {\n  '$',\t\t\t\t/* -1 == FRIBIDI_SENTINEL, indicating\n\t\t\t\t * start or end of string. */\n  /* 0-61 == 0-9,a-z,A-Z are the the only valid levels before resolving\n   * implicits.  after that the level @ may be appear too. */\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n  'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n  'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',\n  'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n  'Y', 'Z',\n\n  /* TBD - insert another 125-64 levels */\n\n  '@',\t\t\t\t/* 62 == only must appear after resolving\n\t\t\t\t * implicits. */\n\n  '!',\t\t\t\t/* 63 == FRIBIDI_LEVEL_INVALID, internal error,\n\t\t\t\t * this level shouldn't be seen.  */\n\n  '*', '*', '*', '*', '*'\t/* >= 64 == overflows, this levels and higher\n\t\t\t\t * levels show a real bug!. */\n};\n\n#define fribidi_char_from_level(level) char_from_level_array[(level) + 1]\n\nstatic void\nprint_types_re (\n  const FriBidiRun *pp\n)\n{\n  fribidi_assert (pp);\n\n  MSG (\"  Run types  : \");\n  for_run_list (pp, pp)\n  {\n    MSG6 (\"%d:%d(%s)[%d,%d] \",\n\t  pp->pos, pp->len, fribidi_get_bidi_type_name (pp->type), pp->level, pp->isolate_level);\n  }\n  MSG (\"\\n\");\n}\n\nstatic void\nprint_resolved_levels (\n  const FriBidiRun *pp\n)\n{\n  fribidi_assert (pp);\n\n  MSG (\"  Res. levels: \");\n  for_run_list (pp, pp)\n  {\n    register FriBidiStrIndex i;\n    for (i = RL_LEN (pp); i; i--)\n      MSG2 (\"%c\", fribidi_char_from_level (RL_LEVEL (pp)));\n  }\n  MSG (\"\\n\");\n}\n\nstatic void\nprint_resolved_types (\n  const FriBidiRun *pp\n)\n{\n  fribidi_assert (pp);\n\n  MSG (\"  Res. types : \");\n  for_run_list (pp, pp)\n  {\n    FriBidiStrIndex i;\n    for (i = RL_LEN (pp); i; i--)\n      MSG2 (\"%s \", fribidi_get_bidi_type_name (pp->type));\n  }\n  MSG (\"\\n\");\n}\n\nstatic void\nprint_bidi_string (\n  /* input */\n  const FriBidiCharType *bidi_types,\n  const FriBidiStrIndex len\n)\n{\n  register FriBidiStrIndex i;\n\n  fribidi_assert (bidi_types);\n\n  MSG (\"  Org. types : \");\n  for (i = 0; i < len; i++)\n    MSG2 (\"%s \", fribidi_get_bidi_type_name (bidi_types[i]));\n  MSG (\"\\n\");\n}\n\nstatic void print_pairing_nodes(FriBidiPairingNode *nodes)\n{\n  MSG (\"Pairs: \");\n  while (nodes)\n    {\n      MSG3 (\"(%d, %d) \", nodes->open->pos, nodes->close->pos);\n      nodes = nodes->next;\n    }\n  MSG (\"\\n\");\n}\n#endif /* DEBUG */\n\n\n/*=========================================================================\n * define macros for push and pop the status in to / out of the stack\n *-------------------------------------------------------------------------*/\n\n/* There are a few little points in pushing into and popping from the status\n   stack:\n   1. when the embedding level is not valid (more than\n   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL=125), you must reject it, and not to push\n   into the stack, but when you see a PDF, you must find the matching code,\n   and if it was pushed in the stack, pop it, it means you must pop if and\n   only if you have pushed the matching code, the over_pushed var counts the\n   number of rejected codes so far.\n\n   2. there's a more confusing point too, when the embedding level is exactly\n   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL-1=124, an LRO, LRE, or LRI is rejected\n   because the new level would be FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL+1=126, that\n   is invalid; but an RLO, RLE, or RLI is accepted because the new level is\n   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL=125, that is valid, so the rejected codes\n   may be not continuous in the logical order, in fact there are at most two\n   continuous intervals of codes, with an RLO, RLE, or RLI between them.  To\n   support this case, the first_interval var counts the number of rejected\n   codes in the first interval, when it is 0, means that there is only one\n   interval.\n\n*/\n\n/* a. If this new level would be valid, then this embedding code is valid.\n   Remember (push) the current embedding level and override status.\n   Reset current level to this new level, and reset the override status to\n   new_override.\n   b. If the new level would not be valid, then this code is invalid. Don't\n   change the current level or override status.\n*/\n#define PUSH_STATUS \\\n    FRIBIDI_BEGIN_STMT \\\n      if LIKELY(over_pushed == 0 \\\n                && isolate_overflow == 0 \\\n                && new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL)   \\\n        { \\\n          if UNLIKELY(level == FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL - 1) \\\n            first_interval = over_pushed; \\\n          status_stack[stack_size].level = level; \\\n          status_stack[stack_size].isolate_level = isolate_level; \\\n          status_stack[stack_size].isolate = isolate; \\\n          status_stack[stack_size].override = override; \\\n          stack_size++; \\\n          level = new_level; \\\n          override = new_override; \\\n        } else if LIKELY(isolate_overflow == 0) \\\n\t  over_pushed++; \\\n    FRIBIDI_END_STMT\n\n/* If there was a valid matching code, restore (pop) the last remembered\n   (pushed) embedding level and directional override.\n*/\n#define POP_STATUS \\\n    FRIBIDI_BEGIN_STMT \\\n      if (stack_size) \\\n      { \\\n        if UNLIKELY(over_pushed > first_interval) \\\n          over_pushed--; \\\n        else \\\n          { \\\n            if LIKELY(over_pushed == first_interval) \\\n              first_interval = 0; \\\n            stack_size--; \\\n            level = status_stack[stack_size].level; \\\n            override = status_stack[stack_size].override; \\\n            isolate = status_stack[stack_size].isolate; \\\n            isolate_level = status_stack[stack_size].isolate_level; \\\n          } \\\n      } \\\n    FRIBIDI_END_STMT\n\n\n/* Return the type of previous run or the SOR, if already at the start of\n   a level run. */\n#define PREV_TYPE_OR_SOR(pp) \\\n    ( \\\n      RL_LEVEL(pp->prev) == RL_LEVEL(pp) ? \\\n        RL_TYPE(pp->prev) : \\\n        FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(pp->prev), RL_LEVEL(pp))) \\\n    )\n\n/* Return the type of next run or the EOR, if already at the end of\n   a level run. */\n#define NEXT_TYPE_OR_EOR(pp) \\\n    ( \\\n      RL_LEVEL(pp->next) == RL_LEVEL(pp) ? \\\n        RL_TYPE(pp->next) : \\\n        FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(pp->next), RL_LEVEL(pp))) \\\n    )\n\n\n/* Return the embedding direction of a link. */\n#define FRIBIDI_EMBEDDING_DIRECTION(link) \\\n    FRIBIDI_LEVEL_TO_DIR(RL_LEVEL(link))\n\n\nFRIBIDI_ENTRY FriBidiParType\nfribidi_get_par_direction (\n  /* input */\n  const FriBidiCharType *bidi_types,\n  const FriBidiStrIndex len\n)\n{\n  register FriBidiStrIndex i;\n\n  fribidi_assert (bidi_types);\n\n  for (i = 0; i < len; i++)\n    if (FRIBIDI_IS_LETTER (bidi_types[i]))\n      return FRIBIDI_IS_RTL (bidi_types[i]) ? FRIBIDI_PAR_RTL :\n\tFRIBIDI_PAR_LTR;\n\n  return FRIBIDI_PAR_ON;\n}\n\n/* Push a new entry to the pairing linked list */\nstatic FriBidiPairingNode * pairing_nodes_push(FriBidiPairingNode *nodes,\n                                               FriBidiRun *open,\n                                               FriBidiRun *close)\n{\n  FriBidiPairingNode *node = fribidi_malloc(sizeof(FriBidiPairingNode));\n  node->open = open;\n  node->close = close;\n  node->next = nodes;\n  nodes = node;\n  return nodes;\n}\n\n/* Sort by merge sort */\nstatic void pairing_nodes_front_back_split(FriBidiPairingNode *source,\n                                           /* output */\n                                           FriBidiPairingNode **front,\n                                           FriBidiPairingNode **back)\n{\n  FriBidiPairingNode *pfast, *pslow;\n  if (!source || !source->next)\n    {\n      *front = source;\n      *back = NULL;\n    }\n  else\n    {\n      pslow = source;\n      pfast = source->next;\n      while (pfast)\n        {\n          pfast= pfast->next;\n          if (pfast)\n            {\n              pfast = pfast->next;\n              pslow = pslow->next;\n            }\n        }\n      *front = source;\n      *back = pslow->next;\n      pslow->next = NULL;\n    }\n}\n\nstatic FriBidiPairingNode *\npairing_nodes_sorted_merge(FriBidiPairingNode *nodes1,\n                           FriBidiPairingNode *nodes2)\n{\n  FriBidiPairingNode *res = NULL;\n  if (!nodes1)\n    return nodes2;\n  if (!nodes2)\n    return nodes1;\n\n  if (nodes1->open->pos < nodes2->open->pos)\n    {\n      res = nodes1;\n      res->next = pairing_nodes_sorted_merge(nodes1->next, nodes2);\n    }\n  else\n    {\n      res = nodes2;\n      res->next = pairing_nodes_sorted_merge(nodes1, nodes2->next);\n    }\n  return res;\n}\n\nstatic void sort_pairing_nodes(FriBidiPairingNode **nodes)\n{\n  FriBidiPairingNode *front, *back;\n\n  /* 0 or 1 node case */\n  if (!*nodes || !(*nodes)->next)\n    return;\n\n  pairing_nodes_front_back_split(*nodes, &front, &back);\n  sort_pairing_nodes(&front);\n  sort_pairing_nodes(&back);\n  *nodes = pairing_nodes_sorted_merge(front, back);\n}\n\nstatic void free_pairing_nodes(FriBidiPairingNode *nodes)\n{\n  while (nodes)\n    {\n      FriBidiPairingNode *p = nodes;\n      nodes = nodes->next;\n      fribidi_free(p);\n    }\n}\n\nFRIBIDI_ENTRY FriBidiLevel\nfribidi_get_par_embedding_levels_ex (\n  /* input */\n  const FriBidiCharType *bidi_types,\n  const FriBidiBracketType *bracket_types,\n  const FriBidiStrIndex len,\n  /* input and output */\n  FriBidiParType *pbase_dir,\n  /* output */\n  FriBidiLevel *embedding_levels\n)\n{\n  FriBidiLevel base_level_per_iso_level[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n  FriBidiLevel base_level, max_level = 0;\n  FriBidiParType base_dir;\n  FriBidiRun *main_run_list = NULL, *explicits_list = NULL, *pp;\n  fribidi_boolean status = false;\n  int max_iso_level = 0;\n\n  if UNLIKELY\n    (!len)\n    {\n      status = true;\n      goto out;\n    }\n\n  DBG (\"in fribidi_get_par_embedding_levels\");\n\n  fribidi_assert (bidi_types);\n  fribidi_assert (pbase_dir);\n  fribidi_assert (embedding_levels);\n\n  /* Determinate character types */\n  {\n    /* Get run-length encoded character types */\n    main_run_list = run_list_encode_bidi_types (bidi_types, bracket_types, len);\n    if UNLIKELY\n      (!main_run_list) goto out;\n  }\n\n  /* Find base level */\n  /* If no strong base_dir was found, resort to the weak direction\n     that was passed on input. */\n  base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);\n  if (!FRIBIDI_IS_STRONG (*pbase_dir))\n    /* P2. P3. Search for first strong character and use its direction as\n       base direction */\n    {\n      int valid_isolate_count = 0;\n      for_run_list (pp, main_run_list)\n        {\n          if (RL_TYPE(pp) == FRIBIDI_TYPE_PDI)\n            {\n              /* Ignore if there is no matching isolate */\n              if (valid_isolate_count>0)\n                valid_isolate_count--;\n            }\n          else if (FRIBIDI_IS_ISOLATE(RL_TYPE(pp)))\n            valid_isolate_count++;\n          else if (valid_isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (pp)))\n            {\n              base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (pp));\n              *pbase_dir = FRIBIDI_LEVEL_TO_DIR (base_level);\n              break;\n            }\n        }\n    }\n  base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);\n  DBG2 (\"  base level : %c\", fribidi_char_from_level (base_level));\n  DBG2 (\"  base dir   : %s\", fribidi_get_bidi_type_name (base_dir));\n\n  base_level_per_iso_level[0] = base_level;\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* Explicit Levels and Directions */\n  DBG (\"explicit levels and directions\");\n  {\n    FriBidiLevel level, new_level = 0;\n    int isolate_level = 0;\n    FriBidiCharType override, new_override;\n    FriBidiStrIndex i;\n    int stack_size, over_pushed, first_interval;\n    int valid_isolate_count = 0;\n    int isolate_overflow = 0;\n    int isolate = 0; /* The isolate status flag */\n    struct\n    {\n      FriBidiCharType override;\t/* only LTR, RTL and ON are valid */\n      FriBidiLevel level;\n      int isolate;\n      int isolate_level;\n    } status_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    FriBidiRun temp_link;\n    FriBidiRun *run_per_isolate_level[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n\n    memset(run_per_isolate_level, 0, sizeof(run_per_isolate_level[0])\n           * FRIBIDI_BIDI_MAX_RESOLVED_LEVELS);\n\n/* explicits_list is a list like main_run_list, that holds the explicit\n   codes that are removed from main_run_list, to reinsert them later by\n   calling the shadow_run_list.\n*/\n    explicits_list = new_run_list ();\n    if UNLIKELY\n      (!explicits_list) goto out;\n\n    /* X1. Begin by setting the current embedding level to the paragraph\n       embedding level. Set the directional override status to neutral,\n       and directional isolate status to false.\n\n       Process each character iteratively, applying rules X2 through X8.\n       Only embedding levels from 0 to 123 are valid in this phase. */\n\n    level = base_level;\n    override = FRIBIDI_TYPE_ON;\n    /* stack */\n    stack_size = 0;\n    over_pushed = 0;\n    first_interval = 0;\n    valid_isolate_count = 0;\n    isolate_overflow = 0;\n\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType this_type = RL_TYPE (pp);\n      RL_ISOLATE_LEVEL (pp) = isolate_level;\n\n      if (FRIBIDI_IS_EXPLICIT_OR_BN (this_type))\n\t{\n\t  if (FRIBIDI_IS_STRONG (this_type))\n\t    {\t\t\t/* LRE, RLE, LRO, RLO */\n\t      /* 1. Explicit Embeddings */\n\t      /*   X2. With each RLE, compute the least greater odd\n\t         embedding level. */\n\t      /*   X3. With each LRE, compute the least greater even\n\t         embedding level. */\n\t      /* 2. Explicit Overrides */\n\t      /*   X4. With each RLO, compute the least greater odd\n\t         embedding level. */\n\t      /*   X5. With each LRO, compute the least greater even\n\t         embedding level. */\n\t      new_override = FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR (this_type);\n\t      for (i = RL_LEN (pp); i; i--)\n\t\t{\n\t\t  new_level =\n\t\t    ((level + FRIBIDI_DIR_TO_LEVEL (this_type) + 2) & ~1) -\n\t\t    FRIBIDI_DIR_TO_LEVEL (this_type);\n                  isolate = 0;\n\t\t  PUSH_STATUS;\n\t\t}\n\t    }\n\t  else if (this_type == FRIBIDI_TYPE_PDF)\n\t    {\n\t      /* 3. Terminating Embeddings and overrides */\n\t      /*   X7. With each PDF, determine the matching embedding or\n\t         override code. */\n              for (i = RL_LEN (pp); i; i--)\n                {\n                  if (stack_size && status_stack[stack_size-1].isolate != 0)\n                    break;\n                  POP_STATUS;\n                }\n\t    }\n\n\t  /* X9. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes. */\n\t  /* Remove element and add it to explicits_list */\n\t  RL_LEVEL (pp) = FRIBIDI_SENTINEL;\n\t  temp_link.next = pp->next;\n\t  move_node_before (pp, explicits_list);\n\t  pp = &temp_link;\n\t}\n      else if (this_type == FRIBIDI_TYPE_PDI)\n        /* X6a. pop the direction of the stack */\n        {\n          for (i = RL_LEN (pp); i; i--)\n            {\n              if (isolate_overflow > 0)\n                {\n                  isolate_overflow--;\n                  RL_LEVEL (pp) = level;\n                }\n\n              else if (valid_isolate_count > 0)\n                {\n                  /* Pop away all LRE,RLE,LRO, RLO levels\n                     from the stack, as these are implicitly\n                     terminated by the PDI */\n                  while (stack_size && !status_stack[stack_size-1].isolate)\n                    POP_STATUS;\n                  over_pushed = 0; /* The PDI resets the overpushed! */\n                  POP_STATUS;\n                  isolate_level-- ;\n                  valid_isolate_count--;\n                  RL_LEVEL (pp) = level;\n                  RL_ISOLATE_LEVEL (pp) = isolate_level;\n                }\n              else\n                {\n                  /* Ignore isolated PDI's by turning them into ON's */\n                  RL_TYPE (pp) = FRIBIDI_TYPE_ON;\n                  RL_LEVEL (pp) = level;\n                }\n            }\n        }\n      else if (FRIBIDI_IS_ISOLATE(this_type))\n        {\n          /* TBD support RL_LEN > 1 */\n          new_override = FRIBIDI_TYPE_ON;\n          isolate = 1;\n          if (this_type == FRIBIDI_TYPE_LRI)\n            new_level = level + 2 - (level%2);\n          else if (this_type == FRIBIDI_TYPE_RLI)\n            new_level = level + 1 + (level%2);\n          else if (this_type == FRIBIDI_TYPE_FSI)\n            {\n              /* Search for a local strong character until we\n                 meet the corresponding PDI or the end of the\n                 paragraph */\n              FriBidiRun *fsi_pp;\n              int isolate_count = 0;\n              int fsi_base_level = 0;\n              for_run_list (fsi_pp, pp)\n                {\n                  if (RL_TYPE(fsi_pp) == FRIBIDI_TYPE_PDI)\n                    {\n                      isolate_count--;\n                      if (valid_isolate_count < 0)\n                        break;\n                    }\n                  else if (FRIBIDI_IS_ISOLATE(RL_TYPE(fsi_pp)))\n                    isolate_count++;\n                  else if (isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (fsi_pp)))\n                    {\n                      fsi_base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (fsi_pp));\n                      break;\n                    }\n                }\n\n              /* Same behavior like RLI and LRI above */\n              if (FRIBIDI_LEVEL_IS_RTL (fsi_base_level))\n                new_level = level + 1 + (level%2);\n              else\n                new_level = level + 2 - (level%2);\n            }\n\n\t  RL_LEVEL (pp) = level;\n          RL_ISOLATE_LEVEL (pp) = isolate_level++;\n          base_level_per_iso_level[isolate_level] = new_level;\n\n\t  if (!FRIBIDI_IS_NEUTRAL (override))\n\t    RL_TYPE (pp) = override;\n\n          if (new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL)\n            {\n              valid_isolate_count++;\n              PUSH_STATUS;\n              level = new_level;\n            }\n          else\n            isolate_overflow += 1;\n        }\n      else if (this_type == FRIBIDI_TYPE_BS)\n\t{\n\t  /* X8. All explicit directional embeddings and overrides are\n\t     completely terminated at the end of each paragraph. Paragraph\n\t     separators are not included in the embedding. */\n\t  break;\n\t}\n      else\n\t{\n\t  /* X6. For all types besides RLE, LRE, RLO, LRO, and PDF:\n\t     a. Set the level of the current character to the current\n\t     embedding level.\n\t     b. Whenever the directional override status is not neutral,\n\t     reset the current character type to the directional override\n\t     status. */\n\t  RL_LEVEL (pp) = level;\n\t  if (!FRIBIDI_IS_NEUTRAL (override))\n\t    RL_TYPE (pp) = override;\n\t}\n    }\n\n    /* Build the isolate_level connections */\n    for_run_list (pp, main_run_list)\n    {\n      int isolate_level = RL_ISOLATE_LEVEL (pp);\n      if (run_per_isolate_level[isolate_level])\n        {\n          run_per_isolate_level[isolate_level]->next_isolate = pp;\n          pp->prev_isolate = run_per_isolate_level[isolate_level];\n        }\n      run_per_isolate_level[isolate_level] = pp;\n    }\n\n    /* Implementing X8. It has no effect on a single paragraph! */\n    level = base_level;\n    override = FRIBIDI_TYPE_ON;\n    stack_size = 0;\n    over_pushed = 0;\n  }\n  /* X10. The remaining rules are applied to each run of characters at the\n     same level. For each run, determine the start-of-level-run (sor) and\n     end-of-level-run (eor) type, either L or R. This depends on the\n     higher of the two levels on either side of the boundary (at the start\n     or end of the paragraph, the level of the 'other' run is the base\n     embedding level). If the higher level is odd, the type is R, otherwise\n     it is L. */\n  /* Resolving Implicit Levels can be done out of X10 loop, so only change\n     of Resolving Weak Types and Resolving Neutral Types is needed. */\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_bidi_string (bidi_types, len);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 4. Resolving weak types. Also calculate the maximum isolate level */\n  max_iso_level = 0;\n  DBG (\"resolving weak types\");\n  {\n    int last_strong_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    FriBidiCharType prev_type_orig;\n    fribidi_boolean w4;\n\n    last_strong_stack[0] = base_dir;\n\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiCharType prev_type, this_type, next_type;\n      FriBidiRun *ppp_prev, *ppp_next;\n      int iso_level;\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      this_type = RL_TYPE (pp);\n      iso_level = RL_ISOLATE_LEVEL(pp);\n\n      if (iso_level > max_iso_level)\n        max_iso_level = iso_level;\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = RL_TYPE(ppp_prev);\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = RL_TYPE(ppp_next);\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_STRONG (prev_type))\n\tlast_strong_stack[iso_level] = prev_type;\n\n      /* W1. NSM\n         Examine each non-spacing mark (NSM) in the level run, and change the\n         type of the NSM to the type of the previous character. If the NSM\n         is at the start of the level run, it will get the type of sor. */\n      /* Implementation note: it is important that if the previous character\n         is not sor, then we should merge this run with the previous,\n         because of rules like W5, that we assume all of a sequence of\n         adjacent ETs are in one FriBidiRun. */\n      if (this_type == FRIBIDI_TYPE_NSM)\n\t{\n          /* New rule in Unicode 6.3 */\n          if (FRIBIDI_IS_ISOLATE (RL_TYPE (pp->prev)))\n              RL_TYPE(pp) = FRIBIDI_TYPE_ON;\n\n\t  if (RL_LEVEL (ppp_prev) == RL_LEVEL (pp))\n            {\n              if (ppp_prev == pp->prev)\n                pp = merge_with_prev (pp);\n            }\n\t  else\n\t    RL_TYPE (pp) = prev_type;\n\n\t  if (prev_type == next_type && RL_LEVEL (pp) == RL_LEVEL (pp->next))\n\t    {\n              if (ppp_next == pp->next)\n                pp = merge_with_prev (pp->next);\n\t    }\n\t  continue;\t\t/* As we know the next condition cannot be true. */\n\t}\n\n      /* W2: European numbers. */\n      if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_AL)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_AN;\n\n\t  /* Resolving dependency of loops for rules W1 and W2, so we\n\t     can merge them in one loop. */\n\t  if (next_type == FRIBIDI_TYPE_NSM)\n\t    RL_TYPE (ppp_next) = FRIBIDI_TYPE_AN;\n\t}\n    }\n\n\n    last_strong_stack[0] = base_dir;\n\n    /* Resolving dependency of loops for rules W4 and W5, W5 may\n       want to prevent W4 to take effect in the next turn, do this\n       through \"w4\". */\n    w4 = true;\n    /* Resolving dependency of loops for rules W4 and W5 with W7,\n       W7 may change an EN to L but it sets the prev_type_orig if needed,\n       so W4 and W5 in next turn can still do their works. */\n    prev_type_orig = FRIBIDI_TYPE_ON;\n\n    /* Each isolate level has its own memory of the last strong character */\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiCharType prev_type, this_type, next_type;\n      int iso_level;\n      FriBidiRun *ppp_prev, *ppp_next;\n\n      this_type = RL_TYPE (pp);\n      iso_level = RL_ISOLATE_LEVEL(pp);\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = RL_TYPE(ppp_prev);\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = RL_TYPE(ppp_next);\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_STRONG (prev_type))\n\tlast_strong_stack[iso_level] = prev_type;\n\n      /* W2 ??? */\n\n      /* W3: Change ALs to R. */\n      if (this_type == FRIBIDI_TYPE_AL)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_RTL;\n\t  w4 = true;\n\t  prev_type_orig = FRIBIDI_TYPE_ON;\n\t  continue;\n\t}\n\n      /* W4. A single european separator changes to a european number.\n         A single common separator between two numbers of the same type\n         changes to that type. */\n      if (w4\n\t  && RL_LEN (pp) == 1 && FRIBIDI_IS_ES_OR_CS (this_type)\n\t  && FRIBIDI_IS_NUMBER (prev_type_orig)\n\t  && prev_type_orig == next_type\n\t  && (prev_type_orig == FRIBIDI_TYPE_EN\n\t      || this_type == FRIBIDI_TYPE_CS))\n\t{\n\t  RL_TYPE (pp) = prev_type;\n\t  this_type = RL_TYPE (pp);\n\t}\n      w4 = true;\n\n      /* W5. A sequence of European terminators adjacent to European\n         numbers changes to All European numbers. */\n      if (this_type == FRIBIDI_TYPE_ET\n\t  && (prev_type_orig == FRIBIDI_TYPE_EN\n\t      || next_type == FRIBIDI_TYPE_EN))\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_EN;\n\t  w4 = false;\n\t  this_type = RL_TYPE (pp);\n\t}\n\n      /* W6. Otherwise change separators and terminators to other neutral. */\n      if (FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR (this_type))\n\tRL_TYPE (pp) = FRIBIDI_TYPE_ON;\n\n      /* W7. Change european numbers to L. */\n      if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_LTR)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_LTR;\n\t  prev_type_orig = (RL_LEVEL (pp) == RL_LEVEL (pp->next) ?\n\t\t\t    FRIBIDI_TYPE_EN : FRIBIDI_TYPE_ON);\n\t}\n      else\n\tprev_type_orig = PREV_TYPE_OR_SOR (pp->next);\n    }\n  }\n\n  compact_neutrals (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 5. Resolving Neutral Types */\n\n  DBG (\"resolving neutral types - N0\");\n  {\n    /*  BD16 - Build list of all pairs*/\n    int num_iso_levels = max_iso_level + 1;\n    FriBidiPairingNode *pairing_nodes = NULL;\n    FriBidiRun *local_bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL][LOCAL_BRACKET_SIZE];\n    FriBidiRun **bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n    int bracket_stack_size[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n    int last_level = RL_LEVEL(main_run_list);\n    int last_iso_level = 0;\n\n    memset(bracket_stack, 0, sizeof(bracket_stack[0])*num_iso_levels);\n    memset(bracket_stack_size, 0, sizeof(bracket_stack_size[0])*num_iso_levels);\n\n    /* populate the bracket_size. The first LOCAL_BRACKET_SIZE entries\n       of the stack are one the stack. Allocate the rest of the entries.\n     */\n    {\n      int iso_level;\n      for (iso_level=0; iso_level < LOCAL_BRACKET_SIZE; iso_level++)\n        bracket_stack[iso_level] = local_bracket_stack[iso_level];\n\n      for (iso_level=LOCAL_BRACKET_SIZE; iso_level < num_iso_levels; iso_level++)\n        bracket_stack[iso_level] = fribidi_malloc (sizeof (bracket_stack[0])\n                                                       * FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS);\n    }\n\n    /* Build the bd16 pair stack. */\n    for_run_list (pp, main_run_list)\n      {\n        int level = RL_LEVEL(pp);\n        int iso_level = RL_ISOLATE_LEVEL(pp);\n        FriBidiBracketType brack_prop = RL_BRACKET_TYPE(pp);\n\n        /* Interpret the isolating run sequence as such that they\n           end at a change in the level, unless the iso_level has been\n           raised. */\n        if (level != last_level && last_iso_level == iso_level)\n          bracket_stack_size[last_iso_level] = 0;\n\n        if (brack_prop!= FRIBIDI_NO_BRACKET\n            && RL_TYPE(pp)==FRIBIDI_TYPE_ON)\n          {\n            if (FRIBIDI_IS_BRACKET_OPEN(brack_prop))\n              {\n                if (bracket_stack_size[iso_level]==FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS)\n                  break;\n\n                /* push onto the pair stack */\n                bracket_stack[iso_level][bracket_stack_size[iso_level]++] = pp;\n              }\n            else\n              {\n                int stack_idx = bracket_stack_size[iso_level] - 1;\n                while (stack_idx >= 0)\n                  {\n                    FriBidiBracketType se_brack_prop = RL_BRACKET_TYPE(bracket_stack[iso_level][stack_idx]);\n                    if (FRIBIDI_BRACKET_ID(se_brack_prop) == FRIBIDI_BRACKET_ID(brack_prop))\n                      {\n                        bracket_stack_size[iso_level] = stack_idx;\n\n                        pairing_nodes = pairing_nodes_push(pairing_nodes,\n                                                           bracket_stack[iso_level][stack_idx],\n                                                           pp);\n                        break;\n                    }\n                    stack_idx--;\n                  }\n              }\n          }\n        last_level = level;\n        last_iso_level = iso_level;\n      }\n\n    /* The list must now be sorted for the next algo to work! */\n    sort_pairing_nodes(&pairing_nodes);\n\n# if DEBUG\n    if UNLIKELY\n    (fribidi_debug_status ())\n      {\n        print_pairing_nodes (pairing_nodes);\n      }\n# endif\t/* DEBUG */\n\n    /* Start the N0 */\n    {\n      FriBidiPairingNode *ppairs = pairing_nodes;\n      while (ppairs)\n        {\n          int iso_level = ppairs->open->isolate_level;\n          int embedding_level = base_level_per_iso_level[iso_level];\n\n          /* Find matching strong. */\n          fribidi_boolean found = false;\n          FriBidiRun *ppn;\n          for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)\n            {\n              FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n\n              /* Calculate level like in resolve implicit levels below to prevent\n                 embedded levels not to match the base_level */\n              int this_level = RL_LEVEL (ppn) +\n                (FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n              /* N0b */\n              if (FRIBIDI_IS_STRONG (this_type) && this_level == embedding_level)\n                {\n                  RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = this_level%2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;\n                  found = true;\n                  break;\n                }\n            }\n\n          /* N0c */\n          /* Search for any strong type preceding and within the bracket pair */\n          if (!found)\n            {\n              /* Search for a preceding strong */\n              int prec_strong_level = embedding_level; /* TBDov! Extract from Isolate level in effect */\n              int iso_level = RL_ISOLATE_LEVEL(ppairs->open);\n              for (ppn = ppairs->open->prev; ppn->type != FRIBIDI_TYPE_SENTINEL; ppn=ppn->prev)\n                {\n                  FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n                  if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)\n                    {\n                      prec_strong_level = RL_LEVEL (ppn) +\n                        (FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n                      break;\n                    }\n                }\n\n              for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)\n                {\n                  FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n                  if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)\n                    {\n                      /* By constraint this is opposite the embedding direction,\n                         since we did not match the N0b rule. We must now\n                         compare with the preceding strong to establish whether\n                         to apply N0c1 (opposite) or N0c2 embedding */\n                      RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = prec_strong_level % 2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;\n                      RL_LEVEL(ppairs->open) = RL_LEVEL(ppairs->close) = prec_strong_level;\n                      found = true;\n                      break;\n                    }\n                }\n            }\n\n          ppairs = ppairs->next;\n        }\n\n      free_pairing_nodes(pairing_nodes);\n\n      if (num_iso_levels >= LOCAL_BRACKET_SIZE)\n        {\n          int i;\n          /* Only need to free the non static members */\n          for (i=LOCAL_BRACKET_SIZE; i<num_iso_levels; i++)\n            fribidi_free(bracket_stack[i]);\n        }\n\n      /* Remove the bracket property and re-compact */\n      {\n        const FriBidiBracketType NoBracket = FRIBIDI_NO_BRACKET;\n        for_run_list (pp, main_run_list)\n          pp->bracket_type = NoBracket;\n        compact_neutrals (main_run_list);\n      }\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n  }\n\n  DBG (\"resolving neutral types - N1+N2\");\n  {\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType prev_type, this_type, next_type;\n      FriBidiRun *ppp_prev, *ppp_next;\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      /* \"European and Arabic numbers are treated as though they were R\"\n         FRIBIDI_CHANGE_NUMBER_TO_RTL does this. */\n      this_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE (pp));\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_prev));\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_next));\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_NEUTRAL (this_type))\n\tRL_TYPE (pp) = (prev_type == next_type) ?\n\t  /* N1. */ prev_type :\n\t  /* N2. */ FRIBIDI_EMBEDDING_DIRECTION (pp);\n    }\n  }\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 6. Resolving implicit levels */\n  DBG (\"resolving implicit levels\");\n  {\n    max_level = base_level;\n\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType this_type;\n      int level;\n\n      this_type = RL_TYPE (pp);\n      level = RL_LEVEL (pp);\n\n      /* I1. Even */\n      /* I2. Odd */\n      if (FRIBIDI_IS_NUMBER (this_type))\n\tRL_LEVEL (pp) = (level + 2) & ~1;\n      else\n\tRL_LEVEL (pp) =\n\t  level +\n\t  (FRIBIDI_LEVEL_IS_RTL (level) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n      if (RL_LEVEL (pp) > max_level)\n\tmax_level = RL_LEVEL (pp);\n    }\n  }\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_bidi_string (bidi_types, len);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n/* Reinsert the explicit codes & BN's that are already removed, from the\n   explicits_list to main_run_list. */\n  DBG (\"reinserting explicit codes\");\n  if UNLIKELY\n    (explicits_list->next != explicits_list)\n    {\n      register FriBidiRun *p;\n      register fribidi_boolean stat =\n\tshadow_run_list (main_run_list, explicits_list, true);\n      explicits_list = NULL;\n      if UNLIKELY\n\t(!stat) goto out;\n\n      /* Set level of inserted explicit chars to that of their previous\n       * char, such that they do not affect reordering. */\n      p = main_run_list->next;\n      if (p != main_run_list && p->level == FRIBIDI_SENTINEL)\n\tp->level = base_level;\n      for_run_list (p, main_run_list) if (p->level == FRIBIDI_SENTINEL)\n\tp->level = p->prev->level;\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  DBG (\"reset the embedding levels, 1, 2, 3.\");\n  {\n    register int j, state, pos;\n    register FriBidiCharType char_type;\n    register FriBidiRun *p, *q, *list;\n\n    /* L1. Reset the embedding levels of some chars:\n       1. segment separators,\n       2. paragraph separators,\n       3. any sequence of whitespace characters preceding a segment\n          separator or paragraph separator, and\n       4. any sequence of whitespace characters and/or isolate formatting\n          characters at the end of the line.\n       ... (to be continued in fribidi_reorder_line()). */\n    list = new_run_list ();\n    if UNLIKELY\n      (!list) goto out;\n    q = list;\n    state = 1;\n    pos = len - 1;\n    for (j = len - 1; j >= -1; j--)\n      {\n\t/* close up the open link at the end */\n\tif (j >= 0)\n\t  char_type = bidi_types[j];\n\telse\n\t  char_type = FRIBIDI_TYPE_ON;\n\tif (!state && FRIBIDI_IS_SEPARATOR (char_type))\n\t  {\n\t    state = 1;\n\t    pos = j;\n\t  }\n\telse if (state &&\n                 !(FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS(char_type)\n                   || FRIBIDI_IS_ISOLATE(char_type)))\n\t  {\n\t    state = 0;\n\t    p = new_run ();\n\t    if UNLIKELY\n\t      (!p)\n\t      {\n\t\tfree_run_list (list);\n\t\tgoto out;\n\t      }\n\t    p->pos = j + 1;\n\t    p->len = pos - j;\n\t    p->type = base_dir;\n\t    p->level = base_level;\n\t    move_node_before (p, q);\n\t    q = p;\n\t  }\n      }\n    if UNLIKELY\n      (!shadow_run_list (main_run_list, list, false)) goto out;\n  }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  {\n    FriBidiStrIndex pos = 0;\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiStrIndex l;\n      register FriBidiLevel level = pp->level;\n      for (l = pp->len; l; l--)\n\tembedding_levels[pos++] = level;\n    }\n  }\n\n  status = true;\n\nout:\n  DBG (\"leaving fribidi_get_par_embedding_levels\");\n\n  if (main_run_list)\n    free_run_list (main_run_list);\n  if UNLIKELY\n    (explicits_list) free_run_list (explicits_list);\n\n  return status ? max_level + 1 : 0;\n}\n\n\nstatic void\nbidi_string_reverse (\n  FriBidiChar *str,\n  const FriBidiStrIndex len\n)\n{\n  FriBidiStrIndex i;\n\n  fribidi_assert (str);\n\n  for (i = 0; i < len / 2; i++)\n    {\n      FriBidiChar tmp = str[i];\n      str[i] = str[len - 1 - i];\n      str[len - 1 - i] = tmp;\n    }\n}\n\nstatic void\nindex_array_reverse (\n  FriBidiStrIndex *arr,\n  const FriBidiStrIndex len\n)\n{\n  FriBidiStrIndex i;\n\n  fribidi_assert (arr);\n\n  for (i = 0; i < len / 2; i++)\n    {\n      FriBidiStrIndex tmp = arr[i];\n      arr[i] = arr[len - 1 - i];\n      arr[len - 1 - i] = tmp;\n    }\n}\n\n\nFRIBIDI_ENTRY FriBidiLevel\nfribidi_reorder_line (\n  /* input */\n  FriBidiFlags flags, /* reorder flags */\n  const FriBidiCharType *bidi_types,\n  const FriBidiStrIndex len,\n  const FriBidiStrIndex off,\n  const FriBidiParType base_dir,\n  /* input and output */\n  FriBidiLevel *embedding_levels,\n  FriBidiChar *visual_str,\n  /* output */\n  FriBidiStrIndex *map\n)\n{\n  fribidi_boolean status = false;\n  FriBidiLevel max_level = 0;\n\n  if UNLIKELY\n    (len == 0)\n    {\n      status = true;\n      goto out;\n    }\n\n  DBG (\"in fribidi_reorder_line\");\n\n  fribidi_assert (bidi_types);\n  fribidi_assert (embedding_levels);\n\n  DBG (\"reset the embedding levels, 4. whitespace at the end of line\");\n  {\n    register FriBidiStrIndex i;\n\n    /* L1. Reset the embedding levels of some chars:\n       4. any sequence of white space characters at the end of the line. */\n    for (i = off + len - 1; i >= off &&\n\t FRIBIDI_IS_EXPLICIT_OR_BN_OR_WS (bidi_types[i]); i--)\n      embedding_levels[i] = FRIBIDI_DIR_TO_LEVEL (base_dir);\n  }\n\n  /* 7. Reordering resolved levels */\n  {\n    register FriBidiLevel level;\n    register FriBidiStrIndex i;\n\n    /* Reorder both the outstring and the order array */\n    {\n      if (FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_REORDER_NSM))\n\t{\n\t  /* L3. Reorder NSMs. */\n\t  for (i = off + len - 1; i >= off; i--)\n\t    if (FRIBIDI_LEVEL_IS_RTL (embedding_levels[i])\n\t\t&& bidi_types[i] == FRIBIDI_TYPE_NSM)\n\t      {\n\t\tregister FriBidiStrIndex seq_end = i;\n\t\tlevel = embedding_levels[i];\n\n\t\tfor (i--; i >= off &&\n\t\t     FRIBIDI_IS_EXPLICIT_OR_BN_OR_NSM (bidi_types[i])\n\t\t     && embedding_levels[i] == level; i--)\n\t\t  ;\n\n\t\tif (i < off || embedding_levels[i] != level)\n\t\t  {\n\t\t    i++;\n\t\t    DBG (\"warning: NSM(s) at the beginning of level run\");\n\t\t  }\n\n\t\tif (visual_str)\n\t\t  {\n\t\t    bidi_string_reverse (visual_str + i, seq_end - i + 1);\n\t\t  }\n\t\tif (map)\n\t\t  {\n\t\t    index_array_reverse (map + i, seq_end - i + 1);\n\t\t  }\n\t      }\n\t}\n\n      /* Find max_level of the line.  We don't reuse the paragraph\n       * max_level, both for a cleaner API, and that the line max_level\n       * may be far less than paragraph max_level. */\n      for (i = off + len - 1; i >= off; i--)\n\tif (embedding_levels[i] > max_level)\n\t  max_level = embedding_levels[i];\n\n      /* L2. Reorder. */\n      for (level = max_level; level > 0; level--)\n\tfor (i = off + len - 1; i >= off; i--)\n\t  if (embedding_levels[i] >= level)\n\t    {\n\t      /* Find all stretches that are >= level_idx */\n\t      register FriBidiStrIndex seq_end = i;\n\t      for (i--; i >= off && embedding_levels[i] >= level; i--)\n\t\t;\n\n\t      if (visual_str)\n\t\tbidi_string_reverse (visual_str + i + 1, seq_end - i);\n\t      if (map)\n\t\tindex_array_reverse (map + i + 1, seq_end - i);\n\t    }\n    }\n\n  }\n\n  status = true;\n\nout:\n\n  return status ? max_level + 1 : 0;\n}\n\n/* Editor directions:\n * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent\n */\n"], "fixing_code": ["/* FriBidi\n * fribidi-bidi.c - bidirectional algorithm\n *\n * Authors:\n *   Behdad Esfahbod, 2001, 2002, 2004\n *   Dov Grobgeld, 1999, 2000, 2017\n *\n * Copyright (C) 2004 Sharif FarsiWeb, Inc\n * Copyright (C) 2001,2002 Behdad Esfahbod\n * Copyright (C) 1999,2000,2017 Dov Grobgeld\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library, in a file named COPYING; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA\n *\n * For licensing issues, contact <fribidi.license@gmail.com>.\n */\n\n#include \"common.h\"\n\n#include <fribidi-bidi.h>\n#include <fribidi-mirroring.h>\n#include <fribidi-brackets.h>\n#include <fribidi-unicode.h>\n\n#include \"bidi-types.h\"\n#include \"run.h\"\n\n/*\n * This file implements most of Unicode Standard Annex #9, Tracking Number 13.\n */\n\n#ifndef MAX\n# define MAX(a,b) ((a) > (b) ? (a) : (b))\n#endif /* !MAX */\n\n/* Some convenience macros */\n#define RL_TYPE(list) ((list)->type)\n#define RL_LEN(list) ((list)->len)\n#define RL_LEVEL(list) ((list)->level)\n\n/* \"Within this scope, bidirectional types EN and AN are treated as R\" */\n#define RL_TYPE_AN_EN_AS_RTL(list) ( \\\n (((list)->type == FRIBIDI_TYPE_AN) || ((list)->type == FRIBIDI_TYPE_EN) | ((list)->type == FRIBIDI_TYPE_RTL)) ? FRIBIDI_TYPE_RTL : (list)->type)\n#define RL_BRACKET_TYPE(list) ((list)->bracket_type)\n#define RL_ISOLATE_LEVEL(list) ((list)->isolate_level)\n\n#define LOCAL_BRACKET_SIZE 16\n\n/* Pairing nodes are used for holding a pair of open/close brackets as\n   described in BD16. */\nstruct _FriBidiPairingNodeStruct {\n  FriBidiRun *open;\n  FriBidiRun *close;\n  struct _FriBidiPairingNodeStruct *next;\n};\ntypedef struct _FriBidiPairingNodeStruct FriBidiPairingNode;\n\nstatic FriBidiRun *\nmerge_with_prev (\n  FriBidiRun *second\n)\n{\n  FriBidiRun *first;\n\n  fribidi_assert (second);\n  fribidi_assert (second->next);\n  first = second->prev;\n  fribidi_assert (first);\n\n  first->next = second->next;\n  first->next->prev = first;\n  RL_LEN (first) += RL_LEN (second);\n  if (second->next_isolate)\n    second->next_isolate->prev_isolate = first;\n  first->next_isolate = second->next_isolate;\n\n  fribidi_free (second);\n  return first;\n}\n\nstatic void\ncompact_list (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    for_run_list (list, list)\n      if (RL_TYPE (list->prev) == RL_TYPE (list)\n\t  && RL_LEVEL (list->prev) == RL_LEVEL (list)\n          && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n          && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n          )\n      list = merge_with_prev (list);\n}\n\nstatic void\ncompact_neutrals (\n  FriBidiRun *list\n)\n{\n  fribidi_assert (list);\n\n  if (list->next)\n    {\n      for_run_list (list, list)\n      {\n\tif (RL_LEVEL (list->prev) == RL_LEVEL (list)\n\t    &&\n\t    ((RL_TYPE (list->prev) == RL_TYPE (list)\n\t      || (FRIBIDI_IS_NEUTRAL (RL_TYPE (list->prev))\n\t\t  && FRIBIDI_IS_NEUTRAL (RL_TYPE (list)))))\n            && RL_BRACKET_TYPE(list) == FRIBIDI_NO_BRACKET /* Don't join brackets! */\n            && RL_BRACKET_TYPE(list->prev) == FRIBIDI_NO_BRACKET\n            )\n\t  list = merge_with_prev (list);\n      }\n    }\n}\n\n/* Search for an adjacent run in the forward or backward direction.\n   It uses the next_isolate and prev_isolate run for short circuited searching.\n */\n\n/* The static sentinel is used to signal the end of an isolating\n   sequence */\nstatic FriBidiRun sentinel = { NULL, NULL, 0,0, FRIBIDI_TYPE_SENTINEL, -1,-1,FRIBIDI_NO_BRACKET, NULL, NULL };\n\nstatic FriBidiRun *get_adjacent_run(FriBidiRun *list, fribidi_boolean forward, fribidi_boolean skip_neutral)\n{\n  FriBidiRun *ppp = forward ? list->next_isolate : list->prev_isolate;\n  if (!ppp)\n    return &sentinel;\n\n  while (ppp)\n    {\n      FriBidiCharType ppp_type = RL_TYPE (ppp);\n\n      if (ppp_type == FRIBIDI_TYPE_SENTINEL)\n        break;\n\n      /* Note that when sweeping forward we continue one run\n         beyond the PDI to see what lies behind. When looking\n         backwards, this is not necessary as the leading isolate\n         run has already been assigned the resolved level. */\n      if (ppp->isolate_level > list->isolate_level   /* <- How can this be true? */\n          || (forward && ppp_type == FRIBIDI_TYPE_PDI)\n          || (skip_neutral && !FRIBIDI_IS_STRONG(ppp_type)))\n        {\n          ppp = forward ? ppp->next_isolate : ppp->prev_isolate;\n          if (!ppp)\n            ppp = &sentinel;\n\n          continue;\n        }\n      break;\n    }\n\n  return ppp;\n}\n\n#ifdef DEBUG\n/*======================================================================\n *  For debugging, define some functions for printing the types and the\n *  levels.\n *----------------------------------------------------------------------*/\n\nstatic char char_from_level_array[] = {\n  '$',\t\t\t\t/* -1 == FRIBIDI_SENTINEL, indicating\n\t\t\t\t * start or end of string. */\n  /* 0-61 == 0-9,a-z,A-Z are the the only valid levels before resolving\n   * implicits.  after that the level @ may be appear too. */\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n  'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n  'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',\n  'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n  'Y', 'Z',\n\n  /* TBD - insert another 125-64 levels */\n\n  '@',\t\t\t\t/* 62 == only must appear after resolving\n\t\t\t\t * implicits. */\n\n  '!',\t\t\t\t/* 63 == FRIBIDI_LEVEL_INVALID, internal error,\n\t\t\t\t * this level shouldn't be seen.  */\n\n  '*', '*', '*', '*', '*'\t/* >= 64 == overflows, this levels and higher\n\t\t\t\t * levels show a real bug!. */\n};\n\n#define fribidi_char_from_level(level) char_from_level_array[(level) + 1]\n\nstatic void\nprint_types_re (\n  const FriBidiRun *pp\n)\n{\n  fribidi_assert (pp);\n\n  MSG (\"  Run types  : \");\n  for_run_list (pp, pp)\n  {\n    MSG6 (\"%d:%d(%s)[%d,%d] \",\n\t  pp->pos, pp->len, fribidi_get_bidi_type_name (pp->type), pp->level, pp->isolate_level);\n  }\n  MSG (\"\\n\");\n}\n\nstatic void\nprint_resolved_levels (\n  const FriBidiRun *pp\n)\n{\n  fribidi_assert (pp);\n\n  MSG (\"  Res. levels: \");\n  for_run_list (pp, pp)\n  {\n    register FriBidiStrIndex i;\n    for (i = RL_LEN (pp); i; i--)\n      MSG2 (\"%c\", fribidi_char_from_level (RL_LEVEL (pp)));\n  }\n  MSG (\"\\n\");\n}\n\nstatic void\nprint_resolved_types (\n  const FriBidiRun *pp\n)\n{\n  fribidi_assert (pp);\n\n  MSG (\"  Res. types : \");\n  for_run_list (pp, pp)\n  {\n    FriBidiStrIndex i;\n    for (i = RL_LEN (pp); i; i--)\n      MSG2 (\"%s \", fribidi_get_bidi_type_name (pp->type));\n  }\n  MSG (\"\\n\");\n}\n\nstatic void\nprint_bidi_string (\n  /* input */\n  const FriBidiCharType *bidi_types,\n  const FriBidiStrIndex len\n)\n{\n  register FriBidiStrIndex i;\n\n  fribidi_assert (bidi_types);\n\n  MSG (\"  Org. types : \");\n  for (i = 0; i < len; i++)\n    MSG2 (\"%s \", fribidi_get_bidi_type_name (bidi_types[i]));\n  MSG (\"\\n\");\n}\n\nstatic void print_pairing_nodes(FriBidiPairingNode *nodes)\n{\n  MSG (\"Pairs: \");\n  while (nodes)\n    {\n      MSG3 (\"(%d, %d) \", nodes->open->pos, nodes->close->pos);\n      nodes = nodes->next;\n    }\n  MSG (\"\\n\");\n}\n#endif /* DEBUG */\n\n\n/*=========================================================================\n * define macros for push and pop the status in to / out of the stack\n *-------------------------------------------------------------------------*/\n\n/* There are a few little points in pushing into and popping from the status\n   stack:\n   1. when the embedding level is not valid (more than\n   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL=125), you must reject it, and not to push\n   into the stack, but when you see a PDF, you must find the matching code,\n   and if it was pushed in the stack, pop it, it means you must pop if and\n   only if you have pushed the matching code, the over_pushed var counts the\n   number of rejected codes so far.\n\n   2. there's a more confusing point too, when the embedding level is exactly\n   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL-1=124, an LRO, LRE, or LRI is rejected\n   because the new level would be FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL+1=126, that\n   is invalid; but an RLO, RLE, or RLI is accepted because the new level is\n   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL=125, that is valid, so the rejected codes\n   may be not continuous in the logical order, in fact there are at most two\n   continuous intervals of codes, with an RLO, RLE, or RLI between them.  To\n   support this case, the first_interval var counts the number of rejected\n   codes in the first interval, when it is 0, means that there is only one\n   interval.\n\n*/\n\n/* a. If this new level would be valid, then this embedding code is valid.\n   Remember (push) the current embedding level and override status.\n   Reset current level to this new level, and reset the override status to\n   new_override.\n   b. If the new level would not be valid, then this code is invalid. Don't\n   change the current level or override status.\n*/\n#define PUSH_STATUS \\\n    FRIBIDI_BEGIN_STMT \\\n      if LIKELY(over_pushed == 0 \\\n                && isolate_overflow == 0 \\\n                && new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL)   \\\n        { \\\n          if UNLIKELY(level == FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL - 1) \\\n            first_interval = over_pushed; \\\n          status_stack[stack_size].level = level; \\\n          status_stack[stack_size].isolate_level = isolate_level; \\\n          status_stack[stack_size].isolate = isolate; \\\n          status_stack[stack_size].override = override; \\\n          stack_size++; \\\n          level = new_level; \\\n          override = new_override; \\\n        } else if LIKELY(isolate_overflow == 0) \\\n\t  over_pushed++; \\\n    FRIBIDI_END_STMT\n\n/* If there was a valid matching code, restore (pop) the last remembered\n   (pushed) embedding level and directional override.\n*/\n#define POP_STATUS \\\n    FRIBIDI_BEGIN_STMT \\\n      if (stack_size) \\\n      { \\\n        if UNLIKELY(over_pushed > first_interval) \\\n          over_pushed--; \\\n        else \\\n          { \\\n            if LIKELY(over_pushed == first_interval) \\\n              first_interval = 0; \\\n            stack_size--; \\\n            level = status_stack[stack_size].level; \\\n            override = status_stack[stack_size].override; \\\n            isolate = status_stack[stack_size].isolate; \\\n            isolate_level = status_stack[stack_size].isolate_level; \\\n          } \\\n      } \\\n    FRIBIDI_END_STMT\n\n\n/* Return the type of previous run or the SOR, if already at the start of\n   a level run. */\n#define PREV_TYPE_OR_SOR(pp) \\\n    ( \\\n      RL_LEVEL(pp->prev) == RL_LEVEL(pp) ? \\\n        RL_TYPE(pp->prev) : \\\n        FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(pp->prev), RL_LEVEL(pp))) \\\n    )\n\n/* Return the type of next run or the EOR, if already at the end of\n   a level run. */\n#define NEXT_TYPE_OR_EOR(pp) \\\n    ( \\\n      RL_LEVEL(pp->next) == RL_LEVEL(pp) ? \\\n        RL_TYPE(pp->next) : \\\n        FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(pp->next), RL_LEVEL(pp))) \\\n    )\n\n\n/* Return the embedding direction of a link. */\n#define FRIBIDI_EMBEDDING_DIRECTION(link) \\\n    FRIBIDI_LEVEL_TO_DIR(RL_LEVEL(link))\n\n\nFRIBIDI_ENTRY FriBidiParType\nfribidi_get_par_direction (\n  /* input */\n  const FriBidiCharType *bidi_types,\n  const FriBidiStrIndex len\n)\n{\n  register FriBidiStrIndex i;\n\n  fribidi_assert (bidi_types);\n\n  for (i = 0; i < len; i++)\n    if (FRIBIDI_IS_LETTER (bidi_types[i]))\n      return FRIBIDI_IS_RTL (bidi_types[i]) ? FRIBIDI_PAR_RTL :\n\tFRIBIDI_PAR_LTR;\n\n  return FRIBIDI_PAR_ON;\n}\n\n/* Push a new entry to the pairing linked list */\nstatic FriBidiPairingNode * pairing_nodes_push(FriBidiPairingNode *nodes,\n                                               FriBidiRun *open,\n                                               FriBidiRun *close)\n{\n  FriBidiPairingNode *node = fribidi_malloc(sizeof(FriBidiPairingNode));\n  node->open = open;\n  node->close = close;\n  node->next = nodes;\n  nodes = node;\n  return nodes;\n}\n\n/* Sort by merge sort */\nstatic void pairing_nodes_front_back_split(FriBidiPairingNode *source,\n                                           /* output */\n                                           FriBidiPairingNode **front,\n                                           FriBidiPairingNode **back)\n{\n  FriBidiPairingNode *pfast, *pslow;\n  if (!source || !source->next)\n    {\n      *front = source;\n      *back = NULL;\n    }\n  else\n    {\n      pslow = source;\n      pfast = source->next;\n      while (pfast)\n        {\n          pfast= pfast->next;\n          if (pfast)\n            {\n              pfast = pfast->next;\n              pslow = pslow->next;\n            }\n        }\n      *front = source;\n      *back = pslow->next;\n      pslow->next = NULL;\n    }\n}\n\nstatic FriBidiPairingNode *\npairing_nodes_sorted_merge(FriBidiPairingNode *nodes1,\n                           FriBidiPairingNode *nodes2)\n{\n  FriBidiPairingNode *res = NULL;\n  if (!nodes1)\n    return nodes2;\n  if (!nodes2)\n    return nodes1;\n\n  if (nodes1->open->pos < nodes2->open->pos)\n    {\n      res = nodes1;\n      res->next = pairing_nodes_sorted_merge(nodes1->next, nodes2);\n    }\n  else\n    {\n      res = nodes2;\n      res->next = pairing_nodes_sorted_merge(nodes1, nodes2->next);\n    }\n  return res;\n}\n\nstatic void sort_pairing_nodes(FriBidiPairingNode **nodes)\n{\n  FriBidiPairingNode *front, *back;\n\n  /* 0 or 1 node case */\n  if (!*nodes || !(*nodes)->next)\n    return;\n\n  pairing_nodes_front_back_split(*nodes, &front, &back);\n  sort_pairing_nodes(&front);\n  sort_pairing_nodes(&back);\n  *nodes = pairing_nodes_sorted_merge(front, back);\n}\n\nstatic void free_pairing_nodes(FriBidiPairingNode *nodes)\n{\n  while (nodes)\n    {\n      FriBidiPairingNode *p = nodes;\n      nodes = nodes->next;\n      fribidi_free(p);\n    }\n}\n\nFRIBIDI_ENTRY FriBidiLevel\nfribidi_get_par_embedding_levels_ex (\n  /* input */\n  const FriBidiCharType *bidi_types,\n  const FriBidiBracketType *bracket_types,\n  const FriBidiStrIndex len,\n  /* input and output */\n  FriBidiParType *pbase_dir,\n  /* output */\n  FriBidiLevel *embedding_levels\n)\n{\n  FriBidiLevel base_level_per_iso_level[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n  FriBidiLevel base_level, max_level = 0;\n  FriBidiParType base_dir;\n  FriBidiRun *main_run_list = NULL, *explicits_list = NULL, *pp;\n  fribidi_boolean status = false;\n  int max_iso_level = 0;\n\n  if UNLIKELY\n    (!len)\n    {\n      status = true;\n      goto out;\n    }\n\n  DBG (\"in fribidi_get_par_embedding_levels\");\n\n  fribidi_assert (bidi_types);\n  fribidi_assert (pbase_dir);\n  fribidi_assert (embedding_levels);\n\n  /* Determinate character types */\n  {\n    /* Get run-length encoded character types */\n    main_run_list = run_list_encode_bidi_types (bidi_types, bracket_types, len);\n    if UNLIKELY\n      (!main_run_list) goto out;\n  }\n\n  /* Find base level */\n  /* If no strong base_dir was found, resort to the weak direction\n     that was passed on input. */\n  base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);\n  if (!FRIBIDI_IS_STRONG (*pbase_dir))\n    /* P2. P3. Search for first strong character and use its direction as\n       base direction */\n    {\n      int valid_isolate_count = 0;\n      for_run_list (pp, main_run_list)\n        {\n          if (RL_TYPE(pp) == FRIBIDI_TYPE_PDI)\n            {\n              /* Ignore if there is no matching isolate */\n              if (valid_isolate_count>0)\n                valid_isolate_count--;\n            }\n          else if (FRIBIDI_IS_ISOLATE(RL_TYPE(pp)))\n            valid_isolate_count++;\n          else if (valid_isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (pp)))\n            {\n              base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (pp));\n              *pbase_dir = FRIBIDI_LEVEL_TO_DIR (base_level);\n              break;\n            }\n        }\n    }\n  base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);\n  DBG2 (\"  base level : %c\", fribidi_char_from_level (base_level));\n  DBG2 (\"  base dir   : %s\", fribidi_get_bidi_type_name (base_dir));\n\n  base_level_per_iso_level[0] = base_level;\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* Explicit Levels and Directions */\n  DBG (\"explicit levels and directions\");\n  {\n    FriBidiLevel level, new_level = 0;\n    int isolate_level = 0;\n    FriBidiCharType override, new_override;\n    FriBidiStrIndex i;\n    int stack_size, over_pushed, first_interval;\n    int valid_isolate_count = 0;\n    int isolate_overflow = 0;\n    int isolate = 0; /* The isolate status flag */\n    struct\n    {\n      FriBidiCharType override;\t/* only LTR, RTL and ON are valid */\n      FriBidiLevel level;\n      int isolate;\n      int isolate_level;\n    } status_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    FriBidiRun temp_link;\n    FriBidiRun *run_per_isolate_level[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n\n    memset(run_per_isolate_level, 0, sizeof(run_per_isolate_level[0])\n           * FRIBIDI_BIDI_MAX_RESOLVED_LEVELS);\n\n/* explicits_list is a list like main_run_list, that holds the explicit\n   codes that are removed from main_run_list, to reinsert them later by\n   calling the shadow_run_list.\n*/\n    explicits_list = new_run_list ();\n    if UNLIKELY\n      (!explicits_list) goto out;\n\n    /* X1. Begin by setting the current embedding level to the paragraph\n       embedding level. Set the directional override status to neutral,\n       and directional isolate status to false.\n\n       Process each character iteratively, applying rules X2 through X8.\n       Only embedding levels from 0 to 123 are valid in this phase. */\n\n    level = base_level;\n    override = FRIBIDI_TYPE_ON;\n    /* stack */\n    stack_size = 0;\n    over_pushed = 0;\n    first_interval = 0;\n    valid_isolate_count = 0;\n    isolate_overflow = 0;\n\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType this_type = RL_TYPE (pp);\n      RL_ISOLATE_LEVEL (pp) = isolate_level;\n\n      if (FRIBIDI_IS_EXPLICIT_OR_BN (this_type))\n\t{\n\t  if (FRIBIDI_IS_STRONG (this_type))\n\t    {\t\t\t/* LRE, RLE, LRO, RLO */\n\t      /* 1. Explicit Embeddings */\n\t      /*   X2. With each RLE, compute the least greater odd\n\t         embedding level. */\n\t      /*   X3. With each LRE, compute the least greater even\n\t         embedding level. */\n\t      /* 2. Explicit Overrides */\n\t      /*   X4. With each RLO, compute the least greater odd\n\t         embedding level. */\n\t      /*   X5. With each LRO, compute the least greater even\n\t         embedding level. */\n\t      new_override = FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR (this_type);\n\t      for (i = RL_LEN (pp); i; i--)\n\t\t{\n\t\t  new_level =\n\t\t    ((level + FRIBIDI_DIR_TO_LEVEL (this_type) + 2) & ~1) -\n\t\t    FRIBIDI_DIR_TO_LEVEL (this_type);\n                  isolate = 0;\n\t\t  PUSH_STATUS;\n\t\t}\n\t    }\n\t  else if (this_type == FRIBIDI_TYPE_PDF)\n\t    {\n\t      /* 3. Terminating Embeddings and overrides */\n\t      /*   X7. With each PDF, determine the matching embedding or\n\t         override code. */\n              for (i = RL_LEN (pp); i; i--)\n                {\n                  if (stack_size && status_stack[stack_size-1].isolate != 0)\n                    break;\n                  POP_STATUS;\n                }\n\t    }\n\n\t  /* X9. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes. */\n\t  /* Remove element and add it to explicits_list */\n\t  RL_LEVEL (pp) = FRIBIDI_SENTINEL;\n\t  temp_link.next = pp->next;\n\t  move_node_before (pp, explicits_list);\n\t  pp = &temp_link;\n\t}\n      else if (this_type == FRIBIDI_TYPE_PDI)\n        /* X6a. pop the direction of the stack */\n        {\n          for (i = RL_LEN (pp); i; i--)\n            {\n              if (isolate_overflow > 0)\n                {\n                  isolate_overflow--;\n                  RL_LEVEL (pp) = level;\n                }\n\n              else if (valid_isolate_count > 0)\n                {\n                  /* Pop away all LRE,RLE,LRO, RLO levels\n                     from the stack, as these are implicitly\n                     terminated by the PDI */\n                  while (stack_size && !status_stack[stack_size-1].isolate)\n                    POP_STATUS;\n                  over_pushed = 0; /* The PDI resets the overpushed! */\n                  POP_STATUS;\n                  isolate_level-- ;\n                  valid_isolate_count--;\n                  RL_LEVEL (pp) = level;\n                  RL_ISOLATE_LEVEL (pp) = isolate_level;\n                }\n              else\n                {\n                  /* Ignore isolated PDI's by turning them into ON's */\n                  RL_TYPE (pp) = FRIBIDI_TYPE_ON;\n                  RL_LEVEL (pp) = level;\n                }\n            }\n        }\n      else if (FRIBIDI_IS_ISOLATE(this_type))\n        {\n          /* TBD support RL_LEN > 1 */\n          new_override = FRIBIDI_TYPE_ON;\n          isolate = 1;\n          if (this_type == FRIBIDI_TYPE_LRI)\n            new_level = level + 2 - (level%2);\n          else if (this_type == FRIBIDI_TYPE_RLI)\n            new_level = level + 1 + (level%2);\n          else if (this_type == FRIBIDI_TYPE_FSI)\n            {\n              /* Search for a local strong character until we\n                 meet the corresponding PDI or the end of the\n                 paragraph */\n              FriBidiRun *fsi_pp;\n              int isolate_count = 0;\n              int fsi_base_level = 0;\n              for_run_list (fsi_pp, pp)\n                {\n                  if (RL_TYPE(fsi_pp) == FRIBIDI_TYPE_PDI)\n                    {\n                      isolate_count--;\n                      if (valid_isolate_count < 0)\n                        break;\n                    }\n                  else if (FRIBIDI_IS_ISOLATE(RL_TYPE(fsi_pp)))\n                    isolate_count++;\n                  else if (isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (fsi_pp)))\n                    {\n                      fsi_base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (fsi_pp));\n                      break;\n                    }\n                }\n\n              /* Same behavior like RLI and LRI above */\n              if (FRIBIDI_LEVEL_IS_RTL (fsi_base_level))\n                new_level = level + 1 + (level%2);\n              else\n                new_level = level + 2 - (level%2);\n            }\n\n\t  RL_LEVEL (pp) = level;\n          RL_ISOLATE_LEVEL (pp) = isolate_level;\n          if (isolate_level < FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL-1)\n              isolate_level++;\n          base_level_per_iso_level[isolate_level] = new_level;\n\n\t  if (!FRIBIDI_IS_NEUTRAL (override))\n\t    RL_TYPE (pp) = override;\n\n          if (new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL)\n            {\n              valid_isolate_count++;\n              PUSH_STATUS;\n              level = new_level;\n            }\n          else\n            isolate_overflow += 1;\n        }\n      else if (this_type == FRIBIDI_TYPE_BS)\n\t{\n\t  /* X8. All explicit directional embeddings and overrides are\n\t     completely terminated at the end of each paragraph. Paragraph\n\t     separators are not included in the embedding. */\n\t  break;\n\t}\n      else\n\t{\n\t  /* X6. For all types besides RLE, LRE, RLO, LRO, and PDF:\n\t     a. Set the level of the current character to the current\n\t     embedding level.\n\t     b. Whenever the directional override status is not neutral,\n\t     reset the current character type to the directional override\n\t     status. */\n\t  RL_LEVEL (pp) = level;\n\t  if (!FRIBIDI_IS_NEUTRAL (override))\n\t    RL_TYPE (pp) = override;\n\t}\n    }\n\n    /* Build the isolate_level connections */\n    for_run_list (pp, main_run_list)\n    {\n      int isolate_level = RL_ISOLATE_LEVEL (pp);\n      if (run_per_isolate_level[isolate_level])\n        {\n          run_per_isolate_level[isolate_level]->next_isolate = pp;\n          pp->prev_isolate = run_per_isolate_level[isolate_level];\n        }\n      run_per_isolate_level[isolate_level] = pp;\n    }\n\n    /* Implementing X8. It has no effect on a single paragraph! */\n    level = base_level;\n    override = FRIBIDI_TYPE_ON;\n    stack_size = 0;\n    over_pushed = 0;\n  }\n  /* X10. The remaining rules are applied to each run of characters at the\n     same level. For each run, determine the start-of-level-run (sor) and\n     end-of-level-run (eor) type, either L or R. This depends on the\n     higher of the two levels on either side of the boundary (at the start\n     or end of the paragraph, the level of the 'other' run is the base\n     embedding level). If the higher level is odd, the type is R, otherwise\n     it is L. */\n  /* Resolving Implicit Levels can be done out of X10 loop, so only change\n     of Resolving Weak Types and Resolving Neutral Types is needed. */\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_bidi_string (bidi_types, len);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 4. Resolving weak types. Also calculate the maximum isolate level */\n  max_iso_level = 0;\n  DBG (\"resolving weak types\");\n  {\n    int last_strong_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];\n    FriBidiCharType prev_type_orig;\n    fribidi_boolean w4;\n\n    last_strong_stack[0] = base_dir;\n\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiCharType prev_type, this_type, next_type;\n      FriBidiRun *ppp_prev, *ppp_next;\n      int iso_level;\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      this_type = RL_TYPE (pp);\n      iso_level = RL_ISOLATE_LEVEL(pp);\n\n      if (iso_level > max_iso_level)\n        max_iso_level = iso_level;\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = RL_TYPE(ppp_prev);\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = RL_TYPE(ppp_next);\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_STRONG (prev_type))\n\tlast_strong_stack[iso_level] = prev_type;\n\n      /* W1. NSM\n         Examine each non-spacing mark (NSM) in the level run, and change the\n         type of the NSM to the type of the previous character. If the NSM\n         is at the start of the level run, it will get the type of sor. */\n      /* Implementation note: it is important that if the previous character\n         is not sor, then we should merge this run with the previous,\n         because of rules like W5, that we assume all of a sequence of\n         adjacent ETs are in one FriBidiRun. */\n      if (this_type == FRIBIDI_TYPE_NSM)\n\t{\n          /* New rule in Unicode 6.3 */\n          if (FRIBIDI_IS_ISOLATE (RL_TYPE (pp->prev)))\n              RL_TYPE(pp) = FRIBIDI_TYPE_ON;\n\n\t  if (RL_LEVEL (ppp_prev) == RL_LEVEL (pp))\n            {\n              if (ppp_prev == pp->prev)\n                pp = merge_with_prev (pp);\n            }\n\t  else\n\t    RL_TYPE (pp) = prev_type;\n\n\t  if (prev_type == next_type && RL_LEVEL (pp) == RL_LEVEL (pp->next))\n\t    {\n              if (ppp_next == pp->next)\n                pp = merge_with_prev (pp->next);\n\t    }\n\t  continue;\t\t/* As we know the next condition cannot be true. */\n\t}\n\n      /* W2: European numbers. */\n      if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_AL)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_AN;\n\n\t  /* Resolving dependency of loops for rules W1 and W2, so we\n\t     can merge them in one loop. */\n\t  if (next_type == FRIBIDI_TYPE_NSM)\n\t    RL_TYPE (ppp_next) = FRIBIDI_TYPE_AN;\n\t}\n    }\n\n\n    last_strong_stack[0] = base_dir;\n\n    /* Resolving dependency of loops for rules W4 and W5, W5 may\n       want to prevent W4 to take effect in the next turn, do this\n       through \"w4\". */\n    w4 = true;\n    /* Resolving dependency of loops for rules W4 and W5 with W7,\n       W7 may change an EN to L but it sets the prev_type_orig if needed,\n       so W4 and W5 in next turn can still do their works. */\n    prev_type_orig = FRIBIDI_TYPE_ON;\n\n    /* Each isolate level has its own memory of the last strong character */\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiCharType prev_type, this_type, next_type;\n      int iso_level;\n      FriBidiRun *ppp_prev, *ppp_next;\n\n      this_type = RL_TYPE (pp);\n      iso_level = RL_ISOLATE_LEVEL(pp);\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = RL_TYPE(ppp_prev);\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = RL_TYPE(ppp_next);\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_STRONG (prev_type))\n\tlast_strong_stack[iso_level] = prev_type;\n\n      /* W2 ??? */\n\n      /* W3: Change ALs to R. */\n      if (this_type == FRIBIDI_TYPE_AL)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_RTL;\n\t  w4 = true;\n\t  prev_type_orig = FRIBIDI_TYPE_ON;\n\t  continue;\n\t}\n\n      /* W4. A single european separator changes to a european number.\n         A single common separator between two numbers of the same type\n         changes to that type. */\n      if (w4\n\t  && RL_LEN (pp) == 1 && FRIBIDI_IS_ES_OR_CS (this_type)\n\t  && FRIBIDI_IS_NUMBER (prev_type_orig)\n\t  && prev_type_orig == next_type\n\t  && (prev_type_orig == FRIBIDI_TYPE_EN\n\t      || this_type == FRIBIDI_TYPE_CS))\n\t{\n\t  RL_TYPE (pp) = prev_type;\n\t  this_type = RL_TYPE (pp);\n\t}\n      w4 = true;\n\n      /* W5. A sequence of European terminators adjacent to European\n         numbers changes to All European numbers. */\n      if (this_type == FRIBIDI_TYPE_ET\n\t  && (prev_type_orig == FRIBIDI_TYPE_EN\n\t      || next_type == FRIBIDI_TYPE_EN))\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_EN;\n\t  w4 = false;\n\t  this_type = RL_TYPE (pp);\n\t}\n\n      /* W6. Otherwise change separators and terminators to other neutral. */\n      if (FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR (this_type))\n\tRL_TYPE (pp) = FRIBIDI_TYPE_ON;\n\n      /* W7. Change european numbers to L. */\n      if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_LTR)\n\t{\n\t  RL_TYPE (pp) = FRIBIDI_TYPE_LTR;\n\t  prev_type_orig = (RL_LEVEL (pp) == RL_LEVEL (pp->next) ?\n\t\t\t    FRIBIDI_TYPE_EN : FRIBIDI_TYPE_ON);\n\t}\n      else\n\tprev_type_orig = PREV_TYPE_OR_SOR (pp->next);\n    }\n  }\n\n  compact_neutrals (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 5. Resolving Neutral Types */\n\n  DBG (\"resolving neutral types - N0\");\n  {\n    /*  BD16 - Build list of all pairs*/\n    int num_iso_levels = max_iso_level + 1;\n    FriBidiPairingNode *pairing_nodes = NULL;\n    FriBidiRun *local_bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL][LOCAL_BRACKET_SIZE];\n    FriBidiRun **bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n    int bracket_stack_size[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];\n    int last_level = RL_LEVEL(main_run_list);\n    int last_iso_level = 0;\n\n    memset(bracket_stack, 0, sizeof(bracket_stack[0])*num_iso_levels);\n    memset(bracket_stack_size, 0, sizeof(bracket_stack_size[0])*num_iso_levels);\n\n    /* populate the bracket_size. The first LOCAL_BRACKET_SIZE entries\n       of the stack are one the stack. Allocate the rest of the entries.\n     */\n    {\n      int iso_level;\n      for (iso_level=0; iso_level < LOCAL_BRACKET_SIZE; iso_level++)\n        bracket_stack[iso_level] = local_bracket_stack[iso_level];\n\n      for (iso_level=LOCAL_BRACKET_SIZE; iso_level < num_iso_levels; iso_level++)\n        bracket_stack[iso_level] = fribidi_malloc (sizeof (bracket_stack[0])\n                                                       * FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS);\n    }\n\n    /* Build the bd16 pair stack. */\n    for_run_list (pp, main_run_list)\n      {\n        int level = RL_LEVEL(pp);\n        int iso_level = RL_ISOLATE_LEVEL(pp);\n        FriBidiBracketType brack_prop = RL_BRACKET_TYPE(pp);\n\n        /* Interpret the isolating run sequence as such that they\n           end at a change in the level, unless the iso_level has been\n           raised. */\n        if (level != last_level && last_iso_level == iso_level)\n          bracket_stack_size[last_iso_level] = 0;\n\n        if (brack_prop!= FRIBIDI_NO_BRACKET\n            && RL_TYPE(pp)==FRIBIDI_TYPE_ON)\n          {\n            if (FRIBIDI_IS_BRACKET_OPEN(brack_prop))\n              {\n                if (bracket_stack_size[iso_level]==FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS)\n                  break;\n\n                /* push onto the pair stack */\n                bracket_stack[iso_level][bracket_stack_size[iso_level]++] = pp;\n              }\n            else\n              {\n                int stack_idx = bracket_stack_size[iso_level] - 1;\n                while (stack_idx >= 0)\n                  {\n                    FriBidiBracketType se_brack_prop = RL_BRACKET_TYPE(bracket_stack[iso_level][stack_idx]);\n                    if (FRIBIDI_BRACKET_ID(se_brack_prop) == FRIBIDI_BRACKET_ID(brack_prop))\n                      {\n                        bracket_stack_size[iso_level] = stack_idx;\n\n                        pairing_nodes = pairing_nodes_push(pairing_nodes,\n                                                           bracket_stack[iso_level][stack_idx],\n                                                           pp);\n                        break;\n                    }\n                    stack_idx--;\n                  }\n              }\n          }\n        last_level = level;\n        last_iso_level = iso_level;\n      }\n\n    /* The list must now be sorted for the next algo to work! */\n    sort_pairing_nodes(&pairing_nodes);\n\n# if DEBUG\n    if UNLIKELY\n    (fribidi_debug_status ())\n      {\n        print_pairing_nodes (pairing_nodes);\n      }\n# endif\t/* DEBUG */\n\n    /* Start the N0 */\n    {\n      FriBidiPairingNode *ppairs = pairing_nodes;\n      while (ppairs)\n        {\n          int iso_level = ppairs->open->isolate_level;\n          int embedding_level = base_level_per_iso_level[iso_level];\n\n          /* Find matching strong. */\n          fribidi_boolean found = false;\n          FriBidiRun *ppn;\n          for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)\n            {\n              FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n\n              /* Calculate level like in resolve implicit levels below to prevent\n                 embedded levels not to match the base_level */\n              int this_level = RL_LEVEL (ppn) +\n                (FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n              /* N0b */\n              if (FRIBIDI_IS_STRONG (this_type) && this_level == embedding_level)\n                {\n                  RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = this_level%2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;\n                  found = true;\n                  break;\n                }\n            }\n\n          /* N0c */\n          /* Search for any strong type preceding and within the bracket pair */\n          if (!found)\n            {\n              /* Search for a preceding strong */\n              int prec_strong_level = embedding_level; /* TBDov! Extract from Isolate level in effect */\n              int iso_level = RL_ISOLATE_LEVEL(ppairs->open);\n              for (ppn = ppairs->open->prev; ppn->type != FRIBIDI_TYPE_SENTINEL; ppn=ppn->prev)\n                {\n                  FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n                  if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)\n                    {\n                      prec_strong_level = RL_LEVEL (ppn) +\n                        (FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n                      break;\n                    }\n                }\n\n              for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)\n                {\n                  FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);\n                  if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)\n                    {\n                      /* By constraint this is opposite the embedding direction,\n                         since we did not match the N0b rule. We must now\n                         compare with the preceding strong to establish whether\n                         to apply N0c1 (opposite) or N0c2 embedding */\n                      RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = prec_strong_level % 2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;\n                      RL_LEVEL(ppairs->open) = RL_LEVEL(ppairs->close) = prec_strong_level;\n                      found = true;\n                      break;\n                    }\n                }\n            }\n\n          ppairs = ppairs->next;\n        }\n\n      free_pairing_nodes(pairing_nodes);\n\n      if (num_iso_levels >= LOCAL_BRACKET_SIZE)\n        {\n          int i;\n          /* Only need to free the non static members */\n          for (i=LOCAL_BRACKET_SIZE; i<num_iso_levels; i++)\n            fribidi_free(bracket_stack[i]);\n        }\n\n      /* Remove the bracket property and re-compact */\n      {\n        const FriBidiBracketType NoBracket = FRIBIDI_NO_BRACKET;\n        for_run_list (pp, main_run_list)\n          pp->bracket_type = NoBracket;\n        compact_neutrals (main_run_list);\n      }\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n  }\n\n  DBG (\"resolving neutral types - N1+N2\");\n  {\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType prev_type, this_type, next_type;\n      FriBidiRun *ppp_prev, *ppp_next;\n\n      ppp_prev = get_adjacent_run(pp, false, false);\n      ppp_next = get_adjacent_run(pp, true, false);\n\n      /* \"European and Arabic numbers are treated as though they were R\"\n         FRIBIDI_CHANGE_NUMBER_TO_RTL does this. */\n      this_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE (pp));\n\n      if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))\n        prev_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_prev));\n      else\n        prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));\n\n      if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))\n        next_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_next));\n      else\n        next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));\n\n      if (FRIBIDI_IS_NEUTRAL (this_type))\n\tRL_TYPE (pp) = (prev_type == next_type) ?\n\t  /* N1. */ prev_type :\n\t  /* N2. */ FRIBIDI_EMBEDDING_DIRECTION (pp);\n    }\n  }\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  /* 6. Resolving implicit levels */\n  DBG (\"resolving implicit levels\");\n  {\n    max_level = base_level;\n\n    for_run_list (pp, main_run_list)\n    {\n      FriBidiCharType this_type;\n      int level;\n\n      this_type = RL_TYPE (pp);\n      level = RL_LEVEL (pp);\n\n      /* I1. Even */\n      /* I2. Odd */\n      if (FRIBIDI_IS_NUMBER (this_type))\n\tRL_LEVEL (pp) = (level + 2) & ~1;\n      else\n\tRL_LEVEL (pp) =\n\t  level +\n\t  (FRIBIDI_LEVEL_IS_RTL (level) ^ FRIBIDI_DIR_TO_LEVEL (this_type));\n\n      if (RL_LEVEL (pp) > max_level)\n\tmax_level = RL_LEVEL (pp);\n    }\n  }\n\n  compact_list (main_run_list);\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_bidi_string (bidi_types, len);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n/* Reinsert the explicit codes & BN's that are already removed, from the\n   explicits_list to main_run_list. */\n  DBG (\"reinserting explicit codes\");\n  if UNLIKELY\n    (explicits_list->next != explicits_list)\n    {\n      register FriBidiRun *p;\n      register fribidi_boolean stat =\n\tshadow_run_list (main_run_list, explicits_list, true);\n      explicits_list = NULL;\n      if UNLIKELY\n\t(!stat) goto out;\n\n      /* Set level of inserted explicit chars to that of their previous\n       * char, such that they do not affect reordering. */\n      p = main_run_list->next;\n      if (p != main_run_list && p->level == FRIBIDI_SENTINEL)\n\tp->level = base_level;\n      for_run_list (p, main_run_list) if (p->level == FRIBIDI_SENTINEL)\n\tp->level = p->prev->level;\n    }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  DBG (\"reset the embedding levels, 1, 2, 3.\");\n  {\n    register int j, state, pos;\n    register FriBidiCharType char_type;\n    register FriBidiRun *p, *q, *list;\n\n    /* L1. Reset the embedding levels of some chars:\n       1. segment separators,\n       2. paragraph separators,\n       3. any sequence of whitespace characters preceding a segment\n          separator or paragraph separator, and\n       4. any sequence of whitespace characters and/or isolate formatting\n          characters at the end of the line.\n       ... (to be continued in fribidi_reorder_line()). */\n    list = new_run_list ();\n    if UNLIKELY\n      (!list) goto out;\n    q = list;\n    state = 1;\n    pos = len - 1;\n    for (j = len - 1; j >= -1; j--)\n      {\n\t/* close up the open link at the end */\n\tif (j >= 0)\n\t  char_type = bidi_types[j];\n\telse\n\t  char_type = FRIBIDI_TYPE_ON;\n\tif (!state && FRIBIDI_IS_SEPARATOR (char_type))\n\t  {\n\t    state = 1;\n\t    pos = j;\n\t  }\n\telse if (state &&\n                 !(FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS(char_type)\n                   || FRIBIDI_IS_ISOLATE(char_type)))\n\t  {\n\t    state = 0;\n\t    p = new_run ();\n\t    if UNLIKELY\n\t      (!p)\n\t      {\n\t\tfree_run_list (list);\n\t\tgoto out;\n\t      }\n\t    p->pos = j + 1;\n\t    p->len = pos - j;\n\t    p->type = base_dir;\n\t    p->level = base_level;\n\t    move_node_before (p, q);\n\t    q = p;\n\t  }\n      }\n    if UNLIKELY\n      (!shadow_run_list (main_run_list, list, false)) goto out;\n  }\n\n# if DEBUG\n  if UNLIKELY\n    (fribidi_debug_status ())\n    {\n      print_types_re (main_run_list);\n      print_resolved_levels (main_run_list);\n      print_resolved_types (main_run_list);\n    }\n# endif\t/* DEBUG */\n\n  {\n    FriBidiStrIndex pos = 0;\n    for_run_list (pp, main_run_list)\n    {\n      register FriBidiStrIndex l;\n      register FriBidiLevel level = pp->level;\n      for (l = pp->len; l; l--)\n\tembedding_levels[pos++] = level;\n    }\n  }\n\n  status = true;\n\nout:\n  DBG (\"leaving fribidi_get_par_embedding_levels\");\n\n  if (main_run_list)\n    free_run_list (main_run_list);\n  if UNLIKELY\n    (explicits_list) free_run_list (explicits_list);\n\n  return status ? max_level + 1 : 0;\n}\n\n\nstatic void\nbidi_string_reverse (\n  FriBidiChar *str,\n  const FriBidiStrIndex len\n)\n{\n  FriBidiStrIndex i;\n\n  fribidi_assert (str);\n\n  for (i = 0; i < len / 2; i++)\n    {\n      FriBidiChar tmp = str[i];\n      str[i] = str[len - 1 - i];\n      str[len - 1 - i] = tmp;\n    }\n}\n\nstatic void\nindex_array_reverse (\n  FriBidiStrIndex *arr,\n  const FriBidiStrIndex len\n)\n{\n  FriBidiStrIndex i;\n\n  fribidi_assert (arr);\n\n  for (i = 0; i < len / 2; i++)\n    {\n      FriBidiStrIndex tmp = arr[i];\n      arr[i] = arr[len - 1 - i];\n      arr[len - 1 - i] = tmp;\n    }\n}\n\n\nFRIBIDI_ENTRY FriBidiLevel\nfribidi_reorder_line (\n  /* input */\n  FriBidiFlags flags, /* reorder flags */\n  const FriBidiCharType *bidi_types,\n  const FriBidiStrIndex len,\n  const FriBidiStrIndex off,\n  const FriBidiParType base_dir,\n  /* input and output */\n  FriBidiLevel *embedding_levels,\n  FriBidiChar *visual_str,\n  /* output */\n  FriBidiStrIndex *map\n)\n{\n  fribidi_boolean status = false;\n  FriBidiLevel max_level = 0;\n\n  if UNLIKELY\n    (len == 0)\n    {\n      status = true;\n      goto out;\n    }\n\n  DBG (\"in fribidi_reorder_line\");\n\n  fribidi_assert (bidi_types);\n  fribidi_assert (embedding_levels);\n\n  DBG (\"reset the embedding levels, 4. whitespace at the end of line\");\n  {\n    register FriBidiStrIndex i;\n\n    /* L1. Reset the embedding levels of some chars:\n       4. any sequence of white space characters at the end of the line. */\n    for (i = off + len - 1; i >= off &&\n\t FRIBIDI_IS_EXPLICIT_OR_BN_OR_WS (bidi_types[i]); i--)\n      embedding_levels[i] = FRIBIDI_DIR_TO_LEVEL (base_dir);\n  }\n\n  /* 7. Reordering resolved levels */\n  {\n    register FriBidiLevel level;\n    register FriBidiStrIndex i;\n\n    /* Reorder both the outstring and the order array */\n    {\n      if (FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_REORDER_NSM))\n\t{\n\t  /* L3. Reorder NSMs. */\n\t  for (i = off + len - 1; i >= off; i--)\n\t    if (FRIBIDI_LEVEL_IS_RTL (embedding_levels[i])\n\t\t&& bidi_types[i] == FRIBIDI_TYPE_NSM)\n\t      {\n\t\tregister FriBidiStrIndex seq_end = i;\n\t\tlevel = embedding_levels[i];\n\n\t\tfor (i--; i >= off &&\n\t\t     FRIBIDI_IS_EXPLICIT_OR_BN_OR_NSM (bidi_types[i])\n\t\t     && embedding_levels[i] == level; i--)\n\t\t  ;\n\n\t\tif (i < off || embedding_levels[i] != level)\n\t\t  {\n\t\t    i++;\n\t\t    DBG (\"warning: NSM(s) at the beginning of level run\");\n\t\t  }\n\n\t\tif (visual_str)\n\t\t  {\n\t\t    bidi_string_reverse (visual_str + i, seq_end - i + 1);\n\t\t  }\n\t\tif (map)\n\t\t  {\n\t\t    index_array_reverse (map + i, seq_end - i + 1);\n\t\t  }\n\t      }\n\t}\n\n      /* Find max_level of the line.  We don't reuse the paragraph\n       * max_level, both for a cleaner API, and that the line max_level\n       * may be far less than paragraph max_level. */\n      for (i = off + len - 1; i >= off; i--)\n\tif (embedding_levels[i] > max_level)\n\t  max_level = embedding_levels[i];\n\n      /* L2. Reorder. */\n      for (level = max_level; level > 0; level--)\n\tfor (i = off + len - 1; i >= off; i--)\n\t  if (embedding_levels[i] >= level)\n\t    {\n\t      /* Find all stretches that are >= level_idx */\n\t      register FriBidiStrIndex seq_end = i;\n\t      for (i--; i >= off && embedding_levels[i] >= level; i--)\n\t\t;\n\n\t      if (visual_str)\n\t\tbidi_string_reverse (visual_str + i + 1, seq_end - i);\n\t      if (map)\n\t\tindex_array_reverse (map + i + 1, seq_end - i);\n\t    }\n    }\n\n  }\n\n  status = true;\n\nout:\n\n  return status ? max_level + 1 : 0;\n}\n\n/* Editor directions:\n * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent\n */\n"], "filenames": ["lib/fribidi-bidi.c"], "buggy_code_start_loc": [750], "buggy_code_end_loc": [751], "fixing_code_start_loc": [750], "fixing_code_end_loc": [753], "type": "CWE-120", "message": "A buffer overflow in the fribidi_get_par_embedding_levels_ex() function in lib/fribidi-bidi.c of GNU FriBidi through 1.0.7 allows an attacker to cause a denial of service or possibly execute arbitrary code by delivering crafted text content to a user, when this content is then rendered by an application that uses FriBidi for text layout calculations. Examples include any GNOME or GTK+ based application that uses Pango for text layout, as this internally uses FriBidi for bidirectional text layout. For example, the attacker can construct a crafted text file to be opened in GEdit, or a crafted IRC message to be viewed in HexChat.", "other": {"cve": {"id": "CVE-2019-18397", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-13T14:15:10.287", "lastModified": "2020-08-18T15:05:57.937", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A buffer overflow in the fribidi_get_par_embedding_levels_ex() function in lib/fribidi-bidi.c of GNU FriBidi through 1.0.7 allows an attacker to cause a denial of service or possibly execute arbitrary code by delivering crafted text content to a user, when this content is then rendered by an application that uses FriBidi for text layout calculations. Examples include any GNOME or GTK+ based application that uses Pango for text layout, as this internally uses FriBidi for bidirectional text layout. For example, the attacker can construct a crafted text file to be opened in GEdit, or a crafted IRC message to be viewed in HexChat."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer en la funci\u00f3n fribidi_get_par_embedding_levels_ex() en la biblioteca lib/fribidi-bidi.c de GNU FriBidi versiones hasta 1.0.7, permite a un atacante causar una denegaci\u00f3n de servicio o posiblemente ejecutar c\u00f3digo arbitrario al entregar contenido de texto dise\u00f1ado a un usuario, cuando este contenido es entonces renderizado mediante una aplicaci\u00f3n que utiliza FriBidi para los c\u00e1lculos de dise\u00f1o de texto. Los ejemplos incluyen cualquier aplicaci\u00f3n basada en GNOME o GTK+ que use Pango para el dise\u00f1o de texto, ya que esto utiliza internamente FriBidi para el dise\u00f1o de texto bidireccional. Por ejemplo, el atacante puede construir un archivo de texto dise\u00f1ado para abrirse en GEdit, o un mensaje IRC dise\u00f1ado para ser visualizado en HexChat."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:fribidi:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndIncluding": "1.0.7", "matchCriteriaId": "A44D7FB1-D10A-4EE2-A822-2143C8FDD733"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:4326", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4361", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0291", "source": "cve@mitre.org"}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=944327", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/fribidi/fribidi/commit/034c6e9a1d296286305f4cfd1e0072b879f52568", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TFS3N6KKXPI6ATDNEUFRSLX7R6BOBNIP/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/W5UJRTG32FDNI7T637Q6PZYL3UCRR5HR/", "source": "cve@mitre.org"}, {"url": "https://marc.info/?l=oss-security&m=157322128105807&w=2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2019-18397", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-41", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/fribidi/fribidi/commit/034c6e9a1d296286305f4cfd1e0072b879f52568"}}