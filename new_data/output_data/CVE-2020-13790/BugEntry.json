{"buggy_code": ["2.0.5\n=====\n\n1. Worked around issues in the MIPS DSPr2 SIMD extensions that caused failures\nin the libjpeg-turbo regression tests.  Specifically, the\n`jsimd_h2v1_downsample_dspr2()` and `jsimd_h2v2_downsample_dspr2()` functions\nin the MIPS DSPr2 SIMD extensions are now disabled until/unless they can be\nfixed, and other functions that are incompatible with big endian MIPS CPUs are\ndisabled when building libjpeg-turbo for such CPUs.\n\n2. Fixed an oversight in the `TJCompressor.compress(int)` method in the\nTurboJPEG Java API that caused an error (\"java.lang.IllegalStateException: No\nsource image is associated with this instance\") when attempting to use that\nmethod to compress a YUV image.\n\n\n2.0.4\n=====\n\n### Significant changes relative to 2.0.3:\n\n1. Fixed a regression in the Windows packaging system (introduced by\n2.0 beta1[2]) whereby, if both the 64-bit libjpeg-turbo SDK for GCC and the\n64-bit libjpeg-turbo SDK for Visual C++ were installed on the same system, only\none of them could be uninstalled.\n\n2. Fixed a signed integer overflow and subsequent segfault that occurred when\nattempting to decompress images with more than 715827882 pixels using the\n64-bit C version of TJBench.\n\n3. Fixed out-of-bounds write in `tjDecompressToYUV2()` and\n`tjDecompressToYUVPlanes()` (sometimes manifesting as a double free) that\noccurred when attempting to decompress grayscale JPEG images that were\ncompressed with a sampling factor other than 1 (for instance, with\n`cjpeg -grayscale -sample 2x2`).\n\n4. Fixed a regression introduced by 2.0.2[5] that caused the TurboJPEG API to\nincorrectly identify some JPEG images with unusual sampling factors as 4:4:4\nJPEG images.  This was known to cause a buffer overflow when attempting to\ndecompress some such images using `tjDecompressToYUV2()` or\n`tjDecompressToYUVPlanes()`.\n\n5. Fixed an issue, detected by ASan, whereby attempting to losslessly transform\na specially-crafted malformed JPEG image containing an extremely-high-frequency\ncoefficient block (junk image data that could never be generated by a\nlegitimate JPEG compressor) could cause the Huffman encoder's local buffer to\nbe overrun. (Refer to 1.4.0[9] and 1.4beta1[15].)  Given that the buffer\noverrun was fully contained within the stack and did not cause a segfault or\nother user-visible errant behavior, and given that the lossless transformer\n(unlike the decompressor) is not generally exposed to arbitrary data exploits,\nthis issue did not likely pose a security risk.\n\n6. The ARM 64-bit (ARMv8) NEON SIMD assembly code now stores constants in a\nseparate read-only data section rather than in the text section, to support\nexecute-only memory layouts.\n\n\n2.0.3\n=====\n\n### Significant changes relative to 2.0.2:\n\n1. Fixed \"using JNI after critical get\" errors that occurred on Android\nplatforms when passing invalid arguments to certain methods in the TurboJPEG\nJava API.\n\n2. Fixed a regression in the SIMD feature detection code, introduced by\nthe AVX2 SIMD extensions (2.0 beta1[1]), that was known to cause an illegal\ninstruction exception, in rare cases, on CPUs that lack support for CPUID leaf\n07H (or on which the maximum CPUID leaf has been limited by way of a BIOS\nsetting.)\n\n3. The 4:4:0 (h1v2) fancy (smooth) chroma upsampling algorithm in the\ndecompressor now uses a similar bias pattern to that of the 4:2:2 (h2v1) fancy\nchroma upsampling algorithm, rounding up or down the upsampled result for\nalternate pixels rather than always rounding down.  This ensures that,\nregardless of whether a 4:2:2 JPEG image is rotated or transposed prior to\ndecompression (in the frequency domain) or after decompression (in the spatial\ndomain), the final image will be similar.\n\n4. Fixed an integer overflow and subsequent segfault that occurred when\nattempting to compress or decompress images with more than 1 billion pixels\nusing the TurboJPEG API.\n\n5. Fixed a regression introduced by 2.0 beta1[15] whereby attempting to\ngenerate a progressive JPEG image on an SSE2-capable CPU using a scan script\ncontaining one or more scans with lengths divisible by 16 would result in an\nerror (\"Missing Huffman code table entry\") and an invalid JPEG image.\n\n6. Fixed an issue whereby `tjDecodeYUV()` and `tjDecodeYUVPlanes()` would throw\nan error (\"Invalid progressive parameters\") or a warning (\"Inconsistent\nprogression sequence\") if passed a TurboJPEG instance that was previously used\nto decompress a progressive JPEG image.\n\n\n2.0.2\n=====\n\n### Significant changes relative to 2.0.1:\n\n1. Fixed a regression introduced by 2.0.1[5] that prevented a runtime search\npath (rpath) from being embedded in the libjpeg-turbo shared libraries and\nexecutables for macOS and iOS.  This caused a fatal error of the form\n\"dyld: Library not loaded\" when attempting to use one of the executables,\nunless `DYLD_LIBRARY_PATH` was explicitly set to the location of the\nlibjpeg-turbo shared libraries.\n\n2. Fixed an integer overflow and subsequent segfault (CVE-2018-20330) that\noccurred when attempting to load a BMP file with more than 1 billion pixels\nusing the `tjLoadImage()` function.\n\n3. Fixed a buffer overrun (CVE-2018-19664) that occurred when attempting to\ndecompress a specially-crafted malformed JPEG image to a 256-color BMP using\ndjpeg.\n\n4. Fixed a floating point exception that occurred when attempting to\ndecompress a specially-crafted malformed JPEG image with a specified image\nwidth or height of 0 using the C version of TJBench.\n\n5. The TurboJPEG API will now decompress 4:4:4 JPEG images with 2x1, 1x2, 3x1,\nor 1x3 luminance and chrominance sampling factors.  This is a non-standard way\nof specifying 1x subsampling (normally 4:4:4 JPEGs have 1x1 luminance and\nchrominance sampling factors), but the JPEG format and the libjpeg API both\nallow it.\n\n6. Fixed a regression introduced by 2.0 beta1[7] that caused djpeg to generate\nincorrect PPM images when used with the `-colors` option.\n\n7. Fixed an issue whereby a static build of libjpeg-turbo (a build in which\n`ENABLE_SHARED` is `0`) could not be installed using the Visual Studio IDE.\n\n8. Fixed a severe performance issue in the Loongson MMI SIMD extensions that\noccurred when compressing RGB images whose image rows were not 64-bit-aligned.\n\n\n2.0.1\n=====\n\n### Significant changes relative to 2.0.0:\n\n1. Fixed a regression introduced with the new CMake-based Un*x build system,\nwhereby jconfig.h could cause compiler warnings of the form\n`\"HAVE_*_H\" redefined` if it was included by downstream Autotools-based\nprojects that used `AC_CHECK_HEADERS()` to check for the existence of locale.h,\nstddef.h, or stdlib.h.\n\n2. The `jsimd_quantize_float_dspr2()` and `jsimd_convsamp_float_dspr2()`\nfunctions in the MIPS DSPr2 SIMD extensions are now disabled at compile time\nif the soft float ABI is enabled.  Those functions use instructions that are\nincompatible with the soft float ABI.\n\n3. Fixed a regression in the SIMD feature detection code, introduced by\nthe AVX2 SIMD extensions (2.0 beta1[1]), that caused libjpeg-turbo to crash on\nWindows 7 if Service Pack 1 was not installed.\n\n4. Fixed out-of-bounds read in cjpeg that occurred when attempting to compress\na specially-crafted malformed color-index (8-bit-per-sample) Targa file in\nwhich some of the samples (color indices) exceeded the bounds of the Targa\nfile's color table.\n\n5. Fixed an issue whereby installing a fully static build of libjpeg-turbo\n(a build in which `CFLAGS` contains `-static` and `ENABLE_SHARED` is `0`) would\nfail with \"No valid ELF RPATH or RUNPATH entry exists in the file.\"\n\n\n2.0.0\n=====\n\n### Significant changes relative to 2.0 beta1:\n\n1. The TurboJPEG API can now decompress CMYK JPEG images that have subsampled M\nand Y components (not to be confused with YCCK JPEG images, in which the C/M/Y\ncomponents have been transformed into luma and chroma.)   Previously, an error\nwas generated (\"Could not determine subsampling type for JPEG image\") when such\nan image was passed to `tjDecompressHeader3()`, `tjTransform()`,\n`tjDecompressToYUVPlanes()`, `tjDecompressToYUV2()`, or the equivalent Java\nmethods.\n\n2. Fixed an issue (CVE-2018-11813) whereby a specially-crafted malformed input\nfile (specifically, a file with a valid Targa header but incomplete pixel data)\nwould cause cjpeg to generate a JPEG file that was potentially thousands of\ntimes larger than the input file.  The Targa reader in cjpeg was not properly\ndetecting that the end of the input file had been reached prematurely, so after\nall valid pixels had been read from the input, the reader injected dummy pixels\nwith values of 255 into the JPEG compressor until the number of pixels\nspecified in the Targa header had been compressed.  The Targa reader in cjpeg\nnow behaves like the PPM reader and aborts compression if the end of the input\nfile is reached prematurely.  Because this issue only affected cjpeg and not\nthe underlying library, and because it did not involve any out-of-bounds reads\nor other exploitable behaviors, it was not believed to represent a security\nthreat.\n\n3. Fixed an issue whereby the `tjLoadImage()` and `tjSaveImage()` functions\nwould produce a \"Bogus message code\" error message if the underlying bitmap and\nPPM readers/writers threw an error that was specific to the readers/writers\n(as opposed to a general libjpeg API error.)\n\n4. Fixed an issue (CVE-2018-1152) whereby a specially-crafted malformed BMP\nfile, one in which the header specified an image width of 1073741824 pixels,\nwould trigger a floating point exception (division by zero) in the\n`tjLoadImage()` function when attempting to load the BMP file into a\n4-component image buffer.\n\n5. Fixed an issue whereby certain combinations of calls to\n`jpeg_skip_scanlines()` and `jpeg_read_scanlines()` could trigger an infinite\nloop when decompressing progressive JPEG images that use vertical chroma\nsubsampling (for instance, 4:2:0 or 4:4:0.)\n\n6. Fixed a segfault in `jpeg_skip_scanlines()` that occurred when decompressing\na 4:2:2 or 4:2:0 JPEG image using the merged (non-fancy) upsampling algorithms\n(that is, when setting `cinfo.do_fancy_upsampling` to `FALSE`.)\n\n7. The new CMake-based build system will now disable the MIPS DSPr2 SIMD\nextensions if it detects that the compiler does not support DSPr2 instructions.\n\n8. Fixed out-of-bounds read in cjpeg (CVE-2018-14498) that occurred when\nattempting to compress a specially-crafted malformed color-index\n(8-bit-per-sample) BMP file in which some of the samples (color indices)\nexceeded the bounds of the BMP file's color table.\n\n9. Fixed a signed integer overflow in the progressive Huffman decoder, detected\nby the Clang and GCC undefined behavior sanitizers, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\ndid not pose a security threat, but removing the warning made it easier to\ndetect actual security issues, should they arise in the future.\n\n\n1.5.90 (2.0 beta1)\n==================\n\n### Significant changes relative to 1.5.3:\n\n1. Added AVX2 SIMD implementations of the colorspace conversion, chroma\ndownsampling and upsampling, integer quantization and sample conversion, and\nslow integer DCT/IDCT algorithms.  When using the slow integer DCT/IDCT\nalgorithms on AVX2-equipped CPUs, the compression of RGB images is\napproximately 13-36% (avg. 22%) faster (relative to libjpeg-turbo 1.5.x) with\n64-bit code and 11-21% (avg. 17%) faster with 32-bit code, and the\ndecompression of RGB images is approximately 9-35% (avg. 17%) faster with\n64-bit code and 7-17% (avg. 12%) faster with 32-bit code.  (As tested on a\n3 GHz Intel Core i7.  Actual mileage may vary.)\n\n2. Overhauled the build system to use CMake on all platforms, and removed the\nautotools-based build system.  This decision resulted from extensive\ndiscussions within the libjpeg-turbo community.  libjpeg-turbo traditionally\nused CMake only for Windows builds, but there was an increasing amount of\ndemand to extend CMake support to other platforms.  However, because of the\nunique nature of our code base (the need to support different assemblers on\neach platform, the need for Java support, etc.), providing dual build systems\nas other OSS imaging libraries do (including libpng and libtiff) would have\ncreated a maintenance burden.  The use of CMake greatly simplifies some aspects\nof our build system, owing to CMake's built-in support for various assemblers,\nJava, and unit testing, as well as generally fewer quirks that have to be\nworked around in order to implement our packaging system.  Eliminating\nautotools puts our project slightly at odds with the traditional practices of\nthe OSS community, since most \"system libraries\" tend to be built with\nautotools, but it is believed that the benefits of this move outweigh the\nrisks.  In addition to providing a unified build environment, switching to\nCMake allows for the use of various build tools and IDEs that aren't supported\nunder autotools, including XCode, Ninja, and Eclipse.  It also eliminates the\nneed to install autotools via MacPorts/Homebrew on OS X and allows\nlibjpeg-turbo to be configured without the use of a terminal/command prompt.\nExtensive testing was conducted to ensure that all features provided by the\nautotools-based build system are provided by the new build system.\n\n3. The libjpeg API in this version of libjpeg-turbo now includes two additional\nfunctions, `jpeg_read_icc_profile()` and `jpeg_write_icc_profile()`, that can\nbe used to extract ICC profile data from a JPEG file while decompressing or to\nembed ICC profile data in a JPEG file while compressing or transforming.  This\neliminates the need for downstream projects, such as color management libraries\nand browsers, to include their own glueware for accomplishing this.\n\n4. Improved error handling in the TurboJPEG API library:\n\n     - Introduced a new function (`tjGetErrorStr2()`) in the TurboJPEG C API\nthat allows compression/decompression/transform error messages to be retrieved\nin a thread-safe manner.  Retrieving error messages from global functions, such\nas `tjInitCompress()` or `tjBufSize()`, is still thread-unsafe, but since those\nfunctions will only throw errors if passed an invalid argument or if a memory\nallocation failure occurs, thread safety is not as much of a concern.\n     - Introduced a new function (`tjGetErrorCode()`) in the TurboJPEG C API\nand a new method (`TJException.getErrorCode()`) in the TurboJPEG Java API that\ncan be used to determine the severity of the last\ncompression/decompression/transform error.  This allows applications to\nchoose whether to ignore warnings (non-fatal errors) from the underlying\nlibjpeg API or to treat them as fatal.\n     - Introduced a new flag (`TJFLAG_STOPONWARNING` in the TurboJPEG C API and\n`TJ.FLAG_STOPONWARNING` in the TurboJPEG Java API) that causes the library to\nimmediately halt a compression/decompression/transform operation if it\nencounters a warning from the underlying libjpeg API (the default behavior is\nto allow the operation to complete unless a fatal error is encountered.)\n\n5. Introduced a new flag in the TurboJPEG C and Java APIs (`TJFLAG_PROGRESSIVE`\nand `TJ.FLAG_PROGRESSIVE`, respectively) that causes the library to use\nprogressive entropy coding in JPEG images generated by compression and\ntransform operations.  Additionally, a new transform option\n(`TJXOPT_PROGRESSIVE` in the C API and `TJTransform.OPT_PROGRESSIVE` in the\nJava API) has been introduced, allowing progressive entropy coding to be\nenabled for selected transforms in a multi-transform operation.\n\n6. Introduced a new transform option in the TurboJPEG API (`TJXOPT_COPYNONE` in\nthe C API and `TJTransform.OPT_COPYNONE` in the Java API) that allows the\ncopying of markers (including EXIF and ICC profile data) to be disabled for a\nparticular transform.\n\n7. Added two functions to the TurboJPEG C API (`tjLoadImage()` and\n`tjSaveImage()`) that can be used to load/save a BMP or PPM/PGM image to/from a\nmemory buffer with a specified pixel format and layout.  These functions\nreplace the project-private (and slow) bmp API, which was previously used by\nTJBench, and they also provide a convenient way for first-time users of\nlibjpeg-turbo to quickly develop a complete JPEG compression/decompression\nprogram.\n\n8. The TurboJPEG C API now includes a new convenience array (`tjAlphaOffset[]`)\nthat contains the alpha component index for each pixel format (or -1 if the\npixel format lacks an alpha component.)  The TurboJPEG Java API now includes a\nnew method (`TJ.getAlphaOffset()`) that returns the same value.  In addition,\nthe `tjRedOffset[]`, `tjGreenOffset[]`, and `tjBlueOffset[]` arrays-- and the\ncorresponding `TJ.getRedOffset()`, `TJ.getGreenOffset()`, and\n`TJ.getBlueOffset()` methods-- now return -1 for `TJPF_GRAY`/`TJ.PF_GRAY`\nrather than 0.  This allows programs to easily determine whether a pixel format\nhas red, green, blue, and alpha components.\n\n9. Added a new example (tjexample.c) that demonstrates the basic usage of the\nTurboJPEG C API.  This example mirrors the functionality of TJExample.java.\nBoth files are now included in the libjpeg-turbo documentation.\n\n10. Fixed two signed integer overflows in the arithmetic decoder, detected by\nthe Clang undefined behavior sanitizer, that could be triggered by attempting\nto decompress a specially-crafted malformed JPEG image.  These issues did not\npose a security threat, but removing the warnings makes it easier to detect\nactual security issues, should they arise in the future.\n\n11. Fixed a bug in the merged 4:2:0 upsampling/dithered RGB565 color conversion\nalgorithm that caused incorrect dithering in the output image.  This algorithm\nnow produces bitwise-identical results to the unmerged algorithms.\n\n12. The SIMD function symbols for x86[-64]/ELF, MIPS/ELF, macOS/x86[-64] (if\nlibjpeg-turbo is built with YASM), and iOS/ARM[64] builds are now private.\nThis prevents those symbols from being exposed in applications or shared\nlibraries that link statically with libjpeg-turbo.\n\n13. Added Loongson MMI SIMD implementations of the RGB-to-YCbCr and\nYCbCr-to-RGB colorspace conversion, 4:2:0 chroma downsampling, 4:2:0 fancy\nchroma upsampling, integer quantization, and slow integer DCT/IDCT algorithms.\nWhen using the slow integer DCT/IDCT, this speeds up the compression of RGB\nimages by approximately 70-100% and the decompression of RGB images by\napproximately 2-3.5x.\n\n14. Fixed a build error when building with older MinGW releases (regression\ncaused by 1.5.1[7].)\n\n15. Added SIMD acceleration for progressive Huffman encoding on SSE2-capable\nx86 and x86-64 platforms.  This speeds up the compression of full-color\nprogressive JPEGs by about 85-90% on average (relative to libjpeg-turbo 1.5.x)\nwhen using modern Intel and AMD CPUs.\n\n\n1.5.3\n=====\n\n### Significant changes relative to 1.5.2:\n\n1. Fixed a NullPointerException in the TurboJPEG Java wrapper that occurred\nwhen using the YUVImage constructor that creates an instance backed by separate\nimage planes and allocates memory for the image planes.\n\n2. Fixed an issue whereby the Java version of TJUnitTest would fail when\ntesting BufferedImage encoding/decoding on big endian systems.\n\n3. Fixed a segfault in djpeg that would occur if an output format other than\nPPM/PGM was selected along with the `-crop` option.  The `-crop` option now\nworks with the GIF and Targa formats as well (unfortunately, it cannot be made\nto work with the BMP and RLE formats due to the fact that those output engines\nwrite scanlines in bottom-up order.)  djpeg will now exit gracefully if an\noutput format other than PPM/PGM, GIF, or Targa is selected along with the\n`-crop` option.\n\n4. Fixed an issue (CVE-2017-15232) whereby `jpeg_skip_scanlines()` would\nsegfault if color quantization was enabled.\n\n5. TJBench (both C and Java versions) will now display usage information if any\ncommand-line argument is unrecognized.  This prevents the program from silently\nignoring typos.\n\n6. Fixed an access violation in tjbench.exe (Windows) that occurred when the\nprogram was used to decompress an existing JPEG image.\n\n7. Fixed an ArrayIndexOutOfBoundsException in the TJExample Java program that\noccurred when attempting to decompress a JPEG image that had been compressed\nwith 4:1:1 chrominance subsampling.\n\n8. Fixed an issue whereby, when using `jpeg_skip_scanlines()` to skip to the\nend of a single-scan (non-progressive) image, subsequent calls to\n`jpeg_consume_input()` would return `JPEG_SUSPENDED` rather than\n`JPEG_REACHED_EOI`.\n\n9. `jpeg_crop_scanlines()` now works correctly when decompressing grayscale\nJPEG images that were compressed with a sampling factor other than 1 (for\ninstance, with `cjpeg -grayscale -sample 2x2`).\n\n\n1.5.2\n=====\n\n### Significant changes relative to 1.5.1:\n\n1. Fixed a regression introduced by 1.5.1[7] that prevented libjpeg-turbo from\nbuilding with Android NDK platforms prior to android-21 (5.0).\n\n2. Fixed a regression introduced by 1.5.1[1] that prevented the MIPS DSPR2 SIMD\ncode in libjpeg-turbo from building.\n\n3. Fixed a regression introduced by 1.5 beta1[11] that prevented the Java\nversion of TJBench from outputting any reference images (the `-nowrite` switch\nwas accidentally enabled by default.)\n\n4. libjpeg-turbo should now build and run with full AltiVec SIMD acceleration\non PowerPC-based AmigaOS 4 and OpenBSD systems.\n\n5. Fixed build and runtime errors on Windows that occurred when building\nlibjpeg-turbo with libjpeg v7 API/ABI emulation and the in-memory\nsource/destination managers.  Due to an oversight, the `jpeg_skip_scanlines()`\nand `jpeg_crop_scanlines()` functions were not being included in jpeg7.dll when\nlibjpeg-turbo was built with `-DWITH_JPEG7=1` and `-DWITH_MEMSRCDST=1`.\n\n6. Fixed \"Bogus virtual array access\" error that occurred when using the\nlossless crop feature in jpegtran or the TurboJPEG API, if libjpeg-turbo was\nbuilt with libjpeg v7 API/ABI emulation.  This was apparently a long-standing\nbug that has existed since the introduction of libjpeg v7/v8 API/ABI emulation\nin libjpeg-turbo v1.1.\n\n7. The lossless transform features in jpegtran and the TurboJPEG API will now\nalways attempt to adjust the EXIF image width and height tags if the image size\nchanged as a result of the transform.  This behavior has always existed when\nusing libjpeg v8 API/ABI emulation.  It was supposed to be available with\nlibjpeg v7 API/ABI emulation as well but did not work properly due to a bug.\nFurthermore, there was never any good reason not to enable it with libjpeg v6b\nAPI/ABI emulation, since the behavior is entirely internal.  Note that\n`-copy all` must be passed to jpegtran in order to transfer the EXIF tags from\nthe source image to the destination image.\n\n8. Fixed several memory leaks in the TurboJPEG API library that could occur\nif the library was built with certain compilers and optimization levels\n(known to occur with GCC 4.x and clang with `-O1` and higher but not with\nGCC 5.x or 6.x) and one of the underlying libjpeg API functions threw an error\nafter a TurboJPEG API function allocated a local buffer.\n\n9. The libjpeg-turbo memory manager will now honor the `max_memory_to_use`\nstructure member in jpeg\\_memory\\_mgr, which can be set to the maximum amount\nof memory (in bytes) that libjpeg-turbo should use during decompression or\nmulti-pass (including progressive) compression.  This limit can also be set\nusing the `JPEGMEM` environment variable or using the `-maxmemory` switch in\ncjpeg/djpeg/jpegtran (refer to the respective man pages for more details.)\nThis has been a documented feature of libjpeg since v5, but the\n`malloc()`/`free()` implementation of the memory manager (jmemnobs.c) never\nimplemented the feature.  Restricting libjpeg-turbo's memory usage is useful\nfor two reasons:  it allows testers to more easily work around the 2 GB limit\nin libFuzzer, and it allows developers of security-sensitive applications to\nmore easily defend against one of the progressive JPEG exploits (LJT-01-004)\nidentified in\n[this report](http://www.libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n10. TJBench will now run each benchmark for 1 second prior to starting the\ntimer, in order to improve the consistency of the results.  Furthermore, the\n`-warmup` option is now used to specify the amount of warmup time rather than\nthe number of warmup iterations.\n\n11. Fixed an error (`short jump is out of range`) that occurred when assembling\nthe 32-bit x86 SIMD extensions with NASM versions prior to 2.04.  This was a\nregression introduced by 1.5 beta1[12].\n\n\n1.5.1\n=====\n\n### Significant changes relative to 1.5.0:\n\n1. Previously, the undocumented `JSIMD_FORCE*` environment variables could be\nused to force-enable a particular SIMD instruction set if multiple instruction\nsets were available on a particular platform.  On x86 platforms, where CPU\nfeature detection is bulletproof and multiple SIMD instruction sets are\navailable, it makes sense for those environment variables to allow forcing the\nuse of an instruction set only if that instruction set is available.  However,\nsince the ARM implementations of libjpeg-turbo can only use one SIMD\ninstruction set, and since their feature detection code is less bulletproof\n(parsing /proc/cpuinfo), it makes sense for the `JSIMD_FORCENEON` environment\nvariable to bypass the feature detection code and really force the use of NEON\ninstructions.  A new environment variable (`JSIMD_FORCEDSPR2`) was introduced\nin the MIPS implementation for the same reasons, and the existing\n`JSIMD_FORCENONE` environment variable was extended to that implementation.\nThese environment variables provide a workaround for those attempting to test\nARM and MIPS builds of libjpeg-turbo in QEMU, which passes through\n/proc/cpuinfo from the host system.\n\n2. libjpeg-turbo previously assumed that AltiVec instructions were always\navailable on PowerPC platforms, which led to \"illegal instruction\" errors when\nrunning on PowerPC chips that lack AltiVec support (such as the older 7xx/G3\nand newer e5500 series.)  libjpeg-turbo now examines /proc/cpuinfo on\nLinux/Android systems and enables AltiVec instructions only if the CPU supports\nthem.  It also now provides two environment variables, `JSIMD_FORCEALTIVEC` and\n`JSIMD_FORCENONE`, to force-enable and force-disable AltiVec instructions in\nenvironments where /proc/cpuinfo is an unreliable means of CPU feature\ndetection (such as when running in QEMU.)  On OS X, libjpeg-turbo continues to\nassume that AltiVec support is always available, which means that libjpeg-turbo\ncannot be used with G3 Macs unless you set the environment variable\n`JSIMD_FORCENONE` to `1`.\n\n3. Fixed an issue whereby 64-bit ARM (AArch64) builds of libjpeg-turbo would\ncrash when built with recent releases of the Clang/LLVM compiler.  This was\ncaused by an ABI conformance issue in some of libjpeg-turbo's 64-bit NEON SIMD\nroutines.  Those routines were incorrectly using 64-bit instructions to\ntransfer a 32-bit JDIMENSION argument, whereas the ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fancy upsampling is now supported when decompressing JPEG images that use\n4:4:0 (h1v2) chroma subsampling.  These images are generated when losslessly\nrotating or transposing JPEG images that use 4:2:2 (h2v1) chroma subsampling.\nThe h1v2 fancy upsampling algorithm is not currently SIMD-accelerated.\n\n5. If merged upsampling isn't SIMD-accelerated but YCbCr-to-RGB conversion is,\nthen libjpeg-turbo will now disable merged upsampling when decompressing YCbCr\nJPEG images into RGB or extended RGB output images.  This significantly speeds\nup the decompression of 4:2:0 and 4:2:2 JPEGs on ARM platforms if fancy\nupsampling is not used (for example, if the `-nosmooth` option to djpeg is\nspecified.)\n\n6. The TurboJPEG API will now decompress 4:2:2 and 4:4:0 JPEG images with\n2x2 luminance sampling factors and 2x1 or 1x2 chrominance sampling factors.\nThis is a non-standard way of specifying 2x subsampling (normally 4:2:2 JPEGs\nhave 2x1 luminance and 1x1 chrominance sampling factors, and 4:4:0 JPEGs have\n1x2 luminance and 1x1 chrominance sampling factors), but the JPEG format and\nthe libjpeg API both allow it.\n\n7. Fixed an unsigned integer overflow in the libjpeg memory manager, detected\nby the Clang undefined behavior sanitizer, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\naffected only 32-bit code and did not pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n8. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers when attempting to decompress\nspecially-crafted malformed JPEG images.  None of these issues posed a security\nthreat, but removing the warnings makes it easier to detect actual security\nissues, should they arise in the future.\n\n9. Fixed an out-of-bounds array reference, introduced by 1.4.90[2] (partial\nimage decompression) and detected by the Clang undefined behavior sanitizer,\nthat could be triggered by a specially-crafted malformed JPEG image with more\nthan four components.  Because the out-of-bounds reference was still within the\nsame structure, it was not known to pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n10. Fixed another ABI conformance issue in the 64-bit ARM (AArch64) NEON SIMD\ncode.  Some of the routines were incorrectly reading and storing data below the\nstack pointer, which caused segfaults in certain applications under specific\ncircumstances.\n\n\n1.5.0\n=====\n\n### Significant changes relative to 1.5 beta1:\n\n1. Fixed an issue whereby a malformed motion-JPEG frame could cause the \"fast\npath\" of libjpeg-turbo's Huffman decoder to read from uninitialized memory.\n\n2. Added libjpeg-turbo version and build information to the global string table\nof the libjpeg and TurboJPEG API libraries.  This is a common practice in other\ninfrastructure libraries, such as OpenSSL and libpng, because it makes it easy\nto examine an application binary and determine which version of the library the\napplication was linked against.\n\n3. Fixed a couple of issues in the PPM reader that would cause buffer overruns\nin cjpeg if one of the values in a binary PPM/PGM input file exceeded the\nmaximum value defined in the file's header.  libjpeg-turbo 1.4.2 already\nincluded a similar fix for ASCII PPM/PGM files.  Note that these issues were\nnot security bugs, since they were confined to the cjpeg program and did not\naffect any of the libjpeg-turbo libraries.\n\n4. Fixed an issue whereby attempting to decompress a JPEG file with a corrupt\nheader using the `tjDecompressToYUV2()` function would cause the function to\nabort without returning an error and, under certain circumstances, corrupt the\nstack.  This only occurred if `tjDecompressToYUV2()` was called prior to\ncalling `tjDecompressHeader3()`, or if the return value from\n`tjDecompressHeader3()` was ignored (both cases represent incorrect usage of\nthe TurboJPEG API.)\n\n5. Fixed an issue in the ARM 32-bit SIMD-accelerated Huffman encoder that\nprevented the code from assembling properly with clang.\n\n6. The `jpeg_stdio_src()`, `jpeg_mem_src()`, `jpeg_stdio_dest()`, and\n`jpeg_mem_dest()` functions in the libjpeg API will now throw an error if a\nsource/destination manager has already been assigned to the compress or\ndecompress object by a different function or by the calling program.  This\nprevents these functions from attempting to reuse a source/destination manager\nstructure that was allocated elsewhere, because there is no way to ensure that\nit would be big enough to accommodate the new source/destination manager.\n\n\n1.4.90 (1.5 beta1)\n==================\n\n### Significant changes relative to 1.4.2:\n\n1. Added full SIMD acceleration for PowerPC platforms using AltiVec VMX\n(128-bit SIMD) instructions.  Although the performance of libjpeg-turbo on\nPowerPC was already good, due to the increased number of registers available\nto the compiler vs. x86, it was still possible to speed up compression by about\n3-4x and decompression by about 2-2.5x (relative to libjpeg v6b) through the\nuse of AltiVec instructions.\n\n2. Added two new libjpeg API functions (`jpeg_skip_scanlines()` and\n`jpeg_crop_scanline()`) that can be used to partially decode a JPEG image.  See\n[libjpeg.txt](libjpeg.txt) for more details.\n\n3. The TJCompressor and TJDecompressor classes in the TurboJPEG Java API now\nimplement the Closeable interface, so those classes can be used with a\ntry-with-resources statement.\n\n4. The TurboJPEG Java classes now throw unchecked idiomatic exceptions\n(IllegalArgumentException, IllegalStateException) for unrecoverable errors\ncaused by incorrect API usage, and those classes throw a new checked exception\ntype (TJException) for errors that are passed through from the C library.\n\n5. Source buffers for the TurboJPEG C API functions, as well as the\n`jpeg_mem_src()` function in the libjpeg API, are now declared as const\npointers.  This facilitates passing read-only buffers to those functions and\nensures the caller that the source buffer will not be modified.  This should\nnot create any backward API or ABI incompatibilities with prior libjpeg-turbo\nreleases.\n\n6. The MIPS DSPr2 SIMD code can now be compiled to support either FR=0 or FR=1\nFPUs.\n\n7. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers.  Most of these issues affected only\n32-bit code, and none of them was known to pose a security threat, but removing\nthe warnings makes it easier to detect actual security issues, should they\narise in the future.\n\n8. Removed the unnecessary `.arch` directive from the ARM64 NEON SIMD code.\nThis directive was preventing the code from assembling using the clang\nintegrated assembler.\n\n9. Fixed a regression caused by 1.4.1[6] that prevented 32-bit and 64-bit\nlibjpeg-turbo RPMs from being installed simultaneously on recent Red Hat/Fedora\ndistributions.  This was due to the addition of a macro in jconfig.h that\nallows the Huffman codec to determine the word size at compile time.  Since\nthat macro differs between 32-bit and 64-bit builds, this caused a conflict\nbetween the i386 and x86_64 RPMs (any differing files, other than executables,\nare not allowed when 32-bit and 64-bit RPMs are installed simultaneously.)\nSince the macro is used only internally, it has been moved into jconfigint.h.\n\n10. The x86-64 SIMD code can now be disabled at run time by setting the\n`JSIMD_FORCENONE` environment variable to `1` (the other SIMD implementations\nalready had this capability.)\n\n11. Added a new command-line argument to TJBench (`-nowrite`) that prevents the\nbenchmark from outputting any images.  This removes any potential operating\nsystem overhead that might be caused by lazy writes to disk and thus improves\nthe consistency of the performance measurements.\n\n12. Added SIMD acceleration for Huffman encoding on SSE2-capable x86 and x86-64\nplatforms.  This speeds up the compression of full-color JPEGs by about 10-15%\non average (relative to libjpeg-turbo 1.4.x) when using modern Intel and AMD\nCPUs.  Additionally, this works around an issue in the clang optimizer that\nprevents it (as of this writing) from achieving the same performance as GCC\nwhen compiling the C version of the Huffman encoder\n(<https://llvm.org/bugs/show_bug.cgi?id=16035>).  For the purposes of\nbenchmarking or regression testing, SIMD-accelerated Huffman encoding can be\ndisabled by setting the `JSIMD_NOHUFFENC` environment variable to `1`.\n\n13. Added ARM 64-bit (ARMv8) NEON SIMD implementations of the commonly-used\ncompression algorithms (including the slow integer forward DCT and h2v2 & h2v1\ndownsampling algorithms, which are not accelerated in the 32-bit NEON\nimplementation.)  This speeds up the compression of full-color JPEGs by about\n75% on average on a Cavium ThunderX processor and by about 2-2.5x on average on\nCortex-A53 and Cortex-A57 cores.\n\n14. Added SIMD acceleration for Huffman encoding on NEON-capable ARM 32-bit\nand 64-bit platforms.\n\n    For 32-bit code, this speeds up the compression of full-color JPEGs by\nabout 30% on average on a typical iOS device (iPhone 4S, Cortex-A9) and by\nabout 6-7% on average on a typical Android device (Nexus 5X, Cortex-A53 and\nCortex-A57), relative to libjpeg-turbo 1.4.x.  Note that the larger speedup\nunder iOS is due to the fact that iOS builds use LLVM, which does not optimize\nthe C Huffman encoder as well as GCC does.\n\n    For 64-bit code, NEON-accelerated Huffman encoding speeds up the\ncompression of full-color JPEGs by about 40% on average on a typical iOS device\n(iPhone 5S, Apple A7) and by about 7-8% on average on a typical Android device\n(Nexus 5X, Cortex-A53 and Cortex-A57), in addition to the speedup described in\n[13] above.\n\n    For the purposes of benchmarking or regression testing, SIMD-accelerated\nHuffman encoding can be disabled by setting the `JSIMD_NOHUFFENC` environment\nvariable to `1`.\n\n15. pkg-config (.pc) scripts are now included for both the libjpeg and\nTurboJPEG API libraries on Un*x systems.  Note that if a project's build system\nrelies on these scripts, then it will not be possible to build that project\nwith libjpeg or with a prior version of libjpeg-turbo.\n\n16. Optimized the ARM 64-bit (ARMv8) NEON SIMD decompression routines to\nimprove performance on CPUs with in-order pipelines.  This speeds up the\ndecompression of full-color JPEGs by nearly 2x on average on a Cavium ThunderX\nprocessor and by about 15% on average on a Cortex-A53 core.\n\n17. Fixed an issue in the accelerated Huffman decoder that could have caused\nthe decoder to read past the end of the input buffer when a malformed,\nspecially-crafted JPEG image was being decompressed.  In prior versions of\nlibjpeg-turbo, the accelerated Huffman decoder was invoked (in most cases) only\nif there were > 128 bytes of data in the input buffer.  However, it is possible\nto construct a JPEG image in which a single Huffman block is over 430 bytes\nlong, so this version of libjpeg-turbo activates the accelerated Huffman\ndecoder only if there are > 512 bytes of data in the input buffer.\n\n18. Fixed a memory leak in tjunittest encountered when running the program\nwith the `-yuv` option.\n\n\n1.4.2\n=====\n\n### Significant changes relative to 1.4.1:\n\n1. Fixed an issue whereby cjpeg would segfault if a Windows bitmap with a\nnegative width or height was used as an input image (Windows bitmaps can have\na negative height if they are stored in top-down order, but such files are\nrare and not supported by libjpeg-turbo.)\n\n2. Fixed an issue whereby, under certain circumstances, libjpeg-turbo would\nincorrectly encode certain JPEG images when quality=100 and the fast integer\nforward DCT were used.  This was known to cause `make test` to fail when the\nlibrary was built with `-march=haswell` on x86 systems.\n\n3. Fixed an issue whereby libjpeg-turbo would crash when built with the latest\n& greatest development version of the Clang/LLVM compiler.  This was caused by\nan x86-64 ABI conformance issue in some of libjpeg-turbo's 64-bit SSE2 SIMD\nroutines.  Those routines were incorrectly using a 64-bit `mov` instruction to\ntransfer a 32-bit JDIMENSION argument, whereas the x86-64 ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fixed a bug in the MIPS DSPr2 4:2:0 \"plain\" (non-fancy and non-merged)\nupsampling routine that caused a buffer overflow (and subsequent segfault) when\ndecompressing a 4:2:0 JPEG image whose scaled output width was less than 16\npixels.  The \"plain\" upsampling routines are normally only used when\ndecompressing a non-YCbCr JPEG image, but they are also used when decompressing\na JPEG image whose scaled output height is 1.\n\n5. Fixed various negative left shifts and other issues reported by the GCC and\nClang undefined behavior sanitizers.  None of these was known to pose a\nsecurity threat, but removing the warnings makes it easier to detect actual\nsecurity issues, should they arise in the future.\n\n\n1.4.1\n=====\n\n### Significant changes relative to 1.4.0:\n\n1. tjbench now properly handles CMYK/YCCK JPEG files.  Passing an argument of\n`-cmyk` (instead of, for instance, `-rgb`) will cause tjbench to internally\nconvert the source bitmap to CMYK prior to compression, to generate YCCK JPEG\nfiles, and to internally convert the decompressed CMYK pixels back to RGB after\ndecompression (the latter is done automatically if a CMYK or YCCK JPEG is\npassed to tjbench as a source image.)  The CMYK<->RGB conversion operation is\nnot benchmarked.  NOTE: The quick & dirty CMYK<->RGB conversions that tjbench\nuses are suitable for testing only.  Proper conversion between CMYK and RGB\nrequires a color management system.\n\n2. `make test` now performs additional bitwise regression tests using tjbench,\nmainly for the purpose of testing compression from/decompression to a subregion\nof a larger image buffer.\n\n3. `make test` no longer tests the regression of the floating point DCT/IDCT\nby default, since the results of those tests can vary if the algorithms in\nquestion are not implemented using SIMD instructions on a particular platform.\nSee the comments in [Makefile.am](Makefile.am) for information on how to\nre-enable the tests and to specify an expected result for them based on the\nparticulars of your platform.\n\n4. The NULL color conversion routines have been significantly optimized,\nwhich speeds up the compression of RGB and CMYK JPEGs by 5-20% when using\n64-bit code and 0-3% when using 32-bit code, and the decompression of those\nimages by 10-30% when using 64-bit code and 3-12% when using 32-bit code.\n\n5. Fixed an \"illegal instruction\" error that occurred when djpeg from a\nSIMD-enabled libjpeg-turbo MIPS build was executed with the `-nosmooth` option\non a MIPS machine that lacked DSPr2 support.  The MIPS SIMD routines for h2v1\nand h2v2 merged upsampling were not properly checking for the existence of\nDSPr2.\n\n6. Performance has been improved significantly on 64-bit non-Linux and\nnon-Windows platforms (generally 10-20% faster compression and 5-10% faster\ndecompression.)  Due to an oversight, the 64-bit version of the accelerated\nHuffman codec was not being compiled in when libjpeg-turbo was built on\nplatforms other than Windows or Linux.  Oops.\n\n7. Fixed an extremely rare bug in the Huffman encoder that caused 64-bit\nbuilds of libjpeg-turbo to incorrectly encode a few specific test images when\nquality=98, an optimized Huffman table, and the slow integer forward DCT were\nused.\n\n8. The Windows (CMake) build system now supports building only static or only\nshared libraries.  This is accomplished by adding either `-DENABLE_STATIC=0` or\n`-DENABLE_SHARED=0` to the CMake command line.\n\n9. TurboJPEG API functions will now return an error code if a warning is\ntriggered in the underlying libjpeg API.  For instance, if a JPEG file is\ncorrupt, the TurboJPEG decompression functions will attempt to decompress\nas much of the image as possible, but those functions will now return -1 to\nindicate that the decompression was not entirely successful.\n\n10. Fixed a bug in the MIPS DSPr2 4:2:2 fancy upsampling routine that caused a\nbuffer overflow (and subsequent segfault) when decompressing a 4:2:2 JPEG image\nin which the right-most MCU was 5 or 6 pixels wide.\n\n\n1.4.0\n=====\n\n### Significant changes relative to 1.4 beta1:\n\n1. Fixed a build issue on OS X PowerPC platforms (md5cmp failed to build\nbecause OS X does not provide the `le32toh()` and `htole32()` functions.)\n\n2. The non-SIMD RGB565 color conversion code did not work correctly on big\nendian machines.  This has been fixed.\n\n3. Fixed an issue in `tjPlaneSizeYUV()` whereby it would erroneously return 1\ninstead of -1 if `componentID` was > 0 and `subsamp` was `TJSAMP_GRAY`.\n\n3. Fixed an issue in `tjBufSizeYUV2()` whereby it would erroneously return 0\ninstead of -1 if `width` was < 1.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM64 platforms (see 1.4 beta1[5].)\n\n6. The `close()` method in the TJCompressor and TJDecompressor Java classes is\nnow idempotent.  Previously, that method would call the native `tjDestroy()`\nfunction even if the TurboJPEG instance had already been destroyed.  This\ncaused an exception to be thrown during finalization, if the `close()` method\nhad already been called.  The exception was caught, but it was still an\nexpensive operation.\n\n7. The TurboJPEG API previously generated an error (`Could not determine\nsubsampling type for JPEG image`) when attempting to decompress grayscale JPEG\nimages that were compressed with a sampling factor other than 1 (for instance,\nwith `cjpeg -grayscale -sample 2x2`).  Subsampling technically has no meaning\nwith grayscale JPEGs, and thus the horizontal and vertical sampling factors\nfor such images are ignored by the decompressor.  However, the TurboJPEG API\nwas being too rigid and was expecting the sampling factors to be equal to 1\nbefore it treated the image as a grayscale JPEG.\n\n8. cjpeg, djpeg, and jpegtran now accept an argument of `-version`, which will\nprint the library version and exit.\n\n9. Referring to 1.4 beta1[15], another extremely rare circumstance was\ndiscovered under which the Huffman encoder's local buffer can be overrun\nwhen a buffered destination manager is being used and an\nextremely-high-frequency block (basically junk image data) is being encoded.\nEven though the Huffman local buffer was increased from 128 bytes to 136 bytes\nto address the previous issue, the new issue caused even the larger buffer to\nbe overrun.  Further analysis reveals that, in the absolute worst case (such as\nsetting alternating AC coefficients to 32767 and -32768 in the JPEG scanning\norder), the Huffman encoder can produce encoded blocks that approach double the\nsize of the unencoded blocks.  Thus, the Huffman local buffer was increased to\n256 bytes, which should prevent any such issue from re-occurring in the future.\n\n10. The new `tjPlaneSizeYUV()`, `tjPlaneWidth()`, and `tjPlaneHeight()`\nfunctions were not actually usable on any platform except OS X and Windows,\nbecause those functions were not included in the libturbojpeg mapfile.  This\nhas been fixed.\n\n11. Restored the `JPP()`, `JMETHOD()`, and `FAR` macros in the libjpeg-turbo\nheader files.  The `JPP()` and `JMETHOD()` macros were originally implemented\nin libjpeg as a way of supporting non-ANSI compilers that lacked support for\nprototype parameters.  libjpeg-turbo has never supported such compilers, but\nsome software packages still use the macros to define their own prototypes.\nSimilarly, libjpeg-turbo has never supported MS-DOS and other platforms that\nhave far symbols, but some software packages still use the `FAR` macro.  A\npretty good argument can be made that this is a bad practice on the part of the\nsoftware in question, but since this affects more than one package, it's just\neasier to fix it here.\n\n12. Fixed issues that were preventing the ARM 64-bit SIMD code from compiling\nfor iOS, and included an ARMv8 architecture in all of the binaries installed by\nthe \"official\" libjpeg-turbo SDK for OS X.\n\n\n1.3.90 (1.4 beta1)\n==================\n\n### Significant changes relative to 1.3.1:\n\n1. New features in the TurboJPEG API:\n\n     - YUV planar images can now be generated with an arbitrary line padding\n(previously only 4-byte padding, which was compatible with X Video, was\nsupported.)\n     - The decompress-to-YUV function has been extended to support image\nscaling.\n     - JPEG images can now be compressed from YUV planar source images.\n     - YUV planar images can now be decoded into RGB or grayscale images.\n     - 4:1:1 subsampling is now supported.  This is mainly included for\ncompatibility, since 4:1:1 is not fully accelerated in libjpeg-turbo and has no\nsignificant advantages relative to 4:2:0.\n     - CMYK images are now supported.  This feature allows CMYK source images\nto be compressed to YCCK JPEGs and YCCK or CMYK JPEGs to be decompressed to\nCMYK destination images.  Conversion between CMYK/YCCK and RGB or YUV images is\nnot supported.  Such conversion requires a color management system and is thus\nout of scope for a codec library.\n     - The handling of YUV images in the Java API has been significantly\nrefactored and should now be much more intuitive.\n     - The Java API now supports encoding a YUV image from an arbitrary\nposition in a large image buffer.\n     - All of the YUV functions now have a corresponding function that operates\non separate image planes instead of a unified image buffer.  This allows for\ncompressing/decoding from or decompressing/encoding to a subregion of a larger\nYUV image.  It also allows for handling YUV formats that swap the order of the\nU and V planes.\n\n2. Added SIMD acceleration for DSPr2-capable MIPS platforms.  This speeds up\nthe compression of full-color JPEGs by 70-80% on such platforms and\ndecompression by 25-35%.\n\n3. If an application attempts to decompress a Huffman-coded JPEG image whose\nheader does not contain Huffman tables, libjpeg-turbo will now insert the\ndefault Huffman tables.  In order to save space, many motion JPEG video frames\nare encoded without the default Huffman tables, so these frames can now be\nsuccessfully decompressed by libjpeg-turbo without additional work on the part\nof the application.  An application can still override the Huffman tables, for\ninstance to re-use tables from a previous frame of the same video.\n\n4. The Mac packaging system now uses pkgbuild and productbuild rather than\nPackageMaker (which is obsolete and no longer supported.)  This means that\nOS X 10.6 \"Snow Leopard\" or later must be used when packaging libjpeg-turbo,\nalthough the packages produced can be installed on OS X 10.5 \"Leopard\" or\nlater.  OS X 10.4 \"Tiger\" is no longer supported.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM platforms rather than a lookup table.  This reduces the memory footprint\nby 64k, which may be important for some mobile applications.  Out of four\nAndroid devices that were tested, two demonstrated a small overall performance\nloss (~3-4% on average) with ARMv6 code and a small gain (also ~3-4%) with\nARMv7 code when enabling this new feature, but the other two devices\ndemonstrated a significant overall performance gain with both ARMv6 and ARMv7\ncode (~10-20%) when enabling the feature.  Actual mileage may vary.\n\n6. Worked around an issue with Visual C++ 2010 and later that caused incorrect\npixels to be generated when decompressing a JPEG image to a 256-color bitmap,\nif compiler optimization was enabled when libjpeg-turbo was built.  This caused\nthe regression tests to fail when doing a release build under Visual C++ 2010\nand later.\n\n7. Improved the accuracy and performance of the non-SIMD implementation of the\nfloating point inverse DCT (using code borrowed from libjpeg v8a and later.)\nThe accuracy of this implementation now matches the accuracy of the SSE/SSE2\nimplementation.  Note, however, that the floating point DCT/IDCT algorithms are\nmainly a legacy feature.  They generally do not produce significantly better\naccuracy than the slow integer DCT/IDCT algorithms, and they are quite a bit\nslower.\n\n8. Added a new output colorspace (`JCS_RGB565`) to the libjpeg API that allows\nfor decompressing JPEG images into RGB565 (16-bit) pixels.  If dithering is not\nused, then this code path is SIMD-accelerated on ARM platforms.\n\n9. Numerous obsolete features, such as support for non-ANSI compilers and\nsupport for the MS-DOS memory model, were removed from the libjpeg code,\ngreatly improving its readability and making it easier to maintain and extend.\n\n10. Fixed a segfault that occurred when calling `output_message()` with\n`msg_code` set to `JMSG_COPYRIGHT`.\n\n11. Fixed an issue whereby wrjpgcom was allowing comments longer than 65k\ncharacters to be passed on the command line, which was causing it to generate\nincorrect JPEG files.\n\n12. Fixed a bug in the build system that was causing the Windows version of\nwrjpgcom to be built using the rdjpgcom source code.\n\n13. Restored 12-bit-per-component JPEG support.  A 12-bit version of\nlibjpeg-turbo can now be built by passing an argument of `--with-12bit` to\nconfigure (Unix) or `-DWITH_12BIT=1` to cmake (Windows.)  12-bit JPEG support\nis included only for convenience.  Enabling this feature disables all of the\nperformance features in libjpeg-turbo, as well as arithmetic coding and the\nTurboJPEG API.  The resulting library still contains the other libjpeg-turbo\nfeatures (such as the colorspace extensions), but in general, it performs no\nfaster than libjpeg v6b.\n\n14. Added ARM 64-bit SIMD acceleration for the YCC-to-RGB color conversion\nand IDCT algorithms (both are used during JPEG decompression.)  For unknown\nreasons (probably related to clang), this code cannot currently be compiled for\niOS.\n\n15. Fixed an extremely rare bug (CVE-2014-9092) that could cause the Huffman\nencoder's local buffer to overrun when a very high-frequency MCU is compressed\nusing quality 100 and no subsampling, and when the JPEG output buffer is being\ndynamically resized by the destination manager.  This issue was so rare that,\neven with a test program specifically designed to make the bug occur (by\ninjecting random high-frequency YUV data into the compressor), it was\nreproducible only once in about every 25 million iterations.\n\n16. Fixed an oversight in the TurboJPEG C wrapper:  if any of the JPEG\ncompression functions was called repeatedly with the same\nautomatically-allocated destination buffer, then TurboJPEG would erroneously\nassume that the `jpegSize` parameter was equal to the size of the buffer, when\nin fact that parameter was probably equal to the size of the most recently\ncompressed JPEG image.  If the size of the previous JPEG image was not as large\nas the current JPEG image, then TurboJPEG would unnecessarily reallocate the\ndestination buffer.\n\n\n1.3.1\n=====\n\n### Significant changes relative to 1.3.0:\n\n1. On Un*x systems, `make install` now installs the libjpeg-turbo libraries\ninto /opt/libjpeg-turbo/lib32 by default on any 32-bit system, not just x86,\nand into /opt/libjpeg-turbo/lib64 by default on any 64-bit system, not just\nx86-64.  You can override this by overriding either the `prefix` or `libdir`\nconfigure variables.\n\n2. The Windows installer now places a copy of the TurboJPEG DLLs in the same\ndirectory as the rest of the libjpeg-turbo binaries.  This was mainly done\nto support TurboVNC 1.3, which bundles the DLLs in its Windows installation.\nWhen using a 32-bit version of CMake on 64-bit Windows, it is impossible to\naccess the c:\\WINDOWS\\system32 directory, which made it impossible for the\nTurboVNC build scripts to bundle the 64-bit TurboJPEG DLL.\n\n3. Fixed a bug whereby attempting to encode a progressive JPEG with arithmetic\nentropy coding (by passing arguments of `-progressive -arithmetic` to cjpeg or\njpegtran, for instance) would result in an error, `Requested feature was\nomitted at compile time`.\n\n4. Fixed a couple of issues (CVE-2013-6629 and CVE-2013-6630) whereby malformed\nJPEG images would cause libjpeg-turbo to use uninitialized memory during\ndecompression.\n\n5. Fixed an error (`Buffer passed to JPEG library is too small`) that occurred\nwhen calling the TurboJPEG YUV encoding function with a very small (< 5x5)\nsource image, and added a unit test to check for this error.\n\n6. The Java classes should now build properly under Visual Studio 2010 and\nlater.\n\n7. Fixed an issue that prevented SRPMs generated using the in-tree packaging\ntools from being rebuilt on certain newer Linux distributions.\n\n8. Numerous minor fixes to eliminate compilation and build/packaging system\nwarnings, fix cosmetic issues, improve documentation clarity, and other general\nsource cleanup.\n\n\n1.3.0\n=====\n\n### Significant changes relative to 1.3 beta1:\n\n1. `make test` now works properly on FreeBSD, and it no longer requires the\nmd5sum executable to be present on other Un*x platforms.\n\n2. Overhauled the packaging system:\n\n     - To avoid conflict with vendor-supplied libjpeg-turbo packages, the\nofficial RPMs and DEBs for libjpeg-turbo have been renamed to\n\"libjpeg-turbo-official\".\n     - The TurboJPEG libraries are now located under /opt/libjpeg-turbo in the\nofficial Linux and Mac packages, to avoid conflict with vendor-supplied\npackages and also to streamline the packaging system.\n     - Release packages are now created with the directory structure defined\nby the configure variables `prefix`, `bindir`, `libdir`, etc. (Un\\*x) or by the\n`CMAKE_INSTALL_PREFIX` variable (Windows.)  The exception is that the docs are\nalways located under the system default documentation directory on Un\\*x and\nMac systems, and on Windows, the TurboJPEG DLL is always located in the Windows\nsystem directory.\n     - To avoid confusion, official libjpeg-turbo packages on Linux/Unix\nplatforms (except for Mac) will always install the 32-bit libraries in\n/opt/libjpeg-turbo/lib32 and the 64-bit libraries in /opt/libjpeg-turbo/lib64.\n     - Fixed an issue whereby, in some cases, the libjpeg-turbo executables on\nUn*x systems were not properly linking with the shared libraries installed by\nthe same package.\n     - Fixed an issue whereby building the \"installer\" target on Windows when\n`WITH_JAVA=1` would fail if the TurboJPEG JAR had not been previously built.\n     - Building the \"install\" target on Windows now installs files into the\nsame places that the installer does.\n\n3. Fixed a Huffman encoder bug that prevented I/O suspension from working\nproperly.\n\n\n1.2.90 (1.3 beta1)\n==================\n\n### Significant changes relative to 1.2.1:\n\n1. Added support for additional scaling factors (3/8, 5/8, 3/4, 7/8, 9/8, 5/4,\n11/8, 3/2, 13/8, 7/4, 15/8, and 2) when decompressing.  Note that the IDCT will\nnot be SIMD-accelerated when using any of these new scaling factors.\n\n2. The TurboJPEG dynamic library is now versioned.  It was not strictly\nnecessary to do so, because TurboJPEG uses versioned symbols, and if a function\nchanges in an ABI-incompatible way, that function is renamed and a legacy\nfunction is provided to maintain backward compatibility.  However, certain\nLinux distro maintainers have a policy against accepting any library that isn't\nversioned.\n\n3. Extended the TurboJPEG Java API so that it can be used to compress a JPEG\nimage from and decompress a JPEG image to an arbitrary position in a large\nimage buffer.\n\n4. The `tjDecompressToYUV()` function now supports the `TJFLAG_FASTDCT` flag.\n\n5. The 32-bit supplementary package for amd64 Debian systems now provides\nsymlinks in /usr/lib/i386-linux-gnu for the TurboJPEG libraries in /usr/lib32.\nThis allows those libraries to be used on MultiArch-compatible systems (such as\nUbuntu 11 and later) without setting the linker path.\n\n6. The TurboJPEG Java wrapper should now find the JNI library on Mac systems\nwithout having to pass `-Djava.library.path=/usr/lib` to java.\n\n7. TJBench has been ported to Java to provide a convenient way of validating\nthe performance of the TurboJPEG Java API.  It can be run with\n`java -cp turbojpeg.jar TJBench`.\n\n8. cjpeg can now be used to generate JPEG files with the RGB colorspace\n(feature ported from jpeg-8d.)\n\n9. The width and height in the `-crop` argument passed to jpegtran can now be\nsuffixed with `f` to indicate that, when the upper left corner of the cropping\nregion is automatically moved to the nearest iMCU boundary, the bottom right\ncorner should be moved by the same amount.  In other words, this feature causes\njpegtran to strictly honor the specified width/height rather than the specified\nbottom right corner (feature ported from jpeg-8d.)\n\n10. JPEG files using the RGB colorspace can now be decompressed into grayscale\nimages (feature ported from jpeg-8d.)\n\n11. Fixed a regression caused by 1.2.1[7] whereby the build would fail with\nmultiple \"Mismatch in operand sizes\" errors when attempting to build the x86\nSIMD code with NASM 0.98.\n\n12. The in-memory source/destination managers (`jpeg_mem_src()` and\n`jpeg_mem_dest()`) are now included by default when building libjpeg-turbo with\nlibjpeg v6b or v7 emulation, so that programs can take advantage of these\nfunctions without requiring the use of the backward-incompatible libjpeg v8\nABI.  The \"age number\" of the libjpeg-turbo library on Un*x systems has been\nincremented by 1 to reflect this.  You can disable this feature with a\nconfigure/CMake switch in order to retain strict API/ABI compatibility with the\nlibjpeg v6b or v7 API/ABI (or with previous versions of libjpeg-turbo.)  See\n[README.md](README.md) for more details.\n\n13. Added ARMv7s architecture to libjpeg.a and libturbojpeg.a in the official\nlibjpeg-turbo binary package for OS X, so that those libraries can be used to\nbuild applications that leverage the faster CPUs in the iPhone 5 and iPad 4.\n\n\n1.2.1\n=====\n\n### Significant changes relative to 1.2.0:\n\n1. Creating or decoding a JPEG file that uses the RGB colorspace should now\nproperly work when the input or output colorspace is one of the libjpeg-turbo\ncolorspace extensions.\n\n2. When libjpeg-turbo was built without SIMD support and merged (non-fancy)\nupsampling was used along with an alpha-enabled colorspace during\ndecompression, the unused byte of the decompressed pixels was not being set to\n0xFF.  This has been fixed.  TJUnitTest has also been extended to test for the\ncorrect behavior of the colorspace extensions when merged upsampling is used.\n\n3. Fixed a bug whereby the libjpeg-turbo SSE2 SIMD code would not preserve the\nupper 64 bits of xmm6 and xmm7 on Win64 platforms, which violated the Win64\ncalling conventions.\n\n4. Fixed a regression (CVE-2012-2806) caused by 1.2.0[6] whereby decompressing\ncorrupt JPEG images (specifically, images in which the component count was\nerroneously set to a large value) would cause libjpeg-turbo to segfault.\n\n5. Worked around a severe performance issue with \"Bobcat\" (AMD Embedded APU)\nprocessors.  The `MASKMOVDQU` instruction, which was used by the libjpeg-turbo\nSSE2 SIMD code, is apparently implemented in microcode on AMD processors, and\nit is painfully slow on Bobcat processors in particular.  Eliminating the use\nof this instruction improved performance by an order of magnitude on Bobcat\nprocessors and by a small amount (typically 5%) on AMD desktop processors.\n\n6. Added SIMD acceleration for performing 4:2:2 upsampling on NEON-capable ARM\nplatforms.  This speeds up the decompression of 4:2:2 JPEGs by 20-25% on such\nplatforms.\n\n7. Fixed a regression caused by 1.2.0[2] whereby, on Linux/x86 platforms\nrunning the 32-bit SSE2 SIMD code in libjpeg-turbo, decompressing a 4:2:0 or\n4:2:2 JPEG image into a 32-bit (RGBX, BGRX, etc.) buffer without using fancy\nupsampling would produce several incorrect columns of pixels at the right-hand\nside of the output image if each row in the output image was not evenly\ndivisible by 16 bytes.\n\n8. Fixed an issue whereby attempting to build the SIMD extensions with Xcode\n4.3 on OS X platforms would cause NASM to return numerous errors of the form\n\"'%define' expects a macro identifier\".\n\n9. Added flags to the TurboJPEG API that allow the caller to force the use of\neither the fast or the accurate DCT/IDCT algorithms in the underlying codec.\n\n\n1.2.0\n=====\n\n### Significant changes relative to 1.2 beta1:\n\n1. Fixed build issue with YASM on Unix systems (the libjpeg-turbo build system\nwas not adding the current directory to the assembler include path, so YASM\nwas not able to find jsimdcfg.inc.)\n\n2. Fixed out-of-bounds read in SSE2 SIMD code that occurred when decompressing\na JPEG image to a bitmap buffer whose size was not a multiple of 16 bytes.\nThis was more of an annoyance than an actual bug, since it did not cause any\nactual run-time problems, but the issue showed up when running libjpeg-turbo in\nvalgrind.  See <http://crbug.com/72399> for more information.\n\n3. Added a compile-time macro (`LIBJPEG_TURBO_VERSION`) that can be used to\ncheck the version of libjpeg-turbo against which an application was compiled.\n\n4. Added new RGBA/BGRA/ABGR/ARGB colorspace extension constants (libjpeg API)\nand pixel formats (TurboJPEG API), which allow applications to specify that,\nwhen decompressing to a 4-component RGB buffer, the unused byte should be set\nto 0xFF so that it can be interpreted as an opaque alpha channel.\n\n5. Fixed regression issue whereby DevIL failed to build against libjpeg-turbo\nbecause libjpeg-turbo's distributed version of jconfig.h contained an `INLINE`\nmacro, which conflicted with a similar macro in DevIL.  This macro is used only\ninternally when building libjpeg-turbo, so it was moved into config.h.\n\n6. libjpeg-turbo will now correctly decompress erroneous CMYK/YCCK JPEGs whose\nK component is assigned a component ID of 1 instead of 4.  Although these files\nare in violation of the spec, other JPEG implementations handle them\ncorrectly.\n\n7. Added ARMv6 and ARMv7 architectures to libjpeg.a and libturbojpeg.a in\nthe official libjpeg-turbo binary package for OS X, so that those libraries can\nbe used to build both OS X and iOS applications.\n\n\n1.1.90 (1.2 beta1)\n==================\n\n### Significant changes relative to 1.1.1:\n\n1. Added a Java wrapper for the TurboJPEG API.  See [java/README](java/README)\nfor more details.\n\n2. The TurboJPEG API can now be used to scale down images during\ndecompression.\n\n3. Added SIMD routines for RGB-to-grayscale color conversion, which\nsignificantly improves the performance of grayscale JPEG compression from an\nRGB source image.\n\n4. Improved the performance of the C color conversion routines, which are used\non platforms for which SIMD acceleration is not available.\n\n5. Added a function to the TurboJPEG API that performs lossless transforms.\nThis function is implemented using the same back end as jpegtran, but it\nperforms transcoding entirely in memory and allows multiple transforms and/or\ncrop operations to be batched together, so the source coefficients only need to\nbe read once.  This is useful when generating image tiles from a single source\nJPEG.\n\n6. Added tests for the new TurboJPEG scaled decompression and lossless\ntransform features to tjbench (the TurboJPEG benchmark, formerly called\n\"jpgtest\".)\n\n7. Added support for 4:4:0 (transposed 4:2:2) subsampling in TurboJPEG, which\nwas necessary in order for it to read 4:2:2 JPEG files that had been losslessly\ntransposed or rotated 90 degrees.\n\n8. All legacy VirtualGL code has been re-factored, and this has allowed\nlibjpeg-turbo, in its entirety, to be re-licensed under a BSD-style license.\n\n9. libjpeg-turbo can now be built with YASM.\n\n10. Added SIMD acceleration for ARM Linux and iOS platforms that support\nNEON instructions.\n\n11. Refactored the TurboJPEG C API and documented it using Doxygen.  The\nTurboJPEG 1.2 API uses pixel formats to define the size and component order of\nthe uncompressed source/destination images, and it includes a more efficient\nversion of `TJBUFSIZE()` that computes a worst-case JPEG size based on the\nlevel of chrominance subsampling.  The refactored implementation of the\nTurboJPEG API now uses the libjpeg memory source and destination managers,\nwhich allows the TurboJPEG compressor to grow the JPEG buffer as necessary.\n\n12. Eliminated errors in the output of jpegtran on Windows that occurred when\nthe application was invoked using I/O redirection\n(`jpegtran <input.jpg >output.jpg`.)\n\n13. The inclusion of libjpeg v7 and v8 emulation as well as arithmetic coding\nsupport in libjpeg-turbo v1.1.0 introduced several new error constants in\njerror.h, and these were mistakenly enabled for all emulation modes, causing\nthe error enum in libjpeg-turbo to sometimes have different values than the\nsame enum in libjpeg.  This represents an ABI incompatibility, and it caused\nproblems with rare applications that took specific action based on a particular\nerror value.  The fix was to include the new error constants conditionally\nbased on whether libjpeg v7 or v8 emulation was enabled.\n\n14. Fixed an issue whereby Windows applications that used libjpeg-turbo would\nfail to compile if the Windows system headers were included before jpeglib.h.\nThis issue was caused by a conflict in the definition of the INT32 type.\n\n15. Fixed 32-bit supplementary package for amd64 Debian systems, which was\nbroken by enhancements to the packaging system in 1.1.\n\n16. When decompressing a JPEG image using an output colorspace of\n`JCS_EXT_RGBX`, `JCS_EXT_BGRX`, `JCS_EXT_XBGR`, or `JCS_EXT_XRGB`,\nlibjpeg-turbo will now set the unused byte to 0xFF, which allows applications\nto interpret that byte as an alpha channel (0xFF = opaque).\n\n\n1.1.1\n=====\n\n### Significant changes relative to 1.1.0:\n\n1. Fixed a 1-pixel error in row 0, column 21 of the luminance plane generated\nby `tjEncodeYUV()`.\n\n2. libjpeg-turbo's accelerated Huffman decoder previously ignored unexpected\nmarkers found in the middle of the JPEG data stream during decompression.  It\nwill now hand off decoding of a particular block to the unaccelerated Huffman\ndecoder if an unexpected marker is found, so that the unaccelerated Huffman\ndecoder can generate an appropriate warning.\n\n3. Older versions of MinGW64 prefixed symbol names with underscores by\ndefault, which differed from the behavior of 64-bit Visual C++.  MinGW64 1.0\nhas adopted the behavior of 64-bit Visual C++ as the default, so to accommodate\nthis, the libjpeg-turbo SIMD function names are no longer prefixed with an\nunderscore when building with MinGW64.  This means that, when building\nlibjpeg-turbo with older versions of MinGW64, you will now have to add\n`-fno-leading-underscore` to the `CFLAGS`.\n\n4. Fixed a regression bug in the NSIS script that caused the Windows installer\nbuild to fail when using the Visual Studio IDE.\n\n5. Fixed a bug in `jpeg_read_coefficients()` whereby it would not initialize\n`cinfo->image_width` and `cinfo->image_height` if libjpeg v7 or v8 emulation\nwas enabled.  This specifically caused the jpegoptim program to fail if it was\nlinked against a version of libjpeg-turbo that was built with libjpeg v7 or v8\nemulation.\n\n6. Eliminated excessive I/O overhead that occurred when reading BMP files in\ncjpeg.\n\n7. Eliminated errors in the output of cjpeg on Windows that occurred when the\napplication was invoked using I/O redirection (`cjpeg <inputfile >output.jpg`.)\n\n\n1.1.0\n=====\n\n### Significant changes relative to 1.1 beta1:\n\n1. The algorithm used by the SIMD quantization function cannot produce correct\nresults when the JPEG quality is >= 98 and the fast integer forward DCT is\nused.  Thus, the non-SIMD quantization function is now used for those cases,\nand libjpeg-turbo should now produce identical output to libjpeg v6b in all\ncases.\n\n2. Despite the above, the fast integer forward DCT still degrades somewhat for\nJPEG qualities greater than 95, so the TurboJPEG wrapper will now automatically\nuse the slow integer forward DCT when generating JPEG images of quality 96 or\ngreater.  This reduces compression performance by as much as 15% for these\nhigh-quality images but is necessary to ensure that the images are perceptually\nlossless.  It also ensures that the library can avoid the performance pitfall\ncreated by [1].\n\n3. Ported jpgtest.cxx to pure C to avoid the need for a C++ compiler.\n\n4. Fixed visual artifacts in grayscale JPEG compression caused by a typo in\nthe RGB-to-luminance lookup tables.\n\n5. The Windows distribution packages now include the libjpeg run-time programs\n(cjpeg, etc.)\n\n6. All packages now include jpgtest.\n\n7. The TurboJPEG dynamic library now uses versioned symbols.\n\n8. Added two new TurboJPEG API functions, `tjEncodeYUV()` and\n`tjDecompressToYUV()`, to replace the somewhat hackish `TJ_YUV` flag.\n\n\n1.0.90 (1.1 beta1)\n==================\n\n### Significant changes relative to 1.0.1:\n\n1. Added emulation of the libjpeg v7 and v8 APIs and ABIs.  See\n[README.md](README.md) for more details.  This feature was sponsored by\nCamTrace SAS.\n\n2. Created a new CMake-based build system for the Visual C++ and MinGW builds.\n\n3. Grayscale bitmaps can now be compressed from/decompressed to using the\nTurboJPEG API.\n\n4. jpgtest can now be used to test decompression performance with existing\nJPEG images.\n\n5. If the default install prefix (/opt/libjpeg-turbo) is used, then\n`make install` now creates /opt/libjpeg-turbo/lib32 and\n/opt/libjpeg-turbo/lib64 sym links to duplicate the behavior of the binary\npackages.\n\n6. All symbols in the libjpeg-turbo dynamic library are now versioned, even\nwhen the library is built with libjpeg v6b emulation.\n\n7. Added arithmetic encoding and decoding support (can be disabled with\nconfigure or CMake options)\n\n8. Added a `TJ_YUV` flag to the TurboJPEG API, which causes both the compressor\nand decompressor to output planar YUV images.\n\n9. Added an extended version of `tjDecompressHeader()` to the TurboJPEG API,\nwhich allows the caller to determine the type of subsampling used in a JPEG\nimage.\n\n10. Added further protections against invalid Huffman codes.\n\n\n1.0.1\n=====\n\n### Significant changes relative to 1.0.0:\n\n1. The Huffman decoder will now handle erroneous Huffman codes (for instance,\nfrom a corrupt JPEG image.)  Previously, these would cause libjpeg-turbo to\ncrash under certain circumstances.\n\n2. Fixed typo in SIMD dispatch routines that was causing 4:2:2 upsampling to\nbe used instead of 4:2:0 when decompressing JPEG images using SSE2 code.\n\n3. The configure script will now automatically determine whether the\n`INCOMPLETE_TYPES_BROKEN` macro should be defined.\n\n\n1.0.0\n=====\n\n### Significant changes relative to 0.0.93:\n\n1. 2983700: Further FreeBSD build tweaks (no longer necessary to specify\n`--host` when configuring on a 64-bit system)\n\n2. Created symlinks in the Unix/Linux packages so that the TurboJPEG\ninclude file can always be found in /opt/libjpeg-turbo/include, the 32-bit\nstatic libraries can always be found in /opt/libjpeg-turbo/lib32, and the\n64-bit static libraries can always be found in /opt/libjpeg-turbo/lib64.\n\n3. The Unix/Linux distribution packages now include the libjpeg run-time\nprograms (cjpeg, etc.) and man pages.\n\n4. Created a 32-bit supplementary package for amd64 Debian systems, which\ncontains just the 32-bit libjpeg-turbo libraries.\n\n5. Moved the libraries from */lib32 to */lib in the i386 Debian package.\n\n6. Include distribution package for Cygwin\n\n7. No longer necessary to specify `--without-simd` on non-x86 architectures,\nand unit tests now work on those architectures.\n\n\n0.0.93\n======\n\n### Significant changes since 0.0.91:\n\n1. 2982659: Fixed x86-64 build on FreeBSD systems\n\n2. 2988188: Added support for Windows 64-bit systems\n\n\n0.0.91\n======\n\n### Significant changes relative to 0.0.90:\n\n1. Added documentation to .deb packages\n\n2. 2968313: Fixed data corruption issues when decompressing large JPEG images\nand/or using buffered I/O with the libjpeg-turbo decompressor\n\n\n0.0.90\n======\n\nInitial release\n", "/*\n * rdppm.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2009 by Bill Allombert, Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015-2017, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to read input images in PPM/PGM format.\n * The extended 2-byte-per-sample raw PPM/PGM formats are supported.\n * The PBMPLUS library is NOT required to compile this software\n * (but it is highly useful as a set of PPM image manipulation programs).\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume input from\n * an ordinary stdio stream.  They further assume that reading begins\n * at the start of the file; start_input may need work if the\n * user interface has already read some data (e.g., to determine that\n * the file is indeed PPM format).\n */\n\n#include \"cmyk.h\"\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#ifdef PPM_SUPPORTED\n\n\n/* Portions of this code are based on the PBMPLUS library, which is:\n**\n** Copyright (C) 1988 by Jef Poskanzer.\n**\n** Permission to use, copy, modify, and distribute this software and its\n** documentation for any purpose and without fee is hereby granted, provided\n** that the above copyright notice appear in all copies and that both that\n** copyright notice and this permission notice appear in supporting\n** documentation.  This software is provided \"as is\" without express or\n** implied warranty.\n*/\n\n\n/* Macros to deal with unsigned chars as efficiently as compiler allows */\n\n#ifdef HAVE_UNSIGNED_CHAR\ntypedef unsigned char U_CHAR;\n#define UCH(x)  ((int)(x))\n#else /* !HAVE_UNSIGNED_CHAR */\n#ifdef __CHAR_UNSIGNED__\ntypedef char U_CHAR;\n#define UCH(x)  ((int)(x))\n#else\ntypedef char U_CHAR;\n#define UCH(x)  ((int)(x) & 0xFF)\n#endif\n#endif /* HAVE_UNSIGNED_CHAR */\n\n\n#define ReadOK(file, buffer, len) \\\n  (JFREAD(file, buffer, len) == ((size_t)(len)))\n\nstatic int alpha_index[JPEG_NUMCS] = {\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1\n};\n\n\n/* Private version of data source object */\n\ntypedef struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  /* Usually these two pointers point to the same place: */\n  U_CHAR *iobuffer;             /* fread's I/O buffer */\n  JSAMPROW pixrow;              /* compressor input buffer */\n  size_t buffer_width;          /* width of I/O buffer */\n  JSAMPLE *rescale;             /* => maxval-remapping array, or NULL */\n  unsigned int maxval;\n} ppm_source_struct;\n\ntypedef ppm_source_struct *ppm_source_ptr;\n\n\nLOCAL(int)\npbm_getc(FILE *infile)\n/* Read next char, skipping over any comments */\n/* A comment/newline sequence is returned as a newline */\n{\n  register int ch;\n\n  ch = getc(infile);\n  if (ch == '#') {\n    do {\n      ch = getc(infile);\n    } while (ch != '\\n' && ch != EOF);\n  }\n  return ch;\n}\n\n\nLOCAL(unsigned int)\nread_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n/* Read an unsigned decimal integer from the PPM file */\n/* Swallows one trailing character after the integer */\n/* Note that on a 16-bit-int machine, only values up to 64k can be read. */\n/* This should not be a problem in practice. */\n{\n  register int ch;\n  register unsigned int val;\n\n  /* Skip any leading whitespace */\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n\n  return val;\n}\n\n\n/*\n * Read one row of pixels.\n *\n * We provide several different versions depending on input file format.\n * In all cases, input is scaled to the size of JSAMPLE.\n *\n * A really fast path is provided for reading byte/sample raw files with\n * maxval = MAXJSAMPLE, which is the normal case for 8-bit data.\n */\n\n\nMETHODDEF(JDIMENSION)\nget_text_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub.buffer[0];\n  for (col = cinfo->image_width; col > 0; col--) {\n    *ptr++ = rescale[read_pbm_integer(cinfo, infile, maxval)];\n  }\n  return 1;\n}\n\n\n#define GRAY_RGB_READ_LOOP(read_op, alpha_set_op) { \\\n  for (col = cinfo->image_width; col > 0; col--) { \\\n    ptr[rindex] = ptr[gindex] = ptr[bindex] = read_op; \\\n    alpha_set_op \\\n    ptr += ps; \\\n  } \\\n}\n\nMETHODDEF(JDIMENSION)\nget_text_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval and\n   converting to extended RGB */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),)\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],)\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_text_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\n#define RGB_READ_LOOP(read_op, alpha_set_op) { \\\n  for (col = cinfo->image_width; col > 0; col--) { \\\n    ptr[rindex] = read_op; \\\n    ptr[gindex] = read_op; \\\n    ptr[bindex] = read_op; \\\n    alpha_set_op \\\n    ptr += ps; \\\n  } \\\n}\n\nMETHODDEF(JDIMENSION)\nget_text_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),\n                    ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),)\n  } else {\n    if (aindex >= 0)\n      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                    ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],)\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_text_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PPM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE g = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE b = read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE g = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE b = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_scaled_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    *ptr++ = rescale[UCH(*bufferptr++)];\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval\n   and converting to extended RGB */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(*bufferptr++,)\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)],)\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval\n   and converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = *bufferptr++;\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = rescale[UCH(*bufferptr++)];\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(*bufferptr++,)\n  } else {\n    if (aindex >= 0)\n      RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(rescale[UCH(*bufferptr++)],)\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PPM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = *bufferptr++;\n      JSAMPLE g = *bufferptr++;\n      JSAMPLE b = *bufferptr++;\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = rescale[UCH(*bufferptr++)];\n      JSAMPLE g = rescale[UCH(*bufferptr++)];\n      JSAMPLE b = rescale[UCH(*bufferptr++)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_raw_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format files with maxval = MAXJSAMPLE.\n * In this case we just read right into the JSAMPLE buffer!\n * Note that same code works for PPM and PGM files.\n */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  int c;\n  unsigned int w, h, maxval;\n  boolean need_iobuffer, use_raw_buffer, need_rescale;\n\n  if (getc(source->pub.input_file) != 'P')\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  c = getc(source->pub.input_file); /* subformat discriminator character */\n\n  /* detect unsupported variants (ie, PBM) before trying to read header */\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n  case '3':                     /* it's a text-format PPM file */\n  case '5':                     /* it's a raw-format PGM file */\n  case '6':                     /* it's a raw-format PPM file */\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_NOT);\n    break;\n  }\n\n  /* fetch the remaining header info */\n  w = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  h = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  maxval = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n\n  if (w <= 0 || h <= 0 || maxval <= 0) /* error check */\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  cinfo->data_precision = BITS_IN_JSAMPLE; /* we always rescale data to this */\n  cinfo->image_width = (JDIMENSION)w;\n  cinfo->image_height = (JDIMENSION)h;\n  source->maxval = maxval;\n\n  /* initialize flags to most common settings */\n  need_iobuffer = TRUE;         /* do we need an I/O buffer? */\n  use_raw_buffer = FALSE;       /* do we map input buffer onto I/O buffer? */\n  need_rescale = TRUE;          /* do we need a rescale array? */\n\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_PGM_TEXT, w, h);\n    if (cinfo->in_color_space == JCS_GRAYSCALE)\n      source->pub.get_pixel_rows = get_text_gray_row;\n    else if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_gray_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_gray_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '3':                     /* it's a text-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS2(cinfo, 1, JTRC_PPM_TEXT, w, h);\n    if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_rgb_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '5':                     /* it's a raw-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_PGM, w, h);\n    if (maxval > 255) {\n      source->pub.get_pixel_rows = get_word_gray_row;\n    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n               cinfo->in_color_space == JCS_GRAYSCALE) {\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (cinfo->in_color_space == JCS_GRAYSCALE)\n        source->pub.get_pixel_rows = get_scaled_gray_row;\n      else if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_gray_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_gray_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n\n  case '6':                     /* it's a raw-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS2(cinfo, 1, JTRC_PPM, w, h);\n    if (maxval > 255) {\n      source->pub.get_pixel_rows = get_word_rgb_row;\n    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n               (cinfo->in_color_space == JCS_EXT_RGB\n#if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3\n                || cinfo->in_color_space == JCS_RGB\n#endif\n               )) {\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_rgb_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n  }\n\n  if (IsExtRGB(cinfo->in_color_space))\n    cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n  else if (cinfo->in_color_space == JCS_GRAYSCALE)\n    cinfo->input_components = 1;\n  else if (cinfo->in_color_space == JCS_CMYK)\n    cinfo->input_components = 4;\n\n  /* Allocate space for I/O buffer: 1 or 3 bytes or words/pixel. */\n  if (need_iobuffer) {\n    if (c == '6')\n      source->buffer_width = (size_t)w * 3 *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    else\n      source->buffer_width = (size_t)w *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  source->buffer_width);\n  }\n\n  /* Create compressor input buffer. */\n  if (use_raw_buffer) {\n    /* For unscaled raw-input case, we can just map it onto the I/O buffer. */\n    /* Synthesize a JSAMPARRAY pointer structure */\n    source->pixrow = (JSAMPROW)source->iobuffer;\n    source->pub.buffer = &source->pixrow;\n    source->pub.buffer_height = 1;\n  } else {\n    /* Need to translate anyway, so make a separate sample buffer. */\n    source->pub.buffer = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)w * cinfo->input_components, (JDIMENSION)1);\n    source->pub.buffer_height = 1;\n  }\n\n  /* Compute the rescaling array if required. */\n  if (need_rescale) {\n    long val, half_maxval;\n\n    /* On 16-bit-int machines we have to be careful of maxval = 65535 */\n    source->rescale = (JSAMPLE *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  (size_t)(((long)maxval + 1L) *\n                                           sizeof(JSAMPLE)));\n    half_maxval = maxval / 2;\n    for (val = 0; val <= (long)maxval; val++) {\n      /* The multiplication here must be done in 32 bits to avoid overflow */\n      source->rescale[val] = (JSAMPLE)((val * MAXJSAMPLE + half_maxval) /\n                                        maxval);\n    }\n  }\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  /* no work */\n}\n\n\n/*\n * The module selection routine for PPM format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\njinit_read_ppm(j_compress_ptr cinfo)\n{\n  ppm_source_ptr source;\n\n  /* Create module interface object */\n  source = (ppm_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(ppm_source_struct));\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_ppm;\n  source->pub.finish_input = finish_input_ppm;\n\n  return (cjpeg_source_ptr)source;\n}\n\n#endif /* PPM_SUPPORTED */\n"], "fixing_code": ["2.0.5\n=====\n\n1. Worked around issues in the MIPS DSPr2 SIMD extensions that caused failures\nin the libjpeg-turbo regression tests.  Specifically, the\n`jsimd_h2v1_downsample_dspr2()` and `jsimd_h2v2_downsample_dspr2()` functions\nin the MIPS DSPr2 SIMD extensions are now disabled until/unless they can be\nfixed, and other functions that are incompatible with big endian MIPS CPUs are\ndisabled when building libjpeg-turbo for such CPUs.\n\n2. Fixed an oversight in the `TJCompressor.compress(int)` method in the\nTurboJPEG Java API that caused an error (\"java.lang.IllegalStateException: No\nsource image is associated with this instance\") when attempting to use that\nmethod to compress a YUV image.\n\n3. Fixed an issue in the PPM reader that caused a buffer overrun in cjpeg,\nTJBench, or the `tjLoadImage()` function if one of the values in a binary\nPPM/PGM input file exceeded the maximum value defined in the file's header and\nthat maximum value was less than 255.  libjpeg-turbo 1.5.0 already included a\nsimilar fix for binary PPM/PGM files with maximum values greater than 255.\n\n\n2.0.4\n=====\n\n### Significant changes relative to 2.0.3:\n\n1. Fixed a regression in the Windows packaging system (introduced by\n2.0 beta1[2]) whereby, if both the 64-bit libjpeg-turbo SDK for GCC and the\n64-bit libjpeg-turbo SDK for Visual C++ were installed on the same system, only\none of them could be uninstalled.\n\n2. Fixed a signed integer overflow and subsequent segfault that occurred when\nattempting to decompress images with more than 715827882 pixels using the\n64-bit C version of TJBench.\n\n3. Fixed out-of-bounds write in `tjDecompressToYUV2()` and\n`tjDecompressToYUVPlanes()` (sometimes manifesting as a double free) that\noccurred when attempting to decompress grayscale JPEG images that were\ncompressed with a sampling factor other than 1 (for instance, with\n`cjpeg -grayscale -sample 2x2`).\n\n4. Fixed a regression introduced by 2.0.2[5] that caused the TurboJPEG API to\nincorrectly identify some JPEG images with unusual sampling factors as 4:4:4\nJPEG images.  This was known to cause a buffer overflow when attempting to\ndecompress some such images using `tjDecompressToYUV2()` or\n`tjDecompressToYUVPlanes()`.\n\n5. Fixed an issue, detected by ASan, whereby attempting to losslessly transform\na specially-crafted malformed JPEG image containing an extremely-high-frequency\ncoefficient block (junk image data that could never be generated by a\nlegitimate JPEG compressor) could cause the Huffman encoder's local buffer to\nbe overrun. (Refer to 1.4.0[9] and 1.4beta1[15].)  Given that the buffer\noverrun was fully contained within the stack and did not cause a segfault or\nother user-visible errant behavior, and given that the lossless transformer\n(unlike the decompressor) is not generally exposed to arbitrary data exploits,\nthis issue did not likely pose a security risk.\n\n6. The ARM 64-bit (ARMv8) NEON SIMD assembly code now stores constants in a\nseparate read-only data section rather than in the text section, to support\nexecute-only memory layouts.\n\n\n2.0.3\n=====\n\n### Significant changes relative to 2.0.2:\n\n1. Fixed \"using JNI after critical get\" errors that occurred on Android\nplatforms when passing invalid arguments to certain methods in the TurboJPEG\nJava API.\n\n2. Fixed a regression in the SIMD feature detection code, introduced by\nthe AVX2 SIMD extensions (2.0 beta1[1]), that was known to cause an illegal\ninstruction exception, in rare cases, on CPUs that lack support for CPUID leaf\n07H (or on which the maximum CPUID leaf has been limited by way of a BIOS\nsetting.)\n\n3. The 4:4:0 (h1v2) fancy (smooth) chroma upsampling algorithm in the\ndecompressor now uses a similar bias pattern to that of the 4:2:2 (h2v1) fancy\nchroma upsampling algorithm, rounding up or down the upsampled result for\nalternate pixels rather than always rounding down.  This ensures that,\nregardless of whether a 4:2:2 JPEG image is rotated or transposed prior to\ndecompression (in the frequency domain) or after decompression (in the spatial\ndomain), the final image will be similar.\n\n4. Fixed an integer overflow and subsequent segfault that occurred when\nattempting to compress or decompress images with more than 1 billion pixels\nusing the TurboJPEG API.\n\n5. Fixed a regression introduced by 2.0 beta1[15] whereby attempting to\ngenerate a progressive JPEG image on an SSE2-capable CPU using a scan script\ncontaining one or more scans with lengths divisible by 16 would result in an\nerror (\"Missing Huffman code table entry\") and an invalid JPEG image.\n\n6. Fixed an issue whereby `tjDecodeYUV()` and `tjDecodeYUVPlanes()` would throw\nan error (\"Invalid progressive parameters\") or a warning (\"Inconsistent\nprogression sequence\") if passed a TurboJPEG instance that was previously used\nto decompress a progressive JPEG image.\n\n\n2.0.2\n=====\n\n### Significant changes relative to 2.0.1:\n\n1. Fixed a regression introduced by 2.0.1[5] that prevented a runtime search\npath (rpath) from being embedded in the libjpeg-turbo shared libraries and\nexecutables for macOS and iOS.  This caused a fatal error of the form\n\"dyld: Library not loaded\" when attempting to use one of the executables,\nunless `DYLD_LIBRARY_PATH` was explicitly set to the location of the\nlibjpeg-turbo shared libraries.\n\n2. Fixed an integer overflow and subsequent segfault (CVE-2018-20330) that\noccurred when attempting to load a BMP file with more than 1 billion pixels\nusing the `tjLoadImage()` function.\n\n3. Fixed a buffer overrun (CVE-2018-19664) that occurred when attempting to\ndecompress a specially-crafted malformed JPEG image to a 256-color BMP using\ndjpeg.\n\n4. Fixed a floating point exception that occurred when attempting to\ndecompress a specially-crafted malformed JPEG image with a specified image\nwidth or height of 0 using the C version of TJBench.\n\n5. The TurboJPEG API will now decompress 4:4:4 JPEG images with 2x1, 1x2, 3x1,\nor 1x3 luminance and chrominance sampling factors.  This is a non-standard way\nof specifying 1x subsampling (normally 4:4:4 JPEGs have 1x1 luminance and\nchrominance sampling factors), but the JPEG format and the libjpeg API both\nallow it.\n\n6. Fixed a regression introduced by 2.0 beta1[7] that caused djpeg to generate\nincorrect PPM images when used with the `-colors` option.\n\n7. Fixed an issue whereby a static build of libjpeg-turbo (a build in which\n`ENABLE_SHARED` is `0`) could not be installed using the Visual Studio IDE.\n\n8. Fixed a severe performance issue in the Loongson MMI SIMD extensions that\noccurred when compressing RGB images whose image rows were not 64-bit-aligned.\n\n\n2.0.1\n=====\n\n### Significant changes relative to 2.0.0:\n\n1. Fixed a regression introduced with the new CMake-based Un*x build system,\nwhereby jconfig.h could cause compiler warnings of the form\n`\"HAVE_*_H\" redefined` if it was included by downstream Autotools-based\nprojects that used `AC_CHECK_HEADERS()` to check for the existence of locale.h,\nstddef.h, or stdlib.h.\n\n2. The `jsimd_quantize_float_dspr2()` and `jsimd_convsamp_float_dspr2()`\nfunctions in the MIPS DSPr2 SIMD extensions are now disabled at compile time\nif the soft float ABI is enabled.  Those functions use instructions that are\nincompatible with the soft float ABI.\n\n3. Fixed a regression in the SIMD feature detection code, introduced by\nthe AVX2 SIMD extensions (2.0 beta1[1]), that caused libjpeg-turbo to crash on\nWindows 7 if Service Pack 1 was not installed.\n\n4. Fixed out-of-bounds read in cjpeg that occurred when attempting to compress\na specially-crafted malformed color-index (8-bit-per-sample) Targa file in\nwhich some of the samples (color indices) exceeded the bounds of the Targa\nfile's color table.\n\n5. Fixed an issue whereby installing a fully static build of libjpeg-turbo\n(a build in which `CFLAGS` contains `-static` and `ENABLE_SHARED` is `0`) would\nfail with \"No valid ELF RPATH or RUNPATH entry exists in the file.\"\n\n\n2.0.0\n=====\n\n### Significant changes relative to 2.0 beta1:\n\n1. The TurboJPEG API can now decompress CMYK JPEG images that have subsampled M\nand Y components (not to be confused with YCCK JPEG images, in which the C/M/Y\ncomponents have been transformed into luma and chroma.)   Previously, an error\nwas generated (\"Could not determine subsampling type for JPEG image\") when such\nan image was passed to `tjDecompressHeader3()`, `tjTransform()`,\n`tjDecompressToYUVPlanes()`, `tjDecompressToYUV2()`, or the equivalent Java\nmethods.\n\n2. Fixed an issue (CVE-2018-11813) whereby a specially-crafted malformed input\nfile (specifically, a file with a valid Targa header but incomplete pixel data)\nwould cause cjpeg to generate a JPEG file that was potentially thousands of\ntimes larger than the input file.  The Targa reader in cjpeg was not properly\ndetecting that the end of the input file had been reached prematurely, so after\nall valid pixels had been read from the input, the reader injected dummy pixels\nwith values of 255 into the JPEG compressor until the number of pixels\nspecified in the Targa header had been compressed.  The Targa reader in cjpeg\nnow behaves like the PPM reader and aborts compression if the end of the input\nfile is reached prematurely.  Because this issue only affected cjpeg and not\nthe underlying library, and because it did not involve any out-of-bounds reads\nor other exploitable behaviors, it was not believed to represent a security\nthreat.\n\n3. Fixed an issue whereby the `tjLoadImage()` and `tjSaveImage()` functions\nwould produce a \"Bogus message code\" error message if the underlying bitmap and\nPPM readers/writers threw an error that was specific to the readers/writers\n(as opposed to a general libjpeg API error.)\n\n4. Fixed an issue (CVE-2018-1152) whereby a specially-crafted malformed BMP\nfile, one in which the header specified an image width of 1073741824 pixels,\nwould trigger a floating point exception (division by zero) in the\n`tjLoadImage()` function when attempting to load the BMP file into a\n4-component image buffer.\n\n5. Fixed an issue whereby certain combinations of calls to\n`jpeg_skip_scanlines()` and `jpeg_read_scanlines()` could trigger an infinite\nloop when decompressing progressive JPEG images that use vertical chroma\nsubsampling (for instance, 4:2:0 or 4:4:0.)\n\n6. Fixed a segfault in `jpeg_skip_scanlines()` that occurred when decompressing\na 4:2:2 or 4:2:0 JPEG image using the merged (non-fancy) upsampling algorithms\n(that is, when setting `cinfo.do_fancy_upsampling` to `FALSE`.)\n\n7. The new CMake-based build system will now disable the MIPS DSPr2 SIMD\nextensions if it detects that the compiler does not support DSPr2 instructions.\n\n8. Fixed out-of-bounds read in cjpeg (CVE-2018-14498) that occurred when\nattempting to compress a specially-crafted malformed color-index\n(8-bit-per-sample) BMP file in which some of the samples (color indices)\nexceeded the bounds of the BMP file's color table.\n\n9. Fixed a signed integer overflow in the progressive Huffman decoder, detected\nby the Clang and GCC undefined behavior sanitizers, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\ndid not pose a security threat, but removing the warning made it easier to\ndetect actual security issues, should they arise in the future.\n\n\n1.5.90 (2.0 beta1)\n==================\n\n### Significant changes relative to 1.5.3:\n\n1. Added AVX2 SIMD implementations of the colorspace conversion, chroma\ndownsampling and upsampling, integer quantization and sample conversion, and\nslow integer DCT/IDCT algorithms.  When using the slow integer DCT/IDCT\nalgorithms on AVX2-equipped CPUs, the compression of RGB images is\napproximately 13-36% (avg. 22%) faster (relative to libjpeg-turbo 1.5.x) with\n64-bit code and 11-21% (avg. 17%) faster with 32-bit code, and the\ndecompression of RGB images is approximately 9-35% (avg. 17%) faster with\n64-bit code and 7-17% (avg. 12%) faster with 32-bit code.  (As tested on a\n3 GHz Intel Core i7.  Actual mileage may vary.)\n\n2. Overhauled the build system to use CMake on all platforms, and removed the\nautotools-based build system.  This decision resulted from extensive\ndiscussions within the libjpeg-turbo community.  libjpeg-turbo traditionally\nused CMake only for Windows builds, but there was an increasing amount of\ndemand to extend CMake support to other platforms.  However, because of the\nunique nature of our code base (the need to support different assemblers on\neach platform, the need for Java support, etc.), providing dual build systems\nas other OSS imaging libraries do (including libpng and libtiff) would have\ncreated a maintenance burden.  The use of CMake greatly simplifies some aspects\nof our build system, owing to CMake's built-in support for various assemblers,\nJava, and unit testing, as well as generally fewer quirks that have to be\nworked around in order to implement our packaging system.  Eliminating\nautotools puts our project slightly at odds with the traditional practices of\nthe OSS community, since most \"system libraries\" tend to be built with\nautotools, but it is believed that the benefits of this move outweigh the\nrisks.  In addition to providing a unified build environment, switching to\nCMake allows for the use of various build tools and IDEs that aren't supported\nunder autotools, including XCode, Ninja, and Eclipse.  It also eliminates the\nneed to install autotools via MacPorts/Homebrew on OS X and allows\nlibjpeg-turbo to be configured without the use of a terminal/command prompt.\nExtensive testing was conducted to ensure that all features provided by the\nautotools-based build system are provided by the new build system.\n\n3. The libjpeg API in this version of libjpeg-turbo now includes two additional\nfunctions, `jpeg_read_icc_profile()` and `jpeg_write_icc_profile()`, that can\nbe used to extract ICC profile data from a JPEG file while decompressing or to\nembed ICC profile data in a JPEG file while compressing or transforming.  This\neliminates the need for downstream projects, such as color management libraries\nand browsers, to include their own glueware for accomplishing this.\n\n4. Improved error handling in the TurboJPEG API library:\n\n     - Introduced a new function (`tjGetErrorStr2()`) in the TurboJPEG C API\nthat allows compression/decompression/transform error messages to be retrieved\nin a thread-safe manner.  Retrieving error messages from global functions, such\nas `tjInitCompress()` or `tjBufSize()`, is still thread-unsafe, but since those\nfunctions will only throw errors if passed an invalid argument or if a memory\nallocation failure occurs, thread safety is not as much of a concern.\n     - Introduced a new function (`tjGetErrorCode()`) in the TurboJPEG C API\nand a new method (`TJException.getErrorCode()`) in the TurboJPEG Java API that\ncan be used to determine the severity of the last\ncompression/decompression/transform error.  This allows applications to\nchoose whether to ignore warnings (non-fatal errors) from the underlying\nlibjpeg API or to treat them as fatal.\n     - Introduced a new flag (`TJFLAG_STOPONWARNING` in the TurboJPEG C API and\n`TJ.FLAG_STOPONWARNING` in the TurboJPEG Java API) that causes the library to\nimmediately halt a compression/decompression/transform operation if it\nencounters a warning from the underlying libjpeg API (the default behavior is\nto allow the operation to complete unless a fatal error is encountered.)\n\n5. Introduced a new flag in the TurboJPEG C and Java APIs (`TJFLAG_PROGRESSIVE`\nand `TJ.FLAG_PROGRESSIVE`, respectively) that causes the library to use\nprogressive entropy coding in JPEG images generated by compression and\ntransform operations.  Additionally, a new transform option\n(`TJXOPT_PROGRESSIVE` in the C API and `TJTransform.OPT_PROGRESSIVE` in the\nJava API) has been introduced, allowing progressive entropy coding to be\nenabled for selected transforms in a multi-transform operation.\n\n6. Introduced a new transform option in the TurboJPEG API (`TJXOPT_COPYNONE` in\nthe C API and `TJTransform.OPT_COPYNONE` in the Java API) that allows the\ncopying of markers (including EXIF and ICC profile data) to be disabled for a\nparticular transform.\n\n7. Added two functions to the TurboJPEG C API (`tjLoadImage()` and\n`tjSaveImage()`) that can be used to load/save a BMP or PPM/PGM image to/from a\nmemory buffer with a specified pixel format and layout.  These functions\nreplace the project-private (and slow) bmp API, which was previously used by\nTJBench, and they also provide a convenient way for first-time users of\nlibjpeg-turbo to quickly develop a complete JPEG compression/decompression\nprogram.\n\n8. The TurboJPEG C API now includes a new convenience array (`tjAlphaOffset[]`)\nthat contains the alpha component index for each pixel format (or -1 if the\npixel format lacks an alpha component.)  The TurboJPEG Java API now includes a\nnew method (`TJ.getAlphaOffset()`) that returns the same value.  In addition,\nthe `tjRedOffset[]`, `tjGreenOffset[]`, and `tjBlueOffset[]` arrays-- and the\ncorresponding `TJ.getRedOffset()`, `TJ.getGreenOffset()`, and\n`TJ.getBlueOffset()` methods-- now return -1 for `TJPF_GRAY`/`TJ.PF_GRAY`\nrather than 0.  This allows programs to easily determine whether a pixel format\nhas red, green, blue, and alpha components.\n\n9. Added a new example (tjexample.c) that demonstrates the basic usage of the\nTurboJPEG C API.  This example mirrors the functionality of TJExample.java.\nBoth files are now included in the libjpeg-turbo documentation.\n\n10. Fixed two signed integer overflows in the arithmetic decoder, detected by\nthe Clang undefined behavior sanitizer, that could be triggered by attempting\nto decompress a specially-crafted malformed JPEG image.  These issues did not\npose a security threat, but removing the warnings makes it easier to detect\nactual security issues, should they arise in the future.\n\n11. Fixed a bug in the merged 4:2:0 upsampling/dithered RGB565 color conversion\nalgorithm that caused incorrect dithering in the output image.  This algorithm\nnow produces bitwise-identical results to the unmerged algorithms.\n\n12. The SIMD function symbols for x86[-64]/ELF, MIPS/ELF, macOS/x86[-64] (if\nlibjpeg-turbo is built with YASM), and iOS/ARM[64] builds are now private.\nThis prevents those symbols from being exposed in applications or shared\nlibraries that link statically with libjpeg-turbo.\n\n13. Added Loongson MMI SIMD implementations of the RGB-to-YCbCr and\nYCbCr-to-RGB colorspace conversion, 4:2:0 chroma downsampling, 4:2:0 fancy\nchroma upsampling, integer quantization, and slow integer DCT/IDCT algorithms.\nWhen using the slow integer DCT/IDCT, this speeds up the compression of RGB\nimages by approximately 70-100% and the decompression of RGB images by\napproximately 2-3.5x.\n\n14. Fixed a build error when building with older MinGW releases (regression\ncaused by 1.5.1[7].)\n\n15. Added SIMD acceleration for progressive Huffman encoding on SSE2-capable\nx86 and x86-64 platforms.  This speeds up the compression of full-color\nprogressive JPEGs by about 85-90% on average (relative to libjpeg-turbo 1.5.x)\nwhen using modern Intel and AMD CPUs.\n\n\n1.5.3\n=====\n\n### Significant changes relative to 1.5.2:\n\n1. Fixed a NullPointerException in the TurboJPEG Java wrapper that occurred\nwhen using the YUVImage constructor that creates an instance backed by separate\nimage planes and allocates memory for the image planes.\n\n2. Fixed an issue whereby the Java version of TJUnitTest would fail when\ntesting BufferedImage encoding/decoding on big endian systems.\n\n3. Fixed a segfault in djpeg that would occur if an output format other than\nPPM/PGM was selected along with the `-crop` option.  The `-crop` option now\nworks with the GIF and Targa formats as well (unfortunately, it cannot be made\nto work with the BMP and RLE formats due to the fact that those output engines\nwrite scanlines in bottom-up order.)  djpeg will now exit gracefully if an\noutput format other than PPM/PGM, GIF, or Targa is selected along with the\n`-crop` option.\n\n4. Fixed an issue (CVE-2017-15232) whereby `jpeg_skip_scanlines()` would\nsegfault if color quantization was enabled.\n\n5. TJBench (both C and Java versions) will now display usage information if any\ncommand-line argument is unrecognized.  This prevents the program from silently\nignoring typos.\n\n6. Fixed an access violation in tjbench.exe (Windows) that occurred when the\nprogram was used to decompress an existing JPEG image.\n\n7. Fixed an ArrayIndexOutOfBoundsException in the TJExample Java program that\noccurred when attempting to decompress a JPEG image that had been compressed\nwith 4:1:1 chrominance subsampling.\n\n8. Fixed an issue whereby, when using `jpeg_skip_scanlines()` to skip to the\nend of a single-scan (non-progressive) image, subsequent calls to\n`jpeg_consume_input()` would return `JPEG_SUSPENDED` rather than\n`JPEG_REACHED_EOI`.\n\n9. `jpeg_crop_scanlines()` now works correctly when decompressing grayscale\nJPEG images that were compressed with a sampling factor other than 1 (for\ninstance, with `cjpeg -grayscale -sample 2x2`).\n\n\n1.5.2\n=====\n\n### Significant changes relative to 1.5.1:\n\n1. Fixed a regression introduced by 1.5.1[7] that prevented libjpeg-turbo from\nbuilding with Android NDK platforms prior to android-21 (5.0).\n\n2. Fixed a regression introduced by 1.5.1[1] that prevented the MIPS DSPR2 SIMD\ncode in libjpeg-turbo from building.\n\n3. Fixed a regression introduced by 1.5 beta1[11] that prevented the Java\nversion of TJBench from outputting any reference images (the `-nowrite` switch\nwas accidentally enabled by default.)\n\n4. libjpeg-turbo should now build and run with full AltiVec SIMD acceleration\non PowerPC-based AmigaOS 4 and OpenBSD systems.\n\n5. Fixed build and runtime errors on Windows that occurred when building\nlibjpeg-turbo with libjpeg v7 API/ABI emulation and the in-memory\nsource/destination managers.  Due to an oversight, the `jpeg_skip_scanlines()`\nand `jpeg_crop_scanlines()` functions were not being included in jpeg7.dll when\nlibjpeg-turbo was built with `-DWITH_JPEG7=1` and `-DWITH_MEMSRCDST=1`.\n\n6. Fixed \"Bogus virtual array access\" error that occurred when using the\nlossless crop feature in jpegtran or the TurboJPEG API, if libjpeg-turbo was\nbuilt with libjpeg v7 API/ABI emulation.  This was apparently a long-standing\nbug that has existed since the introduction of libjpeg v7/v8 API/ABI emulation\nin libjpeg-turbo v1.1.\n\n7. The lossless transform features in jpegtran and the TurboJPEG API will now\nalways attempt to adjust the EXIF image width and height tags if the image size\nchanged as a result of the transform.  This behavior has always existed when\nusing libjpeg v8 API/ABI emulation.  It was supposed to be available with\nlibjpeg v7 API/ABI emulation as well but did not work properly due to a bug.\nFurthermore, there was never any good reason not to enable it with libjpeg v6b\nAPI/ABI emulation, since the behavior is entirely internal.  Note that\n`-copy all` must be passed to jpegtran in order to transfer the EXIF tags from\nthe source image to the destination image.\n\n8. Fixed several memory leaks in the TurboJPEG API library that could occur\nif the library was built with certain compilers and optimization levels\n(known to occur with GCC 4.x and clang with `-O1` and higher but not with\nGCC 5.x or 6.x) and one of the underlying libjpeg API functions threw an error\nafter a TurboJPEG API function allocated a local buffer.\n\n9. The libjpeg-turbo memory manager will now honor the `max_memory_to_use`\nstructure member in jpeg\\_memory\\_mgr, which can be set to the maximum amount\nof memory (in bytes) that libjpeg-turbo should use during decompression or\nmulti-pass (including progressive) compression.  This limit can also be set\nusing the `JPEGMEM` environment variable or using the `-maxmemory` switch in\ncjpeg/djpeg/jpegtran (refer to the respective man pages for more details.)\nThis has been a documented feature of libjpeg since v5, but the\n`malloc()`/`free()` implementation of the memory manager (jmemnobs.c) never\nimplemented the feature.  Restricting libjpeg-turbo's memory usage is useful\nfor two reasons:  it allows testers to more easily work around the 2 GB limit\nin libFuzzer, and it allows developers of security-sensitive applications to\nmore easily defend against one of the progressive JPEG exploits (LJT-01-004)\nidentified in\n[this report](http://www.libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n10. TJBench will now run each benchmark for 1 second prior to starting the\ntimer, in order to improve the consistency of the results.  Furthermore, the\n`-warmup` option is now used to specify the amount of warmup time rather than\nthe number of warmup iterations.\n\n11. Fixed an error (`short jump is out of range`) that occurred when assembling\nthe 32-bit x86 SIMD extensions with NASM versions prior to 2.04.  This was a\nregression introduced by 1.5 beta1[12].\n\n\n1.5.1\n=====\n\n### Significant changes relative to 1.5.0:\n\n1. Previously, the undocumented `JSIMD_FORCE*` environment variables could be\nused to force-enable a particular SIMD instruction set if multiple instruction\nsets were available on a particular platform.  On x86 platforms, where CPU\nfeature detection is bulletproof and multiple SIMD instruction sets are\navailable, it makes sense for those environment variables to allow forcing the\nuse of an instruction set only if that instruction set is available.  However,\nsince the ARM implementations of libjpeg-turbo can only use one SIMD\ninstruction set, and since their feature detection code is less bulletproof\n(parsing /proc/cpuinfo), it makes sense for the `JSIMD_FORCENEON` environment\nvariable to bypass the feature detection code and really force the use of NEON\ninstructions.  A new environment variable (`JSIMD_FORCEDSPR2`) was introduced\nin the MIPS implementation for the same reasons, and the existing\n`JSIMD_FORCENONE` environment variable was extended to that implementation.\nThese environment variables provide a workaround for those attempting to test\nARM and MIPS builds of libjpeg-turbo in QEMU, which passes through\n/proc/cpuinfo from the host system.\n\n2. libjpeg-turbo previously assumed that AltiVec instructions were always\navailable on PowerPC platforms, which led to \"illegal instruction\" errors when\nrunning on PowerPC chips that lack AltiVec support (such as the older 7xx/G3\nand newer e5500 series.)  libjpeg-turbo now examines /proc/cpuinfo on\nLinux/Android systems and enables AltiVec instructions only if the CPU supports\nthem.  It also now provides two environment variables, `JSIMD_FORCEALTIVEC` and\n`JSIMD_FORCENONE`, to force-enable and force-disable AltiVec instructions in\nenvironments where /proc/cpuinfo is an unreliable means of CPU feature\ndetection (such as when running in QEMU.)  On OS X, libjpeg-turbo continues to\nassume that AltiVec support is always available, which means that libjpeg-turbo\ncannot be used with G3 Macs unless you set the environment variable\n`JSIMD_FORCENONE` to `1`.\n\n3. Fixed an issue whereby 64-bit ARM (AArch64) builds of libjpeg-turbo would\ncrash when built with recent releases of the Clang/LLVM compiler.  This was\ncaused by an ABI conformance issue in some of libjpeg-turbo's 64-bit NEON SIMD\nroutines.  Those routines were incorrectly using 64-bit instructions to\ntransfer a 32-bit JDIMENSION argument, whereas the ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fancy upsampling is now supported when decompressing JPEG images that use\n4:4:0 (h1v2) chroma subsampling.  These images are generated when losslessly\nrotating or transposing JPEG images that use 4:2:2 (h2v1) chroma subsampling.\nThe h1v2 fancy upsampling algorithm is not currently SIMD-accelerated.\n\n5. If merged upsampling isn't SIMD-accelerated but YCbCr-to-RGB conversion is,\nthen libjpeg-turbo will now disable merged upsampling when decompressing YCbCr\nJPEG images into RGB or extended RGB output images.  This significantly speeds\nup the decompression of 4:2:0 and 4:2:2 JPEGs on ARM platforms if fancy\nupsampling is not used (for example, if the `-nosmooth` option to djpeg is\nspecified.)\n\n6. The TurboJPEG API will now decompress 4:2:2 and 4:4:0 JPEG images with\n2x2 luminance sampling factors and 2x1 or 1x2 chrominance sampling factors.\nThis is a non-standard way of specifying 2x subsampling (normally 4:2:2 JPEGs\nhave 2x1 luminance and 1x1 chrominance sampling factors, and 4:4:0 JPEGs have\n1x2 luminance and 1x1 chrominance sampling factors), but the JPEG format and\nthe libjpeg API both allow it.\n\n7. Fixed an unsigned integer overflow in the libjpeg memory manager, detected\nby the Clang undefined behavior sanitizer, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\naffected only 32-bit code and did not pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n8. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers when attempting to decompress\nspecially-crafted malformed JPEG images.  None of these issues posed a security\nthreat, but removing the warnings makes it easier to detect actual security\nissues, should they arise in the future.\n\n9. Fixed an out-of-bounds array reference, introduced by 1.4.90[2] (partial\nimage decompression) and detected by the Clang undefined behavior sanitizer,\nthat could be triggered by a specially-crafted malformed JPEG image with more\nthan four components.  Because the out-of-bounds reference was still within the\nsame structure, it was not known to pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n10. Fixed another ABI conformance issue in the 64-bit ARM (AArch64) NEON SIMD\ncode.  Some of the routines were incorrectly reading and storing data below the\nstack pointer, which caused segfaults in certain applications under specific\ncircumstances.\n\n\n1.5.0\n=====\n\n### Significant changes relative to 1.5 beta1:\n\n1. Fixed an issue whereby a malformed motion-JPEG frame could cause the \"fast\npath\" of libjpeg-turbo's Huffman decoder to read from uninitialized memory.\n\n2. Added libjpeg-turbo version and build information to the global string table\nof the libjpeg and TurboJPEG API libraries.  This is a common practice in other\ninfrastructure libraries, such as OpenSSL and libpng, because it makes it easy\nto examine an application binary and determine which version of the library the\napplication was linked against.\n\n3. Fixed a couple of issues in the PPM reader that would cause buffer overruns\nin cjpeg if one of the values in a binary PPM/PGM input file exceeded the\nmaximum value defined in the file's header and that maximum value was greater\nthan 255.  libjpeg-turbo 1.4.2 already included a similar fix for ASCII PPM/PGM\nfiles.  Note that these issues were not security bugs, since they were confined\nto the cjpeg program and did not affect any of the libjpeg-turbo libraries.\n\n4. Fixed an issue whereby attempting to decompress a JPEG file with a corrupt\nheader using the `tjDecompressToYUV2()` function would cause the function to\nabort without returning an error and, under certain circumstances, corrupt the\nstack.  This only occurred if `tjDecompressToYUV2()` was called prior to\ncalling `tjDecompressHeader3()`, or if the return value from\n`tjDecompressHeader3()` was ignored (both cases represent incorrect usage of\nthe TurboJPEG API.)\n\n5. Fixed an issue in the ARM 32-bit SIMD-accelerated Huffman encoder that\nprevented the code from assembling properly with clang.\n\n6. The `jpeg_stdio_src()`, `jpeg_mem_src()`, `jpeg_stdio_dest()`, and\n`jpeg_mem_dest()` functions in the libjpeg API will now throw an error if a\nsource/destination manager has already been assigned to the compress or\ndecompress object by a different function or by the calling program.  This\nprevents these functions from attempting to reuse a source/destination manager\nstructure that was allocated elsewhere, because there is no way to ensure that\nit would be big enough to accommodate the new source/destination manager.\n\n\n1.4.90 (1.5 beta1)\n==================\n\n### Significant changes relative to 1.4.2:\n\n1. Added full SIMD acceleration for PowerPC platforms using AltiVec VMX\n(128-bit SIMD) instructions.  Although the performance of libjpeg-turbo on\nPowerPC was already good, due to the increased number of registers available\nto the compiler vs. x86, it was still possible to speed up compression by about\n3-4x and decompression by about 2-2.5x (relative to libjpeg v6b) through the\nuse of AltiVec instructions.\n\n2. Added two new libjpeg API functions (`jpeg_skip_scanlines()` and\n`jpeg_crop_scanline()`) that can be used to partially decode a JPEG image.  See\n[libjpeg.txt](libjpeg.txt) for more details.\n\n3. The TJCompressor and TJDecompressor classes in the TurboJPEG Java API now\nimplement the Closeable interface, so those classes can be used with a\ntry-with-resources statement.\n\n4. The TurboJPEG Java classes now throw unchecked idiomatic exceptions\n(IllegalArgumentException, IllegalStateException) for unrecoverable errors\ncaused by incorrect API usage, and those classes throw a new checked exception\ntype (TJException) for errors that are passed through from the C library.\n\n5. Source buffers for the TurboJPEG C API functions, as well as the\n`jpeg_mem_src()` function in the libjpeg API, are now declared as const\npointers.  This facilitates passing read-only buffers to those functions and\nensures the caller that the source buffer will not be modified.  This should\nnot create any backward API or ABI incompatibilities with prior libjpeg-turbo\nreleases.\n\n6. The MIPS DSPr2 SIMD code can now be compiled to support either FR=0 or FR=1\nFPUs.\n\n7. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers.  Most of these issues affected only\n32-bit code, and none of them was known to pose a security threat, but removing\nthe warnings makes it easier to detect actual security issues, should they\narise in the future.\n\n8. Removed the unnecessary `.arch` directive from the ARM64 NEON SIMD code.\nThis directive was preventing the code from assembling using the clang\nintegrated assembler.\n\n9. Fixed a regression caused by 1.4.1[6] that prevented 32-bit and 64-bit\nlibjpeg-turbo RPMs from being installed simultaneously on recent Red Hat/Fedora\ndistributions.  This was due to the addition of a macro in jconfig.h that\nallows the Huffman codec to determine the word size at compile time.  Since\nthat macro differs between 32-bit and 64-bit builds, this caused a conflict\nbetween the i386 and x86_64 RPMs (any differing files, other than executables,\nare not allowed when 32-bit and 64-bit RPMs are installed simultaneously.)\nSince the macro is used only internally, it has been moved into jconfigint.h.\n\n10. The x86-64 SIMD code can now be disabled at run time by setting the\n`JSIMD_FORCENONE` environment variable to `1` (the other SIMD implementations\nalready had this capability.)\n\n11. Added a new command-line argument to TJBench (`-nowrite`) that prevents the\nbenchmark from outputting any images.  This removes any potential operating\nsystem overhead that might be caused by lazy writes to disk and thus improves\nthe consistency of the performance measurements.\n\n12. Added SIMD acceleration for Huffman encoding on SSE2-capable x86 and x86-64\nplatforms.  This speeds up the compression of full-color JPEGs by about 10-15%\non average (relative to libjpeg-turbo 1.4.x) when using modern Intel and AMD\nCPUs.  Additionally, this works around an issue in the clang optimizer that\nprevents it (as of this writing) from achieving the same performance as GCC\nwhen compiling the C version of the Huffman encoder\n(<https://llvm.org/bugs/show_bug.cgi?id=16035>).  For the purposes of\nbenchmarking or regression testing, SIMD-accelerated Huffman encoding can be\ndisabled by setting the `JSIMD_NOHUFFENC` environment variable to `1`.\n\n13. Added ARM 64-bit (ARMv8) NEON SIMD implementations of the commonly-used\ncompression algorithms (including the slow integer forward DCT and h2v2 & h2v1\ndownsampling algorithms, which are not accelerated in the 32-bit NEON\nimplementation.)  This speeds up the compression of full-color JPEGs by about\n75% on average on a Cavium ThunderX processor and by about 2-2.5x on average on\nCortex-A53 and Cortex-A57 cores.\n\n14. Added SIMD acceleration for Huffman encoding on NEON-capable ARM 32-bit\nand 64-bit platforms.\n\n    For 32-bit code, this speeds up the compression of full-color JPEGs by\nabout 30% on average on a typical iOS device (iPhone 4S, Cortex-A9) and by\nabout 6-7% on average on a typical Android device (Nexus 5X, Cortex-A53 and\nCortex-A57), relative to libjpeg-turbo 1.4.x.  Note that the larger speedup\nunder iOS is due to the fact that iOS builds use LLVM, which does not optimize\nthe C Huffman encoder as well as GCC does.\n\n    For 64-bit code, NEON-accelerated Huffman encoding speeds up the\ncompression of full-color JPEGs by about 40% on average on a typical iOS device\n(iPhone 5S, Apple A7) and by about 7-8% on average on a typical Android device\n(Nexus 5X, Cortex-A53 and Cortex-A57), in addition to the speedup described in\n[13] above.\n\n    For the purposes of benchmarking or regression testing, SIMD-accelerated\nHuffman encoding can be disabled by setting the `JSIMD_NOHUFFENC` environment\nvariable to `1`.\n\n15. pkg-config (.pc) scripts are now included for both the libjpeg and\nTurboJPEG API libraries on Un*x systems.  Note that if a project's build system\nrelies on these scripts, then it will not be possible to build that project\nwith libjpeg or with a prior version of libjpeg-turbo.\n\n16. Optimized the ARM 64-bit (ARMv8) NEON SIMD decompression routines to\nimprove performance on CPUs with in-order pipelines.  This speeds up the\ndecompression of full-color JPEGs by nearly 2x on average on a Cavium ThunderX\nprocessor and by about 15% on average on a Cortex-A53 core.\n\n17. Fixed an issue in the accelerated Huffman decoder that could have caused\nthe decoder to read past the end of the input buffer when a malformed,\nspecially-crafted JPEG image was being decompressed.  In prior versions of\nlibjpeg-turbo, the accelerated Huffman decoder was invoked (in most cases) only\nif there were > 128 bytes of data in the input buffer.  However, it is possible\nto construct a JPEG image in which a single Huffman block is over 430 bytes\nlong, so this version of libjpeg-turbo activates the accelerated Huffman\ndecoder only if there are > 512 bytes of data in the input buffer.\n\n18. Fixed a memory leak in tjunittest encountered when running the program\nwith the `-yuv` option.\n\n\n1.4.2\n=====\n\n### Significant changes relative to 1.4.1:\n\n1. Fixed an issue whereby cjpeg would segfault if a Windows bitmap with a\nnegative width or height was used as an input image (Windows bitmaps can have\na negative height if they are stored in top-down order, but such files are\nrare and not supported by libjpeg-turbo.)\n\n2. Fixed an issue whereby, under certain circumstances, libjpeg-turbo would\nincorrectly encode certain JPEG images when quality=100 and the fast integer\nforward DCT were used.  This was known to cause `make test` to fail when the\nlibrary was built with `-march=haswell` on x86 systems.\n\n3. Fixed an issue whereby libjpeg-turbo would crash when built with the latest\n& greatest development version of the Clang/LLVM compiler.  This was caused by\nan x86-64 ABI conformance issue in some of libjpeg-turbo's 64-bit SSE2 SIMD\nroutines.  Those routines were incorrectly using a 64-bit `mov` instruction to\ntransfer a 32-bit JDIMENSION argument, whereas the x86-64 ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fixed a bug in the MIPS DSPr2 4:2:0 \"plain\" (non-fancy and non-merged)\nupsampling routine that caused a buffer overflow (and subsequent segfault) when\ndecompressing a 4:2:0 JPEG image whose scaled output width was less than 16\npixels.  The \"plain\" upsampling routines are normally only used when\ndecompressing a non-YCbCr JPEG image, but they are also used when decompressing\na JPEG image whose scaled output height is 1.\n\n5. Fixed various negative left shifts and other issues reported by the GCC and\nClang undefined behavior sanitizers.  None of these was known to pose a\nsecurity threat, but removing the warnings makes it easier to detect actual\nsecurity issues, should they arise in the future.\n\n\n1.4.1\n=====\n\n### Significant changes relative to 1.4.0:\n\n1. tjbench now properly handles CMYK/YCCK JPEG files.  Passing an argument of\n`-cmyk` (instead of, for instance, `-rgb`) will cause tjbench to internally\nconvert the source bitmap to CMYK prior to compression, to generate YCCK JPEG\nfiles, and to internally convert the decompressed CMYK pixels back to RGB after\ndecompression (the latter is done automatically if a CMYK or YCCK JPEG is\npassed to tjbench as a source image.)  The CMYK<->RGB conversion operation is\nnot benchmarked.  NOTE: The quick & dirty CMYK<->RGB conversions that tjbench\nuses are suitable for testing only.  Proper conversion between CMYK and RGB\nrequires a color management system.\n\n2. `make test` now performs additional bitwise regression tests using tjbench,\nmainly for the purpose of testing compression from/decompression to a subregion\nof a larger image buffer.\n\n3. `make test` no longer tests the regression of the floating point DCT/IDCT\nby default, since the results of those tests can vary if the algorithms in\nquestion are not implemented using SIMD instructions on a particular platform.\nSee the comments in [Makefile.am](Makefile.am) for information on how to\nre-enable the tests and to specify an expected result for them based on the\nparticulars of your platform.\n\n4. The NULL color conversion routines have been significantly optimized,\nwhich speeds up the compression of RGB and CMYK JPEGs by 5-20% when using\n64-bit code and 0-3% when using 32-bit code, and the decompression of those\nimages by 10-30% when using 64-bit code and 3-12% when using 32-bit code.\n\n5. Fixed an \"illegal instruction\" error that occurred when djpeg from a\nSIMD-enabled libjpeg-turbo MIPS build was executed with the `-nosmooth` option\non a MIPS machine that lacked DSPr2 support.  The MIPS SIMD routines for h2v1\nand h2v2 merged upsampling were not properly checking for the existence of\nDSPr2.\n\n6. Performance has been improved significantly on 64-bit non-Linux and\nnon-Windows platforms (generally 10-20% faster compression and 5-10% faster\ndecompression.)  Due to an oversight, the 64-bit version of the accelerated\nHuffman codec was not being compiled in when libjpeg-turbo was built on\nplatforms other than Windows or Linux.  Oops.\n\n7. Fixed an extremely rare bug in the Huffman encoder that caused 64-bit\nbuilds of libjpeg-turbo to incorrectly encode a few specific test images when\nquality=98, an optimized Huffman table, and the slow integer forward DCT were\nused.\n\n8. The Windows (CMake) build system now supports building only static or only\nshared libraries.  This is accomplished by adding either `-DENABLE_STATIC=0` or\n`-DENABLE_SHARED=0` to the CMake command line.\n\n9. TurboJPEG API functions will now return an error code if a warning is\ntriggered in the underlying libjpeg API.  For instance, if a JPEG file is\ncorrupt, the TurboJPEG decompression functions will attempt to decompress\nas much of the image as possible, but those functions will now return -1 to\nindicate that the decompression was not entirely successful.\n\n10. Fixed a bug in the MIPS DSPr2 4:2:2 fancy upsampling routine that caused a\nbuffer overflow (and subsequent segfault) when decompressing a 4:2:2 JPEG image\nin which the right-most MCU was 5 or 6 pixels wide.\n\n\n1.4.0\n=====\n\n### Significant changes relative to 1.4 beta1:\n\n1. Fixed a build issue on OS X PowerPC platforms (md5cmp failed to build\nbecause OS X does not provide the `le32toh()` and `htole32()` functions.)\n\n2. The non-SIMD RGB565 color conversion code did not work correctly on big\nendian machines.  This has been fixed.\n\n3. Fixed an issue in `tjPlaneSizeYUV()` whereby it would erroneously return 1\ninstead of -1 if `componentID` was > 0 and `subsamp` was `TJSAMP_GRAY`.\n\n3. Fixed an issue in `tjBufSizeYUV2()` whereby it would erroneously return 0\ninstead of -1 if `width` was < 1.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM64 platforms (see 1.4 beta1[5].)\n\n6. The `close()` method in the TJCompressor and TJDecompressor Java classes is\nnow idempotent.  Previously, that method would call the native `tjDestroy()`\nfunction even if the TurboJPEG instance had already been destroyed.  This\ncaused an exception to be thrown during finalization, if the `close()` method\nhad already been called.  The exception was caught, but it was still an\nexpensive operation.\n\n7. The TurboJPEG API previously generated an error (`Could not determine\nsubsampling type for JPEG image`) when attempting to decompress grayscale JPEG\nimages that were compressed with a sampling factor other than 1 (for instance,\nwith `cjpeg -grayscale -sample 2x2`).  Subsampling technically has no meaning\nwith grayscale JPEGs, and thus the horizontal and vertical sampling factors\nfor such images are ignored by the decompressor.  However, the TurboJPEG API\nwas being too rigid and was expecting the sampling factors to be equal to 1\nbefore it treated the image as a grayscale JPEG.\n\n8. cjpeg, djpeg, and jpegtran now accept an argument of `-version`, which will\nprint the library version and exit.\n\n9. Referring to 1.4 beta1[15], another extremely rare circumstance was\ndiscovered under which the Huffman encoder's local buffer can be overrun\nwhen a buffered destination manager is being used and an\nextremely-high-frequency block (basically junk image data) is being encoded.\nEven though the Huffman local buffer was increased from 128 bytes to 136 bytes\nto address the previous issue, the new issue caused even the larger buffer to\nbe overrun.  Further analysis reveals that, in the absolute worst case (such as\nsetting alternating AC coefficients to 32767 and -32768 in the JPEG scanning\norder), the Huffman encoder can produce encoded blocks that approach double the\nsize of the unencoded blocks.  Thus, the Huffman local buffer was increased to\n256 bytes, which should prevent any such issue from re-occurring in the future.\n\n10. The new `tjPlaneSizeYUV()`, `tjPlaneWidth()`, and `tjPlaneHeight()`\nfunctions were not actually usable on any platform except OS X and Windows,\nbecause those functions were not included in the libturbojpeg mapfile.  This\nhas been fixed.\n\n11. Restored the `JPP()`, `JMETHOD()`, and `FAR` macros in the libjpeg-turbo\nheader files.  The `JPP()` and `JMETHOD()` macros were originally implemented\nin libjpeg as a way of supporting non-ANSI compilers that lacked support for\nprototype parameters.  libjpeg-turbo has never supported such compilers, but\nsome software packages still use the macros to define their own prototypes.\nSimilarly, libjpeg-turbo has never supported MS-DOS and other platforms that\nhave far symbols, but some software packages still use the `FAR` macro.  A\npretty good argument can be made that this is a bad practice on the part of the\nsoftware in question, but since this affects more than one package, it's just\neasier to fix it here.\n\n12. Fixed issues that were preventing the ARM 64-bit SIMD code from compiling\nfor iOS, and included an ARMv8 architecture in all of the binaries installed by\nthe \"official\" libjpeg-turbo SDK for OS X.\n\n\n1.3.90 (1.4 beta1)\n==================\n\n### Significant changes relative to 1.3.1:\n\n1. New features in the TurboJPEG API:\n\n     - YUV planar images can now be generated with an arbitrary line padding\n(previously only 4-byte padding, which was compatible with X Video, was\nsupported.)\n     - The decompress-to-YUV function has been extended to support image\nscaling.\n     - JPEG images can now be compressed from YUV planar source images.\n     - YUV planar images can now be decoded into RGB or grayscale images.\n     - 4:1:1 subsampling is now supported.  This is mainly included for\ncompatibility, since 4:1:1 is not fully accelerated in libjpeg-turbo and has no\nsignificant advantages relative to 4:2:0.\n     - CMYK images are now supported.  This feature allows CMYK source images\nto be compressed to YCCK JPEGs and YCCK or CMYK JPEGs to be decompressed to\nCMYK destination images.  Conversion between CMYK/YCCK and RGB or YUV images is\nnot supported.  Such conversion requires a color management system and is thus\nout of scope for a codec library.\n     - The handling of YUV images in the Java API has been significantly\nrefactored and should now be much more intuitive.\n     - The Java API now supports encoding a YUV image from an arbitrary\nposition in a large image buffer.\n     - All of the YUV functions now have a corresponding function that operates\non separate image planes instead of a unified image buffer.  This allows for\ncompressing/decoding from or decompressing/encoding to a subregion of a larger\nYUV image.  It also allows for handling YUV formats that swap the order of the\nU and V planes.\n\n2. Added SIMD acceleration for DSPr2-capable MIPS platforms.  This speeds up\nthe compression of full-color JPEGs by 70-80% on such platforms and\ndecompression by 25-35%.\n\n3. If an application attempts to decompress a Huffman-coded JPEG image whose\nheader does not contain Huffman tables, libjpeg-turbo will now insert the\ndefault Huffman tables.  In order to save space, many motion JPEG video frames\nare encoded without the default Huffman tables, so these frames can now be\nsuccessfully decompressed by libjpeg-turbo without additional work on the part\nof the application.  An application can still override the Huffman tables, for\ninstance to re-use tables from a previous frame of the same video.\n\n4. The Mac packaging system now uses pkgbuild and productbuild rather than\nPackageMaker (which is obsolete and no longer supported.)  This means that\nOS X 10.6 \"Snow Leopard\" or later must be used when packaging libjpeg-turbo,\nalthough the packages produced can be installed on OS X 10.5 \"Leopard\" or\nlater.  OS X 10.4 \"Tiger\" is no longer supported.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM platforms rather than a lookup table.  This reduces the memory footprint\nby 64k, which may be important for some mobile applications.  Out of four\nAndroid devices that were tested, two demonstrated a small overall performance\nloss (~3-4% on average) with ARMv6 code and a small gain (also ~3-4%) with\nARMv7 code when enabling this new feature, but the other two devices\ndemonstrated a significant overall performance gain with both ARMv6 and ARMv7\ncode (~10-20%) when enabling the feature.  Actual mileage may vary.\n\n6. Worked around an issue with Visual C++ 2010 and later that caused incorrect\npixels to be generated when decompressing a JPEG image to a 256-color bitmap,\nif compiler optimization was enabled when libjpeg-turbo was built.  This caused\nthe regression tests to fail when doing a release build under Visual C++ 2010\nand later.\n\n7. Improved the accuracy and performance of the non-SIMD implementation of the\nfloating point inverse DCT (using code borrowed from libjpeg v8a and later.)\nThe accuracy of this implementation now matches the accuracy of the SSE/SSE2\nimplementation.  Note, however, that the floating point DCT/IDCT algorithms are\nmainly a legacy feature.  They generally do not produce significantly better\naccuracy than the slow integer DCT/IDCT algorithms, and they are quite a bit\nslower.\n\n8. Added a new output colorspace (`JCS_RGB565`) to the libjpeg API that allows\nfor decompressing JPEG images into RGB565 (16-bit) pixels.  If dithering is not\nused, then this code path is SIMD-accelerated on ARM platforms.\n\n9. Numerous obsolete features, such as support for non-ANSI compilers and\nsupport for the MS-DOS memory model, were removed from the libjpeg code,\ngreatly improving its readability and making it easier to maintain and extend.\n\n10. Fixed a segfault that occurred when calling `output_message()` with\n`msg_code` set to `JMSG_COPYRIGHT`.\n\n11. Fixed an issue whereby wrjpgcom was allowing comments longer than 65k\ncharacters to be passed on the command line, which was causing it to generate\nincorrect JPEG files.\n\n12. Fixed a bug in the build system that was causing the Windows version of\nwrjpgcom to be built using the rdjpgcom source code.\n\n13. Restored 12-bit-per-component JPEG support.  A 12-bit version of\nlibjpeg-turbo can now be built by passing an argument of `--with-12bit` to\nconfigure (Unix) or `-DWITH_12BIT=1` to cmake (Windows.)  12-bit JPEG support\nis included only for convenience.  Enabling this feature disables all of the\nperformance features in libjpeg-turbo, as well as arithmetic coding and the\nTurboJPEG API.  The resulting library still contains the other libjpeg-turbo\nfeatures (such as the colorspace extensions), but in general, it performs no\nfaster than libjpeg v6b.\n\n14. Added ARM 64-bit SIMD acceleration for the YCC-to-RGB color conversion\nand IDCT algorithms (both are used during JPEG decompression.)  For unknown\nreasons (probably related to clang), this code cannot currently be compiled for\niOS.\n\n15. Fixed an extremely rare bug (CVE-2014-9092) that could cause the Huffman\nencoder's local buffer to overrun when a very high-frequency MCU is compressed\nusing quality 100 and no subsampling, and when the JPEG output buffer is being\ndynamically resized by the destination manager.  This issue was so rare that,\neven with a test program specifically designed to make the bug occur (by\ninjecting random high-frequency YUV data into the compressor), it was\nreproducible only once in about every 25 million iterations.\n\n16. Fixed an oversight in the TurboJPEG C wrapper:  if any of the JPEG\ncompression functions was called repeatedly with the same\nautomatically-allocated destination buffer, then TurboJPEG would erroneously\nassume that the `jpegSize` parameter was equal to the size of the buffer, when\nin fact that parameter was probably equal to the size of the most recently\ncompressed JPEG image.  If the size of the previous JPEG image was not as large\nas the current JPEG image, then TurboJPEG would unnecessarily reallocate the\ndestination buffer.\n\n\n1.3.1\n=====\n\n### Significant changes relative to 1.3.0:\n\n1. On Un*x systems, `make install` now installs the libjpeg-turbo libraries\ninto /opt/libjpeg-turbo/lib32 by default on any 32-bit system, not just x86,\nand into /opt/libjpeg-turbo/lib64 by default on any 64-bit system, not just\nx86-64.  You can override this by overriding either the `prefix` or `libdir`\nconfigure variables.\n\n2. The Windows installer now places a copy of the TurboJPEG DLLs in the same\ndirectory as the rest of the libjpeg-turbo binaries.  This was mainly done\nto support TurboVNC 1.3, which bundles the DLLs in its Windows installation.\nWhen using a 32-bit version of CMake on 64-bit Windows, it is impossible to\naccess the c:\\WINDOWS\\system32 directory, which made it impossible for the\nTurboVNC build scripts to bundle the 64-bit TurboJPEG DLL.\n\n3. Fixed a bug whereby attempting to encode a progressive JPEG with arithmetic\nentropy coding (by passing arguments of `-progressive -arithmetic` to cjpeg or\njpegtran, for instance) would result in an error, `Requested feature was\nomitted at compile time`.\n\n4. Fixed a couple of issues (CVE-2013-6629 and CVE-2013-6630) whereby malformed\nJPEG images would cause libjpeg-turbo to use uninitialized memory during\ndecompression.\n\n5. Fixed an error (`Buffer passed to JPEG library is too small`) that occurred\nwhen calling the TurboJPEG YUV encoding function with a very small (< 5x5)\nsource image, and added a unit test to check for this error.\n\n6. The Java classes should now build properly under Visual Studio 2010 and\nlater.\n\n7. Fixed an issue that prevented SRPMs generated using the in-tree packaging\ntools from being rebuilt on certain newer Linux distributions.\n\n8. Numerous minor fixes to eliminate compilation and build/packaging system\nwarnings, fix cosmetic issues, improve documentation clarity, and other general\nsource cleanup.\n\n\n1.3.0\n=====\n\n### Significant changes relative to 1.3 beta1:\n\n1. `make test` now works properly on FreeBSD, and it no longer requires the\nmd5sum executable to be present on other Un*x platforms.\n\n2. Overhauled the packaging system:\n\n     - To avoid conflict with vendor-supplied libjpeg-turbo packages, the\nofficial RPMs and DEBs for libjpeg-turbo have been renamed to\n\"libjpeg-turbo-official\".\n     - The TurboJPEG libraries are now located under /opt/libjpeg-turbo in the\nofficial Linux and Mac packages, to avoid conflict with vendor-supplied\npackages and also to streamline the packaging system.\n     - Release packages are now created with the directory structure defined\nby the configure variables `prefix`, `bindir`, `libdir`, etc. (Un\\*x) or by the\n`CMAKE_INSTALL_PREFIX` variable (Windows.)  The exception is that the docs are\nalways located under the system default documentation directory on Un\\*x and\nMac systems, and on Windows, the TurboJPEG DLL is always located in the Windows\nsystem directory.\n     - To avoid confusion, official libjpeg-turbo packages on Linux/Unix\nplatforms (except for Mac) will always install the 32-bit libraries in\n/opt/libjpeg-turbo/lib32 and the 64-bit libraries in /opt/libjpeg-turbo/lib64.\n     - Fixed an issue whereby, in some cases, the libjpeg-turbo executables on\nUn*x systems were not properly linking with the shared libraries installed by\nthe same package.\n     - Fixed an issue whereby building the \"installer\" target on Windows when\n`WITH_JAVA=1` would fail if the TurboJPEG JAR had not been previously built.\n     - Building the \"install\" target on Windows now installs files into the\nsame places that the installer does.\n\n3. Fixed a Huffman encoder bug that prevented I/O suspension from working\nproperly.\n\n\n1.2.90 (1.3 beta1)\n==================\n\n### Significant changes relative to 1.2.1:\n\n1. Added support for additional scaling factors (3/8, 5/8, 3/4, 7/8, 9/8, 5/4,\n11/8, 3/2, 13/8, 7/4, 15/8, and 2) when decompressing.  Note that the IDCT will\nnot be SIMD-accelerated when using any of these new scaling factors.\n\n2. The TurboJPEG dynamic library is now versioned.  It was not strictly\nnecessary to do so, because TurboJPEG uses versioned symbols, and if a function\nchanges in an ABI-incompatible way, that function is renamed and a legacy\nfunction is provided to maintain backward compatibility.  However, certain\nLinux distro maintainers have a policy against accepting any library that isn't\nversioned.\n\n3. Extended the TurboJPEG Java API so that it can be used to compress a JPEG\nimage from and decompress a JPEG image to an arbitrary position in a large\nimage buffer.\n\n4. The `tjDecompressToYUV()` function now supports the `TJFLAG_FASTDCT` flag.\n\n5. The 32-bit supplementary package for amd64 Debian systems now provides\nsymlinks in /usr/lib/i386-linux-gnu for the TurboJPEG libraries in /usr/lib32.\nThis allows those libraries to be used on MultiArch-compatible systems (such as\nUbuntu 11 and later) without setting the linker path.\n\n6. The TurboJPEG Java wrapper should now find the JNI library on Mac systems\nwithout having to pass `-Djava.library.path=/usr/lib` to java.\n\n7. TJBench has been ported to Java to provide a convenient way of validating\nthe performance of the TurboJPEG Java API.  It can be run with\n`java -cp turbojpeg.jar TJBench`.\n\n8. cjpeg can now be used to generate JPEG files with the RGB colorspace\n(feature ported from jpeg-8d.)\n\n9. The width and height in the `-crop` argument passed to jpegtran can now be\nsuffixed with `f` to indicate that, when the upper left corner of the cropping\nregion is automatically moved to the nearest iMCU boundary, the bottom right\ncorner should be moved by the same amount.  In other words, this feature causes\njpegtran to strictly honor the specified width/height rather than the specified\nbottom right corner (feature ported from jpeg-8d.)\n\n10. JPEG files using the RGB colorspace can now be decompressed into grayscale\nimages (feature ported from jpeg-8d.)\n\n11. Fixed a regression caused by 1.2.1[7] whereby the build would fail with\nmultiple \"Mismatch in operand sizes\" errors when attempting to build the x86\nSIMD code with NASM 0.98.\n\n12. The in-memory source/destination managers (`jpeg_mem_src()` and\n`jpeg_mem_dest()`) are now included by default when building libjpeg-turbo with\nlibjpeg v6b or v7 emulation, so that programs can take advantage of these\nfunctions without requiring the use of the backward-incompatible libjpeg v8\nABI.  The \"age number\" of the libjpeg-turbo library on Un*x systems has been\nincremented by 1 to reflect this.  You can disable this feature with a\nconfigure/CMake switch in order to retain strict API/ABI compatibility with the\nlibjpeg v6b or v7 API/ABI (or with previous versions of libjpeg-turbo.)  See\n[README.md](README.md) for more details.\n\n13. Added ARMv7s architecture to libjpeg.a and libturbojpeg.a in the official\nlibjpeg-turbo binary package for OS X, so that those libraries can be used to\nbuild applications that leverage the faster CPUs in the iPhone 5 and iPad 4.\n\n\n1.2.1\n=====\n\n### Significant changes relative to 1.2.0:\n\n1. Creating or decoding a JPEG file that uses the RGB colorspace should now\nproperly work when the input or output colorspace is one of the libjpeg-turbo\ncolorspace extensions.\n\n2. When libjpeg-turbo was built without SIMD support and merged (non-fancy)\nupsampling was used along with an alpha-enabled colorspace during\ndecompression, the unused byte of the decompressed pixels was not being set to\n0xFF.  This has been fixed.  TJUnitTest has also been extended to test for the\ncorrect behavior of the colorspace extensions when merged upsampling is used.\n\n3. Fixed a bug whereby the libjpeg-turbo SSE2 SIMD code would not preserve the\nupper 64 bits of xmm6 and xmm7 on Win64 platforms, which violated the Win64\ncalling conventions.\n\n4. Fixed a regression (CVE-2012-2806) caused by 1.2.0[6] whereby decompressing\ncorrupt JPEG images (specifically, images in which the component count was\nerroneously set to a large value) would cause libjpeg-turbo to segfault.\n\n5. Worked around a severe performance issue with \"Bobcat\" (AMD Embedded APU)\nprocessors.  The `MASKMOVDQU` instruction, which was used by the libjpeg-turbo\nSSE2 SIMD code, is apparently implemented in microcode on AMD processors, and\nit is painfully slow on Bobcat processors in particular.  Eliminating the use\nof this instruction improved performance by an order of magnitude on Bobcat\nprocessors and by a small amount (typically 5%) on AMD desktop processors.\n\n6. Added SIMD acceleration for performing 4:2:2 upsampling on NEON-capable ARM\nplatforms.  This speeds up the decompression of 4:2:2 JPEGs by 20-25% on such\nplatforms.\n\n7. Fixed a regression caused by 1.2.0[2] whereby, on Linux/x86 platforms\nrunning the 32-bit SSE2 SIMD code in libjpeg-turbo, decompressing a 4:2:0 or\n4:2:2 JPEG image into a 32-bit (RGBX, BGRX, etc.) buffer without using fancy\nupsampling would produce several incorrect columns of pixels at the right-hand\nside of the output image if each row in the output image was not evenly\ndivisible by 16 bytes.\n\n8. Fixed an issue whereby attempting to build the SIMD extensions with Xcode\n4.3 on OS X platforms would cause NASM to return numerous errors of the form\n\"'%define' expects a macro identifier\".\n\n9. Added flags to the TurboJPEG API that allow the caller to force the use of\neither the fast or the accurate DCT/IDCT algorithms in the underlying codec.\n\n\n1.2.0\n=====\n\n### Significant changes relative to 1.2 beta1:\n\n1. Fixed build issue with YASM on Unix systems (the libjpeg-turbo build system\nwas not adding the current directory to the assembler include path, so YASM\nwas not able to find jsimdcfg.inc.)\n\n2. Fixed out-of-bounds read in SSE2 SIMD code that occurred when decompressing\na JPEG image to a bitmap buffer whose size was not a multiple of 16 bytes.\nThis was more of an annoyance than an actual bug, since it did not cause any\nactual run-time problems, but the issue showed up when running libjpeg-turbo in\nvalgrind.  See <http://crbug.com/72399> for more information.\n\n3. Added a compile-time macro (`LIBJPEG_TURBO_VERSION`) that can be used to\ncheck the version of libjpeg-turbo against which an application was compiled.\n\n4. Added new RGBA/BGRA/ABGR/ARGB colorspace extension constants (libjpeg API)\nand pixel formats (TurboJPEG API), which allow applications to specify that,\nwhen decompressing to a 4-component RGB buffer, the unused byte should be set\nto 0xFF so that it can be interpreted as an opaque alpha channel.\n\n5. Fixed regression issue whereby DevIL failed to build against libjpeg-turbo\nbecause libjpeg-turbo's distributed version of jconfig.h contained an `INLINE`\nmacro, which conflicted with a similar macro in DevIL.  This macro is used only\ninternally when building libjpeg-turbo, so it was moved into config.h.\n\n6. libjpeg-turbo will now correctly decompress erroneous CMYK/YCCK JPEGs whose\nK component is assigned a component ID of 1 instead of 4.  Although these files\nare in violation of the spec, other JPEG implementations handle them\ncorrectly.\n\n7. Added ARMv6 and ARMv7 architectures to libjpeg.a and libturbojpeg.a in\nthe official libjpeg-turbo binary package for OS X, so that those libraries can\nbe used to build both OS X and iOS applications.\n\n\n1.1.90 (1.2 beta1)\n==================\n\n### Significant changes relative to 1.1.1:\n\n1. Added a Java wrapper for the TurboJPEG API.  See [java/README](java/README)\nfor more details.\n\n2. The TurboJPEG API can now be used to scale down images during\ndecompression.\n\n3. Added SIMD routines for RGB-to-grayscale color conversion, which\nsignificantly improves the performance of grayscale JPEG compression from an\nRGB source image.\n\n4. Improved the performance of the C color conversion routines, which are used\non platforms for which SIMD acceleration is not available.\n\n5. Added a function to the TurboJPEG API that performs lossless transforms.\nThis function is implemented using the same back end as jpegtran, but it\nperforms transcoding entirely in memory and allows multiple transforms and/or\ncrop operations to be batched together, so the source coefficients only need to\nbe read once.  This is useful when generating image tiles from a single source\nJPEG.\n\n6. Added tests for the new TurboJPEG scaled decompression and lossless\ntransform features to tjbench (the TurboJPEG benchmark, formerly called\n\"jpgtest\".)\n\n7. Added support for 4:4:0 (transposed 4:2:2) subsampling in TurboJPEG, which\nwas necessary in order for it to read 4:2:2 JPEG files that had been losslessly\ntransposed or rotated 90 degrees.\n\n8. All legacy VirtualGL code has been re-factored, and this has allowed\nlibjpeg-turbo, in its entirety, to be re-licensed under a BSD-style license.\n\n9. libjpeg-turbo can now be built with YASM.\n\n10. Added SIMD acceleration for ARM Linux and iOS platforms that support\nNEON instructions.\n\n11. Refactored the TurboJPEG C API and documented it using Doxygen.  The\nTurboJPEG 1.2 API uses pixel formats to define the size and component order of\nthe uncompressed source/destination images, and it includes a more efficient\nversion of `TJBUFSIZE()` that computes a worst-case JPEG size based on the\nlevel of chrominance subsampling.  The refactored implementation of the\nTurboJPEG API now uses the libjpeg memory source and destination managers,\nwhich allows the TurboJPEG compressor to grow the JPEG buffer as necessary.\n\n12. Eliminated errors in the output of jpegtran on Windows that occurred when\nthe application was invoked using I/O redirection\n(`jpegtran <input.jpg >output.jpg`.)\n\n13. The inclusion of libjpeg v7 and v8 emulation as well as arithmetic coding\nsupport in libjpeg-turbo v1.1.0 introduced several new error constants in\njerror.h, and these were mistakenly enabled for all emulation modes, causing\nthe error enum in libjpeg-turbo to sometimes have different values than the\nsame enum in libjpeg.  This represents an ABI incompatibility, and it caused\nproblems with rare applications that took specific action based on a particular\nerror value.  The fix was to include the new error constants conditionally\nbased on whether libjpeg v7 or v8 emulation was enabled.\n\n14. Fixed an issue whereby Windows applications that used libjpeg-turbo would\nfail to compile if the Windows system headers were included before jpeglib.h.\nThis issue was caused by a conflict in the definition of the INT32 type.\n\n15. Fixed 32-bit supplementary package for amd64 Debian systems, which was\nbroken by enhancements to the packaging system in 1.1.\n\n16. When decompressing a JPEG image using an output colorspace of\n`JCS_EXT_RGBX`, `JCS_EXT_BGRX`, `JCS_EXT_XBGR`, or `JCS_EXT_XRGB`,\nlibjpeg-turbo will now set the unused byte to 0xFF, which allows applications\nto interpret that byte as an alpha channel (0xFF = opaque).\n\n\n1.1.1\n=====\n\n### Significant changes relative to 1.1.0:\n\n1. Fixed a 1-pixel error in row 0, column 21 of the luminance plane generated\nby `tjEncodeYUV()`.\n\n2. libjpeg-turbo's accelerated Huffman decoder previously ignored unexpected\nmarkers found in the middle of the JPEG data stream during decompression.  It\nwill now hand off decoding of a particular block to the unaccelerated Huffman\ndecoder if an unexpected marker is found, so that the unaccelerated Huffman\ndecoder can generate an appropriate warning.\n\n3. Older versions of MinGW64 prefixed symbol names with underscores by\ndefault, which differed from the behavior of 64-bit Visual C++.  MinGW64 1.0\nhas adopted the behavior of 64-bit Visual C++ as the default, so to accommodate\nthis, the libjpeg-turbo SIMD function names are no longer prefixed with an\nunderscore when building with MinGW64.  This means that, when building\nlibjpeg-turbo with older versions of MinGW64, you will now have to add\n`-fno-leading-underscore` to the `CFLAGS`.\n\n4. Fixed a regression bug in the NSIS script that caused the Windows installer\nbuild to fail when using the Visual Studio IDE.\n\n5. Fixed a bug in `jpeg_read_coefficients()` whereby it would not initialize\n`cinfo->image_width` and `cinfo->image_height` if libjpeg v7 or v8 emulation\nwas enabled.  This specifically caused the jpegoptim program to fail if it was\nlinked against a version of libjpeg-turbo that was built with libjpeg v7 or v8\nemulation.\n\n6. Eliminated excessive I/O overhead that occurred when reading BMP files in\ncjpeg.\n\n7. Eliminated errors in the output of cjpeg on Windows that occurred when the\napplication was invoked using I/O redirection (`cjpeg <inputfile >output.jpg`.)\n\n\n1.1.0\n=====\n\n### Significant changes relative to 1.1 beta1:\n\n1. The algorithm used by the SIMD quantization function cannot produce correct\nresults when the JPEG quality is >= 98 and the fast integer forward DCT is\nused.  Thus, the non-SIMD quantization function is now used for those cases,\nand libjpeg-turbo should now produce identical output to libjpeg v6b in all\ncases.\n\n2. Despite the above, the fast integer forward DCT still degrades somewhat for\nJPEG qualities greater than 95, so the TurboJPEG wrapper will now automatically\nuse the slow integer forward DCT when generating JPEG images of quality 96 or\ngreater.  This reduces compression performance by as much as 15% for these\nhigh-quality images but is necessary to ensure that the images are perceptually\nlossless.  It also ensures that the library can avoid the performance pitfall\ncreated by [1].\n\n3. Ported jpgtest.cxx to pure C to avoid the need for a C++ compiler.\n\n4. Fixed visual artifacts in grayscale JPEG compression caused by a typo in\nthe RGB-to-luminance lookup tables.\n\n5. The Windows distribution packages now include the libjpeg run-time programs\n(cjpeg, etc.)\n\n6. All packages now include jpgtest.\n\n7. The TurboJPEG dynamic library now uses versioned symbols.\n\n8. Added two new TurboJPEG API functions, `tjEncodeYUV()` and\n`tjDecompressToYUV()`, to replace the somewhat hackish `TJ_YUV` flag.\n\n\n1.0.90 (1.1 beta1)\n==================\n\n### Significant changes relative to 1.0.1:\n\n1. Added emulation of the libjpeg v7 and v8 APIs and ABIs.  See\n[README.md](README.md) for more details.  This feature was sponsored by\nCamTrace SAS.\n\n2. Created a new CMake-based build system for the Visual C++ and MinGW builds.\n\n3. Grayscale bitmaps can now be compressed from/decompressed to using the\nTurboJPEG API.\n\n4. jpgtest can now be used to test decompression performance with existing\nJPEG images.\n\n5. If the default install prefix (/opt/libjpeg-turbo) is used, then\n`make install` now creates /opt/libjpeg-turbo/lib32 and\n/opt/libjpeg-turbo/lib64 sym links to duplicate the behavior of the binary\npackages.\n\n6. All symbols in the libjpeg-turbo dynamic library are now versioned, even\nwhen the library is built with libjpeg v6b emulation.\n\n7. Added arithmetic encoding and decoding support (can be disabled with\nconfigure or CMake options)\n\n8. Added a `TJ_YUV` flag to the TurboJPEG API, which causes both the compressor\nand decompressor to output planar YUV images.\n\n9. Added an extended version of `tjDecompressHeader()` to the TurboJPEG API,\nwhich allows the caller to determine the type of subsampling used in a JPEG\nimage.\n\n10. Added further protections against invalid Huffman codes.\n\n\n1.0.1\n=====\n\n### Significant changes relative to 1.0.0:\n\n1. The Huffman decoder will now handle erroneous Huffman codes (for instance,\nfrom a corrupt JPEG image.)  Previously, these would cause libjpeg-turbo to\ncrash under certain circumstances.\n\n2. Fixed typo in SIMD dispatch routines that was causing 4:2:2 upsampling to\nbe used instead of 4:2:0 when decompressing JPEG images using SSE2 code.\n\n3. The configure script will now automatically determine whether the\n`INCOMPLETE_TYPES_BROKEN` macro should be defined.\n\n\n1.0.0\n=====\n\n### Significant changes relative to 0.0.93:\n\n1. 2983700: Further FreeBSD build tweaks (no longer necessary to specify\n`--host` when configuring on a 64-bit system)\n\n2. Created symlinks in the Unix/Linux packages so that the TurboJPEG\ninclude file can always be found in /opt/libjpeg-turbo/include, the 32-bit\nstatic libraries can always be found in /opt/libjpeg-turbo/lib32, and the\n64-bit static libraries can always be found in /opt/libjpeg-turbo/lib64.\n\n3. The Unix/Linux distribution packages now include the libjpeg run-time\nprograms (cjpeg, etc.) and man pages.\n\n4. Created a 32-bit supplementary package for amd64 Debian systems, which\ncontains just the 32-bit libjpeg-turbo libraries.\n\n5. Moved the libraries from */lib32 to */lib in the i386 Debian package.\n\n6. Include distribution package for Cygwin\n\n7. No longer necessary to specify `--without-simd` on non-x86 architectures,\nand unit tests now work on those architectures.\n\n\n0.0.93\n======\n\n### Significant changes since 0.0.91:\n\n1. 2982659: Fixed x86-64 build on FreeBSD systems\n\n2. 2988188: Added support for Windows 64-bit systems\n\n\n0.0.91\n======\n\n### Significant changes relative to 0.0.90:\n\n1. Added documentation to .deb packages\n\n2. 2968313: Fixed data corruption issues when decompressing large JPEG images\nand/or using buffered I/O with the libjpeg-turbo decompressor\n\n\n0.0.90\n======\n\nInitial release\n", "/*\n * rdppm.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2009 by Bill Allombert, Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015-2017, 2020, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to read input images in PPM/PGM format.\n * The extended 2-byte-per-sample raw PPM/PGM formats are supported.\n * The PBMPLUS library is NOT required to compile this software\n * (but it is highly useful as a set of PPM image manipulation programs).\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume input from\n * an ordinary stdio stream.  They further assume that reading begins\n * at the start of the file; start_input may need work if the\n * user interface has already read some data (e.g., to determine that\n * the file is indeed PPM format).\n */\n\n#include \"cmyk.h\"\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#ifdef PPM_SUPPORTED\n\n\n/* Portions of this code are based on the PBMPLUS library, which is:\n**\n** Copyright (C) 1988 by Jef Poskanzer.\n**\n** Permission to use, copy, modify, and distribute this software and its\n** documentation for any purpose and without fee is hereby granted, provided\n** that the above copyright notice appear in all copies and that both that\n** copyright notice and this permission notice appear in supporting\n** documentation.  This software is provided \"as is\" without express or\n** implied warranty.\n*/\n\n\n/* Macros to deal with unsigned chars as efficiently as compiler allows */\n\n#ifdef HAVE_UNSIGNED_CHAR\ntypedef unsigned char U_CHAR;\n#define UCH(x)  ((int)(x))\n#else /* !HAVE_UNSIGNED_CHAR */\n#ifdef __CHAR_UNSIGNED__\ntypedef char U_CHAR;\n#define UCH(x)  ((int)(x))\n#else\ntypedef char U_CHAR;\n#define UCH(x)  ((int)(x) & 0xFF)\n#endif\n#endif /* HAVE_UNSIGNED_CHAR */\n\n\n#define ReadOK(file, buffer, len) \\\n  (JFREAD(file, buffer, len) == ((size_t)(len)))\n\nstatic int alpha_index[JPEG_NUMCS] = {\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1\n};\n\n\n/* Private version of data source object */\n\ntypedef struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  /* Usually these two pointers point to the same place: */\n  U_CHAR *iobuffer;             /* fread's I/O buffer */\n  JSAMPROW pixrow;              /* compressor input buffer */\n  size_t buffer_width;          /* width of I/O buffer */\n  JSAMPLE *rescale;             /* => maxval-remapping array, or NULL */\n  unsigned int maxval;\n} ppm_source_struct;\n\ntypedef ppm_source_struct *ppm_source_ptr;\n\n\nLOCAL(int)\npbm_getc(FILE *infile)\n/* Read next char, skipping over any comments */\n/* A comment/newline sequence is returned as a newline */\n{\n  register int ch;\n\n  ch = getc(infile);\n  if (ch == '#') {\n    do {\n      ch = getc(infile);\n    } while (ch != '\\n' && ch != EOF);\n  }\n  return ch;\n}\n\n\nLOCAL(unsigned int)\nread_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n/* Read an unsigned decimal integer from the PPM file */\n/* Swallows one trailing character after the integer */\n/* Note that on a 16-bit-int machine, only values up to 64k can be read. */\n/* This should not be a problem in practice. */\n{\n  register int ch;\n  register unsigned int val;\n\n  /* Skip any leading whitespace */\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n\n  return val;\n}\n\n\n/*\n * Read one row of pixels.\n *\n * We provide several different versions depending on input file format.\n * In all cases, input is scaled to the size of JSAMPLE.\n *\n * A really fast path is provided for reading byte/sample raw files with\n * maxval = MAXJSAMPLE, which is the normal case for 8-bit data.\n */\n\n\nMETHODDEF(JDIMENSION)\nget_text_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub.buffer[0];\n  for (col = cinfo->image_width; col > 0; col--) {\n    *ptr++ = rescale[read_pbm_integer(cinfo, infile, maxval)];\n  }\n  return 1;\n}\n\n\n#define GRAY_RGB_READ_LOOP(read_op, alpha_set_op) { \\\n  for (col = cinfo->image_width; col > 0; col--) { \\\n    ptr[rindex] = ptr[gindex] = ptr[bindex] = read_op; \\\n    alpha_set_op \\\n    ptr += ps; \\\n  } \\\n}\n\nMETHODDEF(JDIMENSION)\nget_text_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval and\n   converting to extended RGB */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),)\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],)\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_text_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\n#define RGB_READ_LOOP(read_op, alpha_set_op) { \\\n  for (col = cinfo->image_width; col > 0; col--) { \\\n    ptr[rindex] = read_op; \\\n    ptr[gindex] = read_op; \\\n    ptr[bindex] = read_op; \\\n    alpha_set_op \\\n    ptr += ps; \\\n  } \\\n}\n\nMETHODDEF(JDIMENSION)\nget_text_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),\n                    ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),)\n  } else {\n    if (aindex >= 0)\n      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                    ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],)\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_text_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PPM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE g = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE b = read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE g = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE b = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_scaled_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    *ptr++ = rescale[UCH(*bufferptr++)];\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval\n   and converting to extended RGB */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(*bufferptr++,)\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)],)\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval\n   and converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = *bufferptr++;\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = rescale[UCH(*bufferptr++)];\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(*bufferptr++,)\n  } else {\n    if (aindex >= 0)\n      RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(rescale[UCH(*bufferptr++)],)\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PPM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = *bufferptr++;\n      JSAMPLE g = *bufferptr++;\n      JSAMPLE b = *bufferptr++;\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = rescale[UCH(*bufferptr++)];\n      JSAMPLE g = rescale[UCH(*bufferptr++)];\n      JSAMPLE b = rescale[UCH(*bufferptr++)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_raw_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format files with maxval = MAXJSAMPLE.\n * In this case we just read right into the JSAMPLE buffer!\n * Note that same code works for PPM and PGM files.\n */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  int c;\n  unsigned int w, h, maxval;\n  boolean need_iobuffer, use_raw_buffer, need_rescale;\n\n  if (getc(source->pub.input_file) != 'P')\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  c = getc(source->pub.input_file); /* subformat discriminator character */\n\n  /* detect unsupported variants (ie, PBM) before trying to read header */\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n  case '3':                     /* it's a text-format PPM file */\n  case '5':                     /* it's a raw-format PGM file */\n  case '6':                     /* it's a raw-format PPM file */\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_NOT);\n    break;\n  }\n\n  /* fetch the remaining header info */\n  w = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  h = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  maxval = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n\n  if (w <= 0 || h <= 0 || maxval <= 0) /* error check */\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  cinfo->data_precision = BITS_IN_JSAMPLE; /* we always rescale data to this */\n  cinfo->image_width = (JDIMENSION)w;\n  cinfo->image_height = (JDIMENSION)h;\n  source->maxval = maxval;\n\n  /* initialize flags to most common settings */\n  need_iobuffer = TRUE;         /* do we need an I/O buffer? */\n  use_raw_buffer = FALSE;       /* do we map input buffer onto I/O buffer? */\n  need_rescale = TRUE;          /* do we need a rescale array? */\n\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_PGM_TEXT, w, h);\n    if (cinfo->in_color_space == JCS_GRAYSCALE)\n      source->pub.get_pixel_rows = get_text_gray_row;\n    else if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_gray_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_gray_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '3':                     /* it's a text-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS2(cinfo, 1, JTRC_PPM_TEXT, w, h);\n    if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_rgb_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '5':                     /* it's a raw-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_PGM, w, h);\n    if (maxval > 255) {\n      source->pub.get_pixel_rows = get_word_gray_row;\n    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n               cinfo->in_color_space == JCS_GRAYSCALE) {\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (cinfo->in_color_space == JCS_GRAYSCALE)\n        source->pub.get_pixel_rows = get_scaled_gray_row;\n      else if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_gray_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_gray_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n\n  case '6':                     /* it's a raw-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS2(cinfo, 1, JTRC_PPM, w, h);\n    if (maxval > 255) {\n      source->pub.get_pixel_rows = get_word_rgb_row;\n    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n               (cinfo->in_color_space == JCS_EXT_RGB\n#if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3\n                || cinfo->in_color_space == JCS_RGB\n#endif\n               )) {\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_rgb_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n  }\n\n  if (IsExtRGB(cinfo->in_color_space))\n    cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n  else if (cinfo->in_color_space == JCS_GRAYSCALE)\n    cinfo->input_components = 1;\n  else if (cinfo->in_color_space == JCS_CMYK)\n    cinfo->input_components = 4;\n\n  /* Allocate space for I/O buffer: 1 or 3 bytes or words/pixel. */\n  if (need_iobuffer) {\n    if (c == '6')\n      source->buffer_width = (size_t)w * 3 *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    else\n      source->buffer_width = (size_t)w *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  source->buffer_width);\n  }\n\n  /* Create compressor input buffer. */\n  if (use_raw_buffer) {\n    /* For unscaled raw-input case, we can just map it onto the I/O buffer. */\n    /* Synthesize a JSAMPARRAY pointer structure */\n    source->pixrow = (JSAMPROW)source->iobuffer;\n    source->pub.buffer = &source->pixrow;\n    source->pub.buffer_height = 1;\n  } else {\n    /* Need to translate anyway, so make a separate sample buffer. */\n    source->pub.buffer = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)w * cinfo->input_components, (JDIMENSION)1);\n    source->pub.buffer_height = 1;\n  }\n\n  /* Compute the rescaling array if required. */\n  if (need_rescale) {\n    long val, half_maxval;\n\n    /* On 16-bit-int machines we have to be careful of maxval = 65535 */\n    source->rescale = (JSAMPLE *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  (size_t)(((long)MAX(maxval, 255) + 1L) *\n                                           sizeof(JSAMPLE)));\n    half_maxval = maxval / 2;\n    for (val = 0; val <= (long)maxval; val++) {\n      /* The multiplication here must be done in 32 bits to avoid overflow */\n      source->rescale[val] = (JSAMPLE)((val * MAXJSAMPLE + half_maxval) /\n                                        maxval);\n    }\n  }\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  /* no work */\n}\n\n\n/*\n * The module selection routine for PPM format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\njinit_read_ppm(j_compress_ptr cinfo)\n{\n  ppm_source_ptr source;\n\n  /* Create module interface object */\n  source = (ppm_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(ppm_source_struct));\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_ppm;\n  source->pub.finish_input = finish_input_ppm;\n\n  return (cjpeg_source_ptr)source;\n}\n\n#endif /* PPM_SUPPORTED */\n"], "filenames": ["ChangeLog.md", "rdppm.c"], "buggy_code_start_loc": [14, 8], "buggy_code_end_loc": [585, 724], "fixing_code_start_loc": [15, 8], "fixing_code_end_loc": [591, 724], "type": "CWE-125", "message": "libjpeg-turbo 2.0.4, and mozjpeg 4.0.0, has a heap-based buffer over-read in get_rgb_row() in rdppm.c via a malformed PPM input file.", "other": {"cve": {"id": "CVE-2020-13790", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-03T19:15:10.817", "lastModified": "2020-10-20T13:15:12.657", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libjpeg-turbo 2.0.4, and mozjpeg 4.0.0, has a heap-based buffer over-read in get_rgb_row() in rdppm.c via a malformed PPM input file."}, {"lang": "es", "value": "libjpeg-turbo versi\u00f3n 2.0.4, y mozjpeg versi\u00f3n 4.0.0, presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n get_rgb_row() en el archivo rdppm.c por medio de un archivo de entrada PPM malformado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libjpeg-turbo:libjpeg-turbo:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "F91F79CC-B2C4-4D9E-99AA-5D6A49D41561"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:mozjpeg:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "EA6BBD46-8949-4596-9C32-4593916A6D10"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-09/msg00031.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-09/msg00062.html", "source": "cve@mitre.org"}, {"url": "https://github.com/libjpeg-turbo/libjpeg-turbo/commit/3de15e0c344d11d4b90f4a47136467053eb2d09a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libjpeg-turbo/libjpeg-turbo/issues/433", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00033.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/P4D6KNUY7YANSPH7SVQ44PJKSABFKAUB/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U6563YHSVZK24MPJXGJVK3CQG7JVWZGK/", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202010-03", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4386-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/libjpeg-turbo/libjpeg-turbo/commit/3de15e0c344d11d4b90f4a47136467053eb2d09a"}}