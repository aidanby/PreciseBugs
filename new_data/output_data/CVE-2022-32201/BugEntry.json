{"buggy_code": ["/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** This class represents the interface for parsing the\n** entropy coded data in JPEG as part of a single scan.\n**\n** $Id: entropyparser.cpp,v 1.24 2021/09/08 10:30:06 thor Exp $\n**\n*/\n\n/// Includes\n#include \"tools/environment.hpp\"\n#include \"marker/scan.hpp\"\n#include \"marker/frame.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"codestream/entropyparser.hpp\"\n#include \"io/bytestream.hpp\"\n///\n\n/// EntropyParser::EntropyParser\nEntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n\n  // The residual scan uses all components here, not just for, but\n  // it does not require the component count either.\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}\n///\n\n/// EntropyParser::StartWriteScan\n// Write the marker to the stream.\nvoid EntropyParser::StartWriteScan(class ByteStream *,class Checksum *,class BufferCtrl *)\n{\n  // Reset the restart marker count.\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n}\n///\n\n/// EntropyParser::~EntropyParser\nEntropyParser::~EntropyParser(void)\n{\n}\n///\n\n/// EntropyParser::WriteRestartMarker\n// Flush the scan statistics, write the restart marker,\n// reset the MCU counter.\nvoid EntropyParser::WriteRestartMarker(class ByteStream *io)\n{\n  Flush(false);\n  if (io) {\n    io->PutWord(m_usNextRestartMarker);\n    m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n  }\n  m_ulMCUsToGo          = m_ulRestartInterval;\n}\n///\n\n/// EntropyParser::ParseRestartMarker\n// Parse the restart marker or resync at the restart marker.\nvoid EntropyParser::ParseRestartMarker(class ByteStream *io)\n{\n  LONG dt = io->PeekWord();\n  \n  while(dt == 0xffff) {\n    // Found a filler byte. Skip over and try again.\n    io->Get();\n    dt = io->PeekWord();\n  }\n  \n  if (dt == 0xffdc && m_bScanForDNL) {\n    ParseDNLMarker(io);\n  } else if (dt == m_usNextRestartMarker) {\n    // Everything worked fine! Continue going after removing the marker.\n    io->GetWord();\n    Restart();\n    m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n    m_ulMCUsToGo          = m_ulRestartInterval;\n    m_bSegmentIsValid     = true;\n  } else {\n    JPG_WARN(MALFORMED_STREAM,\"EntropyParser::ParseRestartMarker\",\n             \"entropy coder is out of sync, trying to advance to the next marker\");\n    // As said...\n    //\n    do {\n      dt = io->Get();\n      if (dt == ByteStream::EOF) {\n        // Outch, run completely out of data.\n        JPG_THROW(UNEXPECTED_EOF,\"EntropyParser::ParseRestartMarker\",\n                  \"run into end of file while trying to resync the entropy parser\");\n        //\n        // Code never goes here...\n        return;\n      } else if (dt == 0xff) {\n        // Could be a marker.\n        io->LastUnDo();\n        dt = io->PeekWord();\n        // Depends now on the marker.\n        if (dt >= 0xffd0 && dt < 0xffd8) {\n          // Is a restart marker. If this is the correct one, just leave,\n          // the entropy coder was behind and we are then again up at the\n          // correct index.\n          if (dt == m_usNextRestartMarker) {\n            io->GetWord();\n            Restart();\n            m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n            m_ulMCUsToGo          = m_ulRestartInterval;\n            m_bSegmentIsValid     = true;\n            return;\n          } else if (((dt - m_usNextRestartMarker) & 0x07) >= 4) {\n            // Here dt is *likely* behind, i.e. we need to skip more\n            // data to advance to the correct restart marker.\n            io->GetWord();\n            // Remove the marker and keep going.\n          } else {\n            // Here dt is likely ahead, that is, the entropy decoder\n            // should better skip the next entropy coded segment\n            // completely and then should re-enter to re-examine whether\n            // the marker fits. Keep the marker in the stream, then, but\n            // do not continue to decode.\n            m_bSegmentIsValid     = false;\n            m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n            m_ulMCUsToGo          = m_ulRestartInterval;\n            // Do not run into a restart as this may pull bytes.\n            return;\n          }\n        } else if (dt >= 0xffc0 && dt < 0xfff0) {\n          // Is apparently some other marker, i.e. we are at the end of\n          // the segment. Continue skipping until the end is reached and\n          // the parser run out of fun...\n          m_bSegmentIsValid     = false;\n          m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n          m_ulMCUsToGo          = m_ulRestartInterval;\n          // Do not run into a restart as this may pull bytes.\n          return;\n        } else {\n          // Some garbadge data, or a 0xff00. Just eat it up, and continue\n          // scanning. Note that a single Get is used here to eventually\n          // skip over a \"fill byte\".\n          io->Get();\n        }\n      }\n    } while(true);\n  }\n}\n///\n\n/// EntropyParser::ParseDNLMarker\n// Parse the DNL marker, update the frame height. If\n// the result is true, the marker has been found.\nbool EntropyParser::ParseDNLMarker(class ByteStream *io)\n{\n  LONG dt;\n\n  if (m_bDNLFound)\n    return true;\n  \n  dt = io->PeekWord();\n\n  while(dt == 0xffff) {\n    // A filler byte followed by the marker (hopefully). Skip the\n    // filler and try again.\n    io->Get();\n    dt = io->PeekWord();\n  }\n\n  if (dt == 0xffdc) {\n    dt = io->GetWord();\n    dt = io->GetWord();\n    if (dt != 4)\n      JPG_THROW(MALFORMED_STREAM,\"EntropyParser::ParseDNLMarker\",\n                \"DNL marker size is out of range, must be exactly four bytes long\");\n    \n    dt = io->GetWord();\n    if (dt == ByteStream::EOF)\n      JPG_THROW(UNEXPECTED_EOF,\"EntropyParser::ParseDNLMarker\",\n                \"stream is truncated, could not read the DNL marker\");\n    if (dt == 0)\n      JPG_THROW(MALFORMED_STREAM,\"EntropyParser::ParseDNLMarker\",\n                \"frame height as indicated by the DNL marker is corrupt, must be > 0\");\n    \n    m_pFrame->PostImageHeight(dt);\n\n    m_bDNLFound = true;\n    return true;\n  } else {\n    return false;\n  }\n}\n///\n\n/// EntropyParser::FractionalColorBitsOf\n// Return the number of fractional bits due to the color\n// transformation.\nUBYTE EntropyParser::FractionalColorBitsOf(void) const\n{\n  return m_pFrame->TablesOf()->FractionalColorBitsOf(m_pFrame->DepthOf(),m_pFrame->isDCTBased());\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents all data in a single scan, and hence is the SOS marker.\n**\n** $Id: scan.cpp,v 1.117 2021/11/15 07:39:43 thor Exp $\n**\n*/\n\n/// Includes\n#include \"marker/scan.hpp\"\n#include \"io/bytestream.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/component.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"codestream/entropyparser.hpp\"\n#include \"codestream/sequentialscan.hpp\"\n#include \"codestream/acsequentialscan.hpp\"\n#include \"codestream/losslessscan.hpp\"\n#include \"codestream/aclosslessscan.hpp\"\n#include \"codestream/refinementscan.hpp\"\n#include \"codestream/acrefinementscan.hpp\"\n#include \"codestream/singlecomponentlsscan.hpp\"\n#include \"codestream/lineinterleavedlsscan.hpp\"\n#include \"codestream/sampleinterleavedlsscan.hpp\"\n#include \"coding/huffmantemplate.hpp\"\n#include \"marker/huffmantable.hpp\"\n#include \"marker/actable.hpp\"\n#include \"marker/thresholds.hpp\"\n#include \"control/bitmapctrl.hpp\"\n///\n\n///\n\n/// Scan::Scan\nScan::Scan(class Frame *frame)\n  : JKeeper(frame->EnvironOf()), m_pNext(NULL), m_pFrame(frame), m_pParser(NULL),\n    m_pHuffman(NULL), m_pConditioner(NULL), m_bHidden(false)\n{\n  m_ucScanIndex = 0;\n  \n  for(int i = 0;i < 4;i++) {\n    m_pComponent[i]     = NULL;\n    m_ucMappingTable[i] = 0;\n  }\n  \n}\n///\n\n/// Scan::~Scan\nScan::~Scan(void)\n{\n  delete m_pParser;\n  delete m_pHuffman;\n  delete m_pConditioner;\n}\n///\n\n/// Scan::WriteMarker\nvoid Scan::WriteMarker(class ByteStream *io)\n{ \n  bool jpegls = (m_pFrame->ScanTypeOf() == JPEG_LS);\n  UWORD len   = m_ucCount * 2 + 6; // Size of the SOS marker\n  int i;\n\n  //\n  // No need to write the DHT marker if this is empty anyhow.\n  if (m_pHuffman && m_pHuffman->isEmpty() == false) {\n    io->PutWord(0xffc4); // DHT table\n    m_pHuffman->WriteMarker(io);\n  }\n\n  if (m_pConditioner) {\n    io->PutWord(0xffcc);\n    m_pConditioner->WriteMarker(io);\n  }\n  \n  io->PutWord(0xffda); // SOS marker\n\n  // Size of the marker\n  io->PutWord(len);\n\n  // Number of components\n  io->Put(m_ucCount);\n\n  for(i = 0;i < m_ucCount;i++) {\n    io->Put(m_ucComponent[i]);\n    //\n    // Write table selectors.\n    assert(m_ucDCTable[i] < 16);\n    assert(m_ucACTable[i] < 16);\n    \n    if (jpegls) {\n      io->Put(m_ucMappingTable[i]);\n    } else {\n      io->Put((m_ucDCTable[i] << 4) | m_ucACTable[i]);\n    }\n  }\n  \n  io->Put(m_ucScanStart);\n  io->Put(m_ucScanStop);\n  \n  assert(m_ucHighBit < 16);\n  assert(m_ucLowBit  < 16);\n\n  io->Put((m_ucHighBit << 4) | m_ucLowBit);\n}\n///\n\n\n/// Scan::ParseMarker\n// Parse the marker contents. The scan type comes from\n// the frame type.\nvoid Scan::ParseMarker(class ByteStream *io)\n{\n  // Just forward to the generic method.\n  Scan::ParseMarker(io,m_pFrame->ScanTypeOf());\n}\n///\n\n/// Scan::ParseMarker\n// Parse the marker contents where the scan type\n// comes from an additional parameter.\nvoid Scan::ParseMarker(class ByteStream *io,ScanType type)\n{\n  LONG len = io->GetWord();\n  LONG data;\n  int i,j;\n\n  if (len < 8)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"marker length of the SOS marker invalid, must be at least 8 bytes long\");\n\n  data = io->Get();\n  if (data < 1 || data > 4)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"number of components in scan is invalid, must be between 1 and 4\");\n\n  m_ucCount = data;\n\n  if (len != m_ucCount * 2 + 6)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"length of the SOS marker is invalid\");\n\n  for(i = 0;i < m_ucCount;i++) {\n    data = io->Get(); // component identifier.\n    if (data == ByteStream::EOF)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n\n    m_ucComponent[i] = data;\n    for(j = 0;j < i;j++) {\n      if (m_ucComponent[j] == data)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS includes the same component twice\");\n    }\n    \n    data = io->Get(); // table selectors.\n    if (data == ByteStream::EOF)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n\n    if (m_pFrame->ScanTypeOf() != JPEG_LS) {\n      m_ucDCTable[i] = data >> 4;\n      m_ucACTable[i] = data & 0x0f;\n      \n      if (m_ucDCTable[i] > 3)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"DC table index in SOS marker is out of range, must be at most 4\");\n      \n      if (m_ucACTable[i] > 3)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"AC table index in SOS marker is out of range, must be at most 4\");\n    } else {\n      m_ucMappingTable[i] = data; // JPEG_LS uses this for the mapping table selector.\n      // The VESA scan types may use this, but the tables are hardwired.\n      m_ucDCTable[i]      = (i == 0)?(0):(1);\n      m_ucACTable[i]      = (i == 0)?(0):(1);\n    }\n  }\n\n  // Start of spectral selection or NEAR value.\n  data = io->Get();\n  if (data == ByteStream::EOF)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n  if (data > 63 && m_pFrame->ScanTypeOf() != JPEG_LS)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"start of scan index is out of range, must be between 0 and 63\");\n  m_ucScanStart = data;\n  \n  //\n  // End of spectral selection or interleave specifier.\n  data = io->Get();\n  if (data == ByteStream::EOF)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n  if (m_pFrame->ScanTypeOf() != JPEG_LS) {\n    if (data > 63)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"end of scan index is out of range, must be between 0 and 63\");\n  } else {\n    if (data > 2)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"interleave specification is out of range, must be between 0 and 2\"); \n  }\n  m_ucScanStop = data;\n  \n  data = io->Get();\n  if (data == ByteStream::EOF)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n\n  m_ucHighBit    = data >> 4;\n  m_ucLowBit     = data & 0x0f;\n  m_ucHiddenBits = m_pFrame->TablesOf()->HiddenDCTBitsOf();\n\n  if (m_ucHighBit > 13)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS high bit approximation is out of range, must be < 13\");\n\n  switch(type) {\n  case Progressive:\n  case ACProgressive:\n  case DifferentialProgressive:\n  case ACDifferentialProgressive:\n    if (m_ucHighBit && m_ucHighBit != m_ucLowBit + 1)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"SOS high bit is invalid, successive approximation must refine by one bit per scan\");\n    if (m_ucScanStop < m_ucScanStart)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"end of scan is lower than start of scan\");\n    if (m_ucScanStart == 0 && m_ucScanStop != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"DC component must be in a separate scan in the progressive mode\");\n    if (m_ucScanStart && m_ucCount != 1)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"AC scans in progressive mode must only contain a single component\");\n    break;\n  case Residual:\n  case ACResidual:\n  case ResidualProgressive:\n  case ACResidualProgressive:\n  case ResidualDCT:\n  case ACResidualDCT:\n    if (m_ucHighBit && m_ucHighBit != m_ucLowBit + 1)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"SOS high bit is invalid, successive approximation must refine by one bit per scan\");\n    if (m_ucScanStop < m_ucScanStart)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"end of scan is lower than start of scan\");\n    break;\n  case Baseline:\n  case Sequential:\n  case ACSequential:\n  case DifferentialSequential:\n  case ACDifferentialSequential:\n    if (m_ucScanStop != 63 || m_ucScanStart != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"scan start must be zero and scan stop must be 63 for the sequential operating modes\");\n    // fall through\n  case JPEG_LS: \n    // Specs don't say anything what to do about them. Just assume they must be zero.\n    if (m_ucHighBit != 0) // Low bit is the point transformation\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"successive approximation parameters must be zero for the sequential operating modes\");\n    break;\n  case Lossless:\n  case ACLossless:\n    if (m_ucScanStart == 0 || m_ucScanStop > 7) // actually the predictor.\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"predictor for the lossless mode must be between 1 and 7\");\n    if (m_ucScanStop != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"scan stop parameter must be zero in the lossless mode\");\n    if (m_ucHighBit != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"successive approximation high bit parameter must be zero for the lossless mode\");\n    break;\n  case DifferentialLossless:\n  case ACDifferentialLossless:\n    if (m_ucScanStart != 0) // actually the predictor.\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"predictor for the differential lossless mode must be zero\");\n    if (m_ucScanStop != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"scan stop parameter must be zero in the lossless mode\");\n    if (m_ucHighBit != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"successive approximation high bit parameter must be zero for the lossless mode\");\n    break;\n  default:\n    break;\n  }\n}\n///\n\n/// Scan::ComponentOf\n// Return the i'th component of the scan.\nclass Component *Scan::ComponentOf(UBYTE i)\n{\n  assert(i < 4);\n\n  if (m_pComponent[i] == NULL)\n    m_pComponent[i] = m_pFrame->FindComponent(m_ucComponent[i]);\n\n  return m_pComponent[i];\n}\n///\n\n/// Scan::CreateParser\n// Create a suitable parser given the scan type as indicated in the\n// header and the contents of the marker. The parser is kept\n// here as it is local to the scan.\nvoid Scan::CreateParser(void)\n{\n  ScanType type = m_pFrame->ScanTypeOf();\n  //\n  assert(m_pParser == NULL);\n  //\n  switch(type) {\n  case Baseline:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits,\n                                                     false,false,false,true);\n    break;\n  case Sequential:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits);\n    break;\n  case DifferentialSequential:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits,true);\n    break;\n  case Lossless:\n    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,m_ucScanStart,\n                                                   m_ucLowBit + m_ucHiddenBits);\n    break;\n  case DifferentialLossless:\n    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,0,\n                                                   m_ucLowBit + m_ucHiddenBits,true);\n    break;\n  case ACLossless:\n    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,m_ucScanStart,\n                                                     m_ucLowBit + m_ucHiddenBits);\n    break;\n  case ACDifferentialLossless:\n    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,0,\n                                                     m_ucLowBit + m_ucHiddenBits,true);\n    break;\n  case ACSequential:\n    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    break;\n  case ACDifferentialSequential:\n    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    break;\n  case Progressive:\n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    } else { \n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    }\n    break;\n  case ResidualProgressive:\n    if (m_ucHighBit == 0) { \n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,\n                                                       true,true);\n    } else { \n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,\n                                                       true,true);\n    }\n    break;\n  case DifferentialProgressive:\n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    } else { \n      // Even though the specs do not mention this, it makes perfect sense that the\n      // refinement scan is a regular refinement scan without modification.\n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    }\n    break;\n  case ACProgressive: \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits);\n    }\n    break;\n  case ACDifferentialProgressive: \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         true);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         true);\n    }\n    break;\n  case ACResidualProgressive:  \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         false,true);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         false,true);\n    }\n    break;\n  case Residual:\n    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this,\n                                               m_ucScanStart,m_ucScanStop,\n                                               m_ucLowBit + m_ucHiddenBits,\n                                               m_ucHighBit + m_ucHiddenBits,\n                                               true,true);\n    break;\n  case ACResidual:\n    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit + m_ucHiddenBits,\n                                                 m_ucHighBit + m_ucHiddenBits,\n                                                 true,true);  \n    break;\n  case ResidualDCT:\n    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this,\n                                               m_ucScanStart,m_ucScanStop,\n                                               m_ucLowBit + m_ucHiddenBits,\n                                               m_ucHighBit + m_ucHiddenBits,\n                                               false,false,true);\n    break; \n  case ACResidualDCT:\n    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit + m_ucHiddenBits,\n                                                 m_ucHighBit + m_ucHiddenBits,\n                                                 false,false,true);\n    break;\n  case JPEG_LS:\n    // Depends on the interleaving\n    switch(m_ucScanStop) {\n    case 0:\n      if (m_ucCount != 1)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::CreateParser\",\n                  \"invalid codestream, found a single comonent scan containing more than one component\");\n      m_pParser = new(m_pEnviron) class SingleComponentLSScan(m_pFrame,this,\n                                                              m_ucScanStart, // NEAR\n                                                              m_ucMappingTable,\n                                                              m_ucLowBit + m_ucHiddenBits); \n      break;\n    case 1:\n      m_pParser = new(m_pEnviron) class LineInterleavedLSScan(m_pFrame,this,\n                                                              m_ucScanStart,\n                                                              m_ucMappingTable,\n                                                              m_ucLowBit + m_ucHiddenBits);\n      break;\n    case 2:\n      m_pParser = new(m_pEnviron) class SampleInterleavedLSScan(m_pFrame,this,\n                                                                m_ucScanStart,\n                                                                m_ucMappingTable,\n                                                                m_ucLowBit + m_ucHiddenBits);\n      break;\n    }\n    break;\n  default:\n    JPG_THROW(NOT_IMPLEMENTED,\"Scan::CreateParser\",\n              \"sorry, the coding mode in the codestream is currently not supported\");\n  }\n}\n///\n\n/// Scan::InstallDefaults\n// Install the defaults for a sequential scan containing the given number of components\nvoid Scan::InstallDefaults(UBYTE depth,ULONG tagoffset,const struct JPG_TagItem *tags)\n{\n  bool ishuffman    = false;\n  bool ispredictive = false;\n  bool isjpegls     = false;\n  bool colortrafo   = m_pFrame->TablesOf()->hasSeparateChroma(m_pFrame->DepthOf());\n  ScanType type     = m_pFrame->ScanTypeOf();\n\n  assert(m_pParser == NULL);\n  \n  switch(type) {\n  case Baseline:\n  case Sequential:\n  case Progressive:\n  case DifferentialSequential:\n  case DifferentialProgressive:\n  case Residual:\n  case ResidualProgressive:\n  case ResidualDCT:\n    ishuffman    = true;\n    break;\n  case Lossless:\n  case DifferentialLossless:\n    ishuffman    = true;\n    ispredictive = true;\n    break;\n  case ACSequential:\n  case ACProgressive:\n  case ACDifferentialSequential:\n  case ACDifferentialProgressive:\n  case ACResidual:\n  case ACResidualProgressive:\n  case ACResidualDCT:\n    break;\n  case ACLossless:\n  case ACDifferentialLossless:\n    ispredictive = true;\n    break;\n  case JPEG_LS:\n    ispredictive = true;\n    isjpegls     = true;\n    break;\n  default:\n    JPG_THROW(NOT_IMPLEMENTED,\"Scan::InstallDefaults\",\n              \"sorry, unknown frame type, not yet implemented\");\n  }\n\n  if (depth < 1 || depth > 4)\n    JPG_THROW(OVERFLOW_PARAMETER,\"Scan::InstallDefaults\",\n              \"JPEG allows only between one and four components per scan\");\n\n  m_ucCount = depth;\n  \n  if (isjpegls) {\n    // None of the below required. \n  } else if (ishuffman) {\n    m_pHuffman     = new(m_pEnviron) HuffmanTable(m_pEnviron);\n  } else {\n    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);\n  }\n  \n  switch(type) {\n  case Progressive:\n  case ACProgressive:\n  case DifferentialProgressive:\n  case ACDifferentialProgressive:\n    m_ucScanStart = 0;\n    m_ucScanStop  = 0; // DC only. User must create other scans manually.\n    m_ucHighBit   = 0;\n    m_ucLowBit    = 0; \n    break;\n  case Baseline:\n  case Sequential: \n  case ACSequential:\n  case DifferentialSequential:\n  case ACDifferentialSequential:\n  case Residual:\n  case ACResidual:\n  case ResidualProgressive:\n  case ACResidualProgressive:\n  case ResidualDCT:\n  case ACResidualDCT:\n    // Install default start and stop of scan for a sequential run.\n    m_ucScanStart = 0;\n    m_ucScanStop  = 63;\n    m_ucHighBit   = 0;\n    m_ucLowBit    = 0; \n    break;\n  case Lossless:\n  case ACLossless:\n    m_ucScanStart = 4; // predictor to use. This is the default.\n    m_ucScanStop  = 0; // shall be zero\n    m_ucHighBit   = 0; // shall be zero\n    m_ucLowBit    = 0; // point transform.\n    break;\n  case DifferentialLossless:\n  case ACDifferentialLossless:\n    m_ucScanStart = 0; // no predictor at all.\n    m_ucScanStop  = 0; // shall be zero\n    m_ucHighBit   = 0; // shall be zero\n    m_ucLowBit    = 0; // point transform.\n    break;\n  case JPEG_LS:\n    m_ucScanStart = 0; // default is lossless\n    m_ucScanStop  = 0; // not interleaved\n    m_ucHighBit   = 0; // shall be zero\n    m_ucLowBit    = 0; // point transform.\n    break;\n  default:\n    assert(!\"unimplemented scan type\");\n    break;\n  }\n  //\n  // Get the tags.\n  m_ucComponent[0] = tags->GetTagData(JPGTAG_SCAN_COMPONENT0            ,0);\n  m_ucComponent[1] = tags->GetTagData(JPGTAG_SCAN_COMPONENT1            ,1);\n  m_ucComponent[2] = tags->GetTagData(JPGTAG_SCAN_COMPONENT2            ,2);  \n  m_ucComponent[3] = tags->GetTagData(JPGTAG_SCAN_COMPONENT3            ,3);\n  m_ucComponent[0] = tags->GetTagData(JPGTAG_SCAN_COMPONENT0 + tagoffset,m_ucComponent[0]);\n  m_ucComponent[1] = tags->GetTagData(JPGTAG_SCAN_COMPONENT1 + tagoffset,m_ucComponent[1]);\n  m_ucComponent[2] = tags->GetTagData(JPGTAG_SCAN_COMPONENT2 + tagoffset,m_ucComponent[2]);  \n  m_ucComponent[3] = tags->GetTagData(JPGTAG_SCAN_COMPONENT3 + tagoffset,m_ucComponent[3]);\n  m_ucHiddenBits   = m_pFrame->TablesOf()->HiddenDCTBitsOf();\n  //\n  // Install the Huffman table specifications\n  // There are only two tables used here, thus this is always fine for baseline.\n  for(UBYTE i = 0;i < depth;i++) {\n    UBYTE c = m_ucComponent[i]; // get the component.\n\n    if (/*ishuffman &&*/ colortrafo) {\n      m_ucDCTable[i] = (c == 0)?(0):(1);\n    } else {\n      m_ucDCTable[i] = 0;\n    }\n    //\n    // AC coding not required for predictive.\n    if (/*ishuffman &&*/ !ispredictive && colortrafo) {\n      m_ucACTable[i] = (c == 0)?(0):(1);\n    } else {\n      m_ucACTable[i] = 0;\n    }\n  } \n  //\n  // Install and check the scan parameters for the progressive scan.\n  switch(type) {\n  case Progressive:\n  case ACProgressive:\n  case DifferentialProgressive:\n  case ACDifferentialProgressive:\n  case ResidualProgressive:\n  case ACResidualProgressive:\n    m_ucScanStart    = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_START            ,m_ucScanStart);\n    m_ucScanStop     = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_STOP             ,m_ucScanStop);    \n    m_ucScanStart    = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_START + tagoffset,m_ucScanStart);\n    m_ucScanStop     = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_STOP  + tagoffset,m_ucScanStop);\n    //\n    if (type != ResidualProgressive && type != ACResidualProgressive) {\n      if (m_ucScanStart == 0 && m_ucScanStop)\n        JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                  \"DC coefficients must be in a separate scan in the progressive mode\");\n      if (m_ucScanStart && m_ucScanStop < m_ucScanStart)\n        JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                  \"Spectral selection stop must be larger or equal than spectral selection start\");\n      if (m_ucScanStart && m_ucCount > 1)\n        JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                  \"In the progressive mode, the AC components must be coded in all separate scans\");\n    } else {\n      if (m_ucScanStop < m_ucScanStart)\n        JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                  \"Spectral selection stop must be larger or equal than spectral selection start\");\n    }\n    if (m_ucScanStop >= 64)\n      JPG_THROW(OVERFLOW_PARAMETER,\"Scan::InstallDefaults\",\n                \"Spectral selection stop is out of range, must be <= 63\");\n\n    m_ucHighBit      = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_HI            ,m_ucHighBit);\n    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_LO            ,m_ucLowBit);\n    m_ucHighBit      = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_HI + tagoffset,m_ucHighBit);\n    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_LO + tagoffset,m_ucLowBit);\n    if (m_ucHighBit > 0 && m_ucHighBit != m_ucLowBit + 1)\n      JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                \"Successive approximation refinement must include only a single bitplane\");\n    //\n    break;\n  case JPEG_LS:\n    // This is the NEAR value of LS. Note that this is never a residual scan.\n    m_ucScanStart = tags->GetTagData(JPGTAG_IMAGE_ERRORBOUND,0);\n    switch(tags->GetTagData(JPGTAG_SCAN_LS_INTERLEAVING)) {\n    case JPGFLAG_SCAN_LS_INTERLEAVING_NONE:\n      m_ucScanStop = 0;\n      break;\n    case JPGFLAG_SCAN_LS_INTERLEAVING_LINE:\n      m_ucScanStop = 1;\n      break;\n    case JPGFLAG_SCAN_LS_INTERLEAVING_SAMPLE:\n      m_ucScanStop = 2;\n      break;\n     default:\n      JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                \"Invalid component interleaving mode for JPEG LS scans\");\n      break;\n    }\n    // Runs into the following to read the point transformation.\n  case Lossless:\n  case ACLossless:\n  case DifferentialLossless:\n  case ACDifferentialLossless:\n    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_POINTTRANSFORM            ,m_ucLowBit);\n    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_POINTTRANSFORM + tagoffset,m_ucLowBit);\n    if (m_ucLowBit >= m_pFrame->PrecisionOf())\n      JPG_THROW(OVERFLOW_PARAMETER,\"Scan::InstallDefaults\",\n                \"Point transformation removes more bits than available in the source data\");\n  default:\n    break;\n  }\n\n  if (m_pParser)\n    JPG_THROW(OBJECT_EXISTS,\"Scan::CompleteSettings\",\n              \"Settings are already installed and active\");\n  \n  CreateParser();\n}\n///\n\n/// Scan::MakeHiddenRefinementScan\n// Make this scan a hidden refinement scan starting at the indicated\n// bit position in the indicated component label.\nvoid Scan::MakeHiddenRefinementScan(UBYTE bitposition,class Component *comp,UBYTE start,UBYTE stop)\n{\n  bool colortrafo = m_pFrame->TablesOf()->hasSeparateChroma(m_pFrame->DepthOf());\n  bool residual   = false; // for a residual scan type.\n  \n  assert(m_pParser == NULL);\n\n  \n  if (m_pFrame->DepthOf() > 4)\n    JPG_THROW(INVALID_PARAMETER,\"Scan::MakeHiddenRefinementScan\",\n              \"hidden refinement scans are confined to four components at most\");\n\n  m_ucScanStart    = start;\n  m_ucScanStop     = stop; \n  m_ucLowBit       = bitposition;\n  m_ucHighBit      = bitposition+1;\n  m_ucHiddenBits   = 0; // not here anymore.\n  m_bHidden        = true;\n\n  switch(m_pFrame->ScanTypeOf()) { \n  case Residual:\n  case ACResidual:\n  case ResidualProgressive: \n  case ACResidualProgressive:\n    // Only one component in the scan.\n    assert(stop >= start);\n      \n    m_ucCount        = 1;\n    m_ucComponent[0] = comp->IDOf();\n    break;\n  default:\n    if (start == 0) {\n      UBYTE i;\n      \n      assert(stop == 0); // This is a DC scan, hopefully.\n      \n      m_ucCount        = m_pFrame->DepthOf();\n      for(i = 0;i < m_ucCount;i++) {\n        m_ucComponent[i] = m_pFrame->ComponentOf(i)->IDOf();\n        m_ucDCTable[i]   = 0;\n        m_ucACTable[i]   = 0; // Fixed later.\n      }\n    } else {\n      // Only one component in the scan.\n      assert(stop >= start);\n      \n      m_ucCount        = 1;\n      m_ucComponent[0] = comp->IDOf();\n    }\n    break;\n  }\n  \n  switch(m_pFrame->ScanTypeOf()) {\n  case Baseline:\n  case Sequential:\n  case Progressive:\n    if (colortrafo) {\n      m_ucACTable[0] = (comp && comp->IndexOf() == 0)?(0):(1);  // Luma uses a separate table.\n      m_ucDCTable[0] = 0;\n      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 1; // Chroma uses a separate table.\n    } else {\n      m_ucACTable[0] = 0;\n      m_ucDCTable[0] = 0;\n      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 0; // Chroma uses the same table.\n    }\n    m_pHuffman = new(m_pEnviron) HuffmanTable(m_pEnviron);\n    m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this,\n                                                start,stop,\n                                                bitposition,bitposition+1,\n                                                false,false);\n    break;\n  case ACSequential:\n  case ACProgressive:\n#if ACCUSOFT_CODE\n    m_ucACTable[0] = 0;\n    m_ucDCTable[0] = 0;\n    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);\n    m_pParser      = new(m_pEnviron) ACRefinementScan(m_pFrame,this,\n                                                      start,stop,\n                                                      bitposition,bitposition+1,\n                                                      false,false);\n#else\n    JPG_THROW(NOT_IMPLEMENTED,\" Scan::MakeHiddenRefinementScan\",\n              \"Arithmetic coding option not available in your code release, please contact Accusoft for a full version\");\n#endif\n    break;\n  case Residual:\n  case ResidualProgressive:\n    residual = true;\n    // runs into the following.\n  case ResidualDCT:\n    if (colortrafo) {\n      m_ucACTable[0] = (comp && comp->IndexOf() == 0)?(0):(1);  // Luma uses a separate table.\n      m_ucDCTable[0] = 0;\n      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 1; // Chroma uses a separate table.\n    } else {\n      m_ucACTable[0] = 0;\n      m_ucDCTable[0] = 0;\n      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 0; // Chroma uses the same table.\n    }\n    assert(residual == false || (start == 0 && stop == 63));\n    m_pHuffman = new(m_pEnviron) HuffmanTable(m_pEnviron);\n    m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this,\n                                                start,stop,\n                                                bitposition,bitposition+1,\n                                                false,residual);\n    break;\n  case ACResidual:\n  case ACResidualProgressive:\n    residual = true;\n    // fall through\n  case ACResidualDCT:\n#if ACCUSOFT_CODE\n    m_ucACTable[0] = 0;\n    m_ucDCTable[0] = 0;\n    assert(residual == false || (start == 0 && stop == 63));\n    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);\n    m_pParser      = new(m_pEnviron) ACRefinementScan(m_pFrame,this,\n                                                      start,stop,\n                                                      bitposition,bitposition+1,\n                                                      false,residual);\n#else\n    JPG_THROW(NOT_IMPLEMENTED,\" Scan::MakeHiddenRefinementScan\",\n              \"Arithmetic coding option not available in your code release, please contact Accusoft for a full version\");\n#endif   \n    break;\n  default:\n    JPG_THROW(INVALID_PARAMETER,\"Scan::MakeHiddenRefinementScan\",\n              \"frame type does not support hidden refinement scans\");\n    break;\n  }\n}\n///\n\n/// Scan::StartParseHiddenRefinementScan\n// Parse off a hidden refinement scan from the given position.\nvoid Scan::StartParseHiddenRefinementScan(class ByteStream *io,class BufferCtrl *ctrl)\n{\n  m_bHidden = true;\n  bool residual = false;\n\n  if (m_pParser == NULL) {\n    ScanType type = m_pFrame->ScanTypeOf();\n    //\n    switch(type) {\n    case Baseline:\n    case Sequential: \n    case Progressive:\n      ParseMarker(io,Progressive);\n      m_pParser = new(m_pEnviron) RefinementScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit,m_ucHighBit,\n                                                 false,false);\n      break;\n    case ACSequential:\n    case ACProgressive:\n#if ACCUSOFT_CODE\n      ParseMarker(io,ACProgressive);\n      m_pParser = new(m_pEnviron) ACRefinementScan(m_pFrame,this,\n                                                   m_ucScanStart,m_ucScanStop,\n                                                   m_ucLowBit,m_ucHighBit,\n                                                   false,false);\n#else\n      JPG_THROW(NOT_IMPLEMENTED,\"Scan::StartParseHiddenRefinementScan\",\n                \"Arithmetic coding option not available in your code release, please contact Accusoft for a full version\");\n#endif\n      break; \n    case Residual:\n    case ResidualProgressive:\n      residual = true;\n      // fall through\n    case ResidualDCT:\n      ParseMarker(io,ResidualProgressive);\n      m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this,\n                                                  m_ucScanStart,m_ucScanStop,\n                                                  m_ucLowBit,m_ucHighBit,\n                                                  false,residual);\n      break;\n    case ACResidual:\n    case ACResidualProgressive:\n      residual = true;\n      // fall through\n    case ACResidualDCT:\n#if ACCUSOFT_CODE\n      ParseMarker(io,ACResidualProgressive);\n      m_pParser  = new(m_pEnviron) ACRefinementScan(m_pFrame,this, \n                                                    m_ucScanStart,m_ucScanStop,\n                                                    m_ucLowBit,m_ucHighBit,\n                                                    false,true);\n#else\n      JPG_THROW(NOT_IMPLEMENTED,\" Scan::MakeHiddenRefinementScan\",\n                \"Arithmetic coding option not available in your code release, \"\n                \"please contact Accusoft for a full version\");\n#endif   \n      break; \n    default:\n      JPG_THROW(NOT_IMPLEMENTED,\"Scan::StartParseHiddenRefinementScan\",\n                \"sorry, the coding mode in the codestream is currently not supported\");\n    }\n  } \n\n  ctrl->PrepareForDecoding();\n  m_pParser->StartParseScan(io,NULL,ctrl);\n}\n///\n\n/// Scan::StartParseScan\n// Fill in the decoding tables required.\nvoid Scan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n  //\n  // The residual scan has the parser set here already.\n  if (m_pParser == NULL)\n    CreateParser();\n  \n  ctrl->PrepareForDecoding();\n  m_pParser->StartParseScan(io,chk,ctrl);\n}\n///\n\n/// Scan::StartWriteScan\n// Fill in the encoding tables.\nvoid Scan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n  assert(m_pParser);\n\n  if (m_pHuffman)\n    m_pHuffman->AdjustToStatistics();\n  \n  ctrl->PrepareForEncoding();\n  m_pParser->StartWriteScan(io,chk,ctrl);\n}\n///\n\n/// Scan::StartMeasureScan\n// Start making a measurement run to optimize the\n// huffman tables.\nvoid Scan::StartMeasureScan(class BufferCtrl *ctrl)\n{\n  assert(m_pParser);\n\n  ctrl->PrepareForEncoding();\n  m_pParser->StartMeasureScan(ctrl);\n}\n///\n\n/// Scan::StartOptimizeScan\n// Start making a R/D optimization\nvoid Scan::StartOptimizeScan(class BufferCtrl *ctrl)\n{\n  assert(m_pParser);\n  //\n  ctrl->PrepareForEncoding();\n  m_pParser->StartOptimizeScan(ctrl);\n}\n///\n\n/// Scan::StartMCURow\n// Start a MCU scan.\nbool Scan::StartMCURow(void)\n{\n  assert(m_pParser);\n\n  return m_pParser->StartMCURow();\n}\n///\n\n/// Scan::ParseMCU\n// Parse a single MCU in this scan.\nbool Scan::ParseMCU(void)\n{\n  assert(m_pParser);\n\n  return m_pParser->ParseMCU();\n}\n///\n\n/// Scan::WriteMCU\n// Write a single MCU in this scan.\nbool Scan::WriteMCU(void)\n{\n  assert(m_pParser);\n\n  return m_pParser->WriteMCU();\n}\n///\n\n/// Scan::WriteFrameType\n// Write the scan type marker at the beginning of the\n// file.\nvoid Scan::WriteFrameType(class ByteStream *io)\n{\n  assert(m_pParser);\n\n  //\n  // Do not write the frame type of hidden scans.\n  if (m_bHidden) {\n    assert(m_pNext);\n    m_pNext->WriteFrameType(io);\n  } else {\n    m_pParser->WriteFrameType(io);\n  }\n}\n///\n\n/// Scan::Flush\n// Flush the remaining bits out to the stream on writing.\nvoid Scan::Flush(void)\n{\n  if (m_pParser)\n    m_pParser->Flush(true);\n}\n///\n\n/// Scan::FindThresholds\n// Find the thresholds of the JPEG LS scan.\nclass Thresholds *Scan::FindThresholds(void) const\n{\n  return m_pFrame->TablesOf()->ThresholdsOf();\n}\n///\n\n/// Scan::DCHuffmanDecoderOf\n// Return the huffman decoder of the DC value for the\n// indicated component.\nclass HuffmanDecoder *Scan::DCHuffmanDecoderOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf();\n\n  assert(idx < 4);\n  \n  t = m_pFrame->TablesOf()->FindDCHuffmanTable(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n    JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::DCHuffmanDecoderOf\",\"requested DC Huffman coding table not defined\");\n\n  return t->DecoderOf();\n}\n///\n\n/// Scan::ACHuffmanDecoderOf\n// Return the huffman decoder of the DC value for the\n// indicated component.\nclass HuffmanDecoder *Scan::ACHuffmanDecoderOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf();\n\n  assert(idx < 4);\n\n  t = m_pFrame->TablesOf()->FindACHuffmanTable(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n    JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::ACHuffmanDecoderOf\",\"requested AC Huffman coding table not defined\");\n\n  return t->DecoderOf();  \n}\n///\n\n/// Scan::DCHuffmanCoderOf\n// Find the Huffman decoder of the indicated index.\nclass HuffmanCoder *Scan::DCHuffmanCoderOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf();\n\n  assert(idx < 4);\n\n  t = m_pHuffman->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n      JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::DCHuffmanCoderOf\",\"requested DC Huffman coding table not defined\");\n\n  t->AdjustToStatistics();\n  \n  return t->EncoderOf();\n}\n///\n\n/// Scan::ACHuffmanCoderOf\n// Find the Huffman decoder of the indicated index.\nclass HuffmanCoder *Scan::ACHuffmanCoderOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf();\n  \n  assert(idx < 4);\n\n  t = m_pHuffman->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n      JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::ACHuffmanCoderOf\",\"requested AC Huffman coding table not defined\");\n\n  t->AdjustToStatistics();\n  \n  return t->EncoderOf();\n}\n///\n\n/// Scan::DCHuffmanStatisticsOf\n// Find the Huffman decoder of the indicated index.\nclass HuffmanStatistics *Scan::DCHuffmanStatisticsOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf(); \n \n  assert(idx < 4);\n\n  t = m_pHuffman->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n      JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::DCHuffmanStatisticsOf\",\"requested DC Huffman coding table not defined\");\n\n  return t->StatisticsOf(true);\n}\n///\n\n/// Scan::ACHuffmanStatisticsOf\n// Find the Huffman decoder of the indicated index.\nclass HuffmanStatistics *Scan::ACHuffmanStatisticsOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf(); \n\n  assert(idx < 4);\n\n  t = m_pHuffman->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  \n  if (t == NULL)\n      JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::ACHuffmanStatisticsOf\",\"requested AC Huffman coding table not defined\");\n\n  return t->StatisticsOf(false);\n}\n///\n\n/// Scan::DCConditionerOf\n// Find the arithmetic coding conditioner table for the indicated\n// component and the DC band.\nclass ACTemplate *Scan::DCConditionerOf(UBYTE idx) const\n{ \n  ScanType sc = m_pFrame->ScanTypeOf();\n  assert(idx < 4);\n\n  if (m_pConditioner) {\n    return m_pConditioner->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                                        m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  }\n\n  return m_pFrame->TablesOf()->FindDCConditioner(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                                                 m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n}\n///\n\n/// Scan::ACConditionerOf\n// The same for the AC band.\nclass ACTemplate *Scan::ACConditionerOf(UBYTE idx) const\n{ \n  ScanType sc = m_pFrame->ScanTypeOf();\n  assert(idx < 4);\n\n  if (m_pConditioner) {\n    return m_pConditioner->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                                        m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  }\n\n  return m_pFrame->TablesOf()->FindACConditioner(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                                                 m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n}\n///\n\n/// Scan::OptimizeDCTBlock\n// Optimize the given DCT block for ideal rate-distortion performance. The\n// input parameters are the component this applies to, the critical R/D slope,\n// the original transformed but unquantized DCT data and the quantized DCT\n// block.\nvoid Scan::OptimizeDCTBlock(LONG bx,LONG by,UBYTE compidx,DOUBLE lambda,\n                            class DCT *dct,LONG quantized[64])\n{\n  UBYTE i;\n\n  assert(m_pParser);\n\n  for(i = 0;i < m_ucCount;i++) {\n    if (m_pComponent[i] && m_pComponent[i]->IndexOf() == compidx) {\n      m_pParser->OptimizeBlock(bx,by,i,lambda,dct,quantized);\n      break;\n    }\n  }\n}\n///\n\n/// Scan::OptimizeDC\n// Run a joint optimization of the R/D performance of all DC coefficients\n// within this scan. This requires a separate joint efford as DC coefficients\n// are encoded dependently.\nvoid Scan::OptimizeDC(void)\n{\n  assert(m_pParser);\n\n  m_pParser->OptimizeDC();\n}\n///\n"], "fixing_code": ["/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** This class represents the interface for parsing the\n** entropy coded data in JPEG as part of a single scan.\n**\n** $Id: entropyparser.cpp,v 1.25 2022/05/30 14:05:58 thor Exp $\n**\n*/\n\n/// Includes\n#include \"tools/environment.hpp\"\n#include \"marker/scan.hpp\"\n#include \"marker/frame.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"codestream/entropyparser.hpp\"\n#include \"io/bytestream.hpp\"\n///\n\n/// EntropyParser::EntropyParser\nEntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n\n  // The residual scan uses all components here, not just four, but\n  // it does not require the component count either.\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}\n///\n\n/// EntropyParser::StartWriteScan\n// Write the marker to the stream.\nvoid EntropyParser::StartWriteScan(class ByteStream *,class Checksum *,class BufferCtrl *)\n{\n  // Reset the restart marker count.\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n}\n///\n\n/// EntropyParser::~EntropyParser\nEntropyParser::~EntropyParser(void)\n{\n}\n///\n\n/// EntropyParser::WriteRestartMarker\n// Flush the scan statistics, write the restart marker,\n// reset the MCU counter.\nvoid EntropyParser::WriteRestartMarker(class ByteStream *io)\n{\n  Flush(false);\n  if (io) {\n    io->PutWord(m_usNextRestartMarker);\n    m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n  }\n  m_ulMCUsToGo          = m_ulRestartInterval;\n}\n///\n\n/// EntropyParser::ParseRestartMarker\n// Parse the restart marker or resync at the restart marker.\nvoid EntropyParser::ParseRestartMarker(class ByteStream *io)\n{\n  LONG dt = io->PeekWord();\n  \n  while(dt == 0xffff) {\n    // Found a filler byte. Skip over and try again.\n    io->Get();\n    dt = io->PeekWord();\n  }\n  \n  if (dt == 0xffdc && m_bScanForDNL) {\n    ParseDNLMarker(io);\n  } else if (dt == m_usNextRestartMarker) {\n    // Everything worked fine! Continue going after removing the marker.\n    io->GetWord();\n    Restart();\n    m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n    m_ulMCUsToGo          = m_ulRestartInterval;\n    m_bSegmentIsValid     = true;\n  } else {\n    JPG_WARN(MALFORMED_STREAM,\"EntropyParser::ParseRestartMarker\",\n             \"entropy coder is out of sync, trying to advance to the next marker\");\n    // As said...\n    //\n    do {\n      dt = io->Get();\n      if (dt == ByteStream::EOF) {\n        // Outch, run completely out of data.\n        JPG_THROW(UNEXPECTED_EOF,\"EntropyParser::ParseRestartMarker\",\n                  \"run into end of file while trying to resync the entropy parser\");\n        //\n        // Code never goes here...\n        return;\n      } else if (dt == 0xff) {\n        // Could be a marker.\n        io->LastUnDo();\n        dt = io->PeekWord();\n        // Depends now on the marker.\n        if (dt >= 0xffd0 && dt < 0xffd8) {\n          // Is a restart marker. If this is the correct one, just leave,\n          // the entropy coder was behind and we are then again up at the\n          // correct index.\n          if (dt == m_usNextRestartMarker) {\n            io->GetWord();\n            Restart();\n            m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n            m_ulMCUsToGo          = m_ulRestartInterval;\n            m_bSegmentIsValid     = true;\n            return;\n          } else if (((dt - m_usNextRestartMarker) & 0x07) >= 4) {\n            // Here dt is *likely* behind, i.e. we need to skip more\n            // data to advance to the correct restart marker.\n            io->GetWord();\n            // Remove the marker and keep going.\n          } else {\n            // Here dt is likely ahead, that is, the entropy decoder\n            // should better skip the next entropy coded segment\n            // completely and then should re-enter to re-examine whether\n            // the marker fits. Keep the marker in the stream, then, but\n            // do not continue to decode.\n            m_bSegmentIsValid     = false;\n            m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n            m_ulMCUsToGo          = m_ulRestartInterval;\n            // Do not run into a restart as this may pull bytes.\n            return;\n          }\n        } else if (dt >= 0xffc0 && dt < 0xfff0) {\n          // Is apparently some other marker, i.e. we are at the end of\n          // the segment. Continue skipping until the end is reached and\n          // the parser run out of fun...\n          m_bSegmentIsValid     = false;\n          m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;\n          m_ulMCUsToGo          = m_ulRestartInterval;\n          // Do not run into a restart as this may pull bytes.\n          return;\n        } else {\n          // Some garbadge data, or a 0xff00. Just eat it up, and continue\n          // scanning. Note that a single Get is used here to eventually\n          // skip over a \"fill byte\".\n          io->Get();\n        }\n      }\n    } while(true);\n  }\n}\n///\n\n/// EntropyParser::ParseDNLMarker\n// Parse the DNL marker, update the frame height. If\n// the result is true, the marker has been found.\nbool EntropyParser::ParseDNLMarker(class ByteStream *io)\n{\n  LONG dt;\n\n  if (m_bDNLFound)\n    return true;\n  \n  dt = io->PeekWord();\n\n  while(dt == 0xffff) {\n    // A filler byte followed by the marker (hopefully). Skip the\n    // filler and try again.\n    io->Get();\n    dt = io->PeekWord();\n  }\n\n  if (dt == 0xffdc) {\n    dt = io->GetWord();\n    dt = io->GetWord();\n    if (dt != 4)\n      JPG_THROW(MALFORMED_STREAM,\"EntropyParser::ParseDNLMarker\",\n                \"DNL marker size is out of range, must be exactly four bytes long\");\n    \n    dt = io->GetWord();\n    if (dt == ByteStream::EOF)\n      JPG_THROW(UNEXPECTED_EOF,\"EntropyParser::ParseDNLMarker\",\n                \"stream is truncated, could not read the DNL marker\");\n    if (dt == 0)\n      JPG_THROW(MALFORMED_STREAM,\"EntropyParser::ParseDNLMarker\",\n                \"frame height as indicated by the DNL marker is corrupt, must be > 0\");\n    \n    m_pFrame->PostImageHeight(dt);\n\n    m_bDNLFound = true;\n    return true;\n  } else {\n    return false;\n  }\n}\n///\n\n/// EntropyParser::FractionalColorBitsOf\n// Return the number of fractional bits due to the color\n// transformation.\nUBYTE EntropyParser::FractionalColorBitsOf(void) const\n{\n  return m_pFrame->TablesOf()->FractionalColorBitsOf(m_pFrame->DepthOf(),m_pFrame->isDCTBased());\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents all data in a single scan, and hence is the SOS marker.\n**\n** $Id: scan.cpp,v 1.118 2022/05/30 14:06:11 thor Exp $\n**\n*/\n\n/// Includes\n#include \"marker/scan.hpp\"\n#include \"io/bytestream.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/component.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"codestream/entropyparser.hpp\"\n#include \"codestream/sequentialscan.hpp\"\n#include \"codestream/acsequentialscan.hpp\"\n#include \"codestream/losslessscan.hpp\"\n#include \"codestream/aclosslessscan.hpp\"\n#include \"codestream/refinementscan.hpp\"\n#include \"codestream/acrefinementscan.hpp\"\n#include \"codestream/singlecomponentlsscan.hpp\"\n#include \"codestream/lineinterleavedlsscan.hpp\"\n#include \"codestream/sampleinterleavedlsscan.hpp\"\n#include \"coding/huffmantemplate.hpp\"\n#include \"marker/huffmantable.hpp\"\n#include \"marker/actable.hpp\"\n#include \"marker/thresholds.hpp\"\n#include \"control/bitmapctrl.hpp\"\n///\n\n///\n\n/// Scan::Scan\nScan::Scan(class Frame *frame)\n  : JKeeper(frame->EnvironOf()), m_pNext(NULL), m_pFrame(frame), m_pParser(NULL),\n    m_pHuffman(NULL), m_pConditioner(NULL), m_bHidden(false)\n{\n  m_ucScanIndex = 0;\n  \n  for(int i = 0;i < 4;i++) {\n    m_pComponent[i]     = NULL;\n    m_ucMappingTable[i] = 0;\n  }\n  \n}\n///\n\n/// Scan::~Scan\nScan::~Scan(void)\n{\n  delete m_pParser;\n  delete m_pHuffman;\n  delete m_pConditioner;\n}\n///\n\n/// Scan::WriteMarker\nvoid Scan::WriteMarker(class ByteStream *io)\n{ \n  bool jpegls = (m_pFrame->ScanTypeOf() == JPEG_LS);\n  UWORD len   = m_ucCount * 2 + 6; // Size of the SOS marker\n  int i;\n\n  //\n  // No need to write the DHT marker if this is empty anyhow.\n  if (m_pHuffman && m_pHuffman->isEmpty() == false) {\n    io->PutWord(0xffc4); // DHT table\n    m_pHuffman->WriteMarker(io);\n  }\n\n  if (m_pConditioner) {\n    io->PutWord(0xffcc);\n    m_pConditioner->WriteMarker(io);\n  }\n  \n  io->PutWord(0xffda); // SOS marker\n\n  // Size of the marker\n  io->PutWord(len);\n\n  // Number of components\n  io->Put(m_ucCount);\n\n  for(i = 0;i < m_ucCount;i++) {\n    io->Put(m_ucComponent[i]);\n    //\n    // Write table selectors.\n    assert(m_ucDCTable[i] < 16);\n    assert(m_ucACTable[i] < 16);\n    \n    if (jpegls) {\n      io->Put(m_ucMappingTable[i]);\n    } else {\n      io->Put((m_ucDCTable[i] << 4) | m_ucACTable[i]);\n    }\n  }\n  \n  io->Put(m_ucScanStart);\n  io->Put(m_ucScanStop);\n  \n  assert(m_ucHighBit < 16);\n  assert(m_ucLowBit  < 16);\n\n  io->Put((m_ucHighBit << 4) | m_ucLowBit);\n}\n///\n\n\n/// Scan::ParseMarker\n// Parse the marker contents. The scan type comes from\n// the frame type.\nvoid Scan::ParseMarker(class ByteStream *io)\n{\n  // Just forward to the generic method.\n  Scan::ParseMarker(io,m_pFrame->ScanTypeOf());\n}\n///\n\n/// Scan::ParseMarker\n// Parse the marker contents where the scan type\n// comes from an additional parameter.\nvoid Scan::ParseMarker(class ByteStream *io,ScanType type)\n{\n  LONG len = io->GetWord();\n  LONG data;\n  int i,j;\n\n  if (len < 8)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"marker length of the SOS marker invalid, must be at least 8 bytes long\");\n\n  data = io->Get();\n  if (data < 1 || data > 4)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"number of components in scan is invalid, must be between 1 and 4\");\n\n  m_ucCount = data;\n\n  if (len != m_ucCount * 2 + 6)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"length of the SOS marker is invalid\");\n\n  for(i = 0;i < m_ucCount;i++) {\n    data = io->Get(); // component identifier.\n    if (data == ByteStream::EOF)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n\n    m_ucComponent[i] = data;\n    for(j = 0;j < i;j++) {\n      if (m_ucComponent[j] == data)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS includes the same component twice\");\n    }\n    \n    data = io->Get(); // table selectors.\n    if (data == ByteStream::EOF)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n\n    if (m_pFrame->ScanTypeOf() != JPEG_LS) {\n      m_ucDCTable[i] = data >> 4;\n      m_ucACTable[i] = data & 0x0f;\n      \n      if (m_ucDCTable[i] > 3)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"DC table index in SOS marker is out of range, must be at most 4\");\n      \n      if (m_ucACTable[i] > 3)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"AC table index in SOS marker is out of range, must be at most 4\");\n    } else {\n      m_ucMappingTable[i] = data; // JPEG_LS uses this for the mapping table selector.\n      // The VESA scan types may use this, but the tables are hardwired.\n      m_ucDCTable[i]      = (i == 0)?(0):(1);\n      m_ucACTable[i]      = (i == 0)?(0):(1);\n    }\n  }\n\n  // Start of spectral selection or NEAR value.\n  data = io->Get();\n  if (data == ByteStream::EOF)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n  if (data > 63 && m_pFrame->ScanTypeOf() != JPEG_LS)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"start of scan index is out of range, must be between 0 and 63\");\n  m_ucScanStart = data;\n  \n  //\n  // End of spectral selection or interleave specifier.\n  data = io->Get();\n  if (data == ByteStream::EOF)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n  if (m_pFrame->ScanTypeOf() != JPEG_LS) {\n    if (data > 63)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"end of scan index is out of range, must be between 0 and 63\");\n  } else {\n    if (data > 2)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"interleave specification is out of range, must be between 0 and 2\"); \n  }\n  m_ucScanStop = data;\n  \n  data = io->Get();\n  if (data == ByteStream::EOF)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS marker run out of data\");\n\n  m_ucHighBit    = data >> 4;\n  m_ucLowBit     = data & 0x0f;\n  m_ucHiddenBits = m_pFrame->TablesOf()->HiddenDCTBitsOf();\n\n  if (m_ucHighBit > 13)\n    JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"SOS high bit approximation is out of range, must be < 13\");\n\n  switch(type) {\n  case Progressive:\n  case ACProgressive:\n  case DifferentialProgressive:\n  case ACDifferentialProgressive:\n    if (m_ucHighBit && m_ucHighBit != m_ucLowBit + 1)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"SOS high bit is invalid, successive approximation must refine by one bit per scan\");\n    if (m_ucScanStop < m_ucScanStart)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"end of scan is lower than start of scan\");\n    if (m_ucScanStart == 0 && m_ucScanStop != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"DC component must be in a separate scan in the progressive mode\");\n    if (m_ucScanStart && m_ucCount != 1)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"AC scans in progressive mode must only contain a single component\");\n    break;\n  case Residual:\n  case ACResidual:\n  case ResidualProgressive:\n  case ACResidualProgressive:\n  case ResidualDCT:\n  case ACResidualDCT:\n    if (m_ucHighBit && m_ucHighBit != m_ucLowBit + 1)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"SOS high bit is invalid, successive approximation must refine by one bit per scan\");\n    if (m_ucScanStop < m_ucScanStart)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\"end of scan is lower than start of scan\");\n    break;\n  case Baseline:\n  case Sequential:\n  case ACSequential:\n  case DifferentialSequential:\n  case ACDifferentialSequential:\n    if (m_ucScanStop != 63 || m_ucScanStart != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"scan start must be zero and scan stop must be 63 for the sequential operating modes\");\n    // fall through\n  case JPEG_LS: \n    // Specs don't say anything what to do about them. Just assume they must be zero.\n    if (m_ucHighBit != 0) // Low bit is the point transformation\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"successive approximation parameters must be zero for the sequential operating modes\");\n    break;\n  case Lossless:\n  case ACLossless:\n    if (m_ucScanStart == 0 || m_ucScanStop > 7) // actually the predictor.\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"predictor for the lossless mode must be between 1 and 7\");\n    if (m_ucScanStop != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"scan stop parameter must be zero in the lossless mode\");\n    if (m_ucHighBit != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"successive approximation high bit parameter must be zero for the lossless mode\");\n    break;\n  case DifferentialLossless:\n  case ACDifferentialLossless:\n    if (m_ucScanStart != 0) // actually the predictor.\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"predictor for the differential lossless mode must be zero\");\n    if (m_ucScanStop != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"scan stop parameter must be zero in the lossless mode\");\n    if (m_ucHighBit != 0)\n      JPG_THROW(MALFORMED_STREAM,\"Scan::ParseMarker\",\n                \"successive approximation high bit parameter must be zero for the lossless mode\");\n    break;\n  default:\n    break;\n  }\n}\n///\n\n/// Scan::ComponentOf\n// Return the i'th component of the scan.\nclass Component *Scan::ComponentOf(UBYTE i)\n{\n  assert(i < 4);\n\n  if (m_pComponent[i] == NULL)\n    m_pComponent[i] = m_pFrame->FindComponent(m_ucComponent[i]);\n\n  return m_pComponent[i];\n}\n///\n\n/// Scan::CreateParser\n// Create a suitable parser given the scan type as indicated in the\n// header and the contents of the marker. The parser is kept\n// here as it is local to the scan.\nvoid Scan::CreateParser(void)\n{\n  ScanType type = m_pFrame->ScanTypeOf();\n  //\n  assert(m_pParser == NULL);\n  //\n  // Check whether all components are there.\n  for(UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    if (ComponentOf(i) == NULL) {\n      JPG_THROW(MALFORMED_STREAM,\"Scan::CreateParser\",\n                \"found a component ID in a scan that does not exist\");\n    }\n  }\n  //\n  switch(type) {\n  case Baseline:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits,\n                                                     false,false,false,true);\n    break;\n  case Sequential:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits);\n    break;\n  case DifferentialSequential:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits,true);\n    break;\n  case Lossless:\n    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,m_ucScanStart,\n                                                   m_ucLowBit + m_ucHiddenBits);\n    break;\n  case DifferentialLossless:\n    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,0,\n                                                   m_ucLowBit + m_ucHiddenBits,true);\n    break;\n  case ACLossless:\n    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,m_ucScanStart,\n                                                     m_ucLowBit + m_ucHiddenBits);\n    break;\n  case ACDifferentialLossless:\n    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,0,\n                                                     m_ucLowBit + m_ucHiddenBits,true);\n    break;\n  case ACSequential:\n    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    break;\n  case ACDifferentialSequential:\n    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    break;\n  case Progressive:\n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    } else { \n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    }\n    break;\n  case ResidualProgressive:\n    if (m_ucHighBit == 0) { \n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,\n                                                       true,true);\n    } else { \n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,\n                                                       true,true);\n    }\n    break;\n  case DifferentialProgressive:\n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    } else { \n      // Even though the specs do not mention this, it makes perfect sense that the\n      // refinement scan is a regular refinement scan without modification.\n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    }\n    break;\n  case ACProgressive: \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits);\n    }\n    break;\n  case ACDifferentialProgressive: \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         true);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         true);\n    }\n    break;\n  case ACResidualProgressive:  \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         false,true);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         false,true);\n    }\n    break;\n  case Residual:\n    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this,\n                                               m_ucScanStart,m_ucScanStop,\n                                               m_ucLowBit + m_ucHiddenBits,\n                                               m_ucHighBit + m_ucHiddenBits,\n                                               true,true);\n    break;\n  case ACResidual:\n    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit + m_ucHiddenBits,\n                                                 m_ucHighBit + m_ucHiddenBits,\n                                                 true,true);  \n    break;\n  case ResidualDCT:\n    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this,\n                                               m_ucScanStart,m_ucScanStop,\n                                               m_ucLowBit + m_ucHiddenBits,\n                                               m_ucHighBit + m_ucHiddenBits,\n                                               false,false,true);\n    break; \n  case ACResidualDCT:\n    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit + m_ucHiddenBits,\n                                                 m_ucHighBit + m_ucHiddenBits,\n                                                 false,false,true);\n    break;\n  case JPEG_LS:\n    // Depends on the interleaving\n    switch(m_ucScanStop) {\n    case 0:\n      if (m_ucCount != 1)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::CreateParser\",\n                  \"invalid codestream, found a single comonent scan containing more than one component\");\n      m_pParser = new(m_pEnviron) class SingleComponentLSScan(m_pFrame,this,\n                                                              m_ucScanStart, // NEAR\n                                                              m_ucMappingTable,\n                                                              m_ucLowBit + m_ucHiddenBits); \n      break;\n    case 1:\n      m_pParser = new(m_pEnviron) class LineInterleavedLSScan(m_pFrame,this,\n                                                              m_ucScanStart,\n                                                              m_ucMappingTable,\n                                                              m_ucLowBit + m_ucHiddenBits);\n      break;\n    case 2:\n      m_pParser = new(m_pEnviron) class SampleInterleavedLSScan(m_pFrame,this,\n                                                                m_ucScanStart,\n                                                                m_ucMappingTable,\n                                                                m_ucLowBit + m_ucHiddenBits);\n      break;\n    }\n    break;\n  default:\n    JPG_THROW(NOT_IMPLEMENTED,\"Scan::CreateParser\",\n              \"sorry, the coding mode in the codestream is currently not supported\");\n  }\n}\n///\n\n/// Scan::InstallDefaults\n// Install the defaults for a sequential scan containing the given number of components\nvoid Scan::InstallDefaults(UBYTE depth,ULONG tagoffset,const struct JPG_TagItem *tags)\n{\n  bool ishuffman    = false;\n  bool ispredictive = false;\n  bool isjpegls     = false;\n  bool colortrafo   = m_pFrame->TablesOf()->hasSeparateChroma(m_pFrame->DepthOf());\n  ScanType type     = m_pFrame->ScanTypeOf();\n\n  assert(m_pParser == NULL);\n  \n  switch(type) {\n  case Baseline:\n  case Sequential:\n  case Progressive:\n  case DifferentialSequential:\n  case DifferentialProgressive:\n  case Residual:\n  case ResidualProgressive:\n  case ResidualDCT:\n    ishuffman    = true;\n    break;\n  case Lossless:\n  case DifferentialLossless:\n    ishuffman    = true;\n    ispredictive = true;\n    break;\n  case ACSequential:\n  case ACProgressive:\n  case ACDifferentialSequential:\n  case ACDifferentialProgressive:\n  case ACResidual:\n  case ACResidualProgressive:\n  case ACResidualDCT:\n    break;\n  case ACLossless:\n  case ACDifferentialLossless:\n    ispredictive = true;\n    break;\n  case JPEG_LS:\n    ispredictive = true;\n    isjpegls     = true;\n    break;\n  default:\n    JPG_THROW(NOT_IMPLEMENTED,\"Scan::InstallDefaults\",\n              \"sorry, unknown frame type, not yet implemented\");\n  }\n\n  if (depth < 1 || depth > 4)\n    JPG_THROW(OVERFLOW_PARAMETER,\"Scan::InstallDefaults\",\n              \"JPEG allows only between one and four components per scan\");\n\n  m_ucCount = depth;\n  \n  if (isjpegls) {\n    // None of the below required. \n  } else if (ishuffman) {\n    m_pHuffman     = new(m_pEnviron) HuffmanTable(m_pEnviron);\n  } else {\n    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);\n  }\n  \n  switch(type) {\n  case Progressive:\n  case ACProgressive:\n  case DifferentialProgressive:\n  case ACDifferentialProgressive:\n    m_ucScanStart = 0;\n    m_ucScanStop  = 0; // DC only. User must create other scans manually.\n    m_ucHighBit   = 0;\n    m_ucLowBit    = 0; \n    break;\n  case Baseline:\n  case Sequential: \n  case ACSequential:\n  case DifferentialSequential:\n  case ACDifferentialSequential:\n  case Residual:\n  case ACResidual:\n  case ResidualProgressive:\n  case ACResidualProgressive:\n  case ResidualDCT:\n  case ACResidualDCT:\n    // Install default start and stop of scan for a sequential run.\n    m_ucScanStart = 0;\n    m_ucScanStop  = 63;\n    m_ucHighBit   = 0;\n    m_ucLowBit    = 0; \n    break;\n  case Lossless:\n  case ACLossless:\n    m_ucScanStart = 4; // predictor to use. This is the default.\n    m_ucScanStop  = 0; // shall be zero\n    m_ucHighBit   = 0; // shall be zero\n    m_ucLowBit    = 0; // point transform.\n    break;\n  case DifferentialLossless:\n  case ACDifferentialLossless:\n    m_ucScanStart = 0; // no predictor at all.\n    m_ucScanStop  = 0; // shall be zero\n    m_ucHighBit   = 0; // shall be zero\n    m_ucLowBit    = 0; // point transform.\n    break;\n  case JPEG_LS:\n    m_ucScanStart = 0; // default is lossless\n    m_ucScanStop  = 0; // not interleaved\n    m_ucHighBit   = 0; // shall be zero\n    m_ucLowBit    = 0; // point transform.\n    break;\n  default:\n    assert(!\"unimplemented scan type\");\n    break;\n  }\n  //\n  // Get the tags.\n  m_ucComponent[0] = tags->GetTagData(JPGTAG_SCAN_COMPONENT0            ,0);\n  m_ucComponent[1] = tags->GetTagData(JPGTAG_SCAN_COMPONENT1            ,1);\n  m_ucComponent[2] = tags->GetTagData(JPGTAG_SCAN_COMPONENT2            ,2);  \n  m_ucComponent[3] = tags->GetTagData(JPGTAG_SCAN_COMPONENT3            ,3);\n  m_ucComponent[0] = tags->GetTagData(JPGTAG_SCAN_COMPONENT0 + tagoffset,m_ucComponent[0]);\n  m_ucComponent[1] = tags->GetTagData(JPGTAG_SCAN_COMPONENT1 + tagoffset,m_ucComponent[1]);\n  m_ucComponent[2] = tags->GetTagData(JPGTAG_SCAN_COMPONENT2 + tagoffset,m_ucComponent[2]);  \n  m_ucComponent[3] = tags->GetTagData(JPGTAG_SCAN_COMPONENT3 + tagoffset,m_ucComponent[3]);\n  m_ucHiddenBits   = m_pFrame->TablesOf()->HiddenDCTBitsOf();\n  //\n  // Install the Huffman table specifications\n  // There are only two tables used here, thus this is always fine for baseline.\n  for(UBYTE i = 0;i < depth;i++) {\n    UBYTE c = m_ucComponent[i]; // get the component.\n\n    if (/*ishuffman &&*/ colortrafo) {\n      m_ucDCTable[i] = (c == 0)?(0):(1);\n    } else {\n      m_ucDCTable[i] = 0;\n    }\n    //\n    // AC coding not required for predictive.\n    if (/*ishuffman &&*/ !ispredictive && colortrafo) {\n      m_ucACTable[i] = (c == 0)?(0):(1);\n    } else {\n      m_ucACTable[i] = 0;\n    }\n  } \n  //\n  // Install and check the scan parameters for the progressive scan.\n  switch(type) {\n  case Progressive:\n  case ACProgressive:\n  case DifferentialProgressive:\n  case ACDifferentialProgressive:\n  case ResidualProgressive:\n  case ACResidualProgressive:\n    m_ucScanStart    = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_START            ,m_ucScanStart);\n    m_ucScanStop     = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_STOP             ,m_ucScanStop);    \n    m_ucScanStart    = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_START + tagoffset,m_ucScanStart);\n    m_ucScanStop     = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_STOP  + tagoffset,m_ucScanStop);\n    //\n    if (type != ResidualProgressive && type != ACResidualProgressive) {\n      if (m_ucScanStart == 0 && m_ucScanStop)\n        JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                  \"DC coefficients must be in a separate scan in the progressive mode\");\n      if (m_ucScanStart && m_ucScanStop < m_ucScanStart)\n        JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                  \"Spectral selection stop must be larger or equal than spectral selection start\");\n      if (m_ucScanStart && m_ucCount > 1)\n        JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                  \"In the progressive mode, the AC components must be coded in all separate scans\");\n    } else {\n      if (m_ucScanStop < m_ucScanStart)\n        JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                  \"Spectral selection stop must be larger or equal than spectral selection start\");\n    }\n    if (m_ucScanStop >= 64)\n      JPG_THROW(OVERFLOW_PARAMETER,\"Scan::InstallDefaults\",\n                \"Spectral selection stop is out of range, must be <= 63\");\n\n    m_ucHighBit      = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_HI            ,m_ucHighBit);\n    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_LO            ,m_ucLowBit);\n    m_ucHighBit      = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_HI + tagoffset,m_ucHighBit);\n    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_LO + tagoffset,m_ucLowBit);\n    if (m_ucHighBit > 0 && m_ucHighBit != m_ucLowBit + 1)\n      JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                \"Successive approximation refinement must include only a single bitplane\");\n    //\n    break;\n  case JPEG_LS:\n    // This is the NEAR value of LS. Note that this is never a residual scan.\n    m_ucScanStart = tags->GetTagData(JPGTAG_IMAGE_ERRORBOUND,0);\n    switch(tags->GetTagData(JPGTAG_SCAN_LS_INTERLEAVING)) {\n    case JPGFLAG_SCAN_LS_INTERLEAVING_NONE:\n      m_ucScanStop = 0;\n      break;\n    case JPGFLAG_SCAN_LS_INTERLEAVING_LINE:\n      m_ucScanStop = 1;\n      break;\n    case JPGFLAG_SCAN_LS_INTERLEAVING_SAMPLE:\n      m_ucScanStop = 2;\n      break;\n     default:\n      JPG_THROW(INVALID_PARAMETER,\"Scan::InstallDefaults\",\n                \"Invalid component interleaving mode for JPEG LS scans\");\n      break;\n    }\n    // Runs into the following to read the point transformation.\n  case Lossless:\n  case ACLossless:\n  case DifferentialLossless:\n  case ACDifferentialLossless:\n    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_POINTTRANSFORM            ,m_ucLowBit);\n    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_POINTTRANSFORM + tagoffset,m_ucLowBit);\n    if (m_ucLowBit >= m_pFrame->PrecisionOf())\n      JPG_THROW(OVERFLOW_PARAMETER,\"Scan::InstallDefaults\",\n                \"Point transformation removes more bits than available in the source data\");\n  default:\n    break;\n  }\n\n  if (m_pParser)\n    JPG_THROW(OBJECT_EXISTS,\"Scan::CompleteSettings\",\n              \"Settings are already installed and active\");\n  \n  CreateParser();\n}\n///\n\n/// Scan::MakeHiddenRefinementScan\n// Make this scan a hidden refinement scan starting at the indicated\n// bit position in the indicated component label.\nvoid Scan::MakeHiddenRefinementScan(UBYTE bitposition,class Component *comp,UBYTE start,UBYTE stop)\n{\n  bool colortrafo = m_pFrame->TablesOf()->hasSeparateChroma(m_pFrame->DepthOf());\n  bool residual   = false; // for a residual scan type.\n  \n  assert(m_pParser == NULL);\n\n  \n  if (m_pFrame->DepthOf() > 4)\n    JPG_THROW(INVALID_PARAMETER,\"Scan::MakeHiddenRefinementScan\",\n              \"hidden refinement scans are confined to four components at most\");\n\n  m_ucScanStart    = start;\n  m_ucScanStop     = stop; \n  m_ucLowBit       = bitposition;\n  m_ucHighBit      = bitposition+1;\n  m_ucHiddenBits   = 0; // not here anymore.\n  m_bHidden        = true;\n\n  switch(m_pFrame->ScanTypeOf()) { \n  case Residual:\n  case ACResidual:\n  case ResidualProgressive: \n  case ACResidualProgressive:\n    // Only one component in the scan.\n    assert(stop >= start);\n      \n    m_ucCount        = 1;\n    m_ucComponent[0] = comp->IDOf();\n    break;\n  default:\n    if (start == 0) {\n      UBYTE i;\n      \n      assert(stop == 0); // This is a DC scan, hopefully.\n      \n      m_ucCount        = m_pFrame->DepthOf();\n      for(i = 0;i < m_ucCount;i++) {\n        m_ucComponent[i] = m_pFrame->ComponentOf(i)->IDOf();\n        m_ucDCTable[i]   = 0;\n        m_ucACTable[i]   = 0; // Fixed later.\n      }\n    } else {\n      // Only one component in the scan.\n      assert(stop >= start);\n      \n      m_ucCount        = 1;\n      m_ucComponent[0] = comp->IDOf();\n    }\n    break;\n  }\n  \n  switch(m_pFrame->ScanTypeOf()) {\n  case Baseline:\n  case Sequential:\n  case Progressive:\n    if (colortrafo) {\n      m_ucACTable[0] = (comp && comp->IndexOf() == 0)?(0):(1);  // Luma uses a separate table.\n      m_ucDCTable[0] = 0;\n      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 1; // Chroma uses a separate table.\n    } else {\n      m_ucACTable[0] = 0;\n      m_ucDCTable[0] = 0;\n      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 0; // Chroma uses the same table.\n    }\n    m_pHuffman = new(m_pEnviron) HuffmanTable(m_pEnviron);\n    m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this,\n                                                start,stop,\n                                                bitposition,bitposition+1,\n                                                false,false);\n    break;\n  case ACSequential:\n  case ACProgressive:\n#if ACCUSOFT_CODE\n    m_ucACTable[0] = 0;\n    m_ucDCTable[0] = 0;\n    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);\n    m_pParser      = new(m_pEnviron) ACRefinementScan(m_pFrame,this,\n                                                      start,stop,\n                                                      bitposition,bitposition+1,\n                                                      false,false);\n#else\n    JPG_THROW(NOT_IMPLEMENTED,\" Scan::MakeHiddenRefinementScan\",\n              \"Arithmetic coding option not available in your code release, please contact Accusoft for a full version\");\n#endif\n    break;\n  case Residual:\n  case ResidualProgressive:\n    residual = true;\n    // runs into the following.\n  case ResidualDCT:\n    if (colortrafo) {\n      m_ucACTable[0] = (comp && comp->IndexOf() == 0)?(0):(1);  // Luma uses a separate table.\n      m_ucDCTable[0] = 0;\n      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 1; // Chroma uses a separate table.\n    } else {\n      m_ucACTable[0] = 0;\n      m_ucDCTable[0] = 0;\n      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 0; // Chroma uses the same table.\n    }\n    assert(residual == false || (start == 0 && stop == 63));\n    m_pHuffman = new(m_pEnviron) HuffmanTable(m_pEnviron);\n    m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this,\n                                                start,stop,\n                                                bitposition,bitposition+1,\n                                                false,residual);\n    break;\n  case ACResidual:\n  case ACResidualProgressive:\n    residual = true;\n    // fall through\n  case ACResidualDCT:\n#if ACCUSOFT_CODE\n    m_ucACTable[0] = 0;\n    m_ucDCTable[0] = 0;\n    assert(residual == false || (start == 0 && stop == 63));\n    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);\n    m_pParser      = new(m_pEnviron) ACRefinementScan(m_pFrame,this,\n                                                      start,stop,\n                                                      bitposition,bitposition+1,\n                                                      false,residual);\n#else\n    JPG_THROW(NOT_IMPLEMENTED,\" Scan::MakeHiddenRefinementScan\",\n              \"Arithmetic coding option not available in your code release, please contact Accusoft for a full version\");\n#endif   \n    break;\n  default:\n    JPG_THROW(INVALID_PARAMETER,\"Scan::MakeHiddenRefinementScan\",\n              \"frame type does not support hidden refinement scans\");\n    break;\n  }\n}\n///\n\n/// Scan::StartParseHiddenRefinementScan\n// Parse off a hidden refinement scan from the given position.\nvoid Scan::StartParseHiddenRefinementScan(class ByteStream *io,class BufferCtrl *ctrl)\n{\n  m_bHidden = true;\n  bool residual = false;\n\n  if (m_pParser == NULL) {\n    ScanType type = m_pFrame->ScanTypeOf();\n    //\n    switch(type) {\n    case Baseline:\n    case Sequential: \n    case Progressive:\n      ParseMarker(io,Progressive);\n      m_pParser = new(m_pEnviron) RefinementScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit,m_ucHighBit,\n                                                 false,false);\n      break;\n    case ACSequential:\n    case ACProgressive:\n#if ACCUSOFT_CODE\n      ParseMarker(io,ACProgressive);\n      m_pParser = new(m_pEnviron) ACRefinementScan(m_pFrame,this,\n                                                   m_ucScanStart,m_ucScanStop,\n                                                   m_ucLowBit,m_ucHighBit,\n                                                   false,false);\n#else\n      JPG_THROW(NOT_IMPLEMENTED,\"Scan::StartParseHiddenRefinementScan\",\n                \"Arithmetic coding option not available in your code release, please contact Accusoft for a full version\");\n#endif\n      break; \n    case Residual:\n    case ResidualProgressive:\n      residual = true;\n      // fall through\n    case ResidualDCT:\n      ParseMarker(io,ResidualProgressive);\n      m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this,\n                                                  m_ucScanStart,m_ucScanStop,\n                                                  m_ucLowBit,m_ucHighBit,\n                                                  false,residual);\n      break;\n    case ACResidual:\n    case ACResidualProgressive:\n      residual = true;\n      // fall through\n    case ACResidualDCT:\n#if ACCUSOFT_CODE\n      ParseMarker(io,ACResidualProgressive);\n      m_pParser  = new(m_pEnviron) ACRefinementScan(m_pFrame,this, \n                                                    m_ucScanStart,m_ucScanStop,\n                                                    m_ucLowBit,m_ucHighBit,\n                                                    false,true);\n#else\n      JPG_THROW(NOT_IMPLEMENTED,\" Scan::MakeHiddenRefinementScan\",\n                \"Arithmetic coding option not available in your code release, \"\n                \"please contact Accusoft for a full version\");\n#endif   \n      break; \n    default:\n      JPG_THROW(NOT_IMPLEMENTED,\"Scan::StartParseHiddenRefinementScan\",\n                \"sorry, the coding mode in the codestream is currently not supported\");\n    }\n  } \n\n  ctrl->PrepareForDecoding();\n  m_pParser->StartParseScan(io,NULL,ctrl);\n}\n///\n\n/// Scan::StartParseScan\n// Fill in the decoding tables required.\nvoid Scan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n  //\n  // The residual scan has the parser set here already.\n  if (m_pParser == NULL)\n    CreateParser();\n  \n  ctrl->PrepareForDecoding();\n  m_pParser->StartParseScan(io,chk,ctrl);\n}\n///\n\n/// Scan::StartWriteScan\n// Fill in the encoding tables.\nvoid Scan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n  assert(m_pParser);\n\n  if (m_pHuffman)\n    m_pHuffman->AdjustToStatistics();\n  \n  ctrl->PrepareForEncoding();\n  m_pParser->StartWriteScan(io,chk,ctrl);\n}\n///\n\n/// Scan::StartMeasureScan\n// Start making a measurement run to optimize the\n// huffman tables.\nvoid Scan::StartMeasureScan(class BufferCtrl *ctrl)\n{\n  assert(m_pParser);\n\n  ctrl->PrepareForEncoding();\n  m_pParser->StartMeasureScan(ctrl);\n}\n///\n\n/// Scan::StartOptimizeScan\n// Start making a R/D optimization\nvoid Scan::StartOptimizeScan(class BufferCtrl *ctrl)\n{\n  assert(m_pParser);\n  //\n  ctrl->PrepareForEncoding();\n  m_pParser->StartOptimizeScan(ctrl);\n}\n///\n\n/// Scan::StartMCURow\n// Start a MCU scan.\nbool Scan::StartMCURow(void)\n{\n  assert(m_pParser);\n\n  return m_pParser->StartMCURow();\n}\n///\n\n/// Scan::ParseMCU\n// Parse a single MCU in this scan.\nbool Scan::ParseMCU(void)\n{\n  assert(m_pParser);\n\n  return m_pParser->ParseMCU();\n}\n///\n\n/// Scan::WriteMCU\n// Write a single MCU in this scan.\nbool Scan::WriteMCU(void)\n{\n  assert(m_pParser);\n\n  return m_pParser->WriteMCU();\n}\n///\n\n/// Scan::WriteFrameType\n// Write the scan type marker at the beginning of the\n// file.\nvoid Scan::WriteFrameType(class ByteStream *io)\n{\n  assert(m_pParser);\n\n  //\n  // Do not write the frame type of hidden scans.\n  if (m_bHidden) {\n    assert(m_pNext);\n    m_pNext->WriteFrameType(io);\n  } else {\n    m_pParser->WriteFrameType(io);\n  }\n}\n///\n\n/// Scan::Flush\n// Flush the remaining bits out to the stream on writing.\nvoid Scan::Flush(void)\n{\n  if (m_pParser)\n    m_pParser->Flush(true);\n}\n///\n\n/// Scan::FindThresholds\n// Find the thresholds of the JPEG LS scan.\nclass Thresholds *Scan::FindThresholds(void) const\n{\n  return m_pFrame->TablesOf()->ThresholdsOf();\n}\n///\n\n/// Scan::DCHuffmanDecoderOf\n// Return the huffman decoder of the DC value for the\n// indicated component.\nclass HuffmanDecoder *Scan::DCHuffmanDecoderOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf();\n\n  assert(idx < 4);\n  \n  t = m_pFrame->TablesOf()->FindDCHuffmanTable(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n    JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::DCHuffmanDecoderOf\",\"requested DC Huffman coding table not defined\");\n\n  return t->DecoderOf();\n}\n///\n\n/// Scan::ACHuffmanDecoderOf\n// Return the huffman decoder of the DC value for the\n// indicated component.\nclass HuffmanDecoder *Scan::ACHuffmanDecoderOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf();\n\n  assert(idx < 4);\n\n  t = m_pFrame->TablesOf()->FindACHuffmanTable(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n    JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::ACHuffmanDecoderOf\",\"requested AC Huffman coding table not defined\");\n\n  return t->DecoderOf();  \n}\n///\n\n/// Scan::DCHuffmanCoderOf\n// Find the Huffman decoder of the indicated index.\nclass HuffmanCoder *Scan::DCHuffmanCoderOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf();\n\n  assert(idx < 4);\n\n  t = m_pHuffman->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n      JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::DCHuffmanCoderOf\",\"requested DC Huffman coding table not defined\");\n\n  t->AdjustToStatistics();\n  \n  return t->EncoderOf();\n}\n///\n\n/// Scan::ACHuffmanCoderOf\n// Find the Huffman decoder of the indicated index.\nclass HuffmanCoder *Scan::ACHuffmanCoderOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf();\n  \n  assert(idx < 4);\n\n  t = m_pHuffman->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n      JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::ACHuffmanCoderOf\",\"requested AC Huffman coding table not defined\");\n\n  t->AdjustToStatistics();\n  \n  return t->EncoderOf();\n}\n///\n\n/// Scan::DCHuffmanStatisticsOf\n// Find the Huffman decoder of the indicated index.\nclass HuffmanStatistics *Scan::DCHuffmanStatisticsOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf(); \n \n  assert(idx < 4);\n\n  t = m_pHuffman->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  if (t == NULL)\n      JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::DCHuffmanStatisticsOf\",\"requested DC Huffman coding table not defined\");\n\n  return t->StatisticsOf(true);\n}\n///\n\n/// Scan::ACHuffmanStatisticsOf\n// Find the Huffman decoder of the indicated index.\nclass HuffmanStatistics *Scan::ACHuffmanStatisticsOf(UBYTE idx) const\n{\n  class HuffmanTemplate *t;\n  ScanType sc = m_pFrame->ScanTypeOf(); \n\n  assert(idx < 4);\n\n  t = m_pHuffman->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                               m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  \n  if (t == NULL)\n      JPG_THROW(OBJECT_DOESNT_EXIST,\"Scan::ACHuffmanStatisticsOf\",\"requested AC Huffman coding table not defined\");\n\n  return t->StatisticsOf(false);\n}\n///\n\n/// Scan::DCConditionerOf\n// Find the arithmetic coding conditioner table for the indicated\n// component and the DC band.\nclass ACTemplate *Scan::DCConditionerOf(UBYTE idx) const\n{ \n  ScanType sc = m_pFrame->ScanTypeOf();\n  assert(idx < 4);\n\n  if (m_pConditioner) {\n    return m_pConditioner->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                                        m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  }\n\n  return m_pFrame->TablesOf()->FindDCConditioner(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(),\n                                                 m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n}\n///\n\n/// Scan::ACConditionerOf\n// The same for the AC band.\nclass ACTemplate *Scan::ACConditionerOf(UBYTE idx) const\n{ \n  ScanType sc = m_pFrame->ScanTypeOf();\n  assert(idx < 4);\n\n  if (m_pConditioner) {\n    return m_pConditioner->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                                        m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n  }\n\n  return m_pFrame->TablesOf()->FindACConditioner(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(),\n                                                 m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);\n}\n///\n\n/// Scan::OptimizeDCTBlock\n// Optimize the given DCT block for ideal rate-distortion performance. The\n// input parameters are the component this applies to, the critical R/D slope,\n// the original transformed but unquantized DCT data and the quantized DCT\n// block.\nvoid Scan::OptimizeDCTBlock(LONG bx,LONG by,UBYTE compidx,DOUBLE lambda,\n                            class DCT *dct,LONG quantized[64])\n{\n  UBYTE i;\n\n  assert(m_pParser);\n\n  for(i = 0;i < m_ucCount;i++) {\n    if (m_pComponent[i] && m_pComponent[i]->IndexOf() == compidx) {\n      m_pParser->OptimizeBlock(bx,by,i,lambda,dct,quantized);\n      break;\n    }\n  }\n}\n///\n\n/// Scan::OptimizeDC\n// Run a joint optimization of the R/D performance of all DC coefficients\n// within this scan. This requires a separate joint efford as DC coefficients\n// are encoded dependently.\nvoid Scan::OptimizeDC(void)\n{\n  assert(m_pParser);\n\n  m_pParser->OptimizeDC();\n}\n///\n"], "filenames": ["codestream/entropyparser.cpp", "marker/scan.cpp"], "buggy_code_start_loc": [46, 45], "buggy_code_end_loc": [66, 339], "fixing_code_start_loc": [46, 45], "fixing_code_end_loc": [66, 348], "type": "CWE-476", "message": "In libjpeg 1.63, there is a NULL pointer dereference in Component::SubXOf in component.hpp.", "other": {"cve": {"id": "CVE-2022-32201", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-02T14:16:01.213", "lastModified": "2022-06-10T16:18:35.690", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In libjpeg 1.63, there is a NULL pointer dereference in Component::SubXOf in component.hpp."}, {"lang": "es", "value": "En libjpeg versi\u00f3n 1.63, se presenta una desreferencia de puntero NULL en la funci\u00f3n Component::SubXOf en el archivo component.hpp"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libjpeg_project:libjpeg:1.63:*:*:*:*:*:*:*", "matchCriteriaId": "E19EEAA5-8206-4988-90CB-8C560A0B932C"}]}]}], "references": [{"url": "https://github.com/thorfdbg/libjpeg/commit/ea6315164b1649ff932a396b7600eac4bffcfaba", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/thorfdbg/libjpeg/issues/73", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/thorfdbg/libjpeg/commit/ea6315164b1649ff932a396b7600eac4bffcfaba"}}