{"buggy_code": ["\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error')\n  var buf = g:RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     g:Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  g:StopVimInTerminal(buf)\n  delete('XTest_compile_error')\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      export def OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xdir'\n  writefile(lines, 'XTest_compile_error')\n\n  var buf = g:RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     g:Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  g:StopVimInTerminal(buf)\n  delete('XTest_compile_error')\n  delete('Xdir', 'rf')\nenddef\n\ndef Test_comment_error()\n  v9.CheckDefFailure(['#{ comment'], 'E1170:')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  v9.CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      var Object = {}\n      function Object.Method()\n      endfunction\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      vim9script\n      var Object = {}\n      def Object.Method()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      vim9script\n      g:Object = {}\n      function g:Object.Method()\n      endfunction\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      let s:Object = {}\n      def Define()\n        function s:Object.Method()\n        endfunction\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\n\n  lines =<< trim END\n      let s:Object = {}\n      def Define()\n        def Object.Method()\n        enddef\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\n\n  lines =<< trim END\n      let g:Object = {}\n      def Define()\n        function g:Object.Method()\n        endfunction\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      export def NoFunction()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  lines =<< trim END\n      call script#Function()\n  END\n  v9.CheckScriptFailure(lines, 'E117:', 1)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    v9.CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  v9.CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef s:CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef s:CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  v9.CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  v9.CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  g:ReturnString()->assert_equal('string')\n  g:ReturnNumber()->assert_equal(123)\n  assert_fails('g:ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\n\n  var lines =<< trim END\n      vim9script\n\n      def Msg()\n          echomsg 'in Msg()...'\n      enddef\n\n      def Func()\n        return Msg()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1096:')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif'\n                   '  return 3'\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  g:ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  v9.CheckScriptFailure(lines, 'E1010:')\n  v9.CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  # This used to fail but now the actual list type is checked, and since it has\n  # an item of type string it can be used as list<string>.\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_return_any_two_types()\n  var lines =<< trim END\n      vim9script\n\n      def G(Fn: func(string): any)\n        g:result = Fn(\"hello\")\n      enddef\n\n      def F(a: number, b: string): any\n        echo b\n        if a > 0\n          return 1\n        else\n          return []\n        endif\n      enddef\n\n      G(function(F, [1]))\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:result)\n  unlet g:result\nenddef\n\nfunc s:Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef Test_call_ufunc_failure()\n  var lines =<< trim END\n      vim9script\n      def Tryit()\n        g:Global(1, 2, 3)\n      enddef\n\n      func g:Global(a, b, c)\n        echo a:a a:b a:c\n      endfunc\n\n      defcompile\n\n      func! g:Global(a, b)\n        echo a:a a:b \n      endfunc\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E118: Too many arguments for function: Global')\n  delfunc g:Global\n\n  lines =<< trim END\n      vim9script\n\n      g:Ref = function('len')\n      def Tryit()\n        g:Ref('x')\n      enddef\n\n      defcompile\n\n      g:Ref = function('add')\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E119: Not enough arguments for function: add')\n  unlet g:Ref\nenddef\n\ndef s:MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  v9.CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef s:MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  g:MyDefaultArgs()->assert_equal('string')\n  g:MyDefaultArgs(v:none)->assert_equal('string')\n  g:MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('g:MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  v9.CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  v9.CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  v9.CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  v9.CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  v9.CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  v9.CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  v9.CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  v9.CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  v9.CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def _Inner()\n          echo 'bad'\n        enddef\n        _Inner()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:inner()\n          echo 'bad'\n        enddef\n        g:inner()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def g:_Func()\n        echo 'bad'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def _Func()\n        echo 'bad'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # nested function with recursive call\n  lines =<< trim END\n      vim9script\n\n      def MyFunc(): number\n        def Fib(n: number): number\n          if n < 2\n            return 1\n          endif\n          return Fib(n - 2) + Fib(n - 1)\n        enddef\n\n        return Fib(5)\n      enddef\n\n      assert_equal(8, MyFunc())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  v9.CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_function_not_found()\n  var lines =<< trim END\n      g:Ref = 123\n      call g:Ref()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E117:', 'E1085:'], 2)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      Funcy()\n  END\n  v9.CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  v9.CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is not found with g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n  END\n  v9.CheckScriptFailure(lines, 'E117:')\n  delfunc g:Func\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', g:Func())\n      delfunc g:Func\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # This does not shadow \"i\" which is visible only inside the for loop\n  lines =<< trim END\n      vim9script\n\n      def Foo(i: number)\n        echo i\n      enddef\n\n      for i in range(3)\n        # Foo() is compiled here\n        Foo(i)\n      endfor\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  v9.CheckDefFailure(['g:TakesOneArg()'], 'E119:')\n  v9.CheckDefFailure(['g:TakesOneArg(11, 22)'], 'E118:')\n  v9.CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  v9.CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  # argument name declared earlier is found when declaring a function\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo name\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # same, inside the same block\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # variable in other block is OK\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n    endif\n    def FuncOne(name: string)\n      echo name\n    enddef\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # with another variable in another block\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      # define a function so that the variable isn't cleared\n      def GetItem(): string\n        return item\n      enddef\n    endif\n    if true\n      var name = 'peter'\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # only variable in another block is OK\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      # define a function so that the variable isn't cleared\n      def GetItem(): string\n        return item\n      enddef\n    endif\n    if true\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # argument name declared later is only found when compiling\n  lines =<< trim END\n    vim9script\n    def FuncOne(name: string)\n      echo nr\n    enddef\n    var name = 'piet'\n  END\n  v9.CheckScriptSuccess(lines)\n  v9.CheckScriptFailure(lines + ['defcompile'], 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  delete('Xscript')\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  v9.CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  v9.CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  v9.CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  v9.CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  v9.CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  v9.CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo g:FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo g:FilterWithCond('foo', (v) => v .. '^b')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  v9.CheckDefSuccess([\n        'var x: any = \"aaa\"'\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(F: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(F: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func g:Getit()\n        return 'it'\n      endfunc\n      var Fn = g:Getit\n      assert_equal('it', Fn())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_define_lambda_in_execute()\n  var lines =<< trim [CODE]\n      vim9script\n\n      def BuildFuncMultiLine(): func\n          var x =<< trim END\n              g:SomeRandomFunc = (d: dict<any>) => {\n                  return d.k1 + d.k2\n              }\n          END\n          execute(x)\n          return g:SomeRandomFunc\n      enddef\n      var ResultPlus = BuildFuncMultiLine()\n      assert_equal(7, ResultPlus({k1: 3, k2: 4}))\n  [CODE]\n  v9.CheckScriptSuccess(lines)\n  unlet g:SomeRandomFunc\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('g:MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  g:MyDefVarargs('one')->assert_equal('one,foo')\n  g:MyDefVarargs('one', 'two')->assert_equal('one,two')\n  g:MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  v9.CheckDefFailure(['g:MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  v9.CheckDefFailure(['g:MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  v9.CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = g:FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = g:FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  v9.CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  v9.CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = g:FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  v9.CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  v9.CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  g:MyVarargsOnly()->assert_equal('')\n  g:MyVarargsOnly('one')->assert_equal('one')\n  g:MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  v9.CheckDefFailure(['g:MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  v9.CheckDefFailure(['g:MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  var lines =<< trim END\n      def Func(x: number)\n        var x = 234\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1006:')\n\n  lines =<< trim END\n      def Func(Ref: number)\n        def Ref()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1073:')\nenddef\n\ndef s:DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef s:ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  v9.CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef s:WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = function('s:func')\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = function(s:func)\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = s:func\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('g:FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_function_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\nenddef\n\ndef Test_nested_function_with_args_split()\n  var lines =<< trim END\n      vim9script\n      def FirstFunction()\n        def SecondFunction(\n        )\n        # had a double free if the right parenthesis of the nested function is\n        # on the next line\n         \n        enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\n\n  lines =<< trim END\n      vim9script\n      def FirstFunction()\n        func SecondFunction()\n        endfunc|BBBB\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')\nenddef\n\ndef Test_error_in_function_args()\n  var lines =<< trim END\n      def FirstFunction()\n        def SecondFunction(J  =\n        # Nois\n        # one\n         \n         enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_return_type_wrong()\n  v9.CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  v9.CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  v9.CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  v9.CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type>')\n  v9.CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  v9.CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  v9.CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  v9.CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  v9.CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim')\n  source Xcall.vim\n  delete('Xcall.vim')\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n  delete('Xcall_const.vim')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  v9.CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      g:GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n\n  delete('XToDelFunc')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  v9.CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func')\n  so XVim9Func\n\n  delete('XVim9Func')\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef s:FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef s:FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = g:FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = g:FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = g:FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = g:FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = g:FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = g:FuncNoArgNoRet\n  RefVoid = g:FuncOneArgNoRet\n  v9.CheckDefFailure(['var RefVoid: func: void', 'RefVoid = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  v9.CheckDefFailure(['var RefVoid: func: void', 'RefVoid = g:FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = g:FuncNoArgRetNumber\n  RefAny = g:FuncNoArgRetString\n  v9.CheckDefFailure(['var RefAny: func(): any', 'RefAny = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  v9.CheckDefFailure(['var RefAny: func(): any', 'RefAny = g:FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = g:FuncNoArgRetNumber\n  RefNr = g:FuncOneArgRetNumber\n  v9.CheckDefFailure(['var RefNr: func: number', 'RefNr = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  v9.CheckDefFailure(['var RefNr: func: number', 'RefNr = g:FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = g:FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  v9.CheckDefFailure(['var RefStr: func: string', 'RefStr = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  v9.CheckDefFailure(['var RefStr: func: string', 'RefStr = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  v9.CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  v9.CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  v9.CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  v9.CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  v9.CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  v9.CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  v9.CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  v9.CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = g:FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  v9.CheckDefFailure(['var str: string', 'str = g:FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef s:MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call s:MultiLine('text')->assert_equal('text1234')\n  call s:MultiLine('text', 777)->assert_equal('text777')\n  call s:MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call s:MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\n\n  delete('Xdef')\nenddef\n\ndef Test_deleted_function()\n  v9.CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  v9.CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef s:RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef s:MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef s:MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef s:ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef s:ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef s:MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef s:MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc s:GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  v9.CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  v9.CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def Func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], g:Shadowed())\nenddef\n\ndef Test_compiling_referenced_func_no_shadow()\n  var lines =<< trim END\n      vim9script\n\n      def InitializeReply(lspserver: dict<any>)\n      enddef\n\n      def ProcessReply(lspserver: dict<any>)\n        var lsp_reply_handlers: dict<func> =\n          { 'initialize': InitializeReply }\n        lsp_reply_handlers['initialize'](lspserver)\n      enddef\n\n      call ProcessReply({})\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    v9.CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = g:RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  g:VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\n  delete('XTest_silent_echo')\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc s:UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef s:TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'p')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\n\n  delete('XclosureDir', 'rf')\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  v9.CheckScriptFailure(lines, 'E1031:')\nenddef\n\ndef Test_partial_double_nested()\n  var idx = 123\n  var Get = () => idx\n  var Ref = function(Get, [])\n  var RefRef = function(Ref, [])\n  assert_equal(123, RefRef())\nenddef\n\ndef Test_partial_null_function()\n  var lines =<< trim END\n      var d: dict<func> = {f: null_function}\n      var Ref = d.f\n      assert_equal('func(...): unknown', typename(Ref))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\n\" Using \"idx\" from a legacy global function does not work.\n\" This caused a crash when called from legacy context.\nfunc Test_partial_call_fails()\n  let lines =<< trim END\n      vim9script\n\n      var l = ['a', 'b', 'c']\n      def Iter(container: any): any\n        var idx = -1\n        var obj = {state: container}\n        def g:NextItem__(self: dict<any>): any\n          ++idx\n          return self.state[idx]\n        enddef\n        obj.__next__ = function('g:NextItem__', [obj])\n        return obj\n      enddef\n\n      var it = Iter(l)\n      echo it.__next__()\n  END\n  call writefile(lines, 'XpartialCall')\n  try\n    source XpartialCall\n  catch /E1248:/\n  endtry\n  call delete('XpartialCall')\nendfunc\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  v9.CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  g:StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    g:StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n  delete('XemsgReset')\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname)\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\n  delete(fname)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=g:Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error')\n\n  var buf = g:RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  g:WaitForAssert(() => assert_match('E684: List index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  g:StopVimInTerminal(buf)\n  delete('XTest_opfunc_error')\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !g:RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_nested_closure_funcref()\n  var lines =<< trim END\n      vim9script\n      def Func()\n          var n: number\n          def Nested()\n              ++n\n          enddef\n          Nested()\n          g:result_one = n\n          var Ref = function(Nested)\n          Ref()\n          g:result_two = n\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:result_one)\n  assert_equal(2, g:result_two)\n  unlet g:result_one g:result_two\nenddef\n\ndef Test_nested_closure_in_dict()\n  var lines =<< trim END\n      vim9script\n      def Func(): dict<any>\n        var n: number\n        def Inc(): number\n          ++n\n          return n\n        enddef\n        return {inc: function(Inc)}\n      enddef\n      disas Func\n      var d = Func()\n      assert_equal(1, d.inc())\n      assert_equal(2, d.inc())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_script_local_other_script()\n  var lines =<< trim END\n      function LegacyJob()\n        let FuncRef = function('s:close_cb')\n      endfunction\n      function s:close_cb(...)\n      endfunction\n  END\n  lines->writefile('Xlegacy.vim')\n  source Xlegacy.vim\n  g:LegacyJob()\n  g:LegacyJob()\n  g:LegacyJob()\n\n  delfunc g:LegacyJob\n  delete('Xlegacy.vim')\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(Fg: func): dict<func>\n        return {f: Fg}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  v9.CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  v9.CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\n\n  v9.CheckScriptFailure(lines + ['def SomeFunc(ff: func)', 'enddef'], 'E704:')\nenddef\n\ndef Test_call_func_with_null()\n  var lines =<< trim END\n      def Fstring(v: string)\n        assert_equal(null_string, v)\n      enddef\n      Fstring(null_string)\n      def Fblob(v: blob)\n        assert_equal(null_blob, v)\n      enddef\n      Fblob(null_blob)\n      def Flist(v: list<number>)\n        assert_equal(null_list, v)\n      enddef\n      Flist(null_list)\n      def Fdict(v: dict<number>)\n        assert_equal(null_dict, v)\n      enddef\n      Fdict(null_dict)\n      def Ffunc(Fv: func(number): number)\n        assert_equal(null_function, Fv)\n      enddef\n      Ffunc(null_function)\n      if has('channel')\n        def Fchannel(v: channel)\n          assert_equal(null_channel, v)\n        enddef\n        Fchannel(null_channel)\n        def Fjob(v: job)\n          assert_equal(null_job, v)\n        enddef\n        Fjob(null_job)\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_null_default_argument()\n  var lines =<< trim END\n      def Fstring(v: string = null_string)\n        assert_equal(null_string, v)\n      enddef\n      Fstring()\n      def Fblob(v: blob = null_blob)\n        assert_equal(null_blob, v)\n      enddef\n      Fblob()\n      def Flist(v: list<number> = null_list)\n        assert_equal(null_list, v)\n      enddef\n      Flist()\n      def Fdict(v: dict<number> = null_dict)\n        assert_equal(null_dict, v)\n      enddef\n      Fdict()\n      def Ffunc(Fv: func(number): number = null_function)\n        assert_equal(null_function, Fv)\n      enddef\n      Ffunc()\n      if has('channel')\n        def Fchannel(v: channel = null_channel)\n          assert_equal(null_channel, v)\n        enddef\n        Fchannel()\n        def Fjob(v: job = null_job)\n          assert_equal(null_job, v)\n        enddef\n        Fjob()\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_null_return()\n  var lines =<< trim END\n      def Fstring(): string\n        return null_string\n      enddef\n      assert_equal(null_string, Fstring())\n      def Fblob(): blob\n        return null_blob\n      enddef\n      assert_equal(null_blob, Fblob())\n      def Flist(): list<number>\n        return null_list\n      enddef\n      assert_equal(null_list, Flist())\n      def Fdict(): dict<number>\n        return null_dict\n      enddef\n      assert_equal(null_dict, Fdict())\n      def Ffunc(): func(number): number\n        return null_function\n      enddef\n      assert_equal(null_function, Ffunc())\n      if has('channel')\n        def Fchannel(): channel\n          return null_channel\n        enddef\n        assert_equal(null_channel, Fchannel())\n        def Fjob(): job\n          return null_job\n        enddef\n        assert_equal(null_job, Fjob())\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  # \"any\" could be \"dict<any>\", thus OK\n  lines[2] = 'var l: list<any>'\n  v9.CheckScriptSuccess(lines)\n  lines[2] = 'var l: list<any> = []'\n  v9.CheckScriptSuccess(lines)\n\n  lines[2] = 'var l: list<any> = [11]'\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  v9.CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E176:', 'E1106: 2 arguments too many'], 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E176', 'E1106: One argument too many'], 1)\n\n  lines =<< trim END\n      vim9script\n      def OneArgument(arg: string)\n        echo arg\n      enddef\n      var Ref = OneArgument\n      Ref('a', 'b')\n  END\n  v9.CheckScriptFailure(lines, 'E118:')\nenddef\n\ndef Test_funcref_with_base()\n  var lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      Ref('a', 12)\n      'b'->Ref(34)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      'a'->Ref('b')\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string', 6)\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      123->Ref(456)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(nr: number, str: string)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      123->Ref('b')\n      def AndNowCompiled()\n        456->Ref('x')\n      enddef\n      AndNowCompiled()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc s:CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\ndef Test_go_beyond_end_of_cmd()\n  # this was reading the byte after the end of the line\n  var lines =<< trim END\n    def F()\n      cal\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E476:')\nenddef\n\n\" Test for memory allocation failure when defining a new lambda\nfunc Test_lambda_allocation_failure()\n  new\n  let lines =<< trim END\n    vim9script\n    g:Xlambda = (x): number => {\n        return x + 1\n      }\n  END\n  call setline(1, lines)\n  call test_alloc_fail(GetAllocId('get_func'), 0, 0)\n  call assert_fails('source', 'E342:')\n  call assert_false(exists('g:Xlambda'))\n  bw!\nendfunc\n\ndef Test_multiple_funcref()\n  # This was using a NULL pointer\n  var lines =<< trim END\n      vim9script\n      def A(F: func, ...args: list<any>): func\n          return funcref(F, args)\n      enddef\n\n      def B(F: func): func\n          return funcref(A, [F])\n      enddef\n\n      def Test(n: number)\n      enddef\n\n      const X = B(Test)\n      X(1)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # slightly different case\n  lines =<< trim END\n      vim9script\n\n      def A(F: func, ...args: list<any>): any\n          return call(F, args)\n      enddef\n\n      def B(F: func): func\n          return funcref(A, [F])\n      enddef\n\n      def Test(n: number)\n      enddef\n\n      const X = B(Test)\n      X(1)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cexpr_errmsg_line_number()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var qfl = {}\n        cexpr qfl\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E777', 2)\nenddef\n\n\" The following messes up syntax highlight, keep near the end.\nif has('python3')\n  def Test_python3_command()\n    py3 import vim\n    py3 vim.command(\"g:done = 'yes'\")\n    assert_equal('yes', g:done)\n    unlet g:done\n  enddef\n\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\n\n  def Test_lua_heredoc_fails()\n    var lines = [\n      'vim9script',\n      'def ExeLua()',\n        'lua << trim EOLUA',\n            \"x = vim.eval('g:nodict')\",\n        'EOLUA',\n      'enddef',\n      'ExeLua()',\n      ]\n    v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:nodict')\n  enddef\nendif\n\nif has('perl')\n  def Test_perl_heredoc_nested()\n    var lines =<< trim END\n        vim9script\n        def F(): string\n            def G(): string\n                perl << EOF\n        EOF\n                return 'done'\n            enddef\n            return G()\n        enddef\n        assert_equal('done', F())\n    END\n    v9.CheckScriptSuccess(lines)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\t// Not in a function scope, find variable with block ID equal to or\n\t// smaller than the current block id.  Use \"cstack\" to go up the block\n\t// scopes.\n\twhile (sav != NULL)\n\t{\n\t    int idx;\n\n\t    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\t\tif (cstack->cs_block_id[idx] == sav->sav_block_id)\n\t\t    break;\n\t    if (idx >= 0)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, variable was not visible.\n    return NULL;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx, cstack) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx, NULL) == OK\n\t    || find_imported(name, len, FALSE) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.  Or commands are being skipped, a declaration may have\n * been skipped then.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    return variable_exists(name, len, cctx);\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(\n\tchar_u\t    *p,\n\tsize_t\t    len,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack,\n\tint\t    is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx, cstack) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, FALSE) != NULL\n\t    || (ufunc = find_func_even_dead(p, 0)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If actual a constant a runtime check makes no sense.  If it's\n    // null_function it is OK.\n    if (actual_is_const && ret == MAYBE && actual == &t_func_unknown)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset,\n\t\t\t\t\t    where.wt_variable, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Reserve space for a local variable.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tisConst,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = isConst;\n    lvar->lv_type = type;\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(\n\tint\t    sid,\n\tchar_u\t    *name,\n\tint\t    check_writable,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx, cstack);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n    {\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    hashitem_T *hi;\n\n\t    // A variable exported from an autoload script is in the global\n\t    // variables, we can find it in the all_vars table.\n\t    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn HI2SAV(hi)->sav_var_vals_idx;\n\t}\n\treturn -2;\n    }\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n    static imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Find \"name\" in imported items of the current script.\n * If \"len\" is 0 use any length that works.\n * If \"load\" is TRUE and the script was not loaded yet, load it now.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, int load)\n{\n    imported_T\t    *ret;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n\n    ret = find_imported_in_script(name, len, current_sctx.sc_sid);\n    if (ret != NULL && load && (ret->imp_flags & IMP_FLAGS_AUTOLOAD))\n    {\n\tscid_T\tdummy;\n\tint\tsave_emsg_off = emsg_off;\n\n\t// \"emsg_off\" will be set when evaluating an expression silently, but\n\t// we do want to know about errors in a script.  Also because it then\n\t// aborts when an error is encountered.\n\temsg_off = FALSE;\n\n\t// script found before but not loaded yet\n\tret->imp_flags &= ~IMP_FLAGS_AUTOLOAD;\n\t(void)do_source(SCRIPT_ITEM(ret->imp_sid)->sn_name, FALSE,\n\t\t\t\t\t\t\t    DOSO_NONE, &dummy);\n\n\temsg_off = save_emsg_off;\n    }\n    return ret;\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n    eap->skip = cctx->ctx_skip == SKIP_YES;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    if (*skipwhite(name_end) == '.')\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->cmd);\n\t    else\n\t\tsemsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip != SKIP_YES\n\t    && check_defined(name_start, name_end - name_start, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\treturn NULL;\n    if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_str), name_start);\n\treturn NULL;\n    }\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, lines_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    // Define the funcref before compiling, so that it is found by any\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    // If a FUNCREF instruction was generated, set the index after compiling.\n    if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)\n\tfuncref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Compile one Vim expression {expr} in string \"p\".\n * \"p\" points to the opening \"{\".\n * Return a pointer to the character after \"}\", NULL for an error.\n */\n    char_u *\ncompile_one_expr_in_str(char_u *p, cctx_T *cctx)\n{\n    char_u\t*block_start;\n    char_u\t*block_end;\n\n    // Skip the opening {.\n    block_start = skipwhite(p + 1);\n    block_end = block_start;\n    if (*block_start != NUL && skip_expr(&block_end, NULL) == FAIL)\n\treturn NULL;\n    block_end = skipwhite(block_end);\n    // The block must be closed by a }.\n    if (*block_end != '}')\n    {\n\tsemsg(_(e_missing_close_curly_str), p);\n\treturn NULL;\n    }\n    if (compile_expr0(&block_start, cctx) == FAIL)\n\treturn NULL;\n    may_generate_2STRING(-1, TRUE, cctx);\n\n    return block_end + 1;\n}\n\n/*\n * Compile a string \"str\" (either containing a literal string or a mix of\n * literal strings and Vim expressions of the form `{expr}`).  This is used\n * when compiling a heredoc assignment to a variable or an interpolated string\n * in a Vim9 def function.  Vim9 instructions are generated to push strings,\n * evaluate expressions, concatenate them and create a list of lines.  When\n * \"evalstr\" is TRUE, Vim expressions in \"str\" are evaluated.\n */\n    int\ncompile_all_expr_in_str(char_u *str, int evalstr, cctx_T *cctx)\n{\n    char_u\t*p = str;\n    char_u\t*val;\n    int\t\tcount = 0;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (!evalstr || *str == NUL)\n    {\n\t// Literal string, possibly empty.\n\tval = *str != NUL ? vim_strsave(str) : NULL;\n\treturn generate_PUSHS(cctx, &val);\n    }\n\n    // Push all the string pieces to the stack, followed by a ISN_CONCAT.\n    while (*p != NUL)\n    {\n\tchar_u\t*lit_start;\n\tint\tescaped_brace = FALSE;\n\n\t// Look for a block start.\n\tlit_start = p;\n\twhile (*p != '{' && *p != '}' && *p != NUL)\n\t    ++p;\n\n\tif (*p != NUL && *p == p[1])\n\t{\n\t    // Escaped brace, unescape and continue.\n\t    // Include the brace in the literal string.\n\t    ++p;\n\t    escaped_brace = TRUE;\n\t}\n\telse if (*p == '}')\n\t{\n\t    semsg(_(e_stray_closing_curly_str), str);\n\t    return FAIL;\n\t}\n\n\t// Append the literal part.\n\tif (p != lit_start)\n\t{\n\t    val = vim_strnsave(lit_start, (size_t)(p - lit_start));\n\t    if (generate_PUSHS(cctx, &val) == FAIL)\n\t\treturn FAIL;\n\t    ++count;\n\t}\n\n\tif (*p == NUL)\n\t    break;\n\n\tif (escaped_brace)\n\t{\n\t    // Skip the second brace.\n\t    ++p;\n\t    continue;\n\t}\n\n\tp = compile_one_expr_in_str(p, cctx);\n\tif (p == NULL)\n\t    return FAIL;\n\t++count;\n    }\n\n    // Small optimization, if there's only a single piece skip the ISN_CONCAT.\n    if (count > 1)\n\treturn generate_CONCAT(cctx, count);\n\n    return OK;\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tcmdidx_T\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(cmdidx_T cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t    cctx, NULL)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t    cctx, NULL)) == OK;\n\t\timported_T  *import =\n\t\t\t      find_imported(var_start, lhs->lhs_varlen, FALSE);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (script_namespace && current_script_is_vim9())\n\t\t    {\n\t\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t   cctx, NULL);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl || (lhs->lhs_has_index && !has_cmd\n\t\t\t\t\t\t&& cctx->ctx_skip != SKIP_YES))\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t    cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl && cctx->ctx_skip != SKIP_YES)\n\t{\n\t    if (has_cmd)\n\t\temsg(_(e_cannot_use_index_when_declaring_variable));\n\t    else\n\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    is_decl,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, has_cmd, oplen, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -2, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type->tt_type != VAR_SPECIAL)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"varname\" or \"[varname, varname]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n    else\n    {\n\tsp = p;\n\tp = skipwhite(p);\n\top = p;\n\toplen = assignment_len(p, &heredoc);\n\n\tif (var_count > 0 && oplen == 0)\n\t    // can be something like \"[1, 2]->func()\"\n\t    return arg;\n\n\tif (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n\t{\n\t    error_white_both(op, oplen);\n\t    return NULL;\n\t}\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE, TRUE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t    needed_list_len, (int)isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\ttype_T\t*inferred_type = NULL;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\tis_decl, heredoc, var_start > eap->cmd,\n\t\t\t\toplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t\tif (r == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_any;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlhs.lhs_lvar->lv_type = rhs_type;\n\t\t\t\tinferred_type = rhs_type;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t\t\tcctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tint r = OK;\n\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tr = generate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t\tr = generate_PUSHF(cctx, 0.0);\n#endif\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tr = generate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tr = generate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tr = generate_PUSHFUNC(cctx, NULL, &t_func_void);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tr = generate_NEWLIST(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tr = generate_NEWDICT(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tr = generate_PUSHJOB(cctx);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tr = generate_PUSHCHANNEL(cctx);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are always\n\t\t\t// initialized to zero.  But in a \"for\" or \"while\" loop\n\t\t\t// the value may have been changed.\n\t\t\tif (lhs.lhs_dest == dest_local\n\t\t\t\t\t\t   && !inside_loop_scope(cctx))\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    instr_count = instr->ga_len;\n\t\t\t    r = generate_PUSHNR(cctx, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (r == FAIL)\n\t\t    goto theend;\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = get_type_on_stack(cctx, 0);\n\t\tif (\n#ifdef FEAT_FLOAT\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n#endif\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_CONCAT(cctx, 2) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if ((lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && lhs.lhs_type->tt_member != &t_any\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\t    else if (inferred_type != NULL\n\t\t    && (inferred_type->tt_type == VAR_DICT\n\t\t\t\t\t|| inferred_type->tt_type == VAR_LIST)\n\t\t    && inferred_type->tt_member != NULL\n\t\t    && inferred_type->tt_member != &t_unknown\n\t\t    && inferred_type->tt_member != &t_any)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, inferred_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    // \"g:var = expr\"\n\t    // \"g:[key] = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// might be \"[var, var] = expr\"\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n/*\n * Check if arguments of \"ufunc\" shadow variables in \"cctx\".\n * Return OK or FAIL.\n */\n    static int\ncheck_args_shadowing(ufunc_T *ufunc, cctx_T *cctx)\n{\n    int\t    i;\n    char_u  *arg;\n    int\t    r = OK;\n\n    // Make sure arguments are not found when compiling a second time.\n    ufunc->uf_args_visible = 0;\n\n    // Check for arguments shadowing variables from the context.\n    for (i = 0; i < ufunc->uf_args.ga_len; ++i)\n    {\n\targ = ((char_u **)(ufunc->uf_args.ga_data))[i];\n\tif (check_defined(arg, STRLEN(arg), cctx, NULL, TRUE) == FAIL)\n\t{\n\t    r = FAIL;\n\t    break;\n\t}\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n    return r;\n}\n\n/*\n * Get the compilation type that should be used for \"ufunc\".\n * Keep in sync with INSTRUCTIONS().\n */\n    compiletype_T\nget_compile_type(ufunc_T *ufunc)\n{\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    if (debug_break_level > 0 || may_break_in_function(ufunc))\n\treturn CT_DEBUG;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tif (!ufunc->uf_profiling && has_profiling(FALSE, ufunc->uf_name, NULL))\n\t    func_do_profile(ufunc);\n\tif (ufunc->uf_profiling)\n\t    return CT_PROFILE;\n    }\n#endif\n    return CT_NONE;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    garray_T\tlines_to_free;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // allocated lines are freed at the end\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    if ((ufunc->uf_flags & FC_CLOSURE) && outer_cctx == NULL)\n    {\n\tsemsg(_(e_compiling_closure_without_context_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\tea.skip = cctx.ctx_skip == SKIP_YES;\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment, but \"#{\" is an error\n\t    if (vim9_bad_comment(ea.cmd))\n\t\tgoto erret;\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    goto erret;\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * 0z1234->func() should not be confused with a zero line number\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t * \"123->func()\" is a method call\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon\n\t\t    || !(*cmd == '\\''\n\t\t\t|| (cmd[0] == '0' && cmd[1] == 'z')\n\t\t\t|| (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-'))\n\t\t\t|| number_method(cmd))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\tsemsg(_(e_ambiguous_use_of_user_defined_command_str), ea.cmd);\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    // \"eval\" is used for \"val->func()\" and \"var\" for \"var = val\", then\n\t    // \"p\" is equal to \"ea.cmd\" for a valid command.\n\t    if (ea.cmdidx == CMD_eval || ea.cmdidx == CMD_var)\n\t\t;\n\t    else if (cctx.ctx_skip == SKIP_YES)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t    if ((ea.argt & EX_RANGE) == 0 && ea.addr_count > 0)\n\t    {\n\t\temsg(_(e_no_range_allowed));\n\t\tgoto erret;\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t    {\n\t\t\temsg(_(e_invalid_assignment));\n\t\t\tline = NULL;\n\t\t    }\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_vim9script:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\temsg(_(e_vim9script_can_only_be_used_in_script));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    ga_clear_strings(&lines_to_free);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n"], "fixing_code": ["\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error')\n  var buf = g:RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     g:Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  g:StopVimInTerminal(buf)\n  delete('XTest_compile_error')\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      export def OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xdir'\n  writefile(lines, 'XTest_compile_error')\n\n  var buf = g:RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     g:Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  g:StopVimInTerminal(buf)\n  delete('XTest_compile_error')\n  delete('Xdir', 'rf')\nenddef\n\ndef Test_comment_error()\n  v9.CheckDefFailure(['#{ comment'], 'E1170:')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  v9.CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      var Object = {}\n      function Object.Method()\n      endfunction\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      vim9script\n      var Object = {}\n      def Object.Method()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      vim9script\n      g:Object = {}\n      function g:Object.Method()\n      endfunction\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      let s:Object = {}\n      def Define()\n        function s:Object.Method()\n        endfunction\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\n\n  lines =<< trim END\n      let s:Object = {}\n      def Define()\n        def Object.Method()\n        enddef\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\n\n  lines =<< trim END\n      let g:Object = {}\n      def Define()\n        function g:Object.Method()\n        endfunction\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      export def NoFunction()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  lines =<< trim END\n      call script#Function()\n  END\n  v9.CheckScriptFailure(lines, 'E117:', 1)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    v9.CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  v9.CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef s:CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef s:CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  v9.CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  v9.CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  g:ReturnString()->assert_equal('string')\n  g:ReturnNumber()->assert_equal(123)\n  assert_fails('g:ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\n\n  var lines =<< trim END\n      vim9script\n\n      def Msg()\n          echomsg 'in Msg()...'\n      enddef\n\n      def Func()\n        return Msg()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1096:')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif'\n                   '  return 3'\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  g:ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  v9.CheckScriptFailure(lines, 'E1010:')\n  v9.CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  # This used to fail but now the actual list type is checked, and since it has\n  # an item of type string it can be used as list<string>.\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_return_any_two_types()\n  var lines =<< trim END\n      vim9script\n\n      def G(Fn: func(string): any)\n        g:result = Fn(\"hello\")\n      enddef\n\n      def F(a: number, b: string): any\n        echo b\n        if a > 0\n          return 1\n        else\n          return []\n        endif\n      enddef\n\n      G(function(F, [1]))\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:result)\n  unlet g:result\nenddef\n\nfunc s:Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef Test_call_ufunc_failure()\n  var lines =<< trim END\n      vim9script\n      def Tryit()\n        g:Global(1, 2, 3)\n      enddef\n\n      func g:Global(a, b, c)\n        echo a:a a:b a:c\n      endfunc\n\n      defcompile\n\n      func! g:Global(a, b)\n        echo a:a a:b \n      endfunc\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E118: Too many arguments for function: Global')\n  delfunc g:Global\n\n  lines =<< trim END\n      vim9script\n\n      g:Ref = function('len')\n      def Tryit()\n        g:Ref('x')\n      enddef\n\n      defcompile\n\n      g:Ref = function('add')\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E119: Not enough arguments for function: add')\n  unlet g:Ref\nenddef\n\ndef s:MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  v9.CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef s:MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  g:MyDefaultArgs()->assert_equal('string')\n  g:MyDefaultArgs(v:none)->assert_equal('string')\n  g:MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('g:MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  v9.CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  v9.CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  v9.CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  v9.CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  v9.CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  v9.CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  v9.CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  v9.CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  v9.CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def _Inner()\n          echo 'bad'\n        enddef\n        _Inner()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:inner()\n          echo 'bad'\n        enddef\n        g:inner()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def g:_Func()\n        echo 'bad'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def _Func()\n        echo 'bad'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # nested function with recursive call\n  lines =<< trim END\n      vim9script\n\n      def MyFunc(): number\n        def Fib(n: number): number\n          if n < 2\n            return 1\n          endif\n          return Fib(n - 2) + Fib(n - 1)\n        enddef\n\n        return Fib(5)\n      enddef\n\n      assert_equal(8, MyFunc())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_nested_function_fails()\n  var lines =<< trim END\n      def T()\n        def Func(g: string):string\n        enddef\n        Func()\n      enddef\n      silent! defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  v9.CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_function_not_found()\n  var lines =<< trim END\n      g:Ref = 123\n      call g:Ref()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E117:', 'E1085:'], 2)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      Funcy()\n  END\n  v9.CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  v9.CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is not found with g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n  END\n  v9.CheckScriptFailure(lines, 'E117:')\n  delfunc g:Func\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', g:Func())\n      delfunc g:Func\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # This does not shadow \"i\" which is visible only inside the for loop\n  lines =<< trim END\n      vim9script\n\n      def Foo(i: number)\n        echo i\n      enddef\n\n      for i in range(3)\n        # Foo() is compiled here\n        Foo(i)\n      endfor\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  v9.CheckDefFailure(['g:TakesOneArg()'], 'E119:')\n  v9.CheckDefFailure(['g:TakesOneArg(11, 22)'], 'E118:')\n  v9.CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  v9.CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  # argument name declared earlier is found when declaring a function\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo name\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # same, inside the same block\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # variable in other block is OK\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n    endif\n    def FuncOne(name: string)\n      echo name\n    enddef\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # with another variable in another block\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      # define a function so that the variable isn't cleared\n      def GetItem(): string\n        return item\n      enddef\n    endif\n    if true\n      var name = 'peter'\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # only variable in another block is OK\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      # define a function so that the variable isn't cleared\n      def GetItem(): string\n        return item\n      enddef\n    endif\n    if true\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # argument name declared later is only found when compiling\n  lines =<< trim END\n    vim9script\n    def FuncOne(name: string)\n      echo nr\n    enddef\n    var name = 'piet'\n  END\n  v9.CheckScriptSuccess(lines)\n  v9.CheckScriptFailure(lines + ['defcompile'], 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  delete('Xscript')\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  v9.CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  v9.CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  v9.CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  v9.CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  v9.CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  v9.CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo g:FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo g:FilterWithCond('foo', (v) => v .. '^b')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  v9.CheckDefSuccess([\n        'var x: any = \"aaa\"'\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(F: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(F: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func g:Getit()\n        return 'it'\n      endfunc\n      var Fn = g:Getit\n      assert_equal('it', Fn())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_define_lambda_in_execute()\n  var lines =<< trim [CODE]\n      vim9script\n\n      def BuildFuncMultiLine(): func\n          var x =<< trim END\n              g:SomeRandomFunc = (d: dict<any>) => {\n                  return d.k1 + d.k2\n              }\n          END\n          execute(x)\n          return g:SomeRandomFunc\n      enddef\n      var ResultPlus = BuildFuncMultiLine()\n      assert_equal(7, ResultPlus({k1: 3, k2: 4}))\n  [CODE]\n  v9.CheckScriptSuccess(lines)\n  unlet g:SomeRandomFunc\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('g:MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  g:MyDefVarargs('one')->assert_equal('one,foo')\n  g:MyDefVarargs('one', 'two')->assert_equal('one,two')\n  g:MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  v9.CheckDefFailure(['g:MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  v9.CheckDefFailure(['g:MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  v9.CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = g:FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = g:FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  v9.CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  v9.CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = g:FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  v9.CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  v9.CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  g:MyVarargsOnly()->assert_equal('')\n  g:MyVarargsOnly('one')->assert_equal('one')\n  g:MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  v9.CheckDefFailure(['g:MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  v9.CheckDefFailure(['g:MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  var lines =<< trim END\n      def Func(x: number)\n        var x = 234\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1006:')\n\n  lines =<< trim END\n      def Func(Ref: number)\n        def Ref()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1073:')\nenddef\n\ndef s:DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef s:ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  v9.CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef s:WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = function('s:func')\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = function(s:func)\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = s:func\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('g:FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_function_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\nenddef\n\ndef Test_nested_function_with_args_split()\n  var lines =<< trim END\n      vim9script\n      def FirstFunction()\n        def SecondFunction(\n        )\n        # had a double free if the right parenthesis of the nested function is\n        # on the next line\n         \n        enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\n\n  lines =<< trim END\n      vim9script\n      def FirstFunction()\n        func SecondFunction()\n        endfunc|BBBB\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')\nenddef\n\ndef Test_error_in_function_args()\n  var lines =<< trim END\n      def FirstFunction()\n        def SecondFunction(J  =\n        # Nois\n        # one\n         \n         enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_return_type_wrong()\n  v9.CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  v9.CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  v9.CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  v9.CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type>')\n  v9.CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  v9.CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  v9.CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  v9.CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  v9.CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim')\n  source Xcall.vim\n  delete('Xcall.vim')\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n  delete('Xcall_const.vim')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  v9.CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      g:GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n\n  delete('XToDelFunc')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  v9.CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func')\n  so XVim9Func\n\n  delete('XVim9Func')\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef s:FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef s:FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = g:FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = g:FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = g:FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = g:FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = g:FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = g:FuncNoArgNoRet\n  RefVoid = g:FuncOneArgNoRet\n  v9.CheckDefFailure(['var RefVoid: func: void', 'RefVoid = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  v9.CheckDefFailure(['var RefVoid: func: void', 'RefVoid = g:FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = g:FuncNoArgRetNumber\n  RefAny = g:FuncNoArgRetString\n  v9.CheckDefFailure(['var RefAny: func(): any', 'RefAny = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  v9.CheckDefFailure(['var RefAny: func(): any', 'RefAny = g:FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = g:FuncNoArgRetNumber\n  RefNr = g:FuncOneArgRetNumber\n  v9.CheckDefFailure(['var RefNr: func: number', 'RefNr = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  v9.CheckDefFailure(['var RefNr: func: number', 'RefNr = g:FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = g:FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  v9.CheckDefFailure(['var RefStr: func: string', 'RefStr = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  v9.CheckDefFailure(['var RefStr: func: string', 'RefStr = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  v9.CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  v9.CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  v9.CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  v9.CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  v9.CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  v9.CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  v9.CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  v9.CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = g:FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  v9.CheckDefFailure(['var str: string', 'str = g:FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef s:MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call s:MultiLine('text')->assert_equal('text1234')\n  call s:MultiLine('text', 777)->assert_equal('text777')\n  call s:MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call s:MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\n\n  delete('Xdef')\nenddef\n\ndef Test_deleted_function()\n  v9.CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  v9.CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef s:RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef s:MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef s:MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef s:ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef s:ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef s:MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef s:MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc s:GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  v9.CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  v9.CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def Func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], g:Shadowed())\nenddef\n\ndef Test_compiling_referenced_func_no_shadow()\n  var lines =<< trim END\n      vim9script\n\n      def InitializeReply(lspserver: dict<any>)\n      enddef\n\n      def ProcessReply(lspserver: dict<any>)\n        var lsp_reply_handlers: dict<func> =\n          { 'initialize': InitializeReply }\n        lsp_reply_handlers['initialize'](lspserver)\n      enddef\n\n      call ProcessReply({})\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    v9.CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = g:RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  g:VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\n  delete('XTest_silent_echo')\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc s:UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef s:TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'p')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\n\n  delete('XclosureDir', 'rf')\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  v9.CheckScriptFailure(lines, 'E1031:')\nenddef\n\ndef Test_partial_double_nested()\n  var idx = 123\n  var Get = () => idx\n  var Ref = function(Get, [])\n  var RefRef = function(Ref, [])\n  assert_equal(123, RefRef())\nenddef\n\ndef Test_partial_null_function()\n  var lines =<< trim END\n      var d: dict<func> = {f: null_function}\n      var Ref = d.f\n      assert_equal('func(...): unknown', typename(Ref))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\n\" Using \"idx\" from a legacy global function does not work.\n\" This caused a crash when called from legacy context.\nfunc Test_partial_call_fails()\n  let lines =<< trim END\n      vim9script\n\n      var l = ['a', 'b', 'c']\n      def Iter(container: any): any\n        var idx = -1\n        var obj = {state: container}\n        def g:NextItem__(self: dict<any>): any\n          ++idx\n          return self.state[idx]\n        enddef\n        obj.__next__ = function('g:NextItem__', [obj])\n        return obj\n      enddef\n\n      var it = Iter(l)\n      echo it.__next__()\n  END\n  call writefile(lines, 'XpartialCall')\n  try\n    source XpartialCall\n  catch /E1248:/\n  endtry\n  call delete('XpartialCall')\nendfunc\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  v9.CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  g:StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    g:StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n  delete('XemsgReset')\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname)\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\n  delete(fname)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=g:Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error')\n\n  var buf = g:RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  g:WaitForAssert(() => assert_match('E684: List index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  g:StopVimInTerminal(buf)\n  delete('XTest_opfunc_error')\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !g:RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_nested_closure_funcref()\n  var lines =<< trim END\n      vim9script\n      def Func()\n          var n: number\n          def Nested()\n              ++n\n          enddef\n          Nested()\n          g:result_one = n\n          var Ref = function(Nested)\n          Ref()\n          g:result_two = n\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:result_one)\n  assert_equal(2, g:result_two)\n  unlet g:result_one g:result_two\nenddef\n\ndef Test_nested_closure_in_dict()\n  var lines =<< trim END\n      vim9script\n      def Func(): dict<any>\n        var n: number\n        def Inc(): number\n          ++n\n          return n\n        enddef\n        return {inc: function(Inc)}\n      enddef\n      disas Func\n      var d = Func()\n      assert_equal(1, d.inc())\n      assert_equal(2, d.inc())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_script_local_other_script()\n  var lines =<< trim END\n      function LegacyJob()\n        let FuncRef = function('s:close_cb')\n      endfunction\n      function s:close_cb(...)\n      endfunction\n  END\n  lines->writefile('Xlegacy.vim')\n  source Xlegacy.vim\n  g:LegacyJob()\n  g:LegacyJob()\n  g:LegacyJob()\n\n  delfunc g:LegacyJob\n  delete('Xlegacy.vim')\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(Fg: func): dict<func>\n        return {f: Fg}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  v9.CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  v9.CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\n\n  v9.CheckScriptFailure(lines + ['def SomeFunc(ff: func)', 'enddef'], 'E704:')\nenddef\n\ndef Test_call_func_with_null()\n  var lines =<< trim END\n      def Fstring(v: string)\n        assert_equal(null_string, v)\n      enddef\n      Fstring(null_string)\n      def Fblob(v: blob)\n        assert_equal(null_blob, v)\n      enddef\n      Fblob(null_blob)\n      def Flist(v: list<number>)\n        assert_equal(null_list, v)\n      enddef\n      Flist(null_list)\n      def Fdict(v: dict<number>)\n        assert_equal(null_dict, v)\n      enddef\n      Fdict(null_dict)\n      def Ffunc(Fv: func(number): number)\n        assert_equal(null_function, Fv)\n      enddef\n      Ffunc(null_function)\n      if has('channel')\n        def Fchannel(v: channel)\n          assert_equal(null_channel, v)\n        enddef\n        Fchannel(null_channel)\n        def Fjob(v: job)\n          assert_equal(null_job, v)\n        enddef\n        Fjob(null_job)\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_null_default_argument()\n  var lines =<< trim END\n      def Fstring(v: string = null_string)\n        assert_equal(null_string, v)\n      enddef\n      Fstring()\n      def Fblob(v: blob = null_blob)\n        assert_equal(null_blob, v)\n      enddef\n      Fblob()\n      def Flist(v: list<number> = null_list)\n        assert_equal(null_list, v)\n      enddef\n      Flist()\n      def Fdict(v: dict<number> = null_dict)\n        assert_equal(null_dict, v)\n      enddef\n      Fdict()\n      def Ffunc(Fv: func(number): number = null_function)\n        assert_equal(null_function, Fv)\n      enddef\n      Ffunc()\n      if has('channel')\n        def Fchannel(v: channel = null_channel)\n          assert_equal(null_channel, v)\n        enddef\n        Fchannel()\n        def Fjob(v: job = null_job)\n          assert_equal(null_job, v)\n        enddef\n        Fjob()\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_null_return()\n  var lines =<< trim END\n      def Fstring(): string\n        return null_string\n      enddef\n      assert_equal(null_string, Fstring())\n      def Fblob(): blob\n        return null_blob\n      enddef\n      assert_equal(null_blob, Fblob())\n      def Flist(): list<number>\n        return null_list\n      enddef\n      assert_equal(null_list, Flist())\n      def Fdict(): dict<number>\n        return null_dict\n      enddef\n      assert_equal(null_dict, Fdict())\n      def Ffunc(): func(number): number\n        return null_function\n      enddef\n      assert_equal(null_function, Ffunc())\n      if has('channel')\n        def Fchannel(): channel\n          return null_channel\n        enddef\n        assert_equal(null_channel, Fchannel())\n        def Fjob(): job\n          return null_job\n        enddef\n        assert_equal(null_job, Fjob())\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  # \"any\" could be \"dict<any>\", thus OK\n  lines[2] = 'var l: list<any>'\n  v9.CheckScriptSuccess(lines)\n  lines[2] = 'var l: list<any> = []'\n  v9.CheckScriptSuccess(lines)\n\n  lines[2] = 'var l: list<any> = [11]'\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  v9.CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E176:', 'E1106: 2 arguments too many'], 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E176', 'E1106: One argument too many'], 1)\n\n  lines =<< trim END\n      vim9script\n      def OneArgument(arg: string)\n        echo arg\n      enddef\n      var Ref = OneArgument\n      Ref('a', 'b')\n  END\n  v9.CheckScriptFailure(lines, 'E118:')\nenddef\n\ndef Test_funcref_with_base()\n  var lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      Ref('a', 12)\n      'b'->Ref(34)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      'a'->Ref('b')\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string', 6)\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      123->Ref(456)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(nr: number, str: string)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      123->Ref('b')\n      def AndNowCompiled()\n        456->Ref('x')\n      enddef\n      AndNowCompiled()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc s:CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\ndef Test_go_beyond_end_of_cmd()\n  # this was reading the byte after the end of the line\n  var lines =<< trim END\n    def F()\n      cal\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E476:')\nenddef\n\n\" Test for memory allocation failure when defining a new lambda\nfunc Test_lambda_allocation_failure()\n  new\n  let lines =<< trim END\n    vim9script\n    g:Xlambda = (x): number => {\n        return x + 1\n      }\n  END\n  call setline(1, lines)\n  call test_alloc_fail(GetAllocId('get_func'), 0, 0)\n  call assert_fails('source', 'E342:')\n  call assert_false(exists('g:Xlambda'))\n  bw!\nendfunc\n\ndef Test_multiple_funcref()\n  # This was using a NULL pointer\n  var lines =<< trim END\n      vim9script\n      def A(F: func, ...args: list<any>): func\n          return funcref(F, args)\n      enddef\n\n      def B(F: func): func\n          return funcref(A, [F])\n      enddef\n\n      def Test(n: number)\n      enddef\n\n      const X = B(Test)\n      X(1)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # slightly different case\n  lines =<< trim END\n      vim9script\n\n      def A(F: func, ...args: list<any>): any\n          return call(F, args)\n      enddef\n\n      def B(F: func): func\n          return funcref(A, [F])\n      enddef\n\n      def Test(n: number)\n      enddef\n\n      const X = B(Test)\n      X(1)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cexpr_errmsg_line_number()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var qfl = {}\n        cexpr qfl\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E777', 2)\nenddef\n\n\" The following messes up syntax highlight, keep near the end.\nif has('python3')\n  def Test_python3_command()\n    py3 import vim\n    py3 vim.command(\"g:done = 'yes'\")\n    assert_equal('yes', g:done)\n    unlet g:done\n  enddef\n\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\n\n  def Test_lua_heredoc_fails()\n    var lines = [\n      'vim9script',\n      'def ExeLua()',\n        'lua << trim EOLUA',\n            \"x = vim.eval('g:nodict')\",\n        'EOLUA',\n      'enddef',\n      'ExeLua()',\n      ]\n    v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:nodict')\n  enddef\nendif\n\nif has('perl')\n  def Test_perl_heredoc_nested()\n    var lines =<< trim END\n        vim9script\n        def F(): string\n            def G(): string\n                perl << EOF\n        EOF\n                return 'done'\n            enddef\n            return G()\n        enddef\n        assert_equal('done', F())\n    END\n    v9.CheckScriptSuccess(lines)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\t// Not in a function scope, find variable with block ID equal to or\n\t// smaller than the current block id.  Use \"cstack\" to go up the block\n\t// scopes.\n\twhile (sav != NULL)\n\t{\n\t    int idx;\n\n\t    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\t\tif (cstack->cs_block_id[idx] == sav->sav_block_id)\n\t\t    break;\n\t    if (idx >= 0)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, variable was not visible.\n    return NULL;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx, cstack) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx, NULL) == OK\n\t    || find_imported(name, len, FALSE) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.  Or commands are being skipped, a declaration may have\n * been skipped then.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    return variable_exists(name, len, cctx);\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(\n\tchar_u\t    *p,\n\tsize_t\t    len,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack,\n\tint\t    is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx, cstack) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, FALSE) != NULL\n\t    || (ufunc = find_func_even_dead(p, 0)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If actual a constant a runtime check makes no sense.  If it's\n    // null_function it is OK.\n    if (actual_is_const && ret == MAYBE && actual == &t_func_unknown)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset,\n\t\t\t\t\t    where.wt_variable, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Reserve space for a local variable.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tisConst,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = isConst;\n    lvar->lv_type = type;\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(\n\tint\t    sid,\n\tchar_u\t    *name,\n\tint\t    check_writable,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx, cstack);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n    {\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    hashitem_T *hi;\n\n\t    // A variable exported from an autoload script is in the global\n\t    // variables, we can find it in the all_vars table.\n\t    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn HI2SAV(hi)->sav_var_vals_idx;\n\t}\n\treturn -2;\n    }\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n    static imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Find \"name\" in imported items of the current script.\n * If \"len\" is 0 use any length that works.\n * If \"load\" is TRUE and the script was not loaded yet, load it now.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, int load)\n{\n    imported_T\t    *ret;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n\n    ret = find_imported_in_script(name, len, current_sctx.sc_sid);\n    if (ret != NULL && load && (ret->imp_flags & IMP_FLAGS_AUTOLOAD))\n    {\n\tscid_T\tdummy;\n\tint\tsave_emsg_off = emsg_off;\n\n\t// \"emsg_off\" will be set when evaluating an expression silently, but\n\t// we do want to know about errors in a script.  Also because it then\n\t// aborts when an error is encountered.\n\temsg_off = FALSE;\n\n\t// script found before but not loaded yet\n\tret->imp_flags &= ~IMP_FLAGS_AUTOLOAD;\n\t(void)do_source(SCRIPT_ITEM(ret->imp_sid)->sn_name, FALSE,\n\t\t\t\t\t\t\t    DOSO_NONE, &dummy);\n\n\temsg_off = save_emsg_off;\n    }\n    return ret;\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n    eap->skip = cctx->ctx_skip == SKIP_YES;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n    lvar_T\t*lvar = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    if (*skipwhite(name_end) == '.')\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->cmd);\n\t    else\n\t\tsemsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip != SKIP_YES\n\t    && check_defined(name_start, name_end - name_start, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\treturn NULL;\n    if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_str), name_start);\n\treturn NULL;\n    }\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, lines_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    // Define the funcref before compiling, so that it is found by any\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tif (lvar != NULL)\n\t    // Now the local variable can't be used.\n\t    *lvar->lv_name = '/';  // impossible value\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    // If a FUNCREF instruction was generated, set the index after compiling.\n    if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)\n\tfuncref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Compile one Vim expression {expr} in string \"p\".\n * \"p\" points to the opening \"{\".\n * Return a pointer to the character after \"}\", NULL for an error.\n */\n    char_u *\ncompile_one_expr_in_str(char_u *p, cctx_T *cctx)\n{\n    char_u\t*block_start;\n    char_u\t*block_end;\n\n    // Skip the opening {.\n    block_start = skipwhite(p + 1);\n    block_end = block_start;\n    if (*block_start != NUL && skip_expr(&block_end, NULL) == FAIL)\n\treturn NULL;\n    block_end = skipwhite(block_end);\n    // The block must be closed by a }.\n    if (*block_end != '}')\n    {\n\tsemsg(_(e_missing_close_curly_str), p);\n\treturn NULL;\n    }\n    if (compile_expr0(&block_start, cctx) == FAIL)\n\treturn NULL;\n    may_generate_2STRING(-1, TRUE, cctx);\n\n    return block_end + 1;\n}\n\n/*\n * Compile a string \"str\" (either containing a literal string or a mix of\n * literal strings and Vim expressions of the form `{expr}`).  This is used\n * when compiling a heredoc assignment to a variable or an interpolated string\n * in a Vim9 def function.  Vim9 instructions are generated to push strings,\n * evaluate expressions, concatenate them and create a list of lines.  When\n * \"evalstr\" is TRUE, Vim expressions in \"str\" are evaluated.\n */\n    int\ncompile_all_expr_in_str(char_u *str, int evalstr, cctx_T *cctx)\n{\n    char_u\t*p = str;\n    char_u\t*val;\n    int\t\tcount = 0;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (!evalstr || *str == NUL)\n    {\n\t// Literal string, possibly empty.\n\tval = *str != NUL ? vim_strsave(str) : NULL;\n\treturn generate_PUSHS(cctx, &val);\n    }\n\n    // Push all the string pieces to the stack, followed by a ISN_CONCAT.\n    while (*p != NUL)\n    {\n\tchar_u\t*lit_start;\n\tint\tescaped_brace = FALSE;\n\n\t// Look for a block start.\n\tlit_start = p;\n\twhile (*p != '{' && *p != '}' && *p != NUL)\n\t    ++p;\n\n\tif (*p != NUL && *p == p[1])\n\t{\n\t    // Escaped brace, unescape and continue.\n\t    // Include the brace in the literal string.\n\t    ++p;\n\t    escaped_brace = TRUE;\n\t}\n\telse if (*p == '}')\n\t{\n\t    semsg(_(e_stray_closing_curly_str), str);\n\t    return FAIL;\n\t}\n\n\t// Append the literal part.\n\tif (p != lit_start)\n\t{\n\t    val = vim_strnsave(lit_start, (size_t)(p - lit_start));\n\t    if (generate_PUSHS(cctx, &val) == FAIL)\n\t\treturn FAIL;\n\t    ++count;\n\t}\n\n\tif (*p == NUL)\n\t    break;\n\n\tif (escaped_brace)\n\t{\n\t    // Skip the second brace.\n\t    ++p;\n\t    continue;\n\t}\n\n\tp = compile_one_expr_in_str(p, cctx);\n\tif (p == NULL)\n\t    return FAIL;\n\t++count;\n    }\n\n    // Small optimization, if there's only a single piece skip the ISN_CONCAT.\n    if (count > 1)\n\treturn generate_CONCAT(cctx, count);\n\n    return OK;\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tcmdidx_T\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(cmdidx_T cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t    cctx, NULL)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t    cctx, NULL)) == OK;\n\t\timported_T  *import =\n\t\t\t      find_imported(var_start, lhs->lhs_varlen, FALSE);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (script_namespace && current_script_is_vim9())\n\t\t    {\n\t\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t   cctx, NULL);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl || (lhs->lhs_has_index && !has_cmd\n\t\t\t\t\t\t&& cctx->ctx_skip != SKIP_YES))\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t    cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl && cctx->ctx_skip != SKIP_YES)\n\t{\n\t    if (has_cmd)\n\t\temsg(_(e_cannot_use_index_when_declaring_variable));\n\t    else\n\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    is_decl,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, has_cmd, oplen, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -2, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type->tt_type != VAR_SPECIAL)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"varname\" or \"[varname, varname]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n    else\n    {\n\tsp = p;\n\tp = skipwhite(p);\n\top = p;\n\toplen = assignment_len(p, &heredoc);\n\n\tif (var_count > 0 && oplen == 0)\n\t    // can be something like \"[1, 2]->func()\"\n\t    return arg;\n\n\tif (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n\t{\n\t    error_white_both(op, oplen);\n\t    return NULL;\n\t}\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE, TRUE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t    needed_list_len, (int)isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\ttype_T\t*inferred_type = NULL;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\tis_decl, heredoc, var_start > eap->cmd,\n\t\t\t\toplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t\tif (r == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_any;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlhs.lhs_lvar->lv_type = rhs_type;\n\t\t\t\tinferred_type = rhs_type;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t\t\tcctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tint r = OK;\n\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tr = generate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t\tr = generate_PUSHF(cctx, 0.0);\n#endif\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tr = generate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tr = generate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tr = generate_PUSHFUNC(cctx, NULL, &t_func_void);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tr = generate_NEWLIST(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tr = generate_NEWDICT(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tr = generate_PUSHJOB(cctx);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tr = generate_PUSHCHANNEL(cctx);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are always\n\t\t\t// initialized to zero.  But in a \"for\" or \"while\" loop\n\t\t\t// the value may have been changed.\n\t\t\tif (lhs.lhs_dest == dest_local\n\t\t\t\t\t\t   && !inside_loop_scope(cctx))\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    instr_count = instr->ga_len;\n\t\t\t    r = generate_PUSHNR(cctx, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (r == FAIL)\n\t\t    goto theend;\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = get_type_on_stack(cctx, 0);\n\t\tif (\n#ifdef FEAT_FLOAT\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n#endif\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_CONCAT(cctx, 2) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if ((lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && lhs.lhs_type->tt_member != &t_any\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\t    else if (inferred_type != NULL\n\t\t    && (inferred_type->tt_type == VAR_DICT\n\t\t\t\t\t|| inferred_type->tt_type == VAR_LIST)\n\t\t    && inferred_type->tt_member != NULL\n\t\t    && inferred_type->tt_member != &t_unknown\n\t\t    && inferred_type->tt_member != &t_any)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, inferred_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    // \"g:var = expr\"\n\t    // \"g:[key] = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// might be \"[var, var] = expr\"\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n/*\n * Check if arguments of \"ufunc\" shadow variables in \"cctx\".\n * Return OK or FAIL.\n */\n    static int\ncheck_args_shadowing(ufunc_T *ufunc, cctx_T *cctx)\n{\n    int\t    i;\n    char_u  *arg;\n    int\t    r = OK;\n\n    // Make sure arguments are not found when compiling a second time.\n    ufunc->uf_args_visible = 0;\n\n    // Check for arguments shadowing variables from the context.\n    for (i = 0; i < ufunc->uf_args.ga_len; ++i)\n    {\n\targ = ((char_u **)(ufunc->uf_args.ga_data))[i];\n\tif (check_defined(arg, STRLEN(arg), cctx, NULL, TRUE) == FAIL)\n\t{\n\t    r = FAIL;\n\t    break;\n\t}\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n    return r;\n}\n\n/*\n * Get the compilation type that should be used for \"ufunc\".\n * Keep in sync with INSTRUCTIONS().\n */\n    compiletype_T\nget_compile_type(ufunc_T *ufunc)\n{\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    if (debug_break_level > 0 || may_break_in_function(ufunc))\n\treturn CT_DEBUG;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tif (!ufunc->uf_profiling && has_profiling(FALSE, ufunc->uf_name, NULL))\n\t    func_do_profile(ufunc);\n\tif (ufunc->uf_profiling)\n\t    return CT_PROFILE;\n    }\n#endif\n    return CT_NONE;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    garray_T\tlines_to_free;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // allocated lines are freed at the end\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    if ((ufunc->uf_flags & FC_CLOSURE) && outer_cctx == NULL)\n    {\n\tsemsg(_(e_compiling_closure_without_context_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\tea.skip = cctx.ctx_skip == SKIP_YES;\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment, but \"#{\" is an error\n\t    if (vim9_bad_comment(ea.cmd))\n\t\tgoto erret;\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    goto erret;\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * 0z1234->func() should not be confused with a zero line number\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t * \"123->func()\" is a method call\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon\n\t\t    || !(*cmd == '\\''\n\t\t\t|| (cmd[0] == '0' && cmd[1] == 'z')\n\t\t\t|| (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-'))\n\t\t\t|| number_method(cmd))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\tsemsg(_(e_ambiguous_use_of_user_defined_command_str), ea.cmd);\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    // \"eval\" is used for \"val->func()\" and \"var\" for \"var = val\", then\n\t    // \"p\" is equal to \"ea.cmd\" for a valid command.\n\t    if (ea.cmdidx == CMD_eval || ea.cmdidx == CMD_var)\n\t\t;\n\t    else if (cctx.ctx_skip == SKIP_YES)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t    if ((ea.argt & EX_RANGE) == 0 && ea.addr_count > 0)\n\t    {\n\t\temsg(_(e_no_range_allowed));\n\t\tgoto erret;\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t    {\n\t\t\temsg(_(e_invalid_assignment));\n\t\t\tline = NULL;\n\t\t    }\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_vim9script:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\temsg(_(e_vim9script_can_only_be_used_in_script));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    ga_clear_strings(&lines_to_free);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n"], "filenames": ["src/testdir/test_vim9_func.vim", "src/version.c", "src/vim9compile.c"], "buggy_code_start_loc": [911, 737, 832], "buggy_code_end_loc": [911, 737, 959], "fixing_code_start_loc": [912, 738, 833], "fixing_code_end_loc": [924, 740, 963], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0221.", "other": {"cve": {"id": "CVE-2022-2862", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-17T20:15:07.693", "lastModified": "2023-05-03T12:16:05.370", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0221."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 9.0.0221."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0221", "matchCriteriaId": "B4143A9C-F268-4A8F-8625-EED34024300F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/1889f499a4f248cd84e0e0bf6d0d820016774494", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/71180988-1ab6-4311-bca8-e9a879b06765", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/1889f499a4f248cd84e0e0bf6d0d820016774494"}}